<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt.geom">
        <import package="java.awt.Shape"/>
        <import package="java.beans.ConstructorProperties"/>
        <class name="AffineTransform" line="4">
            <implements interface="Cloneable"/>
            <implements interface="java.io.Serializable"/>
            <javadoc line="4">
                The &lt;code&gt;AffineTransform&lt;/code&gt; class represents a 2D affine transform
                  that performs a linear mapping from 2D coordinates to other 2D
                  coordinates that preserves the &quot;straightness&quot; and
                  &quot;parallelness&quot; of lines.  Affine transformations can be constructed
                  using sequences of translations, scales, flips, rotations, and shears.
                  &lt;p&gt;
                  Such a coordinate transformation can be represented by a 3 row by
                  3 column matrix with an implied last row of [ 0 0 1 ].  This matrix
                  transforms source coordinates {@code (x,y)} into
                  destination coordinates {@code (x&apos;,y&apos;)} by considering
                  them to be a column vector and multiplying the coordinate vector
                  by the matrix according to the following process:
                  &lt;pre&gt;
                  [ x&apos;]   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
                  [ y&apos;] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
                  [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
                  &lt;/pre&gt;
                  &lt;p&gt;
                  &lt;a name=&quot;quadrantapproximation&quot;&gt;&lt;h4&gt;Handling 90-Degree Rotations&lt;/h4&gt;&lt;/a&gt;
                  &lt;p&gt;
                  In some variations of the &lt;code&gt;rotate&lt;/code&gt; methods in the
                  &lt;code&gt;AffineTransform&lt;/code&gt; class, a double-precision argument
                  specifies the angle of rotation in radians.
                  These methods have special handling for rotations of approximately
                  90 degrees (including multiples such as 180, 270, and 360 degrees),
                  so that the common case of quadrant rotation is handled more
                  efficiently.
                  This special handling can cause angles very close to multiples of
                  90 degrees to be treated as if they were exact multiples of
                  90 degrees.
                  For small multiples of 90 degrees the range of angles treated
                  as a quadrant rotation is approximately 0.00000121 degrees wide.
                  This section explains why such special care is needed and how
                  it is implemented.
                  &lt;p&gt;
                  Since 90 degrees is represented as &lt;code&gt;PI/2&lt;/code&gt; in radians,
                  and since PI is a transcendental (and therefore irrational) number,
                  it is not possible to exactly represent a multiple of 90 degrees as
                  an exact double precision value measured in radians.
                  As a result it is theoretically impossible to describe quadrant
                  rotations (90, 180, 270 or 360 degrees) using these values.
                  Double precision floating point values can get very close to
                  non-zero multiples of &lt;code&gt;PI/2&lt;/code&gt; but never close enough
                  for the sine or cosine to be exactly 0.0, 1.0 or -1.0.
                  The implementations of &lt;code&gt;Math.sin()&lt;/code&gt; and
                  &lt;code&gt;Math.cos()&lt;/code&gt; correspondingly never return 0.0
                  for any case other than &lt;code&gt;Math.sin(0.0)&lt;/code&gt;.
                  These same implementations do, however, return exactly 1.0 and
                  -1.0 for some range of numbers around each multiple of 90
                  degrees since the correct answer is so close to 1.0 or -1.0 that
                  the double precision significand cannot represent the difference
                  as accurately as it can for numbers that are near 0.0.
                  &lt;p&gt;
                  The net result of these issues is that if the
                  &lt;code&gt;Math.sin()&lt;/code&gt; and &lt;code&gt;Math.cos()&lt;/code&gt; methods
                  are used to directly generate the values for the matrix modifications
                  during these radian-based rotation operations then the resulting
                  transform is never strictly classifiable as a quadrant rotation
                  even for a simple case like &lt;code&gt;rotate(Math.PI/2.0)&lt;/code&gt;,
                  due to minor variations in the matrix caused by the non-0.0 values
                  obtained for the sine and cosine.
                  If these transforms are not classified as quadrant rotations then
                  subsequent code which attempts to optimize further operations based
                  upon the type of the transform will be relegated to its most general
                  implementation.
                  &lt;p&gt;
                  Because quadrant rotations are fairly common,
                  this class should handle these cases reasonably quickly, both in
                  applying the rotations to the transform and in applying the resulting
                  transform to the coordinates.
                  To facilitate this optimal handling, the methods which take an angle
                  of rotation measured in radians attempt to detect angles that are
                  intended to be quadrant rotations and treat them as such.
                  These methods therefore treat an angle &lt;em&gt;theta&lt;/em&gt; as a quadrant
                  rotation if either &lt;code&gt;Math.sin(&lt;em&gt;theta&lt;/em&gt;)&lt;/code&gt; or
                  &lt;code&gt;Math.cos(&lt;em&gt;theta&lt;/em&gt;)&lt;/code&gt; returns exactly 1.0 or -1.0.
                  As a rule of thumb, this property holds true for a range of
                  approximately 0.0000000211 radians (or 0.00000121 degrees) around
                  small multiples of &lt;code&gt;Math.PI/2.0&lt;/code&gt;.                
                <author>
                    Jim Graham                    
                </author>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_UNKNOWN" type="int" line="88"/>
            <declaration name="TYPE_IDENTITY" type="int" line="89"/>
            <javadoc line="89">
                This constant indicates that the transform defined by this object
                  is an identity transform.
                  An identity transform is one in which the output coordinates are
                  always the same as the input coordinates.
                  If this transform is anything other than the identity transform,
                  the type will either be the constant GENERAL_TRANSFORM or a
                  combination of the appropriate flag bits for the various coordinate
                  conversions that this transform performs.                
                <see>
                    #TYPE_TRANSLATION                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <see>
                    #TYPE_FLIP                    
                </see>
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_TRANSFORM                    
                </see>
                <see>
                    #getType                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_TRANSLATION" type="int" line="109"/>
            <javadoc line="109">
                This flag bit indicates that the transform defined by this object
                  performs a translation in addition to the conversions indicated
                  by other flag bits.
                  A translation moves the coordinates by a constant amount in x
                  and y without changing the length or angle of vectors.                
                <see>
                    #TYPE_IDENTITY                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <see>
                    #TYPE_FLIP                    
                </see>
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_TRANSFORM                    
                </see>
                <see>
                    #getType                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_UNIFORM_SCALE" type="int" line="126"/>
            <javadoc line="126">
                This flag bit indicates that the transform defined by this object
                  performs a uniform scale in addition to the conversions indicated
                  by other flag bits.
                  A uniform scale multiplies the length of vectors by the same amount
                  in both the x and y directions without changing the angle between
                  vectors.
                  This flag bit is mutually exclusive with the TYPE_GENERAL_SCALE flag.                
                <see>
                    #TYPE_IDENTITY                    
                </see>
                <see>
                    #TYPE_TRANSLATION                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <see>
                    #TYPE_FLIP                    
                </see>
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_TRANSFORM                    
                </see>
                <see>
                    #getType                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_GENERAL_SCALE" type="int" line="145"/>
            <javadoc line="145">
                This flag bit indicates that the transform defined by this object
                  performs a general scale in addition to the conversions indicated
                  by other flag bits.
                  A general scale multiplies the length of vectors by different
                  amounts in the x and y directions without changing the angle
                  between perpendicular vectors.
                  This flag bit is mutually exclusive with the TYPE_UNIFORM_SCALE flag.                
                <see>
                    #TYPE_IDENTITY                    
                </see>
                <see>
                    #TYPE_TRANSLATION                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_FLIP                    
                </see>
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_TRANSFORM                    
                </see>
                <see>
                    #getType                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_MASK_SCALE" type="int" line="164"/>
            <javadoc line="164">
                This constant is a bit mask for any of the scale flag bits.                
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_FLIP" type="int" line="171"/>
            <javadoc line="171">
                This flag bit indicates that the transform defined by this object
                  performs a mirror image flip about some axis which changes the
                  normally right handed coordinate system into a left handed
                  system in addition to the conversions indicated by other flag bits.
                  A right handed coordinate system is one where the positive X
                  axis rotates counterclockwise to overlay the positive Y axis
                  similar to the direction that the fingers on your right hand
                  curl when you stare end on at your thumb.
                  A left handed coordinate system is one where the positive X
                  axis rotates clockwise to overlay the positive Y axis similar
                  to the direction that the fingers on your left hand curl.
                  There is no mathematical way to determine the angle of the
                  original flipping or mirroring transformation since all angles
                  of flip are identical given an appropriate adjusting rotation.                
                <see>
                    #TYPE_IDENTITY                    
                </see>
                <see>
                    #TYPE_TRANSLATION                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_TRANSFORM                    
                </see>
                <see>
                    #getType                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_QUADRANT_ROTATION" type="int" line="197"/>
            <javadoc line="197">
                This flag bit indicates that the transform defined by this object
                  performs a quadrant rotation by some multiple of 90 degrees in
                  addition to the conversions indicated by other flag bits.
                  A rotation changes the angles of vectors by the same amount
                  regardless of the original direction of the vector and without
                  changing the length of the vector.
                  This flag bit is mutually exclusive with the TYPE_GENERAL_ROTATION flag.                
                <see>
                    #TYPE_IDENTITY                    
                </see>
                <see>
                    #TYPE_TRANSLATION                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <see>
                    #TYPE_FLIP                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_TRANSFORM                    
                </see>
                <see>
                    #getType                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_GENERAL_ROTATION" type="int" line="216"/>
            <javadoc line="216">
                This flag bit indicates that the transform defined by this object
                  performs a rotation by an arbitrary angle in addition to the
                  conversions indicated by other flag bits.
                  A rotation changes the angles of vectors by the same amount
                  regardless of the original direction of the vector and without
                  changing the length of the vector.
                  This flag bit is mutually exclusive with the
                  TYPE_QUADRANT_ROTATION flag.                
                <see>
                    #TYPE_IDENTITY                    
                </see>
                <see>
                    #TYPE_TRANSLATION                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <see>
                    #TYPE_FLIP                    
                </see>
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_TRANSFORM                    
                </see>
                <see>
                    #getType                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_MASK_ROTATION" type="int" line="236"/>
            <javadoc line="236">
                This constant is a bit mask for any of the rotation flag bits.                
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TYPE_GENERAL_TRANSFORM" type="int" line="243"/>
            <javadoc line="243">
                This constant indicates that the transform defined by this object
                  performs an arbitrary conversion of the input coordinates.
                  If this transform can be classified by any of the above constants,
                  the type will either be the constant TYPE_IDENTITY or a
                  combination of the appropriate flag bits for the various coordinate
                  conversions that this transform performs.                
                <see>
                    #TYPE_IDENTITY                    
                </see>
                <see>
                    #TYPE_TRANSLATION                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <see>
                    #TYPE_FLIP                    
                </see>
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <see>
                    #getType                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="APPLY_IDENTITY" type="int" line="261"/>
            <javadoc line="261">
                This constant is used for the internal state variable to indicate
                  that no calculations need to be performed and that the source
                  coordinates only need to be copied to their destinations to
                  complete the transformation equation of this transform.                
                <see>
                    #APPLY_TRANSLATE                    
                </see>
                <see>
                    #APPLY_SCALE                    
                </see>
                <see>
                    #APPLY_SHEAR                    
                </see>
                <see>
                    #state                    
                </see>
            </javadoc>
            <declaration name="APPLY_TRANSLATE" type="int" line="272"/>
            <javadoc line="272">
                This constant is used for the internal state variable to indicate
                  that the translation components of the matrix (m02 and m12) need
                  to be added to complete the transformation equation of this transform.                
                <see>
                    #APPLY_IDENTITY                    
                </see>
                <see>
                    #APPLY_SCALE                    
                </see>
                <see>
                    #APPLY_SHEAR                    
                </see>
                <see>
                    #state                    
                </see>
            </javadoc>
            <declaration name="APPLY_SCALE" type="int" line="282"/>
            <javadoc line="282">
                This constant is used for the internal state variable to indicate
                  that the scaling components of the matrix (m00 and m11) need
                  to be factored in to complete the transformation equation of
                  this transform.  If the APPLY_SHEAR bit is also set then it
                  indicates that the scaling components are not both 0.0.  If the
                  APPLY_SHEAR bit is not also set then it indicates that the
                  scaling components are not both 1.0.  If neither the APPLY_SHEAR
                  nor the APPLY_SCALE bits are set then the scaling components
                  are both 1.0, which means that the x and y components contribute
                  to the transformed coordinate, but they are not multiplied by
                  any scaling factor.                
                <see>
                    #APPLY_IDENTITY                    
                </see>
                <see>
                    #APPLY_TRANSLATE                    
                </see>
                <see>
                    #APPLY_SHEAR                    
                </see>
                <see>
                    #state                    
                </see>
            </javadoc>
            <declaration name="APPLY_SHEAR" type="int" line="300"/>
            <javadoc line="300">
                This constant is used for the internal state variable to indicate
                  that the shearing components of the matrix (m01 and m10) need
                  to be factored in to complete the transformation equation of this
                  transform.  The presence of this bit in the state variable changes
                  the interpretation of the APPLY_SCALE bit as indicated in its
                  documentation.                
                <see>
                    #APPLY_IDENTITY                    
                </see>
                <see>
                    #APPLY_TRANSLATE                    
                </see>
                <see>
                    #APPLY_SCALE                    
                </see>
                <see>
                    #state                    
                </see>
            </javadoc>
            <declaration name="HI_SHIFT" type="int" line="313"/>
            <declaration name="HI_IDENTITY" type="int" line="314"/>
            <declaration name="HI_TRANSLATE" type="int" line="315"/>
            <declaration name="HI_SCALE" type="int" line="316"/>
            <declaration name="HI_SHEAR" type="int" line="317"/>
            <declaration name="m00" type="double" line="318"/>
            <javadoc line="318">
                The X coordinate scaling element of the 3x3
                  affine transformation matrix.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="m10" type="double" line="324"/>
            <javadoc line="324">
                The Y coordinate shearing element of the 3x3
                  affine transformation matrix.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="m01" type="double" line="330"/>
            <javadoc line="330">
                The X coordinate shearing element of the 3x3
                  affine transformation matrix.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="m11" type="double" line="336"/>
            <javadoc line="336">
                The Y coordinate scaling element of the 3x3
                  affine transformation matrix.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="m02" type="double" line="342"/>
            <javadoc line="342">
                The X coordinate of the translation element of the
                  3x3 affine transformation matrix.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="m12" type="double" line="348"/>
            <javadoc line="348">
                The Y coordinate of the translation element of the
                  3x3 affine transformation matrix.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="state" type="int" line="354"/>
            <javadoc line="354">
                This field keeps track of which components of the matrix need to
                  be applied when performing a transformation.                
                <see>
                    #APPLY_IDENTITY                    
                </see>
                <see>
                    #APPLY_TRANSLATE                    
                </see>
                <see>
                    #APPLY_SCALE                    
                </see>
                <see>
                    #APPLY_SHEAR                    
                </see>
            </javadoc>
            <declaration name="type" type="int" line="363"/>
            <javadoc line="363">
                This field caches the current transformation type of the matrix.                
                <see>
                    #TYPE_IDENTITY                    
                </see>
                <see>
                    #TYPE_TRANSLATION                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <see>
                    #TYPE_FLIP                    
                </see>
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_TRANSFORM                    
                </see>
                <see>
                    #TYPE_UNKNOWN                    
                </see>
                <see>
                    #getType                    
                </see>
            </javadoc>
            <method name="AffineTransform" type="constructor" line="377">
                <params>
                    <param name="m00" type="double"/>
                    <param name="m10" type="double"/>
                    <param name="m01" type="double"/>
                    <param name="m11" type="double"/>
                    <param name="m02" type="double"/>
                    <param name="m12" type="double"/>
                    <param name="state" type="int"/>
                </params>
            </method>
            <javadoc line="387">
                Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; representing the
                  Identity transformation.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="AffineTransform" type="constructor" line="392"/>
            <javadoc line="395">
                Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; that is a copy of
                  the specified &lt;code&gt;AffineTransform&lt;/code&gt; object.                
                <param>
                    Tx the <code>AffineTransform</code> object to copy                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="AffineTransform" type="constructor" line="401">
                <params>
                    <param name="Tx" type="AffineTransform"/>
                </params>
            </method>
            <javadoc line="411">
                Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; from 6 floating point
                  values representing the 6 specifiable entries of the 3x3
                  transformation matrix.                
                <param>
                    m00 the X coordinate scaling element of the 3x3 matrix                    
                </param>
                <param>
                    m10 the Y coordinate shearing element of the 3x3 matrix                    
                </param>
                <param>
                    m01 the X coordinate shearing element of the 3x3 matrix                    
                </param>
                <param>
                    m11 the Y coordinate scaling element of the 3x3 matrix                    
                </param>
                <param>
                    m02 the X coordinate translation element of the 3x3 matrix                    
                </param>
                <param>
                    m12 the Y coordinate translation element of the 3x3 matrix                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="AffineTransform" type="constructor" line="423">
                <params>
                    <param name="m00" type="float"/>
                    <param name="m10" type="float"/>
                    <param name="m01" type="float"/>
                    <param name="m11" type="float"/>
                    <param name="m02" type="float"/>
                    <param name="m12" type="float"/>
                </params>
            </method>
            <javadoc line="432">
                Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; from an array of
                  floating point values representing either the 4 non-translation
                  enries or the 6 specifiable entries of the 3x3 transformation
                  matrix.  The values are retrieved from the array as
                  {&amp;nbsp;m00&amp;nbsp;m10&amp;nbsp;m01&amp;nbsp;m11&amp;nbsp;[m02&amp;nbsp;m12]}.                
                <param>
                    flatmatrix the float array containing the values to be set
                      in the new <code>AffineTransform</code> object. The length of the
                      array is assumed to be at least 4. If the length of the array is
                      less than 6, only the first 4 values are taken. If the length of
                      the array is greater than 6, the first 6 values are taken.                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="AffineTransform" type="constructor" line="445">
                <params>
                    <param name="flatmatrix" type="float[]"/>
                </params>
                <scope line="450"/>
            </method>
            <javadoc line="456">
                Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; from 6 double
                  precision values representing the 6 specifiable entries of the 3x3
                  transformation matrix.                
                <param>
                    m00 the X coordinate scaling element of the 3x3 matrix                    
                </param>
                <param>
                    m10 the Y coordinate shearing element of the 3x3 matrix                    
                </param>
                <param>
                    m01 the X coordinate shearing element of the 3x3 matrix                    
                </param>
                <param>
                    m11 the Y coordinate scaling element of the 3x3 matrix                    
                </param>
                <param>
                    m02 the X coordinate translation element of the 3x3 matrix                    
                </param>
                <param>
                    m12 the Y coordinate translation element of the 3x3 matrix                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="AffineTransform" type="constructor" line="468">
                <params>
                    <param name="m00" type="double"/>
                    <param name="m10" type="double"/>
                    <param name="m01" type="double"/>
                    <param name="m11" type="double"/>
                    <param name="m02" type="double"/>
                    <param name="m12" type="double"/>
                </params>
            </method>
            <javadoc line="477">
                Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; from an array of
                  double precision values representing either the 4 non-translation
                  entries or the 6 specifiable entries of the 3x3 transformation
                  matrix. The values are retrieved from the array as
                  {&amp;nbsp;m00&amp;nbsp;m10&amp;nbsp;m01&amp;nbsp;m11&amp;nbsp;[m02&amp;nbsp;m12]}.                
                <param>
                    flatmatrix the double array containing the values to be set
                      in the new <code>AffineTransform</code> object. The length of the
                      array is assumed to be at least 4. If the length of the array is
                      less than 6, only the first 4 values are taken. If the length of
                      the array is greater than 6, the first 6 values are taken.                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="AffineTransform" type="constructor" line="490">
                <params>
                    <param name="flatmatrix" type="double[]"/>
                </params>
                <scope line="495"/>
            </method>
            <javadoc line="501">
                Returns a transform representing a translation transformation.
                  The matrix representing the returned transform is:
                  &lt;pre&gt;
                  [   1    0    tx  ]
                  [   0    1    ty  ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    tx the distance by which coordinates are translated in the
                      X axis direction                    
                </param>
                <param>
                    ty the distance by which coordinates are translated in the
                      Y axis direction                    
                </param>
                <return>
                    an <code>AffineTransform</code> object that represents a
                      translation transformation, created with the specified vector.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getTranslateInstance" type="AffineTransform" line="517">
                <params>
                    <param name="tx" type="double"/>
                    <param name="ty" type="double"/>
                </params>
                <declaration name="Tx" type="AffineTransform" line="518"/>
            </method>
            <javadoc line="522">
                Returns a transform representing a rotation transformation.
                  The matrix representing the returned transform is:
                  &lt;pre&gt;
                  [   cos(theta)    -sin(theta)    0   ]
                  [   sin(theta)     cos(theta)    0   ]
                  [       0              0         1   ]
                  &lt;/pre&gt;
                  Rotating by a positive angle theta rotates points on the positive
                  X axis toward the positive Y axis.
                  Note also the discussion of
                  &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
                  above.                
                <param>
                    theta the angle of rotation measured in radians                    
                </param>
                <return>
                    an <code>AffineTransform</code> object that is a rotation
                      transformation, created with the specified angle of rotation.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getRotateInstance" type="AffineTransform" line="540">
                <params>
                    <param name="theta" type="double"/>
                </params>
                <declaration name="Tx" type="AffineTransform" line="541"/>
            </method>
            <javadoc line="545">
                Returns a transform that rotates coordinates around an anchor point.
                  This operation is equivalent to translating the coordinates so
                  that the anchor point is at the origin (S1), then rotating them
                  about the new origin (S2), and finally translating so that the
                  intermediate origin is restored to the coordinates of the original
                  anchor point (S3).
                  &lt;p&gt;
                  This operation is equivalent to the following sequence of calls:
                  &lt;pre&gt;
                  AffineTransform Tx = new AffineTransform();
                  Tx.translate(anchorx, anchory);    // S3: final translation
                  Tx.rotate(theta);                  // S2: rotate around anchor
                  Tx.translate(-anchorx, -anchory);  // S1: translate anchor to origin
                  &lt;/pre&gt;
                  The matrix representing the returned transform is:
                  &lt;pre&gt;
                  [   cos(theta)    -sin(theta)    x-xcos+ysin  ]
                  [   sin(theta)     cos(theta)    y-xsin-ycos  ]
                  [       0              0               1        ]
                  &lt;/pre&gt;
                  Rotating by a positive angle theta rotates points on the positive
                  X axis toward the positive Y axis.
                  Note also the discussion of
                  &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
                  above.                
                <param>
                    theta the angle of rotation measured in radians                    
                </param>
                <param>
                    anchorx the X coordinate of the rotation anchor point                    
                </param>
                <param>
                    anchory the Y coordinate of the rotation anchor point                    
                </param>
                <return>
                    an <code>AffineTransform</code> object that rotates
                      coordinates around the specified point by the specified angle of
                      rotation.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getRotateInstance" type="AffineTransform" line="579">
                <params>
                    <param name="theta" type="double"/>
                    <param name="anchorx" type="double"/>
                    <param name="anchory" type="double"/>
                </params>
                <declaration name="Tx" type="AffineTransform" line="580"/>
            </method>
            <javadoc line="584">
                Returns a transform that rotates coordinates according to
                  a rotation vector.
                  All coordinates rotate about the origin by the same amount.
                  The amount of rotation is such that coordinates along the former
                  positive X axis will subsequently align with the vector pointing
                  from the origin to the specified vector coordinates.
                  If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
                  an identity transform is returned.
                  This operation is equivalent to calling:
                  &lt;pre&gt;
                  AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));
                  &lt;/pre&gt;                
                <param>
                    vecx the X coordinate of the rotation vector                    
                </param>
                <param>
                    vecy the Y coordinate of the rotation vector                    
                </param>
                <return>
                    an <code>AffineTransform</code> object that rotates
                      coordinates according to the specified rotation vector.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getRotateInstance" type="AffineTransform" line="603">
                <params>
                    <param name="vecx" type="double"/>
                    <param name="vecy" type="double"/>
                </params>
                <declaration name="Tx" type="AffineTransform" line="604"/>
            </method>
            <javadoc line="608">
                Returns a transform that rotates coordinates around an anchor
                  point accordinate to a rotation vector.
                  All coordinates rotate about the specified anchor coordinates
                  by the same amount.
                  The amount of rotation is such that coordinates along the former
                  positive X axis will subsequently align with the vector pointing
                  from the origin to the specified vector coordinates.
                  If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
                  an identity transform is returned.
                  This operation is equivalent to calling:
                  &lt;pre&gt;
                  AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),
                  anchorx, anchory);
                  &lt;/pre&gt;                
                <param>
                    vecx the X coordinate of the rotation vector                    
                </param>
                <param>
                    vecy the Y coordinate of the rotation vector                    
                </param>
                <param>
                    anchorx the X coordinate of the rotation anchor point                    
                </param>
                <param>
                    anchory the Y coordinate of the rotation anchor point                    
                </param>
                <return>
                    an <code>AffineTransform</code> object that rotates
                      coordinates around the specified point according to the
                      specified rotation vector.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getRotateInstance" type="AffineTransform" line="632">
                <params>
                    <param name="vecx" type="double"/>
                    <param name="vecy" type="double"/>
                    <param name="anchorx" type="double"/>
                    <param name="anchory" type="double"/>
                </params>
                <declaration name="Tx" type="AffineTransform" line="633"/>
            </method>
            <javadoc line="637">
                Returns a transform that rotates coordinates by the specified
                  number of quadrants.
                  This operation is equivalent to calling:
                  &lt;pre&gt;
                  AffineTransform.getRotateInstance(numquadrants  Math.PI / 2.0);
                  &lt;/pre&gt;
                  Rotating by a positive number of quadrants rotates points on
                  the positive X axis toward the positive Y axis.                
                <param>
                    numquadrants the number of 90 degree arcs to rotate by                    
                </param>
                <return>
                    an <code>AffineTransform</code> object that rotates
                      coordinates by the specified number of quadrants.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getQuadrantRotateInstance" type="AffineTransform" line="651">
                <params>
                    <param name="numquadrants" type="int"/>
                </params>
                <declaration name="Tx" type="AffineTransform" line="652"/>
            </method>
            <javadoc line="656">
                Returns a transform that rotates coordinates by the specified
                  number of quadrants around the specified anchor point.
                  This operation is equivalent to calling:
                  &lt;pre&gt;
                  AffineTransform.getRotateInstance(numquadrants  Math.PI / 2.0,
                  anchorx, anchory);
                  &lt;/pre&gt;
                  Rotating by a positive number of quadrants rotates points on
                  the positive X axis toward the positive Y axis.                
                <param>
                    numquadrants the number of 90 degree arcs to rotate by                    
                </param>
                <param>
                    anchorx the X coordinate of the rotation anchor point                    
                </param>
                <param>
                    anchory the Y coordinate of the rotation anchor point                    
                </param>
                <return>
                    an <code>AffineTransform</code> object that rotates
                      coordinates by the specified number of quadrants around the
                      specified anchor point.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getQuadrantRotateInstance" type="AffineTransform" line="674">
                <params>
                    <param name="numquadrants" type="int"/>
                    <param name="anchorx" type="double"/>
                    <param name="anchory" type="double"/>
                </params>
                <declaration name="Tx" type="AffineTransform" line="675"/>
            </method>
            <javadoc line="679">
                Returns a transform representing a scaling transformation.
                  The matrix representing the returned transform is:
                  &lt;pre&gt;
                  [   sx   0    0   ]
                  [   0    sy   0   ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    sx the factor by which coordinates are scaled along the
                      X axis direction                    
                </param>
                <param>
                    sy the factor by which coordinates are scaled along the
                      Y axis direction                    
                </param>
                <return>
                    an <code>AffineTransform</code> object that scales
                      coordinates by the specified factors.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getScaleInstance" type="AffineTransform" line="695">
                <params>
                    <param name="sx" type="double"/>
                    <param name="sy" type="double"/>
                </params>
                <declaration name="Tx" type="AffineTransform" line="696"/>
            </method>
            <javadoc line="700">
                Returns a transform representing a shearing transformation.
                  The matrix representing the returned transform is:
                  &lt;pre&gt;
                  [   1   shx   0   ]
                  [  shy   1    0   ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    shx the multiplier by which coordinates are shifted in the
                      direction of the positive X axis as a factor of their Y coordinate                    
                </param>
                <param>
                    shy the multiplier by which coordinates are shifted in the
                      direction of the positive Y axis as a factor of their X coordinate                    
                </param>
                <return>
                    an <code>AffineTransform</code> object that shears
                      coordinates by the specified multipliers.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getShearInstance" type="AffineTransform" line="716">
                <params>
                    <param name="shx" type="double"/>
                    <param name="shy" type="double"/>
                </params>
                <declaration name="Tx" type="AffineTransform" line="717"/>
            </method>
            <javadoc line="721">
                Retrieves the flag bits describing the conversion properties of
                  this transform.
                  The return value is either one of the constants TYPE_IDENTITY
                  or TYPE_GENERAL_TRANSFORM, or a combination of the
                  appriopriate flag bits.
                  A valid combination of flag bits is an exclusive OR operation
                  that can combine
                  the TYPE_TRANSLATION flag bit
                  in addition to either of the
                  TYPE_UNIFORM_SCALE or TYPE_GENERAL_SCALE flag bits
                  as well as either of the
                  TYPE_QUADRANT_ROTATION or TYPE_GENERAL_ROTATION flag bits.                
                <return>
                    the OR combination of any of the indicated flags that
                      apply to this transform                    
                </return>
                <see>
                    #TYPE_IDENTITY                    
                </see>
                <see>
                    #TYPE_TRANSLATION                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <see>
                    #TYPE_GENERAL_SCALE                    
                </see>
                <see>
                    #TYPE_QUADRANT_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_ROTATION                    
                </see>
                <see>
                    #TYPE_GENERAL_TRANSFORM                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getType" type="int" line="745">
                <scope line="746"/>
            </method>
            <javadoc line="751">
                This is the utility function to calculate the flag bits when
                  they have not been cached.                
                <see>
                    #getType                    
                </see>
            </javadoc>
            <method name="calculateType" type="void" line="756">
                <declaration name="ret" type="int" line="757"/>
                <declaration name="sgn0" type="boolean" line="758"/>
                <declaration name="M0" type="double" line="759"/>
                <scope line="767"/>
                <scope line="773">
                    <scope line="774"/>
                    <scope line="777"/>
                    <scope line="780"/>
                </scope>
                <scope line="784">
                    <scope line="785"/>
                    <scope line="788"/>
                    <scope line="791"/>
                </scope>
                <scope line="801">
                    <scope line="802"/>
                    <scope line="805"/>
                    <scope line="808"/>
                </scope>
                <scope line="812">
                    <scope line="813"/>
                    <scope line="816"/>
                </scope>
                <scope line="826">
                    <scope line="827">
                        <scope line="828"/>
                        <scope line="831"/>
                    </scope>
                    <scope line="835">
                        <scope line="836"/>
                        <scope line="839"/>
                        <scope line="842"/>
                    </scope>
                </scope>
                <scope line="847">
                    <scope line="848">
                        <scope line="849"/>
                        <scope line="852"/>
                    </scope>
                    <scope line="856"/>
                </scope>
            </method>
            <javadoc line="869">
                Returns the determinant of the matrix representation of the transform.
                  The determinant is useful both to determine if the transform can
                  be inverted and to get a single value representing the
                  combined X and Y scaling of the transform.
                  &lt;p&gt;
                  If the determinant is non-zero, then this transform is
                  invertible and the various methods that depend on the inverse
                  transform do not need to throw a{@link NoninvertibleTransformException}.
                  If the determinant is zero then this transform can not be
                  inverted since the transform maps all input coordinates onto
                  a line or a point.
                  If the determinant is near enough to zero then inverse transform
                  operations might not carry enough precision to produce meaningful
                  results.
                  &lt;p&gt;
                  If this transform represents a uniform scale, as indicated by
                  the &lt;code&gt;getType&lt;/code&gt; method then the determinant also
                  represents the square of the uniform scale factor by which all of
                  the points are expanded from or contracted towards the origin.
                  If this transform represents a non-uniform scale or more general
                  transform then the determinant is not likely to represent a
                  value useful for any purpose other than determining if inverse
                  transforms are possible.
                  &lt;p&gt;
                  Mathematically, the determinant is calculated using the formula:
                  &lt;pre&gt;
                  |  m00  m01  m02  |
                  |  m10  m11  m12  |  =  m00  m11 - m01  m10
                  |   0    0    1   |
                  &lt;/pre&gt;                
                <return>
                    the determinant of the matrix used to transform the
                      coordinates.                    
                </return>
                <see>
                    #getType                    
                </see>
                <see>
                    #createInverse                    
                </see>
                <see>
                    #inverseTransform                    
                </see>
                <see>
                    #TYPE_UNIFORM_SCALE                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getDeterminant" type="double" line="908"/>
            <javadoc line="926">
                Manually recalculates the state of the transform when the matrix
                  changes too much to predict the effects on the state.
                  The following table specifies what the various settings of the
                  state field say about the values of the corresponding matrix
                  element fields.
                  Note that the rules governing the SCALE fields are slightly
                  different depending on whether the SHEAR flag is also set.
                  &lt;pre&gt;
                  SCALE            SHEAR          TRANSLATE
                  m00/m11          m01/m10          m02/m12
                  IDENTITY             1.0              0.0              0.0
                  TRANSLATE (TR)       1.0              0.0          not both 0.0
                  SCALE (SC)       not both 1.0         0.0              0.0
                  TR | SC          not both 1.0         0.0          not both 0.0
                  SHEAR (SH)           0.0          not both 0.0         0.0
                  TR | SH              0.0          not both 0.0     not both 0.0
                  SC | SH          not both 0.0     not both 0.0         0.0
                  TR | SC | SH     not both 0.0     not both 0.0     not both 0.0
                  &lt;/pre&gt;                
            </javadoc>
            <method name="updateState" type="void" line="947">
                <scope line="948">
                    <scope line="949">
                        <scope line="950"/>
                        <scope line="954"/>
                    </scope>
                    <scope line="959">
                        <scope line="960"/>
                        <scope line="964"/>
                    </scope>
                </scope>
                <scope line="970">
                    <scope line="971">
                        <scope line="972"/>
                        <scope line="976"/>
                    </scope>
                    <scope line="981">
                        <scope line="982"/>
                        <scope line="986"/>
                    </scope>
                </scope>
            </method>
            <method name="stateError" type="void" line="993"/>
            <javadoc line="996">
                Retrieves the 6 specifiable values in the 3x3 affine transformation
                  matrix and places them into an array of double precisions values.
                  The values are stored in the array as
                  {&amp;nbsp;m00&amp;nbsp;m10&amp;nbsp;m01&amp;nbsp;m11&amp;nbsp;m02&amp;nbsp;m12&amp;nbsp;}.
                  An array of 4 doubles can also be specified, in which case only the
                  first four elements representing the non-transform
                  parts of the array are retrieved and the values are stored into
                  the array as {&amp;nbsp;m00&amp;nbsp;m10&amp;nbsp;m01&amp;nbsp;m11&amp;nbsp;}                
                <param>
                    flatmatrix the double array used to store the returned
                      values.                    
                </param>
                <see>
                    #getScaleX                    
                </see>
                <see>
                    #getScaleY                    
                </see>
                <see>
                    #getShearX                    
                </see>
                <see>
                    #getShearY                    
                </see>
                <see>
                    #getTranslateX                    
                </see>
                <see>
                    #getTranslateY                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getMatrix" type="void" line="1015">
                <params>
                    <param name="flatmatrix" type="double[]"/>
                </params>
                <scope line="1020"/>
            </method>
            <javadoc line="1025">
                Returns the X coordinate scaling element (m00) of the 3x3
                  affine transformation matrix.                
                <return>
                    a double value that is the X coordinate of the scaling
                      element of the affine transformation matrix.                    
                </return>
                <see>
                    #getMatrix                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getScaleX" type="double" line="1033"/>
            <javadoc line="1036">
                Returns the Y coordinate scaling element (m11) of the 3x3
                  affine transformation matrix.                
                <return>
                    a double value that is the Y coordinate of the scaling
                      element of the affine transformation matrix.                    
                </return>
                <see>
                    #getMatrix                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getScaleY" type="double" line="1044"/>
            <javadoc line="1047">
                Returns the X coordinate shearing element (m01) of the 3x3
                  affine transformation matrix.                
                <return>
                    a double value that is the X coordinate of the shearing
                      element of the affine transformation matrix.                    
                </return>
                <see>
                    #getMatrix                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getShearX" type="double" line="1055"/>
            <javadoc line="1058">
                Returns the Y coordinate shearing element (m10) of the 3x3
                  affine transformation matrix.                
                <return>
                    a double value that is the Y coordinate of the shearing
                      element of the affine transformation matrix.                    
                </return>
                <see>
                    #getMatrix                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getShearY" type="double" line="1066"/>
            <javadoc line="1069">
                Returns the X coordinate of the translation element (m02) of the
                  3x3 affine transformation matrix.                
                <return>
                    a double value that is the X coordinate of the translation
                      element of the affine transformation matrix.                    
                </return>
                <see>
                    #getMatrix                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getTranslateX" type="double" line="1077"/>
            <javadoc line="1080">
                Returns the Y coordinate of the translation element (m12) of the
                  3x3 affine transformation matrix.                
                <return>
                    a double value that is the Y coordinate of the translation
                      element of the affine transformation matrix.                    
                </return>
                <see>
                    #getMatrix                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getTranslateY" type="double" line="1088"/>
            <javadoc line="1091">
                Concatenates this transform with a translation transformation.
                  This is equivalent to calling concatenate(T), where T is an
                  &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
                  &lt;pre&gt;
                  [   1    0    tx  ]
                  [   0    1    ty  ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    tx the distance by which coordinates are translated in the
                      X axis direction                    
                </param>
                <param>
                    ty the distance by which coordinates are translated in the
                      Y axis direction                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="translate" type="void" line="1106">
                <params>
                    <param name="tx" type="double"/>
                    <param name="ty" type="double"/>
                </params>
                <scope line="1113">
                    <scope line="1115"/>
                </scope>
                <scope line="1123"/>
                <scope line="1131">
                    <scope line="1133"/>
                </scope>
                <scope line="1141"/>
                <scope line="1149">
                    <scope line="1151"/>
                </scope>
                <scope line="1159"/>
                <scope line="1167"/>
                <scope line="1175"/>
            </method>
            <declaration name="rot90conversion" type="int" line="1182"/>
            <method name="rotate90" type="void" line="1183">
                <declaration name="M0" type="double" line="1184"/>
                <declaration name="state" type="int" line="1190"/>
                <scope line="1191"/>
            </method>
            <method name="rotate180" type="void" line="1197">
                <declaration name="state" type="int" line="1200"/>
                <scope line="1201"/>
                <scope line="1205">
                    <scope line="1206"/>
                    <scope line="1209"/>
                </scope>
            </method>
            <method name="rotate270" type="void" line="1215">
                <declaration name="M0" type="double" line="1216"/>
                <declaration name="state" type="int" line="1222"/>
                <scope line="1223"/>
            </method>
            <javadoc line="1229">
                Concatenates this transform with a rotation transformation.
                  This is equivalent to calling concatenate(R), where R is an
                  &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
                  &lt;pre&gt;
                  [   cos(theta)    -sin(theta)    0   ]
                  [   sin(theta)     cos(theta)    0   ]
                  [       0              0         1   ]
                  &lt;/pre&gt;
                  Rotating by a positive angle theta rotates points on the positive
                  X axis toward the positive Y axis.
                  Note also the discussion of
                  &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
                  above.                
                <param>
                    theta the angle of rotation measured in radians                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="rotate" type="void" line="1246">
                <params>
                    <param name="theta" type="double"/>
                </params>
                <declaration name="sin" type="double" line="1247"/>
                <scope line="1248"/>
                <scope line="1251"/>
                <scope line="1254">
                    <declaration name="cos" type="double" line="1255"/>
                    <scope line="1256"/>
                    <scope line="1259">
                        <declaration name="M0" type="double" line="1260"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1273">
                Concatenates this transform with a transform that rotates
                  coordinates around an anchor point.
                  This operation is equivalent to translating the coordinates so
                  that the anchor point is at the origin (S1), then rotating them
                  about the new origin (S2), and finally translating so that the
                  intermediate origin is restored to the coordinates of the original
                  anchor point (S3).
                  &lt;p&gt;
                  This operation is equivalent to the following sequence of calls:
                  &lt;pre&gt;
                  translate(anchorx, anchory);      // S3: final translation
                  rotate(theta);                    // S2: rotate around anchor
                  translate(-anchorx, -anchory);    // S1: translate anchor to origin
                  &lt;/pre&gt;
                  Rotating by a positive angle theta rotates points on the positive
                  X axis toward the positive Y axis.
                  Note also the discussion of
                  &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
                  above.                
                <param>
                    theta the angle of rotation measured in radians                    
                </param>
                <param>
                    anchorx the X coordinate of the rotation anchor point                    
                </param>
                <param>
                    anchory the Y coordinate of the rotation anchor point                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="rotate" type="void" line="1298">
                <params>
                    <param name="theta" type="double"/>
                    <param name="anchorx" type="double"/>
                    <param name="anchory" type="double"/>
                </params>
            </method>
            <javadoc line="1303">
                Concatenates this transform with a transform that rotates
                  coordinates according to a rotation vector.
                  All coordinates rotate about the origin by the same amount.
                  The amount of rotation is such that coordinates along the former
                  positive X axis will subsequently align with the vector pointing
                  from the origin to the specified vector coordinates.
                  If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
                  no additional rotation is added to this transform.
                  This operation is equivalent to calling:
                  &lt;pre&gt;
                  rotate(Math.atan2(vecy, vecx));
                  &lt;/pre&gt;                
                <param>
                    vecx the X coordinate of the rotation vector                    
                </param>
                <param>
                    vecy the Y coordinate of the rotation vector                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="rotate" type="void" line="1320">
                <params>
                    <param name="vecx" type="double"/>
                    <param name="vecy" type="double"/>
                </params>
                <scope line="1321">
                    <scope line="1322"/>
                </scope>
                <scope line="1326">
                    <scope line="1327"/>
                    <scope line="1330"/>
                </scope>
                <scope line="1334">
                    <declaration name="len" type="double" line="1335"/>
                    <declaration name="sin" type="double" line="1336"/>
                    <declaration name="cos" type="double" line="1337"/>
                    <declaration name="M0" type="double" line="1338"/>
                </scope>
            </method>
            <javadoc line="1350">
                Concatenates this transform with a transform that rotates
                  coordinates around an anchor point according to a rotation
                  vector.
                  All coordinates rotate about the specified anchor coordinates
                  by the same amount.
                  The amount of rotation is such that coordinates along the former
                  positive X axis will subsequently align with the vector pointing
                  from the origin to the specified vector coordinates.
                  If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
                  the transform is not modified in any way.
                  This method is equivalent to calling:
                  &lt;pre&gt;
                  rotate(Math.atan2(vecy, vecx), anchorx, anchory);
                  &lt;/pre&gt;                
                <param>
                    vecx the X coordinate of the rotation vector                    
                </param>
                <param>
                    vecy the Y coordinate of the rotation vector                    
                </param>
                <param>
                    anchorx the X coordinate of the rotation anchor point                    
                </param>
                <param>
                    anchory the Y coordinate of the rotation anchor point                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="rotate" type="void" line="1371">
                <params>
                    <param name="vecx" type="double"/>
                    <param name="vecy" type="double"/>
                    <param name="anchorx" type="double"/>
                    <param name="anchory" type="double"/>
                </params>
            </method>
            <javadoc line="1376">
                Concatenates this transform with a transform that rotates
                  coordinates by the specified number of quadrants.
                  This is equivalent to calling:
                  &lt;pre&gt;
                  rotate(numquadrants  Math.PI / 2.0);
                  &lt;/pre&gt;
                  Rotating by a positive number of quadrants rotates points on
                  the positive X axis toward the positive Y axis.                
                <param>
                    numquadrants the number of 90 degree arcs to rotate by                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="quadrantRotate" type="void" line="1388">
                <params>
                    <param name="numquadrants" type="int"/>
                </params>
            </method>
            <javadoc line="1403">
                Concatenates this transform with a transform that rotates
                  coordinates by the specified number of quadrants around
                  the specified anchor point.
                  This method is equivalent to calling:
                  &lt;pre&gt;
                  rotate(numquadrants  Math.PI / 2.0, anchorx, anchory);
                  &lt;/pre&gt;
                  Rotating by a positive number of quadrants rotates points on
                  the positive X axis toward the positive Y axis.                
                <param>
                    numquadrants the number of 90 degree arcs to rotate by                    
                </param>
                <param>
                    anchorx the X coordinate of the rotation anchor point                    
                </param>
                <param>
                    anchory the Y coordinate of the rotation anchor point                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="quadrantRotate" type="void" line="1418">
                <params>
                    <param name="numquadrants" type="int"/>
                    <param name="anchorx" type="double"/>
                    <param name="anchory" type="double"/>
                </params>
                <scope line="1438"/>
                <scope line="1441"/>
            </method>
            <javadoc line="1445">
                Concatenates this transform with a scaling transformation.
                  This is equivalent to calling concatenate(S), where S is an
                  &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
                  &lt;pre&gt;
                  [   sx   0    0   ]
                  [   0    sy   0   ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    sx the factor by which coordinates are scaled along the
                      X axis direction                    
                </param>
                <param>
                    sy the factor by which coordinates are scaled along the
                      Y axis direction                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="scale" type="void" line="1460">
                <params>
                    <param name="sx" type="double"/>
                    <param name="sy" type="double"/>
                </params>
                <declaration name="state" type="int" line="1461"/>
                <scope line="1473">
                    <scope line="1475"/>
                    <scope line="1478"/>
                </scope>
                <scope line="1489"/>
                <scope line="1493"/>
                <scope line="1501"/>
            </method>
            <javadoc line="1508">
                Concatenates this transform with a shearing transformation.
                  This is equivalent to calling concatenate(SH), where SH is an
                  &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
                  &lt;pre&gt;
                  [   1   shx   0   ]
                  [  shy   1    0   ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    shx the multiplier by which coordinates are shifted in the
                      direction of the positive X axis as a factor of their Y coordinate                    
                </param>
                <param>
                    shy the multiplier by which coordinates are shifted in the
                      direction of the positive Y axis as a factor of their X coordinate                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="shear" type="void" line="1523">
                <params>
                    <param name="shx" type="double"/>
                    <param name="shy" type="double"/>
                </params>
                <declaration name="state" type="int" line="1524"/>
                <declaration name="M0" type="double" line="1530"/>
                <scope line="1545"/>
                <scope line="1554"/>
                <scope line="1563"/>
            </method>
            <javadoc line="1570">
                Resets this transform to the Identity transform.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setToIdentity" type="void" line="1574"/>
            <javadoc line="1580">
                Sets this transform to a translation transformation.
                  The matrix representing this transform becomes:
                  &lt;pre&gt;
                  [   1    0    tx  ]
                  [   0    1    ty  ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    tx the distance by which coordinates are translated in the
                      X axis direction                    
                </param>
                <param>
                    ty the distance by which coordinates are translated in the
                      Y axis direction                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setToTranslation" type="void" line="1594">
                <params>
                    <param name="tx" type="double"/>
                    <param name="ty" type="double"/>
                </params>
                <scope line="1601"/>
                <scope line="1605"/>
            </method>
            <javadoc line="1610">
                Sets this transform to a rotation transformation.
                  The matrix representing this transform becomes:
                  &lt;pre&gt;
                  [   cos(theta)    -sin(theta)    0   ]
                  [   sin(theta)     cos(theta)    0   ]
                  [       0              0         1   ]
                  &lt;/pre&gt;
                  Rotating by a positive angle theta rotates points on the positive
                  X axis toward the positive Y axis.
                  Note also the discussion of
                  &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
                  above.                
                <param>
                    theta the angle of rotation measured in radians                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setToRotation" type="void" line="1626">
                <params>
                    <param name="theta" type="double"/>
                </params>
                <declaration name="sin" type="double" line="1627"/>
                <declaration name="cos" type="double" line="1628"/>
                <scope line="1629"/>
                <scope line="1634">
                    <scope line="1636"/>
                    <scope line="1641"/>
                    <scope line="1646"/>
                </scope>
            </method>
            <javadoc line="1658">
                Sets this transform to a translated rotation transformation.
                  This operation is equivalent to translating the coordinates so
                  that the anchor point is at the origin (S1), then rotating them
                  about the new origin (S2), and finally translating so that the
                  intermediate origin is restored to the coordinates of the original
                  anchor point (S3).
                  &lt;p&gt;
                  This operation is equivalent to the following sequence of calls:
                  &lt;pre&gt;
                  setToTranslation(anchorx, anchory); // S3: final translation
                  rotate(theta);                      // S2: rotate around anchor
                  translate(-anchorx, -anchory);      // S1: translate anchor to origin
                  &lt;/pre&gt;
                  The matrix representing this transform becomes:
                  &lt;pre&gt;
                  [   cos(theta)    -sin(theta)    x-xcos+ysin  ]
                  [   sin(theta)     cos(theta)    y-xsin-ycos  ]
                  [       0              0               1        ]
                  &lt;/pre&gt;
                  Rotating by a positive angle theta rotates points on the positive
                  X axis toward the positive Y axis.
                  Note also the discussion of
                  &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
                  above.                
                <param>
                    theta the angle of rotation measured in radians                    
                </param>
                <param>
                    anchorx the X coordinate of the rotation anchor point                    
                </param>
                <param>
                    anchory the Y coordinate of the rotation anchor point                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setToRotation" type="void" line="1688">
                <params>
                    <param name="theta" type="double"/>
                    <param name="anchorx" type="double"/>
                    <param name="anchory" type="double"/>
                </params>
                <declaration name="sin" type="double" line="1690"/>
                <declaration name="oneMinusCos" type="double" line="1691"/>
                <scope line="1694"/>
            </method>
            <javadoc line="1699">
                Sets this transform to a rotation transformation that rotates
                  coordinates according to a rotation vector.
                  All coordinates rotate about the origin by the same amount.
                  The amount of rotation is such that coordinates along the former
                  positive X axis will subsequently align with the vector pointing
                  from the origin to the specified vector coordinates.
                  If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
                  the transform is set to an identity transform.
                  This operation is equivalent to calling:
                  &lt;pre&gt;
                  setToRotation(Math.atan2(vecy, vecx));
                  &lt;/pre&gt;                
                <param>
                    vecx the X coordinate of the rotation vector                    
                </param>
                <param>
                    vecy the Y coordinate of the rotation vector                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setToRotation" type="void" line="1716">
                <params>
                    <param name="vecx" type="double"/>
                    <param name="vecy" type="double"/>
                </params>
                <declaration name="sin" type="double" line="1717"/>
                <scope line="1718">
                    <scope line="1720"/>
                    <scope line="1725"/>
                </scope>
                <scope line="1731"/>
                <scope line="1737">
                    <declaration name="len" type="double" line="1738"/>
                </scope>
            </method>
            <javadoc line="1751">
                Sets this transform to a rotation transformation that rotates
                  coordinates around an anchor point according to a rotation
                  vector.
                  All coordinates rotate about the specified anchor coordinates
                  by the same amount.
                  The amount of rotation is such that coordinates along the former
                  positive X axis will subsequently align with the vector pointing
                  from the origin to the specified vector coordinates.
                  If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
                  the transform is set to an identity transform.
                  This operation is equivalent to calling:
                  &lt;pre&gt;
                  setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
                  &lt;/pre&gt;                
                <param>
                    vecx the X coordinate of the rotation vector                    
                </param>
                <param>
                    vecy the Y coordinate of the rotation vector                    
                </param>
                <param>
                    anchorx the X coordinate of the rotation anchor point                    
                </param>
                <param>
                    anchory the Y coordinate of the rotation anchor point                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setToRotation" type="void" line="1772">
                <params>
                    <param name="vecx" type="double"/>
                    <param name="vecy" type="double"/>
                    <param name="anchorx" type="double"/>
                    <param name="anchory" type="double"/>
                </params>
                <declaration name="sin" type="double" line="1774"/>
                <declaration name="oneMinusCos" type="double" line="1775"/>
                <scope line="1778"/>
            </method>
            <javadoc line="1783">
                Sets this transform to a rotation transformation that rotates
                  coordinates by the specified number of quadrants.
                  This operation is equivalent to calling:
                  &lt;pre&gt;
                  setToRotation(numquadrants  Math.PI / 2.0);
                  &lt;/pre&gt;
                  Rotating by a positive number of quadrants rotates points on
                  the positive X axis toward the positive Y axis.                
                <param>
                    numquadrants the number of 90 degree arcs to rotate by                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setToQuadrantRotation" type="void" line="1795">
                <params>
                    <param name="numquadrants" type="int"/>
                </params>
            </method>
            <javadoc line="1839">
                Sets this transform to a translated rotation transformation
                  that rotates coordinates by the specified number of quadrants
                  around the specified anchor point.
                  This operation is equivalent to calling:
                  &lt;pre&gt;
                  setToRotation(numquadrants  Math.PI / 2.0, anchorx, anchory);
                  &lt;/pre&gt;
                  Rotating by a positive number of quadrants rotates points on
                  the positive X axis toward the positive Y axis.                
                <param>
                    numquadrants the number of 90 degree arcs to rotate by                    
                </param>
                <param>
                    anchorx the X coordinate of the rotation anchor point                    
                </param>
                <param>
                    anchory the Y coordinate of the rotation anchor point                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setToQuadrantRotation" type="void" line="1854">
                <params>
                    <param name="numquadrants" type="int"/>
                    <param name="anchorx" type="double"/>
                    <param name="anchory" type="double"/>
                </params>
                <scope line="1873"/>
                <scope line="1877"/>
                <scope line="1889"/>
                <scope line="1893"/>
                <scope line="1905"/>
                <scope line="1909"/>
            </method>
            <javadoc line="1916">
                Sets this transform to a scaling transformation.
                  The matrix representing this transform becomes:
                  &lt;pre&gt;
                  [   sx   0    0   ]
                  [   0    sy   0   ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    sx the factor by which coordinates are scaled along the
                      X axis direction                    
                </param>
                <param>
                    sy the factor by which coordinates are scaled along the
                      Y axis direction                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setToScale" type="void" line="1930">
                <params>
                    <param name="sx" type="double"/>
                    <param name="sy" type="double"/>
                </params>
                <scope line="1937"/>
                <scope line="1941"/>
            </method>
            <javadoc line="1946">
                Sets this transform to a shearing transformation.
                  The matrix representing this transform becomes:
                  &lt;pre&gt;
                  [   1   shx   0   ]
                  [  shy   1    0   ]
                  [   0    0    1   ]
                  &lt;/pre&gt;                
                <param>
                    shx the multiplier by which coordinates are shifted in the
                      direction of the positive X axis as a factor of their Y coordinate                    
                </param>
                <param>
                    shy the multiplier by which coordinates are shifted in the
                      direction of the positive Y axis as a factor of their X coordinate                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setToShear" type="void" line="1960">
                <params>
                    <param name="shx" type="double"/>
                    <param name="shy" type="double"/>
                </params>
                <scope line="1967"/>
                <scope line="1971"/>
            </method>
            <javadoc line="1976">
                Sets this transform to a copy of the transform in the specified
                  &lt;code&gt;AffineTransform&lt;/code&gt; object.                
                <param>
                    Tx the <code>AffineTransform</code> object from which to
                      copy the transform                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setTransform" type="void" line="1983">
                <params>
                    <param name="Tx" type="AffineTransform"/>
                </params>
            </method>
            <javadoc line="1993">
                Sets this transform to the matrix specified by the 6
                  double precision values.                
                <param>
                    m00 the X coordinate scaling element of the 3x3 matrix                    
                </param>
                <param>
                    m10 the Y coordinate shearing element of the 3x3 matrix                    
                </param>
                <param>
                    m01 the X coordinate shearing element of the 3x3 matrix                    
                </param>
                <param>
                    m11 the Y coordinate scaling element of the 3x3 matrix                    
                </param>
                <param>
                    m02 the X coordinate translation element of the 3x3 matrix                    
                </param>
                <param>
                    m12 the Y coordinate translation element of the 3x3 matrix                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setTransform" type="void" line="2004">
                <params>
                    <param name="m00" type="double"/>
                    <param name="m10" type="double"/>
                    <param name="m01" type="double"/>
                    <param name="m11" type="double"/>
                    <param name="m02" type="double"/>
                    <param name="m12" type="double"/>
                </params>
            </method>
            <javadoc line="2013">
                Concatenates an &lt;code&gt;AffineTransform&lt;/code&gt; &lt;code&gt;Tx&lt;/code&gt; to
                  this &lt;code&gt;AffineTransform&lt;/code&gt; Cx in the most commonly useful
                  way to provide a new user space
                  that is mapped to the former user space by &lt;code&gt;Tx&lt;/code&gt;.
                  Cx is updated to perform the combined transformation.
                  Transforming a point p by the updated transform Cx&apos; is
                  equivalent to first transforming p by &lt;code&gt;Tx&lt;/code&gt; and then
                  transforming the result by the original transform Cx like this:
                  Cx&apos;(p) = Cx(Tx(p))
                  In matrix notation, if this transform Cx is
                  represented by the matrix [this] and &lt;code&gt;Tx&lt;/code&gt; is represented
                  by the matrix [Tx] then this method does the following:
                  &lt;pre&gt;
                  [this] = [this] x [Tx]
                  &lt;/pre&gt;                
                <param>
                    Tx the <code>AffineTransform</code> object to be
                      concatenated with this <code>AffineTransform</code> object.                    
                </param>
                <see>
                    #preConcatenate                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="concatenate" type="void" line="2034">
                <params>
                    <param name="Tx" type="AffineTransform"/>
                </params>
                <declaration name="M0" type="double" line="2035"/>
                <declaration name="T00" type="double" line="2036"/>
                <declaration name="T02" type="double" line="2037"/>
                <declaration name="mystate" type="int" line="2038"/>
                <declaration name="txstate" type="int" line="2039"/>
            </method>
            <javadoc line="2197">
                Concatenates an &lt;code&gt;AffineTransform&lt;/code&gt; &lt;code&gt;Tx&lt;/code&gt; to
                  this &lt;code&gt;AffineTransform&lt;/code&gt; Cx
                  in a less commonly used way such that &lt;code&gt;Tx&lt;/code&gt; modifies the
                  coordinate transformation relative to the absolute pixel
                  space rather than relative to the existing user space.
                  Cx is updated to perform the combined transformation.
                  Transforming a point p by the updated transform Cx&apos; is
                  equivalent to first transforming p by the original transform
                  Cx and then transforming the result by
                  &lt;code&gt;Tx&lt;/code&gt; like this:
                  Cx&apos;(p) = Tx(Cx(p))
                  In matrix notation, if this transform Cx
                  is represented by the matrix [this] and &lt;code&gt;Tx&lt;/code&gt; is
                  represented by the matrix [Tx] then this method does the
                  following:
                  &lt;pre&gt;
                  [this] = [Tx] x [this]
                  &lt;/pre&gt;                
                <param>
                    Tx the <code>AffineTransform</code> object to be
                      concatenated with this <code>AffineTransform</code> object.                    
                </param>
                <see>
                    #concatenate                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="preConcatenate" type="void" line="2221">
                <params>
                    <param name="Tx" type="AffineTransform"/>
                </params>
                <declaration name="M0" type="double" line="2222"/>
                <declaration name="T00" type="double" line="2223"/>
                <declaration name="T02" type="double" line="2224"/>
                <declaration name="mystate" type="int" line="2225"/>
                <declaration name="txstate" type="int" line="2226"/>
                <scope line="2264">
                    <scope line="2267"/>
                </scope>
                <scope line="2272"/>
                <scope line="2276"/>
            </method>
            <javadoc line="2380">
                Returns an &lt;code&gt;AffineTransform&lt;/code&gt; object representing the
                  inverse transformation.
                  The inverse transform Tx&apos; of this transform Tx
                  maps coordinates transformed by Tx back
                  to their original coordinates.
                  In other words, Tx&apos;(Tx(p)) = p = Tx(Tx&apos;(p)).
                  &lt;p&gt;
                  If this transform maps all coordinates onto a point or a line
                  then it will not have an inverse, since coordinates that do
                  not lie on the destination point or line will not have an inverse
                  mapping.
                  The &lt;code&gt;getDeterminant&lt;/code&gt; method can be used to determine if this
                  transform has no inverse, in which case an exception will be
                  thrown if the &lt;code&gt;createInverse&lt;/code&gt; method is called.                
                <return>
                    a new <code>AffineTransform</code> object representing the
                      inverse transformation.                    
                </return>
                <see>
                    #getDeterminant                    
                </see>
                <exception>
                    NoninvertibleTransformExceptionif the matrix cannot be inverted.                    
                </exception>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="createInverse" type="AffineTransform" line="2401">
                <declaration name="det" type="double" line="2402"/>
                <scope line="2408"/>
                <scope line="2414"/>
                <scope line="2419"/>
                <scope line="2424"/>
                <scope line="2429"/>
                <scope line="2434"/>
            </method>
            <javadoc line="2444">
                Sets this transform to the inverse of itself.
                  The inverse transform Tx&apos; of this transform Tx
                  maps coordinates transformed by Tx back
                  to their original coordinates.
                  In other words, Tx&apos;(Tx(p)) = p = Tx(Tx&apos;(p)).
                  &lt;p&gt;
                  If this transform maps all coordinates onto a point or a line
                  then it will not have an inverse, since coordinates that do
                  not lie on the destination point or line will not have an inverse
                  mapping.
                  The &lt;code&gt;getDeterminant&lt;/code&gt; method can be used to determine if this
                  transform has no inverse, in which case an exception will be
                  thrown if the &lt;code&gt;invert&lt;/code&gt; method is called.                
                <see>
                    #getDeterminant                    
                </see>
                <exception>
                    NoninvertibleTransformExceptionif the matrix cannot be inverted.                    
                </exception>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="invert" type="void" line="2462">
                <declaration name="M00" type="double" line="2463"/>
                <declaration name="M10" type="double" line="2464"/>
                <declaration name="det" type="double" line="2465"/>
                <scope line="2477"/>
                <scope line="2493"/>
                <scope line="2506"/>
                <scope line="2517"/>
                <scope line="2528"/>
                <scope line="2539"/>
            </method>
            <javadoc line="2553">
                Transforms the specified &lt;code&gt;ptSrc&lt;/code&gt; and stores the result
                  in &lt;code&gt;ptDst&lt;/code&gt;.
                  If &lt;code&gt;ptDst&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new {@link Point2D}object is allocated and then the result of the transformation is
                  stored in this object.
                  In either case, &lt;code&gt;ptDst&lt;/code&gt;, which contains the
                  transformed point, is returned for convenience.
                  If &lt;code&gt;ptSrc&lt;/code&gt; and &lt;code&gt;ptDst&lt;/code&gt; are the same
                  object, the input point is correctly overwritten with
                  the transformed point.                
                <param>
                    ptSrc the specified <code>Point2D</code> to be transformed                    
                </param>
                <param>
                    ptDst the specified <code>Point2D</code> that stores the
                      result of transforming <code>ptSrc</code>                    
                </param>
                <return>
                    the <code>ptDst</code> after transforming
                      <code>ptSrc</code> and stroring the result in <code>ptDst</code>.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="transform" type="Point2D" line="2570">
                <params>
                    <param name="ptSrc" type="Point2D"/>
                    <param name="ptDst" type="Point2D"/>
                </params>
                <scope line="2571">
                    <scope line="2572"/>
                    <scope line="2575"/>
                </scope>
                <declaration name="x" type="double" line="2579"/>
                <declaration name="y" type="double" line="2580"/>
            </method>
            <javadoc line="2610">
                Transforms an array of point objects by this transform.
                  If any element of the &lt;code&gt;ptDst&lt;/code&gt; array is
                  &lt;code&gt;null&lt;/code&gt;, a new &lt;code&gt;Point2D&lt;/code&gt; object is allocated
                  and stored into that element before storing the results of the
                  transformation.
                  &lt;p&gt;
                  Note that this method does not take any precautions to
                  avoid problems caused by storing results into &lt;code&gt;Point2D&lt;/code&gt;
                  objects that will be used as the source for calculations
                  further down the source array.
                  This method does guarantee that if a specified &lt;code&gt;Point2D&lt;/code&gt;
                  object is both the source and destination for the same single point
                  transform operation then the results will not be stored until
                  the calculations are complete to avoid storing the results on
                  top of the operands.
                  If, however, the destination &lt;code&gt;Point2D&lt;/code&gt; object for one
                  operation is the same object as the source &lt;code&gt;Point2D&lt;/code&gt;
                  object for another operation further down the source array then
                  the original coordinates in that point are overwritten before
                  they can be converted.                
                <param>
                    ptSrc the array containing the source point objects                    
                </param>
                <param>
                    ptDst the array into which the transform point objects are
                      returned                    
                </param>
                <param>
                    srcOff the offset to the first point object to be
                      transformed in the source array                    
                </param>
                <param>
                    dstOff the offset to the location of the first
                      transformed point object that is stored in the destination array                    
                </param>
                <param>
                    numPts the number of point objects to be transformed                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="transform" type="void" line="2641">
                <params>
                    <param name="ptSrc" type="Point2D[]"/>
                    <param name="srcOff" type="int"/>
                    <param name="ptDst" type="Point2D[]"/>
                    <param name="dstOff" type="int"/>
                    <param name="numPts" type="int"/>
                </params>
                <declaration name="state" type="int" line="2642"/>
                <scope line="2643">
                    <declaration name="src" type="Point2D" line="2644"/>
                    <declaration name="x" type="double" line="2645"/>
                    <declaration name="y" type="double" line="2646"/>
                    <declaration name="dst" type="Point2D" line="2647"/>
                    <scope line="2648">
                        <scope line="2649"/>
                        <scope line="2652"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2687">
                Transforms an array of floating point coordinates by this transform.
                  The two coordinate array sections can be exactly the same or
                  can be overlapping sections of the same array without affecting the
                  validity of the results.
                  This method ensures that no source coordinates are overwritten by a
                  previous operation before they can be transformed.
                  The coordinates are stored in the arrays starting at the specified
                  offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.                
                <param>
                    srcPts the array containing the source point coordinates.
                      Each point is stored as a pair of x,&nbsp;y coordinates.                    
                </param>
                <param>
                    dstPts the array into which the transformed point coordinates
                      are returned.  Each point is stored as a pair of x,&nbsp;y
                      coordinates.                    
                </param>
                <param>
                    srcOff the offset to the first point to be transformed
                      in the source array                    
                </param>
                <param>
                    dstOff the offset to the location of the first
                      transformed point that is stored in the destination array                    
                </param>
                <param>
                    numPts the number of points to be transformed                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="transform" type="void" line="2708">
                <params>
                    <param name="srcPts" type="float[]"/>
                    <param name="srcOff" type="int"/>
                    <param name="dstPts" type="float[]"/>
                    <param name="dstOff" type="int"/>
                    <param name="numPts" type="int"/>
                </params>
                <declaration name="M00" type="double" line="2709"/>
                <scope line="2710"/>
                <scope line="2724">
                    <declaration name="x" type="double" line="2725"/>
                    <declaration name="y" type="double" line="2726"/>
                </scope>
                <scope line="2736">
                    <declaration name="x" type="double" line="2737"/>
                    <declaration name="y" type="double" line="2738"/>
                </scope>
                <scope line="2748">
                    <declaration name="x" type="double" line="2749"/>
                </scope>
                <scope line="2757">
                    <declaration name="x" type="double" line="2758"/>
                </scope>
                <scope line="2768"/>
                <scope line="2776"/>
                <scope line="2784"/>
                <scope line="2790"/>
            </method>
            <javadoc line="2796">
                Transforms an array of double precision coordinates by this transform.
                  The two coordinate array sections can be exactly the same or
                  can be overlapping sections of the same array without affecting the
                  validity of the results.
                  This method ensures that no source coordinates are
                  overwritten by a previous operation before they can be transformed.
                  The coordinates are stored in the arrays starting at the indicated
                  offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.                
                <param>
                    srcPts the array containing the source point coordinates.
                      Each point is stored as a pair of x,&nbsp;y coordinates.                    
                </param>
                <param>
                    dstPts the array into which the transformed point
                      coordinates are returned.  Each point is stored as a pair of
                      x,&nbsp;y coordinates.                    
                </param>
                <param>
                    srcOff the offset to the first point to be transformed
                      in the source array                    
                </param>
                <param>
                    dstOff the offset to the location of the first
                      transformed point that is stored in the destination array                    
                </param>
                <param>
                    numPts the number of point objects to be transformed                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="transform" type="void" line="2817">
                <params>
                    <param name="srcPts" type="double[]"/>
                    <param name="srcOff" type="int"/>
                    <param name="dstPts" type="double[]"/>
                    <param name="dstOff" type="int"/>
                    <param name="numPts" type="int"/>
                </params>
                <declaration name="M00" type="double" line="2818"/>
                <scope line="2819"/>
                <scope line="2833">
                    <declaration name="x" type="double" line="2834"/>
                    <declaration name="y" type="double" line="2835"/>
                </scope>
                <scope line="2845">
                    <declaration name="x" type="double" line="2846"/>
                    <declaration name="y" type="double" line="2847"/>
                </scope>
                <scope line="2857">
                    <declaration name="x" type="double" line="2858"/>
                </scope>
                <scope line="2866">
                    <declaration name="x" type="double" line="2867"/>
                </scope>
                <scope line="2877"/>
                <scope line="2885"/>
                <scope line="2893"/>
                <scope line="2899"/>
            </method>
            <javadoc line="2905">
                Transforms an array of floating point coordinates by this transform
                  and stores the results into an array of doubles.
                  The coordinates are stored in the arrays starting at the specified
                  offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.                
                <param>
                    srcPts the array containing the source point coordinates.
                      Each point is stored as a pair of x,&nbsp;y coordinates.                    
                </param>
                <param>
                    dstPts the array into which the transformed point coordinates
                      are returned.  Each point is stored as a pair of x,&nbsp;y
                      coordinates.                    
                </param>
                <param>
                    srcOff the offset to the first point to be transformed
                      in the source array                    
                </param>
                <param>
                    dstOff the offset to the location of the first
                      transformed point that is stored in the destination array                    
                </param>
                <param>
                    numPts the number of points to be transformed                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="transform" type="void" line="2922">
                <params>
                    <param name="srcPts" type="float[]"/>
                    <param name="srcOff" type="int"/>
                    <param name="dstPts" type="double[]"/>
                    <param name="dstOff" type="int"/>
                    <param name="numPts" type="int"/>
                </params>
                <declaration name="M00" type="double" line="2923"/>
                <scope line="2934">
                    <declaration name="x" type="double" line="2935"/>
                    <declaration name="y" type="double" line="2936"/>
                </scope>
                <scope line="2946">
                    <declaration name="x" type="double" line="2947"/>
                    <declaration name="y" type="double" line="2948"/>
                </scope>
                <scope line="2958">
                    <declaration name="x" type="double" line="2959"/>
                </scope>
                <scope line="2967">
                    <declaration name="x" type="double" line="2968"/>
                </scope>
                <scope line="2978"/>
                <scope line="2986"/>
                <scope line="2994"/>
                <scope line="3000"/>
            </method>
            <javadoc line="3007">
                Transforms an array of double precision coordinates by this transform
                  and stores the results into an array of floats.
                  The coordinates are stored in the arrays starting at the specified
                  offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.                
                <param>
                    srcPts the array containing the source point coordinates.
                      Each point is stored as a pair of x,&nbsp;y coordinates.                    
                </param>
                <param>
                    dstPts the array into which the transformed point
                      coordinates are returned.  Each point is stored as a pair of
                      x,&nbsp;y coordinates.                    
                </param>
                <param>
                    srcOff the offset to the first point to be transformed
                      in the source array                    
                </param>
                <param>
                    dstOff the offset to the location of the first
                      transformed point that is stored in the destination array                    
                </param>
                <param>
                    numPts the number of point objects to be transformed                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="transform" type="void" line="3024">
                <params>
                    <param name="srcPts" type="double[]"/>
                    <param name="srcOff" type="int"/>
                    <param name="dstPts" type="float[]"/>
                    <param name="dstOff" type="int"/>
                    <param name="numPts" type="int"/>
                </params>
                <declaration name="M00" type="double" line="3025"/>
                <scope line="3036">
                    <declaration name="x" type="double" line="3037"/>
                    <declaration name="y" type="double" line="3038"/>
                </scope>
                <scope line="3048">
                    <declaration name="x" type="double" line="3049"/>
                    <declaration name="y" type="double" line="3050"/>
                </scope>
                <scope line="3060">
                    <declaration name="x" type="double" line="3061"/>
                </scope>
                <scope line="3069">
                    <declaration name="x" type="double" line="3070"/>
                </scope>
                <scope line="3080"/>
                <scope line="3088"/>
                <scope line="3096"/>
                <scope line="3102"/>
            </method>
            <javadoc line="3109">
                Inverse transforms the specified &lt;code&gt;ptSrc&lt;/code&gt; and stores the
                  result in &lt;code&gt;ptDst&lt;/code&gt;.
                  If &lt;code&gt;ptDst&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new
                  &lt;code&gt;Point2D&lt;/code&gt; object is allocated and then the result of the
                  transform is stored in this object.
                  In either case, &lt;code&gt;ptDst&lt;/code&gt;, which contains the transformed
                  point, is returned for convenience.
                  If &lt;code&gt;ptSrc&lt;/code&gt; and &lt;code&gt;ptDst&lt;/code&gt; are the same
                  object, the input point is correctly overwritten with the
                  transformed point.                
                <param>
                    ptSrc the point to be inverse transformed                    
                </param>
                <param>
                    ptDst the resulting transformed point                    
                </param>
                <return>
                    <code>ptDst</code>, which contains the result of the
                      inverse transform.                    
                </return>
                <exception>
                    NoninvertibleTransformException  if the matrix cannot be
                      inverted.                    
                </exception>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="inverseTransform" type="Point2D" line="3128">
                <params>
                    <param name="ptSrc" type="Point2D"/>
                    <param name="ptDst" type="Point2D"/>
                </params>
                <scope line="3129">
                    <scope line="3130"/>
                    <scope line="3133"/>
                </scope>
                <declaration name="x" type="double" line="3137"/>
                <declaration name="y" type="double" line="3138"/>
                <declaration name="det" type="double" line="3146"/>
                <scope line="3147"/>
                <scope line="3156"/>
                <scope line="3165"/>
            </method>
            <javadoc line="3178">
                Inverse transforms an array of double precision coordinates by
                  this transform.
                  The two coordinate array sections can be exactly the same or
                  can be overlapping sections of the same array without affecting the
                  validity of the results.
                  This method ensures that no source coordinates are
                  overwritten by a previous operation before they can be transformed.
                  The coordinates are stored in the arrays starting at the specified
                  offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.                
                <param>
                    srcPts the array containing the source point coordinates.
                      Each point is stored as a pair of x,&nbsp;y coordinates.                    
                </param>
                <param>
                    dstPts the array into which the transformed point
                      coordinates are returned.  Each point is stored as a pair of
                      x,&nbsp;y coordinates.                    
                </param>
                <param>
                    srcOff the offset to the first point to be transformed
                      in the source array                    
                </param>
                <param>
                    dstOff the offset to the location of the first
                      transformed point that is stored in the destination array                    
                </param>
                <param>
                    numPts the number of point objects to be transformed                    
                </param>
                <exception>
                    NoninvertibleTransformException  if the matrix cannot be
                      inverted.                    
                </exception>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="inverseTransform" type="void" line="3202">
                <params>
                    <param name="srcPts" type="double[]"/>
                    <param name="srcOff" type="int"/>
                    <param name="dstPts" type="double[]"/>
                    <param name="dstOff" type="int"/>
                    <param name="numPts" type="int"/>
                </params>
                <declaration name="M00" type="double" line="3203"/>
                <declaration name="det" type="double" line="3204"/>
                <scope line="3205"/>
                <scope line="3220"/>
                <scope line="3223">
                    <declaration name="x" type="double" line="3224"/>
                    <declaration name="y" type="double" line="3225"/>
                </scope>
                <scope line="3236"/>
                <scope line="3239">
                    <declaration name="x" type="double" line="3240"/>
                    <declaration name="y" type="double" line="3241"/>
                </scope>
                <scope line="3251"/>
                <scope line="3254">
                    <declaration name="x" type="double" line="3255"/>
                </scope>
                <scope line="3263"/>
                <scope line="3266">
                    <declaration name="x" type="double" line="3267"/>
                </scope>
                <scope line="3277"/>
                <scope line="3280"/>
                <scope line="3288"/>
                <scope line="3291"/>
                <scope line="3299"/>
                <scope line="3305"/>
            </method>
            <javadoc line="3311">
                Transforms the relative distance vector specified by
                  &lt;code&gt;ptSrc&lt;/code&gt; and stores the result in &lt;code&gt;ptDst&lt;/code&gt;.
                  A relative distance vector is transformed without applying the
                  translation components of the affine transformation matrix
                  using the following equations:
                  &lt;pre&gt;
                  [  x&apos; ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
                  [  y&apos; ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
                  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
                  &lt;/pre&gt;
                  If &lt;code&gt;ptDst&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new
                  &lt;code&gt;Point2D&lt;/code&gt; object is allocated and then the result of the
                  transform is stored in this object.
                  In either case, &lt;code&gt;ptDst&lt;/code&gt;, which contains the
                  transformed point, is returned for convenience.
                  If &lt;code&gt;ptSrc&lt;/code&gt; and &lt;code&gt;ptDst&lt;/code&gt; are the same object,
                  the input point is correctly overwritten with the transformed
                  point.                
                <param>
                    ptSrc the distance vector to be delta transformed                    
                </param>
                <param>
                    ptDst the resulting transformed distance vector                    
                </param>
                <return>
                    <code>ptDst</code>, which contains the result of the
                      transformation.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="deltaTransform" type="Point2D" line="3336">
                <params>
                    <param name="ptSrc" type="Point2D"/>
                    <param name="ptDst" type="Point2D"/>
                </params>
                <scope line="3337">
                    <scope line="3338"/>
                    <scope line="3341"/>
                </scope>
                <declaration name="x" type="double" line="3345"/>
                <declaration name="y" type="double" line="3346"/>
            </method>
            <javadoc line="3368">
                Transforms an array of relative distance vectors by this
                  transform.
                  A relative distance vector is transformed without applying the
                  translation components of the affine transformation matrix
                  using the following equations:
                  &lt;pre&gt;
                  [  x&apos; ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
                  [  y&apos; ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
                  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
                  &lt;/pre&gt;
                  The two coordinate array sections can be exactly the same or
                  can be overlapping sections of the same array without affecting the
                  validity of the results.
                  This method ensures that no source coordinates are
                  overwritten by a previous operation before they can be transformed.
                  The coordinates are stored in the arrays starting at the indicated
                  offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.                
                <param>
                    srcPts the array containing the source distance vectors.
                      Each vector is stored as a pair of relative x,&nbsp;y coordinates.                    
                </param>
                <param>
                    dstPts the array into which the transformed distance vectors
                      are returned.  Each vector is stored as a pair of relative
                      x,&nbsp;y coordinates.                    
                </param>
                <param>
                    srcOff the offset to the first vector to be transformed
                      in the source array                    
                </param>
                <param>
                    dstOff the offset to the location of the first
                      transformed vector that is stored in the destination array                    
                </param>
                <param>
                    numPts the number of vector coordinate pairs to be
                      transformed                    
                </param>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="deltaTransform" type="void" line="3399">
                <params>
                    <param name="srcPts" type="double[]"/>
                    <param name="srcOff" type="int"/>
                    <param name="dstPts" type="double[]"/>
                    <param name="dstOff" type="int"/>
                    <param name="numPts" type="int"/>
                </params>
                <declaration name="M00" type="double" line="3400"/>
                <scope line="3401"/>
                <scope line="3414">
                    <declaration name="x" type="double" line="3415"/>
                    <declaration name="y" type="double" line="3416"/>
                </scope>
                <scope line="3425">
                    <declaration name="x" type="double" line="3426"/>
                </scope>
                <scope line="3435"/>
                <scope line="3442"/>
            </method>
            <javadoc line="3448">
                Returns a new {@link Shape} object defined by the geometry of the
                  specified &lt;code&gt;Shape&lt;/code&gt; after it has been transformed by
                  this transform.                
                <param>
                    pSrc the specified <code>Shape</code> object to be
                      transformed by this transform.                    
                </param>
                <return>
                    a new <code>Shape</code> object that defines the geometry
                      of the transformed <code>Shape</code>, or null if {@code pSrc} is null.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="createTransformedShape" type="Shape" line="3458">
                <params>
                    <param name="pSrc" type="Shape"/>
                </params>
                <scope line="3459"/>
            </method>
            <method name="_matround" type="double" line="3464">
                <params>
                    <param name="matval" type="double"/>
                </params>
            </method>
            <javadoc line="3467">
                Returns a &lt;code&gt;String&lt;/code&gt; that represents the value of this{@link Object}.                
                <return>
                    a <code>String</code> representing the value of this
                      <code>Object</code>.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3473"/>
            <javadoc line="3476">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;AffineTransform&lt;/code&gt; is
                  an identity transform.                
                <return>
                    <code>true</code> if this <code>AffineTransform</code> is
                      an identity transform; <code>false</code> otherwise.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="isIdentity" type="boolean" line="3483"/>
            <javadoc line="3486">
                Returns a copy of this &lt;code&gt;AffineTransform&lt;/code&gt; object.                
                <return>
                    an <code>Object</code> that is a copy of this
                      <code>AffineTransform</code> object.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="clone" type="Object" line="3492">
                <scope line="3493"/>
                <scope line="3496"/>
            </method>
            <javadoc line="3500">
                Returns the hashcode for this transform.                
                <return>
                    a hash code for this transform.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="3505">
                <declaration name="bits" type="long" line="3506"/>
            </method>
            <javadoc line="3514">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;AffineTransform&lt;/code&gt;
                  represents the same affine coordinate transform as the specified
                  argument.                
                <param>
                    obj the <code>Object</code> to test for equality with this
                      <code>AffineTransform</code>                    
                </param>
                <return>
                    <code>true</code> if <code>obj</code> equals this
                      <code>AffineTransform</code> object; <code>false</code> otherwise.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="equals" type="boolean" line="3524">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="3525"/>
                <declaration name="a" type="AffineTransform" line="3528"/>
            </method>
            <declaration name="serialVersionUID" type="long" line="3531"/>
            <method name="writeObject" type="void" line="3532">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
            </method>
            <method name="readObject" type="void" line="3535">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
            </method>
        </class>
    </source>