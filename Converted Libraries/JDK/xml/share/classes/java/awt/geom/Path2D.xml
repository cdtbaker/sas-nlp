<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt.geom">
        <import package="java.awt.Shape"/>
        <import package="java.awt.Rectangle"/>
        <import package="sun.awt.geom.Curve"/>
        <import package="java.io.Serializable"/>
        <import package="java.io.StreamCorruptedException"/>
        <import package="java.util.Arrays"/>
        <class name="Path2D" line="8">
            <implements interface="Shape"/>
            <implements interface="Cloneable"/>
            <javadoc line="8">
                The {@code Path2D} class provides a simple, yet flexible
                  shape which represents an arbitrary geometric path.
                  It can fully represent any path which can be iterated by the{@link PathIterator} interface including all of its segment
                  types and winding rules and it implements all of the
                  basic hit testing methods of the {@link Shape} interface.
                  &lt;p&gt;
                  Use {@link Path2D.Float} when dealing with data that can be represented
                  and used with floating point precision.  Use {@link Path2D.Double}for data that requires the accuracy or range of double precision.
                  &lt;p&gt;{@code Path2D} provides exactly those facilities required for
                  basic construction and management of a geometric path and
                  implementation of the above interfaces with little added
                  interpretation.
                  If it is useful to manipulate the interiors of closed
                  geometric shapes beyond simple hit testing then the{@link Area} class provides additional capabilities
                  specifically targeted at closed figures.
                  While both classes nominally implement the {@code Shape}interface, they differ in purpose and together they provide
                  two useful views of a geometric shape where {@code Path2D}deals primarily with a trajectory formed by path segments
                  and {@code Area} deals more with interpretation and manipulation
                  of enclosed regions of 2D geometric space.
                  &lt;p&gt;
                  The {@link PathIterator} interface has more detailed descriptions
                  of the types of segments that make up a path and the winding rules
                  that control how to determine which regions are inside or outside
                  the path.                
                <author>
                    Jim Graham                    
                </author>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="WIND_EVEN_ODD" type="int" line="37"/>
            <javadoc line="37">
                An even-odd winding rule for determining the interior of
                  a path.                
                <see>
                    PathIterator#WIND_EVEN_ODD                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="WIND_NON_ZERO" type="int" line="44"/>
            <javadoc line="44">
                A non-zero winding rule for determining the interior of a
                  path.                
                <see>
                    PathIterator#WIND_NON_ZERO                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="SEG_MOVETO" type="byte" line="51"/>
            <declaration name="SEG_LINETO" type="byte" line="52"/>
            <declaration name="SEG_QUADTO" type="byte" line="53"/>
            <declaration name="SEG_CUBICTO" type="byte" line="54"/>
            <declaration name="SEG_CLOSE" type="byte" line="55"/>
            <declaration name="pointTypes" type="byte[]" line="56"/>
            <declaration name="numTypes" type="int" line="57"/>
            <declaration name="numCoords" type="int" line="58"/>
            <declaration name="windingRule" type="int" line="59"/>
            <declaration name="INIT_SIZE" type="int" line="60"/>
            <declaration name="EXPAND_MAX" type="int" line="61"/>
            <javadoc line="62">
                Constructs a new empty {@code Path2D} object.
                  It is assumed that the package sibling subclass that is
                  defaulting to this constructor will fill in all values.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="Path2D" type="constructor" line="68"/>
            <javadoc line="70">
                Constructs a new {@code Path2D} object from the given
                  specified initial values.
                  This method is only intended for internal use and should
                  not be made public if the other constructors for this class
                  are ever exposed.                
                <param>
                    rule the winding rule                    
                </param>
                <param>
                    initialTypes the size to make the initial array to
                      store the path segment types                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="Path2D" type="constructor" line="81">
                <params>
                    <param name="rule" type="int"/>
                    <param name="initialTypes" type="int"/>
                </params>
            </method>
            <method name="cloneCoordsFloat" type="float[]" line="85"/>
            <method name="cloneCoordsDouble" type="double[]" line="86"/>
            <method name="append" type="void" line="87"/>
            <method name="append" type="void" line="88"/>
            <method name="getPoint" type="Point2D" line="89"/>
            <method name="needRoom" type="void" line="90"/>
            <method name="pointCrossings" type="int" line="91"/>
            <method name="rectCrossings" type="int" line="92"/>
            <class name="Float" line="93">
                <extends class="Path2D"/>
                <implements interface="Serializable"/>
                <javadoc line="93">
                    The {@code Float} class defines a geometric path with
                      coordinates stored in single precision floating point.                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <declaration name="floatCoords" type="float" line="99"/>
                <javadoc line="100">
                    Constructs a new empty single precision {@code Path2D} object
                      with a default winding rule of {@link #WIND_NON_ZERO}.                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Float" type="constructor" line="105"/>
                <javadoc line="108">
                    Constructs a new empty single precision {@code Path2D} object
                      with the specified winding rule to control operations that
                      require the interior of the path to be defined.                    
                    <param>
                        rule the winding rule                        
                    </param>
                    <see>
                        #WIND_EVEN_ODD                        
                    </see>
                    <see>
                        #WIND_NON_ZERO                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Float" type="constructor" line="117">
                    <params>
                        <param name="rule" type="int"/>
                    </params>
                </method>
                <javadoc line="120">
                    Constructs a new empty single precision {@code Path2D} object
                      with the specified winding rule and the specified initial
                      capacity to store path segments.
                      This number is an initial guess as to how many path segments
                      will be added to the path, but the storage is expanded as
                      needed to store whatever path segments are added.                    
                    <param>
                        rule the winding rule                        
                    </param>
                    <param>
                        initialCapacity the estimate for the number of path segments
                          in the path                        
                    </param>
                    <see>
                        #WIND_EVEN_ODD                        
                    </see>
                    <see>
                        #WIND_NON_ZERO                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Float" type="constructor" line="134">
                    <params>
                        <param name="rule" type="int"/>
                        <param name="initialCapacity" type="int"/>
                    </params>
                </method>
                <javadoc line="138">
                    Constructs a new single precision {@code Path2D} object
                      from an arbitrary {@link Shape} object.
                      All of the initial geometry and the winding rule for this path are
                      taken from the specified {@code Shape} object.                    
                    <param>
                        s the specified {@code Shape} object                        
                    </param>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Float" type="constructor" line="146">
                    <params>
                        <param name="s" type="Shape"/>
                    </params>
                </method>
                <javadoc line="149">
                    Constructs a new single precision {@code Path2D} object
                      from an arbitrary {@link Shape} object, transformed by an{@link AffineTransform} object.
                      All of the initial geometry and the winding rule for this path are
                      taken from the specified {@code Shape} object and transformed
                      by the specified {@code AffineTransform} object.                    
                    <param>
                        s the specified {@code Shape} object                        
                    </param>
                    <param>
                        at the specified {@code AffineTransform} object                        
                    </param>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Float" type="constructor" line="159">
                    <params>
                        <param name="s" type="Shape"/>
                        <param name="at" type="AffineTransform"/>
                    </params>
                    <scope line="160">
                        <declaration name="p2d" type="Path2D" line="161"/>
                    </scope>
                    <scope line="168">
                        <declaration name="pi" type="PathIterator" line="169"/>
                    </scope>
                </method>
                <method name="cloneCoordsFloat" type="float[]" line="176">
                    <params>
                        <param name="at" type="AffineTransform"/>
                    </params>
                    <declaration name="ret" type="float" line="177"/>
                    <scope line="178"/>
                    <scope line="181"/>
                </method>
                <method name="cloneCoordsDouble" type="double[]" line="187">
                    <params>
                        <param name="at" type="AffineTransform"/>
                    </params>
                    <declaration name="ret" type="double" line="188"/>
                    <scope line="189">
                        <scope line="190"/>
                    </scope>
                    <scope line="194"/>
                </method>
                <method name="append" type="void" line="199">
                    <params>
                        <param name="x" type="float"/>
                        <param name="y" type="float"/>
                    </params>
                </method>
                <method name="append" type="void" line="203">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <method name="getPoint" type="Point2D" line="207">
                    <params>
                        <param name="coordindex" type="int"/>
                    </params>
                </method>
                <method name="needRoom" type="void" line="210">
                    <params>
                        <param name="needMove" type="boolean"/>
                        <param name="newCoords" type="int"/>
                    </params>
                    <scope line="211"/>
                    <declaration name="size" type="int" line="214"/>
                    <scope line="215">
                        <declaration name="grow" type="int" line="216"/>
                        <scope line="217"/>
                    </scope>
                    <scope line="223">
                        <declaration name="grow" type="int" line="224"/>
                        <scope line="225"/>
                        <scope line="228"/>
                    </scope>
                </method>
                <javadoc line="234">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="moveTo" type="void" line="238">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                    <scope line="239"/>
                    <scope line="243"/>
                </method>
                <javadoc line="250">
                    Adds a point to the path by moving to the specified
                      coordinates specified in float precision.
                      &lt;p&gt;
                      This method provides a single precision variant of
                      the double precision {@code moveTo()} method on the
                      base {@code Path2D} class.                    
                    <param>
                        x the specified X coordinate                        
                    </param>
                    <param>
                        y the specified Y coordinate                        
                    </param>
                    <see>
                        Path2D#moveTo                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="moveTo" type="void" line="262">
                    <params>
                        <param name="x" type="float"/>
                        <param name="y" type="float"/>
                    </params>
                    <scope line="263"/>
                    <scope line="267"/>
                </method>
                <javadoc line="274">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="lineTo" type="void" line="278">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="284">
                    Adds a point to the path by drawing a straight line from the
                      current coordinates to the new specified coordinates
                      specified in float precision.
                      &lt;p&gt;
                      This method provides a single precision variant of
                      the double precision {@code lineTo()} method on the
                      base {@code Path2D} class.                    
                    <param>
                        x the specified X coordinate                        
                    </param>
                    <param>
                        y the specified Y coordinate                        
                    </param>
                    <see>
                        Path2D#lineTo                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="lineTo" type="void" line="297">
                    <params>
                        <param name="x" type="float"/>
                        <param name="y" type="float"/>
                    </params>
                </method>
                <javadoc line="303">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="quadTo" type="void" line="307">
                    <params>
                        <param name="x1" type="double"/>
                        <param name="y1" type="double"/>
                        <param name="x2" type="double"/>
                        <param name="y2" type="double"/>
                    </params>
                </method>
                <javadoc line="315">
                    Adds a curved segment, defined by two new points, to the path by
                      drawing a Quadratic curve that intersects both the current
                      coordinates and the specified coordinates {@code (x2,y2)},
                      using the specified point {@code (x1,y1)} as a quadratic
                      parametric control point.
                      All coordinates are specified in float precision.
                      &lt;p&gt;
                      This method provides a single precision variant of
                      the double precision {@code quadTo()} method on the
                      base {@code Path2D} class.                    
                    <param>
                        x1 the X coordinate of the quadratic control point                        
                    </param>
                    <param>
                        y1 the Y coordinate of the quadratic control point                        
                    </param>
                    <param>
                        x2 the X coordinate of the final end point                        
                    </param>
                    <param>
                        y2 the Y coordinate of the final end point                        
                    </param>
                    <see>
                        Path2D#quadTo                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="quadTo" type="void" line="333">
                    <params>
                        <param name="x1" type="float"/>
                        <param name="y1" type="float"/>
                        <param name="x2" type="float"/>
                        <param name="y2" type="float"/>
                    </params>
                </method>
                <javadoc line="341">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="curveTo" type="void" line="345">
                    <params>
                        <param name="x1" type="double"/>
                        <param name="y1" type="double"/>
                        <param name="x2" type="double"/>
                        <param name="y2" type="double"/>
                        <param name="x3" type="double"/>
                        <param name="y3" type="double"/>
                    </params>
                </method>
                <javadoc line="355">
                    Adds a curved segment, defined by three new points, to the path by
                      drawing a B&amp;eacute;zier curve that intersects both the current
                      coordinates and the specified coordinates {@code (x3,y3)},
                      using the specified points {@code (x1,y1)} and {@code (x2,y2)} as
                      B&amp;eacute;zier control points.
                      All coordinates are specified in float precision.
                      &lt;p&gt;
                      This method provides a single precision variant of
                      the double precision {@code curveTo()} method on the
                      base {@code Path2D} class.                    
                    <param>
                        x1 the X coordinate of the first B&amp;eacute;zier control point                        
                    </param>
                    <param>
                        y1 the Y coordinate of the first B&amp;eacute;zier control point                        
                    </param>
                    <param>
                        x2 the X coordinate of the second B&amp;eacute;zier control point                        
                    </param>
                    <param>
                        y2 the Y coordinate of the second B&amp;eacute;zier control point                        
                    </param>
                    <param>
                        x3 the X coordinate of the final end point                        
                    </param>
                    <param>
                        y3 the Y coordinate of the final end point                        
                    </param>
                    <see>
                        Path2D#curveTo                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="curveTo" type="void" line="375">
                    <params>
                        <param name="x1" type="float"/>
                        <param name="y1" type="float"/>
                        <param name="x2" type="float"/>
                        <param name="y2" type="float"/>
                        <param name="x3" type="float"/>
                        <param name="y3" type="float"/>
                    </params>
                </method>
                <method name="pointCrossings" type="int" line="385">
                    <params>
                        <param name="px" type="double"/>
                        <param name="py" type="double"/>
                    </params>
                    <declaration name="movx" type="double" line="386"/>
                    <declaration name="coords" type="float" line="387"/>
                    <declaration name="crossings" type="int" line="390"/>
                    <declaration name="ci" type="int" line="391"/>
                    <scope line="392">
                        <scope line="395"/>
                        <scope line="417"/>
                    </scope>
                    <scope line="425"/>
                </method>
                <method name="rectCrossings" type="int" line="430">
                    <params>
                        <param name="rxmin" type="double"/>
                        <param name="rymin" type="double"/>
                        <param name="rxmax" type="double"/>
                        <param name="rymax" type="double"/>
                    </params>
                    <declaration name="coords" type="float" line="431"/>
                    <declaration name="curx" type="double" line="432"/>
                    <declaration name="crossings" type="int" line="435"/>
                    <declaration name="ci" type="int" line="436"/>
                    <scope line="437">
                        <scope line="440"/>
                        <scope line="462"/>
                    </scope>
                    <scope line="470"/>
                </method>
                <javadoc line="475">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="append" type="void" line="479">
                    <params>
                        <param name="pi" type="PathIterator"/>
                        <param name="connect" type="boolean"/>
                    </params>
                    <declaration name="coords" type="float" line="480"/>
                    <scope line="481">
                        <scope line="484"/>
                        <scope line="488"/>
                    </scope>
                </method>
                <javadoc line="508">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="transform" type="void" line="512">
                    <params>
                        <param name="at" type="AffineTransform"/>
                    </params>
                </method>
                <javadoc line="515">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="getBounds2D" type="Rectangle2D" line="519">
                    <declaration name="x1" type="float" line="520"/>
                    <declaration name="i" type="int" line="521"/>
                    <scope line="522">
                        <scope line="525">
                            <declaration name="y" type="float" line="526"/>
                            <declaration name="x" type="float" line="527"/>
                        </scope>
                    </scope>
                    <scope line="534"/>
                </method>
                <javadoc line="539">
                    {@inheritDoc}&lt;p&gt;
                      The iterator for this class is not multi-threaded safe,
                      which means that the {@code Path2D} class does not
                      guarantee that modifications to the geometry of this{@code Path2D} object do not affect any iterations of
                      that geometry that are already in process.                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="getPathIterator" type="PathIterator" line="547">
                    <params>
                        <param name="at" type="AffineTransform"/>
                    </params>
                    <scope line="548"/>
                    <scope line="551"/>
                </method>
                <javadoc line="555">
                    Creates a new object of the same class as this object.                    
                    <return>
                        a clone of this instance.                        
                    </return>
                    <exception>
                        OutOfMemoryError    if there is not enough memory.                        
                    </exception>
                    <see>
                        java.lang.Cloneable                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="clone" type="Object" line="562">
                    <scope line="563"/>
                    <scope line="566"/>
                </method>
                <declaration name="serialVersionUID" type="long" line="570"/>
                <javadoc line="571">
                    Writes the default serializable fields to the{@code ObjectOutputStream} followed by an explicit
                      serialization of the path segments stored in this
                      path.                    
                    <serialData>
                        &lt;a name=&quot;Path2DSerialData&quot;&gt;&lt;!-- --&gt;&lt;/a&gt;
                          &lt;ol&gt;
                          &lt;li&gt;The default serializable fields.
                          There are no default serializable fields as of 1.6.
                          &lt;li&gt;followed by
                          a byte indicating the storage type of the original object
                          as a hint (SERIAL_STORAGE_FLT_ARRAY)
                          &lt;li&gt;followed by
                          an integer indicating the number of path segments to follow (NP)
                          or -1 to indicate an unknown number of path segments follows
                          &lt;li&gt;followed by
                          an integer indicating the total number of coordinates to follow (NC)
                          or -1 to indicate an unknown number of coordinates follows
                          (NC should always be even since coordinates always appear in pairs
                          representing an x,y pair)
                          &lt;li&gt;followed by
                          a byte indicating the winding rule
                          ({@link #WIND_EVEN_ODD WIND_EVEN_ODD} or{@link #WIND_NON_ZERO WIND_NON_ZERO})
                          &lt;li&gt;followed by
                          NP (or unlimited if NP &lt; 0) sets of values consisting of
                          a single byte indicating a path segment type
                          followed by one or more pairs of float or double
                          values representing the coordinates of the path segment
                          &lt;li&gt;followed by
                          a byte indicating the end of the path (SERIAL_PATH_END).
                          &lt;/ol&gt;
                          &lt;p&gt;
                          The following byte value constants are used in the serialized form
                          of {@code Path2D} objects:
                          &lt;table&gt;
                          &lt;tr&gt;
                          &lt;th&gt;Constant Name&lt;/th&gt;
                          &lt;th&gt;Byte Value&lt;/th&gt;
                          &lt;th&gt;Followed by&lt;/th&gt;
                          &lt;th&gt;Description&lt;/th&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_STORAGE_FLT_ARRAY}&lt;/td&gt;
                          &lt;td&gt;0x30&lt;/td&gt;
                          &lt;td&gt;&lt;/td&gt;
                          &lt;td&gt;A hint that the original {@code Path2D} object stored
                          the coordinates in a Java array of floats.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_STORAGE_DBL_ARRAY}&lt;/td&gt;
                          &lt;td&gt;0x31&lt;/td&gt;
                          &lt;td&gt;&lt;/td&gt;
                          &lt;td&gt;A hint that the original {@code Path2D} object stored
                          the coordinates in a Java array of doubles.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_FLT_MOVETO}&lt;/td&gt;
                          &lt;td&gt;0x40&lt;/td&gt;
                          &lt;td&gt;2 floats&lt;/td&gt;
                          &lt;td&gt;A {@link #moveTo moveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_FLT_LINETO}&lt;/td&gt;
                          &lt;td&gt;0x41&lt;/td&gt;
                          &lt;td&gt;2 floats&lt;/td&gt;
                          &lt;td&gt;A {@link #lineTo lineTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_FLT_QUADTO}&lt;/td&gt;
                          &lt;td&gt;0x42&lt;/td&gt;
                          &lt;td&gt;4 floats&lt;/td&gt;
                          &lt;td&gt;A {@link #quadTo quadTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_FLT_CUBICTO}&lt;/td&gt;
                          &lt;td&gt;0x43&lt;/td&gt;
                          &lt;td&gt;6 floats&lt;/td&gt;
                          &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_DBL_MOVETO}&lt;/td&gt;
                          &lt;td&gt;0x50&lt;/td&gt;
                          &lt;td&gt;2 doubles&lt;/td&gt;
                          &lt;td&gt;A {@link #moveTo moveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_DBL_LINETO}&lt;/td&gt;
                          &lt;td&gt;0x51&lt;/td&gt;
                          &lt;td&gt;2 doubles&lt;/td&gt;
                          &lt;td&gt;A {@link #lineTo lineTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_DBL_QUADTO}&lt;/td&gt;
                          &lt;td&gt;0x52&lt;/td&gt;
                          &lt;td&gt;4 doubles&lt;/td&gt;
                          &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_DBL_CUBICTO}&lt;/td&gt;
                          &lt;td&gt;0x53&lt;/td&gt;
                          &lt;td&gt;6 doubles&lt;/td&gt;
                          &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_CLOSE}&lt;/td&gt;
                          &lt;td&gt;0x60&lt;/td&gt;
                          &lt;td&gt;&lt;/td&gt;
                          &lt;td&gt;A {@link #closePath closePath} path segment.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_PATH_END}&lt;/td&gt;
                          &lt;td&gt;0x61&lt;/td&gt;
                          &lt;td&gt;&lt;/td&gt;
                          &lt;td&gt;There are no more path segments following.&lt;/td&gt;
                          &lt;/table&gt;                        
                    </serialData>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="writeObject" type="void" line="687">
                    <params>
                        <param name="s" type="java.io.ObjectOutputStream"/>
                    </params>
                </method>
                <javadoc line="690">
                    Reads the default serializable fields from the{@code ObjectInputStream} followed by an explicit
                      serialization of the path segments stored in this
                      path.
                      &lt;p&gt;
                      There are no default serializable fields as of 1.6.
                      &lt;p&gt;
                      The serial data for this object is described in the
                      writeObject method.                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="readObject" type="void" line="701">
                    <params>
                        <param name="s" type="java.io.ObjectInputStream"/>
                    </params>
                </method>
                <class name="CopyIterator" line="704">
                    <extends class="Path2D.Iterator"/>
                    <declaration name="floatCoords" type="float" line="705"/>
                    <method name="CopyIterator" type="constructor" line="706">
                        <params>
                            <param name="p2df" type="Path2D.Float"/>
                        </params>
                    </method>
                    <method name="currentSegment" type="int" line="710">
                        <params>
                            <param name="coords" type="float[]"/>
                        </params>
                        <declaration name="type" type="int" line="711"/>
                        <declaration name="numCoords" type="int" line="712"/>
                        <scope line="713"/>
                    </method>
                    <method name="currentSegment" type="int" line="718">
                        <params>
                            <param name="coords" type="double[]"/>
                        </params>
                        <declaration name="type" type="int" line="719"/>
                        <declaration name="numCoords" type="int" line="720"/>
                        <scope line="721">
                            <scope line="722"/>
                        </scope>
                    </method>
                </class>
                <class name="TxIterator" line="729">
                    <extends class="Path2D.Iterator"/>
                    <declaration name="floatCoords" type="float" line="730"/>
                    <declaration name="affine" type="AffineTransform" line="731"/>
                    <method name="TxIterator" type="constructor" line="732">
                        <params>
                            <param name="p2df" type="Path2D.Float"/>
                            <param name="at" type="AffineTransform"/>
                        </params>
                    </method>
                    <method name="currentSegment" type="int" line="737">
                        <params>
                            <param name="coords" type="float[]"/>
                        </params>
                        <declaration name="type" type="int" line="738"/>
                        <declaration name="numCoords" type="int" line="739"/>
                        <scope line="740"/>
                    </method>
                    <method name="currentSegment" type="int" line="745">
                        <params>
                            <param name="coords" type="double[]"/>
                        </params>
                        <declaration name="type" type="int" line="746"/>
                        <declaration name="numCoords" type="int" line="747"/>
                        <scope line="748"/>
                    </method>
                </class>
            </class>
            <class name="Double" line="755">
                <extends class="Path2D"/>
                <implements interface="Serializable"/>
                <javadoc line="755">
                    The {@code Double} class defines a geometric path with
                      coordinates stored in double precision floating point.                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <declaration name="doubleCoords" type="double" line="761"/>
                <javadoc line="762">
                    Constructs a new empty double precision {@code Path2D} object
                      with a default winding rule of {@link #WIND_NON_ZERO}.                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Double" type="constructor" line="767"/>
                <javadoc line="770">
                    Constructs a new empty double precision {@code Path2D} object
                      with the specified winding rule to control operations that
                      require the interior of the path to be defined.                    
                    <param>
                        rule the winding rule                        
                    </param>
                    <see>
                        #WIND_EVEN_ODD                        
                    </see>
                    <see>
                        #WIND_NON_ZERO                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Double" type="constructor" line="779">
                    <params>
                        <param name="rule" type="int"/>
                    </params>
                </method>
                <javadoc line="782">
                    Constructs a new empty double precision {@code Path2D} object
                      with the specified winding rule and the specified initial
                      capacity to store path segments.
                      This number is an initial guess as to how many path segments
                      are in the path, but the storage is expanded as needed to store
                      whatever path segments are added to this path.                    
                    <param>
                        rule the winding rule                        
                    </param>
                    <param>
                        initialCapacity the estimate for the number of path segments
                          in the path                        
                    </param>
                    <see>
                        #WIND_EVEN_ODD                        
                    </see>
                    <see>
                        #WIND_NON_ZERO                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Double" type="constructor" line="796">
                    <params>
                        <param name="rule" type="int"/>
                        <param name="initialCapacity" type="int"/>
                    </params>
                </method>
                <javadoc line="800">
                    Constructs a new double precision {@code Path2D} object
                      from an arbitrary {@link Shape} object.
                      All of the initial geometry and the winding rule for this path are
                      taken from the specified {@code Shape} object.                    
                    <param>
                        s the specified {@code Shape} object                        
                    </param>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Double" type="constructor" line="808">
                    <params>
                        <param name="s" type="Shape"/>
                    </params>
                </method>
                <javadoc line="811">
                    Constructs a new double precision {@code Path2D} object
                      from an arbitrary {@link Shape} object, transformed by an{@link AffineTransform} object.
                      All of the initial geometry and the winding rule for this path are
                      taken from the specified {@code Shape} object and transformed
                      by the specified {@code AffineTransform} object.                    
                    <param>
                        s the specified {@code Shape} object                        
                    </param>
                    <param>
                        at the specified {@code AffineTransform} object                        
                    </param>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="Double" type="constructor" line="821">
                    <params>
                        <param name="s" type="Shape"/>
                        <param name="at" type="AffineTransform"/>
                    </params>
                    <scope line="822">
                        <declaration name="p2d" type="Path2D" line="823"/>
                    </scope>
                    <scope line="830">
                        <declaration name="pi" type="PathIterator" line="831"/>
                    </scope>
                </method>
                <method name="cloneCoordsFloat" type="float[]" line="838">
                    <params>
                        <param name="at" type="AffineTransform"/>
                    </params>
                    <declaration name="ret" type="float" line="839"/>
                    <scope line="840">
                        <scope line="841"/>
                    </scope>
                    <scope line="845"/>
                </method>
                <method name="cloneCoordsDouble" type="double[]" line="850">
                    <params>
                        <param name="at" type="AffineTransform"/>
                    </params>
                    <declaration name="ret" type="double" line="851"/>
                    <scope line="852"/>
                    <scope line="855"/>
                </method>
                <method name="append" type="void" line="861">
                    <params>
                        <param name="x" type="float"/>
                        <param name="y" type="float"/>
                    </params>
                </method>
                <method name="append" type="void" line="865">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <method name="getPoint" type="Point2D" line="869">
                    <params>
                        <param name="coordindex" type="int"/>
                    </params>
                </method>
                <method name="needRoom" type="void" line="872">
                    <params>
                        <param name="needMove" type="boolean"/>
                        <param name="newCoords" type="int"/>
                    </params>
                    <scope line="873"/>
                    <declaration name="size" type="int" line="876"/>
                    <scope line="877">
                        <declaration name="grow" type="int" line="878"/>
                        <scope line="879"/>
                    </scope>
                    <scope line="885">
                        <declaration name="grow" type="int" line="886"/>
                        <scope line="887"/>
                        <scope line="890"/>
                    </scope>
                </method>
                <javadoc line="896">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="moveTo" type="void" line="900">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                    <scope line="901"/>
                    <scope line="905"/>
                </method>
                <javadoc line="912">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="lineTo" type="void" line="916">
                    <params>
                        <param name="x" type="double"/>
                        <param name="y" type="double"/>
                    </params>
                </method>
                <javadoc line="922">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="quadTo" type="void" line="926">
                    <params>
                        <param name="x1" type="double"/>
                        <param name="y1" type="double"/>
                        <param name="x2" type="double"/>
                        <param name="y2" type="double"/>
                    </params>
                </method>
                <javadoc line="934">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="curveTo" type="void" line="938">
                    <params>
                        <param name="x1" type="double"/>
                        <param name="y1" type="double"/>
                        <param name="x2" type="double"/>
                        <param name="y2" type="double"/>
                        <param name="x3" type="double"/>
                        <param name="y3" type="double"/>
                    </params>
                </method>
                <method name="pointCrossings" type="int" line="948">
                    <params>
                        <param name="px" type="double"/>
                        <param name="py" type="double"/>
                    </params>
                    <declaration name="movx" type="double" line="949"/>
                    <declaration name="coords" type="double" line="950"/>
                    <declaration name="crossings" type="int" line="953"/>
                    <declaration name="ci" type="int" line="954"/>
                    <scope line="955">
                        <scope line="958"/>
                        <scope line="980"/>
                    </scope>
                    <scope line="988"/>
                </method>
                <method name="rectCrossings" type="int" line="993">
                    <params>
                        <param name="rxmin" type="double"/>
                        <param name="rymin" type="double"/>
                        <param name="rxmax" type="double"/>
                        <param name="rymax" type="double"/>
                    </params>
                    <declaration name="coords" type="double" line="994"/>
                    <declaration name="curx" type="double" line="995"/>
                    <declaration name="crossings" type="int" line="998"/>
                    <declaration name="ci" type="int" line="999"/>
                    <scope line="1000">
                        <scope line="1003"/>
                        <scope line="1027"/>
                    </scope>
                    <scope line="1035"/>
                </method>
                <javadoc line="1040">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="append" type="void" line="1044">
                    <params>
                        <param name="pi" type="PathIterator"/>
                        <param name="connect" type="boolean"/>
                    </params>
                    <declaration name="coords" type="double" line="1045"/>
                    <scope line="1046">
                        <scope line="1049"/>
                        <scope line="1053"/>
                    </scope>
                </method>
                <javadoc line="1073">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="transform" type="void" line="1077">
                    <params>
                        <param name="at" type="AffineTransform"/>
                    </params>
                </method>
                <javadoc line="1080">
                    {@inheritDoc}                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="getBounds2D" type="Rectangle2D" line="1084">
                    <declaration name="x1" type="double" line="1085"/>
                    <declaration name="i" type="int" line="1086"/>
                    <scope line="1087">
                        <scope line="1090">
                            <declaration name="y" type="double" line="1091"/>
                            <declaration name="x" type="double" line="1092"/>
                        </scope>
                    </scope>
                    <scope line="1099"/>
                </method>
                <javadoc line="1104">
                    {@inheritDoc}&lt;p&gt;
                      The iterator for this class is not multi-threaded safe,
                      which means that the {@code Path2D} class does not
                      guarantee that modifications to the geometry of this{@code Path2D} object do not affect any iterations of
                      that geometry that are already in process.                    
                    <param>
                        at an {@code AffineTransform}                        
                    </param>
                    <return>
                        a new {@code PathIterator} that iterates along the boundary
                          of this {@code Shape} and provides access to the geometry
                          of this {@code Shape}&apos;s outline                        
                    </return>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="getPathIterator" type="PathIterator" line="1116">
                    <params>
                        <param name="at" type="AffineTransform"/>
                    </params>
                    <scope line="1117"/>
                    <scope line="1120"/>
                </method>
                <javadoc line="1124">
                    Creates a new object of the same class as this object.                    
                    <return>
                        a clone of this instance.                        
                    </return>
                    <exception>
                        OutOfMemoryError    if there is not enough memory.                        
                    </exception>
                    <see>
                        java.lang.Cloneable                        
                    </see>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="clone" type="Object" line="1131"/>
                <declaration name="serialVersionUID" type="long" line="1134"/>
                <javadoc line="1135">
                    Writes the default serializable fields to the{@code ObjectOutputStream} followed by an explicit
                      serialization of the path segments stored in this
                      path.                    
                    <serialData>
                        &lt;a name=&quot;Path2DSerialData&quot;&gt;&lt;!-- --&gt;&lt;/a&gt;
                          &lt;ol&gt;
                          &lt;li&gt;The default serializable fields.
                          There are no default serializable fields as of 1.6.
                          &lt;li&gt;followed by
                          a byte indicating the storage type of the original object
                          as a hint (SERIAL_STORAGE_DBL_ARRAY)
                          &lt;li&gt;followed by
                          an integer indicating the number of path segments to follow (NP)
                          or -1 to indicate an unknown number of path segments follows
                          &lt;li&gt;followed by
                          an integer indicating the total number of coordinates to follow (NC)
                          or -1 to indicate an unknown number of coordinates follows
                          (NC should always be even since coordinates always appear in pairs
                          representing an x,y pair)
                          &lt;li&gt;followed by
                          a byte indicating the winding rule
                          ({@link #WIND_EVEN_ODD WIND_EVEN_ODD} or{@link #WIND_NON_ZERO WIND_NON_ZERO})
                          &lt;li&gt;followed by
                          NP (or unlimited if NP &lt; 0) sets of values consisting of
                          a single byte indicating a path segment type
                          followed by one or more pairs of float or double
                          values representing the coordinates of the path segment
                          &lt;li&gt;followed by
                          a byte indicating the end of the path (SERIAL_PATH_END).
                          &lt;/ol&gt;
                          &lt;p&gt;
                          The following byte value constants are used in the serialized form
                          of {@code Path2D} objects:
                          &lt;table&gt;
                          &lt;tr&gt;
                          &lt;th&gt;Constant Name&lt;/th&gt;
                          &lt;th&gt;Byte Value&lt;/th&gt;
                          &lt;th&gt;Followed by&lt;/th&gt;
                          &lt;th&gt;Description&lt;/th&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_STORAGE_FLT_ARRAY}&lt;/td&gt;
                          &lt;td&gt;0x30&lt;/td&gt;
                          &lt;td&gt;&lt;/td&gt;
                          &lt;td&gt;A hint that the original {@code Path2D} object stored
                          the coordinates in a Java array of floats.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_STORAGE_DBL_ARRAY}&lt;/td&gt;
                          &lt;td&gt;0x31&lt;/td&gt;
                          &lt;td&gt;&lt;/td&gt;
                          &lt;td&gt;A hint that the original {@code Path2D} object stored
                          the coordinates in a Java array of doubles.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_FLT_MOVETO}&lt;/td&gt;
                          &lt;td&gt;0x40&lt;/td&gt;
                          &lt;td&gt;2 floats&lt;/td&gt;
                          &lt;td&gt;A {@link #moveTo moveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_FLT_LINETO}&lt;/td&gt;
                          &lt;td&gt;0x41&lt;/td&gt;
                          &lt;td&gt;2 floats&lt;/td&gt;
                          &lt;td&gt;A {@link #lineTo lineTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_FLT_QUADTO}&lt;/td&gt;
                          &lt;td&gt;0x42&lt;/td&gt;
                          &lt;td&gt;4 floats&lt;/td&gt;
                          &lt;td&gt;A {@link #quadTo quadTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_FLT_CUBICTO}&lt;/td&gt;
                          &lt;td&gt;0x43&lt;/td&gt;
                          &lt;td&gt;6 floats&lt;/td&gt;
                          &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_DBL_MOVETO}&lt;/td&gt;
                          &lt;td&gt;0x50&lt;/td&gt;
                          &lt;td&gt;2 doubles&lt;/td&gt;
                          &lt;td&gt;A {@link #moveTo moveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_DBL_LINETO}&lt;/td&gt;
                          &lt;td&gt;0x51&lt;/td&gt;
                          &lt;td&gt;2 doubles&lt;/td&gt;
                          &lt;td&gt;A {@link #lineTo lineTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_DBL_QUADTO}&lt;/td&gt;
                          &lt;td&gt;0x52&lt;/td&gt;
                          &lt;td&gt;4 doubles&lt;/td&gt;
                          &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_DBL_CUBICTO}&lt;/td&gt;
                          &lt;td&gt;0x53&lt;/td&gt;
                          &lt;td&gt;6 doubles&lt;/td&gt;
                          &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_SEG_CLOSE}&lt;/td&gt;
                          &lt;td&gt;0x60&lt;/td&gt;
                          &lt;td&gt;&lt;/td&gt;
                          &lt;td&gt;A {@link #closePath closePath} path segment.&lt;/td&gt;
                          &lt;/tr&gt;
                          &lt;tr&gt;
                          &lt;td&gt;{@code SERIAL_PATH_END}&lt;/td&gt;
                          &lt;td&gt;0x61&lt;/td&gt;
                          &lt;td&gt;&lt;/td&gt;
                          &lt;td&gt;There are no more path segments following.&lt;/td&gt;
                          &lt;/table&gt;                        
                    </serialData>
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="writeObject" type="void" line="1251">
                    <params>
                        <param name="s" type="java.io.ObjectOutputStream"/>
                    </params>
                </method>
                <javadoc line="1254">
                    Reads the default serializable fields from the{@code ObjectInputStream} followed by an explicit
                      serialization of the path segments stored in this
                      path.
                      &lt;p&gt;
                      There are no default serializable fields as of 1.6.
                      &lt;p&gt;
                      The serial data for this object is described in the
                      writeObject method.                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <method name="readObject" type="void" line="1265">
                    <params>
                        <param name="s" type="java.io.ObjectInputStream"/>
                    </params>
                </method>
                <class name="CopyIterator" line="1268">
                    <extends class="Path2D.Iterator"/>
                    <declaration name="doubleCoords" type="double" line="1269"/>
                    <method name="CopyIterator" type="constructor" line="1270">
                        <params>
                            <param name="p2dd" type="Path2D.Double"/>
                        </params>
                    </method>
                    <method name="currentSegment" type="int" line="1274">
                        <params>
                            <param name="coords" type="float[]"/>
                        </params>
                        <declaration name="type" type="int" line="1275"/>
                        <declaration name="numCoords" type="int" line="1276"/>
                        <scope line="1277">
                            <scope line="1278"/>
                        </scope>
                    </method>
                    <method name="currentSegment" type="int" line="1284">
                        <params>
                            <param name="coords" type="double[]"/>
                        </params>
                        <declaration name="type" type="int" line="1285"/>
                        <declaration name="numCoords" type="int" line="1286"/>
                        <scope line="1287"/>
                    </method>
                </class>
                <class name="TxIterator" line="1293">
                    <extends class="Path2D.Iterator"/>
                    <declaration name="doubleCoords" type="double" line="1294"/>
                    <declaration name="affine" type="AffineTransform" line="1295"/>
                    <method name="TxIterator" type="constructor" line="1296">
                        <params>
                            <param name="p2dd" type="Path2D.Double"/>
                            <param name="at" type="AffineTransform"/>
                        </params>
                    </method>
                    <method name="currentSegment" type="int" line="1301">
                        <params>
                            <param name="coords" type="float[]"/>
                        </params>
                        <declaration name="type" type="int" line="1302"/>
                        <declaration name="numCoords" type="int" line="1303"/>
                        <scope line="1304"/>
                    </method>
                    <method name="currentSegment" type="int" line="1309">
                        <params>
                            <param name="coords" type="double[]"/>
                        </params>
                        <declaration name="type" type="int" line="1310"/>
                        <declaration name="numCoords" type="int" line="1311"/>
                        <scope line="1312"/>
                    </method>
                </class>
            </class>
            <method name="moveTo" type="void" line="1319"/>
            <javadoc line="1319">
                Adds a point to the path by moving to the specified
                  coordinates specified in double precision.                
                <param>
                    x the specified X coordinate                    
                </param>
                <param>
                    y the specified Y coordinate                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="lineTo" type="void" line="1327"/>
            <javadoc line="1327">
                Adds a point to the path by drawing a straight line from the
                  current coordinates to the new specified coordinates
                  specified in double precision.                
                <param>
                    x the specified X coordinate                    
                </param>
                <param>
                    y the specified Y coordinate                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="quadTo" type="void" line="1336"/>
            <javadoc line="1336">
                Adds a curved segment, defined by two new points, to the path by
                  drawing a Quadratic curve that intersects both the current
                  coordinates and the specified coordinates {@code (x2,y2)},
                  using the specified point {@code (x1,y1)} as a quadratic
                  parametric control point.
                  All coordinates are specified in double precision.                
                <param>
                    x1 the X coordinate of the quadratic control point                    
                </param>
                <param>
                    y1 the Y coordinate of the quadratic control point                    
                </param>
                <param>
                    x2 the X coordinate of the final end point                    
                </param>
                <param>
                    y2 the Y coordinate of the final end point                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="curveTo" type="void" line="1350"/>
            <javadoc line="1350">
                Adds a curved segment, defined by three new points, to the path by
                  drawing a B&amp;eacute;zier curve that intersects both the current
                  coordinates and the specified coordinates {@code (x3,y3)},
                  using the specified points {@code (x1,y1)} and {@code (x2,y2)} as
                  B&amp;eacute;zier control points.
                  All coordinates are specified in double precision.                
                <param>
                    x1 the X coordinate of the first B&amp;eacute;zier control point                    
                </param>
                <param>
                    y1 the Y coordinate of the first B&amp;eacute;zier control point                    
                </param>
                <param>
                    x2 the X coordinate of the second B&amp;eacute;zier control point                    
                </param>
                <param>
                    y2 the Y coordinate of the second B&amp;eacute;zier control point                    
                </param>
                <param>
                    x3 the X coordinate of the final end point                    
                </param>
                <param>
                    y3 the Y coordinate of the final end point                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <javadoc line="1366">
                Closes the current subpath by drawing a straight line back to
                  the coordinates of the last {@code moveTo}.  If the path is already
                  closed then this method has no effect.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="closePath" type="void" line="1372">
                <scope line="1373"/>
            </method>
            <javadoc line="1378">
                Appends the geometry of the specified {@code Shape} object to the
                  path, possibly connecting the new geometry to the existing path
                  segments with a line segment.
                  If the {@code connect} parameter is {@code true} and the
                  path is not empty then any initial {@code moveTo} in the
                  geometry of the appended {@code Shape}is turned into a {@code lineTo} segment.
                  If the destination coordinates of such a connecting {@code lineTo}segment match the ending coordinates of a currently open
                  subpath then the segment is omitted as superfluous.
                  The winding rule of the specified {@code Shape} is ignored
                  and the appended geometry is governed by the winding
                  rule specified for this path.                
                <param>
                    s the {@code Shape} whose geometry is appended
                      to this path                    
                </param>
                <param>
                    connect a boolean to control whether or not to turn an initial{@code moveTo} segment into a {@code lineTo} segment
                      to connect the new geometry to the existing path                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="append" type="void" line="1396">
                <params>
                    <param name="s" type="Shape"/>
                    <param name="connect" type="boolean"/>
                </params>
            </method>
            <method name="append" type="void" line="1399"/>
            <javadoc line="1399">
                Appends the geometry of the specified{@link PathIterator} object
                  to the path, possibly connecting the new geometry to the existing
                  path segments with a line segment.
                  If the {@code connect} parameter is {@code true} and the
                  path is not empty then any initial {@code moveTo} in the
                  geometry of the appended {@code Shape} is turned into a{@code lineTo} segment.
                  If the destination coordinates of such a connecting {@code lineTo}segment match the ending coordinates of a currently open
                  subpath then the segment is omitted as superfluous.
                  The winding rule of the specified {@code Shape} is ignored
                  and the appended geometry is governed by the winding
                  rule specified for this path.                
                <param>
                    pi the {@code PathIterator} whose geometry is appended to
                      this path                    
                </param>
                <param>
                    connect a boolean to control whether or not to turn an initial{@code moveTo} segment into a {@code lineTo} segment
                      to connect the new geometry to the existing path                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <javadoc line="1418">
                Returns the fill style winding rule.                
                <return>
                    an integer representing the current winding rule.                    
                </return>
                <see>
                    #WIND_EVEN_ODD                    
                </see>
                <see>
                    #WIND_NON_ZERO                    
                </see>
                <see>
                    #setWindingRule                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getWindingRule" type="int" line="1426"/>
            <javadoc line="1429">
                Sets the winding rule for this path to the specified value.                
                <param>
                    rule an integer representing the specified
                      winding rule                    
                </param>
                <exception>
                    IllegalArgumentException if{@code rule} is not either{@link #WIND_EVEN_ODD} or{@link #WIND_NON_ZERO}                    
                </exception>
                <see>
                    #getWindingRule                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setWindingRule" type="void" line="1437">
                <params>
                    <param name="rule" type="int"/>
                </params>
                <scope line="1438"/>
            </method>
            <javadoc line="1443">
                Returns the coordinates most recently added to the end of the path
                  as a {@link Point2D} object.                
                <return>
                    a {@code Point2D} object containing the ending coordinates of
                      the path or {@code null} if there are no points in the path.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getCurrentPoint" type="Point2D" line="1450">
                <declaration name="index" type="int" line="1451"/>
                <scope line="1452"/>
                <scope line="1455">
                    <scope line="1456"/>
                </scope>
            </method>
            <javadoc line="1476">
                Resets the path to empty.  The append position is set back to the
                  beginning of the path and all coordinates and point types are
                  forgotten.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="reset" type="void" line="1482"/>
            <method name="transform" type="void" line="1485"/>
            <javadoc line="1485">
                Transforms the geometry of this path using the specified{@link AffineTransform}.
                  The geometry is transformed in place, which permanently changes the
                  boundary defined by this object.                
                <param>
                    at the {@code AffineTransform} used to transform the area                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <javadoc line="1493">
                Returns a new {@code Shape} representing a transformed version
                  of this {@code Path2D}.
                  Note that the exact type and coordinate precision of the return
                  value is not specified for this method.
                  The method will return a Shape that contains no less precision
                  for the transformed geometry than this {@code Path2D} currently
                  maintains, but it may contain no more precision either.
                  If the tradeoff of precision vs. storage size in the result is
                  important then the convenience constructors in the{@link Path2D.Float#Float(Shape,AffineTransform) Path2D.Float}and{@link Path2D.Double#Double(Shape,AffineTransform) Path2D.Double}subclasses should be used to make the choice explicit.                
                <param>
                    at the {@code AffineTransform} used to transform a
                      new {@code Shape}.                    
                </param>
                <return>
                    a new {@code Shape}, transformed with the specified{@code AffineTransform}.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="createTransformedShape" type="Shape" line="1508">
                <params>
                    <param name="at" type="AffineTransform"/>
                </params>
                <declaration name="p2d" type="Path2D" line="1509"/>
                <scope line="1510"/>
            </method>
            <javadoc line="1515">
                {@inheritDoc}                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getBounds" type="Rectangle" line="1519"/>
            <javadoc line="1522">
                Tests if the specified coordinates are inside the closed
                  boundary of the specified {@link PathIterator}.
                  &lt;p&gt;
                  This method provides a basic facility for implementors of
                  the {@link Shape} interface to implement support for the{@link Shape#contains(double,double)} method.                
                <param>
                    pi the specified {@code PathIterator}                    
                </param>
                <param>
                    x the specified X coordinate                    
                </param>
                <param>
                    y the specified Y coordinate                    
                </param>
                <return>
                    {@code true} if the specified coordinates are inside the
                      specified {@code PathIterator}; {@code false} otherwise                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="contains" type="boolean" line="1535">
                <params>
                    <param name="pi" type="PathIterator"/>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
                <scope line="1536">
                    <declaration name="mask" type="int" line="1537"/>
                    <declaration name="cross" type="int" line="1538"/>
                </scope>
                <scope line="1541"/>
            </method>
            <javadoc line="1545">
                Tests if the specified {@link Point2D} is inside the closed
                  boundary of the specified {@link PathIterator}.
                  &lt;p&gt;
                  This method provides a basic facility for implementors of
                  the {@link Shape} interface to implement support for the{@link Shape#contains(Point2D)} method.                
                <param>
                    pi the specified {@code PathIterator}                    
                </param>
                <param>
                    p the specified {@code Point2D}                    
                </param>
                <return>
                    {@code true} if the specified coordinates are inside the
                      specified {@code PathIterator}; {@code false} otherwise                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="contains" type="boolean" line="1557">
                <params>
                    <param name="pi" type="PathIterator"/>
                    <param name="p" type="Point2D"/>
                </params>
            </method>
            <javadoc line="1560">
                {@inheritDoc}                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="contains" type="boolean" line="1564">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                </params>
                <scope line="1565">
                    <scope line="1566"/>
                    <declaration name="mask" type="int" line="1569"/>
                </scope>
                <scope line="1572"/>
            </method>
            <javadoc line="1576">
                {@inheritDoc}                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="contains" type="boolean" line="1580">
                <params>
                    <param name="p" type="Point2D"/>
                </params>
            </method>
            <javadoc line="1583">
                Tests if the specified rectangular area is entirely inside the
                  closed boundary of the specified {@link PathIterator}.
                  &lt;p&gt;
                  This method provides a basic facility for implementors of
                  the {@link Shape} interface to implement support for the{@link Shape#contains(double,double,double,double)} method.
                  &lt;p&gt;
                  This method object may conservatively return false in
                  cases where the specified rectangular area intersects a
                  segment of the path, but that segment does not represent a
                  boundary between the interior and exterior of the path.
                  Such segments could lie entirely within the interior of the
                  path if they are part of a path with a {@link #WIND_NON_ZERO}winding rule or if the segments are retraced in the reverse
                  direction such that the two sets of segments cancel each
                  other out without any exterior area falling between them.
                  To determine whether segments represent true boundaries of
                  the interior of the path would require extensive calculations
                  involving all of the segments of the path and the winding
                  rule and are thus beyond the scope of this implementation.                
                <param>
                    pi the specified {@code PathIterator}                    
                </param>
                <param>
                    x the specified X coordinate                    
                </param>
                <param>
                    y the specified Y coordinate                    
                </param>
                <param>
                    w the width of the specified rectangular area                    
                </param>
                <param>
                    h the height of the specified rectangular area                    
                </param>
                <return>
                    {@code true} if the specified {@code PathIterator} contains
                      the specified rectangluar area; {@code false} otherwise.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="contains" type="boolean" line="1611">
                <params>
                    <param name="pi" type="PathIterator"/>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="w" type="double"/>
                    <param name="h" type="double"/>
                </params>
                <scope line="1612"/>
                <scope line="1615"/>
                <declaration name="mask" type="int" line="1618"/>
                <declaration name="crossings" type="int" line="1619"/>
            </method>
            <javadoc line="1622">
                Tests if the specified {@link Rectangle2D} is entirely inside the
                  closed boundary of the specified {@link PathIterator}.
                  &lt;p&gt;
                  This method provides a basic facility for implementors of
                  the {@link Shape} interface to implement support for the{@link Shape#contains(Rectangle2D)} method.
                  &lt;p&gt;
                  This method object may conservatively return false in
                  cases where the specified rectangular area intersects a
                  segment of the path, but that segment does not represent a
                  boundary between the interior and exterior of the path.
                  Such segments could lie entirely within the interior of the
                  path if they are part of a path with a {@link #WIND_NON_ZERO}winding rule or if the segments are retraced in the reverse
                  direction such that the two sets of segments cancel each
                  other out without any exterior area falling between them.
                  To determine whether segments represent true boundaries of
                  the interior of the path would require extensive calculations
                  involving all of the segments of the path and the winding
                  rule and are thus beyond the scope of this implementation.                
                <param>
                    pi the specified {@code PathIterator}                    
                </param>
                <param>
                    r a specified {@code Rectangle2D}                    
                </param>
                <return>
                    {@code true} if the specified {@code PathIterator} contains
                      the specified {@code Rectangle2D}; {@code false} otherwise.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="contains" type="boolean" line="1647">
                <params>
                    <param name="pi" type="PathIterator"/>
                    <param name="r" type="Rectangle2D"/>
                </params>
            </method>
            <javadoc line="1650">
                {@inheritDoc}&lt;p&gt;
                  This method object may conservatively return false in
                  cases where the specified rectangular area intersects a
                  segment of the path, but that segment does not represent a
                  boundary between the interior and exterior of the path.
                  Such segments could lie entirely within the interior of the
                  path if they are part of a path with a {@link #WIND_NON_ZERO}winding rule or if the segments are retraced in the reverse
                  direction such that the two sets of segments cancel each
                  other out without any exterior area falling between them.
                  To determine whether segments represent true boundaries of
                  the interior of the path would require extensive calculations
                  involving all of the segments of the path and the winding
                  rule and are thus beyond the scope of this implementation.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="contains" type="boolean" line="1666">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="w" type="double"/>
                    <param name="h" type="double"/>
                </params>
                <scope line="1667"/>
                <scope line="1670"/>
                <declaration name="mask" type="int" line="1673"/>
                <declaration name="crossings" type="int" line="1674"/>
            </method>
            <javadoc line="1677">
                {@inheritDoc}&lt;p&gt;
                  This method object may conservatively return false in
                  cases where the specified rectangular area intersects a
                  segment of the path, but that segment does not represent a
                  boundary between the interior and exterior of the path.
                  Such segments could lie entirely within the interior of the
                  path if they are part of a path with a {@link #WIND_NON_ZERO}winding rule or if the segments are retraced in the reverse
                  direction such that the two sets of segments cancel each
                  other out without any exterior area falling between them.
                  To determine whether segments represent true boundaries of
                  the interior of the path would require extensive calculations
                  involving all of the segments of the path and the winding
                  rule and are thus beyond the scope of this implementation.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="contains" type="boolean" line="1693">
                <params>
                    <param name="r" type="Rectangle2D"/>
                </params>
            </method>
            <javadoc line="1696">
                Tests if the interior of the specified {@link PathIterator}intersects the interior of a specified set of rectangular
                  coordinates.
                  &lt;p&gt;
                  This method provides a basic facility for implementors of
                  the {@link Shape} interface to implement support for the{@link Shape#intersects(double,double,double,double)} method.
                  &lt;p&gt;
                  This method object may conservatively return true in
                  cases where the specified rectangular area intersects a
                  segment of the path, but that segment does not represent a
                  boundary between the interior and exterior of the path.
                  Such a case may occur if some set of segments of the
                  path are retraced in the reverse direction such that the
                  two sets of segments cancel each other out without any
                  interior area between them.
                  To determine whether segments represent true boundaries of
                  the interior of the path would require extensive calculations
                  involving all of the segments of the path and the winding
                  rule and are thus beyond the scope of this implementation.                
                <param>
                    pi the specified {@code PathIterator}                    
                </param>
                <param>
                    x the specified X coordinate                    
                </param>
                <param>
                    y the specified Y coordinate                    
                </param>
                <param>
                    w the width of the specified rectangular coordinates                    
                </param>
                <param>
                    h the height of the specified rectangular coordinates                    
                </param>
                <return>
                    {@code true} if the specified {@code PathIterator} and
                      the interior of the specified set of rectangular
                      coordinates intersect each other; {@code false} otherwise.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="intersects" type="boolean" line="1725">
                <params>
                    <param name="pi" type="PathIterator"/>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="w" type="double"/>
                    <param name="h" type="double"/>
                </params>
                <scope line="1726"/>
                <scope line="1729"/>
                <declaration name="mask" type="int" line="1732"/>
                <declaration name="crossings" type="int" line="1733"/>
            </method>
            <javadoc line="1736">
                Tests if the interior of the specified {@link PathIterator}intersects the interior of a specified {@link Rectangle2D}.
                  &lt;p&gt;
                  This method provides a basic facility for implementors of
                  the {@link Shape} interface to implement support for the{@link Shape#intersects(Rectangle2D)} method.
                  &lt;p&gt;
                  This method object may conservatively return true in
                  cases where the specified rectangular area intersects a
                  segment of the path, but that segment does not represent a
                  boundary between the interior and exterior of the path.
                  Such a case may occur if some set of segments of the
                  path are retraced in the reverse direction such that the
                  two sets of segments cancel each other out without any
                  interior area between them.
                  To determine whether segments represent true boundaries of
                  the interior of the path would require extensive calculations
                  involving all of the segments of the path and the winding
                  rule and are thus beyond the scope of this implementation.                
                <param>
                    pi the specified {@code PathIterator}                    
                </param>
                <param>
                    r the specified {@code Rectangle2D}                    
                </param>
                <return>
                    {@code true} if the specified {@code PathIterator} and
                      the interior of the specified {@code Rectangle2D}intersect each other; {@code false} otherwise.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="intersects" type="boolean" line="1760">
                <params>
                    <param name="pi" type="PathIterator"/>
                    <param name="r" type="Rectangle2D"/>
                </params>
            </method>
            <javadoc line="1763">
                {@inheritDoc}&lt;p&gt;
                  This method object may conservatively return true in
                  cases where the specified rectangular area intersects a
                  segment of the path, but that segment does not represent a
                  boundary between the interior and exterior of the path.
                  Such a case may occur if some set of segments of the
                  path are retraced in the reverse direction such that the
                  two sets of segments cancel each other out without any
                  interior area between them.
                  To determine whether segments represent true boundaries of
                  the interior of the path would require extensive calculations
                  involving all of the segments of the path and the winding
                  rule and are thus beyond the scope of this implementation.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="intersects" type="boolean" line="1779">
                <params>
                    <param name="x" type="double"/>
                    <param name="y" type="double"/>
                    <param name="w" type="double"/>
                    <param name="h" type="double"/>
                </params>
                <scope line="1780"/>
                <scope line="1783"/>
                <declaration name="mask" type="int" line="1786"/>
                <declaration name="crossings" type="int" line="1787"/>
            </method>
            <javadoc line="1790">
                {@inheritDoc}&lt;p&gt;
                  This method object may conservatively return true in
                  cases where the specified rectangular area intersects a
                  segment of the path, but that segment does not represent a
                  boundary between the interior and exterior of the path.
                  Such a case may occur if some set of segments of the
                  path are retraced in the reverse direction such that the
                  two sets of segments cancel each other out without any
                  interior area between them.
                  To determine whether segments represent true boundaries of
                  the interior of the path would require extensive calculations
                  involving all of the segments of the path and the winding
                  rule and are thus beyond the scope of this implementation.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="intersects" type="boolean" line="1806">
                <params>
                    <param name="r" type="Rectangle2D"/>
                </params>
            </method>
            <javadoc line="1809">
                {@inheritDoc}&lt;p&gt;
                  The iterator for this class is not multi-threaded safe,
                  which means that this {@code Path2D} class does not
                  guarantee that modifications to the geometry of this{@code Path2D} object do not affect any iterations of
                  that geometry that are already in process.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getPathIterator" type="PathIterator" line="1817">
                <params>
                    <param name="at" type="AffineTransform"/>
                    <param name="flatness" type="double"/>
                </params>
            </method>
            <method name="clone" type="Object" line="1820"/>
            <javadoc line="1820">
                Creates a new object of the same class as this object.                
                <return>
                    a clone of this instance.                    
                </return>
                <exception>
                    OutOfMemoryError            if there is not enough memory.                    
                </exception>
                <see>
                    java.lang.Cloneable                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="SERIAL_STORAGE_FLT_ARRAY" type="byte" line="1828"/>
            <declaration name="SERIAL_STORAGE_DBL_ARRAY" type="byte" line="1829"/>
            <declaration name="SERIAL_SEG_FLT_MOVETO" type="byte" line="1830"/>
            <declaration name="SERIAL_SEG_FLT_LINETO" type="byte" line="1831"/>
            <declaration name="SERIAL_SEG_FLT_QUADTO" type="byte" line="1832"/>
            <declaration name="SERIAL_SEG_FLT_CUBICTO" type="byte" line="1833"/>
            <declaration name="SERIAL_SEG_DBL_MOVETO" type="byte" line="1834"/>
            <declaration name="SERIAL_SEG_DBL_LINETO" type="byte" line="1835"/>
            <declaration name="SERIAL_SEG_DBL_QUADTO" type="byte" line="1836"/>
            <declaration name="SERIAL_SEG_DBL_CUBICTO" type="byte" line="1837"/>
            <declaration name="SERIAL_SEG_CLOSE" type="byte" line="1838"/>
            <declaration name="SERIAL_PATH_END" type="byte" line="1839"/>
            <method name="writeObject" type="void" line="1840">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                    <param name="isdbl" type="boolean"/>
                </params>
                <declaration name="fCoords" type="float" line="1842"/>
                <declaration name="dCoords" type="double" line="1843"/>
                <scope line="1844"/>
                <scope line="1848"/>
                <declaration name="numTypes" type="int" line="1852"/>
                <declaration name="cindex" type="int" line="1857"/>
                <scope line="1858">
                    <declaration name="npoints" type="int" line="1859"/>
                    <declaration name="serialtype" type="byte" line="1860"/>
                    <scope line="1886">
                        <scope line="1887"/>
                        <scope line="1891"/>
                    </scope>
                </scope>
            </method>
            <method name="readObject" type="void" line="1899">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                    <param name="storedbl" type="boolean"/>
                </params>
                <declaration name="nT" type="int" line="1902"/>
                <declaration name="nC" type="int" line="1903"/>
                <scope line="1904"/>
                <scope line="1907"/>
                <scope line="1911"/>
                <scope line="1914"/>
                <scope line="1917"/>
                <scope line="1920">
                    <declaration name="isdbl" type="boolean" line="1921"/>
                    <declaration name="npoints" type="int" line="1922"/>
                    <declaration name="segtype" type="byte" line="1923"/>
                    <declaration name="serialtype" type="byte" line="1924"/>
                    <scope line="1972"/>
                    <scope line="1980">
                        <scope line="1981"/>
                    </scope>
                    <scope line="1985">
                        <scope line="1986"/>
                    </scope>
                </scope>
                <scope line="1992"/>
            </method>
            <class name="Iterator" line="1996">
                <implements interface="PathIterator"/>
                <declaration name="typeIdx" type="int" line="1997"/>
                <declaration name="pointIdx" type="int" line="1998"/>
                <declaration name="path" type="Path2D" line="1999"/>
                <declaration name="curvecoords" type="int" line="2000"/>
                <method name="Iterator" type="constructor" line="2001">
                    <params>
                        <param name="path" type="Path2D"/>
                    </params>
                </method>
                <method name="getWindingRule" type="int" line="2004"/>
                <method name="isDone" type="boolean" line="2007"/>
                <method name="next" type="void" line="2010">
                    <declaration name="type" type="int" line="2011"/>
                </method>
            </class>
        </class>
    </source>