<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.awt.image.ColorModel"/>
        <import package="sun.awt.AWTAccessor"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.SunToolkit"/>
        <class name="GraphicsDevice" line="35">
            <comment line="82">
                tracks which AppContext                
            </comment>
            <comment line="83">
                created the FS window                
            </comment>
            <comment line="84">
                this lock is used for making synchronous changes to the AppContext&apos;s                
            </comment>
            <comment line="85">
                current full screen window                
            </comment>
            <javadoc line="35">
                The &lt;code&gt;GraphicsDevice&lt;/code&gt; class describes the graphics devices
                  that might be available in a particular graphics environment.  These
                  include screen and printer devices. Note that there can be many screens
                  and many printers in an instance of {@link GraphicsEnvironment}. Each
                  graphics device has one or more {@link GraphicsConfiguration} objects
                  associated with it.  These objects specify the different configurations
                  in which the &lt;code&gt;GraphicsDevice&lt;/code&gt; can be used.
                  &lt;p&gt;
                  In a multi-screen environment, the &lt;code&gt;GraphicsConfiguration&lt;/code&gt;
                  objects can be used to render components on multiple screens.  The
                  following code sample demonstrates how to create a &lt;code&gt;JFrame&lt;/code&gt;
                  object for each &lt;code&gt;GraphicsConfiguration&lt;/code&gt; on each screen
                  device in the &lt;code&gt;GraphicsEnvironment&lt;/code&gt;:
                  &lt;pre&gt;
                  GraphicsEnvironment ge = GraphicsEnvironment.
                  getLocalGraphicsEnvironment();
                  GraphicsDevice[] gs = ge.getScreenDevices();
                  for (int j = 0; j &lt; gs.length; j++) {
                  GraphicsDevice gd = gs[j];
                  GraphicsConfiguration[] gc =
                  gd.getConfigurations();
                  for (int i=0; i &lt; gc.length; i++) {
                  JFrame f = new
                  JFrame(gs[j].getDefaultConfiguration());
                  Canvas c = new Canvas(gc[i]);
                  Rectangle gcBounds = gc[i].getBounds();
                  int xoffs = gcBounds.x;
                  int yoffs = gcBounds.y;
                  f.getContentPane().add(c);
                  f.setLocation((i50)+xoffs, (i60)+yoffs);
                  f.show();
                  }
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;
                  For more information on full-screen exclusive mode API, see the
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/fullscreen/index.html&quot;&gt;
                  Full-Screen Exclusive Mode API Tutorial&lt;/a&gt;.                
                <see>
                    GraphicsEnvironment                    
                </see>
                <see>
                    GraphicsConfiguration                    
                </see>
            </javadoc>
            <declaration name="fullScreenWindow" type="Window" line="80"/>
            <declaration name="fullScreenAppContext" type="AppContext" line="81"/>
            <declaration name="fsAppContextLock" type="Object" line="85"/>
            <declaration name="windowedModeBounds" type="Rectangle" line="87"/>
            <javadoc line="89">
                This is an abstract class that cannot be instantiated directly.
                  Instances must be obtained from a suitable factory or query method.                
                <see>
                    GraphicsEnvironment#getScreenDevices                    
                </see>
                <see>
                    GraphicsEnvironment#getDefaultScreenDevice                    
                </see>
                <see>
                    GraphicsConfiguration#getDevice                    
                </see>
            </javadoc>
            <method name="GraphicsDevice" type="constructor" line="96"/>
            <declaration name="TYPE_RASTER_SCREEN" type="int" line="99"/>
            <javadoc line="99">
                Device is a raster screen.                
            </javadoc>
            <declaration name="TYPE_PRINTER" type="int" line="104"/>
            <javadoc line="104">
                Device is a printer.                
            </javadoc>
            <declaration name="TYPE_IMAGE_BUFFER" type="int" line="109"/>
            <javadoc line="109">
                Device is an image buffer.  This buffer can reside in device
                  or system memory but it is not physically viewable by the user.                
            </javadoc>
            <javadoc line="115">
                Kinds of translucency supported by the underlying system.                
                <see>
                    #isWindowTranslucencySupported                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <javadoc line="123">
                Represents support in the underlying system for windows each pixel
                  of which is guaranteed to be either completely opaque, with
                  an alpha value of 1.0, or completely transparent, with an alpha
                  value of 0.0.                
            </javadoc>
            <javadoc line="130">
                Represents support in the underlying system for windows all of
                  the pixels of which have the same alpha value between or including
                  0.0 and 1.0.                
            </javadoc>
            <javadoc line="136">
                Represents support in the underlying system for windows that
                  contain or might contain pixels with arbitrary alpha values
                  between and including 0.0 and 1.0.                
            </javadoc>
            <method name="getType" type="int" line="144"/>
            <javadoc line="144">
                Returns the type of this &lt;code&gt;GraphicsDevice&lt;/code&gt;.                
                <return>
                    the type of this <code>GraphicsDevice</code>, which can
                      either be TYPE_RASTER_SCREEN, TYPE_PRINTER or TYPE_IMAGE_BUFFER.                    
                </return>
                <see>
                    #TYPE_RASTER_SCREEN                    
                </see>
                <see>
                    #TYPE_PRINTER                    
                </see>
                <see>
                    #TYPE_IMAGE_BUFFER                    
                </see>
            </javadoc>
            <method name="getIDstring" type="String" line="154"/>
            <javadoc line="154">
                Returns the identification string associated with this
                  &lt;code&gt;GraphicsDevice&lt;/code&gt;.
                  &lt;p&gt;
                  A particular program might use more than one
                  &lt;code&gt;GraphicsDevice&lt;/code&gt; in a &lt;code&gt;GraphicsEnvironment&lt;/code&gt;.
                  This method returns a &lt;code&gt;String&lt;/code&gt; identifying a
                  particular &lt;code&gt;GraphicsDevice&lt;/code&gt; in the local
                  &lt;code&gt;GraphicsEnvironment&lt;/code&gt;.  Although there is
                  no public method to set this &lt;code&gt;String&lt;/code&gt;, a programmer can
                  use the &lt;code&gt;String&lt;/code&gt; for debugging purposes.  Vendors of
                  the Java&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; Runtime Environment can
                  format the return value of the &lt;code&gt;String&lt;/code&gt;.  To determine
                  how to interpret the value of the &lt;code&gt;String&lt;/code&gt;, contact the
                  vendor of your Java Runtime.  To find out who the vendor is, from
                  your program, call the{@link System#getProperty(String) getProperty} method of the
                  System class with &quot;java.vendor&quot;.                
                <return>
                    a <code>String</code> that is the identification
                      of this <code>GraphicsDevice</code>.                    
                </return>
            </javadoc>
            <method name="getConfigurations" type="GraphicsConfiguration[]" line="177"/>
            <javadoc line="177">
                Returns all of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt;
                  objects associated with this &lt;code&gt;GraphicsDevice&lt;/code&gt;.                
                <return>
                    an array of <code>GraphicsConfiguration</code>
                      objects that are associated with this
                      <code>GraphicsDevice</code>.                    
                </return>
            </javadoc>
            <method name="getDefaultConfiguration" type="GraphicsConfiguration" line="186"/>
            <javadoc line="186">
                Returns the default &lt;code&gt;GraphicsConfiguration&lt;/code&gt;
                  associated with this &lt;code&gt;GraphicsDevice&lt;/code&gt;.                
                <return>
                    the default <code>GraphicsConfiguration</code>
                      of this <code>GraphicsDevice</code>.                    
                </return>
            </javadoc>
            <javadoc line="194">
                Returns the &quot;best&quot; configuration possible that passes the
                  criteria defined in the {@link GraphicsConfigTemplate}.                
                <param>
                    gct the <code>GraphicsConfigTemplate</code> object
                      used to obtain a valid <code>GraphicsConfiguration</code>                    
                </param>
                <return>
                    a <code>GraphicsConfiguration</code> that passes
                      the criteria defined in the specified
                      <code>GraphicsConfigTemplate</code>.                    
                </return>
                <see>
                    GraphicsConfigTemplate                    
                </see>
            </javadoc>
            <method name="getBestConfiguration" type="GraphicsConfiguration" line="205">
                <params>
                    <param name="gct" type="GraphicsConfigTemplate"/>
                </params>
                <declaration name="configs" type="GraphicsConfiguration[]" line="206"/>
            </method>
            <javadoc line="210">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;GraphicsDevice&lt;/code&gt;
                  supports full-screen exclusive mode.
                  If a SecurityManager is installed, its
                  &lt;code&gt;checkPermission&lt;/code&gt; method will be called
                  with &lt;code&gt;AWTPermission(&quot;fullScreenExclusive&quot;)&lt;/code&gt;.
                  &lt;code&gt;isFullScreenSupported&lt;/code&gt; returns true only if
                  that permission is granted.                
                <return>
                    whether full-screen exclusive mode is available for
                      this graphics device                    
                </return>
                <see>
                    java.awt.AWTPermission                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFullScreenSupported" type="boolean" line="223"/>
            <javadoc line="227">
                Enter full-screen mode, or return to windowed mode.  The entered
                  full-screen mode may be either exclusive or simulated.  Exclusive
                  mode is only available if &lt;code&gt;isFullScreenSupported&lt;/code&gt;
                  returns &lt;code&gt;true&lt;/code&gt;.
                  &lt;p&gt;
                  Exclusive mode implies:
                  &lt;ul&gt;
                  &lt;li&gt;Windows cannot overlap the full-screen window.  All other application
                  windows will always appear beneath the full-screen window in the Z-order.
                  &lt;li&gt;There can be only one full-screen window on a device at any time,
                  so calling this method while there is an existing full-screen Window
                  will cause the existing full-screen window to
                  return to windowed mode.
                  &lt;li&gt;Input method windows are disabled.  It is advisable to call
                  &lt;code&gt;Component.enableInputMethods(false)&lt;/code&gt; to make a component
                  a non-client of the input method framework.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  The simulated full-screen mode places and resizes the window to the maximum
                  possible visible area of the screen. However, the native windowing system
                  may modify the requested geometry-related data, so that the {@code Window} object
                  is placed and sized in a way that corresponds closely to the desktop settings.
                  &lt;p&gt;
                  When entering full-screen mode, if the window to be used as a
                  full-screen window is not visible, this method will make it visible.
                  It will remain visible when returning to windowed mode.
                  &lt;p&gt;
                  When entering full-screen mode, all the translucency effects are reset for
                  the window. Its shape is set to {@code null}, the opacity value is set to
                  1.0f, and the background color alpha is set to 255 (completely opaque).
                  These values are not restored when returning to windowed mode.
                  &lt;p&gt;
                  It is unspecified and platform-dependent how decorated windows operate
                  in full-screen mode. For this reason, it is recommended to turn off
                  the decorations in a {@code Frame} or {@code Dialog} object by using the{@code setUndecorated} method.
                  &lt;p&gt;
                  When returning to windowed mode from an exclusive full-screen window,
                  any display changes made by calling {@code setDisplayMode} are
                  automatically restored to their original state.                
                <param>
                    w a window to use as the full-screen window; {@code null}if returning to windowed mode.  Some platforms expect the
                      fullscreen window to be a top-level component (i.e., a {@code Frame});
                      therefore it is preferable to use a {@code Frame} here rather than a{@code Window}.                    
                </param>
                <see>
                    #isFullScreenSupported                    
                </see>
                <see>
                    #getFullScreenWindow                    
                </see>
                <see>
                    #setDisplayMode                    
                </see>
                <see>
                    Component#enableInputMethods                    
                </see>
                <see>
                    Component#setVisible                    
                </see>
                <see>
                    Frame#setUndecorated                    
                </see>
                <see>
                    Dialog#setUndecorated                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setFullScreenWindow" type="void" line="285">
                <params>
                    <param name="w" type="Window"/>
                </params>
                <comment line="301">
                    if the window went into fs mode before it was realized it may                    
                </comment>
                <comment line="302">
                    have (0,0) dimensions                    
                </comment>
                <comment line="307">
                    Set the full screen window                    
                </comment>
                <comment line="309">
                    Associate fullscreen window with current AppContext                    
                </comment>
                <comment line="319">
                    Note that we use the graphics configuration of the device,                    
                </comment>
                <comment line="320">
                    not the window&apos;s, because we&apos;re setting the fs window for                    
                </comment>
                <comment line="321">
                    this device.                    
                </comment>
                <scope line="286">
                    <scope line="287"/>
                    <scope line="290"/>
                    <scope line="293">
                        <declaration name="bgColor" type="Color" line="294"/>
                    </scope>
                </scope>
                <scope line="300"/>
                <scope line="308">
                    <scope line="310"/>
                    <scope line="312"/>
                </scope>
                <scope line="317">
                    <declaration name="screenBounds" type="Rectangle" line="322"/>
                </scope>
            </method>
            <javadoc line="330">
                Returns the &lt;code&gt;Window&lt;/code&gt; object representing the
                  full-screen window if the device is in full-screen mode.                
                <return>
                    the full-screen window, or <code>null</code> if the device is
                      not in full-screen mode.                    
                </return>
                <see>
                    #setFullScreenWindow(Window)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getFullScreenWindow" type="Window" line="339">
                <comment line="342">
                    Only return a handle to the current fs window if we are in the                    
                </comment>
                <comment line="343">
                    same AppContext that set the fs window                    
                </comment>
                <declaration name="returnWindow" type="Window" line="340"/>
                <scope line="341">
                    <scope line="344"/>
                </scope>
            </method>
            <javadoc line="351">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;GraphicsDevice&lt;/code&gt;
                  supports low-level display changes.
                  On some platforms low-level display changes may only be allowed in
                  full-screen exclusive mode (i.e., if {@link #isFullScreenSupported()}returns {@code true} and the application has already entered
                  full-screen mode using {@link #setFullScreenWindow}).                
                <return>
                    whether low-level display changes are supported for this
                      graphics device.                    
                </return>
                <see>
                    #isFullScreenSupported                    
                </see>
                <see>
                    #setDisplayMode                    
                </see>
                <see>
                    #setFullScreenWindow                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isDisplayChangeSupported" type="boolean" line="365"/>
            <javadoc line="369">
                Sets the display mode of this graphics device. This is only allowed
                  if {@link #isDisplayChangeSupported()} returns {@code true} and may
                  require first entering full-screen exclusive mode using{@link #setFullScreenWindow} providing that full-screen exclusive mode is
                  supported (i.e., {@link #isFullScreenSupported()} returns{@code true}).
                  &lt;p&gt;
                  The display mode must be one of the display modes returned by{@link #getDisplayModes()}, with one exception: passing a display mode
                  with {@link DisplayMode#REFRESH_RATE_UNKNOWN} refresh rate will result in
                  selecting a display mode from the list of available display modes with
                  matching width, height and bit depth.
                  However, passing a display mode with {@link DisplayMode#BIT_DEPTH_MULTI}for bit depth is only allowed if such mode exists in the list returned by{@link #getDisplayModes()}.
                  &lt;p&gt;
                  Example code:
                  &lt;pre&gt;&lt;code&gt;
                  Frame frame;
                  DisplayMode newDisplayMode;
                  GraphicsDevice gd;
                  // create a Frame, select desired DisplayMode from the list of modes
                  // returned by gd.getDisplayModes() ...
                  if (gd.isFullScreenSupported()) {
                  gd.setFullScreenWindow(frame);
                  } else {
                  // proceed in non-full-screen mode
                  frame.setSize(...);
                  frame.setLocation(...);
                  frame.setVisible(true);
                  }
                  if (gd.isDisplayChangeSupported()) {
                  gd.setDisplayMode(newDisplayMode);
                  }
                  &lt;/code&gt;&lt;/pre&gt;                
                <param>
                    dm The new display mode of this graphics device.                    
                </param>
                <exception>
                    IllegalArgumentException if the <code>DisplayMode</code>
                      supplied is <code>null</code>, or is not available in the array returned
                      by <code>getDisplayModes</code>                    
                </exception>
                <exception>
                    UnsupportedOperationException if
                      <code>isDisplayChangeSupported</code> returns <code>false</code>                    
                </exception>
                <see>
                    #getDisplayMode                    
                </see>
                <see>
                    #getDisplayModes                    
                </see>
                <see>
                    #isDisplayChangeSupported                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setDisplayMode" type="void" line="420">
                <params>
                    <param name="dm" type="DisplayMode"/>
                </params>
            </method>
            <javadoc line="424">
                Returns the current display mode of this
                  &lt;code&gt;GraphicsDevice&lt;/code&gt;.
                  The returned display mode is allowed to have a refresh rate{@link DisplayMode#REFRESH_RATE_UNKNOWN} if it is indeterminate.
                  Likewise, the returned display mode is allowed to have a bit depth{@link DisplayMode#BIT_DEPTH_MULTI} if it is indeterminate or if multiple
                  bit depths are supported.                
                <return>
                    the current display mode of this graphics device.                    
                </return>
                <see>
                    #setDisplayMode(DisplayMode)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getDisplayMode" type="DisplayMode" line="436">
                <declaration name="gc" type="GraphicsConfiguration" line="437"/>
                <declaration name="r" type="Rectangle" line="438"/>
                <declaration name="cm" type="ColorModel" line="439"/>
            </method>
            <javadoc line="443">
                Returns all display modes available for this
                  &lt;code&gt;GraphicsDevice&lt;/code&gt;.
                  The returned display modes are allowed to have a refresh rate{@link DisplayMode#REFRESH_RATE_UNKNOWN} if it is indeterminate.
                  Likewise, the returned display modes are allowed to have a bit depth{@link DisplayMode#BIT_DEPTH_MULTI} if it is indeterminate or if multiple
                  bit depths are supported.                
                <return>
                    all of the display modes available for this graphics device.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getDisplayModes" type="DisplayMode[]" line="454"/>
            <javadoc line="458">
                This method returns the number of bytes available in
                  accelerated memory on this device.
                  Some images are created or cached
                  in accelerated memory on a first-come,
                  first-served basis.  On some operating systems,
                  this memory is a finite resource.  Calling this method
                  and scheduling the creation and flushing of images carefully may
                  enable applications to make the most efficient use of
                  that finite resource.
                  &lt;br&gt;
                  Note that the number returned is a snapshot of how much
                  memory is available; some images may still have problems
                  being allocated into that memory.  For example, depending
                  on operating system, driver, memory configuration, and
                  thread situations, the full extent of the size reported
                  may not be available for a given image.  There are further
                  inquiry methods on the {@link ImageCapabilities} object
                  associated with a VolatileImage that can be used to determine
                  whether a particular VolatileImage has been created in accelerated
                  memory.                
                <return>
                    number of bytes available in accelerated memory.
                      A negative return value indicates that the amount of accelerated memory
                      on this GraphicsDevice is indeterminate.                    
                </return>
                <see>
                    java.awt.image.VolatileImage#flush                    
                </see>
                <see>
                    ImageCapabilities#isAccelerated                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getAvailableAcceleratedMemory" type="int" line="486"/>
            <javadoc line="490">
                Returns whether the given level of translucency is supported by
                  this graphics device.                
                <param>
                    translucencyKind a kind of translucency support                    
                </param>
                <return>
                    whether the given translucency kind is supported                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="isWindowTranslucencySupported" type="boolean" line="499">
                <params>
                    <param name="translucencyKind" type="WindowTranslucency"/>
                </params>
            </method>
            <javadoc line="511">
                Returns whether the windowing system supports changing the shape
                  of top-level windows.
                  Note that this method may sometimes return true, but the native
                  windowing system may still not support the concept of
                  shaping (due to the bugs in the windowing system).                
            </javadoc>
            <method name="isWindowShapingSupported" type="boolean" line="518">
                <declaration name="curToolkit" type="Toolkit" line="519"/>
                <scope line="520"/>
            </method>
            <javadoc line="526">
                Returns whether the windowing system supports changing the opacity
                  value of top-level windows.
                  Note that this method may sometimes return true, but the native
                  windowing system may still not support the concept of
                  translucency (due to the bugs in the windowing system).                
            </javadoc>
            <method name="isWindowOpacitySupported" type="boolean" line="533">
                <declaration name="curToolkit" type="Toolkit" line="534"/>
                <scope line="535"/>
            </method>
            <method name="isWindowPerpixelTranslucencySupported" type="boolean" line="541">
                <comment line="542">
                    Per-pixel alpha is supported if all the conditions are TRUE:
                        1. The toolkit is a sort of SunToolkit
                        2. The toolkit supports translucency in general
                            (isWindowTranslucencySupported())
                        3. There&apos;s at least one translucency-capable
                            GraphicsConfiguration                    
                </comment>
                <comment line="558">
                    TODO: cache translucency capable GC                    
                </comment>
                <declaration name="curToolkit" type="Toolkit" line="550"/>
                <scope line="551"/>
                <scope line="554"/>
            </method>
            <method name="getTranslucencyCapableGC" type="GraphicsConfiguration" line="562">
                <comment line="563">
                    If the default GC supports translucency return true.                    
                </comment>
                <comment line="564">
                    It is important to optimize the verification this way,                    
                </comment>
                <comment line="565">
                    see CR 6661196 for more details.                    
                </comment>
                <comment line="571">
                    ... otherwise iterate through all the GCs.                    
                </comment>
                <declaration name="defaultGC" type="GraphicsConfiguration" line="566"/>
                <scope line="567"/>
                <declaration name="configs" type="GraphicsConfiguration[]" line="572"/>
                <scope line="573">
                    <scope line="574"/>
                </scope>
            </method>
        </class>
    </source>