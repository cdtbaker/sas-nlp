<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt.image">
        <import package="java.awt.Color"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.GraphicsDevice"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.ImageCapabilities"/>
        <import package="java.awt.Toolkit"/>
        <import package="java.awt.Transparency"/>
        <class name="VolatileImage" line="38">
            <extends class="Image"/>
            <comment line="137">
                Return codes for validate() method                
            </comment>
            <comment line="183">
                Image overrides                
            </comment>
            <comment line="222">
                REMIND: if we want any decent performance for getScaledInstance(),
                 we should override the Image implementation of it...                
            </comment>
            <comment line="246">
                Volatile management methods                
            </comment>
            <implements interface="Transparency"/>
            <javadoc line="38">
                VolatileImage is an image which can lose its
                  contents at any time due to circumstances beyond the control of the
                  application (e.g., situations caused by the operating system or by
                  other applications). Because of the potential for hardware acceleration,
                  a VolatileImage object can have significant performance benefits on
                  some platforms.
                  &lt;p&gt;
                  The drawing surface of an image (the memory where the image contents
                  actually reside) can be lost or invalidated, causing the contents of that
                  memory to go away.  The drawing surface thus needs to be restored
                  or recreated and the contents of that surface need to be
                  re-rendered.  VolatileImage provides an interface for
                  allowing the user to detect these problems and fix them
                  when they occur.
                  &lt;p&gt;
                  When a VolatileImage object is created, limited system resources
                  such as video memory (VRAM) may be allocated in order to support
                  the image.
                  When a VolatileImage object is no longer used, it may be
                  garbage-collected and those system resources will be returned,
                  but this process does not happen at guaranteed times.
                  Applications that create many VolatileImage objects (for example,
                  a resizing window may force recreation of its back buffer as the
                  size changes) may run out of optimal system resources for new
                  VolatileImage objects simply because the old objects have not
                  yet been removed from the system.
                  (New VolatileImage objects may still be created, but they
                  may not perform as well as those created in accelerated
                  memory).
                  The flush method may be called at any time to proactively release
                  the resources used by a VolatileImage so that it does not prevent
                  subsequent VolatileImage objects from being accelerated.
                  In this way, applications can have more control over the state
                  of the resources taken up by obsolete VolatileImage objects.
                  &lt;p&gt;
                  This image should not be subclassed directly but should be created
                  by using the {@link java.awt.Component#createVolatileImage(int,int)Component.createVolatileImage} or{@link java.awt.GraphicsConfiguration#createCompatibleVolatileImage(int,int)GraphicsConfiguration.createCompatibleVolatileImage(int, int)} methods.
                  &lt;P&gt;
                  An example of using a VolatileImage object follows:
                  &lt;pre&gt;
                  // image creation
                  VolatileImage vImg = createVolatileImage(w, h);
                  // rendering to the image
                  void renderOffscreen() {
                  do {
                  if (vImg.validate(getGraphicsConfiguration()) ==
                  VolatileImage.IMAGE_INCOMPATIBLE)
                  {
                  // old vImg doesn&apos;t work with new GraphicsConfig; re-create it
                  vImg = createVolatileImage(w, h);
                  }
                  Graphics2D g = vImg.createGraphics();
                  //
                  // miscellaneous rendering commands...
                  //
                  g.dispose();
                  } while (vImg.contentsLost());
                  }
                  // copying from the image (here, gScreen is the Graphics
                  // object for the onscreen window)
                  do {
                  int returnCode = vImg.validate(getGraphicsConfiguration());
                  if (returnCode == VolatileImage.IMAGE_RESTORED) {
                  // Contents need to be restored
                  renderOffscreen();      // restore contents
                  } else if (returnCode == VolatileImage.IMAGE_INCOMPATIBLE) {
                  // old vImg doesn&apos;t work with new GraphicsConfig; re-create it
                  vImg = createVolatileImage(w, h);
                  renderOffscreen();
                  }
                  gScreen.drawImage(vImg, 0, 0, this);
                  } while (vImg.contentsLost());
                  &lt;/pre&gt;
                  &lt;P&gt;
                  Note that this class subclasses from the {@link Image} class, which
                  includes methods that take an {@link ImageObserver} parameter for
                  asynchronous notifications as information is received from
                  a potential {@link ImageProducer}.  Since this &lt;code&gt;VolatileImage&lt;/code&gt;
                  is not loaded from an asynchronous source, the various methods that take
                  an &lt;code&gt;ImageObserver&lt;/code&gt; parameter will behave as if the data has
                  already been obtained from the &lt;code&gt;ImageProducer&lt;/code&gt;.
                  Specifically, this means that the return values from such methods
                  will never indicate that the information is not yet available and
                  the &lt;code&gt;ImageObserver&lt;/code&gt; used in such methods will never
                  need to be recorded for an asynchronous callback notification.                
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="IMAGE_OK" type="int" line="138"/>
            <javadoc line="138">
                Validated image is ready to use as-is.                
            </javadoc>
            <declaration name="IMAGE_RESTORED" type="int" line="143"/>
            <javadoc line="143">
                Validated image has been restored and is now ready to use.
                  Note that restoration causes contents of the image to be lost.                
            </javadoc>
            <declaration name="IMAGE_INCOMPATIBLE" type="int" line="149"/>
            <javadoc line="149">
                Validated image is incompatible with supplied
                  &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object and should be
                  re-created as appropriate.  Usage of the image as-is
                  after receiving this return code from &lt;code&gt;validate&lt;/code&gt;
                  is undefined.                
            </javadoc>
            <method name="getSnapshot" type="BufferedImage" line="158"/>
            <javadoc line="158">
                Returns a static snapshot image of this object.  The
                  &lt;code&gt;BufferedImage&lt;/code&gt; returned is only current with
                  the &lt;code&gt;VolatileImage&lt;/code&gt; at the time of the request
                  and will not be updated with any future changes to the
                  &lt;code&gt;VolatileImage&lt;/code&gt;.                
                <return>
                    a {@link BufferedImage} representation of this
                      &lt;code&gt;VolatileImage&lt;/code&gt;                    
                </return>
                <see>
                    BufferedImage                    
                </see>
            </javadoc>
            <method name="getWidth" type="int" line="170"/>
            <javadoc line="170">
                Returns the width of the &lt;code&gt;VolatileImage&lt;/code&gt;.                
                <return>
                    the width of this &lt;code&gt;VolatileImage&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getHeight" type="int" line="176"/>
            <javadoc line="176">
                Returns the height of the &lt;code&gt;VolatileImage&lt;/code&gt;.                
                <return>
                    the height of this &lt;code&gt;VolatileImage&lt;/code&gt;.                    
                </return>
            </javadoc>
            <javadoc line="184">
                This returns an ImageProducer for this VolatileImage.
                  Note that the VolatileImage object is optimized for
                  rendering operations and blitting to the screen or other
                  VolatileImage objects, as opposed to reading back the
                  pixels of the image.  Therefore, operations such as
                  &lt;code&gt;getSource&lt;/code&gt; may not perform as fast as
                  operations that do not rely on reading the pixels.
                  Note also that the pixel values read from the image are current
                  with those in the image only at the time that they are
                  retrieved. This method takes a snapshot
                  of the image at the time the request is made and the
                  ImageProducer object returned works with
                  that static snapshot image, not the original VolatileImage.
                  Calling getSource()
                  is equivalent to calling getSnapshot().getSource().                
                <return>
                    an {@link ImageProducer} that can be used to produce the
                      pixels for a &lt;code&gt;BufferedImage&lt;/code&gt; representation of
                      this Image.                    
                </return>
                <see>
                    ImageProducer                    
                </see>
                <see>
                    #getSnapshot()                    
                </see>
            </javadoc>
            <method name="getSource" type="ImageProducer" line="206">
                <comment line="208">
                    REMIND: Make sure this functionality is in line with the
                     spec.  In particular, we are returning the Source for a
                     static image (the snapshot), not a changing image (the
                     VolatileImage).  So if the user expects the Source to be
                     up-to-date with the current contents of the VolatileImage,
                     they will be disappointed...
                     REMIND: This assumes that getSnapshot() returns something
                     valid and not the default null object returned by this class
                     (so it assumes that the actual VolatileImage object is
                     subclassed off something that does the right thing
                     (e.g., SunVolatileImage).                    
                </comment>
            </method>
            <javadoc line="224">
                This method returns a {@link Graphics2D}, but is here
                  for backwards compatibility.  {@link #createGraphics() createGraphics} is more
                  convenient, since it is declared to return a
                  &lt;code&gt;Graphics2D&lt;/code&gt;.                
                <return>
                    a &lt;code&gt;Graphics2D&lt;/code&gt;, which can be used to draw into
                      this image.                    
                </return>
            </javadoc>
            <method name="getGraphics" type="Graphics" line="232"/>
            <method name="createGraphics" type="Graphics2D" line="236"/>
            <javadoc line="236">
                Creates a &lt;code&gt;Graphics2D&lt;/code&gt;, which can be used to draw into
                  this &lt;code&gt;VolatileImage&lt;/code&gt;.                
                <return>
                    a &lt;code&gt;Graphics2D&lt;/code&gt;, used for drawing into this
                      image.                    
                </return>
            </javadoc>
            <method name="validate" type="int" line="247"/>
            <javadoc line="247">
                Attempts to restore the drawing surface of the image if the surface
                  had been lost since the last &lt;code&gt;validate&lt;/code&gt; call.  Also
                  validates this image against the given GraphicsConfiguration
                  parameter to see whether operations from this image to the
                  GraphicsConfiguration are compatible.  An example of an
                  incompatible combination might be a situation where a VolatileImage
                  object was created on one graphics device and then was used
                  to render to a different graphics device.  Since VolatileImage
                  objects tend to be very device-specific, this operation might
                  not work as intended, so the return code from this validate
                  call would note that incompatibility.  A null or incorrect
                  value for gc may cause incorrect values to be returned from
                  &lt;code&gt;validate&lt;/code&gt; and may cause later problems with rendering.                
                <param>
                    gc   a &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object for this
                      image to be validated against.  A null gc implies that the
                      validate method should skip the compatibility test.                    
                </param>
                <return>
                    &lt;code&gt;IMAGE_OK&lt;/code&gt; if the image did not need validation&lt;BR&gt;
                      &lt;code&gt;IMAGE_RESTORED&lt;/code&gt; if the image needed restoration.
                      Restoration implies that the contents of the image may have
                      been affected and the image may need to be re-rendered.&lt;BR&gt;
                      &lt;code&gt;IMAGE_INCOMPATIBLE&lt;/code&gt; if the image is incompatible
                      with the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object passed
                      into the &lt;code&gt;validate&lt;/code&gt; method.  Incompatibility
                      implies that the image may need to be recreated with a
                      new &lt;code&gt;Component&lt;/code&gt; or
                      &lt;code&gt;GraphicsConfiguration&lt;/code&gt; in order to get an image
                      that can be used successfully with this
                      &lt;code&gt;GraphicsConfiguration&lt;/code&gt;.
                      An incompatible image is not checked for whether restoration
                      was necessary, so the state of the image is unchanged
                      after a return value of &lt;code&gt;IMAGE_INCOMPATIBLE&lt;/code&gt;
                      and this return value implies nothing about whether the
                      image needs to be restored.                    
                </return>
                <see>
                    java.awt.GraphicsConfiguration                    
                </see>
                <see>
                    java.awt.Component                    
                </see>
                <see>
                    #IMAGE_OK                    
                </see>
                <see>
                    #IMAGE_RESTORED                    
                </see>
                <see>
                    #IMAGE_INCOMPATIBLE                    
                </see>
            </javadoc>
            <method name="contentsLost" type="boolean" line="290"/>
            <javadoc line="290">
                Returns &lt;code&gt;true&lt;/code&gt; if rendering data was lost since last
                  &lt;code&gt;validate&lt;/code&gt; call.  This method should be called by the
                  application at the end of any series of rendering operations to
                  or from the image to see whether
                  the image needs to be validated and the rendering redone.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the drawing surface needs to be restored;
                      &lt;code&gt;false&lt;/code&gt; otherwise.                    
                </return>
            </javadoc>
            <method name="getCapabilities" type="ImageCapabilities" line="301"/>
            <javadoc line="301">
                Returns an ImageCapabilities object which can be
                  inquired as to the specific capabilities of this
                  VolatileImage.  This would allow programmers to find
                  out more runtime information on the specific VolatileImage
                  object that they have created.  For example, the user
                  might create a VolatileImage but the system may have
                  no video memory left for creating an image of that
                  size, so although the object is a VolatileImage, it is
                  not as accelerated as other VolatileImage objects on
                  this platform might be.  The user might want that
                  information to find other solutions to their problem.                
                <return>
                    an &lt;code&gt;ImageCapabilities&lt;/code&gt; object that contains
                      the capabilities of this &lt;code&gt;VolatileImage&lt;/code&gt;.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="transparency" type="int" line="319"/>
            <javadoc line="319">
                The transparency value with which this image was created.                
                <see>
                    java.awt.GraphicsConfiguration#createCompatibleVolatileImage(int,int,int)                    
                </see>
                <see>
                    java.awt.GraphicsConfiguration#createCompatibleVolatileImage(int,int,ImageCapabilities,int)                    
                </see>
                <see>
                    Transparency                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <javadoc line="330">
                Returns the transparency.  Returns either OPAQUE, BITMASK,
                  or TRANSLUCENT.                
                <return>
                    the transparency of this &lt;code&gt;VolatileImage&lt;/code&gt;.                    
                </return>
                <see>
                    Transparency#OPAQUE                    
                </see>
                <see>
                    Transparency#BITMASK                    
                </see>
                <see>
                    Transparency#TRANSLUCENT                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getTransparency" type="int" line="339"/>
        </class>
    </source>