<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt.image">
        <import package="java.awt.BufferCapabilities"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.Image"/>
        <class name="BufferStrategy" line="32">
            <javadoc line="32">
                The &lt;code&gt;BufferStrategy&lt;/code&gt; class represents the mechanism with which
                  to organize complex memory on a particular &lt;code&gt;Canvas&lt;/code&gt; or
                  &lt;code&gt;Window&lt;/code&gt;.  Hardware and software limitations determine whether and
                  how a particular buffer strategy can be implemented.  These limitations
                  are detectible through the capabilities of the
                  &lt;code&gt;GraphicsConfiguration&lt;/code&gt; used when creating the
                  &lt;code&gt;Canvas&lt;/code&gt; or &lt;code&gt;Window&lt;/code&gt;.
                  &lt;p&gt;
                  It is worth noting that the terms &lt;i&gt;buffer&lt;/i&gt; and &lt;i&gt;surface&lt;/i&gt; are meant
                  to be synonymous: an area of contiguous memory, either in video device
                  memory or in system memory.
                  &lt;p&gt;
                  There are several types of complex buffer strategies, including
                  sequential ring buffering and blit buffering.
                  Sequential ring buffering (i.e., double or triple
                  buffering) is the most common; an application draws to a single &lt;i&gt;back
                  buffer&lt;/i&gt; and then moves the contents to the front (display) in a single
                  step, either by copying the data or moving the video pointer.
                  Moving the video pointer exchanges the buffers so that the first buffer
                  drawn becomes the &lt;i&gt;front buffer&lt;/i&gt;, or what is currently displayed on the
                  device; this is called &lt;i&gt;page flipping&lt;/i&gt;.
                  &lt;p&gt;
                  Alternatively, the contents of the back buffer can be copied, or
                  &lt;i&gt;blitted&lt;/i&gt; forward in a chain instead of moving the video pointer.
                  &lt;p&gt;
                  &lt;pre&gt;
                  Double buffering:
                           
                            ------&gt;          
                  [To display] &lt;----  Front B    Show   Back B.  &lt;---- Rendering
                            &lt;------          
                           
                  Triple buffering:
                  [To                       
                  display]           --------+---------+------&gt;          
                  &lt;----  Front B    Show   Mid. B.          Back B.  &lt;---- Rendering
                            &lt;------           &lt;-----          
                                   
                  &lt;/pre&gt;
                  &lt;p&gt;
                  Here is an example of how buffer strategies can be created and used:
                  &lt;pre&gt;&lt;code&gt;
                  // Check the capabilities of the GraphicsConfiguration
                  ...
                  // Create our component
                  Window w = new Window(gc);
                  // Show our window
                  w.setVisible(true);
                  // Create a general double-buffering strategy
                  w.createBufferStrategy(2);
                  BufferStrategy strategy = w.getBufferStrategy();
                  // Main loop
                  while (!done) {
                  // Prepare for rendering the next frame
                  // ...
                  // Render single frame
                  do {
                  // The following loop ensures that the contents of the drawing buffer
                  // are consistent in case the underlying surface was recreated
                  do {
                  // Get a new graphics context every time through the loop
                  // to make sure the strategy is validated
                  Graphics graphics = strategy.getDrawGraphics();
                  // Render to graphics
                  // ...
                  // Dispose the graphics
                  graphics.dispose();
                  // Repeat the rendering if the drawing buffer contents
                  // were restored
                  } while (strategy.contentsRestored());
                  // Display the buffer
                  strategy.show();
                  // Repeat the rendering if the drawing buffer was lost
                  } while (strategy.contentsLost());
                  }
                  // Dispose the window
                  w.setVisible(false);
                  w.dispose();
                  &lt;/code&gt;&lt;/pre&gt;                
                <see>
                    java.awt.Window                    
                </see>
                <see>
                    java.awt.Canvas                    
                </see>
                <see>
                    java.awt.GraphicsConfiguration                    
                </see>
                <see>
                    VolatileImage                    
                </see>
                <author>
                    Michael Martak                    
                </author>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getCapabilities" type="BufferCapabilities" line="138"/>
            <javadoc line="138">
                Returns the &lt;code&gt;BufferCapabilities&lt;/code&gt; for this
                  &lt;code&gt;BufferStrategy&lt;/code&gt;.                
                <return>
                    the buffering capabilities of this strategy                    
                </return>
            </javadoc>
            <method name="getDrawGraphics" type="Graphics" line="146"/>
            <javadoc line="146">
                Creates a graphics context for the drawing buffer.  This method may not
                  be synchronized for performance reasons; use of this method by multiple
                  threads should be handled at the application level.  Disposal of the
                  graphics object obtained must be handled by the application.                
                <return>
                    a graphics context for the drawing buffer                    
                </return>
            </javadoc>
            <method name="contentsLost" type="boolean" line="156"/>
            <javadoc line="156">
                Returns whether the drawing buffer was lost since the last call to
                  &lt;code&gt;getDrawGraphics&lt;/code&gt;.  Since the buffers in a buffer strategy
                  are usually type &lt;code&gt;VolatileImage&lt;/code&gt;, they may become lost.
                  For a discussion on lost buffers, see &lt;code&gt;VolatileImage&lt;/code&gt;.                
                <return>
                    Whether or not the drawing buffer was lost since the last call
                      to <code>getDrawGraphics</code>.                    
                </return>
                <see>
                    java.awt.image.VolatileImage                    
                </see>
            </javadoc>
            <method name="contentsRestored" type="boolean" line="168"/>
            <javadoc line="168">
                Returns whether the drawing buffer was recently restored from a lost
                  state and reinitialized to the default background color (white).
                  Since the buffers in a buffer strategy are usually type
                  &lt;code&gt;VolatileImage&lt;/code&gt;, they may become lost.  If a surface has
                  been recently restored from a lost state since the last call to
                  &lt;code&gt;getDrawGraphics&lt;/code&gt;, it may require repainting.
                  For a discussion on lost buffers, see &lt;code&gt;VolatileImage&lt;/code&gt;.                
                <return>
                    Whether or not the drawing buffer was restored since the last
                      call to <code>getDrawGraphics</code>.                    
                </return>
                <see>
                    java.awt.image.VolatileImage                    
                </see>
            </javadoc>
            <method name="show" type="void" line="183"/>
            <javadoc line="183">
                Makes the next available buffer visible by either copying the memory
                  (blitting) or changing the display pointer (flipping).                
            </javadoc>
            <javadoc line="189">
                Releases system resources currently consumed by this
                  &lt;code&gt;BufferStrategy&lt;/code&gt; and
                  removes it from the associated Component.  After invoking this
                  method, &lt;code&gt;getBufferStrategy&lt;/code&gt; will return null.  Trying
                  to use a &lt;code&gt;BufferStrategy&lt;/code&gt; after it has been disposed will
                  result in undefined behavior.                
                <see>
                    java.awt.Window#createBufferStrategy                    
                </see>
                <see>
                    java.awt.Canvas#createBufferStrategy                    
                </see>
                <see>
                    java.awt.Window#getBufferStrategy                    
                </see>
                <see>
                    java.awt.Canvas#getBufferStrategy                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="dispose" type="void" line="203"/>
        </class>
    </source>