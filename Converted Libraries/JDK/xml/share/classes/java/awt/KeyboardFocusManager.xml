<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.awt.event.FocusEvent"/>
        <import package="java.awt.event.InputEvent"/>
        <import package="java.awt.event.KeyEvent"/>
        <import package="java.awt.event.WindowEvent"/>
        <import package="java.awt.peer.KeyboardFocusManagerPeer"/>
        <import package="java.awt.peer.LightweightPeer"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.beans.PropertyChangeSupport"/>
        <import package="java.beans.PropertyVetoException"/>
        <import package="java.beans.VetoableChangeListener"/>
        <import package="java.beans.VetoableChangeSupport"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.Collections"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.Set"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.WeakHashMap"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.HeadlessToolkit"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.CausedFocusEvent"/>
        <import package="sun.awt.KeyboardFocusManagerPeerProvider"/>
        <import package="sun.awt.AWTAccessor"/>
        <class name="KeyboardFocusManager" line="65">
            <comment line="113">
                Shared focus engine logger                
            </comment>
            <comment line="410">
                SequencedEvent which is currently dispatched in AppContext.                
            </comment>
            <comment line="1860">
                Please be careful changing this method! It is called from
                 javax.swing.JComponent.runInputVerifier() using reflection.                
            </comment>
            <comment line="2220">
                heavyweightRequests is used as a monitor for synchronized changes of
                 currentLightweightRequests, clearingCurrentLightweightRequests and
                 newFocusOwner.                
            </comment>
            <comment line="2543">
                Used to process exceptions in dispatching focus event (in focusLostfocusGained callbacks).
                 @param ex previously caught exception that may be processed right here, or null
                 @param comp the component to dispatch the event to
                 @param event the event to dispatch to the component                
            </comment>
            <comment line="3015">
                Accessor to private field isProxyActive of KeyEvent                
            </comment>
            <comment line="3042">
                Returns the value of this KeyEvent&apos;s field isProxyActive                
            </comment>
            <implements interface="KeyEventDispatcher"/>
            <implements interface="KeyEventPostProcessor"/>
            <javadoc line="65">
                The KeyboardFocusManager is responsible for managing the active and focused
                  Windows, and the current focus owner. The focus owner is defined as the
                  Component in an application that will typically receive all KeyEvents
                  generated by the user. The focused Window is the Window that is, or
                  contains, the focus owner. Only a Frame or a Dialog can be the active
                  Window. The native windowing system may denote the active Window or its
                  children with special decorations, such as a highlighted title bar. The
                  active Window is always either the focused Window, or the first Frame or
                  Dialog that is an owner of the focused Window.
                  &lt;p&gt;
                  The KeyboardFocusManager is both a centralized location for client code to
                  query for the focus owner and initiate focus changes, and an event
                  dispatcher for all FocusEvents, WindowEvents related to focus, and
                  KeyEvents.
                  &lt;p&gt;
                  Some browsers partition applets in different code bases into separate
                  contexts, and establish walls between these contexts. In such a scenario,
                  there will be one KeyboardFocusManager per context. Other browsers place all
                  applets into the same context, implying that there will be only a single,
                  global KeyboardFocusManager for all applets. This behavior is
                  implementation-dependent. Consult your browser&apos;s documentation for more
                  information. No matter how many contexts there may be, however, there can
                  never be more than one focus owner, focused Window, or active Window, per
                  ClassLoader.
                  &lt;p&gt;
                  Please see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                  &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
                  for more information.                
                <author>
                    David Mendenhall                    
                </author>
                <see>
                    Window                    
                </see>
                <see>
                    Frame                    
                </see>
                <see>
                    Dialog                    
                </see>
                <see>
                    java.awt.event.FocusEvent                    
                </see>
                <see>
                    java.awt.event.WindowEvent                    
                </see>
                <see>
                    java.awt.event.KeyEvent                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="focusLog" type="PlatformLogger" line="113"/>
            <scope line="115">
                <scope line="118"/>
                <anonymous_class line="122">
                    <method name="shouldNativelyFocusHeavyweight" type="int" line="129">
                        <params>
                            <param name="heavyweight" type="Component"/>
                            <param name="descendant" type="Component"/>
                            <param name="temporary" type="boolean"/>
                            <param name="focusedWindowChangeAllowed" type="boolean"/>
                            <param name="time" type="long"/>
                            <param name="cause" type="CausedFocusEvent.Cause"/>
                        </params>
                    </method>
                    <method name="processSynchronousLightweightTransfer" type="boolean" line="138">
                        <params>
                            <param name="heavyweight" type="Component"/>
                            <param name="descendant" type="Component"/>
                            <param name="temporary" type="boolean"/>
                            <param name="focusedWindowChangeAllowed" type="boolean"/>
                            <param name="time" type="long"/>
                        </params>
                    </method>
                    <method name="removeLastFocusRequest" type="void" line="142">
                        <params>
                            <param name="heavyweight" type="Component"/>
                        </params>
                    </method>
                    <method name="setMostRecentFocusOwner" type="void" line="145">
                        <params>
                            <param name="window" type="Window"/>
                            <param name="component" type="Component"/>
                        </params>
                    </method>
                </anonymous_class>
            </scope>
            <declaration name="peer" type="KeyboardFocusManagerPeer" line="152"/>
            <method name="initIDs" type="void" line="154"/>
            <javadoc line="154">
                Initialize JNI field and method IDs                
            </javadoc>
            <declaration name="log" type="PlatformLogger" line="159"/>
            <declaration name="FORWARD_TRAVERSAL_KEYS" type="int" line="161"/>
            <javadoc line="161">
                The identifier for the Forward focus traversal keys.                
                <see>
                    #setDefaultFocusTraversalKeys                    
                </see>
                <see>
                    #getDefaultFocusTraversalKeys                    
                </see>
                <see>
                    Component#setFocusTraversalKeys                    
                </see>
                <see>
                    Component#getFocusTraversalKeys                    
                </see>
            </javadoc>
            <declaration name="BACKWARD_TRAVERSAL_KEYS" type="int" line="171"/>
            <javadoc line="171">
                The identifier for the Backward focus traversal keys.                
                <see>
                    #setDefaultFocusTraversalKeys                    
                </see>
                <see>
                    #getDefaultFocusTraversalKeys                    
                </see>
                <see>
                    Component#setFocusTraversalKeys                    
                </see>
                <see>
                    Component#getFocusTraversalKeys                    
                </see>
            </javadoc>
            <declaration name="UP_CYCLE_TRAVERSAL_KEYS" type="int" line="181"/>
            <javadoc line="181">
                The identifier for the Up Cycle focus traversal keys.                
                <see>
                    #setDefaultFocusTraversalKeys                    
                </see>
                <see>
                    #getDefaultFocusTraversalKeys                    
                </see>
                <see>
                    Component#setFocusTraversalKeys                    
                </see>
                <see>
                    Component#getFocusTraversalKeys                    
                </see>
            </javadoc>
            <declaration name="DOWN_CYCLE_TRAVERSAL_KEYS" type="int" line="191"/>
            <javadoc line="191">
                The identifier for the Down Cycle focus traversal keys.                
                <see>
                    #setDefaultFocusTraversalKeys                    
                </see>
                <see>
                    #getDefaultFocusTraversalKeys                    
                </see>
                <see>
                    Component#setFocusTraversalKeys                    
                </see>
                <see>
                    Component#getFocusTraversalKeys                    
                </see>
            </javadoc>
            <declaration name="TRAVERSAL_KEY_LENGTH" type="int" line="201"/>
            <javadoc line="203">
                Returns the current KeyboardFocusManager instance for the calling
                  thread&apos;s context.                
                <return>
                    this thread's context's KeyboardFocusManager                    
                </return>
                <see>
                    #setCurrentKeyboardFocusManager                    
                </see>
            </javadoc>
            <method name="getCurrentKeyboardFocusManager" type="KeyboardFocusManager" line="210"/>
            <method name="getCurrentKeyboardFocusManager" type="KeyboardFocusManager" line="216">
                <params>
                    <param name="appcontext" type="AppContext"/>
                </params>
                <declaration name="manager" type="KeyboardFocusManager" line="217"/>
                <scope line="219"/>
            </method>
            <javadoc line="226">
                Sets the current KeyboardFocusManager instance for the calling thread&apos;s
                  context. If null is specified, then the current KeyboardFocusManager
                  is replaced with a new instance of DefaultKeyboardFocusManager.
                  &lt;p&gt;
                  If a SecurityManager is installed, the calling thread must be granted
                  the AWTPermission &quot;replaceKeyboardFocusManager&quot; in order to replace the
                  the current KeyboardFocusManager. If this permission is not granted,
                  this method will throw a SecurityException, and the current
                  KeyboardFocusManager will be unchanged.                
                <param>
                    newManager the new KeyboardFocusManager for this thread's context                    
                </param>
                <see>
                    #getCurrentKeyboardFocusManager                    
                </see>
                <see>
                    DefaultKeyboardFocusManager                    
                </see>
                <throws>
                    SecurityException if the calling thread does not have permission
                      to replace the current KeyboardFocusManager                    
                </throws>
            </javadoc>
            <method name="setCurrentKeyboardFocusManager" type="void" line="245">
                <params>
                    <param name="newManager" type="KeyboardFocusManager"/>
                </params>
                <declaration name="security" type="SecurityManager" line="246"/>
                <scope line="247">
                    <scope line="248"/>
                </scope>
                <declaration name="oldManager" type="KeyboardFocusManager" line="256"/>
                <scope line="258">
                    <declaration name="appcontext" type="AppContext" line="259"/>
                    <scope line="261"/>
                    <scope line="265"/>
                </scope>
                <scope line="271"/>
                <scope line="276"/>
            </method>
            <declaration name="focusOwner" type="Component" line="283"/>
            <javadoc line="283">
                The Component in an application that will typically receive all
                  KeyEvents generated by the user.                
            </javadoc>
            <declaration name="permanentFocusOwner" type="Component" line="289"/>
            <javadoc line="289">
                The Component in an application that will regain focus when an
                  outstanding temporary focus transfer has completed, or the focus owner,
                  if no outstanding temporary transfer exists.                
            </javadoc>
            <declaration name="focusedWindow" type="Window" line="296"/>
            <javadoc line="296">
                The Window which is, or contains, the focus owner.                
            </javadoc>
            <declaration name="activeWindow" type="Window" line="301"/>
            <javadoc line="301">
                Only a Frame or a Dialog can be the active Window. The native windowing
                  system may denote the active Window with a special decoration, such as a
                  highlighted title bar. The active Window is always either the focused
                  Window, or the first Frame or Dialog which is an owner of the focused
                  Window.                
            </javadoc>
            <declaration name="defaultPolicy" type="FocusTraversalPolicy" line="310"/>
            <javadoc line="310">
                The default FocusTraversalPolicy for all Windows that have no policy of
                  their own set. If those Windows have focus-cycle-root children that have
                  no keyboard-traversal policy of their own, then those children will also
                  inherit this policy (as will, recursively, their focus-cycle-root
                  children).                
            </javadoc>
            <declaration name="defaultFocusTraversalKeyPropertyNames" type="String[]" line="320"/>
            <javadoc line="320">
                The bound property names of each focus traversal key.                
            </javadoc>
            <declaration name="defaultFocusTraversalKeyStrokes" type="AWTKeyStroke[][]" line="330"/>
            <javadoc line="330">
                The default strokes for initializing the default focus traversal keys.                
            </javadoc>
            <declaration name="defaultFocusTraversalKeys" type="Set[]" line="347"/>
            <javadoc line="347">
                The default focus traversal keys. Each array of traversal keys will be
                  in effect on all Windows that have no such array of their own explicitly
                  set. Each array will also be inherited, recursively, by any child
                  Component of those Windows that has no such array of its own explicitly
                  set.                
            </javadoc>
            <declaration name="currentFocusCycleRoot" type="Container" line="356"/>
            <javadoc line="356">
                The current focus cycle root. If the focus owner is itself a focus cycle
                  root, then it may be ambiguous as to which Components represent the next
                  and previous Components to focus during normal focus traversal. In that
                  case, the current focus cycle root is used to differentiate among the
                  possibilities.                
            </javadoc>
            <declaration name="vetoableSupport" type="VetoableChangeSupport" line="365"/>
            <javadoc line="365">
                A description of any VetoableChangeListeners which have been registered.                
            </javadoc>
            <declaration name="changeSupport" type="PropertyChangeSupport" line="370"/>
            <javadoc line="370">
                A description of any PropertyChangeListeners which have been registered.                
            </javadoc>
            <declaration name="keyEventDispatchers" type="java.util.LinkedList" line="375"/>
            <javadoc line="375">
                This KeyboardFocusManager&apos;s KeyEventDispatcher chain. The List does not
                  include this KeyboardFocusManager unless it was explicitly re-registered
                  via a call to &lt;code&gt;addKeyEventDispatcher&lt;/code&gt;. If no other
                  KeyEventDispatchers are registered, this field may be null or refer to
                  a List of length 0.                
            </javadoc>
            <declaration name="keyEventPostProcessors" type="java.util.LinkedList" line="384"/>
            <javadoc line="384">
                This KeyboardFocusManager&apos;s KeyEventPostProcessor chain. The List does
                  not include this KeyboardFocusManager unless it was explicitly
                  re-registered via a call to &lt;code&gt;addKeyEventPostProcessor&lt;/code&gt;.
                  If no other KeyEventPostProcessors are registered, this field may be
                  null or refer to a List of length 0.                
            </javadoc>
            <declaration name="mostRecentFocusOwners" type="java.util.Map" line="393"/>
            <javadoc line="393">
                Maps Windows to those Windows&apos; most recent focus owners.                
            </javadoc>
            <declaration name="notPrivileged" type="String" line="398"/>
            <javadoc line="398">
                Error String for initializing SecurityExceptions.                
            </javadoc>
            <declaration name="replaceKeyboardFocusManagerPermission" type="AWTPermission" line="403"/>
            <javadoc line="403">
                We cache the permission used to verify that the calling thread is
                  permitted to access the global focus state.                
            </javadoc>
            <declaration name="currentSequencedEvent" type="SequencedEvent" line="412"/>
            <method name="setCurrentSequencedEvent" type="void" line="414">
                <params>
                    <param name="current" type="SequencedEvent"/>
                </params>
                <scope line="415"/>
            </method>
            <method name="getCurrentSequencedEvent" type="SequencedEvent" line="421">
                <scope line="422"/>
            </method>
            <method name="initFocusTraversalKeysSet" type="Set" line="427">
                <params>
                    <param name="value" type="String"/>
                    <param name="targetSet" type="Set"/>
                </params>
                <declaration name="tokens" type="StringTokenizer" line="428"/>
                <scope line="429"/>
            </method>
            <javadoc line="437">
                Initializes a KeyboardFocusManager.                
            </javadoc>
            <method name="KeyboardFocusManager" type="constructor" line="440">
                <scope line="441">
                    <declaration name="work_set" type="Set" line="442"/>
                    <scope line="443"/>
                </scope>
            </method>
            <method name="initPeer" type="void" line="453">
                <declaration name="tk" type="Toolkit" line="454"/>
                <declaration name="peerProvider" type="KeyboardFocusManagerPeerProvider" line="455"/>
            </method>
            <javadoc line="459">
                Returns the focus owner, if the focus owner is in the same context as
                  the calling thread. The focus owner is defined as the Component in an
                  application that will typically receive all KeyEvents generated by the
                  user. KeyEvents which map to the focus owner&apos;s focus traversal keys will
                  not be delivered if focus traversal keys are enabled for the focus
                  owner. In addition, KeyEventDispatchers may retarget or consume
                  KeyEvents before they reach the focus owner.                
                <return>
                    the focus owner, or null if the focus owner is not a member of
                      the calling thread's context                    
                </return>
                <see>
                    #getGlobalFocusOwner                    
                </see>
                <see>
                    #setGlobalFocusOwner                    
                </see>
            </javadoc>
            <method name="getFocusOwner" type="Component" line="473">
                <scope line="474">
                    <scope line="475"/>
                </scope>
            </method>
            <javadoc line="485">
                Returns the focus owner, even if the calling thread is in a different
                  context than the focus owner. The focus owner is defined as the
                  Component in an application that will typically receive all KeyEvents
                  generated by the user. KeyEvents which map to the focus owner&apos;s focus
                  traversal keys will not be delivered if focus traversal keys are enabled
                  for the focus owner. In addition, KeyEventDispatchers may retarget or
                  consume KeyEvents before they reach the focus owner.
                  &lt;p&gt;
                  This method will throw a SecurityException if this KeyboardFocusManager
                  is not the current KeyboardFocusManager for the calling thread&apos;s
                  context.                
                <return>
                    the focus owner                    
                </return>
                <see>
                    #getFocusOwner                    
                </see>
                <see>
                    #setGlobalFocusOwner                    
                </see>
                <throws>
                    SecurityException if this KeyboardFocusManager is not the
                      current KeyboardFocusManager for the calling thread's context                    
                </throws>
            </javadoc>
            <method name="getGlobalFocusOwner" type="Component" line="504">
                <scope line="505">
                    <scope line="506"/>
                    <scope line="508">
                        <scope line="509"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="517">
                Sets the focus owner. The operation will be cancelled if the Component
                  is not focusable. The focus owner is defined as the Component in an
                  application that will typically receive all KeyEvents generated by the
                  user. KeyEvents which map to the focus owner&apos;s focus traversal keys will
                  not be delivered if focus traversal keys are enabled for the focus
                  owner. In addition, KeyEventDispatchers may retarget or consume
                  KeyEvents before they reach the focus owner.
                  &lt;p&gt;
                  This method does not actually set the focus to the specified Component.
                  It merely stores the value to be subsequently returned by
                  &lt;code&gt;getFocusOwner()&lt;/code&gt;. Use &lt;code&gt;Component.requestFocus()&lt;/code&gt;
                  or &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt; to change the focus
                  owner, subject to platform limitations.                
                <param>
                    focusOwner the focus owner                    
                </param>
                <see>
                    #getFocusOwner                    
                </see>
                <see>
                    #getGlobalFocusOwner                    
                </see>
                <see>
                    Component#requestFocus()                    
                </see>
                <see>
                    Component#requestFocusInWindow()                    
                </see>
                <see>
                    Component#isFocusable                    
                </see>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setGlobalFocusOwner" type="void" line="541">
                <params>
                    <param name="focusOwner" type="Component"/>
                </params>
                <comment line="553">
                    rejected                    
                </comment>
                <declaration name="oldFocusOwner" type="Component" line="542"/>
                <declaration name="shouldFire" type="boolean" line="543"/>
                <scope line="545">
                    <scope line="546">
                        <scope line="549"/>
                        <scope line="552"/>
                        <scope line="562">
                            <declaration name="rootAncestor" type="Container" line="563"/>
                            <scope line="566"/>
                            <scope line="569"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="578"/>
            </method>
            <javadoc line="583">
                Clears the global focus owner at both the Java and native levels. If
                  there exists a focus owner, that Component will receive a permanent
                  FOCUS_LOST event. After this operation completes, the native windowing
                  system will discard all user-generated KeyEvents until the user selects
                  a new Component to receive focus, or a Component is given focus
                  explicitly via a call to &lt;code&gt;requestFocus()&lt;/code&gt;. This operation
                  does not change the focused or active Windows.                
                <see>
                    Component#requestFocus()                    
                </see>
                <see>
                    java.awt.event.FocusEvent#FOCUS_LOST                    
                </see>
            </javadoc>
            <method name="clearGlobalFocusOwner" type="void" line="595">
                <comment line="597">
                    Toolkit must be fully initialized, otherwise                    
                </comment>
                <comment line="598">
                    _clearGlobalFocusOwner will crash or throw an exception                    
                </comment>
                <scope line="596"/>
            </method>
            <method name="_clearGlobalFocusOwner" type="void" line="604">
                <declaration name="activeWindow" type="Window" line="605"/>
            </method>
            <method name="getNativeFocusOwner" type="Component" line="609"/>
            <method name="setNativeFocusOwner" type="void" line="613">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="614"/>
            </method>
            <method name="getNativeFocusedWindow" type="Window" line="621"/>
            <javadoc line="625">
                Returns the permanent focus owner, if the permanent focus owner is in
                  the same context as the calling thread. The permanent focus owner is
                  defined as the last Component in an application to receive a permanent
                  FOCUS_GAINED event. The focus owner and permanent focus owner are
                  equivalent unless a temporary focus change is currently in effect. In
                  such a situation, the permanent focus owner will again be the focus
                  owner when the temporary focus change ends.                
                <return>
                    the permanent focus owner, or null if the permanent focus owner
                      is not a member of the calling thread's context                    
                </return>
                <see>
                    #getGlobalPermanentFocusOwner                    
                </see>
                <see>
                    #setGlobalPermanentFocusOwner                    
                </see>
            </javadoc>
            <method name="getPermanentFocusOwner" type="Component" line="639">
                <scope line="640">
                    <scope line="641"/>
                </scope>
            </method>
            <javadoc line="652">
                Returns the permanent focus owner, even if the calling thread is in a
                  different context than the permanent focus owner. The permanent focus
                  owner is defined as the last Component in an application to receive a
                  permanent FOCUS_GAINED event. The focus owner and permanent focus owner
                  are equivalent unless a temporary focus change is currently in effect.
                  In such a situation, the permanent focus owner will again be the focus
                  owner when the temporary focus change ends.
                  &lt;p&gt;
                  This method will throw a SecurityException if this KeyboardFocusManager
                  is not the current KeyboardFocusManager for the calling thread&apos;s
                  context.                
                <return>
                    the permanent focus owner                    
                </return>
                <see>
                    #getPermanentFocusOwner                    
                </see>
                <see>
                    #setGlobalPermanentFocusOwner                    
                </see>
                <throws>
                    SecurityException if this KeyboardFocusManager is not the
                      current KeyboardFocusManager for the calling thread's context                    
                </throws>
            </javadoc>
            <method name="getGlobalPermanentFocusOwner" type="Component" line="673">
                <scope line="674">
                    <scope line="675"/>
                    <scope line="677">
                        <scope line="678"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="686">
                Sets the permanent focus owner. The operation will be cancelled if the
                  Component is not focusable. The permanent focus owner is defined as the
                  last Component in an application to receive a permanent FOCUS_GAINED
                  event. The focus owner and permanent focus owner are equivalent unless
                  a temporary focus change is currently in effect. In such a situation,
                  the permanent focus owner will again be the focus owner when the
                  temporary focus change ends.
                  &lt;p&gt;
                  This method does not actually set the focus to the specified Component.
                  It merely stores the value to be subsequently returned by
                  &lt;code&gt;getPermanentFocusOwner()&lt;/code&gt;. Use
                  &lt;code&gt;Component.requestFocus()&lt;/code&gt; or
                  &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt; to change the focus owner,
                  subject to platform limitations.                
                <param>
                    permanentFocusOwner the permanent focus owner                    
                </param>
                <see>
                    #getPermanentFocusOwner                    
                </see>
                <see>
                    #getGlobalPermanentFocusOwner                    
                </see>
                <see>
                    Component#requestFocus()                    
                </see>
                <see>
                    Component#requestFocusInWindow()                    
                </see>
                <see>
                    Component#isFocusable                    
                </see>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setGlobalPermanentFocusOwner" type="void" line="712">
                <params>
                    <param name="permanentFocusOwner" type="Component"/>
                </params>
                <comment line="725">
                    rejected                    
                </comment>
                <declaration name="oldPermanentFocusOwner" type="Component" line="713"/>
                <declaration name="shouldFire" type="boolean" line="714"/>
                <scope line="716">
                    <scope line="717">
                        <scope line="720"/>
                        <scope line="724"/>
                    </scope>
                </scope>
                <scope line="738"/>
            </method>
            <javadoc line="744">
                Returns the focused Window, if the focused Window is in the same context
                  as the calling thread. The focused Window is the Window that is or
                  contains the focus owner.                
                <return>
                    the focused Window, or null if the focused Window is not a
                      member of the calling thread's context                    
                </return>
                <see>
                    #getGlobalFocusedWindow                    
                </see>
                <see>
                    #setGlobalFocusedWindow                    
                </see>
            </javadoc>
            <method name="getFocusedWindow" type="Window" line="754">
                <scope line="755">
                    <scope line="756"/>
                </scope>
            </method>
            <javadoc line="766">
                Returns the focused Window, even if the calling thread is in a different
                  context than the focused Window. The focused Window is the Window that
                  is or contains the focus owner.
                  &lt;p&gt;
                  This method will throw a SecurityException if this KeyboardFocusManager
                  is not the current KeyboardFocusManager for the calling thread&apos;s
                  context.                
                <return>
                    the focused Window                    
                </return>
                <see>
                    #getFocusedWindow                    
                </see>
                <see>
                    #setGlobalFocusedWindow                    
                </see>
                <throws>
                    SecurityException if this KeyboardFocusManager is not the
                      current KeyboardFocusManager for the calling thread's context                    
                </throws>
            </javadoc>
            <method name="getGlobalFocusedWindow" type="Window" line="781">
                <scope line="782">
                    <scope line="783"/>
                    <scope line="785">
                        <scope line="786"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="794">
                Sets the focused Window. The focused Window is the Window that is or
                  contains the focus owner. The operation will be cancelled if the
                  specified Window to focus is not a focusable Window.
                  &lt;p&gt;
                  This method does not actually change the focused Window as far as the
                  native windowing system is concerned. It merely stores the value to be
                  subsequently returned by &lt;code&gt;getFocusedWindow()&lt;/code&gt;. Use
                  &lt;code&gt;Component.requestFocus()&lt;/code&gt; or
                  &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt; to change the focused
                  Window, subject to platform limitations.                
                <param>
                    focusedWindow the focused Window                    
                </param>
                <see>
                    #getFocusedWindow                    
                </see>
                <see>
                    #getGlobalFocusedWindow                    
                </see>
                <see>
                    Component#requestFocus()                    
                </see>
                <see>
                    Component#requestFocusInWindow()                    
                </see>
                <see>
                    Window#isFocusableWindow                    
                </see>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setGlobalFocusedWindow" type="void" line="815">
                <params>
                    <param name="focusedWindow" type="Window"/>
                </params>
                <comment line="827">
                    rejected                    
                </comment>
                <declaration name="oldFocusedWindow" type="Window" line="816"/>
                <declaration name="shouldFire" type="boolean" line="817"/>
                <scope line="819">
                    <scope line="820">
                        <scope line="823"/>
                        <scope line="826"/>
                    </scope>
                </scope>
                <scope line="836"/>
            </method>
            <javadoc line="842">
                Returns the active Window, if the active Window is in the same context
                  as the calling thread. Only a Frame or a Dialog can be the active
                  Window. The native windowing system may denote the active Window or its
                  children with special decorations, such as a highlighted title bar.
                  The active Window is always either the focused Window, or the first
                  Frame or Dialog that is an owner of the focused Window.                
                <return>
                    the active Window, or null if the active Window is not a member
                      of the calling thread's context                    
                </return>
                <see>
                    #getGlobalActiveWindow                    
                </see>
                <see>
                    #setGlobalActiveWindow                    
                </see>
            </javadoc>
            <method name="getActiveWindow" type="Window" line="855">
                <scope line="856">
                    <scope line="857"/>
                </scope>
            </method>
            <javadoc line="867">
                Returns the active Window, even if the calling thread is in a different
                  context than the active Window. Only a Frame or a Dialog can be the
                  active Window. The native windowing system may denote the active Window
                  or its children with special decorations, such as a highlighted title
                  bar. The active Window is always either the focused Window, or the first
                  Frame or Dialog that is an owner of the focused Window.
                  &lt;p&gt;
                  This method will throw a SecurityException if this KeyboardFocusManager
                  is not the current KeyboardFocusManager for the calling thread&apos;s
                  context.                
                <return>
                    the active Window                    
                </return>
                <see>
                    #getActiveWindow                    
                </see>
                <see>
                    #setGlobalActiveWindow                    
                </see>
                <throws>
                    SecurityException if this KeyboardFocusManager is not the
                      current KeyboardFocusManager for the calling thread's context                    
                </throws>
            </javadoc>
            <method name="getGlobalActiveWindow" type="Window" line="885">
                <scope line="886">
                    <scope line="887"/>
                    <scope line="889">
                        <scope line="890"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="898">
                Sets the active Window. Only a Frame or a Dialog can be the active
                  Window. The native windowing system may denote the active Window or its
                  children with special decorations, such as a highlighted title bar. The
                  active Window is always either the focused Window, or the first Frame or
                  Dialog that is an owner of the focused Window.
                  &lt;p&gt;
                  This method does not actually change the active Window as far as the
                  native windowing system is concerned. It merely stores the value to be
                  subsequently returned by &lt;code&gt;getActiveWindow()&lt;/code&gt;. Use
                  &lt;code&gt;Component.requestFocus()&lt;/code&gt; or
                  &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt;to change the active
                  Window, subject to platform limitations.                
                <param>
                    activeWindow the active Window                    
                </param>
                <see>
                    #getActiveWindow                    
                </see>
                <see>
                    #getGlobalActiveWindow                    
                </see>
                <see>
                    Component#requestFocus()                    
                </see>
                <see>
                    Component#requestFocusInWindow()                    
                </see>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setGlobalActiveWindow" type="void" line="920">
                <params>
                    <param name="activeWindow" type="Window"/>
                </params>
                <comment line="932">
                    rejected                    
                </comment>
                <declaration name="oldActiveWindow" type="Window" line="921"/>
                <scope line="922">
                    <scope line="924"/>
                    <scope line="928"/>
                    <scope line="931"/>
                </scope>
            </method>
            <javadoc line="942">
                Returns the default FocusTraversalPolicy. Top-level components
                  use this value on their creation to initialize their own focus traversal
                  policy by explicit call to Container.setFocusTraversalPolicy.                
                <return>
                    the default FocusTraversalPolicy. null will never be returned.                    
                </return>
                <see>
                    #setDefaultFocusTraversalPolicy                    
                </see>
                <see>
                    Container#setFocusTraversalPolicy                    
                </see>
                <see>
                    Container#getFocusTraversalPolicy                    
                </see>
            </javadoc>
            <method name="getDefaultFocusTraversalPolicy" type="FocusTraversalPolicy" line="952"/>
            <javadoc line="956">
                Sets the default FocusTraversalPolicy. Top-level components
                  use this value on their creation to initialize their own focus traversal
                  policy by explicit call to Container.setFocusTraversalPolicy.
                  Note: this call doesn&apos;t affect already created components as they have
                  their policy initialized. Only new components will use this policy as
                  their default policy.                
                <param>
                    defaultPolicy the new, default FocusTraversalPolicy                    
                </param>
                <see>
                    #getDefaultFocusTraversalPolicy                    
                </see>
                <see>
                    Container#setFocusTraversalPolicy                    
                </see>
                <see>
                    Container#getFocusTraversalPolicy                    
                </see>
                <throws>
                    IllegalArgumentException if defaultPolicy is null                    
                </throws>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setDefaultFocusTraversalPolicy" type="void" line="973">
                <params>
                    <param name="defaultPolicy" type="FocusTraversalPolicy"/>
                </params>
                <scope line="974"/>
                <declaration name="oldPolicy" type="FocusTraversalPolicy" line="978"/>
                <scope line="980"/>
            </method>
            <javadoc line="989">
                Sets the default focus traversal keys for a given traversal operation.
                  This traversal key &lt;code&gt;Set&lt;/code&gt; will be in effect on all
                  &lt;code&gt;Window&lt;/code&gt;s that have no such &lt;code&gt;Set&lt;/code&gt; of
                  their own explicitly defined. This &lt;code&gt;Set&lt;/code&gt; will also be
                  inherited, recursively, by any child &lt;code&gt;Component&lt;/code&gt; of
                  those &lt;code&gt;Windows&lt;/code&gt; that has
                  no such &lt;code&gt;Set&lt;/code&gt; of its own explicitly defined.
                  &lt;p&gt;
                  The default values for the default focus traversal keys are
                  implementation-dependent. Sun recommends that all implementations for a
                  particular native platform use the same default values. The
                  recommendations for Windows and Unix are listed below. These
                  recommendations are used in the Sun AWT implementations.
                  &lt;table border=1 summary=&quot;Recommended default values for focus traversal keys&quot;&gt;
                  &lt;tr&gt;
                  &lt;th&gt;Identifier&lt;/th&gt;
                  &lt;th&gt;Meaning&lt;/th&gt;
                  &lt;th&gt;Default&lt;/th&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS&lt;/code&gt;&lt;/td&gt;
                  &lt;td&gt;Normal forward keyboard traversal&lt;/td&gt;
                  &lt;td&gt;&lt;code&gt;TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;,
                  &lt;code&gt;CTRL-TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS&lt;/code&gt;&lt;/td&gt;
                  &lt;td&gt;Normal reverse keyboard traversal&lt;/td&gt;
                  &lt;td&gt;&lt;code&gt;SHIFT-TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;,
                  &lt;code&gt;CTRL-SHIFT-TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;&lt;/td&gt;
                  &lt;td&gt;Go up one focus traversal cycle&lt;/td&gt;
                  &lt;td&gt;none&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;&lt;/td&gt;
                  &lt;td&gt;Go down one focus traversal cycle&lt;/td&gt;
                  &lt;td&gt;none&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  To disable a traversal key, use an empty &lt;code&gt;Set&lt;/code&gt;;
                  &lt;code&gt;Collections.EMPTY_SET&lt;/code&gt; is recommended.
                  &lt;p&gt;
                  Using the &lt;code&gt;AWTKeyStroke&lt;/code&gt; API, client code can
                  specify on which of two
                  specific &lt;code&gt;KeyEvent&lt;/code&gt;s, &lt;code&gt;KEY_PRESSED&lt;/code&gt; or
                  &lt;code&gt;KEY_RELEASED&lt;/code&gt;, the focus traversal operation will
                  occur. Regardless of which &lt;code&gt;KeyEvent&lt;/code&gt; is specified,
                  however, all &lt;code&gt;KeyEvent&lt;/code&gt;s related to the focus
                  traversal key, including the associated &lt;code&gt;KEY_TYPED&lt;/code&gt;
                  event, will be consumed, and will not be dispatched
                  to any &lt;code&gt;Component&lt;/code&gt;. It is a runtime error to
                  specify a &lt;code&gt;KEY_TYPED&lt;/code&gt; event as
                  mapping to a focus traversal operation, or to map the same event to
                  multiple default focus traversal operations.                
                <param>
                    id one of
                      <code>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</code>,
                      <code>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</code>,
                      <code>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</code>, or
                      <code>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</code>                    
                </param>
                <param>
                    keystrokes the Set of <code>AWTKeyStroke</code>s for the
                      specified operation                    
                </param>
                <see>
                    #getDefaultFocusTraversalKeys                    
                </see>
                <see>
                    Component#setFocusTraversalKeys                    
                </see>
                <see>
                    Component#getFocusTraversalKeys                    
                </see>
                <throws>
                    IllegalArgumentException if id is not one of
                      <code>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</code>,
                      <code>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</code>,
                      <code>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</code>, or
                      <code>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</code>,
                      or if keystrokes is <code>null</code>,
                      or if keystrokes contains <code>null</code>,
                      or if any <code>Object</code> in
                      keystrokes is not an <code>AWTKeyStroke</code>,
                      or if any keystroke
                      represents a <code>KEY_TYPED</code> event,
                      or if any keystroke already maps
                      to another default focus traversal operation                    
                </throws>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setDefaultFocusTraversalKeys" type="void" line="1079">
                <params>
                    <param name="id" type="int"/>
                    <param name="keystrokes" type="Set<? extends AWTKeyStroke>"/>
                </params>
                <comment line="1097">
                    Fix for 6195831:                    
                </comment>
                <comment line="1098">
                    According to javadoc this method should throw IAE instead of ClassCastException                    
                </comment>
                <comment line="1108">
                    Check to see if key already maps to another traversal                    
                </comment>
                <comment line="1109">
                    operation                    
                </comment>
                <scope line="1080"/>
                <scope line="1083"/>
                <declaration name="oldKeys" type="Set" line="1087"/>
                <scope line="1089">
                    <scope line="1090">
                        <declaration name="obj" type="Object" line="1091"/>
                        <scope line="1093"/>
                        <scope line="1099"/>
                        <declaration name="keystroke" type="AWTKeyStroke" line="1102"/>
                        <scope line="1104"/>
                        <scope line="1110">
                            <scope line="1111"/>
                            <scope line="1115"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1130">
                Returns a Set of default focus traversal keys for a given traversal
                  operation. This traversal key Set will be in effect on all Windows that
                  have no such Set of their own explicitly defined. This Set will also be
                  inherited, recursively, by any child Component of those Windows that has
                  no such Set of its own explicitly defined. (See
                  &lt;code&gt;setDefaultFocusTraversalKeys&lt;/code&gt; for a full description of each
                  operation.)                
                <param>
                    id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </param>
                <return>
                    the <code>Set</code> of <code>AWTKeyStroke</code>s
                      for the specified operation; the <code>Set</code>
                      will be unmodifiable, and may be empty; <code>null</code>
                      will never be returned                    
                </return>
                <see>
                    #setDefaultFocusTraversalKeys                    
                </see>
                <see>
                    Component#setFocusTraversalKeys                    
                </see>
                <see>
                    Component#getFocusTraversalKeys                    
                </see>
                <throws>
                    IllegalArgumentException if id is not one of
                      KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </throws>
            </javadoc>
            <method name="getDefaultFocusTraversalKeys" type="Set<AWTKeyStroke>" line="1156">
                <params>
                    <param name="id" type="int"/>
                </params>
                <comment line="1161">
                    Okay to return Set directly because it is an unmodifiable view                    
                </comment>
                <scope line="1157"/>
            </method>
            <javadoc line="1165">
                Returns the current focus cycle root, if the current focus cycle root is
                  in the same context as the calling thread. If the focus owner is itself
                  a focus cycle root, then it may be ambiguous as to which Components
                  represent the next and previous Components to focus during normal focus
                  traversal. In that case, the current focus cycle root is used to
                  differentiate among the possibilities.
                  &lt;p&gt;
                  This method is intended to be used only by KeyboardFocusManagers and
                  focus implementations. It is not for general client use.                
                <return>
                    the current focus cycle root, or null if the current focus cycle
                      root is not a member of the calling thread's context                    
                </return>
                <see>
                    #getGlobalCurrentFocusCycleRoot                    
                </see>
                <see>
                    #setGlobalCurrentFocusCycleRoot                    
                </see>
            </javadoc>
            <method name="getCurrentFocusCycleRoot" type="Container" line="1181">
                <scope line="1182">
                    <scope line="1183"/>
                </scope>
            </method>
            <javadoc line="1194">
                Returns the current focus cycle root, even if the calling thread is in a
                  different context than the current focus cycle root. If the focus owner
                  is itself a focus cycle root, then it may be ambiguous as to which
                  Components represent the next and previous Components to focus during
                  normal focus traversal. In that case, the current focus cycle root is
                  used to differentiate among the possibilities.
                  &lt;p&gt;
                  This method will throw a SecurityException if this KeyboardFocusManager
                  is not the current KeyboardFocusManager for the calling thread&apos;s
                  context.                
                <return>
                    the current focus cycle root, or null if the current focus cycle
                      root is not a member of the calling thread's context                    
                </return>
                <see>
                    #getCurrentFocusCycleRoot                    
                </see>
                <see>
                    #setGlobalCurrentFocusCycleRoot                    
                </see>
                <throws>
                    SecurityException if this KeyboardFocusManager is not the
                      current KeyboardFocusManager for the calling thread's context                    
                </throws>
            </javadoc>
            <method name="getGlobalCurrentFocusCycleRoot" type="Container" line="1215">
                <scope line="1216">
                    <scope line="1217"/>
                    <scope line="1219">
                        <scope line="1220"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1228">
                Sets the current focus cycle root. If the focus owner is itself a focus
                  cycle root, then it may be ambiguous as to which Components represent
                  the next and previous Components to focus during normal focus traversal.
                  In that case, the current focus cycle root is used to differentiate
                  among the possibilities.
                  &lt;p&gt;
                  This method is intended to be used only by KeyboardFocusManagers and
                  focus implementations. It is not for general client use.                
                <param>
                    newFocusCycleRoot the new focus cycle root                    
                </param>
                <see>
                    #getCurrentFocusCycleRoot                    
                </see>
                <see>
                    #getGlobalCurrentFocusCycleRoot                    
                </see>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setGlobalCurrentFocusCycleRoot" type="void" line="1244">
                <params>
                    <param name="newFocusCycleRoot" type="Container"/>
                </params>
                <declaration name="oldFocusCycleRoot" type="Container" line="1245"/>
                <scope line="1247"/>
            </method>
            <javadoc line="1256">
                Adds a PropertyChangeListener to the listener list. The listener is
                  registered for all bound properties of this class, including the
                  following:
                  &lt;ul&gt;
                  &lt;li&gt;whether the KeyboardFocusManager is currently managing focus
                  for this application or applet&apos;s browser context
                  (&quot;managingFocus&quot;)&lt;/li&gt;
                  &lt;li&gt;the focus owner (&quot;focusOwner&quot;)&lt;/li&gt;
                  &lt;li&gt;the permanent focus owner (&quot;permanentFocusOwner&quot;)&lt;/li&gt;
                  &lt;li&gt;the focused Window (&quot;focusedWindow&quot;)&lt;/li&gt;
                  &lt;li&gt;the active Window (&quot;activeWindow&quot;)&lt;/li&gt;
                  &lt;li&gt;the default focus traversal policy
                  (&quot;defaultFocusTraversalPolicy&quot;)&lt;/li&gt;
                  &lt;li&gt;the Set of default FORWARD_TRAVERSAL_KEYS
                  (&quot;forwardDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;the Set of default BACKWARD_TRAVERSAL_KEYS
                  (&quot;backwardDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;the Set of default UP_CYCLE_TRAVERSAL_KEYS
                  (&quot;upCycleDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;the Set of default DOWN_CYCLE_TRAVERSAL_KEYS
                  (&quot;downCycleDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;the current focus cycle root (&quot;currentFocusCycleRoot&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    listener the PropertyChangeListener to be added                    
                </param>
                <see>
                    #removePropertyChangeListener                    
                </see>
                <see>
                    #getPropertyChangeListeners                    
                </see>
                <see>
                    #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)                    
                </see>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="1287">
                <params>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
                <scope line="1288">
                    <scope line="1289">
                        <scope line="1290"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1298">
                Removes a PropertyChangeListener from the listener list. This method
                  should be used to remove the PropertyChangeListeners that were
                  registered for all bound properties of this class.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    listener the PropertyChangeListener to be removed                    
                </param>
                <see>
                    #addPropertyChangeListener                    
                </see>
                <see>
                    #getPropertyChangeListeners                    
                </see>
                <see>
                    #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)                    
                </see>
            </javadoc>
            <method name="removePropertyChangeListener" type="void" line="1310">
                <params>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
                <scope line="1311">
                    <scope line="1312">
                        <scope line="1313"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1320">
                Returns an array of all the property change listeners
                  registered on this keyboard focus manager.                
                <return>
                    all of this keyboard focus manager's
                      <code>PropertyChangeListener</code>s
                      or an empty array if no property change
                      listeners are currently registered                    
                </return>
                <see>
                    #addPropertyChangeListener                    
                </see>
                <see>
                    #removePropertyChangeListener                    
                </see>
                <see>
                    #getPropertyChangeListeners(java.lang.String)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getPropertyChangeListeners" type="PropertyChangeListener[]" line="1334">
                <scope line="1335"/>
            </method>
            <javadoc line="1341">
                Adds a PropertyChangeListener to the listener list for a specific
                  property. The specified property may be user-defined, or one of the
                  following:
                  &lt;ul&gt;
                  &lt;li&gt;whether the KeyboardFocusManager is currently managing focus
                  for this application or applet&apos;s browser context
                  (&quot;managingFocus&quot;)&lt;/li&gt;
                  &lt;li&gt;the focus owner (&quot;focusOwner&quot;)&lt;/li&gt;
                  &lt;li&gt;the permanent focus owner (&quot;permanentFocusOwner&quot;)&lt;/li&gt;
                  &lt;li&gt;the focused Window (&quot;focusedWindow&quot;)&lt;/li&gt;
                  &lt;li&gt;the active Window (&quot;activeWindow&quot;)&lt;/li&gt;
                  &lt;li&gt;the default focus traversal policy
                  (&quot;defaultFocusTraversalPolicy&quot;)&lt;/li&gt;
                  &lt;li&gt;the Set of default FORWARD_TRAVERSAL_KEYS
                  (&quot;forwardDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;the Set of default BACKWARD_TRAVERSAL_KEYS
                  (&quot;backwardDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;the Set of default UP_CYCLE_TRAVERSAL_KEYS
                  (&quot;upCycleDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;the Set of default DOWN_CYCLE_TRAVERSAL_KEYS
                  (&quot;downCycleDefaultFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;the current focus cycle root (&quot;currentFocusCycleRoot&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    propertyName one of the property names listed above                    
                </param>
                <param>
                    listener the PropertyChangeListener to be added                    
                </param>
                <see>
                    #addPropertyChangeListener(java.beans.PropertyChangeListener)                    
                </see>
                <see>
                    #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)                    
                </see>
                <see>
                    #getPropertyChangeListeners(java.lang.String)                    
                </see>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="1374">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
                <scope line="1375">
                    <scope line="1376">
                        <scope line="1377"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1386">
                Removes a PropertyChangeListener from the listener list for a specific
                  property. This method should be used to remove PropertyChangeListeners
                  that were registered for a specific bound property.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    propertyName a valid property name                    
                </param>
                <param>
                    listener the PropertyChangeListener to be removed                    
                </param>
                <see>
                    #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)                    
                </see>
                <see>
                    #getPropertyChangeListeners(java.lang.String)                    
                </see>
                <see>
                    #removePropertyChangeListener(java.beans.PropertyChangeListener)                    
                </see>
            </javadoc>
            <method name="removePropertyChangeListener" type="void" line="1400">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
                <scope line="1401">
                    <scope line="1402">
                        <scope line="1403"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1411">
                Returns an array of all the &lt;code&gt;PropertyChangeListener&lt;/code&gt;s
                  associated with the named property.                
                <return>
                    all of the <code>PropertyChangeListener</code>s associated with
                      the named property or an empty array if no such listeners have
                      been added.                    
                </return>
                <see>
                    #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)                    
                </see>
                <see>
                    #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getPropertyChangeListeners" type="PropertyChangeListener[]" line="1423">
                <params>
                    <param name="propertyName" type="String"/>
                </params>
                <scope line="1424"/>
            </method>
            <javadoc line="1430">
                Fires a PropertyChangeEvent in response to a change in a bound property.
                  The event will be delivered to all registered PropertyChangeListeners.
                  No event will be delivered if oldValue and newValue are the same.                
                <param>
                    propertyName the name of the property that has changed                    
                </param>
                <param>
                    oldValue the property's previous value                    
                </param>
                <param>
                    newValue the property's new value                    
                </param>
            </javadoc>
            <method name="firePropertyChange" type="void" line="1441">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="oldValue" type="Object"/>
                    <param name="newValue" type="Object"/>
                </params>
                <scope line="1442"/>
                <declaration name="changeSupport" type="PropertyChangeSupport" line="1445"/>
                <scope line="1446"/>
            </method>
            <javadoc line="1451">
                Adds a VetoableChangeListener to the listener list. The listener is
                  registered for all vetoable properties of this class, including the
                  following:
                  &lt;ul&gt;
                  &lt;li&gt;the focus owner (&quot;focusOwner&quot;)&lt;/li&gt;
                  &lt;li&gt;the permanent focus owner (&quot;permanentFocusOwner&quot;)&lt;/li&gt;
                  &lt;li&gt;the focused Window (&quot;focusedWindow&quot;)&lt;/li&gt;
                  &lt;li&gt;the active Window (&quot;activeWindow&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    listener the VetoableChangeListener to be added                    
                </param>
                <see>
                    #removeVetoableChangeListener                    
                </see>
                <see>
                    #getVetoableChangeListeners                    
                </see>
                <see>
                    #addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)                    
                </see>
            </javadoc>
            <method name="addVetoableChangeListener" type="void" line="1468">
                <params>
                    <param name="listener" type="VetoableChangeListener"/>
                </params>
                <scope line="1469">
                    <scope line="1470">
                        <scope line="1471"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1480">
                Removes a VetoableChangeListener from the listener list. This method
                  should be used to remove the VetoableChangeListeners that were
                  registered for all vetoable properties of this class.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    listener the VetoableChangeListener to be removed                    
                </param>
                <see>
                    #addVetoableChangeListener                    
                </see>
                <see>
                    #getVetoableChangeListeners                    
                </see>
                <see>
                    #removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)                    
                </see>
            </javadoc>
            <method name="removeVetoableChangeListener" type="void" line="1492">
                <params>
                    <param name="listener" type="VetoableChangeListener"/>
                </params>
                <scope line="1493">
                    <scope line="1494">
                        <scope line="1495"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1502">
                Returns an array of all the vetoable change listeners
                  registered on this keyboard focus manager.                
                <return>
                    all of this keyboard focus manager's
                      <code>VetoableChangeListener</code>s
                      or an empty array if no vetoable change
                      listeners are currently registered                    
                </return>
                <see>
                    #addVetoableChangeListener                    
                </see>
                <see>
                    #removeVetoableChangeListener                    
                </see>
                <see>
                    #getVetoableChangeListeners(java.lang.String)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getVetoableChangeListeners" type="VetoableChangeListener[]" line="1516">
                <scope line="1517"/>
            </method>
            <javadoc line="1523">
                Adds a VetoableChangeListener to the listener list for a specific
                  property. The specified property may be user-defined, or one of the
                  following:
                  &lt;ul&gt;
                  &lt;li&gt;the focus owner (&quot;focusOwner&quot;)&lt;/li&gt;
                  &lt;li&gt;the permanent focus owner (&quot;permanentFocusOwner&quot;)&lt;/li&gt;
                  &lt;li&gt;the focused Window (&quot;focusedWindow&quot;)&lt;/li&gt;
                  &lt;li&gt;the active Window (&quot;activeWindow&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    propertyName one of the property names listed above                    
                </param>
                <param>
                    listener the VetoableChangeListener to be added                    
                </param>
                <see>
                    #addVetoableChangeListener(java.beans.VetoableChangeListener)                    
                </see>
                <see>
                    #removeVetoableChangeListener                    
                </see>
                <see>
                    #getVetoableChangeListeners                    
                </see>
            </javadoc>
            <method name="addVetoableChangeListener" type="void" line="1542">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="listener" type="VetoableChangeListener"/>
                </params>
                <scope line="1543">
                    <scope line="1544">
                        <scope line="1545"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1555">
                Removes a VetoableChangeListener from the listener list for a specific
                  property. This method should be used to remove VetoableChangeListeners
                  that were registered for a specific bound property.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    propertyName a valid property name                    
                </param>
                <param>
                    listener the VetoableChangeListener to be removed                    
                </param>
                <see>
                    #addVetoableChangeListener                    
                </see>
                <see>
                    #getVetoableChangeListeners                    
                </see>
                <see>
                    #removeVetoableChangeListener(java.beans.VetoableChangeListener)                    
                </see>
            </javadoc>
            <method name="removeVetoableChangeListener" type="void" line="1569">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="listener" type="VetoableChangeListener"/>
                </params>
                <scope line="1570">
                    <scope line="1571">
                        <scope line="1572"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1580">
                Returns an array of all the &lt;code&gt;VetoableChangeListener&lt;/code&gt;s
                  associated with the named property.                
                <return>
                    all of the <code>VetoableChangeListener</code>s associated with
                      the named property or an empty array if no such listeners have
                      been added.                    
                </return>
                <see>
                    #addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)                    
                </see>
                <see>
                    #removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)                    
                </see>
                <see>
                    #getVetoableChangeListeners                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getVetoableChangeListeners" type="VetoableChangeListener[]" line="1593">
                <params>
                    <param name="propertyName" type="String"/>
                </params>
                <scope line="1594"/>
            </method>
            <javadoc line="1600">
                Fires a PropertyChangeEvent in response to a change in a vetoable
                  property. The event will be delivered to all registered
                  VetoableChangeListeners. If a VetoableChangeListener throws a
                  PropertyVetoException, a new event is fired reverting all
                  VetoableChangeListeners to the old value and the exception is then
                  rethrown. No event will be delivered if oldValue and newValue are the
                  same.                
                <param>
                    propertyName the name of the property that has changed                    
                </param>
                <param>
                    oldValue the property's previous value                    
                </param>
                <param>
                    newValue the property's new value                    
                </param>
                <throws>
                    java.beans.PropertyVetoException if a
                      <code>VetoableChangeListener</code> threw
                      <code>PropertyVetoException</code>                    
                </throws>
            </javadoc>
            <method name="fireVetoableChange" type="void" line="1619">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="oldValue" type="Object"/>
                    <param name="newValue" type="Object"/>
                </params>
                <scope line="1620"/>
                <declaration name="vetoableSupport" type="VetoableChangeSupport" line="1623"/>
                <scope line="1625"/>
            </method>
            <javadoc line="1631">
                Adds a KeyEventDispatcher to this KeyboardFocusManager&apos;s dispatcher
                  chain. This KeyboardFocusManager will request that each
                  KeyEventDispatcher dispatch KeyEvents generated by the user before
                  finally dispatching the KeyEvent itself. KeyEventDispatchers will be
                  notified in the order in which they were added. Notifications will halt
                  as soon as one KeyEventDispatcher returns &lt;code&gt;true&lt;/code&gt; from its
                  &lt;code&gt;dispatchKeyEvent&lt;/code&gt; method. There is no limit to the total
                  number of KeyEventDispatchers which can be added, nor to the number of
                  times which a particular KeyEventDispatcher instance can be added.
                  &lt;p&gt;
                  If a null dispatcher is specified, no action is taken and no exception
                  is thrown.
                  &lt;p&gt;
                  In a multithreaded application, {@link KeyEventDispatcher} behaves
                  the same as other AWT listeners.  See
                  &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for more details.                
                <param>
                    dispatcher the KeyEventDispatcher to add to the dispatcher chain                    
                </param>
                <see>
                    #removeKeyEventDispatcher                    
                </see>
            </javadoc>
            <method name="addKeyEventDispatcher" type="void" line="1653">
                <params>
                    <param name="dispatcher" type="KeyEventDispatcher"/>
                </params>
                <scope line="1654">
                    <scope line="1655">
                        <scope line="1656"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1664">
                Removes a KeyEventDispatcher which was previously added to this
                  KeyboardFocusManager&apos;s dispatcher chain. This KeyboardFocusManager
                  cannot itself be removed, unless it was explicitly re-registered via a
                  call to &lt;code&gt;addKeyEventDispatcher&lt;/code&gt;.
                  &lt;p&gt;
                  If a null dispatcher is specified, if the specified dispatcher is not
                  in the dispatcher chain, or if this KeyboardFocusManager is specified
                  without having been explicitly re-registered, no action is taken and no
                  exception is thrown.
                  &lt;p&gt;
                  In a multithreaded application, {@link KeyEventDispatcher} behaves
                  the same as other AWT listeners.  See
                  &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for more details.                
                <param>
                    dispatcher the KeyEventDispatcher to remove from the dispatcher
                      chain                    
                </param>
                <see>
                    #addKeyEventDispatcher                    
                </see>
            </javadoc>
            <method name="removeKeyEventDispatcher" type="void" line="1684">
                <params>
                    <param name="dispatcher" type="KeyEventDispatcher"/>
                </params>
                <scope line="1685">
                    <scope line="1686">
                        <scope line="1687"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1694">
                Returns this KeyboardFocusManager&apos;s KeyEventDispatcher chain as a List.
                  The List will not include this KeyboardFocusManager unless it was
                  explicitly re-registered via a call to
                  &lt;code&gt;addKeyEventDispatcher&lt;/code&gt;. If no other KeyEventDispatchers are
                  registered, implementations are free to return null or a List of length
                  0. Client code should not assume one behavior over another, nor should
                  it assume that the behavior, once established, will not change.                
                <return>
                    a possibly null or empty List of KeyEventDispatchers                    
                </return>
                <see>
                    #addKeyEventDispatcher                    
                </see>
                <see>
                    #removeKeyEventDispatcher                    
                </see>
            </javadoc>
            <method name="getKeyEventDispatchers" type="java.util.List<KeyEventDispatcher>" line="1709"/>
            <javadoc line="1715">
                Adds a KeyEventPostProcessor to this KeyboardFocusManager&apos;s post-
                  processor chain. After a KeyEvent has been dispatched to and handled by
                  its target, KeyboardFocusManager will request that each
                  KeyEventPostProcessor perform any necessary post-processing as part
                  of the KeyEvent&apos;s final resolution. KeyEventPostProcessors
                  will be notified in the order in which they were added; the current
                  KeyboardFocusManager will be notified last. Notifications will halt
                  as soon as one KeyEventPostProcessor returns &lt;code&gt;true&lt;/code&gt; from its
                  &lt;code&gt;postProcessKeyEvent&lt;/code&gt; method. There is no limit to the the
                  total number of KeyEventPostProcessors that can be added, nor to the
                  number of times that a particular KeyEventPostProcessor instance can be
                  added.
                  &lt;p&gt;
                  If a null post-processor is specified, no action is taken and no
                  exception is thrown.
                  &lt;p&gt;
                  In a multithreaded application, {@link KeyEventPostProcessor} behaves
                  the same as other AWT listeners.  See
                  &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for more details.                
                <param>
                    processor the KeyEventPostProcessor to add to the post-processor
                      chain                    
                </param>
                <see>
                    #removeKeyEventPostProcessor                    
                </see>
            </javadoc>
            <method name="addKeyEventPostProcessor" type="void" line="1741">
                <params>
                    <param name="processor" type="KeyEventPostProcessor"/>
                </params>
                <scope line="1742">
                    <scope line="1743">
                        <scope line="1744"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1753">
                Removes a previously added KeyEventPostProcessor from this
                  KeyboardFocusManager&apos;s post-processor chain. This KeyboardFocusManager
                  cannot itself be entirely removed from the chain. Only additional
                  references added via &lt;code&gt;addKeyEventPostProcessor&lt;/code&gt; can be
                  removed.
                  &lt;p&gt;
                  If a null post-processor is specified, if the specified post-processor
                  is not in the post-processor chain, or if this KeyboardFocusManager is
                  specified without having been explicitly added, no action is taken and
                  no exception is thrown.
                  &lt;p&gt;
                  In a multithreaded application, {@link KeyEventPostProcessor} behaves
                  the same as other AWT listeners.  See
                  &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for more details.                
                <param>
                    processor the KeyEventPostProcessor to remove from the post-
                      processor chain                    
                </param>
                <see>
                    #addKeyEventPostProcessor                    
                </see>
            </javadoc>
            <method name="removeKeyEventPostProcessor" type="void" line="1774">
                <params>
                    <param name="processor" type="KeyEventPostProcessor"/>
                </params>
                <scope line="1775">
                    <scope line="1776">
                        <scope line="1777"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1785">
                Returns this KeyboardFocusManager&apos;s KeyEventPostProcessor chain as a
                  List. The List will not include this KeyboardFocusManager unless it was
                  explicitly added via a call to &lt;code&gt;addKeyEventPostProcessor&lt;/code&gt;. If
                  no KeyEventPostProcessors are registered, implementations are free to
                  return null or a List of length 0. Client code should not assume one
                  behavior over another, nor should it assume that the behavior, once
                  established, will not change.                
                <return>
                    a possibly null or empty List of KeyEventPostProcessors                    
                </return>
                <see>
                    #addKeyEventPostProcessor                    
                </see>
                <see>
                    #removeKeyEventPostProcessor                    
                </see>
            </javadoc>
            <method name="getKeyEventPostProcessors" type="java.util.List<KeyEventPostProcessor>" line="1800"/>
            <method name="setMostRecentFocusOwner" type="void" line="1808">
                <params>
                    <param name="component" type="Component"/>
                </params>
                <declaration name="window" type="Component" line="1809"/>
                <scope line="1810"/>
                <scope line="1813"/>
            </method>
            <method name="setMostRecentFocusOwner" type="void" line="1818">
                <params>
                    <param name="window" type="Window"/>
                    <param name="component" type="Component"/>
                </params>
                <comment line="1819">
                    ATTN: component has a strong reference to window via chain                    
                </comment>
                <comment line="1820">
                    of Component.parent fields.  Since WeakHasMap refers to its                    
                </comment>
                <comment line="1821">
                    values strongly, we need to break the strong link from the                    
                </comment>
                <comment line="1822">
                    value (component) back to its key (window).                    
                </comment>
                <declaration name="weakValue" type="WeakReference" line="1823"/>
                <scope line="1824"/>
            </method>
            <method name="clearMostRecentFocusOwner" type="void" line="1829">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <comment line="1849">
                    Also clear temporary lost component stored in Window                    
                </comment>
                <declaration name="window" type="Container" line="1830"/>
                <scope line="1832"/>
                <scope line="1836">
                    <scope line="1838"/>
                </scope>
                <scope line="1843">
                    <scope line="1846"/>
                    <scope line="1850">
                        <declaration name="realWindow" type="Window" line="1851"/>
                        <scope line="1852"/>
                    </scope>
                </scope>
            </method>
            <method name="getMostRecentFocusOwner" type="Component" line="1863">
                <params>
                    <param name="window" type="Window"/>
                </params>
                <declaration name="weakValue" type="WeakReference" line="1864"/>
            </method>
            <method name="dispatchEvent" type="boolean" line="1869"/>
            <javadoc line="1869">
                This method is called by the AWT event dispatcher requesting that the
                  current KeyboardFocusManager dispatch the specified event on its behalf.
                  It is expected that all KeyboardFocusManagers will dispatch all
                  FocusEvents, all WindowEvents related to focus, and all KeyEvents.
                  These events should be dispatched based on the KeyboardFocusManager&apos;s
                  notion of the focus owner and the focused and active Windows, sometimes
                  overriding the source of the specified AWTEvent. Dispatching must be
                  done using &lt;code&gt;redispatchEvent&lt;/code&gt; to prevent the AWT event
                  dispatcher from recursively requesting that the KeyboardFocusManager
                  dispatch the event again. If this method returns &lt;code&gt;false&lt;/code&gt;,
                  then the AWT event dispatcher will attempt to dispatch the event itself.                
                <param>
                    e the AWTEvent to be dispatched                    
                </param>
                <return>
                    <code>true</code> if this method dispatched the event;
                      <code>false</code> otherwise                    
                </return>
                <see>
                    #redispatchEvent                    
                </see>
                <see>
                    #dispatchKeyEvent                    
                </see>
            </javadoc>
            <javadoc line="1890">
                Redispatches an AWTEvent in such a way that the AWT event dispatcher
                  will not recursively request that the KeyboardFocusManager, or any
                  installed KeyEventDispatchers, dispatch the event again. Client
                  implementations of &lt;code&gt;dispatchEvent&lt;/code&gt; and client-defined
                  KeyEventDispatchers must call &lt;code&gt;redispatchEvent(target, e)&lt;/code&gt;
                  instead of &lt;code&gt;target.dispatchEvent(e)&lt;/code&gt; to dispatch an event.
                  &lt;p&gt;
                  This method is intended to be used only by KeyboardFocusManagers and
                  KeyEventDispatchers. It is not for general client use.                
                <param>
                    target the Component to which the event should be dispatched                    
                </param>
                <param>
                    e the event to dispatch                    
                </param>
                <see>
                    #dispatchEvent                    
                </see>
                <see>
                    KeyEventDispatcher                    
                </see>
            </javadoc>
            <method name="redispatchEvent" type="void" line="1906">
                <params>
                    <param name="target" type="Component"/>
                    <param name="e" type="AWTEvent"/>
                </params>
            </method>
            <method name="dispatchKeyEvent" type="boolean" line="1912"/>
            <javadoc line="1912">
                Typically this method will be called by &lt;code&gt;dispatchEvent&lt;/code&gt; if no
                  other KeyEventDispatcher in the dispatcher chain dispatched the
                  KeyEvent, or if no other KeyEventDispatchers are registered. If an
                  implementation of this method returns &lt;code&gt;false&lt;/code&gt;,
                  &lt;code&gt;dispatchEvent&lt;/code&gt; may try to dispatch the KeyEvent itself, or
                  may simply return &lt;code&gt;false&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt; is returned,
                  &lt;code&gt;dispatchEvent&lt;/code&gt; should return &lt;code&gt;true&lt;/code&gt; as well.                
                <param>
                    e the KeyEvent which the current KeyboardFocusManager has
                      requested that this KeyEventDispatcher dispatch                    
                </param>
                <return>
                    <code>true</code> if the KeyEvent was dispatched;
                      <code>false</code> otherwise                    
                </return>
                <see>
                    #dispatchEvent                    
                </see>
            </javadoc>
            <method name="postProcessKeyEvent" type="boolean" line="1929"/>
            <javadoc line="1929">
                This method will be called by &lt;code&gt;dispatchKeyEvent&lt;/code&gt;.
                  By default, this method will handle any unconsumed KeyEvents that
                  map to an AWT &lt;code&gt;MenuShortcut&lt;/code&gt; by consuming the event
                  and activating the shortcut.                
                <param>
                    e the KeyEvent to post-process                    
                </param>
                <return>
                    <code>true</code> to indicate that no other
                      KeyEventPostProcessor will be notified of the KeyEvent.                    
                </return>
                <see>
                    #dispatchKeyEvent                    
                </see>
                <see>
                    MenuShortcut                    
                </see>
            </javadoc>
            <method name="processKeyEvent" type="void" line="1943"/>
            <javadoc line="1943">
                This method initiates a focus traversal operation if and only if the
                  KeyEvent represents a focus traversal key for the specified
                  focusedComponent. It is expected that focusedComponent is the current
                  focus owner, although this need not be the case. If it is not,
                  focus traversal will nevertheless proceed as if focusedComponent
                  were the current focus owner.                
                <param>
                    focusedComponent the Component that will be the basis for a focus
                      traversal operation if the specified event represents a focus
                      traversal key for the Component                    
                </param>
                <param>
                    e the event that may represent a focus traversal key                    
                </param>
            </javadoc>
            <method name="enqueueKeyEvents" type="void" line="1959"/>
            <javadoc line="1959">
                Called by the AWT to notify the KeyboardFocusManager that it should
                  delay dispatching of KeyEvents until the specified Component becomes
                  the focus owner. If client code requests a focus change, and the AWT
                  determines that this request might be granted by the native windowing
                  system, then the AWT will call this method. It is the responsibility of
                  the KeyboardFocusManager to delay dispatching of KeyEvents with
                  timestamps later than the specified time stamp until the specified
                  Component receives a FOCUS_GAINED event, or the AWT cancels the delay
                  request by invoking &lt;code&gt;dequeueKeyEvents&lt;/code&gt; or
                  &lt;code&gt;discardKeyEvents&lt;/code&gt;.                
                <param>
                    after timestamp of current event, or the current, system time if
                      the current event has no timestamp, or the AWT cannot determine
                      which event is currently being handled                    
                </param>
                <param>
                    untilFocused Component which should receive a FOCUS_GAINED event
                      before any pending KeyEvents                    
                </param>
                <see>
                    #dequeueKeyEvents                    
                </see>
                <see>
                    #discardKeyEvents                    
                </see>
            </javadoc>
            <method name="dequeueKeyEvents" type="void" line="1982"/>
            <javadoc line="1982">
                Called by the AWT to notify the KeyboardFocusManager that it should
                  cancel delayed dispatching of KeyEvents. All KeyEvents which were
                  enqueued because of a call to &lt;code&gt;enqueueKeyEvents&lt;/code&gt; with the
                  same timestamp and Component should be released for normal dispatching
                  to the current focus owner. If the given timestamp is less than zero,
                  the outstanding enqueue request for the given Component with the &lt;b&gt;
                  oldest&lt;/b&gt; timestamp (if any) should be cancelled.                
                <param>
                    after the timestamp specified in the call to
                      <code>enqueueKeyEvents</code>, or any value < 0                    
                </param>
                <param>
                    untilFocused the Component specified in the call to
                      <code>enqueueKeyEvents</code>                    
                </param>
                <see>
                    #enqueueKeyEvents                    
                </see>
                <see>
                    #discardKeyEvents                    
                </see>
            </javadoc>
            <method name="discardKeyEvents" type="void" line="2001"/>
            <javadoc line="2001">
                Called by the AWT to notify the KeyboardFocusManager that it should
                  cancel delayed dispatching of KeyEvents. All KeyEvents which were
                  enqueued because of one or more calls to &lt;code&gt;enqueueKeyEvents&lt;/code&gt;
                  with the same Component should be discarded.                
                <param>
                    comp the Component specified in one or more calls to
                      <code>enqueueKeyEvents</code>                    
                </param>
                <see>
                    #enqueueKeyEvents                    
                </see>
                <see>
                    #dequeueKeyEvents                    
                </see>
            </javadoc>
            <method name="focusNextComponent" type="void" line="2014"/>
            <javadoc line="2014">
                Focuses the Component after aComponent, typically based on a
                  FocusTraversalPolicy.                
                <param>
                    aComponent the Component that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    FocusTraversalPolicy                    
                </see>
            </javadoc>
            <method name="focusPreviousComponent" type="void" line="2024"/>
            <javadoc line="2024">
                Focuses the Component before aComponent, typically based on a
                  FocusTraversalPolicy.                
                <param>
                    aComponent the Component that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    FocusTraversalPolicy                    
                </see>
            </javadoc>
            <method name="upFocusCycle" type="void" line="2034"/>
            <javadoc line="2034">
                Moves the focus up one focus traversal cycle. Typically, the focus owner
                  is set to aComponent&apos;s focus cycle root, and the current focus cycle
                  root is set to the new focus owner&apos;s focus cycle root. If, however,
                  aComponent&apos;s focus cycle root is a Window, then typically the focus
                  owner is set to the Window&apos;s default Component to focus, and the current
                  focus cycle root is unchanged.                
                <param>
                    aComponent the Component that is the basis for the focus
                      traversal operation                    
                </param>
            </javadoc>
            <method name="downFocusCycle" type="void" line="2047"/>
            <javadoc line="2047">
                Moves the focus down one focus traversal cycle. Typically, if
                  aContainer is a focus cycle root, then the focus owner is set to
                  aContainer&apos;s default Component to focus, and the current focus cycle
                  root is set to aContainer. If aContainer is not a focus cycle root, then
                  no focus traversal operation occurs.                
                <param>
                    aContainer the Container that is the basis for the focus
                      traversal operation                    
                </param>
            </javadoc>
            <javadoc line="2059">
                Focuses the Component after the current focus owner.                
            </javadoc>
            <method name="focusNextComponent" type="void" line="2062">
                <declaration name="focusOwner" type="Component" line="2063"/>
                <scope line="2064"/>
            </method>
            <javadoc line="2069">
                Focuses the Component before the current focus owner.                
            </javadoc>
            <method name="focusPreviousComponent" type="void" line="2072">
                <declaration name="focusOwner" type="Component" line="2073"/>
                <scope line="2074"/>
            </method>
            <javadoc line="2079">
                Moves the focus up one focus traversal cycle from the current focus
                  owner. Typically, the new focus owner is set to the current focus
                  owner&apos;s focus cycle root, and the current focus cycle root is set to the
                  new focus owner&apos;s focus cycle root. If, however, the current focus
                  owner&apos;s focus cycle root is a Window, then typically the focus owner is
                  set to the focus cycle root&apos;s default Component to focus, and the
                  current focus cycle root is unchanged.                
            </javadoc>
            <method name="upFocusCycle" type="void" line="2088">
                <declaration name="focusOwner" type="Component" line="2089"/>
                <scope line="2090"/>
            </method>
            <javadoc line="2095">
                Moves the focus down one focus traversal cycle from the current focus
                  owner, if and only if the current focus owner is a Container that is a
                  focus cycle root. Typically, the focus owner is set to the current focus
                  owner&apos;s default Component to focus, and the current focus cycle root is
                  set to the current focus owner. If the current focus owner is not a
                  Container that is a focus cycle root, then no focus traversal operation
                  occurs.                
            </javadoc>
            <method name="downFocusCycle" type="void" line="2104">
                <declaration name="focusOwner" type="Component" line="2105"/>
                <scope line="2106"/>
            </method>
            <javadoc line="2111">
                Dumps the list of focus requests to stderr                
            </javadoc>
            <method name="dumpRequests" type="void" line="2114">
                <scope line="2116">
                    <scope line="2117"/>
                </scope>
            </method>
            <class name="LightweightFocusRequest" line="2124">
                <declaration name="component" type="Component" line="2125"/>
                <declaration name="temporary" type="boolean" line="2126"/>
                <declaration name="cause" type="CausedFocusEvent.Cause" line="2127"/>
                <method name="LightweightFocusRequest" type="constructor" line="2129">
                    <params>
                        <param name="component" type="Component"/>
                        <param name="temporary" type="boolean"/>
                        <param name="cause" type="CausedFocusEvent.Cause"/>
                    </params>
                </method>
                <method name="toString" type="String" line="2134"/>
            </class>
            <class name="HeavyweightFocusRequest" line="2140">
                <declaration name="heavyweight" type="Component" line="2141"/>
                <declaration name="lightweightRequests" type="LinkedList&lt;LightweightFocusRequest&gt;" line="2142"/>
                <declaration name="CLEAR_GLOBAL_FOCUS_OWNER" type="HeavyweightFocusRequest" line="2144"/>
                <method name="HeavyweightFocusRequest" type="constructor" line="2147"/>
                <method name="HeavyweightFocusRequest" type="constructor" line="2153">
                    <params>
                        <param name="heavyweight" type="Component"/>
                        <param name="descendant" type="Component"/>
                        <param name="temporary" type="boolean"/>
                        <param name="cause" type="CausedFocusEvent.Cause"/>
                    </params>
                    <scope line="2154">
                        <scope line="2155"/>
                    </scope>
                </method>
                <method name="addLightweightRequest" type="boolean" line="2165">
                    <params>
                        <param name="descendant" type="Component"/>
                        <param name="temporary" type="boolean"/>
                        <param name="cause" type="CausedFocusEvent.Cause"/>
                    </params>
                    <comment line="2180">
                        Not a duplicate request                        
                    </comment>
                    <scope line="2166">
                        <scope line="2167"/>
                        <scope line="2170"/>
                    </scope>
                    <declaration name="lastDescendant" type="Component" line="2175"/>
                    <scope line="2179"/>
                    <scope line="2184"/>
                </method>
                <method name="getFirstLightweightRequest" type="LightweightFocusRequest" line="2189">
                    <scope line="2190"/>
                </method>
                <method name="toString" type="String" line="2195">
                    <declaration name="first" type="boolean" line="2196"/>
                    <declaration name="str" type="String" line="2197"/>
                    <scope line="2199"/>
                    <scope line="2201">
                        <scope line="2204">
                            <scope line="2205"/>
                            <scope line="2207"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <declaration name="heavyweightRequests" type="LinkedList&lt;HeavyweightFocusRequest&gt;" line="2224"/>
            <declaration name="currentLightweightRequests" type="LinkedList&lt;LightweightFocusRequest&gt;" line="2226"/>
            <declaration name="clearingCurrentLightweightRequests" type="boolean" line="2227"/>
            <declaration name="allowSyncFocusRequests" type="boolean" line="2228"/>
            <declaration name="newFocusOwner" type="Component" line="2229"/>
            <declaration name="disableRestoreFocus" type="boolean" line="2230"/>
            <declaration name="SNFH_FAILURE" type="int" line="2232"/>
            <declaration name="SNFH_SUCCESS_HANDLED" type="int" line="2233"/>
            <declaration name="SNFH_SUCCESS_PROCEED" type="int" line="2234"/>
            <method name="processSynchronousLightweightTransfer" type="boolean" line="2239">
                <params>
                    <param name="heavyweight" type="Component"/>
                    <param name="descendant" type="Component"/>
                    <param name="temporary" type="boolean"/>
                    <param name="focusedWindowChangeAllowed" type="boolean"/>
                    <param name="time" type="long"/>
                </params>
                <comment line="2245">
                    Focus transfers from a lightweight child back to the                    
                </comment>
                <comment line="2246">
                    heavyweight Container should be treated like lightweight                    
                </comment>
                <comment line="2247">
                    focus transfers.                    
                </comment>
                <comment line="2265">
                    Redundant request.                    
                </comment>
                <comment line="2269">
                    &apos;heavyweight&apos; owns the native focus and there are no pending                    
                </comment>
                <comment line="2270">
                    requests. &apos;heavyweight&apos; must be a Container and                    
                </comment>
                <comment line="2271">
                    &apos;descendant&apos; must not be the focus owner. Otherwise,                    
                </comment>
                <comment line="2272">
                    we would never have gotten this far.                    
                </comment>
                <declaration name="parentWindow" type="Window" line="2240"/>
                <scope line="2241"/>
                <scope line="2244"/>
                <declaration name="manager" type="KeyboardFocusManager" line="2251"/>
                <declaration name="currentFocusOwnerEvent" type="FocusEvent" line="2253"/>
                <declaration name="newFocusOwnerEvent" type="FocusEvent" line="2254"/>
                <declaration name="currentFocusOwner" type="Component" line="2255"/>
                <scope line="2257">
                    <declaration name="hwFocusRequest" type="HeavyweightFocusRequest" line="2258"/>
                    <scope line="2262">
                        <scope line="2264"/>
                        <scope line="2280"/>
                    </scope>
                </scope>
                <declaration name="result" type="boolean" line="2291"/>
                <declaration name="clearing" type="boolean" line="2292"/>
                <declaration name="caughtEx" type="Throwable" line="2294"/>
                <scope line="2295">
                    <scope line="2297">
                        <scope line="2299"/>
                        <scope line="2305"/>
                    </scope>
                </scope>
                <scope line="2311"/>
                <scope line="2314"/>
                <scope line="2316"/>
            </method>
            <javadoc line="2322">
                Indicates whether the native implementation should proceed with a
                  pending, native focus request. Before changing the focus at the native
                  level, the AWT implementation should always call this function for
                  permission. This function will reject the request if a duplicate request
                  preceded it, or if the specified heavyweight Component already owns the
                  focus and no native focus changes are pending. Otherwise, the request
                  will be approved and the focus request list will be updated so that,
                  if necessary, the proper descendant will be focused when the
                  corresponding FOCUS_GAINED event on the heavyweight is received.
                  An implementation must ensure that calls to this method and native
                  focus changes are atomic. If this is not guaranteed, then the ordering
                  of the focus request list may be incorrect, leading to errors in the
                  type-ahead mechanism. Typically this is accomplished by only calling
                  this function from the native event pumping thread, or by holding a
                  global, native lock during invocation.                
            </javadoc>
            <method name="shouldNativelyFocusHeavyweight" type="int" line="2343">
                <params>
                    <param name="heavyweight" type="Component"/>
                    <param name="descendant" type="Component"/>
                    <param name="temporary" type="boolean"/>
                    <param name="focusedWindowChangeAllowed" type="boolean"/>
                    <param name="time" type="long"/>
                    <param name="cause" type="CausedFocusEvent.Cause"/>
                </params>
                <comment line="2354">
                    Focus transfers from a lightweight child back to the                    
                </comment>
                <comment line="2355">
                    heavyweight Container should be treated like lightweight                    
                </comment>
                <comment line="2356">
                    focus transfers.                    
                </comment>
                <comment line="2387">
                    Redundant request.                    
                </comment>
                <comment line="2394">
                    &apos;heavyweight&apos; owns the native focus and there are no pending                    
                </comment>
                <comment line="2395">
                    requests. &apos;heavyweight&apos; must be a Container and                    
                </comment>
                <comment line="2396">
                    &apos;descendant&apos; must not be the focus owner. Otherwise,                    
                </comment>
                <comment line="2397">
                    we would never have gotten this far.                    
                </comment>
                <comment line="2410">
                    Fix 5028014. Rolled out.                    
                </comment>
                <comment line="2411">
                    SunToolkit.postPriorityEvent(currentFocusOwnerEvent);                    
                </comment>
                <comment line="2418">
                    Fix 5028014. Rolled out.                    
                </comment>
                <comment line="2419">
                    SunToolkit.postPriorityEvent(newFocusOwnerEvent);                    
                </comment>
                <comment line="2427">
                    &apos;heavyweight&apos; doesn&apos;t have the native focus right now, but                    
                </comment>
                <comment line="2428">
                    if all pending requests were completed, it would. Add                    
                </comment>
                <comment line="2429">
                    descendant to the heavyweight&apos;s list of pending                    
                </comment>
                <comment line="2430">
                    lightweight focus transfers.                    
                </comment>
                <comment line="2442">
                    For purposes of computing oldFocusedWindow, we should look at                    
                </comment>
                <comment line="2443">
                    the second to last HeavyweightFocusRequest on the queue iff the                    
                </comment>
                <comment line="2444">
                    last HeavyweightFocusRequest is CLEAR_GLOBAL_FOCUS_OWNER. If                    
                </comment>
                <comment line="2445">
                    there is no second to last HeavyweightFocusRequest, null is an                    
                </comment>
                <comment line="2446">
                    acceptable value.                    
                </comment>
                <scope line="2344">
                    <scope line="2345"/>
                    <scope line="2348"/>
                </scope>
                <scope line="2353"/>
                <declaration name="manager" type="KeyboardFocusManager" line="2360"/>
                <declaration name="thisManager" type="KeyboardFocusManager" line="2362"/>
                <declaration name="currentFocusOwner" type="Component" line="2363"/>
                <declaration name="nativeFocusOwner" type="Component" line="2364"/>
                <declaration name="nativeFocusedWindow" type="Window" line="2365"/>
                <scope line="2366"/>
                <scope line="2370"/>
                <scope line="2378">
                    <declaration name="hwFocusRequest" type="HeavyweightFocusRequest" line="2379"/>
                    <scope line="2380"/>
                    <scope line="2385">
                        <scope line="2386"/>
                        <scope line="2405">
                            <declaration name="currentFocusOwnerEvent" type="FocusEvent" line="2406"/>
                        </scope>
                        <declaration name="newFocusOwnerEvent" type="FocusEvent" line="2415"/>
                    </scope>
                    <scope line="2426">
                        <scope line="2432"/>
                    </scope>
                    <scope line="2440">
                        <scope line="2441">
                            <scope line="2449">
                                <declaration name="size" type="int" line="2450"/>
                            </scope>
                            <scope line="2458"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="2476">
                Returns the Window which will be active after processing this request,
                  or null if this is a duplicate request. The active Window is useful
                  because some native platforms do not support setting the native focus
                  owner to null. On these platforms, the obvious choice is to set the
                  focus owner to the focus proxy of the active Window.                
            </javadoc>
            <method name="markClearGlobalFocusOwner" type="Window" line="2483">
                <comment line="2484">
                    need to call this out of synchronized block to avoid possible deadlock                    
                </comment>
                <comment line="2485">
                    see 6454631.                    
                </comment>
                <comment line="2494">
                    duplicate request                    
                </comment>
                <declaration name="nativeFocusedWindow" type="Component" line="2486"/>
                <scope line="2489">
                    <declaration name="hwFocusRequest" type="HeavyweightFocusRequest" line="2490"/>
                    <scope line="2493"/>
                    <declaration name="activeWindow" type="Component" line="2501"/>
                    <scope line="2507"/>
                </scope>
            </method>
            <method name="getCurrentWaitingRequest" type="Component" line="2514">
                <params>
                    <param name="parent" type="Component"/>
                </params>
                <scope line="2515">
                    <declaration name="hwFocusRequest" type="HeavyweightFocusRequest" line="2516"/>
                    <scope line="2517">
                        <scope line="2518">
                            <declaration name="lwFocusRequest" type="LightweightFocusRequest" line="2519"/>
                            <scope line="2521"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="isAutoFocusTransferEnabled" type="boolean" line="2530">
                <scope line="2531"/>
            </method>
            <method name="isAutoFocusTransferEnabledFor" type="boolean" line="2538">
                <params>
                    <param name="comp" type="Component"/>
                </params>
            </method>
            <method name="dispatchAndCatchException" type="Throwable" line="2548">
                <params>
                    <param name="ex" type="Throwable"/>
                    <param name="comp" type="Component"/>
                    <param name="event" type="FocusEvent"/>
                </params>
                <declaration name="retEx" type="Throwable" line="2549"/>
                <scope line="2550"/>
                <scope line="2552"/>
                <scope line="2554"/>
                <scope line="2557">
                    <scope line="2558"/>
                </scope>
            </method>
            <method name="handleException" type="void" line="2566">
                <params>
                    <param name="ex" type="Throwable"/>
                </params>
            </method>
            <method name="processCurrentLightweightRequests" type="void" line="2570">
                <comment line="2578">
                    The current app context differs from the app context of a focus                    
                </comment>
                <comment line="2579">
                    owner (and all pending lightweight requests), so we do nothing                    
                </comment>
                <comment line="2580">
                    now and wait for a next event.                    
                </comment>
                <comment line="2592">
                    do nothing                    
                </comment>
                <comment line="2609">
                    WARNING: This is based on DKFM&apos;s logic solely!
                    
                     We allow to trigger restoreFocus() in the dispatching process
                     only if we have the last request to dispatch. If the last request
                     fails, focus will be restored to either the component of the last
                     previously succedded request, or to to the focus owner that was
                     before this clearing proccess.                    
                </comment>
                <comment line="2623">
                    We&apos;re not dispatching FOCUS_LOST while the current focus owner is null.
                     But regardless of whether it&apos;s null or not, we&apos;re clearing ALL the local
                     lw requests.                    
                </comment>
                <declaration name="manager" type="KeyboardFocusManager" line="2571"/>
                <declaration name="localLightweightRequests" type="LinkedList&lt;LightweightFocusRequest&gt;" line="2572"/>
                <declaration name="globalFocusOwner" type="Component" line="2574"/>
                <scope line="2577"/>
                <scope line="2584">
                    <scope line="2585"/>
                    <scope line="2591"/>
                </scope>
                <declaration name="caughtEx" type="Throwable" line="2597"/>
                <scope line="2598">
                    <scope line="2599">
                        <declaration name="lastFocusOwner" type="Component" line="2600"/>
                        <declaration name="currentFocusOwner" type="Component" line="2601"/>
                        <scope line="2603">
                            <declaration name="lwFocusRequest" type="LightweightFocusRequest" line="2606"/>
                            <scope line="2618"/>
                            <declaration name="currentFocusOwnerEvent" type="FocusEvent" line="2622"/>
                            <scope line="2628"/>
                            <declaration name="newFocusOwnerEvent" type="FocusEvent" line="2634"/>
                            <scope line="2641"/>
                            <scope line="2649"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2654"/>
                <scope line="2660"/>
                <scope line="2662"/>
            </method>
            <method name="retargetUnexpectedFocusEvent" type="FocusEvent" line="2667">
                <params>
                    <param name="fe" type="FocusEvent"/>
                </params>
                <comment line="2669">
                    Any other case represents a failure condition which we did                    
                </comment>
                <comment line="2670">
                    not expect. We need to clearFocusRequestList() and patch up                    
                </comment>
                <comment line="2671">
                    the event as best as possible.                    
                </comment>
                <scope line="2668">
                    <scope line="2673"/>
                    <declaration name="source" type="Component" line="2677"/>
                    <declaration name="opposite" type="Component" line="2678"/>
                    <declaration name="temporary" type="boolean" line="2679"/>
                    <scope line="2682"/>
                </scope>
            </method>
            <method name="retargetFocusGained" type="FocusEvent" line="2690">
                <params>
                    <param name="fe" type="FocusEvent"/>
                </params>
                <comment line="2708">
                    if source w/o peer and                    
                </comment>
                <comment line="2709">
                    if source is equal to first lightweight                    
                </comment>
                <comment line="2710">
                    then we should correct source and nativeSource                    
                </comment>
                <comment line="2714">
                    source is heavuweight itself                    
                </comment>
                <comment line="2720">
                    Focus change as a result of a known call to requestFocus(),                    
                </comment>
                <comment line="2721">
                    or known click on a peer focusable heavyweight Component.                    
                </comment>
                <comment line="2730">
                    Since we receive FOCUS_GAINED when current focus
                     owner is not null, correcponding FOCUS_LOST is supposed
                     to be lost.  And so,  we keep new focus owner
                     to determine synthetic FOCUS_LOST event which will be
                     generated by KeyboardFocusManager for this FOCUS_GAINED.
                    
                     This code based on knowledge of
                     DefaultKeyboardFocusManager&apos;s implementation and might
                     be not applicable for another KeyboardFocusManager.                    
                </comment>
                <comment line="2759">
                    &apos;opposite&apos; will be fixed by                    
                </comment>
                <comment line="2760">
                    DefaultKeyboardFocusManager.realOppositeComponent                    
                </comment>
                <comment line="2770">
                    Special case for FOCUS_GAINED in top-levels                    
                </comment>
                <comment line="2771">
                    If it arrives as the result of activation we should skip it                    
                </comment>
                <comment line="2772">
                    This event will not have appropriate request record and                    
                </comment>
                <comment line="2773">
                    on arrival there will be already some focus owner set.                    
                </comment>
                <comment line="2779">
                    end synchronized(heavyweightRequests)                    
                </comment>
                <declaration name="currentFocusOwner" type="Component" line="2693"/>
                <declaration name="source" type="Component" line="2695"/>
                <declaration name="opposite" type="Component" line="2696"/>
                <declaration name="nativeSource" type="Component" line="2697"/>
                <scope line="2699">
                    <declaration name="hwFocusRequest" type="HeavyweightFocusRequest" line="2700"/>
                    <scope line="2703"/>
                    <scope line="2707">
                        <scope line="2712"/>
                    </scope>
                    <scope line="2719">
                        <declaration name="lwFocusRequest" type="LightweightFocusRequest" line="2725"/>
                        <declaration name="newSource" type="Component" line="2728"/>
                        <scope line="2729"/>
                        <declaration name="temporary" type="boolean" line="2744"/>
                        <scope line="2749">
                            <anonymous_class line="2752">
                                <method name="run" type="void" line="2753"/>
                            </anonymous_class>
                        </scope>
                    </scope>
                    <scope line="2769"/>
                </scope>
            </method>
            <method name="retargetFocusLost" type="FocusEvent" line="2782">
                <params>
                    <param name="fe" type="FocusEvent"/>
                </params>
                <comment line="2796">
                    Call to KeyboardFocusManager.clearGlobalFocusOwner()                    
                </comment>
                <comment line="2803">
                    Otherwise, fall through to failure case below                    
                </comment>
                <comment line="2807">
                    Focus leaving application                    
                </comment>
                <comment line="2823">
                    Focus change as a result of a known call to requestFocus(),                    
                </comment>
                <comment line="2824">
                    or click on a peer focusable heavyweight Component.                    
                </comment>
                <comment line="2825">
                    If a focus transfer is made across top-levels, then the                    
                </comment>
                <comment line="2826">
                    FOCUS_LOST event is always temporary, and the FOCUS_GAINED                    
                </comment>
                <comment line="2827">
                    event is always permanent. Otherwise, the stored temporary                    
                </comment>
                <comment line="2828">
                    value is honored.                    
                </comment>
                <comment line="2840">
                    If top-level changed there might be no focus request in a list                    
                </comment>
                <comment line="2841">
                    But we know the opposite, we now it is temporary - dispatch the event.                    
                </comment>
                <comment line="2843">
                    Create copy of the event with only difference in temporary parameter.                    
                </comment>
                <comment line="2851">
                    end synchronized(heavyweightRequests)                    
                </comment>
                <declaration name="currentFocusOwner" type="Component" line="2785"/>
                <declaration name="opposite" type="Component" line="2787"/>
                <declaration name="nativeOpposite" type="Component" line="2788"/>
                <scope line="2790">
                    <declaration name="hwFocusRequest" type="HeavyweightFocusRequest" line="2791"/>
                    <scope line="2794">
                        <scope line="2795"/>
                    </scope>
                    <scope line="2806">
                        <scope line="2808"/>
                        <scope line="2812"/>
                    </scope>
                    <scope line="2819">
                        <scope line="2820"/>
                        <declaration name="lwFocusRequest" type="LightweightFocusRequest" line="2830"/>
                        <declaration name="temporary" type="boolean" line="2833"/>
                    </scope>
                    <scope line="2839">
                        <scope line="2842"/>
                    </scope>
                </scope>
            </method>
            <method name="retargetFocusEvent" type="AWTEvent" line="2854">
                <params>
                    <param name="event" type="AWTEvent"/>
                </params>
                <comment line="2872">
                    This code handles FOCUS_LOST event which is generated by
                     DefaultKeyboardFocusManager for FOCUS_GAINED.
                    
                     This code based on knowledge of DefaultKeyboardFocusManager&apos;s
                     implementation and might be not applicable for another
                     KeyboardFocusManager.
                    
                     Fix for 4472032                    
                </comment>
                <comment line="2908">
                                        
                </comment>
                <scope line="2855"/>
                <declaration name="manager" type="KeyboardFocusManager" line="2859"/>
                <scope line="2860">
                    <scope line="2861"/>
                    <scope line="2864"/>
                </scope>
                <scope line="2871">
                    <scope line="2884">
                        <declaration name="fe" type="FocusEvent" line="2885"/>
                        <scope line="2889"/>
                    </scope>
                </scope>
                <scope line="2899"/>
                <scope line="2903"/>
            </method>
            <javadoc line="2913">
                Clears markers queue
                  This method is not intended to be overridden by KFM&apos;s.
                  Only DefaultKeyboardFocusManager can implement it.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="clearMarkers" type="void" line="2919"/>
            <method name="removeFirstRequest" type="boolean" line="2922">
                <comment line="2942">
                    Fix for 4799136 - clear type-ahead markers if requests queue is empty                    
                </comment>
                <comment line="2943">
                    We do it here because this method is called only when problems happen                    
                </comment>
                <declaration name="manager" type="KeyboardFocusManager" line="2923"/>
                <scope line="2926">
                    <declaration name="hwFocusRequest" type="HeavyweightFocusRequest" line="2927"/>
                    <scope line="2929">
                        <scope line="2931">
                            <scope line="2935"/>
                        </scope>
                    </scope>
                    <scope line="2944"/>
                </scope>
            </method>
            <method name="removeLastFocusRequest" type="void" line="2950">
                <params>
                    <param name="heavyweight" type="Component"/>
                </params>
                <comment line="2965">
                    Fix for 4799136 - clear type-ahead markers if requests queue is empty                    
                </comment>
                <comment line="2966">
                    We do it here because this method is called only when problems happen                    
                </comment>
                <scope line="2951">
                    <scope line="2952"/>
                </scope>
                <declaration name="manager" type="KeyboardFocusManager" line="2957"/>
                <scope line="2959">
                    <declaration name="hwFocusRequest" type="HeavyweightFocusRequest" line="2960"/>
                    <scope line="2962"/>
                    <scope line="2967"/>
                </scope>
            </method>
            <method name="focusedWindowChanged" type="boolean" line="2973">
                <params>
                    <param name="to" type="Component"/>
                    <param name="from" type="Component"/>
                </params>
                <declaration name="wto" type="Window" line="2974"/>
                <declaration name="wfrom" type="Window" line="2975"/>
                <scope line="2976"/>
                <scope line="2979"/>
                <scope line="2982"/>
            </method>
            <method name="isTemporary" type="boolean" line="2988">
                <params>
                    <param name="to" type="Component"/>
                    <param name="from" type="Component"/>
                </params>
                <declaration name="wto" type="Window" line="2989"/>
                <declaration name="wfrom" type="Window" line="2990"/>
                <scope line="2991"/>
                <scope line="2994"/>
                <scope line="2997"/>
            </method>
            <method name="getHeavyweight" type="Component" line="3003">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="3004"/>
                <scope line="3006"/>
                <scope line="3008"/>
            </method>
            <declaration name="proxyActive" type="Field" line="3013"/>
            <method name="isProxyActiveImpl" type="boolean" line="3015">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <scope line="3016">
                    <anonymous_class line="3017">
                        <method name="run" type="Object" line="3018">
                            <declaration name="field" type="Field" line="3019"/>
                            <scope line="3020">
                                <scope line="3022"/>
                            </scope>
                            <scope line="3025"/>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="3033"/>
                <scope line="3035"/>
            </method>
            <method name="isProxyActive" type="boolean" line="3042">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <scope line="3043"/>
                <scope line="3045"/>
            </method>
            <method name="getLastHWRequest" type="HeavyweightFocusRequest" line="3050">
                <scope line="3051"/>
            </method>
            <method name="getFirstHWRequest" type="HeavyweightFocusRequest" line="3058">
                <scope line="3059"/>
            </method>
        </class>
    </source>