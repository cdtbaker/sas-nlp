<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt.datatransfer">
        <import package="java.awt.Toolkit"/>
        <import package="java.io"/>
        <import package="java.nio"/>
        <import package="java.util"/>
        <import package="sun.awt.datatransfer.DataTransferer"/>
        <class name="DataFlavor" line="35">
            <comment line="144">
                private initializer                
            </comment>
            <comment line="155">
                private initializer                
            </comment>
            <comment line="1327">
                clone()                
            </comment>
            <comment line="1364">
                fields                
            </comment>
            <comment line="1368">
                                
            </comment>
            <comment line="1372">
                                
            </comment>
            <implements interface="Externalizable"/>
            <implements interface="Cloneable"/>
            <javadoc line="35">
                A {@code DataFlavor} provides meta information about data. {@code DataFlavor}is typically used to access data on the clipboard, or during
                  a drag and drop operation.
                  &lt;p&gt;
                  An instance of {@code DataFlavor} encapsulates a content type as
                  defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;
                  and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt;.
                  A content type is typically referred to as a MIME type.
                  &lt;p&gt;
                  A content type consists of a media type (referred
                  to as the primary type), a subtype, and optional parameters. See
                  &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;
                  for details on the syntax of a MIME type.
                  &lt;p&gt;
                  The JRE data transfer implementation interprets the parameter &amp;quot;class&amp;quot;
                  of a MIME type as &lt;B&gt;a representation class&lt;/b&gt;.
                  The representation class reflects the class of the object being
                  transferred. In other words, the representation class is the type of
                  object returned by {@link Transferable#getTransferData}.
                  For example, the MIME type of {@link #imageFlavor} is{@code &quot;image/x-java-image;class=java.awt.Image&quot;},
                  the primary type is {@code image}, the subtype is{@code x-java-image}, and the representation class is{@code java.awt.Image}. When {@code getTransferData} is invoked
                  with a {@code DataFlavor} of {@code imageFlavor}, an instance of{@code java.awt.Image} is returned.
                  It&apos;s important to note that {@code DataFlavor} does no error checking
                  against the representation class. It is up to consumers of{@code DataFlavor}, such as {@code Transferable}, to honor the representation
                  class.
                  &lt;br&gt;
                  Note, if you do not specify a representation class when
                  creating a {@code DataFlavor}, the default
                  representation class is used. See appropriate documentation for{@code DataFlavor}&apos;s constructors.
                  &lt;p&gt;
                  Also, {@code DataFlavor} instances with the &amp;quot;text&amp;quot; primary
                  MIME type may have a &amp;quot;charset&amp;quot; parameter. Refer to
                  &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt; and{@link #selectBestTextFlavor} for details on &amp;quot;text&amp;quot; MIME types
                  and the &amp;quot;charset&amp;quot; parameter.
                  &lt;p&gt;
                  Equality of {@code DataFlavors} is determined by the primary type,
                  subtype, and representation class. Refer to {@link #equals(DataFlavor)} for
                  details. When determining equality, any optional parameters are ignored.
                  For example, the following produces two {@code DataFlavors} that
                  are considered identical:
                  &lt;pre&gt;
                  DataFlavor flavor1 = new DataFlavor(Object.class, &amp;quot;X-test/test; class=&amp;lt;java.lang.Object&amp;gt;; foo=bar&amp;quot;);
                  DataFlavor flavor2 = new DataFlavor(Object.class, &amp;quot;X-test/test; class=&amp;lt;java.lang.Object&amp;gt;; x=y&amp;quot;);
                  // The following returns true.
                  flavor1.equals(flavor2);
                  &lt;/pre&gt;
                  As mentioned, {@code flavor1} and {@code flavor2} are considered identical.
                  As such, asking a {@code Transferable} for either {@code DataFlavor} returns
                  the same results.
                  &lt;p&gt;
                  For more information on the using data transfer with Swing see
                  the &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/dnd.html&quot;&gt;
                  How to Use Drag and Drop and Data Transfer&lt;/a&gt;,
                  section in &lt;em&gt;Java Tutorial&lt;/em&gt;.                
                <author>
                    Blake Sullivan                    
                </author>
                <author>
                    Laurence P. G. Cable                    
                </author>
                <author>
                    Jeff Dunn                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="104"/>
            <declaration name="ioInputStreamClass" type="Class" line="105"/>
            <javadoc line="107">
                Tries to load a class from: the bootstrap loader, the system loader,
                  the context loader (if one is present) and finally the loader specified.                
                <param>
                    className the name of the class to be loaded                    
                </param>
                <param>
                    fallback the fallback loader                    
                </param>
                <return>
                    the class loaded                    
                </return>
                <exception>
                    ClassNotFoundException if class is not found                    
                </exception>
            </javadoc>
            <method name="tryToLoadClass" type="Class<?>" line="119">
                <params>
                    <param name="className" type="String"/>
                    <param name="fallback" type="ClassLoader"/>
                </params>
                <anonymous_class line="122">
                    <method name="run" type="Object" line="123">
                        <declaration name="cl" type="ClassLoader" line="124"/>
                    </method>
                </anonymous_class>
                <declaration name="systemClassLoader" type="ClassLoader" line="120"/>
                <scope line="132"/>
                <scope line="134">
                    <scope line="135"/>
                    <scope line="137"/>
                </scope>
            </method>
            <method name="createConstant" type="DataFlavor" line="146">
                <params>
                    <param name="rc" type="Class"/>
                    <param name="prn" type="String"/>
                </params>
                <scope line="147"/>
                <scope line="149"/>
            </method>
            <method name="createConstant" type="DataFlavor" line="157">
                <params>
                    <param name="mt" type="String"/>
                    <param name="prn" type="String"/>
                </params>
                <scope line="158"/>
                <scope line="160"/>
            </method>
            <declaration name="stringFlavor" type="DataFlavor" line="165"/>
            <javadoc line="165">
                The &lt;code&gt;DataFlavor&lt;/code&gt; representing a Java Unicode String class,
                  where:
                  &lt;pre&gt;
                  representationClass = java.lang.String
                  mimeType           = &quot;application/x-java-serialized-object&quot;
                  &lt;/pre&gt;                
            </javadoc>
            <declaration name="imageFlavor" type="DataFlavor" line="175"/>
            <javadoc line="175">
                The &lt;code&gt;DataFlavor&lt;/code&gt; representing a Java Image class,
                  where:
                  &lt;pre&gt;
                  representationClass = java.awt.Image
                  mimeType            = &quot;image/x-java-image&quot;
                  &lt;/pre&gt;                
            </javadoc>
            <declaration name="plainTextFlavor" type="DataFlavor" line="185"/>
            <javadoc line="185">
                The &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text with Unicode
                  encoding, where:
                  &lt;pre&gt;
                  representationClass = InputStream
                  mimeType            = &quot;text/plain; charset=unicode&quot;
                  &lt;/pre&gt;
                  This &lt;code&gt;DataFlavor&lt;/code&gt; has been &lt;b&gt;deprecated&lt;/b&gt; because
                  (1) Its representation is an InputStream, an 8-bit based representation,
                  while Unicode is a 16-bit character set; and (2) The charset &quot;unicode&quot;
                  is not well-defined. &quot;unicode&quot; implies a particular platform&apos;s
                  implementation of Unicode, not a cross-platform implementation.                
                <deprecated>
                    as of 1.3. Use <code>DataFlavor.getReaderForText(Transferable)</code>
                      instead of <code>Transferable.getTransferData(DataFlavor.plainTextFlavor)</code>.                    
                </deprecated>
            </javadoc>
            <declaration name="javaSerializedObjectMimeType" type="String" line="204"/>
            <javadoc line="204">
                A MIME Content-Type of application/x-java-serialized-object represents
                  a graph of Java object(s) that have been made persistent.
                  The representation class associated with this &lt;code&gt;DataFlavor&lt;/code&gt;
                  identifies the Java type of an object returned as a reference
                  from an invocation &lt;code&gt;java.awt.datatransfer.getTransferData&lt;/code&gt;.                
            </javadoc>
            <declaration name="javaFileListFlavor" type="DataFlavor" line="214"/>
            <javadoc line="214">
                To transfer a list of files to/from Java (and the underlying
                  platform) a &lt;code&gt;DataFlavor&lt;/code&gt; of this type/subtype and
                  representation class of &lt;code&gt;java.util.List&lt;/code&gt; is used.
                  Each element of the list is required/guaranteed to be of type
                  &lt;code&gt;java.io.File&lt;/code&gt;.                
            </javadoc>
            <declaration name="javaJVMLocalObjectMimeType" type="String" line="223"/>
            <javadoc line="223">
                To transfer a reference to an arbitrary Java object reference that
                  has no associated MIME Content-type, across a &lt;code&gt;Transferable&lt;/code&gt;
                  interface WITHIN THE SAME JVM, a &lt;code&gt;DataFlavor&lt;/code&gt;
                  with this type/subtype is used, with a &lt;code&gt;representationClass&lt;/code&gt;
                  equal to the type of the class/interface being passed across the
                  &lt;code&gt;Transferable&lt;/code&gt;.
                  &lt;p&gt;
                  The object reference returned from
                  &lt;code&gt;Transferable.getTransferData&lt;/code&gt; for a &lt;code&gt;DataFlavor&lt;/code&gt;
                  with this MIME Content-Type is required to be
                  an instance of the representation Class of the &lt;code&gt;DataFlavor&lt;/code&gt;.                
            </javadoc>
            <declaration name="javaRemoteObjectMimeType" type="String" line="238"/>
            <javadoc line="238">
                In order to pass a live link to a Remote object via a Drag and Drop
                  &lt;code&gt;ACTION_LINK&lt;/code&gt; operation a Mime Content Type of
                  application/x-java-remote-object should be used,
                  where the representation class of the &lt;code&gt;DataFlavor&lt;/code&gt;
                  represents the type of the &lt;code&gt;Remote&lt;/code&gt; interface to be
                  transferred.                
            </javadoc>
            <javadoc line="248">
                Constructs a new &lt;code&gt;DataFlavor&lt;/code&gt;.  This constructor is
                  provided only for the purpose of supporting the
                  &lt;code&gt;Externalizable&lt;/code&gt; interface.  It is not
                  intended for public (client) use.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="DataFlavor" type="constructor" line="256"/>
            <javadoc line="260">
                Constructs a fully specified &lt;code&gt;DataFlavor&lt;/code&gt;.                
                <exception>
                    NullPointerException if either <code>primaryType</code>,
                      <code>subType</code> or <code>representationClass</code> is null                    
                </exception>
            </javadoc>
            <method name="DataFlavor" type="constructor" line="266">
                <params>
                    <param name="primaryType" type="String"/>
                    <param name="subType" type="String"/>
                    <param name="params" type="MimeTypeParameterList"/>
                    <param name="representationClass" type="Class"/>
                    <param name="humanPresentableName" type="String"/>
                </params>
                <scope line="268"/>
                <scope line="271"/>
                <scope line="274"/>
                <scope line="282"/>
                <scope line="289"/>
                <scope line="291"/>
            </method>
            <javadoc line="301">
                Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; that represents a Java class.
                  &lt;p&gt;
                  The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following
                  characteristics:
                  &lt;pre&gt;
                  representationClass = representationClass
                  mimeType            = application/x-java-serialized-object
                  &lt;/pre&gt;                
                <param>
                    representationClass the class used to transfer data in this flavor                    
                </param>
                <param>
                    humanPresentableName the human-readable string used to identify
                      this flavor; if this parameter is <code>null</code>
                      then the value of the the MIME Content Type is used                    
                </param>
                <exception>
                    NullPointerException if <code>representationClass</code> is null                    
                </exception>
            </javadoc>
            <method name="DataFlavor" type="constructor" line="316">
                <params>
                    <param name="representationClass" type="Class<?>"/>
                    <param name="humanPresentableName" type="String"/>
                </params>
                <scope line="318"/>
            </method>
            <javadoc line="323">
                Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; that represents a
                  &lt;code&gt;MimeType&lt;/code&gt;.
                  &lt;p&gt;
                  The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following
                  characteristics:
                  &lt;p&gt;
                  If the &lt;code&gt;mimeType&lt;/code&gt; is
                  &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;,
                  the result is the same as calling
                  &lt;code&gt;new DataFlavor(Class:forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.
                  &lt;p&gt;
                  Otherwise:
                  &lt;pre&gt;
                  representationClass = InputStream
                  mimeType            = mimeType
                  &lt;/pre&gt;                
                <param>
                    mimeType the string used to identify the MIME type for this flavor;
                      if the the <code>mimeType</code> does not specify a
                      "class=" parameter, or if the class is not successfully
                      loaded, then an <code>IllegalArgumentException</code>
                      is thrown                    
                </param>
                <param>
                    humanPresentableName the human-readable string used to identify
                      this flavor; if this parameter is <code>null</code>
                      then the value of the the MIME Content Type is used                    
                </param>
                <exception>
                    IllegalArgumentException if <code>mimeType</code> is
                      invalid or if the class is not successfully loaded                    
                </exception>
                <exception>
                    NullPointerException if <code>mimeType</code> is null                    
                </exception>
            </javadoc>
            <method name="DataFlavor" type="constructor" line="352">
                <params>
                    <param name="mimeType" type="String"/>
                    <param name="humanPresentableName" type="String"/>
                </params>
                <scope line="354"/>
                <scope line="357"/>
                <scope line="359"/>
                <scope line="361"/>
            </method>
            <javadoc line="366">
                Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; that represents a
                  &lt;code&gt;MimeType&lt;/code&gt;.
                  &lt;p&gt;
                  The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following
                  characteristics:
                  &lt;p&gt;
                  If the mimeType is
                  &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;,
                  the result is the same as calling
                  &lt;code&gt;new DataFlavor(Class:forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.
                  &lt;p&gt;
                  Otherwise:
                  &lt;pre&gt;
                  representationClass = InputStream
                  mimeType            = mimeType
                  &lt;/pre&gt;                
                <param>
                    mimeType the string used to identify the MIME type for this flavor                    
                </param>
                <param>
                    humanPresentableName the human-readable string used to
                      identify this flavor                    
                </param>
                <param>
                    classLoader the class loader to use                    
                </param>
                <exception>
                    ClassNotFoundException if the class is not loaded                    
                </exception>
                <exception>
                    IllegalArgumentException if <code>mimeType</code> is
                      invalid                    
                </exception>
                <exception>
                    NullPointerException if <code>mimeType</code> is null                    
                </exception>
            </javadoc>
            <method name="DataFlavor" type="constructor" line="392">
                <params>
                    <param name="mimeType" type="String"/>
                    <param name="humanPresentableName" type="String"/>
                    <param name="classLoader" type="ClassLoader"/>
                </params>
                <scope line="394"/>
                <scope line="397"/>
                <scope line="399"/>
            </method>
            <javadoc line="404">
                Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; from a &lt;code&gt;mimeType&lt;/code&gt; string.
                  The string can specify a &quot;class=&lt;fully specified Java class name&gt;&quot;
                  parameter to create a &lt;code&gt;DataFlavor&lt;/code&gt; with the desired
                  representation class. If the string does not contain &quot;class=&quot; parameter,
                  &lt;code&gt;java.io.InputStream&lt;/code&gt; is used as default.                
                <param>
                    mimeType the string used to identify the MIME type for this flavor;
                      if the class specified by "class=" parameter is not
                      successfully loaded, then an
                      <code>ClassNotFoundException</code> is thrown                    
                </param>
                <exception>
                    ClassNotFoundException if the class is not loaded                    
                </exception>
                <exception>
                    IllegalArgumentException if <code>mimeType</code> is
                      invalid                    
                </exception>
                <exception>
                    NullPointerException if <code>mimeType</code> is null                    
                </exception>
            </javadoc>
            <method name="DataFlavor" type="constructor" line="420">
                <params>
                    <param name="mimeType" type="String"/>
                </params>
                <scope line="422"/>
                <scope line="425"/>
                <scope line="427"/>
            </method>
            <javadoc line="432">
                Common initialization code called from various constructors.                
                <param>
                    mimeType the MIME Content Type (must have a class= param)                    
                </param>
                <param>
                    humanPresentableName the human Presentable Name or
                      <code>null</code>                    
                </param>
                <param>
                    classLoader the fallback class loader to resolve against                    
                </param>
                <throws>
                    MimeTypeParseException                    
                </throws>
                <throws>
                    ClassNotFoundException                    
                </throws>
                <throws>
                    NullPointerException if <code>mimeType</code> is null                    
                </throws>
                <see>
                    tryToLoadClass                    
                </see>
            </javadoc>
            <method name="initialize" type="void" line="446">
                <params>
                    <param name="mimeType" type="String"/>
                    <param name="humanPresentableName" type="String"/>
                    <param name="classLoader" type="ClassLoader"/>
                </params>
                <comment line="451">
                    throws                    
                </comment>
                <comment line="460">
                    default                    
                </comment>
                <comment line="461">
                    got a class name                    
                </comment>
                <comment line="473">
                    set it.                    
                </comment>
                <comment line="475">
                    just in case                    
                </comment>
                <scope line="447"/>
                <declaration name="rcn" type="String" line="453"/>
                <scope line="455"/>
                <scope line="461"/>
                <scope line="467"/>
            </method>
            <javadoc line="478">
                String representation of this &lt;code&gt;DataFlavor&lt;/code&gt; and its
                  parameters. The resulting &lt;code&gt;String&lt;/code&gt; contains the name of
                  the &lt;code&gt;DataFlavor&lt;/code&gt; class, this flavor&apos;s MIME type, and its
                  representation class. If this flavor has a primary MIME type of &quot;text&quot;,
                  supports the charset parameter, and has an encoded representation, the
                  flavor&apos;s charset is also included. See &lt;code&gt;selectBestTextFlavor&lt;/code&gt;
                  for a list of text flavors which support the charset parameter.                
                <return>
                    string representation of this <code>DataFlavor</code>                    
                </return>
                <see>
                    #selectBestTextFlavor                    
                </see>
            </javadoc>
            <method name="toString" type="String" line="490">
                <declaration name="string" type="String" line="491"/>
            </method>
            <method name="paramString" type="String" line="496">
                <declaration name="params" type="String" line="497"/>
                <scope line="499"/>
                <scope line="501"/>
                <scope line="505"/>
                <scope line="507"/>
                <scope line="514"/>
            </method>
            <javadoc line="520">
                Returns a &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text with Unicode
                  encoding, where:
                  &lt;pre&gt;
                  representationClass = java.io.InputStream
                  mimeType            = &quot;text/plain;
                  charset=&amp;lt;platform default Unicode encoding&amp;gt;&quot;
                  &lt;/pre&gt;
                  Sun&apos;s implementation for Microsoft Windows uses the encoding &lt;code&gt;utf-16le&lt;/code&gt;.
                  Sun&apos;s implementation for Solaris and Linux uses the encoding
                  &lt;code&gt;iso-10646-ucs-2&lt;/code&gt;.                
                <return>
                    a <code>DataFlavor</code> representing plain text
                      with Unicode encoding                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getTextPlainUnicodeFlavor" type="DataFlavor" line="536">
                <declaration name="encoding" type="String" line="537"/>
                <declaration name="transferer" type="DataTransferer" line="538"/>
                <scope line="539"/>
            </method>
            <javadoc line="547">
                Selects the best text &lt;code&gt;DataFlavor&lt;/code&gt; from an array of &lt;code&gt;
                  DataFlavor&lt;/code&gt;s. Only &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt;, and
                  equivalent flavors, and flavors that have a primary MIME type of &quot;text&quot;,
                  are considered for selection.
                  &lt;p&gt;
                  Flavors are first sorted by their MIME types in the following order:
                  &lt;ul&gt;
                  &lt;li&gt;&quot;text/sgml&quot;
                  &lt;li&gt;&quot;text/xml&quot;
                  &lt;li&gt;&quot;text/html&quot;
                  &lt;li&gt;&quot;text/rtf&quot;
                  &lt;li&gt;&quot;text/enriched&quot;
                  &lt;li&gt;&quot;text/richtext&quot;
                  &lt;li&gt;&quot;text/uri-list&quot;
                  &lt;li&gt;&quot;text/tab-separated-values&quot;
                  &lt;li&gt;&quot;text/t140&quot;
                  &lt;li&gt;&quot;text/rfc822-headers&quot;
                  &lt;li&gt;&quot;text/parityfec&quot;
                  &lt;li&gt;&quot;text/directory&quot;
                  &lt;li&gt;&quot;text/css&quot;
                  &lt;li&gt;&quot;text/calendar&quot;
                  &lt;li&gt;&quot;application/x-java-serialized-object&quot;
                  &lt;li&gt;&quot;text/plain&quot;
                  &lt;li&gt;&quot;text/&amp;lt;other&amp;gt;&quot;
                  &lt;/ul&gt;
                  &lt;p&gt;For example, &quot;text/sgml&quot; will be selected over
                  &quot;text/html&quot;, and &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt; will be chosen
                  over &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt;.
                  &lt;p&gt;
                  If two or more flavors share the best MIME type in the array, then that
                  MIME type will be checked to see if it supports the charset parameter.
                  &lt;p&gt;
                  The following MIME types support, or are treated as though they support,
                  the charset parameter:
                  &lt;ul&gt;
                  &lt;li&gt;&quot;text/sgml&quot;
                  &lt;li&gt;&quot;text/xml&quot;
                  &lt;li&gt;&quot;text/html&quot;
                  &lt;li&gt;&quot;text/enriched&quot;
                  &lt;li&gt;&quot;text/richtext&quot;
                  &lt;li&gt;&quot;text/uri-list&quot;
                  &lt;li&gt;&quot;text/directory&quot;
                  &lt;li&gt;&quot;text/css&quot;
                  &lt;li&gt;&quot;text/calendar&quot;
                  &lt;li&gt;&quot;application/x-java-serialized-object&quot;
                  &lt;li&gt;&quot;text/plain&quot;
                  &lt;/ul&gt;
                  The following MIME types do not support, or are treated as though they
                  do not support, the charset parameter:
                  &lt;ul&gt;
                  &lt;li&gt;&quot;text/rtf&quot;
                  &lt;li&gt;&quot;text/tab-separated-values&quot;
                  &lt;li&gt;&quot;text/t140&quot;
                  &lt;li&gt;&quot;text/rfc822-headers&quot;
                  &lt;li&gt;&quot;text/parityfec&quot;
                  &lt;/ul&gt;
                  For &quot;text/&amp;lt;other&amp;gt;&quot; MIME types, the first time the JRE needs to
                  determine whether the MIME type supports the charset parameter, it will
                  check whether the parameter is explicitly listed in an arbitrarily
                  chosen &lt;code&gt;DataFlavor&lt;/code&gt; which uses that MIME type. If so, the JRE
                  will assume from that point on that the MIME type supports the charset
                  parameter and will not check again. If the parameter is not explicitly
                  listed, the JRE will assume from that point on that the MIME type does
                  not support the charset parameter and will not check again. Because
                  this check is performed on an arbitrarily chosen
                  &lt;code&gt;DataFlavor&lt;/code&gt;, developers must ensure that all
                  &lt;code&gt;DataFlavor&lt;/code&gt;s with a &quot;text/&amp;lt;other&amp;gt;&quot; MIME type specify
                  the charset parameter if it is supported by that MIME type. Developers
                  should never rely on the JRE to substitute the platform&apos;s default
                  charset for a &quot;text/&amp;lt;other&amp;gt;&quot; DataFlavor. Failure to adhere to this
                  restriction will lead to undefined behavior.
                  &lt;p&gt;
                  If the best MIME type in the array does not support the charset
                  parameter, the flavors which share that MIME type will then be sorted by
                  their representation classes in the following order:
                  &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;,
                  &lt;code&gt;[B&lt;/code&gt;, &amp;lt;all others&amp;gt;.
                  &lt;p&gt;
                  If two or more flavors share the best representation class, or if no
                  flavor has one of the three specified representations, then one of those
                  flavors will be chosen non-deterministically.
                  &lt;p&gt;
                  If the best MIME type in the array does support the charset parameter,
                  the flavors which share that MIME type will then be sorted by their
                  representation classes in the following order:
                  &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;,
                  &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;, &amp;lt;all others&amp;gt;.
                  &lt;p&gt;
                  If two or more flavors share the best representation class, and that
                  representation is one of the four explicitly listed, then one of those
                  flavors will be chosen non-deterministically. If, however, no flavor has
                  one of the four specified representations, the flavors will then be
                  sorted by their charsets. Unicode charsets, such as &quot;UTF-16&quot;, &quot;UTF-8&quot;,
                  &quot;UTF-16BE&quot;, &quot;UTF-16LE&quot;, and their aliases, are considered best. After
                  them, the platform default charset and its aliases are selected.
                  &quot;US-ASCII&quot; and its aliases are worst. All other charsets are chosen in
                  alphabetical order, but only charsets supported by this implementation
                  of the Java platform will be considered.
                  &lt;p&gt;
                  If two or more flavors share the best charset, the flavors will then
                  again be sorted by their representation classes in the following order:
                  &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;,
                  &lt;code&gt;[B&lt;/code&gt;, &amp;lt;all others&amp;gt;.
                  &lt;p&gt;
                  If two or more flavors share the best representation class, or if no
                  flavor has one of the three specified representations, then one of those
                  flavors will be chosen non-deterministically.                
                <param>
                    availableFlavors an array of available <code>DataFlavor</code>s                    
                </param>
                <return>
                    the best (highest fidelity) flavor according to the rules
                      specified above, or <code>null</code>,
                      if <code>availableFlavors</code> is <code>null</code>,
                      has zero length, or contains no text flavors                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="selectBestTextFlavor" type="DataFlavor" line="664">
                <params>
                    <param name="availableFlavors" type="DataFlavor[]"/>
                </params>
                <scope line="665"/>
                <scope line="669"/>
                <declaration name="bestFlavor" type="DataFlavor" line="673"/>
                <scope line="677"/>
            </method>
            <declaration name="textFlavorComparator" type="Comparator" line="684"/>
            <class name="TextFlavorComparator" line="686">
                <extends class="DataTransferer.DataFlavorComparator"/>
                <javadoc line="689">
                    Compares two &lt;code&gt;DataFlavor&lt;/code&gt; objects. Returns a negative
                      integer, zero, or a positive integer as the first
                      &lt;code&gt;DataFlavor&lt;/code&gt; is worse than, equal to, or better than the
                      second.
                      &lt;p&gt;
                      &lt;code&gt;DataFlavor&lt;/code&gt;s are ordered according to the rules outlined
                      for &lt;code&gt;selectBestTextFlavor&lt;/code&gt;.                    
                    <param>
                        obj1 the first <code>DataFlavor</code> to be compared                        
                    </param>
                    <param>
                        obj2 the second <code>DataFlavor</code> to be compared                        
                    </param>
                    <return>
                        a negative integer, zero, or a positive integer as the first
                          argument is worse, equal to, or better than the second                        
                    </return>
                    <throws>
                        ClassCastException if either of the arguments is not an
                          instance of <code>DataFlavor</code>                        
                    </throws>
                    <throws>
                        NullPointerException if either of the arguments is
                          <code>null</code>                        
                    </throws>
                    <see>
                        #selectBestTextFlavor                        
                    </see>
                </javadoc>
                <method name="compare" type="int" line="709">
                    <params>
                        <param name="obj1" type="Object"/>
                        <param name="obj2" type="Object"/>
                    </params>
                    <declaration name="flavor1" type="DataFlavor" line="710"/>
                    <declaration name="flavor2" type="DataFlavor" line="711"/>
                    <scope line="713">
                        <scope line="714"/>
                        <scope line="716"/>
                    </scope>
                    <scope line="719"/>
                    <scope line="721"/>
                </method>
            </class>
            <javadoc line="727">
                Gets a Reader for a text flavor, decoded, if necessary, for the expected
                  charset (encoding). The supported representation classes are
                  &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;,
                  &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;,
                  &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;,
                  and &lt;code&gt;[B&lt;/code&gt;.
                  &lt;p&gt;
                  Because text flavors which do not support the charset parameter are
                  encoded in a non-standard format, this method should not be called for
                  such flavors. However, in order to maintain backward-compatibility,
                  if this method is called for such a flavor, this method will treat the
                  flavor as though it supports the charset parameter and attempt to
                  decode it accordingly. See &lt;code&gt;selectBestTextFlavor&lt;/code&gt; for a list
                  of text flavors which do not support the charset parameter.                
                <param>
                    transferable the <code>Transferable</code> whose data will be
                      requested in this flavor                    
                </param>
                <return>
                    a <code>Reader</code> to read the <code>Transferable</code>'s
                      data                    
                </return>
                <exception>
                    IllegalArgumentException if the representation class
                      is not one of the seven listed above                    
                </exception>
                <exception>
                    IllegalArgumentException if the <code>Transferable</code>
                      has <code>null</code> data                    
                </exception>
                <exception>
                    NullPointerException if the <code>Transferable</code> is
                      <code>null</code>                    
                </exception>
                <exception>
                    UnsupportedEncodingException if this flavor's representation
                      is <code>java.io.InputStream</code>,
                      <code>java.nio.ByteBuffer</code>, or <code>[B</code> and
                      this flavor's encoding is not supported by this
                      implementation of the Java platform                    
                </exception>
                <exception>
                    UnsupportedFlavorException if the <code>Transferable</code>
                      does not support this flavor                    
                </exception>
                <exception>
                    IOException if the data cannot be read because of an
                      I/O error                    
                </exception>
                <see>
                    #selectBestTextFlavor                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getReaderForText" type="Reader" line="769">
                <params>
                    <param name="transferable" type="Transferable"/>
                </params>
                <declaration name="transferObject" type="Object" line="770"/>
                <scope line="771"/>
                <scope line="776"/>
                <scope line="778"/>
                <scope line="780">
                    <declaration name="buffer" type="CharBuffer" line="781"/>
                    <declaration name="size" type="int" line="782"/>
                    <declaration name="chars" type="char[]" line="783"/>
                </scope>
                <scope line="786"/>
                <declaration name="stream" type="InputStream" line="790"/>
                <scope line="792"/>
                <scope line="794">
                    <declaration name="buffer" type="ByteBuffer" line="795"/>
                    <declaration name="size" type="int" line="796"/>
                    <declaration name="bytes" type="byte[]" line="797"/>
                </scope>
                <scope line="800"/>
                <scope line="804"/>
                <declaration name="encoding" type="String" line="808"/>
            </method>
            <javadoc line="814">
                Returns the MIME type string for this &lt;code&gt;DataFlavor&lt;/code&gt;.                
                <return>
                    the MIME type string for this flavor                    
                </return>
            </javadoc>
            <method name="getMimeType" type="String" line="818"/>
            <javadoc line="822">
                Returns the &lt;code&gt;Class&lt;/code&gt; which objects supporting this
                  &lt;code&gt;DataFlavor&lt;/code&gt; will return when this &lt;code&gt;DataFlavor&lt;/code&gt;
                  is requested.                
                <return>
                    the <code>Class</code> which objects supporting this
                      <code>DataFlavor</code> will return when this <code>DataFlavor</code>
                      is requested                    
                </return>
            </javadoc>
            <method name="getRepresentationClass" type="Class<?>" line="830"/>
            <javadoc line="834">
                Returns the human presentable name for the data format that this
                  &lt;code&gt;DataFlavor&lt;/code&gt; represents.  This name would be localized
                  for different countries.                
                <return>
                    the human presentable name for the data format that this
                      <code>DataFlavor</code> represents                    
                </return>
            </javadoc>
            <method name="getHumanPresentableName" type="String" line="841"/>
            <javadoc line="845">
                Returns the primary MIME type for this &lt;code&gt;DataFlavor&lt;/code&gt;.                
                <return>
                    the primary MIME type of this <code>DataFlavor</code>                    
                </return>
            </javadoc>
            <method name="getPrimaryType" type="String" line="849"/>
            <javadoc line="853">
                Returns the sub MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;.                
                <return>
                    the Sub MIME type of this <code>DataFlavor</code>                    
                </return>
            </javadoc>
            <method name="getSubType" type="String" line="857"/>
            <javadoc line="861">
                Returns the human presentable name for this &lt;code&gt;DataFlavor&lt;/code&gt;
                  if &lt;code&gt;paramName&lt;/code&gt; equals &quot;humanPresentableName&quot;.  Otherwise
                  returns the MIME type value associated with &lt;code&gt;paramName&lt;/code&gt;.                
                <param>
                    paramName the parameter name requested                    
                </param>
                <return>
                    the value of the name parameter, or <code>null</code>
                      if there is no associated value                    
                </return>
            </javadoc>
            <method name="getParameter" type="String" line="870">
                <params>
                    <param name="paramName" type="String"/>
                </params>
                <scope line="871"/>
                <scope line="873"/>
            </method>
            <javadoc line="879">
                Sets the human presentable name for the data format that this
                  &lt;code&gt;DataFlavor&lt;/code&gt; represents. This name would be localized
                  for different countries.                
                <param>
                    humanPresentableName the new human presentable name                    
                </param>
            </javadoc>
            <method name="setHumanPresentableName" type="void" line="885">
                <params>
                    <param name="humanPresentableName" type="String"/>
                </params>
            </method>
            <javadoc line="889">
                {@inheritDoc}&lt;p&gt;
                  The equals comparison for the {@code DataFlavor} class is implemented
                  as follows: Two &lt;code&gt;DataFlavor&lt;/code&gt;s are considered equal if and
                  only if their MIME primary type and subtype and representation class are
                  equal. Additionally, if the primary type is &quot;text&quot;, the subtype denotes
                  a text flavor which supports the charset parameter, and the
                  representation class is not &lt;code&gt;java.io.Reader&lt;/code&gt;,
                  &lt;code&gt;java.lang.String&lt;/code&gt;, &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, or
                  &lt;code&gt;[C&lt;/code&gt;, the &lt;code&gt;charset&lt;/code&gt; parameter must also be equal.
                  If a charset is not explicitly specified for one or both
                  &lt;code&gt;DataFlavor&lt;/code&gt;s, the platform default encoding is assumed. See
                  &lt;code&gt;selectBestTextFlavor&lt;/code&gt; for a list of text flavors which
                  support the charset parameter.                
                <param>
                    o the <code>Object</code> to compare with <code>this</code>                    
                </param>
                <return>
                    <code>true</code> if <code>that</code> is equivalent to this
                      <code>DataFlavor</code>; <code>false</code> otherwise                    
                </return>
                <see>
                    #selectBestTextFlavor                    
                </see>
            </javadoc>
            <method name="equals" type="boolean" line="910">
                <params>
                    <param name="o" type="Object"/>
                </params>
            </method>
            <javadoc line="914">
                This method has the same behavior as {@link #equals(Object)}.
                  The only difference being that it takes a {@code DataFlavor} instance
                  as a parameter.                
                <param>
                    that the <code>DataFlavor</code> to compare with
                      <code>this</code>                    
                </param>
                <return>
                    <code>true</code> if <code>that</code> is equivalent to this
                      <code>DataFlavor</code>; <code>false</code> otherwise                    
                </return>
                <see>
                    #selectBestTextFlavor                    
                </see>
            </javadoc>
            <method name="equals" type="boolean" line="925">
                <params>
                    <param name="that" type="DataFlavor"/>
                </params>
                <scope line="926"/>
                <scope line="929"/>
                <scope line="933">
                    <scope line="934"/>
                </scope>
                <scope line="937">
                    <scope line="938"/>
                </scope>
                <scope line="943">
                    <scope line="944"/>
                </scope>
                <scope line="947">
                    <scope line="948"/>
                    <scope line="959">
                        <declaration name="thisCharset" type="String" line="960"/>
                        <declaration name="thatCharset" type="String" line="962"/>
                        <scope line="964">
                            <scope line="965"/>
                        </scope>
                        <scope line="968">
                            <scope line="969"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="979">
                Compares only the &lt;code&gt;mimeType&lt;/code&gt; against the passed in
                  &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;representationClass&lt;/code&gt; is
                  not considered in the comparison.
                  If &lt;code&gt;representationClass&lt;/code&gt; needs to be compared, then
                  &lt;code&gt;equals(new DataFlavor(s))&lt;/code&gt; may be used.                
                <deprecated>
                    As inconsistent with <code>hashCode()</code> contract,
                      use <code>isMimeTypeEqual(String)</code> instead.                    
                </deprecated>
                <param>
                    s the {@code mimeType} to compare.                    
                </param>
                <return>
                    true if the String (MimeType) is equal; false otherwise or if{@code s} is {@code null}                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="993">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="999">
                Returns hash code for this &lt;code&gt;DataFlavor&lt;/code&gt;.
                  For two equal &lt;code&gt;DataFlavor&lt;/code&gt;s, hash codes are equal.
                  For the &lt;code&gt;String&lt;/code&gt;
                  that matches &lt;code&gt;DataFlavor.equals(String)&lt;/code&gt;, it is not
                  guaranteed that &lt;code&gt;DataFlavor&lt;/code&gt;&apos;s hash code is equal
                  to the hash code of the &lt;code&gt;String&lt;/code&gt;.                
                <return>
                    a hash code for this <code>DataFlavor</code>                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="1009">
                <comment line="1022">
                    Do not add subType.hashCode() to the total. equals uses                    
                </comment>
                <comment line="1023">
                    MimeType.match which reports a match if one or both of the                    
                </comment>
                <comment line="1024">
                    subTypes is &apos;*&apos;, regardless of the other subType.                    
                </comment>
                <declaration name="total" type="int" line="1010"/>
                <scope line="1012"/>
                <scope line="1016">
                    <declaration name="primaryType" type="String" line="1017"/>
                    <scope line="1018"/>
                    <scope line="1034">
                        <declaration name="charset" type="String" line="1035"/>
                        <scope line="1037"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1046">
                Identical to {@link #equals(DataFlavor)}.                
                <param>
                    that the <code>DataFlavor</code> to compare with
                      <code>this</code>                    
                </param>
                <return>
                    <code>true</code> if <code>that</code> is equivalent to this
                      <code>DataFlavor</code>; <code>false</code> otherwise                    
                </return>
                <see>
                    #selectBestTextFlavor                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="match" type="boolean" line="1056">
                <params>
                    <param name="that" type="DataFlavor"/>
                </params>
            </method>
            <javadoc line="1060">
                Returns whether the string representation of the MIME type passed in
                  is equivalent to the MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;.
                  Parameters are not included in the comparison.                
                <param>
                    mimeType the string representation of the MIME type                    
                </param>
                <return>
                    true if the string representation of the MIME type passed in is
                      equivalent to the MIME type of this <code>DataFlavor</code>;
                      false otherwise                    
                </return>
                <throws>
                    NullPointerException if mimeType is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="isMimeTypeEqual" type="boolean" line="1071">
                <params>
                    <param name="mimeType" type="String"/>
                </params>
                <comment line="1072">
                    JCK Test DataFlavor0117: if &apos;mimeType&apos; is null, throw NPE                    
                </comment>
                <scope line="1073"/>
                <scope line="1076"/>
                <scope line="1079"/>
                <scope line="1081"/>
            </method>
            <javadoc line="1086">
                Compares the &lt;code&gt;mimeType&lt;/code&gt; of two &lt;code&gt;DataFlavor&lt;/code&gt;
                  objects. No parameters are considered.                
                <param>
                    dataFlavor the <code>DataFlavor</code> to be compared                    
                </param>
                <return>
                    true if the <code>MimeType</code>s are equal,
                      otherwise false                    
                </return>
            </javadoc>
            <method name="isMimeTypeEqual" type="boolean" line="1095">
                <params>
                    <param name="dataFlavor" type="DataFlavor"/>
                </params>
            </method>
            <javadoc line="1099">
                Compares the &lt;code&gt;mimeType&lt;/code&gt; of two &lt;code&gt;DataFlavor&lt;/code&gt;
                  objects.  No parameters are considered.                
                <return>
                    true if the <code>MimeType</code>s are equal,
                      otherwise false                    
                </return>
            </javadoc>
            <method name="isMimeTypeEqual" type="boolean" line="1107">
                <params>
                    <param name="mtype" type="MimeType"/>
                </params>
                <scope line="1108"/>
            </method>
            <javadoc line="1114">
                Does the &lt;code&gt;DataFlavor&lt;/code&gt; represent a serialized object?                
            </javadoc>
            <method name="isMimeTypeSerializedObject" type="boolean" line="1118"/>
            <method name="getDefaultRepresentationClass" type="Class<?>" line="1122"/>
            <method name="getDefaultRepresentationClassAsString" type="String" line="1126"/>
            <javadoc line="1130">
                Does the &lt;code&gt;DataFlavor&lt;/code&gt; represent a
                  &lt;code&gt;java.io.InputStream&lt;/code&gt;?                
            </javadoc>
            <method name="isRepresentationClassInputStream" type="boolean" line="1135"/>
            <javadoc line="1139">
                Returns whether the representation class for this
                  &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;java.io.Reader&lt;/code&gt; or a subclass
                  thereof.                
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isRepresentationClassReader" type="boolean" line="1146"/>
            <javadoc line="1150">
                Returns whether the representation class for this
                  &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;java.nio.CharBuffer&lt;/code&gt; or a
                  subclass thereof.                
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isRepresentationClassCharBuffer" type="boolean" line="1157"/>
            <javadoc line="1161">
                Returns whether the representation class for this
                  &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt; or a
                  subclass thereof.                
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isRepresentationClassByteBuffer" type="boolean" line="1168"/>
            <javadoc line="1172">
                Returns true if the representation class can be serialized.                
                <return>
                    true if the representation class can be serialized                    
                </return>
            </javadoc>
            <method name="isRepresentationClassSerializable" type="boolean" line="1177"/>
            <javadoc line="1181">
                Returns true if the representation class is &lt;code&gt;Remote&lt;/code&gt;.                
                <return>
                    true if the representation class is <code>Remote</code>                    
                </return>
            </javadoc>
            <method name="isRepresentationClassRemote" type="boolean" line="1186"/>
            <javadoc line="1190">
                Returns true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
                  a serialized object.                
                <return>
                    true if the <code>DataFlavor</code> specified represents
                      a Serialized Object                    
                </return>
            </javadoc>
            <method name="isFlavorSerializedObjectType" type="boolean" line="1197"/>
            <javadoc line="1201">
                Returns true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
                  a remote object.                
                <return>
                    true if the <code>DataFlavor</code> specified represents
                      a Remote Object                    
                </return>
            </javadoc>
            <method name="isFlavorRemoteObjectType" type="boolean" line="1208"/>
            <javadoc line="1215">
                Returns true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
                  a list of file objects.                
                <return>
                    true if the <code>DataFlavor</code> specified represents
                      a List of File objects                    
                </return>
            </javadoc>
            <method name="isFlavorJavaFileListType" type="boolean" line="1222"/>
            <javadoc line="1230">
                Returns whether this &lt;code&gt;DataFlavor&lt;/code&gt; is a valid text flavor for
                  this implementation of the Java platform. Only flavors equivalent to
                  &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt; and &lt;code&gt;DataFlavor&lt;/code&gt;s with
                  a primary MIME type of &quot;text&quot; can be valid text flavors.
                  &lt;p&gt;
                  If this flavor supports the charset parameter, it must be equivalent to
                  &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt;, or its representation must be
                  &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;,
                  &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;,
                  &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or
                  &lt;code&gt;[B&lt;/code&gt;. If the representation is
                  &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or
                  &lt;code&gt;[B&lt;/code&gt;, then this flavor&apos;s &lt;code&gt;charset&lt;/code&gt; parameter must
                  be supported by this implementation of the Java platform. If a charset
                  is not specified, then the platform default charset, which is always
                  supported, is assumed.
                  &lt;p&gt;
                  If this flavor does not support the charset parameter, its
                  representation must be &lt;code&gt;java.io.InputStream&lt;/code&gt;,
                  &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or &lt;code&gt;[B&lt;/code&gt;.
                  &lt;p&gt;
                  See &lt;code&gt;selectBestTextFlavor&lt;/code&gt; for a list of text flavors which
                  support the charset parameter.                
                <return>
                    <code>true</code> if this <code>DataFlavor</code> is a valid
                      text flavor as described above; <code>false</code> otherwise                    
                </return>
                <see>
                    #selectBestTextFlavor                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFlavorTextType" type="boolean" line="1260"/>
            <javadoc line="1265">
                Serializes this &lt;code&gt;DataFlavor&lt;/code&gt;.                
            </javadoc>
            <method name="writeExternal" type="void" line="1269">
                <params>
                    <param name="os" type="ObjectOutput"/>
                </params>
                <scope line="1270"/>
                <scope line="1274"/>
            </method>
            <javadoc line="1281">
                Restores this &lt;code&gt;DataFlavor&lt;/code&gt; from a Serialized state.                
            </javadoc>
            <method name="readExternal" type="void" line="1285">
                <params>
                    <param name="is" type="ObjectInput"/>
                </params>
                <comment line="1306">
                    Ensure backward compatibility.                    
                </comment>
                <comment line="1307">
                    Old versions didn&apos;t write the representation class to the stream.                    
                </comment>
                <declaration name="rcn" type="String" line="1286"/>
                <scope line="1289">
                    <scope line="1294"/>
                </scope>
                <scope line="1300"/>
                <scope line="1302">
                    <scope line="1303"/>
                    <scope line="1308"/>
                </scope>
            </method>
            <javadoc line="1315">
                Returns a clone of this &lt;code&gt;DataFlavor&lt;/code&gt;.                
                <return>
                    a clone of this <code>DataFlavor</code>                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="1320">
                <declaration name="newObj" type="Object" line="1321"/>
                <scope line="1322"/>
            </method>
            <javadoc line="1328">
                Called on &lt;code&gt;DataFlavor&lt;/code&gt; for every MIME Type parameter
                  to allow &lt;code&gt;DataFlavor&lt;/code&gt; subclasses to handle special
                  parameters like the text/plain &lt;code&gt;charset&lt;/code&gt;
                  parameters, whose values are case insensitive.  (MIME type parameter
                  values are supposed to be case sensitive.
                  &lt;p&gt;
                  This method is called for each parameter name/value pair and should
                  return the normalized representation of the &lt;code&gt;parameterValue&lt;/code&gt;.
                  This method is never invoked by this implementation from 1.1 onwards.                
                <deprecated>
                                        
                </deprecated>
            </javadoc>
            <method name="normalizeMimeTypeParameter" type="String" line="1343">
                <params>
                    <param name="parameterName" type="String"/>
                    <param name="parameterValue" type="String"/>
                </params>
            </method>
            <javadoc line="1347">
                Called for each MIME type string to give &lt;code&gt;DataFlavor&lt;/code&gt; subtypes
                  the opportunity to change how the normalization of MIME types is
                  accomplished.  One possible use would be to add default
                  parameter/value pairs in cases where none are present in the MIME
                  type string passed in.
                  This method is never invoked by this implementation from 1.1 onwards.                
                <deprecated>
                                        
                </deprecated>
            </javadoc>
            <method name="normalizeMimeType" type="String" line="1359">
                <params>
                    <param name="mimeType" type="String"/>
                </params>
            </method>
            <declaration name="atom" type="int" line="1369"/>
            <declaration name="mimeType" type="MimeType" line="1373"/>
            <declaration name="humanPresentableName" type="String" line="1375"/>
            <declaration name="representationClass" type="Class" line="1377"/>
            <javadoc line="1377">
                Java class of objects this DataFlavor represents                
            </javadoc>
        </class>
    </source>