<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt.font">
        <import package="java.awt.Font"/>
        <import package="java.text.AttributedCharacterIterator"/>
        <import package="java.text.AttributedString"/>
        <import package="java.text.Bidi"/>
        <import package="java.text.BreakIterator"/>
        <import package="java.text.CharacterIterator"/>
        <import package="java.awt.font.FontRenderContext"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Map"/>
        <import package="sun.font.AttributeValues"/>
        <import package="sun.font.BidiUtils"/>
        <import package="sun.font.TextLineComponent"/>
        <import package="sun.font.TextLabelFactory"/>
        <import package="sun.font.FontResolver"/>
        <class name="TextMeasurer" line="62">
            <comment line="100">
                Number of lines to format to.                
            </comment>
            <comment line="103">
                static {
                String s = System.getProperty(&quot;estLines&quot;);
                if (s != null) {
                try {
                Float f = new Float(s);
                EST_LINES = f.floatValue();
                }
                catch(NumberFormatException e) {
                }
                }
                System.out.println(&quot;EST_LINES=&quot;+EST_LINES);
                }                
            </comment>
            <comment line="122">
                characters in source text                
            </comment>
            <comment line="125">
                Bidi for this paragraph                
            </comment>
            <comment line="128">
                Levels array for chars in this paragraph - needed to reorder
                 trailing counterdirectional whitespace                
            </comment>
            <comment line="132">
                line components in logical order                
            </comment>
            <comment line="135">
                index where components begin                
            </comment>
            <comment line="138">
                index where components end                
            </comment>
            <comment line="143">
                used to find valid starting points for line components                
            </comment>
            <comment line="149">
                paragraph, with resolved fonts and styles                
            </comment>
            <comment line="152">
                paragraph data - same across all layouts                
            </comment>
            <implements interface="Cloneable"/>
            <javadoc line="62">
                The &lt;code&gt;TextMeasurer&lt;/code&gt; class provides the primitive operations
                  needed for line break: measuring up to a given advance, determining the
                  advance of a range of characters, and generating a
                  &lt;code&gt;TextLayout&lt;/code&gt; for a range of characters. It also provides
                  methods for incremental editing of paragraphs.
                  &lt;p&gt;
                  A &lt;code&gt;TextMeasurer&lt;/code&gt; object is constructed with an{@link java.text.AttributedCharacterIterator AttributedCharacterIterator}representing a single paragraph of text.  The value returned by the{@link AttributedCharacterIterator#getBeginIndex() getBeginIndex}method of &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
                  defines the absolute index of the first character.  The value
                  returned by the{@link AttributedCharacterIterator#getEndIndex() getEndIndex}method of &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; defines the index
                  past the last character.  These values define the range of indexes to
                  use in calls to the &lt;code&gt;TextMeasurer&lt;/code&gt;.  For example, calls to
                  get the advance of a range of text or the line break of a range of text
                  must use indexes between the beginning and end index values.  Calls to{@link #insertChar(java.text.AttributedCharacterIterator,int) insertChar}and{@link #deleteChar(java.text.AttributedCharacterIterator,int) deleteChar}reset the &lt;code&gt;TextMeasurer&lt;/code&gt; to use the beginning index and end
                  index of the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; passed in those calls.
                  &lt;p&gt;
                  Most clients will use the more convenient &lt;code&gt;LineBreakMeasurer&lt;/code&gt;,
                  which implements the standard line break policy (placing as many words
                  as will fit on each line).                
                <author>
                    John Raley                    
                </author>
                <see>
                    LineBreakMeasurer                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="EST_LINES" type="float" line="100"/>
            <declaration name="fFrc" type="FontRenderContext" line="117"/>
            <declaration name="fStart" type="int" line="119"/>
            <declaration name="fChars" type="char[]" line="122"/>
            <declaration name="fBidi" type="Bidi" line="125"/>
            <declaration name="fLevels" type="byte[]" line="129"/>
            <declaration name="fComponents" type="TextLineComponent[]" line="132"/>
            <declaration name="fComponentStart" type="int" line="135"/>
            <declaration name="fComponentLimit" type="int" line="138"/>
            <declaration name="haveLayoutWindow" type="boolean" line="140"/>
            <declaration name="fLineBreak" type="BreakIterator" line="143"/>
            <declaration name="charIter" type="CharArrayIterator" line="144"/>
            <declaration name="layoutCount" type="int" line="145"/>
            <declaration name="layoutCharCount" type="int" line="146"/>
            <declaration name="fParagraph" type="StyledParagraph" line="149"/>
            <declaration name="fIsDirectionLTR" type="boolean" line="152"/>
            <declaration name="fBaseline" type="byte" line="153"/>
            <declaration name="fBaselineOffsets" type="float[]" line="154"/>
            <declaration name="fJustifyRatio" type="float" line="155"/>
            <javadoc line="157">
                Constructs a &lt;code&gt;TextMeasurer&lt;/code&gt; from the source text.
                  The source text should be a single entire paragraph.                
                <param>
                    text the source paragraph.  Cannot be null.                    
                </param>
                <param>
                    frc the information about a graphics device which is needed
                      to measure the text correctly.  Cannot be null.                    
                </param>
            </javadoc>
            <method name="TextMeasurer" type="constructor" line="164">
                <params>
                    <param name="text" type="AttributedCharacterIterator"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
            </method>
            <method name="clone" type="Object" line="170">
                <declaration name="other" type="TextMeasurer" line="171"/>
                <scope line="172"/>
                <scope line="175"/>
                <scope line="178"/>
            </method>
            <method name="invalidateComponents" type="void" line="184"/>
            <javadoc line="190">
                Initialize state, including fChars array, direction, and
                  fBidi.                
            </javadoc>
            <method name="initAll" type="void" line="194">
                <params>
                    <param name="text" type="AttributedCharacterIterator"/>
                </params>
                <comment line="199">
                    extract chars                    
                </comment>
                <comment line="223">
                    set paragraph attributes                    
                </comment>
                <comment line="225">
                    If there&apos;s an embedded graphic at the start of the
                     paragraph, look for the first non-graphic character
                     and use it and its font to initialize the paragraph.
                     If not, use the first graphic to initialize.                    
                </comment>
                <comment line="241">
                    hmmm what to do here?  Just try to supply reasonable
                     values I guess.                    
                </comment>
                <declaration name="n" type="int" line="201"/>
                <scope line="202"/>
                <scope line="209"/>
                <declaration name="paragraphAttrs" type="Map" line="214"/>
                <declaration name="shaper" type="NumericShaper" line="215"/>
                <scope line="216"/>
                <scope line="223">
                    <declaration name="haveFont" type="boolean" line="230"/>
                    <scope line="232">
                        <declaration name="defaultFont" type="Font" line="233"/>
                        <declaration name="charsStart" type="int" line="234"/>
                        <declaration name="lm" type="LineMetrics" line="235"/>
                    </scope>
                    <scope line="239">
                        <declaration name="graphic" type="GraphicAttribute" line="243"/>
                        <declaration name="dummyFont" type="Font" line="246"/>
                        <declaration name="lm" type="LineMetrics" line="247"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="256">
                Generate components for the paragraph.  fChars, fBidi should have been
                  initialized already.                
            </javadoc>
            <method name="generateComponents" type="void" line="260">
                <params>
                    <param name="startingAt" type="int"/>
                    <param name="endingAt" type="int"/>
                </params>
                <comment line="266">
                    no extra info yet, bidi determines run and line direction                    
                </comment>
                <comment line="294">
                    debugFormatCount += (endingAt-startingAt);                    
                </comment>
                <scope line="262"/>
                <declaration name="layoutFlags" type="int" line="265"/>
                <declaration name="factory" type="TextLabelFactory" line="266"/>
                <declaration name="charsLtoV" type="int[]" line="268"/>
                <scope line="270">
                    <declaration name="charsVtoL" type="int[]" line="272"/>
                </scope>
                <scope line="276"/>
                <scope line="281"/>
                <scope line="285"/>
            </method>
            <method name="calcLineBreak" type="int" line="296">
                <params>
                    <param name="pos" type="int"/>
                    <param name="maxAdvance" type="float"/>
                </params>
                <comment line="299">
                    either of these statements removes the bug:
                    generateComponents(0, fChars.length);
                    generateComponents(pos, fChars.length);                    
                </comment>
                <comment line="319">
                    tlcStart is now the start of the tlc at tlcIndex                    
                </comment>
                <comment line="338">
                    format more text and try again
                    if (haveLayoutWindow) {
                        outOfWindow++;
                    }                    
                </comment>
                <declaration name="startPos" type="int" line="302"/>
                <declaration name="width" type="float" line="303"/>
                <declaration name="tlcIndex" type="int" line="305"/>
                <declaration name="tlcStart" type="int" line="306"/>
                <scope line="308">
                    <declaration name="gaLimit" type="int" line="309"/>
                    <scope line="310"/>
                    <scope line="313"/>
                </scope>
                <scope line="320">
                    <declaration name="tlc" type="TextLineComponent" line="322"/>
                    <declaration name="numCharsInGa" type="int" line="323"/>
                    <declaration name="lineBreak" type="int" line="325"/>
                    <scope line="326"/>
                    <scope line="331"/>
                </scope>
                <scope line="336"/>
            </method>
            <javadoc line="349">
                According to the Unicode Bidirectional Behavior specification
                  (Unicode Standard 2.0, section 3.11), whitespace at the ends
                  of lines which would naturally flow against the base direction
                  must be made to flow with the line direction, and moved to the
                  end of the line.  This method returns the start of the sequence
                  of trailing whitespace characters to move to the end of a
                  line taken from the given range.                
            </javadoc>
            <method name="trailingCdWhitespaceStart" type="int" line="358">
                <params>
                    <param name="startPos" type="int"/>
                    <param name="limitPos" type="int"/>
                </params>
                <comment line="362">
                    Back up over counterdirectional whitespace                    
                </comment>
                <scope line="360">
                    <declaration name="baseLevel" type="byte" line="362"/>
                    <scope line="363">
                        <scope line="365"/>
                    </scope>
                </scope>
            </method>
            <method name="makeComponentsOnRange" type="TextLineComponent[]" line="375">
                <params>
                    <param name="startPos" type="int"/>
                    <param name="limitPos" type="int"/>
                </params>
                <comment line="378">
                    sigh I really hate to do this here since it&apos;s part of the
                     bidi algorithm.
                     cdWsStart is the start of the trailing counterdirectional
                     whitespace                    
                </comment>
                <comment line="397">
                    tlcStart is now the start of the tlc at tlcIndex                    
                </comment>
                <declaration name="cdWsStart" type="int" line="381"/>
                <declaration name="tlcIndex" type="int" line="383"/>
                <declaration name="tlcStart" type="int" line="384"/>
                <scope line="386">
                    <declaration name="gaLimit" type="int" line="387"/>
                    <scope line="388"/>
                    <scope line="391"/>
                </scope>
                <declaration name="componentCount" type="int" line="398"/>
                <scope line="399">
                    <declaration name="split" type="boolean" line="400"/>
                    <declaration name="compStart" type="int" line="401"/>
                    <declaration name="lim" type="int" line="402"/>
                    <scope line="403">
                        <declaration name="gaLimit" type="int" line="404"/>
                        <scope line="406"/>
                        <scope line="409"/>
                        <scope line="412"/>
                    </scope>
                    <scope line="417"/>
                </scope>
                <declaration name="components" type="TextLineComponent[]" line="422"/>
                <declaration name="newCompIndex" type="int" line="423"/>
                <declaration name="linePos" type="int" line="424"/>
                <declaration name="breakPt" type="int" line="426"/>
                <declaration name="subsetFlag" type="int" line="428"/>
                <scope line="429"/>
                <scope line="434"/>
                <scope line="438">
                    <declaration name="compLength" type="int" line="440"/>
                    <declaration name="tlcLimit" type="int" line="441"/>
                    <declaration name="start" type="int" line="443"/>
                    <declaration name="limit" type="int" line="444"/>
                    <scope line="451"/>
                    <scope line="456"/>
                </scope>
            </method>
            <method name="makeTextLineOnRange" type="TextLine" line="465">
                <params>
                    <param name="startPos" type="int"/>
                    <param name="limitPos" type="int"/>
                </params>
                <declaration name="charsLtoV" type="int[]" line="467"/>
                <declaration name="charLevels" type="byte[]" line="468"/>
                <scope line="470">
                    <declaration name="lineBidi" type="Bidi" line="471"/>
                    <declaration name="charsVtoL" type="int[]" line="473"/>
                </scope>
                <declaration name="components" type="TextLineComponent[]" line="477"/>
            </method>
            <method name="ensureComponents" type="void" line="491">
                <params>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <scope line="493"/>
            </method>
            <method name="makeLayoutWindow" type="void" line="498">
                <params>
                    <param name="localStart" type="int"/>
                </params>
                <comment line="504">
                    If we&apos;ve already gone past the layout window, format to end of paragraph                    
                </comment>
                <declaration name="compStart" type="int" line="500"/>
                <declaration name="compLimit" type="int" line="501"/>
                <scope line="504">
                    <declaration name="avgLineLength" type="float" line="505"/>
                </scope>
                <scope line="509">
                    <scope line="510"/>
                    <scope line="513"/>
                    <scope line="516"/>
                    <scope line="520">
                        <scope line="521"/>
                    </scope>
                    <scope line="525">
                        <scope line="526"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="536">
                Returns the index of the first character which will not fit on
                  on a line beginning at &lt;code&gt;start&lt;/code&gt; and possible
                  measuring up to &lt;code&gt;maxAdvance&lt;/code&gt; in graphical width.                
                <param>
                    start the character index at which to start measuring.
                      <code>start</code> is an absolute index, not relative to the
                      start of the paragraph                    
                </param>
                <param>
                    maxAdvance the graphical width in which the line must fit                    
                </param>
                <return>
                    the index after the last character that will fit
                      on a line beginning at <code>start</code>, which is not longer
                      than <code>maxAdvance</code> in graphical width                    
                </return>
                <throws>
                    IllegalArgumentException if <code>start</code> is
                      less than the beginning of the paragraph.                    
                </throws>
            </javadoc>
            <method name="getLineBreakIndex" type="int" line="551">
                <params>
                    <param name="start" type="int"/>
                    <param name="maxAdvance" type="float"/>
                </params>
                <declaration name="localStart" type="int" line="553"/>
                <scope line="557"/>
            </method>
            <javadoc line="564">
                Returns the graphical width of a line beginning at &lt;code&gt;start&lt;/code&gt;
                  and including characters up to &lt;code&gt;limit&lt;/code&gt;.
                  &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;limit&lt;/code&gt; are absolute indices,
                  not relative to the start of the paragraph.                
                <param>
                    start the character index at which to start measuring                    
                </param>
                <param>
                    limit the character index at which to stop measuring                    
                </param>
                <return>
                    the graphical width of a line beginning at <code>start</code>
                      and including characters up to <code>limit</code>                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <code>limit</code> is less
                      than <code>start</code>                    
                </throws>
                <throws>
                    IllegalArgumentException if <code>start</code> or
                      <code>limit</code> is not between the beginning of
                      the paragraph and the end of the paragraph.                    
                </throws>
            </javadoc>
            <method name="getAdvanceBetween" type="float" line="580">
                <params>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <comment line="589">
                    could cache line in case getLayout is called with same start, limit                    
                </comment>
                <declaration name="localStart" type="int" line="582"/>
                <declaration name="localLimit" type="int" line="583"/>
                <declaration name="line" type="TextLine" line="586"/>
            </method>
            <javadoc line="591">
                Returns a &lt;code&gt;TextLayout&lt;/code&gt; on the given character range.                
                <param>
                    start the index of the first character                    
                </param>
                <param>
                    limit the index after the last character.  Must be greater
                      than <code>start</code>                    
                </param>
                <return>
                    a <code>TextLayout</code> for the characters beginning at
                      <code>start</code> up to (but not including) <code>limit</code>                    
                </return>
                <throws>
                    IndexOutOfBoundsException if <code>limit</code> is less
                      than <code>start</code>                    
                </throws>
                <throws>
                    IllegalArgumentException if <code>start</code> or
                      <code>limit</code> is not between the beginning of
                      the paragraph and the end of the paragraph.                    
                </throws>
            </javadoc>
            <method name="getLayout" type="TextLayout" line="605">
                <params>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <declaration name="localStart" type="int" line="607"/>
                <declaration name="localLimit" type="int" line="608"/>
                <declaration name="textLine" type="TextLine" line="611"/>
                <scope line="613"/>
            </method>
            <declaration name="formattedChars" type="int" line="624"/>
            <declaration name="wantStats" type="boolean" line="625"/>
            <declaration name="collectStats" type="boolean" line="626"/>
            <method name="printStats" type="void" line="628">
                <comment line="631">
                    formattedChars = 0;                    
                </comment>
            </method>
            <javadoc line="634">
                Updates the &lt;code&gt;TextMeasurer&lt;/code&gt; after a single character has
                  been inserted
                  into the paragraph currently represented by this
                  &lt;code&gt;TextMeasurer&lt;/code&gt;.  After this call, this
                  &lt;code&gt;TextMeasurer&lt;/code&gt; is equivalent to a new
                  &lt;code&gt;TextMeasurer&lt;/code&gt; created from the text;  however, it will
                  usually be more efficient to update an existing
                  &lt;code&gt;TextMeasurer&lt;/code&gt; than to create a new one from scratch.                
                <param>
                    newParagraph the text of the paragraph after performing
                      the insertion.  Cannot be null.                    
                </param>
                <param>
                    insertPos the position in the text where the character was
                      inserted.  Must not be less than the start of
                      <code>newParagraph</code>, and must be less than the end of
                      <code>newParagraph</code>.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if <code>insertPos</code> is less
                      than the start of <code>newParagraph</code> or greater than
                      or equal to the end of <code>newParagraph</code>                    
                </throws>
                <throws>
                    NullPointerException if <code>newParagraph</code> is
                      <code>null</code>                    
                </throws>
            </javadoc>
            <method name="insertChar" type="void" line="656">
                <params>
                    <param name="newParagraph" type="AttributedCharacterIterator"/>
                    <param name="insertPos" type="int"/>
                </params>
                <scope line="658"/>
                <scope line="661"/>
                <declaration name="end" type="int" line="666"/>
                <scope line="667"/>
                <declaration name="newChars" type="char[]" line="671"/>
                <declaration name="newCharIndex" type="int" line="672"/>
                <declaration name="newChar" type="char" line="675"/>
                <scope line="685">
                    <scope line="688"/>
                </scope>
            </method>
            <javadoc line="700">
                Updates the &lt;code&gt;TextMeasurer&lt;/code&gt; after a single character has
                  been deleted
                  from the paragraph currently represented by this
                  &lt;code&gt;TextMeasurer&lt;/code&gt;.  After this call, this
                  &lt;code&gt;TextMeasurer&lt;/code&gt; is equivalent to a new &lt;code&gt;TextMeasurer&lt;/code&gt;
                  created from the text;  however, it will usually be more efficient
                  to update an existing &lt;code&gt;TextMeasurer&lt;/code&gt; than to create a new one
                  from scratch.                
                <param>
                    newParagraph the text of the paragraph after performing
                      the deletion.  Cannot be null.                    
                </param>
                <param>
                    deletePos the position in the text where the character was removed.
                      Must not be less than
                      the start of <code>newParagraph</code>, and must not be greater than the
                      end of <code>newParagraph</code>.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if <code>deletePos</code> is
                      less than the start of <code>newParagraph</code> or greater
                      than the end of <code>newParagraph</code>                    
                </throws>
                <throws>
                    NullPointerException if <code>newParagraph</code> is
                      <code>null</code>                    
                </throws>
            </javadoc>
            <method name="deleteChar" type="void" line="722">
                <params>
                    <param name="newParagraph" type="AttributedCharacterIterator"/>
                    <param name="deletePos" type="int"/>
                </params>
                <declaration name="end" type="int" line="725"/>
                <scope line="726"/>
                <declaration name="newChars" type="char[]" line="730"/>
                <declaration name="changedIndex" type="int" line="731"/>
                <scope line="737">
                    <scope line="739"/>
                </scope>
            </method>
            <javadoc line="751">
                NOTE:  This method is only for LineBreakMeasurer&apos;s use.  It is package-
                  private because it returns internal data.                
            </javadoc>
            <method name="getChars" type="char[]" line="755"/>
        </class>
    </source>