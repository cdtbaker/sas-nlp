<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt.font">
        <import package="java.text.BreakIterator"/>
        <import package="java.text.CharacterIterator"/>
        <import package="java.text.AttributedCharacterIterator"/>
        <import package="java.awt.font.FontRenderContext"/>
        <class name="LineBreakMeasurer" line="6">
            <javadoc line="6">
                The &lt;code&gt;LineBreakMeasurer&lt;/code&gt; class allows styled text to be
                  broken into lines (or segments) that fit within a particular visual
                  advance.  This is useful for clients who wish to display a paragraph of
                  text that fits within a specific width, called the &lt;b&gt;wrapping
                  width&lt;/b&gt;.
                  &lt;p&gt;
                  &lt;code&gt;LineBreakMeasurer&lt;/code&gt; is constructed with an iterator over
                  styled text.  The iterator&apos;s range should be a single paragraph in the
                  text.
                  &lt;code&gt;LineBreakMeasurer&lt;/code&gt; maintains a position in the text for the
                  start of the next text segment.  Initially, this position is the
                  start of text.  Paragraphs are assigned an overall direction (either
                  left-to-right or right-to-left) according to the bidirectional
                  formatting rules.  All segments obtained from a paragraph have the
                  same direction as the paragraph.
                  &lt;p&gt;
                  Segments of text are obtained by calling the method
                  &lt;code&gt;nextLayout&lt;/code&gt;, which returns a {@link TextLayout}representing the text that fits within the wrapping width.
                  The &lt;code&gt;nextLayout&lt;/code&gt; method moves the current position
                  to the end of the layout returned from &lt;code&gt;nextLayout&lt;/code&gt;.
                  &lt;p&gt;
                  &lt;code&gt;LineBreakMeasurer&lt;/code&gt; implements the most commonly used
                  line-breaking policy: Every word that fits within the wrapping
                  width is placed on the line. If the first word does not fit, then all
                  of the characters that fit within the wrapping width are placed on the
                  line.  At least one character is placed on each line.
                  &lt;p&gt;
                  The &lt;code&gt;TextLayout&lt;/code&gt; instances returned by
                  &lt;code&gt;LineBreakMeasurer&lt;/code&gt; treat tabs like 0-width spaces.  Clients
                  who wish to obtain tab-delimited segments for positioning should use
                  the overload of &lt;code&gt;nextLayout&lt;/code&gt; which takes a limiting offset
                  in the text.
                  The limiting offset should be the first character after the tab.
                  The &lt;code&gt;TextLayout&lt;/code&gt; objects returned from this method end
                  at the limit provided (or before, if the text between the current
                  position and the limit won&apos;t fit entirely within the  wrapping
                  width).
                  &lt;p&gt;
                  Clients who are laying out tab-delimited text need a slightly
                  different line-breaking policy after the first segment has been
                  placed on a line.  Instead of fitting partial words in the
                  remaining space, they should place words which don&apos;t fit in the
                  remaining space entirely on the next line.  This change of policy
                  can be requested in the overload of &lt;code&gt;nextLayout&lt;/code&gt; which
                  takes a &lt;code&gt;boolean&lt;/code&gt; parameter.  If this parameter is
                  &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;nextLayout&lt;/code&gt; returns
                  &lt;code&gt;null&lt;/code&gt; if the first word won&apos;t fit in
                  the given space.  See the tab sample below.
                  &lt;p&gt;
                  In general, if the text used to construct the
                  &lt;code&gt;LineBreakMeasurer&lt;/code&gt; changes, a new
                  &lt;code&gt;LineBreakMeasurer&lt;/code&gt; must be constructed to reflect
                  the change.  (The old &lt;code&gt;LineBreakMeasurer&lt;/code&gt; continues to
                  function properly, but it won&apos;t be aware of the text change.)
                  Nevertheless, if the text change is the insertion or deletion of a
                  single character, an existing &lt;code&gt;LineBreakMeasurer&lt;/code&gt; can be
                  &apos;updated&apos; by calling &lt;code&gt;insertChar&lt;/code&gt; or
                  &lt;code&gt;deleteChar&lt;/code&gt;. Updating an existing
                  &lt;code&gt;LineBreakMeasurer&lt;/code&gt; is much faster than creating a new one.
                  Clients who modify text based on user typing should take advantage
                  of these methods.
                  &lt;p&gt;
                  &lt;strong&gt;Examples&lt;/strong&gt;:&lt;p&gt;
                  Rendering a paragraph in a component
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  public void paint(Graphics graphics) {
                  Point2D pen = new Point2D(10, 20);
                  Graphics2D g2d = (Graphics2D)graphics;
                  FontRenderContext frc = g2d.getFontRenderContext();
                  // let styledText be an AttributedCharacterIterator containing at least
                  // one character
                  LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, frc);
                  float wrappingWidth = getSize().width - 15;
                  while (measurer.getPosition() &lt; fStyledText.length()) {
                  TextLayout layout = measurer.nextLayout(wrappingWidth);
                  pen.y += (layout.getAscent());
                  float dx = layout.isLeftToRight() ?
                  0 : (wrappingWidth - layout.getAdvance());
                  layout.draw(graphics, pen.x + dx, pen.y);
                  pen.y += layout.getDescent() + layout.getLeading();
                  }
                  }
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  Rendering text with tabs.  For simplicity, the overall text
                  direction is assumed to be left-to-right
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  public void paint(Graphics graphics) {
                  float leftMargin = 10, rightMargin = 310;
                  float[] tabStops = { 100, 250 };
                  // assume styledText is an AttributedCharacterIterator, and the number
                  // of tabs in styledText is tabCount
                  int[] tabLocations = new int[tabCount+1];
                  int i = 0;
                  for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {
                  if (c == &apos;\t&apos;) {
                  tabLocations[i++] = styledText.getIndex();
                  }
                  }
                  tabLocations[tabCount] = styledText.getEndIndex() - 1;
                  // Now tabLocations has an entry for every tab&apos;s offset in
                  // the text.  For convenience, the last entry is tabLocations
                  // is the offset of the last character in the text.
                  LineBreakMeasurer measurer = new LineBreakMeasurer(styledText);
                  int currentTab = 0;
                  float verticalPos = 20;
                  while (measurer.getPosition() &lt; styledText.getEndIndex()) {
                  // Lay out and draw each line.  All segments on a line
                  // must be computed before any drawing can occur, since
                  // we must know the largest ascent on the line.
                  // TextLayouts are computed and stored in a Vector;
                  // their horizontal positions are stored in a parallel
                  // Vector.
                  // lineContainsText is true after first segment is drawn
                  boolean lineContainsText = false;
                  boolean lineComplete = false;
                  float maxAscent = 0, maxDescent = 0;
                  float horizontalPos = leftMargin;
                  Vector layouts = new Vector(1);
                  Vector penPositions = new Vector(1);
                  while (!lineComplete) {
                  float wrappingWidth = rightMargin - horizontalPos;
                  TextLayout layout =
                  measurer.nextLayout(wrappingWidth,
                  tabLocations[currentTab]+1,
                  lineContainsText);
                  // layout can be null if lineContainsText is true
                  if (layout != null) {
                  layouts.addElement(layout);
                  penPositions.addElement(new Float(horizontalPos));
                  horizontalPos += layout.getAdvance();
                  maxAscent = Math.max(maxAscent, layout.getAscent());
                  maxDescent = Math.max(maxDescent,
                  layout.getDescent() + layout.getLeading());
                  } else {
                  lineComplete = true;
                  }
                  lineContainsText = true;
                  if (measurer.getPosition() == tabLocations[currentTab]+1) {
                  currentTab++;
                  }
                  if (measurer.getPosition() == styledText.getEndIndex())
                  lineComplete = true;
                  else if (horizontalPos &gt;= tabStops[tabStops.length-1])
                  lineComplete = true;
                  if (!lineComplete) {
                  // move to next tab stop
                  int j;
                  for (j=0; horizontalPos &gt;= tabStops[j]; j++) {}
                  horizontalPos = tabStops[j];
                  }
                  }
                  verticalPos += maxAscent;
                  Enumeration layoutEnum = layouts.elements();
                  Enumeration positionEnum = penPositions.elements();
                  // now iterate through layouts and draw them
                  while (layoutEnum.hasMoreElements()) {
                  TextLayout nextLayout = (TextLayout) layoutEnum.nextElement();
                  Float nextPosition = (Float) positionEnum.nextElement();
                  nextLayout.draw(graphics, nextPosition.floatValue(), verticalPos);
                  }
                  verticalPos += maxDescent;
                  }
                  }
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;                
                <see>
                    TextLayout                    
                </see>
            </javadoc>
            <declaration name="breakIter" type="BreakIterator" line="179"/>
            <declaration name="start" type="int" line="180"/>
            <declaration name="pos" type="int" line="181"/>
            <declaration name="limit" type="int" line="182"/>
            <declaration name="measurer" type="TextMeasurer" line="183"/>
            <declaration name="charIter" type="CharArrayIterator" line="184"/>
            <javadoc line="185">
                Constructs a &lt;code&gt;LineBreakMeasurer&lt;/code&gt; for the specified text.                
                <param>
                    text the text for which this <code>LineBreakMeasurer</code>
                      produces <code>TextLayout</code> objects; the text must contain
                      at least one character; if the text available through
                      <code>iter</code> changes, further calls to this
                      <code>LineBreakMeasurer</code> instance are undefined (except,
                      in some cases, when <code>insertChar</code> or
                      <code>deleteChar</code> are invoked afterward - see below)                    
                </param>
                <param>
                    frc contains information about a graphics device which is
                      needed to measure the text correctly;
                      text measurements can vary slightly depending on the
                      device resolution, and attributes such as antialiasing; this
                      parameter does not specify a translation between the
                      <code>LineBreakMeasurer</code> and user space                    
                </param>
                <see>
                    LineBreakMeasurer#insertChar                    
                </see>
                <see>
                    LineBreakMeasurer#deleteChar                    
                </see>
            </javadoc>
            <method name="LineBreakMeasurer" type="constructor" line="203">
                <params>
                    <param name="text" type="AttributedCharacterIterator"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
            </method>
            <javadoc line="206">
                Constructs a &lt;code&gt;LineBreakMeasurer&lt;/code&gt; for the specified text.                
                <param>
                    text the text for which this <code>LineBreakMeasurer</code>
                      produces <code>TextLayout</code> objects; the text must contain
                      at least one character; if the text available through
                      <code>iter</code> changes, further calls to this
                      <code>LineBreakMeasurer</code> instance are undefined (except,
                      in some cases, when <code>insertChar</code> or
                      <code>deleteChar</code> are invoked afterward - see below)                    
                </param>
                <param>
                    breakIter the {@link BreakIterator} which defines line
                      breaks                    
                </param>
                <param>
                    frc contains information about a graphics device which is
                      needed to measure the text correctly;
                      text measurements can vary slightly depending on the
                      device resolution, and attributes such as antialiasing; this
                      parameter does not specify a translation between the
                      <code>LineBreakMeasurer</code> and user space                    
                </param>
                <throws>
                    IllegalArgumentException if the text has less than one character                    
                </throws>
                <see>
                    LineBreakMeasurer#insertChar                    
                </see>
                <see>
                    LineBreakMeasurer#deleteChar                    
                </see>
            </javadoc>
            <method name="LineBreakMeasurer" type="constructor" line="227">
                <params>
                    <param name="text" type="AttributedCharacterIterator"/>
                    <param name="breakIter" type="BreakIterator"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <scope line="228"/>
            </method>
            <javadoc line="238">
                Returns the position at the end of the next layout.  Does NOT
                  update the current position of this &lt;code&gt;LineBreakMeasurer&lt;/code&gt;.                
                <param>
                    wrappingWidth the maximum visible advance permitted for
                      the text in the next layout                    
                </param>
                <return>
                    an offset in the text representing the limit of the
                      next <code>TextLayout</code>.                    
                </return>
            </javadoc>
            <method name="nextOffset" type="int" line="246">
                <params>
                    <param name="wrappingWidth" type="float"/>
                </params>
            </method>
            <javadoc line="249">
                Returns the position at the end of the next layout.  Does NOT
                  update the current position of this &lt;code&gt;LineBreakMeasurer&lt;/code&gt;.                
                <param>
                    wrappingWidth the maximum visible advance permitted for
                      the text in the next layout                    
                </param>
                <param>
                    offsetLimit the first character that can not be included
                      in the next layout, even if the text after the limit would fit
                      within the wrapping width; <code>offsetLimit</code> must be
                      greater than the current position                    
                </param>
                <param>
                    requireNextWord if <code>true</code>, the current position
                      that is returned if the entire next word does not fit within
                      <code>wrappingWidth</code>; if <code>false</code>, the offset
                      returned is at least one greater than the current position                    
                </param>
                <return>
                    an offset in the text representing the limit of the
                      next <code>TextLayout</code>                    
                </return>
            </javadoc>
            <method name="nextOffset" type="int" line="265">
                <params>
                    <param name="wrappingWidth" type="float"/>
                    <param name="offsetLimit" type="int"/>
                    <param name="requireNextWord" type="boolean"/>
                </params>
                <declaration name="nextOffset" type="int" line="266"/>
                <scope line="267">
                    <scope line="268"/>
                    <declaration name="charAtMaxAdvance" type="int" line="271"/>
                    <scope line="272"/>
                    <scope line="275"/>
                    <scope line="278">
                        <declaration name="testPos" type="int" line="279"/>
                        <scope line="280"/>
                        <scope line="284"/>
                        <scope line="287">
                            <scope line="288"/>
                            <scope line="291"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="297"/>
            </method>
            <javadoc line="302">
                Returns the next layout, and updates the current position.                
                <param>
                    wrappingWidth the maximum visible advance permitted for
                      the text in the next layout                    
                </param>
                <return>
                    a <code>TextLayout</code>, beginning at the current
                      position, which represents the next line fitting within
                      <code>wrappingWidth</code>                    
                </return>
            </javadoc>
            <method name="nextLayout" type="TextLayout" line="310">
                <params>
                    <param name="wrappingWidth" type="float"/>
                </params>
            </method>
            <javadoc line="313">
                Returns the next layout, and updates the current position.                
                <param>
                    wrappingWidth the maximum visible advance permitted
                      for the text in the next layout                    
                </param>
                <param>
                    offsetLimit the first character that can not be
                      included in the next layout, even if the text after the limit
                      would fit within the wrapping width; <code>offsetLimit</code>
                      must be greater than the current position                    
                </param>
                <param>
                    requireNextWord if <code>true</code>, and if the entire word
                      at the current position does not fit within the wrapping width,
                      <code>null</code> is returned. If <code>false</code>, a valid
                      layout is returned that includes at least the character at the
                      current position                    
                </param>
                <return>
                    a <code>TextLayout</code>, beginning at the current
                      position, that represents the next line fitting within
                      <code>wrappingWidth</code>.  If the current position is at the end
                      of the text used by this <code>LineBreakMeasurer</code>,
                      <code>null</code> is returned                    
                </return>
            </javadoc>
            <method name="nextLayout" type="TextLayout" line="332">
                <params>
                    <param name="wrappingWidth" type="float"/>
                    <param name="offsetLimit" type="int"/>
                    <param name="requireNextWord" type="boolean"/>
                </params>
                <scope line="333">
                    <declaration name="layoutLimit" type="int" line="334"/>
                    <scope line="335"/>
                    <declaration name="result" type="TextLayout" line="338"/>
                </scope>
                <scope line="342"/>
            </method>
            <javadoc line="346">
                Returns the current position of this &lt;code&gt;LineBreakMeasurer&lt;/code&gt;.                
                <return>
                    the current position of this <code>LineBreakMeasurer</code>                    
                </return>
                <see>
                    #setPosition                    
                </see>
            </javadoc>
            <method name="getPosition" type="int" line="351"/>
            <javadoc line="354">
                Sets the current position of this &lt;code&gt;LineBreakMeasurer&lt;/code&gt;.                
                <param>
                    newPosition the current position of this
                      <code>LineBreakMeasurer</code>; the position should be within the
                      text used to construct this <code>LineBreakMeasurer</code> (or in
                      the text most recently passed to <code>insertChar</code>
                      or <code>deleteChar</code>                    
                </param>
                <see>
                    #getPosition                    
                </see>
            </javadoc>
            <method name="setPosition" type="void" line="363">
                <params>
                    <param name="newPosition" type="int"/>
                </params>
                <scope line="364"/>
            </method>
            <javadoc line="369">
                Updates this &lt;code&gt;LineBreakMeasurer&lt;/code&gt; after a single
                  character is inserted into the text, and sets the current
                  position to the beginning of the paragraph.                
                <param>
                    newParagraph the text after the insertion                    
                </param>
                <param>
                    insertPos the position in the text at which the character
                      is inserted                    
                </param>
                <throws>
                    IndexOutOfBoundsException if <code>insertPos</code> is less
                      than the start of <code>newParagraph</code> or greater than
                      or equal to the end of <code>newParagraph</code>                    
                </throws>
                <throws>
                    NullPointerException if <code>newParagraph</code> is
                      <code>null</code>                    
                </throws>
                <see>
                    #deleteChar                    
                </see>
            </javadoc>
            <method name="insertChar" type="void" line="383">
                <params>
                    <param name="newParagraph" type="AttributedCharacterIterator"/>
                    <param name="insertPos" type="int"/>
                </params>
            </method>
            <javadoc line="390">
                Updates this &lt;code&gt;LineBreakMeasurer&lt;/code&gt; after a single
                  character is deleted from the text, and sets the current
                  position to the beginning of the paragraph.                
                <param>
                    newParagraph the text after the deletion                    
                </param>
                <param>
                    deletePos the position in the text at which the character
                      is deleted                    
                </param>
                <throws>
                    IndexOutOfBoundsException if <code>deletePos</code> is
                      less than the start of <code>newParagraph</code> or greater
                      than the end of <code>newParagraph</code>                    
                </throws>
                <throws>
                    NullPointerException if <code>newParagraph</code> is
                      <code>null</code>                    
                </throws>
                <see>
                    #insertChar                    
                </see>
            </javadoc>
            <method name="deleteChar" type="void" line="404">
                <params>
                    <param name="newParagraph" type="AttributedCharacterIterator"/>
                    <param name="deletePos" type="int"/>
                </params>
            </method>
        </class>
    </source>