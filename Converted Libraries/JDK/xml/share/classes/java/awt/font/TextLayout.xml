<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt.font">
        <import package="java.awt.Color"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Shape"/>
        <import package="java.awt.font.NumericShaper"/>
        <import package="java.awt.font.TextLine.TextLineMetrics"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.GeneralPath"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.text.AttributedString"/>
        <import package="java.text.AttributedCharacterIterator"/>
        <import package="java.text.AttributedCharacterIterator.Attribute"/>
        <import package="java.util.Map"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Hashtable"/>
        <import package="sun.font.AttributeValues"/>
        <import package="sun.font.CoreMetrics"/>
        <import package="sun.font.Decoration"/>
        <import package="sun.font.FontLineMetrics"/>
        <import package="sun.font.FontResolver"/>
        <import package="sun.font.GraphicComponent"/>
        <import package="sun.font.LayoutPathImpl"/>
        <import package="sun.text.CodePointIterator"/>
        <class name="TextLayout" line="70">
            <comment line="244">
                why have these ?                
            </comment>
            <comment line="247">
                cached values computed from GlyphSets and set info:
                 all are recomputed from scratch in buildCache()                
            </comment>
            <comment line="253">
                TextLayouts are supposedly immutable.  If you mutate a TextLayout under
                 the covers (like the justification code does) you&apos;ll need to set this
                 back to false.  Could be replaced with textLine != null &lt;--&gt; cacheIsValid.                
            </comment>
            <comment line="261">
                This value is obtained from an attribute, and constrained to the
                 interval [0,1].  If 0, the layout cannot be justified.                
            </comment>
            <comment line="265">
                If a layout is produced by justification, then that layout
                 cannot be justified.  To enforce this constraint the
                 justifyRatio of the justified layout is set to this value.                
            </comment>
            <comment line="270">
                dx and dy specify the distance between the TextLayout&apos;s origin
                 and the origin of the leftmost GlyphSet (TextLayoutComponent,
                 actually).  They were used for hanging punctuation support,
                 which is no longer implemented.  Currently they are both always 0,
                 and TextLayout is not guaranteed to work with non-zero dx, dy
                 values right now.  They were left in as an aide and reminder to
                 anyone who implements hanging punctuation or other similar stuff.
                 They are static now so they don&apos;t take up space in TextLayout
                 instances.                
            </comment>
            <comment line="282">
                Natural bounds is used internally.  It is built on demand in
                 getNaturalBounds.                
            </comment>
            <comment line="288">
                boundsRect encloses all of the bits this TextLayout can draw.  It
                 is build on demand in getBounds.                
            </comment>
            <comment line="294">
                flag to supressallow carets inside of ligatures when hit testing or
                 arrow-keying                
            </comment>
            <comment line="445">
                Determines a font for the attributes, and if a single font can render
                 all the text on one baseline, return it, otherwise null.  If the
                 attributes specify a font, assume it can display all the text without
                 checking.
                 If the AttributeSet contains an embedded graphic, return null.                
            </comment>
            <comment line="579">
                the fast init generates a single glyph set.  This requires:
                 all one style
                 all renderable by one font (ie no embedded graphics)
                 all on one baseline                
            </comment>
            <comment line="607">
                the standard init generates multiple glyph sets based on style,
                 renderable, and baseline runs.
                 @param chars the text in the iterator, extracted into a char array                
            </comment>
            <comment line="649">
                A utility to rebuild the ascentdescentleadingadvance cache.
                 You&apos;ll need to call this if you clone and mutate (like justification,
                 editing methods do)                
            </comment>
            <comment line="761">
                Utility to throw an expection if an invalid TextHitInfo is passed
                 as a parameter.  Avoids code duplication.                
            </comment>
            <comment line="1047">
                carets and hit testing
                
                 Positions on a text line are represented by instances of TextHitInfo.
                 Any TextHitInfo with characterOffset between 0 and characterCount-1,
                 inclusive, represents a valid position on the line.  Additionally,
                 [-1, trailing] and [characterCount, leading] are valid positions, and
                 represent positions at the logical start and end of the line,
                 respectively.
                
                 The characterOffsets in TextHitInfo&apos;s used and returned by TextLayout
                 are relative to the beginning of the text layout, not necessarily to
                 the beginning of the text storage the client is using.
                
                
                 Every valid TextHitInfo has either one or two carets associated with it.
                 A caret is a visual location in the TextLayout indicating where text at
                 the TextHitInfo will be displayed on screen.  If a TextHitInfo
                 represents a location on a directional boundary, then there are two
                 possible visible positions for newly inserted text.  Consider the
                 following example, in which capital letters indicate right-to-left text,
                 and the overall line direction is left-to-right:
                
                 Text Storage: [ a, b, C, D, E, f ]
                 Display:        a b E D C f
                
                 The text hit info (1, t) represents the trailing side of &apos;b&apos;.  If &apos;q&apos;,
                 a left-to-right character is inserted into the text storage at this
                 location, it will be displayed between the &apos;b&apos; and the &apos;E&apos;:
                
                 Text Storage: [ a, b, q, C, D, E, f ]
                 Display:        a b q E D C f
                
                 However, if a &apos;W&apos;, which is right-to-left, is inserted into the storage
                 after &apos;b&apos;, the storage and display will be:
                
                 Text Storage: [ a, b, W, C, D, E, f ]
                 Display:        a b E D C W f
                
                 So, for the original text storage, two carets should be displayed for
                 location (1, t): one visually between &apos;b&apos; and &apos;E&apos; and one visually
                 between &apos;C&apos; and &apos;f&apos;.
                
                
                 When two carets are displayed for a TextHitInfo, one caret is the
                 &apos;strong&apos; caret and the other is the &apos;weak&apos; caret.  The strong caret
                 indicates where an inserted character will be displayed when that
                 character&apos;s direction is the same as the direction of the TextLayout.
                 The weak caret shows where an character inserted character will be
                 displayed when the character&apos;s direction is opposite that of the
                 TextLayout.
                
                
                 Clients should not be overly concerned with the details of correct
                 caret display. TextLayout.getCaretShapes(TextHitInfo) will return an
                 array of two paths representing where carets should be displayed.
                 The first path in the array is the strong caret; the second element,
                 if non-null, is the weak caret.  If the second element is null,
                 then there is no weak caret for the given TextHitInfo.
                
                
                 Since text can be visually reordered, logically consecutive
                 TextHitInfo&apos;s may not be visually consecutive.  One implication of this
                 is that a client cannot tell from inspecting a TextHitInfo whether the
                 hit represents the first (or last) caret in the layout.  Clients
                 can call getVisualOtherHit();  if the visual companion is
                 (-1, TRAILING) or (characterCount, LEADING), then the hit is at the
                 first (last) caret position in the layout.                
            </comment>
            <comment line="1217">
                this version provides extra info in the float array
                 the first two values are as above
                 the next four values are the endpoints of the caret, as computed
                 using the hit character&apos;s offset (baseline + ssoffset) and
                 natural ascent and descent.
                 these  values are trimmed to the bounds where required to fit,
                 but otherwise independent of it.                
            </comment>
            <comment line="1944">
                A utility to return a path enclosing the given path
                 Path0 must be left or top of path1
                 {jbr} no assumptions about size of path0, path1 anymore.                
            </comment>
            <comment line="1993">
                A utility to convert a pair of carets into a bounding path
                 {jbr} Shape is never outside of bounds.                
            </comment>
            <comment line="2009">
                A utility to return the path bounding the area to the left (top) of the
                 layout.
                 Shape is never outside of bounds.                
            </comment>
            <comment line="2032">
                A utility to return the path bounding the area to the right (bottom) of
                 the layout.                
            </comment>
            <implements interface="Cloneable"/>
            <javadoc line="70">
                &lt;code&gt;TextLayout&lt;/code&gt; is an immutable graphical representation of styled
                  character data.
                  &lt;p&gt;
                  It provides the following capabilities:
                  &lt;ul&gt;
                  &lt;li&gt;implicit bidirectional analysis and reordering,
                  &lt;li&gt;cursor positioning and movement, including split cursors for
                  mixed directional text,
                  &lt;li&gt;highlighting, including both logical and visual highlighting
                  for mixed directional text,
                  &lt;li&gt;multiple baselines (roman, hanging, and centered),
                  &lt;li&gt;hit testing,
                  &lt;li&gt;justification,
                  &lt;li&gt;default font substitution,
                  &lt;li&gt;metric information such as ascent, descent, and advance, and
                  &lt;li&gt;rendering
                  &lt;/ul&gt;
                  &lt;p&gt;
                  A &lt;code&gt;TextLayout&lt;/code&gt; object can be rendered using
                  its &lt;code&gt;draw&lt;/code&gt; method.
                  &lt;p&gt;
                  &lt;code&gt;TextLayout&lt;/code&gt; can be constructed either directly or through
                  the use of a {@link LineBreakMeasurer}.  When constructed directly, the
                  source text represents a single paragraph.  &lt;code&gt;LineBreakMeasurer&lt;/code&gt;
                  allows styled text to be broken into lines that fit within a particular
                  width.  See the &lt;code&gt;LineBreakMeasurer&lt;/code&gt; documentation for more
                  information.
                  &lt;p&gt;
                  &lt;code&gt;TextLayout&lt;/code&gt; construction logically proceeds as follows:
                  &lt;ul&gt;
                  &lt;li&gt;paragraph attributes are extracted and examined,
                  &lt;li&gt;text is analyzed for bidirectional reordering, and reordering
                  information is computed if needed,
                  &lt;li&gt;text is segmented into style runs
                  &lt;li&gt;fonts are chosen for style runs, first by using a font if the
                  attribute {@link TextAttribute#FONT} is present, otherwise by computing
                  a default font using the attributes that have been defined
                  &lt;li&gt;if text is on multiple baselines, the runs or subruns are further
                  broken into subruns sharing a common baseline,
                  &lt;li&gt;glyphvectors are generated for each run using the chosen font,
                  &lt;li&gt;final bidirectional reordering is performed on the glyphvectors
                  &lt;/ul&gt;
                  &lt;p&gt;
                  All graphical information returned from a &lt;code&gt;TextLayout&lt;/code&gt;
                  object&apos;s methods is relative to the origin of the
                  &lt;code&gt;TextLayout&lt;/code&gt;, which is the intersection of the
                  &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s baseline with its left edge.  Also,
                  coordinates passed into a &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s methods
                  are assumed to be relative to the &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s
                  origin.  Clients usually need to translate between a
                  &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s coordinate system and the coordinate
                  system in another object (such as a{@link java.awt.Graphics Graphics} object).
                  &lt;p&gt;
                  &lt;code&gt;TextLayout&lt;/code&gt; objects are constructed from styled text,
                  but they do not retain a reference to their source text.  Thus,
                  changes in the text previously used to generate a &lt;code&gt;TextLayout&lt;/code&gt;
                  do not affect the &lt;code&gt;TextLayout&lt;/code&gt;.
                  &lt;p&gt;
                  Three methods on a &lt;code&gt;TextLayout&lt;/code&gt; object
                  (&lt;code&gt;getNextRightHit&lt;/code&gt;, &lt;code&gt;getNextLeftHit&lt;/code&gt;, and
                  &lt;code&gt;hitTestChar&lt;/code&gt;) return instances of {@link TextHitInfo}.
                  The offsets contained in these &lt;code&gt;TextHitInfo&lt;/code&gt; objects
                  are relative to the start of the &lt;code&gt;TextLayout&lt;/code&gt;, &lt;b&gt;not&lt;/b&gt;
                  to the text used to create the &lt;code&gt;TextLayout&lt;/code&gt;.  Similarly,
                  &lt;code&gt;TextLayout&lt;/code&gt; methods that accept &lt;code&gt;TextHitInfo&lt;/code&gt;
                  instances as parameters expect the &lt;code&gt;TextHitInfo&lt;/code&gt; object&apos;s
                  offsets to be relative to the &lt;code&gt;TextLayout&lt;/code&gt;, not to any
                  underlying text storage model.
                  &lt;p&gt;
                  &lt;strong&gt;Examples&lt;/strong&gt;:&lt;p&gt;
                  Constructing and drawing a &lt;code&gt;TextLayout&lt;/code&gt; and its bounding
                  rectangle:
                  &lt;blockquote&gt;&lt;pre&gt;
                  Graphics2D g = ...;
                  Point2D loc = ...;
                  Font font = Font.getFont(&quot;Helvetica-bold-italic&quot;);
                  FontRenderContext frc = g.getFontRenderContext();
                  TextLayout layout = new TextLayout(&quot;This is a string&quot;, font, frc);
                  layout.draw(g, (float)loc.getX(), (float)loc.getY());
                  Rectangle2D bounds = layout.getBounds();
                  bounds.setRect(bounds.getX()+loc.getX(),
                  bounds.getY()+loc.getY(),
                  bounds.getWidth(),
                  bounds.getHeight());
                  g.draw(bounds);
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  Hit-testing a &lt;code&gt;TextLayout&lt;/code&gt; (determining which character is at
                  a particular graphical location):
                  &lt;blockquote&gt;&lt;pre&gt;
                  Point2D click = ...;
                  TextHitInfo hit = layout.hitTestChar(
                  (float) (click.getX() - loc.getX()),
                  (float) (click.getY() - loc.getY()));
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  Responding to a right-arrow key press:
                  &lt;blockquote&gt;&lt;pre&gt;
                  int insertionIndex = ...;
                  TextHitInfo next = layout.getNextRightHit(insertionIndex);
                  if (next != null) {
                  // translate graphics to origin of layout on screen
                  g.translate(loc.getX(), loc.getY());
                  Shape[] carets = layout.getCaretShapes(next.getInsertionIndex());
                  g.draw(carets[0]);
                  if (carets[1] != null) {
                  g.draw(carets[1]);
                  }
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  Drawing a selection range corresponding to a substring in the source text.
                  The selected area may not be visually contiguous:
                  &lt;blockquote&gt;&lt;pre&gt;
                  // selStart, selLimit should be relative to the layout,
                  // not to the source text
                  int selStart = ..., selLimit = ...;
                  Color selectionColor = ...;
                  Shape selection = layout.getLogicalHighlightShape(selStart, selLimit);
                  // selection may consist of disjoint areas
                  // graphics is assumed to be tranlated to origin of layout
                  g.setColor(selectionColor);
                  g.fill(selection);
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  Drawing a visually contiguous selection range.  The selection range may
                  correspond to more than one substring in the source text.  The ranges of
                  the corresponding source text substrings can be obtained with
                  &lt;code&gt;getLogicalRangesForVisualSelection()&lt;/code&gt;:
                  &lt;blockquote&gt;&lt;pre&gt;
                  TextHitInfo selStart = ..., selLimit = ...;
                  Shape selection = layout.getVisualHighlightShape(selStart, selLimit);
                  g.setColor(selectionColor);
                  g.fill(selection);
                  int[] ranges = getLogicalRangesForVisualSelection(selStart, selLimit);
                  // ranges[0], ranges[1] is the first selection range,
                  // ranges[2], ranges[3] is the second selection range, etc.
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  Note: Font rotations can cause text baselines to be rotated, and
                  multiple runs with different rotations can cause the baseline to
                  bend or zig-zag.  In order to account for this (rare) possibility,
                  some APIs are specified to return metrics and take parameters &apos;in
                  baseline-relative coordinates&apos; (e.g. ascent, advance), and others
                  are in &apos;in standard coordinates&apos; (e.g. getBounds).  Values in
                  baseline-relative coordinates map the &apos;x&apos; coordinate to the
                  distance along the baseline, (positive x is forward along the
                  baseline), and the &apos;y&apos; coordinate to a distance along the
                  perpendicular to the baseline at &apos;x&apos; (postitive y is 90 degrees
                  clockwise from the baseline vector).  Values in standard
                  coordinates are measured along the x and y axes, with 0,0 at the
                  origin of the TextLayout.  Documentation for each relevant API
                  indicates what values are in what coordinate system.  In general,
                  measurement-related APIs are in baseline-relative coordinates,
                  while display-related APIs are in standard coordinates.                
                <see>
                    LineBreakMeasurer                    
                </see>
                <see>
                    TextAttribute                    
                </see>
                <see>
                    TextHitInfo                    
                </see>
                <see>
                    LayoutPath                    
                </see>
            </javadoc>
            <declaration name="characterCount" type="int" line="240"/>
            <declaration name="isVerticalLine" type="boolean" line="241"/>
            <declaration name="baseline" type="byte" line="242"/>
            <declaration name="baselineOffsets" type="float[]" line="243"/>
            <declaration name="textLine" type="TextLine" line="244"/>
            <declaration name="lineMetrics" type="TextLine.TextLineMetrics" line="248"/>
            <declaration name="visibleAdvance" type="float" line="249"/>
            <declaration name="hashCodeCache" type="int" line="250"/>
            <declaration name="cacheIsValid" type="boolean" line="257"/>
            <declaration name="justifyRatio" type="float" line="262"/>
            <declaration name="ALREADY_JUSTIFIED" type="float" line="267"/>
            <declaration name="dx" type="float" line="278"/>
            <declaration name="dy" type="float" line="279"/>
            <declaration name="naturalBounds" type="Rectangle2D" line="285"/>
            <declaration name="boundsRect" type="Rectangle2D" line="291"/>
            <declaration name="caretsInLigaturesAreAllowed" type="boolean" line="297"/>
            <class name="CaretPolicy" line="299">
                <javadoc line="299">
                    Defines a policy for determining the strong caret location.
                      This class contains one method, &lt;code&gt;getStrongCaret&lt;/code&gt;, which
                      is used to specify the policy that determines the strong caret in
                      dual-caret text.  The strong caret is used to move the caret to the
                      left or right. Instances of this class can be passed to
                      &lt;code&gt;getCaretShapes&lt;/code&gt;, &lt;code&gt;getNextLeftHit&lt;/code&gt; and
                      &lt;code&gt;getNextRightHit&lt;/code&gt; to customize strong caret
                      selection.
                      &lt;p&gt;
                      To specify alternate caret policies, subclass &lt;code&gt;CaretPolicy&lt;/code&gt;
                      and override &lt;code&gt;getStrongCaret&lt;/code&gt;.  &lt;code&gt;getStrongCaret&lt;/code&gt;
                      should inspect the two &lt;code&gt;TextHitInfo&lt;/code&gt; arguments and choose
                      one of them as the strong caret.
                      &lt;p&gt;
                      Most clients do not need to use this class.                    
                </javadoc>
                <javadoc line="318">
                    Constructs a &lt;code&gt;CaretPolicy&lt;/code&gt;.                    
                </javadoc>
                <method name="CaretPolicy" type="constructor" line="321"/>
                <javadoc line="324">
                    Chooses one of the specified &lt;code&gt;TextHitInfo&lt;/code&gt; instances as
                      a strong caret in the specified &lt;code&gt;TextLayout&lt;/code&gt;.                    
                    <param>
                        hit1 a valid hit in &lt;code&gt;layout&lt;/code&gt;                        
                    </param>
                    <param>
                        hit2 a valid hit in &lt;code&gt;layout&lt;/code&gt;                        
                    </param>
                    <param>
                        layout the &lt;code&gt;TextLayout&lt;/code&gt; in which
                          &lt;code&gt;hit1&lt;/code&gt; and &lt;code&gt;hit2&lt;/code&gt; are used                        
                    </param>
                    <return>
                        &lt;code&gt;hit1&lt;/code&gt; or &lt;code&gt;hit2&lt;/code&gt;
                          (or an equivalent &lt;code&gt;TextHitInfo&lt;/code&gt;), indicating the
                          strong caret.                        
                    </return>
                </javadoc>
                <method name="getStrongCaret" type="TextHitInfo" line="337">
                    <params>
                        <param name="hit1" type="TextHitInfo"/>
                        <param name="hit2" type="TextHitInfo"/>
                        <param name="layout" type="TextLayout"/>
                    </params>
                    <comment line="340">
                        default implmentation just calls private method on layout                        
                    </comment>
                </method>
            </class>
            <declaration name="DEFAULT_CARET_POLICY" type="CaretPolicy" line="344"/>
            <javadoc line="344">
                This &lt;code&gt;CaretPolicy&lt;/code&gt; is used when a policy is not specified
                  by the client.  With this policy, a hit on a character whose direction
                  is the same as the line direction is stronger than a hit on a
                  counterdirectional character.  If the characters&apos; directions are
                  the same, a hit on the leading edge of a character is stronger
                  than a hit on the trailing edge of a character.                
            </javadoc>
            <javadoc line="354">
                Constructs a &lt;code&gt;TextLayout&lt;/code&gt; from a &lt;code&gt;String&lt;/code&gt;
                  and a {@link Font}.  All the text is styled using the specified
                  &lt;code&gt;Font&lt;/code&gt;.
                  &lt;p&gt;
                  The &lt;code&gt;String&lt;/code&gt; must specify a single paragraph of text,
                  because an entire paragraph is required for the bidirectional
                  algorithm.                
                <param>
                    string the text to display                    
                </param>
                <param>
                    font a &lt;code&gt;Font&lt;/code&gt; used to style the text                    
                </param>
                <param>
                    frc contains information about a graphics device which is needed
                      to measure the text correctly.
                      Text measurements can vary slightly depending on the
                      device resolution, and attributes such as antialiasing.  This
                      parameter does not specify a translation between the
                      &lt;code&gt;TextLayout&lt;/code&gt; and user space.                    
                </param>
            </javadoc>
            <method name="TextLayout" type="constructor" line="371">
                <params>
                    <param name="string" type="String"/>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <scope line="373"/>
                <scope line="377"/>
                <scope line="381"/>
                <declaration name="attributes" type="Map" line="385"/>
                <scope line="386"/>
                <declaration name="text" type="char[]" line="390"/>
                <scope line="391"/>
                <scope line="393">
                    <declaration name="as" type="AttributedString" line="394"/>
                </scope>
            </method>
            <javadoc line="402">
                Constructs a &lt;code&gt;TextLayout&lt;/code&gt; from a &lt;code&gt;String&lt;/code&gt;
                  and an attribute set.
                  &lt;p&gt;
                  All the text is styled using the provided attributes.
                  &lt;p&gt;
                  &lt;code&gt;string&lt;/code&gt; must specify a single paragraph of text because an
                  entire paragraph is required for the bidirectional algorithm.                
                <param>
                    string the text to display                    
                </param>
                <param>
                    attributes the attributes used to style the text                    
                </param>
                <param>
                    frc contains information about a graphics device which is needed
                      to measure the text correctly.
                      Text measurements can vary slightly depending on the
                      device resolution, and attributes such as antialiasing.  This
                      parameter does not specify a translation between the
                      &lt;code&gt;TextLayout&lt;/code&gt; and user space.                    
                </param>
            </javadoc>
            <method name="TextLayout" type="constructor" line="421">
                <params>
                    <param name="string" type="String"/>
                    <param name="attributes" type="Map<? extends Attribute,?>"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <scope line="422"/>
                <scope line="426"/>
                <scope line="430"/>
                <declaration name="text" type="char[]" line="434"/>
                <declaration name="font" type="Font" line="435"/>
                <scope line="436"/>
                <scope line="438">
                    <declaration name="as" type="AttributedString" line="439"/>
                </scope>
            </method>
            <method name="singleFont" type="Font" line="454">
                <params>
                    <param name="text" type="char[]"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                    <param name="attributes" type="Map"/>
                </params>
                <scope line="456"/>
                <declaration name="font" type="Font" line="460"/>
                <scope line="461"/>
                <scope line="464"/>
                <scope line="466">
                    <scope line="467">
                        <scope line="469"/>
                    </scope>
                    <scope line="472">
                        <declaration name="resolver" type="FontResolver" line="473"/>
                        <declaration name="iter" type="CodePointIterator" line="474"/>
                        <declaration name="fontIndex" type="int" line="475"/>
                        <scope line="476"/>
                    </scope>
                </scope>
                <scope line="482"/>
            </method>
            <javadoc line="489">
                Constructs a &lt;code&gt;TextLayout&lt;/code&gt; from an iterator over styled text.
                  &lt;p&gt;
                  The iterator must specify a single paragraph of text because an
                  entire paragraph is required for the bidirectional
                  algorithm.                
                <param>
                    text the styled text to display                    
                </param>
                <param>
                    frc contains information about a graphics device which is needed
                      to measure the text correctly.
                      Text measurements can vary slightly depending on the
                      device resolution, and attributes such as antialiasing.  This
                      parameter does not specify a translation between the
                      &lt;code&gt;TextLayout&lt;/code&gt; and user space.                    
                </param>
            </javadoc>
            <method name="TextLayout" type="constructor" line="503">
                <params>
                    <param name="text" type="AttributedCharacterIterator"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <scope line="505"/>
                <declaration name="start" type="int" line="509"/>
                <declaration name="limit" type="int" line="510"/>
                <scope line="511"/>
                <declaration name="len" type="int" line="515"/>
                <declaration name="chars" type="char[]" line="517"/>
                <declaration name="n" type="int" line="518"/>
                <scope line="519"/>
                <scope line="524">
                    <declaration name="attributes" type="Map" line="526"/>
                    <declaration name="font" type="Font" line="527"/>
                    <scope line="528"/>
                </scope>
            </method>
            <javadoc line="537">
                Creates a &lt;code&gt;TextLayout&lt;/code&gt; from a {@link TextLine} and
                  some paragraph data.  This method is used by {@link TextMeasurer}.                
                <param>
                    textLine the line measurement attributes to apply to the
                      the resulting &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <param>
                    baseline the baseline of the text                    
                </param>
                <param>
                    baselineOffsets the baseline offsets for this
                      &lt;code&gt;TextLayout&lt;/code&gt;.  This should already be normalized to
                      &lt;code&gt;baseline&lt;/code&gt;                    
                </param>
                <param>
                    justifyRatio &lt;code&gt;0&lt;/code&gt; if the &lt;code&gt;TextLayout&lt;/code&gt;
                      cannot be justified; &lt;code&gt;1&lt;/code&gt; otherwise.                    
                </param>
            </javadoc>
            <method name="TextLayout" type="constructor" line="552">
                <params>
                    <param name="textLine" type="TextLine"/>
                    <param name="baseline" type="byte"/>
                    <param name="baselineOffsets" type="float[]"/>
                    <param name="justifyRatio" type="float"/>
                </params>
            </method>
            <javadoc line="561">
                Initialize the paragraph-specific data.                
            </javadoc>
            <method name="paragraphInit" type="void" line="564">
                <params>
                    <param name="aBaseline" type="byte"/>
                    <param name="lm" type="CoreMetrics"/>
                    <param name="paragraphAttrs" type="Map"/>
                    <param name="text" type="char[]"/>
                </params>
                <comment line="569">
                    normalize to current baseline                    
                </comment>
                <declaration name="shaper" type="NumericShaper" line="572"/>
                <scope line="573"/>
            </method>
            <method name="fastInit" type="void" line="584">
                <params>
                    <param name="chars" type="char[]"/>
                    <param name="font" type="Font"/>
                    <param name="attrs" type="Map"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <comment line="586">
                    Object vf = attrs.get(TextAttribute.ORIENTATION);
                     isVerticalLine = TextAttribute.ORIENTATION_VERTICAL.equals(vf);                    
                </comment>
                <declaration name="lm" type="LineMetrics" line="589"/>
                <declaration name="cm" type="CoreMetrics" line="590"/>
                <declaration name="glyphBaseline" type="byte" line="591"/>
                <scope line="593"/>
                <scope line="597"/>
            </method>
            <method name="standardInit" type="void" line="611">
                <params>
                    <param name="text" type="AttributedCharacterIterator"/>
                    <param name="chars" type="char[]"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <comment line="616">
                    set paragraph attributes                    
                </comment>
                <comment line="618">
                    If there&apos;s an embedded graphic at the start of the
                     paragraph, look for the first non-graphic character
                     and use it and its font to initialize the paragraph.
                     If not, use the first graphic to initialize.                    
                </comment>
                <comment line="635">
                    hmmm what to do here?  Just try to supply reasonable
                     values I guess.                    
                </comment>
                <scope line="616">
                    <declaration name="paragraphAttrs" type="Map" line="622"/>
                    <declaration name="haveFont" type="boolean" line="624"/>
                    <scope line="626">
                        <declaration name="defaultFont" type="Font" line="627"/>
                        <declaration name="charsStart" type="int" line="628"/>
                        <declaration name="lm" type="LineMetrics" line="629"/>
                        <declaration name="cm" type="CoreMetrics" line="630"/>
                    </scope>
                    <scope line="633">
                        <declaration name="graphic" type="GraphicAttribute" line="637"/>
                        <declaration name="defaultBaseline" type="byte" line="639"/>
                        <declaration name="cm" type="CoreMetrics" line="640"/>
                    </scope>
                </scope>
            </method>
            <method name="ensureCache" type="void" line="653">
                <scope line="654"/>
            </method>
            <method name="buildCache" type="void" line="659">
                <comment line="663">
                    compute visibleAdvance                    
                </comment>
                <comment line="713">
                    naturalBounds, boundsRect will be generated on demand                    
                </comment>
                <comment line="717">
                    hashCode will be regenerated on demand                    
                </comment>
                <scope line="663">
                    <declaration name="lastNonSpace" type="int" line="665"/>
                    <scope line="666">
                        <declaration name="logIndex" type="int" line="667"/>
                        <scope line="668"/>
                        <scope line="671"/>
                    </scope>
                    <scope line="675"/>
                    <scope line="678"/>
                    <scope line="681">
                        <declaration name="logIndex" type="int" line="682"/>
                    </scope>
                </scope>
                <scope line="687">
                    <declaration name="leftmostNonSpace" type="int" line="689"/>
                    <scope line="690">
                        <declaration name="logIndex" type="int" line="691"/>
                        <scope line="692"/>
                        <scope line="695"/>
                    </scope>
                    <scope line="699"/>
                    <scope line="702"/>
                    <scope line="705">
                        <declaration name="logIndex" type="int" line="706"/>
                        <declaration name="pos" type="float" line="707"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="722">
                The &apos;natural bounds&apos; encloses all the carets the layout can draw.                
            </javadoc>
            <method name="getNaturalBounds" type="Rectangle2D" line="726">
                <scope line="729"/>
            </method>
            <javadoc line="736">
                Creates a copy of this &lt;code&gt;TextLayout&lt;/code&gt;.                
            </javadoc>
            <method name="clone" type="Object" line="739">
                <comment line="741">
                    !!! I think this is safe.  Once created, nothing mutates the
                     glyphvectors or arrays.  But we need to make sure.
                     {jbr} actually, that&apos;s not quite true.  The justification code
                     mutates after cloning.  It doesn&apos;t actually change the glyphvectors
                     (that&apos;s impossible) but it replaces them with justified sets.  This
                     is a problem for GlyphIterator creation, since new GlyphIterators
                     are created by cloning a prototype.  If the prototype has outdated
                     glyphvectors, so will the new ones.  A partial solution is to set the
                     prototypical GlyphIterator to null when the glyphvectors change.  If
                     you forget this one time, you&apos;re hosed.                    
                </comment>
                <scope line="752"/>
                <scope line="755"/>
            </method>
            <method name="checkTextHit" type="void" line="764">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <scope line="765"/>
                <scope line="770"/>
            </method>
            <javadoc line="775">
                Creates a copy of this &lt;code&gt;TextLayout&lt;/code&gt; justified to the
                  specified width.
                  &lt;p&gt;
                  If this &lt;code&gt;TextLayout&lt;/code&gt; has already been justified, an
                  exception is thrown.  If this &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s
                  justification ratio is zero, a &lt;code&gt;TextLayout&lt;/code&gt; identical
                  to this &lt;code&gt;TextLayout&lt;/code&gt; is returned.                
                <param>
                    justificationWidth the width to use when justifying the line.
                      For best results, it should not be too different from the current
                      advance of the line.                    
                </param>
                <return>
                    a &lt;code&gt;TextLayout&lt;/code&gt; justified to the specified width.                    
                </return>
                <exception>
                    Error if this layout has already been justified, an Error is
                      thrown.                    
                </exception>
            </javadoc>
            <method name="getJustifiedLayout" type="TextLayout" line="790">
                <params>
                    <param name="justificationWidth" type="float"/>
                </params>
                <comment line="801">
                    make sure textLine is not null                    
                </comment>
                <comment line="803">
                    default justification range to exclude trailing logical whitespace                    
                </comment>
                <scope line="792"/>
                <scope line="796"/>
                <declaration name="limit" type="int" line="803"/>
                <scope line="804"/>
                <declaration name="newLine" type="TextLine" line="808"/>
                <scope line="809"/>
            </method>
            <javadoc line="816">
                Justify this layout.  Overridden by subclassers to control justification
                  (if there were subclassers, that is...)
                  The layout will only justify if the paragraph attributes (from the
                  source text, possibly defaulted by the layout attributes) indicate a
                  non-zero justification ratio.  The text will be justified to the
                  indicated width.  The current implementation also adjusts hanging
                  punctuation and trailing whitespace to overhang the justification width.
                  Once justified, the layout may not be rejustified.
                  &lt;p&gt;
                  Some code may rely on immutablity of layouts.  Subclassers should not
                  call this directly, but instead should call getJustifiedLayout, which
                  will call this method on a clone of this layout, preserving
                  the original.                
                <param>
                    justificationWidth the width to use when justifying the line.
                      For best results, it should not be too different from the current
                      advance of the line.                    
                </param>
                <see>
                    #getJustifiedLayout(float)                    
                </see>
            </javadoc>
            <method name="handleJustify" type="void" line="837">
                <params>
                    <param name="justificationWidth" type="float"/>
                </params>
                <comment line="839">
                    never called                    
                </comment>
            </method>
            <javadoc line="842">
                Returns the baseline for this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The baseline is one of the values defined in &lt;code&gt;Font&lt;/code&gt;,
                  which are roman, centered and hanging.  Ascent and descent are
                  relative to this baseline.  The &lt;code&gt;baselineOffsets&lt;/code&gt;
                  are also relative to this baseline.                
                <return>
                    the baseline of this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
                <see>
                    #getBaselineOffsets()                    
                </see>
                <see>
                    Font                    
                </see>
            </javadoc>
            <method name="getBaseline" type="byte" line="852"/>
            <javadoc line="856">
                Returns the offsets array for the baselines used for this
                  &lt;code&gt;TextLayout&lt;/code&gt;.
                  &lt;p&gt;
                  The array is indexed by one of the values defined in
                  &lt;code&gt;Font&lt;/code&gt;, which are roman, centered and hanging.  The
                  values are relative to this &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s
                  baseline, so that &lt;code&gt;getBaselineOffsets[getBaseline()] == 0&lt;/code&gt;.
                  Offsets are added to the position of the &lt;code&gt;TextLayout&lt;/code&gt;
                  object&apos;s baseline to get the position for the new baseline.                
                <return>
                    the offsets array containing the baselines used for this
                      &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
                <see>
                    #getBaseline()                    
                </see>
                <see>
                    Font                    
                </see>
            </javadoc>
            <method name="getBaselineOffsets" type="float[]" line="871">
                <declaration name="offsets" type="float[]" line="872"/>
            </method>
            <javadoc line="877">
                Returns the advance of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The advance is the distance from the origin to the advance of the
                  rightmost (bottommost) character.  This is in baseline-relative
                  coordinates.                
                <return>
                    the advance of this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getAdvance" type="float" line="884"/>
            <javadoc line="889">
                Returns the advance of this &lt;code&gt;TextLayout&lt;/code&gt;, minus trailing
                  whitespace.  This is in baseline-relative coordinates.                
                <return>
                    the advance of this &lt;code&gt;TextLayout&lt;/code&gt; without the
                      trailing whitespace.                    
                </return>
                <see>
                    #getAdvance()                    
                </see>
            </javadoc>
            <method name="getVisibleAdvance" type="float" line="896"/>
            <javadoc line="901">
                Returns the ascent of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The ascent is the distance from the top (right) of the
                  &lt;code&gt;TextLayout&lt;/code&gt; to the baseline.  It is always either
                  positive or zero.  The ascent is sufficient to
                  accomodate superscripted text and is the maximum of the sum of the
                  ascent, offset, and baseline of each glyph.  The ascent is
                  the maximum ascent from the baseline of all the text in the
                  TextLayout.  It is in baseline-relative coordinates.                
                <return>
                    the ascent of this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getAscent" type="float" line="912"/>
            <javadoc line="917">
                Returns the descent of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The descent is the distance from the baseline to the bottom (left) of
                  the &lt;code&gt;TextLayout&lt;/code&gt;.  It is always either positive or zero.
                  The descent is sufficient to accomodate subscripted text and is the
                  maximum of the sum of the descent, offset, and baseline of each glyph.
                  This is the maximum descent from the baseline of all the text in
                  the TextLayout.  It is in baseline-relative coordinates.                
                <return>
                    the descent of this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getDescent" type="float" line="927"/>
            <javadoc line="932">
                Returns the leading of the &lt;code&gt;TextLayout&lt;/code&gt;.
                  The leading is the suggested interline spacing for this
                  &lt;code&gt;TextLayout&lt;/code&gt;.  This is in baseline-relative
                  coordinates.
                  &lt;p&gt;
                  The leading is computed from the leading, descent, and baseline
                  of all glyphvectors in the &lt;code&gt;TextLayout&lt;/code&gt;.  The algorithm
                  is roughly as follows:
                  &lt;blockquote&gt;&lt;pre&gt;
                  maxD = 0;
                  maxDL = 0;
                  for (GlyphVector g in all glyphvectors) {
                  maxD = max(maxD, g.getDescent() + offsets[g.getBaseline()]);
                  maxDL = max(maxDL, g.getDescent() + g.getLeading() +
                  offsets[g.getBaseline()]);
                  }
                  return maxDL - maxD;
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <return>
                    the leading of this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getLeading" type="float" line="953"/>
            <javadoc line="958">
                Returns the bounds of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The bounds are in standard coordinates.
                  &lt;p&gt;Due to rasterization effects, this bounds might not enclose all of the
                  pixels rendered by the TextLayout.&lt;/p&gt;
                  It might not coincide exactly with the ascent, descent,
                  origin or advance of the &lt;code&gt;TextLayout&lt;/code&gt;.                
                <return>
                    a {@link Rectangle2D} that is the bounds of this
                      &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getBounds" type="Rectangle2D" line="968">
                <scope line="971">
                    <declaration name="vb" type="Rectangle2D" line="972"/>
                    <scope line="973"/>
                </scope>
                <declaration name="bounds" type="Rectangle2D" line="982"/>
            </method>
            <javadoc line="988">
                Returns the pixel bounds of this &lt;code&gt;TextLayout&lt;/code&gt; when
                  rendered in a graphics with the given
                  &lt;code&gt;FontRenderContext&lt;/code&gt; at the given location.  The
                  graphics render context need not be the same as the
                  &lt;code&gt;FontRenderContext&lt;/code&gt; used to create this
                  &lt;code&gt;TextLayout&lt;/code&gt;, and can be null.  If it is null, the
                  &lt;code&gt;FontRenderContext&lt;/code&gt; of this &lt;code&gt;TextLayout&lt;/code&gt;
                  is used.                
                <param>
                    frc the &lt;code&gt;FontRenderContext&lt;/code&gt; of the &lt;code&gt;Graphics&lt;/code&gt;.                    
                </param>
                <param>
                    x the x-coordinate at which to render this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </param>
                <param>
                    y the y-coordinate at which to render this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </param>
                <return>
                    a &lt;code&gt;Rectangle&lt;/code&gt; bounding the pixels that would be affected.                    
                </return>
                <see>
                    GlyphVector#getPixelBounds                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getPixelBounds" type="Rectangle" line="1004">
                <params>
                    <param name="frc" type="FontRenderContext"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
            </method>
            <javadoc line="1008">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;TextLayout&lt;/code&gt; has
                  a left-to-right base direction or &lt;code&gt;false&lt;/code&gt; if it has
                  a right-to-left base direction.  The &lt;code&gt;TextLayout&lt;/code&gt;
                  has a base direction of either left-to-right (LTR) or
                  right-to-left (RTL).  The base direction is independent of the
                  actual direction of text on the line, which may be either LTR,
                  RTL, or mixed. Left-to-right layouts by default should position
                  flush left.  If the layout is on a tabbed line, the
                  tabs run left to right, so that logically successive layouts position
                  left to right.  The opposite is true for RTL layouts. By default they
                  should position flush left, and tabs run right-to-left.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the base direction of this
                      &lt;code&gt;TextLayout&lt;/code&gt; is left-to-right; &lt;code&gt;false&lt;/code&gt;
                      otherwise.                    
                </return>
            </javadoc>
            <method name="isLeftToRight" type="boolean" line="1024"/>
            <javadoc line="1028">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;TextLayout&lt;/code&gt; is vertical.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;TextLayout&lt;/code&gt; is vertical;
                      &lt;code&gt;false&lt;/code&gt; otherwise.                    
                </return>
            </javadoc>
            <method name="isVertical" type="boolean" line="1033"/>
            <javadoc line="1037">
                Returns the number of characters represented by this
                  &lt;code&gt;TextLayout&lt;/code&gt;.                
                <return>
                    the number of characters in this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getCharacterCount" type="int" line="1042"/>
            <method name="getCaretInfo" type="float[]" line="1118">
                <params>
                    <param name="caret" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                    <param name="info" type="float[]"/>
                </params>
                <declaration name="top1X" type="float" line="1120"/>
                <declaration name="bottom1X" type="float" line="1121"/>
                <scope line="1123">
                    <declaration name="pos" type="float" line="1125"/>
                    <declaration name="logIndex" type="int" line="1126"/>
                    <scope line="1127"/>
                    <scope line="1132"/>
                    <declaration name="angle" type="float" line="1136"/>
                    <declaration name="shift" type="float" line="1137"/>
                </scope>
                <scope line="1142">
                    <scope line="1144">
                        <declaration name="logIndex" type="int" line="1145"/>
                        <declaration name="angle1" type="float" line="1146"/>
                        <declaration name="pos1" type="float" line="1147"/>
                        <scope line="1149"/>
                        <scope line="1154"/>
                    </scope>
                    <scope line="1158">
                        <declaration name="logIndex" type="int" line="1159"/>
                        <declaration name="angle2" type="float" line="1160"/>
                        <declaration name="pos2" type="float" line="1161"/>
                        <scope line="1162"/>
                        <scope line="1167"/>
                    </scope>
                </scope>
                <declaration name="topX" type="float" line="1173"/>
                <declaration name="bottomX" type="float" line="1174"/>
                <scope line="1176"/>
                <scope line="1180"/>
                <scope line="1184"/>
            </method>
            <javadoc line="1192">
                Returns information about the caret corresponding to &lt;code&gt;hit&lt;/code&gt;.
                  The first element of the array is the intersection of the caret with
                  the baseline, as a distance along the baseline. The second element
                  of the array is the inverse slope (run/rise) of the caret, measured
                  with respect to the baseline at that point.
                  &lt;p&gt;
                  This method is meant for informational use.  To display carets, it
                  is better to use &lt;code&gt;getCaretShapes&lt;/code&gt;.                
                <param>
                    hit a hit on a character in this &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <param>
                    bounds the bounds to which the caret info is constructed.
                      The bounds is in baseline-relative coordinates.                    
                </param>
                <return>
                    a two-element array containing the position and slope of
                      the caret.  The returned caret info is in baseline-relative coordinates.                    
                </return>
                <see>
                    #getCaretShapes(int,Rectangle2D,TextLayout.CaretPolicy)                    
                </see>
                <see>
                    Font#getItalicAngle                    
                </see>
            </javadoc>
            <method name="getCaretInfo" type="float[]" line="1209">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
            </method>
            <method name="getCaretInfoTestInternal" type="float[]" line="1223">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <comment line="1230">
                    get old data first                    
                </comment>
                <comment line="1233">
                    then add our new data                    
                </comment>
                <comment line="1242">
                    !!! note: want non-shifted, baseline ascent and descent here!
                     TextLine should return appropriate line metrics object for these values                    
                </comment>
                <comment line="1261">
                    this is a graphic, no italics, use entire line height for caret                    
                </comment>
                <comment line="1276">
                    !!! top/bottom adjustment not implemented for vertical                    
                </comment>
                <declaration name="info" type="float[]" line="1227"/>
                <declaration name="iangle" type="double" line="1233"/>
                <declaration name="charix" type="int" line="1235"/>
                <declaration name="lead" type="boolean" line="1236"/>
                <declaration name="ltr" type="boolean" line="1237"/>
                <declaration name="horiz" type="boolean" line="1238"/>
                <scope line="1240">
                    <declaration name="m" type="TextLineMetrics" line="1243"/>
                    <declaration name="low" type="boolean" line="1244"/>
                    <scope line="1246"/>
                    <scope line="1250"/>
                </scope>
                <scope line="1255">
                    <declaration name="thiscm" type="CoreMetrics" line="1256"/>
                    <scope line="1259">
                        <declaration name="m" type="TextLineMetrics" line="1261"/>
                        <scope line="1262">
                            <scope line="1264"/>
                            <scope line="1267"/>
                        </scope>
                        <scope line="1271"/>
                    </scope>
                    <scope line="1277">
                        <declaration name="bo" type="float" line="1278"/>
                        <scope line="1279"/>
                        <scope line="1285"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1303">
                Returns information about the caret corresponding to &lt;code&gt;hit&lt;/code&gt;.
                  This method is a convenience overload of &lt;code&gt;getCaretInfo&lt;/code&gt; and
                  uses the natural bounds of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    hit a hit on a character in this &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <return>
                    the information about a caret corresponding to a hit.  The
                      returned caret info is in baseline-relative coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretInfo" type="float[]" line="1311">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
            </method>
            <javadoc line="1316">
                Returns a caret index corresponding to &lt;code&gt;hit&lt;/code&gt;.
                  Carets are numbered from left to right (top to bottom) starting from
                  zero. This always places carets next to the character hit, on the
                  indicated side of the character.                
                <param>
                    hit a hit on a character in this &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <return>
                    a caret index corresponding to the specified hit.                    
                </return>
            </javadoc>
            <method name="hitToCaret" type="int" line="1324">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <declaration name="hitIndex" type="int" line="1326"/>
                <scope line="1328"/>
                <scope line="1330"/>
                <declaration name="visIndex" type="int" line="1334"/>
                <scope line="1336"/>
            </method>
            <javadoc line="1343">
                Given a caret index, return a hit whose caret is at the index.
                  The hit is NOT guaranteed to be strong!!!                
                <param>
                    caret a caret index.                    
                </param>
                <return>
                    a hit on this layout whose strong caret is at the requested
                      index.                    
                </return>
            </javadoc>
            <method name="caretToHit" type="TextHitInfo" line="1351">
                <params>
                    <param name="caret" type="int"/>
                </params>
                <scope line="1353">
                    <scope line="1355"/>
                    <scope line="1358"/>
                </scope>
                <scope line="1362">
                    <declaration name="charIndex" type="int" line="1364"/>
                    <declaration name="leading" type="boolean" line="1365"/>
                </scope>
            </method>
            <method name="caretIsValid" type="boolean" line="1372">
                <params>
                    <param name="caret" type="int"/>
                </params>
                <comment line="1388">
                    At this point, the leading edge of the character
                     at offset is at the given caret.                    
                </comment>
                <scope line="1374"/>
                <declaration name="offset" type="int" line="1378"/>
                <scope line="1380">
                    <scope line="1382"/>
                </scope>
            </method>
            <javadoc line="1393">
                Returns the hit for the next caret to the right (bottom); if there
                  is no such hit, returns &lt;code&gt;null&lt;/code&gt;.
                  If the hit character index is out of bounds, an{@link IllegalArgumentException} is thrown.                
                <param>
                    hit a hit on a character in this layout                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      right (bottom) of the caret of the provided hit or &lt;code&gt;null&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getNextRightHit" type="TextHitInfo" line="1402">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <declaration name="caret" type="int" line="1406"/>
                <scope line="1408"/>
                <scope line="1412"/>
            </method>
            <javadoc line="1419">
                Returns the hit for the next caret to the right (bottom); if no
                  such hit, returns &lt;code&gt;null&lt;/code&gt;.  The hit is to the right of
                  the strong caret at the specified offset, as determined by the
                  specified policy.
                  The returned hit is the stronger of the two possible
                  hits, as determined by the specified policy.                
                <param>
                    offset an insertion offset in this &lt;code&gt;TextLayout&lt;/code&gt;.
                      Cannot be less than 0 or greater than this &lt;code&gt;TextLayout&lt;/code&gt;
                      object&apos;s character count.                    
                </param>
                <param>
                    policy the policy used to select the strong caret                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      right (bottom) of the caret of the provided hit, or &lt;code&gt;null&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getNextRightHit" type="TextHitInfo" line="1433">
                <params>
                    <param name="offset" type="int"/>
                    <param name="policy" type="CaretPolicy"/>
                </params>
                <scope line="1435"/>
                <scope line="1439"/>
                <declaration name="hit1" type="TextHitInfo" line="1443"/>
                <declaration name="hit2" type="TextHitInfo" line="1444"/>
                <declaration name="nextHit" type="TextHitInfo" line="1446"/>
                <scope line="1448">
                    <declaration name="otherHit" type="TextHitInfo" line="1449"/>
                </scope>
                <scope line="1452"/>
            </method>
            <javadoc line="1457">
                Returns the hit for the next caret to the right (bottom); if no
                  such hit, returns &lt;code&gt;null&lt;/code&gt;.  The hit is to the right of
                  the strong caret at the specified offset, as determined by the
                  default policy.
                  The returned hit is the stronger of the two possible
                  hits, as determined by the default policy.                
                <param>
                    offset an insertion offset in this &lt;code&gt;TextLayout&lt;/code&gt;.
                      Cannot be less than 0 or greater than the &lt;code&gt;TextLayout&lt;/code&gt;
                      object&apos;s character count.                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      right (bottom) of the caret of the provided hit, or &lt;code&gt;null&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getNextRightHit" type="TextHitInfo" line="1470">
                <params>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="1475">
                Returns the hit for the next caret to the left (top); if no such
                  hit, returns &lt;code&gt;null&lt;/code&gt;.
                  If the hit character index is out of bounds, an
                  &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.                
                <param>
                    hit a hit on a character in this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      left (top) of the caret of the provided hit, or &lt;code&gt;null&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getNextLeftHit" type="TextHitInfo" line="1484">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <declaration name="caret" type="int" line="1488"/>
                <scope line="1490"/>
                <scope line="1494"/>
            </method>
            <javadoc line="1501">
                Returns the hit for the next caret to the left (top); if no
                  such hit, returns &lt;code&gt;null&lt;/code&gt;.  The hit is to the left of
                  the strong caret at the specified offset, as determined by the
                  specified policy.
                  The returned hit is the stronger of the two possible
                  hits, as determined by the specified policy.                
                <param>
                    offset an insertion offset in this &lt;code&gt;TextLayout&lt;/code&gt;.
                      Cannot be less than 0 or greater than this &lt;code&gt;TextLayout&lt;/code&gt;
                      object&apos;s character count.                    
                </param>
                <param>
                    policy the policy used to select the strong caret                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      left (top) of the caret of the provided hit, or &lt;code&gt;null&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getNextLeftHit" type="TextHitInfo" line="1515">
                <params>
                    <param name="offset" type="int"/>
                    <param name="policy" type="CaretPolicy"/>
                </params>
                <scope line="1517"/>
                <scope line="1521"/>
                <declaration name="hit1" type="TextHitInfo" line="1525"/>
                <declaration name="hit2" type="TextHitInfo" line="1526"/>
                <declaration name="nextHit" type="TextHitInfo" line="1528"/>
                <scope line="1530">
                    <declaration name="otherHit" type="TextHitInfo" line="1531"/>
                </scope>
                <scope line="1534"/>
            </method>
            <javadoc line="1539">
                Returns the hit for the next caret to the left (top); if no
                  such hit, returns &lt;code&gt;null&lt;/code&gt;.  The hit is to the left of
                  the strong caret at the specified offset, as determined by the
                  default policy.
                  The returned hit is the stronger of the two possible
                  hits, as determined by the default policy.                
                <param>
                    offset an insertion offset in this &lt;code&gt;TextLayout&lt;/code&gt;.
                      Cannot be less than 0 or greater than this &lt;code&gt;TextLayout&lt;/code&gt;
                      object&apos;s character count.                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      left (top) of the caret of the provided hit, or &lt;code&gt;null&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="getNextLeftHit" type="TextHitInfo" line="1552">
                <params>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="1557">
                Returns the hit on the opposite side of the specified hit&apos;s caret.                
                <param>
                    hit the specified hit                    
                </param>
                <return>
                    a hit that is on the opposite side of the specified hit&apos;s
                      caret.                    
                </return>
            </javadoc>
            <method name="getVisualOtherHit" type="TextHitInfo" line="1563">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <comment line="1587">
                    at left end                    
                </comment>
                <comment line="1591">
                    at right end                    
                </comment>
                <declaration name="hitCharIndex" type="int" line="1568"/>
                <declaration name="charIndex" type="int" line="1570"/>
                <declaration name="leading" type="boolean" line="1571"/>
                <scope line="1573">
                    <declaration name="visIndex" type="int" line="1575"/>
                    <scope line="1576"/>
                    <scope line="1579"/>
                    <scope line="1585"/>
                    <scope line="1589"/>
                </scope>
                <scope line="1594">
                    <declaration name="visIndex" type="int" line="1596"/>
                    <declaration name="movedToRight" type="boolean" line="1598"/>
                    <scope line="1599"/>
                    <scope line="1603"/>
                    <scope line="1608"/>
                    <scope line="1612"/>
                </scope>
            </method>
            <method name="getCaretPath" type="double[]" line="1623">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <declaration name="info" type="float[]" line="1624"/>
            </method>
            <javadoc line="1628">
                Return an array of four floats corresponding the endpoints of the caret
                  x0, y0, x1, y1.
                  This creates a line along the slope of the caret intersecting the
                  baseline at the caret
                  position, and extending from ascent above the baseline to descent below
                  it.                
            </javadoc>
            <method name="getCaretPath" type="double[]" line="1638">
                <params>
                    <param name="caret" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                    <param name="clipToBounds" type="boolean"/>
                </params>
                <comment line="1647">
                    values are there to make compiler happy                    
                </comment>
                <comment line="1670">
                    y0 &lt;= y1, always                    
                </comment>
                <comment line="1715">
                    x0 &lt;= x1, always                    
                </comment>
                <declaration name="info" type="float[]" line="1640"/>
                <declaration name="pos" type="double" line="1642"/>
                <declaration name="slope" type="double" line="1643"/>
                <declaration name="x0" type="double" line="1645"/>
                <declaration name="x2" type="double" line="1646"/>
                <declaration name="left" type="double" line="1648"/>
                <declaration name="right" type="double" line="1649"/>
                <declaration name="top" type="double" line="1650"/>
                <declaration name="bottom" type="double" line="1651"/>
                <declaration name="threePoints" type="boolean" line="1653"/>
                <scope line="1655">
                    <scope line="1657"/>
                    <scope line="1661"/>
                    <scope line="1671">
                        <scope line="1672">
                            <scope line="1673"/>
                            <scope line="1676">
                                <scope line="1681"/>
                            </scope>
                        </scope>
                        <scope line="1686">
                            <scope line="1687"/>
                            <scope line="1690"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1700">
                    <scope line="1702"/>
                    <scope line="1706"/>
                    <scope line="1716">
                        <scope line="1717">
                            <scope line="1718"/>
                            <scope line="1721">
                                <scope line="1726"/>
                            </scope>
                        </scope>
                        <scope line="1731">
                            <scope line="1732"/>
                            <scope line="1735"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="pathToShape" type="GeneralPath" line="1751">
                <params>
                    <param name="path" type="double[]"/>
                    <param name="close" type="boolean"/>
                    <param name="lp" type="LayoutPathImpl"/>
                </params>
                <declaration name="result" type="GeneralPath" line="1752"/>
                <scope line="1754"/>
                <scope line="1757"/>
                <scope line="1761"/>
            </method>
            <javadoc line="1767">
                Returns a {@link Shape} representing the caret at the specified
                  hit inside the specified bounds.                
                <param>
                    hit the hit at which to generate the caret                    
                </param>
                <param>
                    bounds the bounds of the &lt;code&gt;TextLayout&lt;/code&gt; to use
                      in generating the caret.  The bounds is in baseline-relative
                      coordinates.                    
                </param>
                <return>
                    a &lt;code&gt;Shape&lt;/code&gt; representing the caret.  The returned
                      shape is in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShape" type="Shape" line="1777">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <scope line="1781"/>
            </method>
            <javadoc line="1788">
                Returns a &lt;code&gt;Shape&lt;/code&gt; representing the caret at the specified
                  hit inside the natural bounds of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    hit the hit at which to generate the caret                    
                </param>
                <return>
                    a &lt;code&gt;Shape&lt;/code&gt; representing the caret.  The returned
                      shape is in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShape" type="Shape" line="1795">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
            </method>
            <javadoc line="1800">
                Return the &quot;stronger&quot; of the TextHitInfos.  The TextHitInfos
                  should be logical or visual counterparts.  They are not
                  checked for validity.                
            </javadoc>
            <method name="getStrongHit" type="TextHitInfo" line="1805">
                <params>
                    <param name="hit1" type="TextHitInfo"/>
                    <param name="hit2" type="TextHitInfo"/>
                </params>
                <comment line="1808">
                    right now we&apos;re using the following rule for strong hits:
                     A hit on a character with a lower level
                     is stronger than one on a character with a higher level.
                     If this rule ties, the hit on the leading edge of a character wins.
                     If THIS rule ties, hit1 wins.  Both rules shouldn&apos;t tie, unless the
                     infos aren&apos;t counterparts of some sort.                    
                </comment>
                <declaration name="hit1Level" type="byte" line="1814"/>
                <declaration name="hit2Level" type="byte" line="1815"/>
                <scope line="1817">
                    <scope line="1818"/>
                    <scope line="1821"/>
                </scope>
                <scope line="1825"/>
            </method>
            <javadoc line="1830">
                Returns the level of the character at &lt;code&gt;index&lt;/code&gt;.
                  Indices -1 and &lt;code&gt;characterCount&lt;/code&gt; are assigned the base
                  level of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    index the index of the character from which to get the level                    
                </param>
                <return>
                    the level of the character at the specified index.                    
                </return>
            </javadoc>
            <method name="getCharacterLevel" type="byte" line="1837">
                <params>
                    <param name="index" type="int"/>
                </params>
                <comment line="1840">
                    hmm, allow indices at endpoints?  For now, yes.                    
                </comment>
                <scope line="1840"/>
                <scope line="1845"/>
            </method>
            <javadoc line="1852">
                Returns two paths corresponding to the strong and weak caret.                
                <param>
                    offset an offset in this &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <param>
                    bounds the bounds to which to extend the carets.  The
                      bounds is in baseline-relative coordinates.                    
                </param>
                <param>
                    policy the specified &lt;code&gt;CaretPolicy&lt;/code&gt;                    
                </param>
                <return>
                    an array of two paths.  Element zero is the strong
                      caret.  If there are two carets, element one is the weak caret,
                      otherwise it is &lt;code&gt;null&lt;/code&gt;. The returned shapes
                      are in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShapes" type="Shape[]" line="1863">
                <params>
                    <param name="offset" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                    <param name="policy" type="CaretPolicy"/>
                </params>
                <comment line="1894">
                    more than one caret                    
                </comment>
                <comment line="1900">
                    then other is weak                    
                </comment>
                <scope line="1867"/>
                <scope line="1871"/>
                <scope line="1875"/>
                <declaration name="result" type="Shape[]" line="1879"/>
                <declaration name="hit" type="TextHitInfo" line="1881"/>
                <declaration name="hitCaret" type="int" line="1883"/>
                <declaration name="lp" type="LayoutPathImpl" line="1885"/>
                <declaration name="hitShape" type="Shape" line="1886"/>
                <declaration name="otherHit" type="TextHitInfo" line="1887"/>
                <declaration name="otherCaret" type="int" line="1888"/>
                <scope line="1890"/>
                <scope line="1893">
                    <declaration name="otherShape" type="Shape" line="1894"/>
                    <declaration name="strongHit" type="TextHitInfo" line="1896"/>
                    <declaration name="hitIsStrong" type="boolean" line="1897"/>
                    <scope line="1899"/>
                    <scope line="1903"/>
                </scope>
            </method>
            <javadoc line="1912">
                Returns two paths corresponding to the strong and weak caret.
                  This method is a convenience overload of &lt;code&gt;getCaretShapes&lt;/code&gt;
                  that uses the default caret policy.                
                <param>
                    offset an offset in this &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <param>
                    bounds the bounds to which to extend the carets.  This is
                      in baseline-relative coordinates.                    
                </param>
                <return>
                    two paths corresponding to the strong and weak caret as
                      defined by the &lt;code&gt;DEFAULT_CARET_POLICY&lt;/code&gt;.  These are
                      in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShapes" type="Shape[]" line="1923">
                <params>
                    <param name="offset" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <comment line="1925">
                    {sfb} parameter checking is done in overloaded version                    
                </comment>
            </method>
            <javadoc line="1928">
                Returns two paths corresponding to the strong and weak caret.
                  This method is a convenience overload of &lt;code&gt;getCaretShapes&lt;/code&gt;
                  that uses the default caret policy and this &lt;code&gt;TextLayout&lt;/code&gt;
                  object&apos;s natural bounds.                
                <param>
                    offset an offset in this &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <return>
                    two paths corresponding to the strong and weak caret as
                      defined by the &lt;code&gt;DEFAULT_CARET_POLICY&lt;/code&gt;.  These are
                      in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShapes" type="Shape[]" line="1938">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <comment line="1940">
                    {sfb} parameter checking is done in overloaded version                    
                </comment>
            </method>
            <method name="boundingShape" type="GeneralPath" line="1946">
                <params>
                    <param name="path0" type="double[]"/>
                    <param name="path1" type="double[]"/>
                </params>
                <comment line="1949">
                    Really, we want the path to be a convex hull around all of the
                     points in path0 and path1.  But we can get by with less than
                     that.  We do need to prevent the two segments which
                     join path0 to path1 from crossing each other.  So, if we
                     traverse path0 from top to bottom, we&apos;ll traverse path1 from
                     bottom to top (and vice versa).                    
                </comment>
                <declaration name="result" type="GeneralPath" line="1955"/>
                <declaration name="sameDirection" type="boolean" line="1957"/>
                <scope line="1959"/>
                <scope line="1963"/>
                <declaration name="start" type="int" line="1968"/>
                <declaration name="limit" type="int" line="1969"/>
                <declaration name="increment" type="int" line="1970"/>
                <scope line="1972"/>
                <scope line="1977"/>
                <scope line="1983"/>
            </method>
            <method name="caretBoundingShape" type="GeneralPath" line="1996">
                <params>
                    <param name="caret0" type="int"/>
                    <param name="caret1" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <scope line="1998">
                    <declaration name="temp" type="int" line="1999"/>
                </scope>
            </method>
            <method name="leftShape" type="GeneralPath" line="2013">
                <params>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <declaration name="path0" type="double[]" line="2015"/>
                <scope line="2016"/>
                <scope line="2020"/>
                <declaration name="path1" type="double[]" line="2026"/>
            </method>
            <method name="rightShape" type="GeneralPath" line="2035">
                <params>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <declaration name="path1" type="double[]" line="2036"/>
                <scope line="2037"/>
                <scope line="2044"/>
                <declaration name="path0" type="double[]" line="2053"/>
            </method>
            <javadoc line="2058">
                Returns the logical ranges of text corresponding to a visual selection.                
                <param>
                    firstEndpoint an endpoint of the visual range                    
                </param>
                <param>
                    secondEndpoint the other endpoint of the visual range.
                      This endpoint can be less than &lt;code&gt;firstEndpoint&lt;/code&gt;.                    
                </param>
                <return>
                    an array of integers representing start/limit pairs for the
                      selected ranges.                    
                </return>
                <see>
                    #getVisualHighlightShape(TextHitInfo,TextHitInfo,Rectangle2D)                    
                </see>
            </javadoc>
            <method name="getLogicalRangesForVisualSelection" type="int[]" line="2068">
                <params>
                    <param name="firstEndpoint" type="TextHitInfo"/>
                    <param name="secondEndpoint" type="TextHitInfo"/>
                </params>
                <comment line="2075">
                    !!! probably want to optimize for all LTR text                    
                </comment>
                <comment line="2088">
                    now we have the visual indexes of the glyphs at the start and limit
                     of the selection range walk through runs marking characters that
                     were included in the visual range there is probably a more efficient
                     way to do this, but this ought to work, so hey                    
                </comment>
                <comment line="2103">
                    count how many runs we have, ought to be one or two, but perhaps
                     things are especially weird                    
                </comment>
                <declaration name="included" type="boolean[]" line="2076"/>
                <declaration name="startIndex" type="int" line="2078"/>
                <declaration name="limitIndex" type="int" line="2079"/>
                <scope line="2081">
                    <declaration name="t" type="int" line="2082"/>
                </scope>
                <scope line="2094">
                    <declaration name="visIndex" type="int" line="2095"/>
                    <scope line="2096"/>
                </scope>
                <declaration name="count" type="int" line="2106"/>
                <declaration name="inrun" type="boolean" line="2107"/>
                <scope line="2108">
                    <scope line="2109">
                        <scope line="2111"/>
                    </scope>
                </scope>
                <declaration name="ranges" type="int[]" line="2117"/>
                <scope line="2120">
                    <scope line="2121"/>
                </scope>
                <scope line="2126"/>
            </method>
            <javadoc line="2133">
                Returns a path enclosing the visual selection in the specified range,
                  extended to &lt;code&gt;bounds&lt;/code&gt;.
                  &lt;p&gt;
                  If the selection includes the leftmost (topmost) position, the selection
                  is extended to the left (top) of &lt;code&gt;bounds&lt;/code&gt;.  If the
                  selection includes the rightmost (bottommost) position, the selection
                  is extended to the right (bottom) of the bounds.  The height
                  (width on vertical lines) of the selection is always extended to
                  &lt;code&gt;bounds&lt;/code&gt;.
                  &lt;p&gt;
                  Although the selection is always contiguous, the logically selected
                  text can be discontiguous on lines with mixed-direction text.  The
                  logical ranges of text selected can be retrieved using
                  &lt;code&gt;getLogicalRangesForVisualSelection&lt;/code&gt;.  For example,
                  consider the text &apos;ABCdef&apos; where capital letters indicate
                  right-to-left text, rendered on a right-to-left line, with a visual
                  selection from 0L (the leading edge of &apos;A&apos;) to 3T (the trailing edge
                  of &apos;d&apos;).  The text appears as follows, with bold underlined areas
                  representing the selection:
                  &lt;br&gt;&lt;pre&gt;
                  d&lt;u&gt;&lt;b&gt;efCBA  &lt;/b&gt;&lt;/u&gt;
                  &lt;/pre&gt;
                  The logical selection ranges are 0-3, 4-6 (ABC, ef) because the
                  visually contiguous text is logically discontiguous.  Also note that
                  since the rightmost position on the layout (to the right of &apos;A&apos;) is
                  selected, the selection is extended to the right of the bounds.                
                <param>
                    firstEndpoint one end of the visual selection                    
                </param>
                <param>
                    secondEndpoint the other end of the visual selection                    
                </param>
                <param>
                    bounds the bounding rectangle to which to extend the selection.
                      This is in baseline-relative coordinates.                    
                </param>
                <return>
                    a &lt;code&gt;Shape&lt;/code&gt; enclosing the selection.  This is in
                      standard coordinates.                    
                </return>
                <see>
                    #getLogicalRangesForVisualSelection(TextHitInfo,TextHitInfo)                    
                </see>
                <see>
                    #getLogicalHighlightShape(int,int,Rectangle2D)                    
                </see>
            </javadoc>
            <method name="getVisualHighlightShape" type="Shape" line="2172">
                <params>
                    <param name="firstEndpoint" type="TextHitInfo"/>
                    <param name="secondEndpoint" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <comment line="2206">
                    dlf cast safe?                    
                </comment>
                <scope line="2178"/>
                <declaration name="result" type="GeneralPath" line="2182"/>
                <declaration name="firstCaret" type="int" line="2184"/>
                <declaration name="secondCaret" type="int" line="2185"/>
                <scope line="2190">
                    <declaration name="ls" type="GeneralPath" line="2191"/>
                </scope>
                <scope line="2196">
                    <declaration name="rs" type="GeneralPath" line="2197"/>
                    <scope line="2198"/>
                </scope>
                <declaration name="lp" type="LayoutPathImpl" line="2203"/>
                <scope line="2204"/>
            </method>
            <javadoc line="2211">
                Returns a &lt;code&gt;Shape&lt;/code&gt; enclosing the visual selection in the
                  specified range, extended to the bounds.  This method is a
                  convenience overload of &lt;code&gt;getVisualHighlightShape&lt;/code&gt; that
                  uses the natural bounds of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    firstEndpoint one end of the visual selection                    
                </param>
                <param>
                    secondEndpoint the other end of the visual selection                    
                </param>
                <return>
                    a &lt;code&gt;Shape&lt;/code&gt; enclosing the selection.  This is
                      in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getVisualHighlightShape" type="Shape" line="2222">
                <params>
                    <param name="firstEndpoint" type="TextHitInfo"/>
                    <param name="secondEndpoint" type="TextHitInfo"/>
                </params>
            </method>
            <javadoc line="2226">
                Returns a &lt;code&gt;Shape&lt;/code&gt; enclosing the logical selection in the
                  specified range, extended to the specified &lt;code&gt;bounds&lt;/code&gt;.
                  &lt;p&gt;
                  If the selection range includes the first logical character, the
                  selection is extended to the portion of &lt;code&gt;bounds&lt;/code&gt; before
                  the start of this &lt;code&gt;TextLayout&lt;/code&gt;.  If the range includes
                  the last logical character, the selection is extended to the portion
                  of &lt;code&gt;bounds&lt;/code&gt; after the end of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The height (width on vertical lines) of the selection is always
                  extended to &lt;code&gt;bounds&lt;/code&gt;.
                  &lt;p&gt;
                  The selection can be discontiguous on lines with mixed-direction text.
                  Only those characters in the logical range between start and limit
                  appear selected.  For example, consider the text &apos;ABCdef&apos; where capital
                  letters indicate right-to-left text, rendered on a right-to-left line,
                  with a logical selection from 0 to 4 (&apos;ABCd&apos;).  The text appears as
                  follows, with bold standing in for the selection, and underlining for
                  the extension:
                  &lt;br&gt;&lt;pre&gt;
                  &lt;u&gt;&lt;b&gt;d&lt;/b&gt;&lt;/u&gt;ef&lt;u&gt;&lt;b&gt;CBA  &lt;/b&gt;&lt;/u&gt;
                  &lt;/pre&gt;
                  The selection is discontiguous because the selected characters are
                  visually discontiguous. Also note that since the range includes the
                  first logical character (A), the selection is extended to the portion
                  of the &lt;code&gt;bounds&lt;/code&gt; before the start of the layout, which in
                  this case (a right-to-left line) is the right portion of the
                  &lt;code&gt;bounds&lt;/code&gt;.                
                <param>
                    firstEndpoint an endpoint in the range of characters to select                    
                </param>
                <param>
                    secondEndpoint the other endpoint of the range of characters
                      to select. Can be less than &lt;code&gt;firstEndpoint&lt;/code&gt;.  The range
                      includes the character at min(firstEndpoint, secondEndpoint), but
                      excludes max(firstEndpoint, secondEndpoint).                    
                </param>
                <param>
                    bounds the bounding rectangle to which to extend the selection.
                      This is in baseline-relative coordinates.                    
                </param>
                <return>
                    an area enclosing the selection.  This is in standard
                      coordinates.                    
                </return>
                <see>
                    #getVisualHighlightShape(TextHitInfo,TextHitInfo,Rectangle2D)                    
                </see>
            </javadoc>
            <method name="getLogicalHighlightShape" type="Shape" line="2267">
                <params>
                    <param name="firstEndpoint" type="int"/>
                    <param name="secondEndpoint" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <comment line="2287">
                    would this ever not handle all cases?                    
                </comment>
                <comment line="2315">
                    now create paths for pairs of carets                    
                </comment>
                <comment line="2343">
                    dlf cast safe?                    
                </comment>
                <scope line="2268"/>
                <scope line="2274">
                    <declaration name="t" type="int" line="2275"/>
                </scope>
                <scope line="2280"/>
                <declaration name="result" type="GeneralPath" line="2284"/>
                <declaration name="carets" type="int[]" line="2286"/>
                <declaration name="count" type="int" line="2287"/>
                <scope line="2289">
                    <declaration name="logIndex" type="int" line="2290"/>
                    <scope line="2291">
                        <declaration name="ltr" type="boolean" line="2293"/>
                        <scope line="2295"/>
                        <declaration name="hitCh" type="int" line="2299"/>
                        <scope line="2302">
                            <declaration name="temp" type="int[]" line="2303"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2309"/>
                <scope line="2316"/>
                <scope line="2321">
                    <scope line="2323">
                        <declaration name="ls" type="GeneralPath" line="2324"/>
                        <scope line="2325"/>
                    </scope>
                    <scope line="2331">
                        <declaration name="rs" type="GeneralPath" line="2333"/>
                        <scope line="2334"/>
                    </scope>
                </scope>
                <declaration name="lp" type="LayoutPathImpl" line="2340"/>
                <scope line="2341"/>
            </method>
            <javadoc line="2347">
                Returns a &lt;code&gt;Shape&lt;/code&gt; enclosing the logical selection in the
                  specified range, extended to the natural bounds of this
                  &lt;code&gt;TextLayout&lt;/code&gt;.  This method is a convenience overload of
                  &lt;code&gt;getLogicalHighlightShape&lt;/code&gt; that uses the natural bounds of
                  this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    firstEndpoint an endpoint in the range of characters to select                    
                </param>
                <param>
                    secondEndpoint the other endpoint of the range of characters
                      to select. Can be less than &lt;code&gt;firstEndpoint&lt;/code&gt;.  The range
                      includes the character at min(firstEndpoint, secondEndpoint), but
                      excludes max(firstEndpoint, secondEndpoint).                    
                </param>
                <return>
                    a &lt;code&gt;Shape&lt;/code&gt; enclosing the selection.  This is in
                      standard coordinates.                    
                </return>
            </javadoc>
            <method name="getLogicalHighlightShape" type="Shape" line="2361">
                <params>
                    <param name="firstEndpoint" type="int"/>
                    <param name="secondEndpoint" type="int"/>
                </params>
            </method>
            <javadoc line="2366">
                Returns the black box bounds of the characters in the specified range.
                  The black box bounds is an area consisting of the union of the bounding
                  boxes of all the glyphs corresponding to the characters between start
                  and limit.  This area can be disjoint.                
                <param>
                    firstEndpoint one end of the character range                    
                </param>
                <param>
                    secondEndpoint the other end of the character range.  Can be
                      less than &lt;code&gt;firstEndpoint&lt;/code&gt;.                    
                </param>
                <return>
                    a &lt;code&gt;Shape&lt;/code&gt; enclosing the black box bounds.  This is
                      in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getBlackBoxBounds" type="Shape" line="2377">
                <params>
                    <param name="firstEndpoint" type="int"/>
                    <param name="secondEndpoint" type="int"/>
                </params>
                <comment line="2391">
                    return an area that consists of the bounding boxes of all the
                     characters from firstEndpoint to limit                    
                </comment>
                <comment line="2419">
                    return new Highlight(result, false);                    
                </comment>
                <scope line="2380">
                    <declaration name="t" type="int" line="2381"/>
                </scope>
                <scope line="2386"/>
                <declaration name="result" type="GeneralPath" line="2395"/>
                <scope line="2397">
                    <scope line="2400">
                        <declaration name="r" type="Rectangle2D" line="2402"/>
                        <scope line="2403"/>
                    </scope>
                </scope>
                <scope line="2409">
                    <declaration name="tx" type="AffineTransform" line="2410"/>
                </scope>
                <declaration name="lp" type="LayoutPathImpl" line="2413"/>
                <scope line="2414"/>
            </method>
            <javadoc line="2422">
                Returns the distance from the point (x,&amp;nbsp;y) to the caret along
                  the line direction defined in &lt;code&gt;caretInfo&lt;/code&gt;.  Distance is
                  negative if the point is to the left of the caret on a horizontal
                  line, or above the caret on a vertical line.
                  Utility for use by hitTestChar.                
            </javadoc>
            <method name="caretToPointDistance" type="float" line="2429">
                <params>
                    <param name="caretInfo" type="float[]"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <comment line="2431">
                    distanceOffBaseline is negative if you&apos;re &apos;above&apos; baseline                    
                </comment>
                <declaration name="lineDistance" type="float" line="2432"/>
                <declaration name="distanceOffBaseline" type="float" line="2433"/>
            </method>
            <javadoc line="2439">
                Returns a &lt;code&gt;TextHitInfo&lt;/code&gt; corresponding to the
                  specified point.
                  Coordinates outside the bounds of the &lt;code&gt;TextLayout&lt;/code&gt;
                  map to hits on the leading edge of the first logical character,
                  or the trailing edge of the last logical character, as appropriate,
                  regardless of the position of that character in the line.  Only the
                  direction along the baseline is used to make this evaluation.                
                <param>
                    x the x offset from the origin of this
                      &lt;code&gt;TextLayout&lt;/code&gt;.  This is in standard coordinates.                    
                </param>
                <param>
                    y the y offset from the origin of this
                      &lt;code&gt;TextLayout&lt;/code&gt;.  This is in standard coordinates.                    
                </param>
                <param>
                    bounds the bounds of the &lt;code&gt;TextLayout&lt;/code&gt;.  This
                      is in baseline-relative coordinates.                    
                </param>
                <return>
                    a hit describing the character and edge (leading or trailing)
                      under the specified point.                    
                </return>
            </javadoc>
            <method name="hitTestChar" type="TextHitInfo" line="2456">
                <params>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <comment line="2458">
                    check boundary conditions                    
                </comment>
                <comment line="2483">
                    revised hit test
                     the original seems too complex and fails miserably with italic offsets
                     the natural tendency is to move towards the character you want to hit
                     so we&apos;ll just measure distance to the center of each character&apos;s visual
                     bounds, pick the closest one, then see which side of the character&apos;s
                     center line (italic) the point is on.
                     this tends to make it easier to hit narrow characters, which can be a
                     bit odd if you&apos;re visually over an adjacent wide character. this makes
                     a difference with bidi, so perhaps i need to revisit this yet again.                    
                </comment>
                <comment line="2509">
                    just work around baseline mess for now                    
                </comment>
                <comment line="2527">
                    proximity in x (along baseline) is two times as important as proximity in y                    
                </comment>
                <declaration name="lp" type="LayoutPathImpl" line="2459"/>
                <declaration name="prev" type="boolean" line="2460"/>
                <scope line="2461">
                    <declaration name="pt" type="Point2D.Float" line="2462"/>
                </scope>
                <scope line="2468">
                    <scope line="2469"/>
                    <scope line="2471"/>
                </scope>
                <scope line="2474">
                    <scope line="2475"/>
                    <scope line="2477"/>
                </scope>
                <declaration name="distance" type="double" line="2492"/>
                <declaration name="index" type="int" line="2493"/>
                <declaration name="trail" type="int" line="2494"/>
                <declaration name="lcm" type="CoreMetrics" line="2495"/>
                <declaration name="icx" type="float" line="2496"/>
                <scope line="2498">
                    <scope line="2499"/>
                    <scope line="2502"/>
                    <declaration name="cm" type="CoreMetrics" line="2505"/>
                    <scope line="2506">
                        <scope line="2509"/>
                        <scope line="2511"/>
                        <scope line="2513"/>
                        <declaration name="dy" type="float" line="2516"/>
                    </scope>
                    <declaration name="cx" type="float" line="2521"/>
                    <declaration name="ca" type="float" line="2522"/>
                    <declaration name="dx" type="float" line="2523"/>
                    <declaration name="nd" type="double" line="2527"/>
                    <scope line="2528"/>
                </scope>
                <declaration name="left" type="boolean" line="2535"/>
                <declaration name="leading" type="boolean" line="2536"/>
                <scope line="2537"/>
                <declaration name="result" type="TextHitInfo" line="2540"/>
            </method>
            <javadoc line="2545">
                Returns a &lt;code&gt;TextHitInfo&lt;/code&gt; corresponding to the
                  specified point.  This method is a convenience overload of
                  &lt;code&gt;hitTestChar&lt;/code&gt; that uses the natural bounds of this
                  &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    x the x offset from the origin of this
                      &lt;code&gt;TextLayout&lt;/code&gt;.  This is in standard coordinates.                    
                </param>
                <param>
                    y the y offset from the origin of this
                      &lt;code&gt;TextLayout&lt;/code&gt;.  This is in standard coordinates.                    
                </param>
                <return>
                    a hit describing the character and edge (leading or trailing)
                      under the specified point.                    
                </return>
            </javadoc>
            <method name="hitTestChar" type="TextHitInfo" line="2557">
                <params>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
            </method>
            <javadoc line="2562">
                Returns the hash code of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <return>
                    the hash code of this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="2566">
                <scope line="2567"/>
            </method>
            <javadoc line="2574">
                Returns &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;Object&lt;/code&gt; is a
                  &lt;code&gt;TextLayout&lt;/code&gt; object and if the specified &lt;code&gt;Object&lt;/code&gt;
                  equals this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    obj an &lt;code&gt;Object&lt;/code&gt; to test for equality                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;Object&lt;/code&gt;
                      equals this &lt;code&gt;TextLayout&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt;
                      otherwise.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="2583">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="2587">
                Returns &lt;code&gt;true&lt;/code&gt; if the two layouts are equal.
                  Two layouts are equal if they contain equal glyphvectors in the same order.                
                <param>
                    rhs the &lt;code&gt;TextLayout&lt;/code&gt; to compare to this
                      &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;TextLayout&lt;/code&gt;
                      equals this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="2596">
                <params>
                    <param name="rhs" type="TextLayout"/>
                </params>
                <scope line="2598"/>
                <scope line="2601"/>
            </method>
            <javadoc line="2609">
                Returns debugging information for this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <return>
                    the &lt;code&gt;textLine&lt;/code&gt; of this &lt;code&gt;TextLayout&lt;/code&gt;
                      as a &lt;code&gt;String&lt;/code&gt;.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="2614"/>
            <javadoc line="2619">
                Renders this &lt;code&gt;TextLayout&lt;/code&gt; at the specified location in
                  the specified {@link java.awt.Graphics2D Graphics2D} context.
                  The origin of the layout is placed at x,&amp;nbsp;y.  Rendering may touch
                  any point within &lt;code&gt;getBounds()&lt;/code&gt; of this position.  This
                  leaves the &lt;code&gt;g2&lt;/code&gt; unchanged.  Text is rendered along the
                  baseline path.                
                <param>
                    g2 the &lt;code&gt;Graphics2D&lt;/code&gt; context into which to render
                      the layout                    
                </param>
                <param>
                    x the X coordinate of the origin of this &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <param>
                    y the Y coordinate of the origin of this &lt;code&gt;TextLayout&lt;/code&gt;                    
                </param>
                <see>
                    #getBounds()                    
                </see>
            </javadoc>
            <method name="draw" type="void" line="2632">
                <params>
                    <param name="g2" type="Graphics2D"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <scope line="2634"/>
            </method>
            <javadoc line="2641">
                Package-only method for testing ONLY.  Please don&apos;t abuse.                
            </javadoc>
            <method name="getTextLineForTesting" type="TextLine" line="2644"/>
            <javadoc line="2649">
                Return the index of the first character with a different baseline from the
                  character at start, or limit if all characters between start and limit have
                  the same baseline.                
            </javadoc>
            <method name="sameBaselineUpTo" type="int" line="2656">
                <params>
                    <param name="font" type="Font"/>
                    <param name="text" type="char[]"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
                <comment line="2658">
                    current implementation doesn&apos;t support multiple baselines                    
                </comment>
                <comment line="2660">
                    byte bl = font.getBaselineFor(text[start++]);
                    while (start &lt; limit &amp;&amp; font.getBaselineFor(text[start]) == bl) {
                    ++start;
                    }
                    return start;                    
                </comment>
            </method>
            <method name="getBaselineFromGraphic" type="byte" line="2668">
                <params>
                    <param name="graphic" type="GraphicAttribute"/>
                </params>
                <declaration name="alignment" type="byte" line="2670"/>
                <scope line="2673"/>
                <scope line="2677"/>
            </method>
            <javadoc line="2682">
                Returns a &lt;code&gt;Shape&lt;/code&gt; representing the outline of this
                  &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    tx an optional {@link AffineTransform} to apply to the
                      outline of this &lt;code&gt;TextLayout&lt;/code&gt;.                    
                </param>
                <return>
                    a &lt;code&gt;Shape&lt;/code&gt; that is the outline of this
                      &lt;code&gt;TextLayout&lt;/code&gt;.  This is in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getOutline" type="Shape" line="2690">
                <params>
                    <param name="tx" type="AffineTransform"/>
                </params>
                <declaration name="result" type="Shape" line="2692"/>
                <declaration name="lp" type="LayoutPathImpl" line="2693"/>
                <scope line="2694"/>
            </method>
            <javadoc line="2700">
                Return the LayoutPath, or null if the layout path is the
                  default path (x maps to advance, y maps to offset).                
                <return>
                    the layout path                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getLayoutPath" type="LayoutPath" line="2706"/>
            <javadoc line="2710">
                Convert a hit to a point in standard coordinates.  The point is
                  on the baseline of the character at the leading or trailing
                  edge of the character, as appropriate.  If the path is
                  broken at the side of the character represented by the hit, the
                  point will be adjacent to the character.                
                <param>
                    hit the hit to check.  This must be a valid hit on
                      the TextLayout.                    
                </param>
                <param>
                    point the returned point. The point is in standard
                      coordinates.                    
                </param>
                <throws>
                    IllegalArgumentException if the hit is not valid for the
                      TextLayout.                    
                </throws>
                <throws>
                    NullPointerException if hit or point is null.                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="hitToPoint" type="void" line="2725">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="point" type="Point2D"/>
                </params>
                <scope line="2726"/>
                <declaration name="adv" type="float" line="2733"/>
                <declaration name="off" type="float" line="2734"/>
                <declaration name="ix" type="int" line="2736"/>
                <declaration name="leading" type="boolean" line="2737"/>
                <declaration name="ltr" type="boolean" line="2738"/>
                <scope line="2739"/>
                <scope line="2742"/>
                <declaration name="lp" type="LayoutPath" line="2748"/>
                <scope line="2749"/>
            </method>
        </class>
    </source>