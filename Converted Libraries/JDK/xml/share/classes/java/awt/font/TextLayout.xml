<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt.font">
        <import package="java.awt.Color"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.Graphics2D"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Shape"/>
        <import package="java.awt.font.NumericShaper"/>
        <import package="java.awt.font.TextLine.TextLineMetrics"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.geom.GeneralPath"/>
        <import package="java.awt.geom.NoninvertibleTransformException"/>
        <import package="java.awt.geom.Point2D"/>
        <import package="java.awt.geom.Rectangle2D"/>
        <import package="java.text.AttributedString"/>
        <import package="java.text.AttributedCharacterIterator"/>
        <import package="java.text.AttributedCharacterIterator.Attribute"/>
        <import package="java.util.Map"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Hashtable"/>
        <import package="sun.font.AttributeValues"/>
        <import package="sun.font.CoreMetrics"/>
        <import package="sun.font.Decoration"/>
        <import package="sun.font.FontLineMetrics"/>
        <import package="sun.font.FontResolver"/>
        <import package="sun.font.GraphicComponent"/>
        <import package="sun.font.LayoutPathImpl"/>
        <import package="sun.text.CodePointIterator"/>
        <class name="TextLayout" line="28">
            <implements interface="Cloneable"/>
            <javadoc line="28">
                &lt;code&gt;TextLayout&lt;/code&gt; is an immutable graphical representation of styled
                  character data.
                  &lt;p&gt;
                  It provides the following capabilities:
                  &lt;ul&gt;
                  &lt;li&gt;implicit bidirectional analysis and reordering,
                  &lt;li&gt;cursor positioning and movement, including split cursors for
                  mixed directional text,
                  &lt;li&gt;highlighting, including both logical and visual highlighting
                  for mixed directional text,
                  &lt;li&gt;multiple baselines (roman, hanging, and centered),
                  &lt;li&gt;hit testing,
                  &lt;li&gt;justification,
                  &lt;li&gt;default font substitution,
                  &lt;li&gt;metric information such as ascent, descent, and advance, and
                  &lt;li&gt;rendering
                  &lt;/ul&gt;
                  &lt;p&gt;
                  A &lt;code&gt;TextLayout&lt;/code&gt; object can be rendered using
                  its &lt;code&gt;draw&lt;/code&gt; method.
                  &lt;p&gt;
                  &lt;code&gt;TextLayout&lt;/code&gt; can be constructed either directly or through
                  the use of a {@link LineBreakMeasurer}.  When constructed directly, the
                  source text represents a single paragraph.  &lt;code&gt;LineBreakMeasurer&lt;/code&gt;
                  allows styled text to be broken into lines that fit within a particular
                  width.  See the &lt;code&gt;LineBreakMeasurer&lt;/code&gt; documentation for more
                  information.
                  &lt;p&gt;
                  &lt;code&gt;TextLayout&lt;/code&gt; construction logically proceeds as follows:
                  &lt;ul&gt;
                  &lt;li&gt;paragraph attributes are extracted and examined,
                  &lt;li&gt;text is analyzed for bidirectional reordering, and reordering
                  information is computed if needed,
                  &lt;li&gt;text is segmented into style runs
                  &lt;li&gt;fonts are chosen for style runs, first by using a font if the
                  attribute {@link TextAttribute#FONT} is present, otherwise by computing
                  a default font using the attributes that have been defined
                  &lt;li&gt;if text is on multiple baselines, the runs or subruns are further
                  broken into subruns sharing a common baseline,
                  &lt;li&gt;glyphvectors are generated for each run using the chosen font,
                  &lt;li&gt;final bidirectional reordering is performed on the glyphvectors
                  &lt;/ul&gt;
                  &lt;p&gt;
                  All graphical information returned from a &lt;code&gt;TextLayout&lt;/code&gt;
                  object&apos;s methods is relative to the origin of the
                  &lt;code&gt;TextLayout&lt;/code&gt;, which is the intersection of the
                  &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s baseline with its left edge.  Also,
                  coordinates passed into a &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s methods
                  are assumed to be relative to the &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s
                  origin.  Clients usually need to translate between a
                  &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s coordinate system and the coordinate
                  system in another object (such as a{@link java.awt.Graphics Graphics} object).
                  &lt;p&gt;
                  &lt;code&gt;TextLayout&lt;/code&gt; objects are constructed from styled text,
                  but they do not retain a reference to their source text.  Thus,
                  changes in the text previously used to generate a &lt;code&gt;TextLayout&lt;/code&gt;
                  do not affect the &lt;code&gt;TextLayout&lt;/code&gt;.
                  &lt;p&gt;
                  Three methods on a &lt;code&gt;TextLayout&lt;/code&gt; object
                  (&lt;code&gt;getNextRightHit&lt;/code&gt;, &lt;code&gt;getNextLeftHit&lt;/code&gt;, and
                  &lt;code&gt;hitTestChar&lt;/code&gt;) return instances of {@link TextHitInfo}.
                  The offsets contained in these &lt;code&gt;TextHitInfo&lt;/code&gt; objects
                  are relative to the start of the &lt;code&gt;TextLayout&lt;/code&gt;, &lt;b&gt;not&lt;/b&gt;
                  to the text used to create the &lt;code&gt;TextLayout&lt;/code&gt;.  Similarly,
                  &lt;code&gt;TextLayout&lt;/code&gt; methods that accept &lt;code&gt;TextHitInfo&lt;/code&gt;
                  instances as parameters expect the &lt;code&gt;TextHitInfo&lt;/code&gt; object&apos;s
                  offsets to be relative to the &lt;code&gt;TextLayout&lt;/code&gt;, not to any
                  underlying text storage model.
                  &lt;p&gt;
                  &lt;strong&gt;Examples&lt;/strong&gt;:&lt;p&gt;
                  Constructing and drawing a &lt;code&gt;TextLayout&lt;/code&gt; and its bounding
                  rectangle:
                  &lt;blockquote&gt;&lt;pre&gt;
                  Graphics2D g = ...;
                  Point2D loc = ...;
                  Font font = Font.getFont(&quot;Helvetica-bold-italic&quot;);
                  FontRenderContext frc = g.getFontRenderContext();
                  TextLayout layout = new TextLayout(&quot;This is a string&quot;, font, frc);
                  layout.draw(g, (float)loc.getX(), (float)loc.getY());
                  Rectangle2D bounds = layout.getBounds();
                  bounds.setRect(bounds.getX()+loc.getX(),
                  bounds.getY()+loc.getY(),
                  bounds.getWidth(),
                  bounds.getHeight());
                  g.draw(bounds);
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  Hit-testing a &lt;code&gt;TextLayout&lt;/code&gt; (determining which character is at
                  a particular graphical location):
                  &lt;blockquote&gt;&lt;pre&gt;
                  Point2D click = ...;
                  TextHitInfo hit = layout.hitTestChar(
                  (float) (click.getX() - loc.getX()),
                  (float) (click.getY() - loc.getY()));
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  Responding to a right-arrow key press:
                  &lt;blockquote&gt;&lt;pre&gt;
                  int insertionIndex = ...;
                  TextHitInfo next = layout.getNextRightHit(insertionIndex);
                  if (next != null) {
                  // translate graphics to origin of layout on screen
                  g.translate(loc.getX(), loc.getY());
                  Shape[] carets = layout.getCaretShapes(next.getInsertionIndex());
                  g.draw(carets[0]);
                  if (carets[1] != null) {
                  g.draw(carets[1]);
                  }
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  Drawing a selection range corresponding to a substring in the source text.
                  The selected area may not be visually contiguous:
                  &lt;blockquote&gt;&lt;pre&gt;
                  // selStart, selLimit should be relative to the layout,
                  // not to the source text
                  int selStart = ..., selLimit = ...;
                  Color selectionColor = ...;
                  Shape selection = layout.getLogicalHighlightShape(selStart, selLimit);
                  // selection may consist of disjoint areas
                  // graphics is assumed to be tranlated to origin of layout
                  g.setColor(selectionColor);
                  g.fill(selection);
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  Drawing a visually contiguous selection range.  The selection range may
                  correspond to more than one substring in the source text.  The ranges of
                  the corresponding source text substrings can be obtained with
                  &lt;code&gt;getLogicalRangesForVisualSelection()&lt;/code&gt;:
                  &lt;blockquote&gt;&lt;pre&gt;
                  TextHitInfo selStart = ..., selLimit = ...;
                  Shape selection = layout.getVisualHighlightShape(selStart, selLimit);
                  g.setColor(selectionColor);
                  g.fill(selection);
                  int[] ranges = getLogicalRangesForVisualSelection(selStart, selLimit);
                  // ranges[0], ranges[1] is the first selection range,
                  // ranges[2], ranges[3] is the second selection range, etc.
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  Note: Font rotations can cause text baselines to be rotated, and
                  multiple runs with different rotations can cause the baseline to
                  bend or zig-zag.  In order to account for this (rare) possibility,
                  some APIs are specified to return metrics and take parameters &apos;in
                  baseline-relative coordinates&apos; (e.g. ascent, advance), and others
                  are in &apos;in standard coordinates&apos; (e.g. getBounds).  Values in
                  baseline-relative coordinates map the &apos;x&apos; coordinate to the
                  distance along the baseline, (positive x is forward along the
                  baseline), and the &apos;y&apos; coordinate to a distance along the
                  perpendicular to the baseline at &apos;x&apos; (postitive y is 90 degrees
                  clockwise from the baseline vector).  Values in standard
                  coordinates are measured along the x and y axes, with 0,0 at the
                  origin of the TextLayout.  Documentation for each relevant API
                  indicates what values are in what coordinate system.  In general,
                  measurement-related APIs are in baseline-relative coordinates,
                  while display-related APIs are in standard coordinates.                
                <see>
                    LineBreakMeasurer                    
                </see>
                <see>
                    TextAttribute                    
                </see>
                <see>
                    TextHitInfo                    
                </see>
                <see>
                    LayoutPath                    
                </see>
            </javadoc>
            <declaration name="characterCount" type="int" line="192"/>
            <declaration name="isVerticalLine" type="boolean" line="193"/>
            <declaration name="baseline" type="byte" line="194"/>
            <declaration name="baselineOffsets" type="float[]" line="195"/>
            <declaration name="textLine" type="TextLine" line="196"/>
            <declaration name="lineMetrics" type="TextLine.TextLineMetrics" line="197"/>
            <declaration name="visibleAdvance" type="float" line="198"/>
            <declaration name="hashCodeCache" type="int" line="199"/>
            <declaration name="cacheIsValid" type="boolean" line="200"/>
            <declaration name="justifyRatio" type="float" line="201"/>
            <declaration name="ALREADY_JUSTIFIED" type="float" line="202"/>
            <declaration name="dx" type="float" line="203"/>
            <declaration name="dy" type="float" line="204"/>
            <declaration name="naturalBounds" type="Rectangle2D" line="205"/>
            <declaration name="boundsRect" type="Rectangle2D" line="206"/>
            <declaration name="caretsInLigaturesAreAllowed" type="boolean" line="207"/>
            <class name="CaretPolicy" line="208">
                <javadoc line="208">
                    Defines a policy for determining the strong caret location.
                      This class contains one method, &lt;code&gt;getStrongCaret&lt;/code&gt;, which
                      is used to specify the policy that determines the strong caret in
                      dual-caret text.  The strong caret is used to move the caret to the
                      left or right. Instances of this class can be passed to
                      &lt;code&gt;getCaretShapes&lt;/code&gt;, &lt;code&gt;getNextLeftHit&lt;/code&gt; and
                      &lt;code&gt;getNextRightHit&lt;/code&gt; to customize strong caret
                      selection.
                      &lt;p&gt;
                      To specify alternate caret policies, subclass &lt;code&gt;CaretPolicy&lt;/code&gt;
                      and override &lt;code&gt;getStrongCaret&lt;/code&gt;.  &lt;code&gt;getStrongCaret&lt;/code&gt;
                      should inspect the two &lt;code&gt;TextHitInfo&lt;/code&gt; arguments and choose
                      one of them as the strong caret.
                      &lt;p&gt;
                      Most clients do not need to use this class.                    
                </javadoc>
                <javadoc line="226">
                    Constructs a &lt;code&gt;CaretPolicy&lt;/code&gt;.                    
                </javadoc>
                <method name="CaretPolicy" type="constructor" line="229"/>
                <javadoc line="231">
                    Chooses one of the specified &lt;code&gt;TextHitInfo&lt;/code&gt; instances as
                      a strong caret in the specified &lt;code&gt;TextLayout&lt;/code&gt;.                    
                    <param>
                        hit1 a valid hit in <code>layout</code>                        
                    </param>
                    <param>
                        hit2 a valid hit in <code>layout</code>                        
                    </param>
                    <param>
                        layout the <code>TextLayout</code> in which
                          <code>hit1</code> and <code>hit2</code> are used                        
                    </param>
                    <return>
                        <code>hit1</code> or <code>hit2</code>
                          (or an equivalent <code>TextHitInfo</code>), indicating the
                          strong caret.                        
                    </return>
                </javadoc>
                <method name="getStrongCaret" type="TextHitInfo" line="242">
                    <params>
                        <param name="hit1" type="TextHitInfo"/>
                        <param name="hit2" type="TextHitInfo"/>
                        <param name="layout" type="TextLayout"/>
                    </params>
                </method>
            </class>
            <declaration name="DEFAULT_CARET_POLICY" type="CaretPolicy" line="246"/>
            <javadoc line="246">
                This &lt;code&gt;CaretPolicy&lt;/code&gt; is used when a policy is not specified
                  by the client.  With this policy, a hit on a character whose direction
                  is the same as the line direction is stronger than a hit on a
                  counterdirectional character.  If the characters&apos; directions are
                  the same, a hit on the leading edge of a character is stronger
                  than a hit on the trailing edge of a character.                
            </javadoc>
            <javadoc line="255">
                Constructs a &lt;code&gt;TextLayout&lt;/code&gt; from a &lt;code&gt;String&lt;/code&gt;
                  and a {@link Font}.  All the text is styled using the specified
                  &lt;code&gt;Font&lt;/code&gt;.
                  &lt;p&gt;
                  The &lt;code&gt;String&lt;/code&gt; must specify a single paragraph of text,
                  because an entire paragraph is required for the bidirectional
                  algorithm.                
                <param>
                    string the text to display                    
                </param>
                <param>
                    font a <code>Font</code> used to style the text                    
                </param>
                <param>
                    frc contains information about a graphics device which is needed
                      to measure the text correctly.
                      Text measurements can vary slightly depending on the
                      device resolution, and attributes such as antialiasing.  This
                      parameter does not specify a translation between the
                      <code>TextLayout</code> and user space.                    
                </param>
            </javadoc>
            <method name="TextLayout" type="constructor" line="272">
                <params>
                    <param name="string" type="String"/>
                    <param name="font" type="Font"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <scope line="273"/>
                <scope line="276"/>
                <scope line="279"/>
                <declaration name="attributes" type="Map" line="282"/>
                <scope line="283"/>
                <declaration name="text" type="char[]" line="286"/>
                <scope line="287"/>
                <scope line="290">
                    <declaration name="as" type="AttributedString" line="291"/>
                </scope>
            </method>
            <javadoc line="296">
                Constructs a &lt;code&gt;TextLayout&lt;/code&gt; from a &lt;code&gt;String&lt;/code&gt;
                  and an attribute set.
                  &lt;p&gt;
                  All the text is styled using the provided attributes.
                  &lt;p&gt;
                  &lt;code&gt;string&lt;/code&gt; must specify a single paragraph of text because an
                  entire paragraph is required for the bidirectional algorithm.                
                <param>
                    string the text to display                    
                </param>
                <param>
                    attributes the attributes used to style the text                    
                </param>
                <param>
                    frc contains information about a graphics device which is needed
                      to measure the text correctly.
                      Text measurements can vary slightly depending on the
                      device resolution, and attributes such as antialiasing.  This
                      parameter does not specify a translation between the
                      <code>TextLayout</code> and user space.                    
                </param>
            </javadoc>
            <method name="TextLayout" type="constructor" line="313">
                <params>
                    <param name="string" type="String"/>
                    <param name="attributes" type="Map<? extends Attribute,?>"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <scope line="314"/>
                <scope line="317"/>
                <scope line="320"/>
                <declaration name="text" type="char[]" line="323"/>
                <declaration name="font" type="Font" line="324"/>
                <scope line="325"/>
                <scope line="328">
                    <declaration name="as" type="AttributedString" line="329"/>
                </scope>
            </method>
            <method name="singleFont" type="Font" line="333">
                <params>
                    <param name="text" type="char[]"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                    <param name="attributes" type="Map"/>
                </params>
                <scope line="334"/>
                <declaration name="font" type="Font" line="337"/>
                <scope line="338"/>
                <scope line="341"/>
                <scope line="343">
                    <scope line="344">
                        <scope line="346"/>
                    </scope>
                    <scope line="350">
                        <declaration name="resolver" type="FontResolver" line="351"/>
                        <declaration name="iter" type="CodePointIterator" line="352"/>
                        <declaration name="fontIndex" type="int" line="353"/>
                        <scope line="354"/>
                    </scope>
                </scope>
                <scope line="359"/>
            </method>
            <javadoc line="364">
                Constructs a &lt;code&gt;TextLayout&lt;/code&gt; from an iterator over styled text.
                  &lt;p&gt;
                  The iterator must specify a single paragraph of text because an
                  entire paragraph is required for the bidirectional
                  algorithm.                
                <param>
                    text the styled text to display                    
                </param>
                <param>
                    frc contains information about a graphics device which is needed
                      to measure the text correctly.
                      Text measurements can vary slightly depending on the
                      device resolution, and attributes such as antialiasing.  This
                      parameter does not specify a translation between the
                      <code>TextLayout</code> and user space.                    
                </param>
            </javadoc>
            <method name="TextLayout" type="constructor" line="378">
                <params>
                    <param name="text" type="AttributedCharacterIterator"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <scope line="379"/>
                <declaration name="start" type="int" line="382"/>
                <declaration name="limit" type="int" line="383"/>
                <scope line="384"/>
                <declaration name="len" type="int" line="387"/>
                <declaration name="chars" type="char[]" line="389"/>
                <declaration name="n" type="int" line="390"/>
                <scope line="391"/>
                <scope line="395">
                    <declaration name="attributes" type="Map" line="396"/>
                    <declaration name="font" type="Font" line="397"/>
                    <scope line="398"/>
                </scope>
            </method>
            <javadoc line="405">
                Creates a &lt;code&gt;TextLayout&lt;/code&gt; from a {@link TextLine} and
                  some paragraph data.  This method is used by {@link TextMeasurer}.                
                <param>
                    textLine the line measurement attributes to apply to the
                      the resulting <code>TextLayout</code>                    
                </param>
                <param>
                    baseline the baseline of the text                    
                </param>
                <param>
                    baselineOffsets the baseline offsets for this
                      <code>TextLayout</code>.  This should already be normalized to
                      <code>baseline</code>                    
                </param>
                <param>
                    justifyRatio <code>0</code> if the <code>TextLayout</code>
                      cannot be justified; <code>1</code> otherwise.                    
                </param>
            </javadoc>
            <method name="TextLayout" type="constructor" line="417">
                <params>
                    <param name="textLine" type="TextLine"/>
                    <param name="baseline" type="byte"/>
                    <param name="baselineOffsets" type="float[]"/>
                    <param name="justifyRatio" type="float"/>
                </params>
            </method>
            <javadoc line="424">
                Initialize the paragraph-specific data.                
            </javadoc>
            <method name="paragraphInit" type="void" line="427">
                <params>
                    <param name="aBaseline" type="byte"/>
                    <param name="lm" type="CoreMetrics"/>
                    <param name="paragraphAttrs" type="Map"/>
                    <param name="text" type="char[]"/>
                </params>
                <declaration name="shaper" type="NumericShaper" line="431"/>
                <scope line="432"/>
            </method>
            <method name="fastInit" type="void" line="436">
                <params>
                    <param name="chars" type="char[]"/>
                    <param name="font" type="Font"/>
                    <param name="attrs" type="Map"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <declaration name="lm" type="LineMetrics" line="438"/>
                <declaration name="cm" type="CoreMetrics" line="439"/>
                <declaration name="glyphBaseline" type="byte" line="440"/>
                <scope line="441"/>
                <scope line="446"/>
            </method>
            <method name="standardInit" type="void" line="452">
                <params>
                    <param name="text" type="AttributedCharacterIterator"/>
                    <param name="chars" type="char[]"/>
                    <param name="frc" type="FontRenderContext"/>
                </params>
                <scope line="454">
                    <declaration name="paragraphAttrs" type="Map" line="455"/>
                    <declaration name="haveFont" type="boolean" line="456"/>
                    <scope line="457">
                        <declaration name="defaultFont" type="Font" line="458"/>
                        <declaration name="charsStart" type="int" line="459"/>
                        <declaration name="lm" type="LineMetrics" line="460"/>
                        <declaration name="cm" type="CoreMetrics" line="461"/>
                    </scope>
                    <scope line="464">
                        <declaration name="graphic" type="GraphicAttribute" line="465"/>
                        <declaration name="defaultBaseline" type="byte" line="466"/>
                        <declaration name="cm" type="CoreMetrics" line="467"/>
                    </scope>
                </scope>
            </method>
            <method name="ensureCache" type="void" line="473">
                <scope line="474"/>
            </method>
            <method name="buildCache" type="void" line="478">
                <scope line="480">
                    <declaration name="lastNonSpace" type="int" line="481"/>
                    <scope line="482">
                        <declaration name="logIndex" type="int" line="483"/>
                        <scope line="484"/>
                        <scope line="487"/>
                    </scope>
                    <scope line="491"/>
                    <scope line="494"/>
                    <scope line="497">
                        <declaration name="logIndex" type="int" line="498"/>
                    </scope>
                </scope>
                <scope line="502">
                    <declaration name="leftmostNonSpace" type="int" line="503"/>
                    <scope line="504">
                        <declaration name="logIndex" type="int" line="505"/>
                        <scope line="506"/>
                        <scope line="509"/>
                    </scope>
                    <scope line="513"/>
                    <scope line="516"/>
                    <scope line="519">
                        <declaration name="logIndex" type="int" line="520"/>
                        <declaration name="pos" type="float" line="521"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="530">
                The &apos;natural bounds&apos; encloses all the carets the layout can draw.                
            </javadoc>
            <method name="getNaturalBounds" type="Rectangle2D" line="533">
                <scope line="535"/>
            </method>
            <javadoc line="540">
                Creates a copy of this &lt;code&gt;TextLayout&lt;/code&gt;.                
            </javadoc>
            <method name="clone" type="Object" line="543">
                <scope line="544"/>
                <scope line="547"/>
            </method>
            <method name="checkTextHit" type="void" line="551">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <scope line="552"/>
                <scope line="555"/>
            </method>
            <javadoc line="559">
                Creates a copy of this &lt;code&gt;TextLayout&lt;/code&gt; justified to the
                  specified width.
                  &lt;p&gt;
                  If this &lt;code&gt;TextLayout&lt;/code&gt; has already been justified, an
                  exception is thrown.  If this &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s
                  justification ratio is zero, a &lt;code&gt;TextLayout&lt;/code&gt; identical
                  to this &lt;code&gt;TextLayout&lt;/code&gt; is returned.                
                <param>
                    justificationWidth the width to use when justifying the line.
                      For best results, it should not be too different from the current
                      advance of the line.                    
                </param>
                <return>
                    a <code>TextLayout</code> justified to the specified width.                    
                </return>
                <exception>
                    Error if this layout has already been justified, an Error is
                      thrown.                    
                </exception>
            </javadoc>
            <method name="getJustifiedLayout" type="TextLayout" line="574">
                <params>
                    <param name="justificationWidth" type="float"/>
                </params>
                <scope line="575"/>
                <scope line="578"/>
                <declaration name="limit" type="int" line="582"/>
                <scope line="583"/>
                <declaration name="newLine" type="TextLine" line="586"/>
                <scope line="587"/>
            </method>
            <javadoc line="592">
                Justify this layout.  Overridden by subclassers to control justification
                  (if there were subclassers, that is...)
                  The layout will only justify if the paragraph attributes (from the
                  source text, possibly defaulted by the layout attributes) indicate a
                  non-zero justification ratio.  The text will be justified to the
                  indicated width.  The current implementation also adjusts hanging
                  punctuation and trailing whitespace to overhang the justification width.
                  Once justified, the layout may not be rejustified.
                  &lt;p&gt;
                  Some code may rely on immutablity of layouts.  Subclassers should not
                  call this directly, but instead should call getJustifiedLayout, which
                  will call this method on a clone of this layout, preserving
                  the original.                
                <param>
                    justificationWidth the width to use when justifying the line.
                      For best results, it should not be too different from the current
                      advance of the line.                    
                </param>
                <see>
                    #getJustifiedLayout(float)                    
                </see>
            </javadoc>
            <method name="handleJustify" type="void" line="611">
                <params>
                    <param name="justificationWidth" type="float"/>
                </params>
            </method>
            <javadoc line="613">
                Returns the baseline for this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The baseline is one of the values defined in &lt;code&gt;Font&lt;/code&gt;,
                  which are roman, centered and hanging.  Ascent and descent are
                  relative to this baseline.  The &lt;code&gt;baselineOffsets&lt;/code&gt;
                  are also relative to this baseline.                
                <return>
                    the baseline of this <code>TextLayout</code>.                    
                </return>
                <see>
                    #getBaselineOffsets()                    
                </see>
                <see>
                    Font                    
                </see>
            </javadoc>
            <method name="getBaseline" type="byte" line="623"/>
            <javadoc line="626">
                Returns the offsets array for the baselines used for this
                  &lt;code&gt;TextLayout&lt;/code&gt;.
                  &lt;p&gt;
                  The array is indexed by one of the values defined in
                  &lt;code&gt;Font&lt;/code&gt;, which are roman, centered and hanging.  The
                  values are relative to this &lt;code&gt;TextLayout&lt;/code&gt; object&apos;s
                  baseline, so that &lt;code&gt;getBaselineOffsets[getBaseline()] == 0&lt;/code&gt;.
                  Offsets are added to the position of the &lt;code&gt;TextLayout&lt;/code&gt;
                  object&apos;s baseline to get the position for the new baseline.                
                <return>
                    the offsets array containing the baselines used for this
                      <code>TextLayout</code>.                    
                </return>
                <see>
                    #getBaseline()                    
                </see>
                <see>
                    Font                    
                </see>
            </javadoc>
            <method name="getBaselineOffsets" type="float[]" line="641">
                <declaration name="offsets" type="float[]" line="642"/>
            </method>
            <javadoc line="646">
                Returns the advance of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The advance is the distance from the origin to the advance of the
                  rightmost (bottommost) character.  This is in baseline-relative
                  coordinates.                
                <return>
                    the advance of this <code>TextLayout</code>.                    
                </return>
            </javadoc>
            <method name="getAdvance" type="float" line="653"/>
            <javadoc line="657">
                Returns the advance of this &lt;code&gt;TextLayout&lt;/code&gt;, minus trailing
                  whitespace.  This is in baseline-relative coordinates.                
                <return>
                    the advance of this <code>TextLayout</code> without the
                      trailing whitespace.                    
                </return>
                <see>
                    #getAdvance()                    
                </see>
            </javadoc>
            <method name="getVisibleAdvance" type="float" line="664"/>
            <javadoc line="668">
                Returns the ascent of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The ascent is the distance from the top (right) of the
                  &lt;code&gt;TextLayout&lt;/code&gt; to the baseline.  It is always either
                  positive or zero.  The ascent is sufficient to
                  accomodate superscripted text and is the maximum of the sum of the
                  ascent, offset, and baseline of each glyph.  The ascent is
                  the maximum ascent from the baseline of all the text in the
                  TextLayout.  It is in baseline-relative coordinates.                
                <return>
                    the ascent of this <code>TextLayout</code>.                    
                </return>
            </javadoc>
            <method name="getAscent" type="float" line="679"/>
            <javadoc line="683">
                Returns the descent of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The descent is the distance from the baseline to the bottom (left) of
                  the &lt;code&gt;TextLayout&lt;/code&gt;.  It is always either positive or zero.
                  The descent is sufficient to accomodate subscripted text and is the
                  maximum of the sum of the descent, offset, and baseline of each glyph.
                  This is the maximum descent from the baseline of all the text in
                  the TextLayout.  It is in baseline-relative coordinates.                
                <return>
                    the descent of this <code>TextLayout</code>.                    
                </return>
            </javadoc>
            <method name="getDescent" type="float" line="693"/>
            <javadoc line="697">
                Returns the leading of the &lt;code&gt;TextLayout&lt;/code&gt;.
                  The leading is the suggested interline spacing for this
                  &lt;code&gt;TextLayout&lt;/code&gt;.  This is in baseline-relative
                  coordinates.
                  &lt;p&gt;
                  The leading is computed from the leading, descent, and baseline
                  of all glyphvectors in the &lt;code&gt;TextLayout&lt;/code&gt;.  The algorithm
                  is roughly as follows:
                  &lt;blockquote&gt;&lt;pre&gt;
                  maxD = 0;
                  maxDL = 0;
                  for (GlyphVector g in all glyphvectors) {
                  maxD = max(maxD, g.getDescent() + offsets[g.getBaseline()]);
                  maxDL = max(maxDL, g.getDescent() + g.getLeading() +
                  offsets[g.getBaseline()]);
                  }
                  return maxDL - maxD;
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <return>
                    the leading of this <code>TextLayout</code>.                    
                </return>
            </javadoc>
            <method name="getLeading" type="float" line="718"/>
            <javadoc line="722">
                Returns the bounds of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The bounds are in standard coordinates.
                  &lt;p&gt;Due to rasterization effects, this bounds might not enclose all of the
                  pixels rendered by the TextLayout.&lt;/p&gt;
                  It might not coincide exactly with the ascent, descent,
                  origin or advance of the &lt;code&gt;TextLayout&lt;/code&gt;.                
                <return>
                    a {@link Rectangle2D} that is the bounds of this
                      <code>TextLayout</code>.                    
                </return>
            </javadoc>
            <method name="getBounds" type="Rectangle2D" line="732">
                <scope line="734">
                    <declaration name="vb" type="Rectangle2D" line="735"/>
                    <scope line="736"/>
                </scope>
                <declaration name="bounds" type="Rectangle2D" line="741"/>
            </method>
            <javadoc line="745">
                Returns the pixel bounds of this &lt;code&gt;TextLayout&lt;/code&gt; when
                  rendered in a graphics with the given
                  &lt;code&gt;FontRenderContext&lt;/code&gt; at the given location.  The
                  graphics render context need not be the same as the
                  &lt;code&gt;FontRenderContext&lt;/code&gt; used to create this
                  &lt;code&gt;TextLayout&lt;/code&gt;, and can be null.  If it is null, the
                  &lt;code&gt;FontRenderContext&lt;/code&gt; of this &lt;code&gt;TextLayout&lt;/code&gt;
                  is used.                
                <param>
                    frc the <code>FontRenderContext</code> of the <code>Graphics</code>.                    
                </param>
                <param>
                    x the x-coordinate at which to render this <code>TextLayout</code>.                    
                </param>
                <param>
                    y the y-coordinate at which to render this <code>TextLayout</code>.                    
                </param>
                <return>
                    a <code>Rectangle</code> bounding the pixels that would be affected.                    
                </return>
                <see>
                    GlyphVector#getPixelBounds                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getPixelBounds" type="Rectangle" line="761">
                <params>
                    <param name="frc" type="FontRenderContext"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
            </method>
            <javadoc line="764">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;TextLayout&lt;/code&gt; has
                  a left-to-right base direction or &lt;code&gt;false&lt;/code&gt; if it has
                  a right-to-left base direction.  The &lt;code&gt;TextLayout&lt;/code&gt;
                  has a base direction of either left-to-right (LTR) or
                  right-to-left (RTL).  The base direction is independent of the
                  actual direction of text on the line, which may be either LTR,
                  RTL, or mixed. Left-to-right layouts by default should position
                  flush left.  If the layout is on a tabbed line, the
                  tabs run left to right, so that logically successive layouts position
                  left to right.  The opposite is true for RTL layouts. By default they
                  should position flush left, and tabs run right-to-left.                
                <return>
                    <code>true</code> if the base direction of this
                      <code>TextLayout</code> is left-to-right; <code>false</code>
                      otherwise.                    
                </return>
            </javadoc>
            <method name="isLeftToRight" type="boolean" line="780"/>
            <javadoc line="783">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;TextLayout&lt;/code&gt; is vertical.                
                <return>
                    <code>true</code> if this <code>TextLayout</code> is vertical;
                      <code>false</code> otherwise.                    
                </return>
            </javadoc>
            <method name="isVertical" type="boolean" line="788"/>
            <javadoc line="791">
                Returns the number of characters represented by this
                  &lt;code&gt;TextLayout&lt;/code&gt;.                
                <return>
                    the number of characters in this <code>TextLayout</code>.                    
                </return>
            </javadoc>
            <method name="getCharacterCount" type="int" line="796"/>
            <method name="getCaretInfo" type="float[]" line="799">
                <params>
                    <param name="caret" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                    <param name="info" type="float[]"/>
                </params>
                <declaration name="top1X" type="float" line="800"/>
                <declaration name="bottom1X" type="float" line="801"/>
                <scope line="802">
                    <declaration name="pos" type="float" line="803"/>
                    <declaration name="logIndex" type="int" line="804"/>
                    <scope line="805"/>
                    <scope line="809"/>
                    <declaration name="angle" type="float" line="813"/>
                    <declaration name="shift" type="float" line="814"/>
                </scope>
                <scope line="819">
                    <scope line="820">
                        <declaration name="logIndex" type="int" line="821"/>
                        <declaration name="angle1" type="float" line="822"/>
                        <declaration name="pos1" type="float" line="823"/>
                        <scope line="824"/>
                        <scope line="829"/>
                    </scope>
                    <scope line="833">
                        <declaration name="logIndex" type="int" line="834"/>
                        <declaration name="angle2" type="float" line="835"/>
                        <declaration name="pos2" type="float" line="836"/>
                        <scope line="837"/>
                        <scope line="842"/>
                    </scope>
                </scope>
                <declaration name="topX" type="float" line="847"/>
                <declaration name="bottomX" type="float" line="848"/>
                <scope line="849"/>
                <scope line="852"/>
                <scope line="856"/>
            </method>
            <javadoc line="862">
                Returns information about the caret corresponding to &lt;code&gt;hit&lt;/code&gt;.
                  The first element of the array is the intersection of the caret with
                  the baseline, as a distance along the baseline. The second element
                  of the array is the inverse slope (run/rise) of the caret, measured
                  with respect to the baseline at that point.
                  &lt;p&gt;
                  This method is meant for informational use.  To display carets, it
                  is better to use &lt;code&gt;getCaretShapes&lt;/code&gt;.                
                <param>
                    hit a hit on a character in this <code>TextLayout</code>                    
                </param>
                <param>
                    bounds the bounds to which the caret info is constructed.
                      The bounds is in baseline-relative coordinates.                    
                </param>
                <return>
                    a two-element array containing the position and slope of
                      the caret.  The returned caret info is in baseline-relative coordinates.                    
                </return>
                <see>
                    #getCaretShapes(int,Rectangle2D,TextLayout.CaretPolicy)                    
                </see>
                <see>
                    Font#getItalicAngle                    
                </see>
            </javadoc>
            <method name="getCaretInfo" type="float[]" line="879">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
            </method>
            <method name="getCaretInfoTestInternal" type="float[]" line="884">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <declaration name="info" type="float[]" line="887"/>
                <declaration name="iangle" type="double" line="889"/>
                <declaration name="charix" type="int" line="890"/>
                <declaration name="lead" type="boolean" line="891"/>
                <declaration name="ltr" type="boolean" line="892"/>
                <declaration name="horiz" type="boolean" line="893"/>
                <scope line="894">
                    <declaration name="m" type="TextLineMetrics" line="895"/>
                    <declaration name="low" type="boolean" line="896"/>
                    <scope line="898"/>
                    <scope line="903"/>
                </scope>
                <scope line="909">
                    <declaration name="thiscm" type="CoreMetrics" line="910"/>
                    <scope line="913">
                        <declaration name="m" type="TextLineMetrics" line="914"/>
                        <scope line="915">
                            <scope line="917"/>
                            <scope line="921"/>
                        </scope>
                        <scope line="926"/>
                    </scope>
                    <scope line="932">
                        <declaration name="bo" type="float" line="933"/>
                        <scope line="934"/>
                        <scope line="941"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="956">
                Returns information about the caret corresponding to &lt;code&gt;hit&lt;/code&gt;.
                  This method is a convenience overload of &lt;code&gt;getCaretInfo&lt;/code&gt; and
                  uses the natural bounds of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    hit a hit on a character in this <code>TextLayout</code>                    
                </param>
                <return>
                    the information about a caret corresponding to a hit.  The
                      returned caret info is in baseline-relative coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretInfo" type="float[]" line="964">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
            </method>
            <javadoc line="967">
                Returns a caret index corresponding to &lt;code&gt;hit&lt;/code&gt;.
                  Carets are numbered from left to right (top to bottom) starting from
                  zero. This always places carets next to the character hit, on the
                  indicated side of the character.                
                <param>
                    hit a hit on a character in this <code>TextLayout</code>                    
                </param>
                <return>
                    a caret index corresponding to the specified hit.                    
                </return>
            </javadoc>
            <method name="hitToCaret" type="int" line="975">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <declaration name="hitIndex" type="int" line="976"/>
                <scope line="977"/>
                <scope line="980"/>
                <declaration name="visIndex" type="int" line="983"/>
                <scope line="984"/>
            </method>
            <javadoc line="989">
                Given a caret index, return a hit whose caret is at the index.
                  The hit is NOT guaranteed to be strong!!!                
                <param>
                    caret a caret index.                    
                </param>
                <return>
                    a hit on this layout whose strong caret is at the requested
                      index.                    
                </return>
            </javadoc>
            <method name="caretToHit" type="TextHitInfo" line="996">
                <params>
                    <param name="caret" type="int"/>
                </params>
                <scope line="997">
                    <scope line="998"/>
                    <scope line="1001"/>
                </scope>
                <scope line="1005">
                    <declaration name="charIndex" type="int" line="1006"/>
                    <declaration name="leading" type="boolean" line="1007"/>
                </scope>
            </method>
            <method name="caretIsValid" type="boolean" line="1011">
                <params>
                    <param name="caret" type="int"/>
                </params>
                <scope line="1012"/>
                <declaration name="offset" type="int" line="1015"/>
                <scope line="1016">
                    <scope line="1018"/>
                </scope>
            </method>
            <javadoc line="1024">
                Returns the hit for the next caret to the right (bottom); if there
                  is no such hit, returns &lt;code&gt;null&lt;/code&gt;.
                  If the hit character index is out of bounds, an{@link IllegalArgumentException} is thrown.                
                <param>
                    hit a hit on a character in this layout                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      right (bottom) of the caret of the provided hit or <code>null</code>.                    
                </return>
            </javadoc>
            <method name="getNextRightHit" type="TextHitInfo" line="1032">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <declaration name="caret" type="int" line="1035"/>
                <scope line="1036"/>
                <scope line="1039"/>
            </method>
            <javadoc line="1045">
                Returns the hit for the next caret to the right (bottom); if no
                  such hit, returns &lt;code&gt;null&lt;/code&gt;.  The hit is to the right of
                  the strong caret at the specified offset, as determined by the
                  specified policy.
                  The returned hit is the stronger of the two possible
                  hits, as determined by the specified policy.                
                <param>
                    offset an insertion offset in this <code>TextLayout</code>.
                      Cannot be less than 0 or greater than this <code>TextLayout</code>
                      object's character count.                    
                </param>
                <param>
                    policy the policy used to select the strong caret                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      right (bottom) of the caret of the provided hit, or <code>null</code>.                    
                </return>
            </javadoc>
            <method name="getNextRightHit" type="TextHitInfo" line="1059">
                <params>
                    <param name="offset" type="int"/>
                    <param name="policy" type="CaretPolicy"/>
                </params>
                <scope line="1060"/>
                <scope line="1063"/>
                <declaration name="hit1" type="TextHitInfo" line="1066"/>
                <declaration name="hit2" type="TextHitInfo" line="1067"/>
                <declaration name="nextHit" type="TextHitInfo" line="1068"/>
                <scope line="1069">
                    <declaration name="otherHit" type="TextHitInfo" line="1070"/>
                </scope>
                <scope line="1073"/>
            </method>
            <javadoc line="1077">
                Returns the hit for the next caret to the right (bottom); if no
                  such hit, returns &lt;code&gt;null&lt;/code&gt;.  The hit is to the right of
                  the strong caret at the specified offset, as determined by the
                  default policy.
                  The returned hit is the stronger of the two possible
                  hits, as determined by the default policy.                
                <param>
                    offset an insertion offset in this <code>TextLayout</code>.
                      Cannot be less than 0 or greater than the <code>TextLayout</code>
                      object's character count.                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      right (bottom) of the caret of the provided hit, or <code>null</code>.                    
                </return>
            </javadoc>
            <method name="getNextRightHit" type="TextHitInfo" line="1090">
                <params>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="1093">
                Returns the hit for the next caret to the left (top); if no such
                  hit, returns &lt;code&gt;null&lt;/code&gt;.
                  If the hit character index is out of bounds, an
                  &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.                
                <param>
                    hit a hit on a character in this <code>TextLayout</code>.                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      left (top) of the caret of the provided hit, or <code>null</code>.                    
                </return>
            </javadoc>
            <method name="getNextLeftHit" type="TextHitInfo" line="1102">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <declaration name="caret" type="int" line="1105"/>
                <scope line="1106"/>
                <scope line="1109"/>
            </method>
            <javadoc line="1115">
                Returns the hit for the next caret to the left (top); if no
                  such hit, returns &lt;code&gt;null&lt;/code&gt;.  The hit is to the left of
                  the strong caret at the specified offset, as determined by the
                  specified policy.
                  The returned hit is the stronger of the two possible
                  hits, as determined by the specified policy.                
                <param>
                    offset an insertion offset in this <code>TextLayout</code>.
                      Cannot be less than 0 or greater than this <code>TextLayout</code>
                      object's character count.                    
                </param>
                <param>
                    policy the policy used to select the strong caret                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      left (top) of the caret of the provided hit, or <code>null</code>.                    
                </return>
            </javadoc>
            <method name="getNextLeftHit" type="TextHitInfo" line="1129">
                <params>
                    <param name="offset" type="int"/>
                    <param name="policy" type="CaretPolicy"/>
                </params>
                <scope line="1130"/>
                <scope line="1133"/>
                <declaration name="hit1" type="TextHitInfo" line="1136"/>
                <declaration name="hit2" type="TextHitInfo" line="1137"/>
                <declaration name="nextHit" type="TextHitInfo" line="1138"/>
                <scope line="1139">
                    <declaration name="otherHit" type="TextHitInfo" line="1140"/>
                </scope>
                <scope line="1143"/>
            </method>
            <javadoc line="1147">
                Returns the hit for the next caret to the left (top); if no
                  such hit, returns &lt;code&gt;null&lt;/code&gt;.  The hit is to the left of
                  the strong caret at the specified offset, as determined by the
                  default policy.
                  The returned hit is the stronger of the two possible
                  hits, as determined by the default policy.                
                <param>
                    offset an insertion offset in this <code>TextLayout</code>.
                      Cannot be less than 0 or greater than this <code>TextLayout</code>
                      object's character count.                    
                </param>
                <return>
                    a hit whose caret appears at the next position to the
                      left (top) of the caret of the provided hit, or <code>null</code>.                    
                </return>
            </javadoc>
            <method name="getNextLeftHit" type="TextHitInfo" line="1160">
                <params>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <javadoc line="1163">
                Returns the hit on the opposite side of the specified hit&apos;s caret.                
                <param>
                    hit the specified hit                    
                </param>
                <return>
                    a hit that is on the opposite side of the specified hit's
                      caret.                    
                </return>
            </javadoc>
            <method name="getVisualOtherHit" type="TextHitInfo" line="1169">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
                <declaration name="hitCharIndex" type="int" line="1172"/>
                <declaration name="charIndex" type="int" line="1173"/>
                <declaration name="leading" type="boolean" line="1174"/>
                <scope line="1175">
                    <declaration name="visIndex" type="int" line="1176"/>
                    <scope line="1177"/>
                    <scope line="1180"/>
                    <scope line="1184"/>
                    <scope line="1187"/>
                </scope>
                <scope line="1191">
                    <declaration name="visIndex" type="int" line="1192"/>
                    <declaration name="movedToRight" type="boolean" line="1193"/>
                    <scope line="1194"/>
                    <scope line="1198"/>
                    <scope line="1202"/>
                    <scope line="1206"/>
                </scope>
            </method>
            <method name="getCaretPath" type="double[]" line="1213">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <declaration name="info" type="float[]" line="1214"/>
            </method>
            <javadoc line="1217">
                Return an array of four floats corresponding the endpoints of the caret
                  x0, y0, x1, y1.
                  This creates a line along the slope of the caret intersecting the
                  baseline at the caret
                  position, and extending from ascent above the baseline to descent below
                  it.                
            </javadoc>
            <method name="getCaretPath" type="double[]" line="1225">
                <params>
                    <param name="caret" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                    <param name="clipToBounds" type="boolean"/>
                </params>
                <declaration name="info" type="float[]" line="1226"/>
                <declaration name="pos" type="double" line="1227"/>
                <declaration name="slope" type="double" line="1228"/>
                <declaration name="x0" type="double" line="1229"/>
                <declaration name="x2" type="double" line="1230"/>
                <declaration name="left" type="double" line="1231"/>
                <declaration name="right" type="double" line="1232"/>
                <declaration name="top" type="double" line="1233"/>
                <declaration name="bottom" type="double" line="1234"/>
                <declaration name="threePoints" type="boolean" line="1235"/>
                <scope line="1236">
                    <scope line="1237"/>
                    <scope line="1241"/>
                    <scope line="1247">
                        <scope line="1248">
                            <scope line="1249"/>
                            <scope line="1252">
                                <scope line="1257"/>
                            </scope>
                        </scope>
                        <scope line="1262">
                            <scope line="1263"/>
                            <scope line="1266"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1275">
                    <scope line="1276"/>
                    <scope line="1280"/>
                    <scope line="1286">
                        <scope line="1287">
                            <scope line="1288"/>
                            <scope line="1291">
                                <scope line="1296"/>
                            </scope>
                        </scope>
                        <scope line="1301">
                            <scope line="1302"/>
                            <scope line="1305"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="pathToShape" type="GeneralPath" line="1316">
                <params>
                    <param name="path" type="double[]"/>
                    <param name="close" type="boolean"/>
                    <param name="lp" type="LayoutPathImpl"/>
                </params>
                <declaration name="result" type="GeneralPath" line="1317"/>
                <scope line="1319"/>
                <scope line="1322"/>
                <scope line="1325"/>
            </method>
            <javadoc line="1330">
                Returns a {@link Shape} representing the caret at the specified
                  hit inside the specified bounds.                
                <param>
                    hit the hit at which to generate the caret                    
                </param>
                <param>
                    bounds the bounds of the <code>TextLayout</code> to use
                      in generating the caret.  The bounds is in baseline-relative
                      coordinates.                    
                </param>
                <return>
                    a <code>Shape</code> representing the caret.  The returned
                      shape is in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShape" type="Shape" line="1340">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <scope line="1343"/>
            </method>
            <javadoc line="1348">
                Returns a &lt;code&gt;Shape&lt;/code&gt; representing the caret at the specified
                  hit inside the natural bounds of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    hit the hit at which to generate the caret                    
                </param>
                <return>
                    a <code>Shape</code> representing the caret.  The returned
                      shape is in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShape" type="Shape" line="1355">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                </params>
            </method>
            <javadoc line="1358">
                Return the &quot;stronger&quot; of the TextHitInfos.  The TextHitInfos
                  should be logical or visual counterparts.  They are not
                  checked for validity.                
            </javadoc>
            <method name="getStrongHit" type="TextHitInfo" line="1363">
                <params>
                    <param name="hit1" type="TextHitInfo"/>
                    <param name="hit2" type="TextHitInfo"/>
                </params>
                <declaration name="hit1Level" type="byte" line="1364"/>
                <declaration name="hit2Level" type="byte" line="1365"/>
                <scope line="1366">
                    <scope line="1367"/>
                    <scope line="1370"/>
                </scope>
                <scope line="1374"/>
            </method>
            <javadoc line="1378">
                Returns the level of the character at &lt;code&gt;index&lt;/code&gt;.
                  Indices -1 and &lt;code&gt;characterCount&lt;/code&gt; are assigned the base
                  level of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    index the index of the character from which to get the level                    
                </param>
                <return>
                    the level of the character at the specified index.                    
                </return>
            </javadoc>
            <method name="getCharacterLevel" type="byte" line="1385">
                <params>
                    <param name="index" type="int"/>
                </params>
                <scope line="1386"/>
                <scope line="1390"/>
            </method>
            <javadoc line="1395">
                Returns two paths corresponding to the strong and weak caret.                
                <param>
                    offset an offset in this <code>TextLayout</code>                    
                </param>
                <param>
                    bounds the bounds to which to extend the carets.  The
                      bounds is in baseline-relative coordinates.                    
                </param>
                <param>
                    policy the specified <code>CaretPolicy</code>                    
                </param>
                <return>
                    an array of two paths.  Element zero is the strong
                      caret.  If there are two carets, element one is the weak caret,
                      otherwise it is <code>null</code>. The returned shapes
                      are in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShapes" type="Shape[]" line="1406">
                <params>
                    <param name="offset" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                    <param name="policy" type="CaretPolicy"/>
                </params>
                <scope line="1408"/>
                <scope line="1411"/>
                <scope line="1414"/>
                <declaration name="result" type="Shape[]" line="1417"/>
                <declaration name="hit" type="TextHitInfo" line="1418"/>
                <declaration name="hitCaret" type="int" line="1419"/>
                <declaration name="lp" type="LayoutPathImpl" line="1420"/>
                <declaration name="hitShape" type="Shape" line="1421"/>
                <declaration name="otherHit" type="TextHitInfo" line="1422"/>
                <declaration name="otherCaret" type="int" line="1423"/>
                <scope line="1424"/>
                <scope line="1427">
                    <declaration name="otherShape" type="Shape" line="1428"/>
                    <declaration name="strongHit" type="TextHitInfo" line="1429"/>
                    <declaration name="hitIsStrong" type="boolean" line="1430"/>
                    <scope line="1431"/>
                    <scope line="1435"/>
                </scope>
            </method>
            <javadoc line="1442">
                Returns two paths corresponding to the strong and weak caret.
                  This method is a convenience overload of &lt;code&gt;getCaretShapes&lt;/code&gt;
                  that uses the default caret policy.                
                <param>
                    offset an offset in this <code>TextLayout</code>                    
                </param>
                <param>
                    bounds the bounds to which to extend the carets.  This is
                      in baseline-relative coordinates.                    
                </param>
                <return>
                    two paths corresponding to the strong and weak caret as
                      defined by the <code>DEFAULT_CARET_POLICY</code>.  These are
                      in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShapes" type="Shape[]" line="1453">
                <params>
                    <param name="offset" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
            </method>
            <javadoc line="1456">
                Returns two paths corresponding to the strong and weak caret.
                  This method is a convenience overload of &lt;code&gt;getCaretShapes&lt;/code&gt;
                  that uses the default caret policy and this &lt;code&gt;TextLayout&lt;/code&gt;
                  object&apos;s natural bounds.                
                <param>
                    offset an offset in this <code>TextLayout</code>                    
                </param>
                <return>
                    two paths corresponding to the strong and weak caret as
                      defined by the <code>DEFAULT_CARET_POLICY</code>.  These are
                      in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getCaretShapes" type="Shape[]" line="1466">
                <params>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <method name="boundingShape" type="GeneralPath" line="1469">
                <params>
                    <param name="path0" type="double[]"/>
                    <param name="path1" type="double[]"/>
                </params>
                <declaration name="result" type="GeneralPath" line="1470"/>
                <declaration name="sameDirection" type="boolean" line="1471"/>
                <scope line="1472"/>
                <scope line="1475"/>
                <declaration name="start" type="int" line="1478"/>
                <declaration name="limit" type="int" line="1479"/>
                <declaration name="increment" type="int" line="1480"/>
                <scope line="1481"/>
                <scope line="1486"/>
                <scope line="1491"/>
            </method>
            <method name="caretBoundingShape" type="GeneralPath" line="1497">
                <params>
                    <param name="caret0" type="int"/>
                    <param name="caret1" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <scope line="1498">
                    <declaration name="temp" type="int" line="1499"/>
                </scope>
            </method>
            <method name="leftShape" type="GeneralPath" line="1505">
                <params>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <declaration name="path0" type="double[]" line="1506"/>
                <scope line="1507"/>
                <scope line="1510"/>
                <declaration name="path1" type="double[]" line="1513"/>
            </method>
            <method name="rightShape" type="GeneralPath" line="1516">
                <params>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <declaration name="path1" type="double[]" line="1517"/>
                <scope line="1518"/>
                <scope line="1521"/>
                <declaration name="path0" type="double[]" line="1524"/>
            </method>
            <javadoc line="1527">
                Returns the logical ranges of text corresponding to a visual selection.                
                <param>
                    firstEndpoint an endpoint of the visual range                    
                </param>
                <param>
                    secondEndpoint the other endpoint of the visual range.
                      This endpoint can be less than <code>firstEndpoint</code>.                    
                </param>
                <return>
                    an array of integers representing start/limit pairs for the
                      selected ranges.                    
                </return>
                <see>
                    #getVisualHighlightShape(TextHitInfo,TextHitInfo,Rectangle2D)                    
                </see>
            </javadoc>
            <method name="getLogicalRangesForVisualSelection" type="int[]" line="1536">
                <params>
                    <param name="firstEndpoint" type="TextHitInfo"/>
                    <param name="secondEndpoint" type="TextHitInfo"/>
                </params>
                <declaration name="included" type="boolean[]" line="1540"/>
                <declaration name="startIndex" type="int" line="1541"/>
                <declaration name="limitIndex" type="int" line="1542"/>
                <scope line="1543">
                    <declaration name="t" type="int" line="1544"/>
                </scope>
                <scope line="1548">
                    <declaration name="visIndex" type="int" line="1549"/>
                    <scope line="1550"/>
                </scope>
                <declaration name="count" type="int" line="1555"/>
                <declaration name="inrun" type="boolean" line="1556"/>
                <scope line="1557">
                    <scope line="1558">
                        <scope line="1560"/>
                    </scope>
                </scope>
                <declaration name="ranges" type="int[]" line="1565"/>
                <scope line="1568">
                    <scope line="1569"/>
                </scope>
                <scope line="1574"/>
            </method>
            <javadoc line="1579">
                Returns a path enclosing the visual selection in the specified range,
                  extended to &lt;code&gt;bounds&lt;/code&gt;.
                  &lt;p&gt;
                  If the selection includes the leftmost (topmost) position, the selection
                  is extended to the left (top) of &lt;code&gt;bounds&lt;/code&gt;.  If the
                  selection includes the rightmost (bottommost) position, the selection
                  is extended to the right (bottom) of the bounds.  The height
                  (width on vertical lines) of the selection is always extended to
                  &lt;code&gt;bounds&lt;/code&gt;.
                  &lt;p&gt;
                  Although the selection is always contiguous, the logically selected
                  text can be discontiguous on lines with mixed-direction text.  The
                  logical ranges of text selected can be retrieved using
                  &lt;code&gt;getLogicalRangesForVisualSelection&lt;/code&gt;.  For example,
                  consider the text &apos;ABCdef&apos; where capital letters indicate
                  right-to-left text, rendered on a right-to-left line, with a visual
                  selection from 0L (the leading edge of &apos;A&apos;) to 3T (the trailing edge
                  of &apos;d&apos;).  The text appears as follows, with bold underlined areas
                  representing the selection:
                  &lt;br&gt;&lt;pre&gt;
                  d&lt;u&gt;&lt;b&gt;efCBA  &lt;/b&gt;&lt;/u&gt;
                  &lt;/pre&gt;
                  The logical selection ranges are 0-3, 4-6 (ABC, ef) because the
                  visually contiguous text is logically discontiguous.  Also note that
                  since the rightmost position on the layout (to the right of &apos;A&apos;) is
                  selected, the selection is extended to the right of the bounds.                
                <param>
                    firstEndpoint one end of the visual selection                    
                </param>
                <param>
                    secondEndpoint the other end of the visual selection                    
                </param>
                <param>
                    bounds the bounding rectangle to which to extend the selection.
                      This is in baseline-relative coordinates.                    
                </param>
                <return>
                    a <code>Shape</code> enclosing the selection.  This is in
                      standard coordinates.                    
                </return>
                <see>
                    #getLogicalRangesForVisualSelection(TextHitInfo,TextHitInfo)                    
                </see>
                <see>
                    #getLogicalHighlightShape(int,int,Rectangle2D)                    
                </see>
            </javadoc>
            <method name="getVisualHighlightShape" type="Shape" line="1615">
                <params>
                    <param name="firstEndpoint" type="TextHitInfo"/>
                    <param name="secondEndpoint" type="TextHitInfo"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <scope line="1619"/>
                <declaration name="result" type="GeneralPath" line="1622"/>
                <declaration name="firstCaret" type="int" line="1623"/>
                <declaration name="secondCaret" type="int" line="1624"/>
                <scope line="1626">
                    <declaration name="ls" type="GeneralPath" line="1627"/>
                </scope>
                <scope line="1630">
                    <declaration name="rs" type="GeneralPath" line="1631"/>
                    <scope line="1632"/>
                </scope>
                <declaration name="lp" type="LayoutPathImpl" line="1636"/>
                <scope line="1637"/>
            </method>
            <javadoc line="1642">
                Returns a &lt;code&gt;Shape&lt;/code&gt; enclosing the visual selection in the
                  specified range, extended to the bounds.  This method is a
                  convenience overload of &lt;code&gt;getVisualHighlightShape&lt;/code&gt; that
                  uses the natural bounds of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    firstEndpoint one end of the visual selection                    
                </param>
                <param>
                    secondEndpoint the other end of the visual selection                    
                </param>
                <return>
                    a <code>Shape</code> enclosing the selection.  This is
                      in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getVisualHighlightShape" type="Shape" line="1652">
                <params>
                    <param name="firstEndpoint" type="TextHitInfo"/>
                    <param name="secondEndpoint" type="TextHitInfo"/>
                </params>
            </method>
            <javadoc line="1655">
                Returns a &lt;code&gt;Shape&lt;/code&gt; enclosing the logical selection in the
                  specified range, extended to the specified &lt;code&gt;bounds&lt;/code&gt;.
                  &lt;p&gt;
                  If the selection range includes the first logical character, the
                  selection is extended to the portion of &lt;code&gt;bounds&lt;/code&gt; before
                  the start of this &lt;code&gt;TextLayout&lt;/code&gt;.  If the range includes
                  the last logical character, the selection is extended to the portion
                  of &lt;code&gt;bounds&lt;/code&gt; after the end of this &lt;code&gt;TextLayout&lt;/code&gt;.
                  The height (width on vertical lines) of the selection is always
                  extended to &lt;code&gt;bounds&lt;/code&gt;.
                  &lt;p&gt;
                  The selection can be discontiguous on lines with mixed-direction text.
                  Only those characters in the logical range between start and limit
                  appear selected.  For example, consider the text &apos;ABCdef&apos; where capital
                  letters indicate right-to-left text, rendered on a right-to-left line,
                  with a logical selection from 0 to 4 (&apos;ABCd&apos;).  The text appears as
                  follows, with bold standing in for the selection, and underlining for
                  the extension:
                  &lt;br&gt;&lt;pre&gt;
                  &lt;u&gt;&lt;b&gt;d&lt;/b&gt;&lt;/u&gt;ef&lt;u&gt;&lt;b&gt;CBA  &lt;/b&gt;&lt;/u&gt;
                  &lt;/pre&gt;
                  The selection is discontiguous because the selected characters are
                  visually discontiguous. Also note that since the range includes the
                  first logical character (A), the selection is extended to the portion
                  of the &lt;code&gt;bounds&lt;/code&gt; before the start of the layout, which in
                  this case (a right-to-left line) is the right portion of the
                  &lt;code&gt;bounds&lt;/code&gt;.                
                <param>
                    firstEndpoint an endpoint in the range of characters to select                    
                </param>
                <param>
                    secondEndpoint the other endpoint of the range of characters
                      to select. Can be less than <code>firstEndpoint</code>.  The range
                      includes the character at min(firstEndpoint, secondEndpoint), but
                      excludes max(firstEndpoint, secondEndpoint).                    
                </param>
                <param>
                    bounds the bounding rectangle to which to extend the selection.
                      This is in baseline-relative coordinates.                    
                </param>
                <return>
                    an area enclosing the selection.  This is in standard
                      coordinates.                    
                </return>
                <see>
                    #getVisualHighlightShape(TextHitInfo,TextHitInfo,Rectangle2D)                    
                </see>
            </javadoc>
            <method name="getLogicalHighlightShape" type="Shape" line="1694">
                <params>
                    <param name="firstEndpoint" type="int"/>
                    <param name="secondEndpoint" type="int"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <scope line="1695"/>
                <scope line="1699">
                    <declaration name="t" type="int" line="1700"/>
                </scope>
                <scope line="1704"/>
                <declaration name="result" type="GeneralPath" line="1707"/>
                <declaration name="carets" type="int[]" line="1708"/>
                <declaration name="count" type="int" line="1709"/>
                <scope line="1710">
                    <declaration name="logIndex" type="int" line="1711"/>
                    <scope line="1712">
                        <declaration name="ltr" type="boolean" line="1714"/>
                        <scope line="1715"/>
                        <declaration name="hitCh" type="int" line="1719"/>
                        <scope line="1721">
                            <declaration name="temp" type="int[]" line="1722"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1729"/>
                <scope line="1733"/>
                <scope line="1736">
                    <scope line="1737">
                        <declaration name="ls" type="GeneralPath" line="1738"/>
                        <scope line="1739"/>
                    </scope>
                    <scope line="1743">
                        <declaration name="rs" type="GeneralPath" line="1744"/>
                        <scope line="1745"/>
                    </scope>
                </scope>
                <declaration name="lp" type="LayoutPathImpl" line="1750"/>
                <scope line="1751"/>
            </method>
            <javadoc line="1756">
                Returns a &lt;code&gt;Shape&lt;/code&gt; enclosing the logical selection in the
                  specified range, extended to the natural bounds of this
                  &lt;code&gt;TextLayout&lt;/code&gt;.  This method is a convenience overload of
                  &lt;code&gt;getLogicalHighlightShape&lt;/code&gt; that uses the natural bounds of
                  this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    firstEndpoint an endpoint in the range of characters to select                    
                </param>
                <param>
                    secondEndpoint the other endpoint of the range of characters
                      to select. Can be less than <code>firstEndpoint</code>.  The range
                      includes the character at min(firstEndpoint, secondEndpoint), but
                      excludes max(firstEndpoint, secondEndpoint).                    
                </param>
                <return>
                    a <code>Shape</code> enclosing the selection.  This is in
                      standard coordinates.                    
                </return>
            </javadoc>
            <method name="getLogicalHighlightShape" type="Shape" line="1770">
                <params>
                    <param name="firstEndpoint" type="int"/>
                    <param name="secondEndpoint" type="int"/>
                </params>
            </method>
            <javadoc line="1773">
                Returns the black box bounds of the characters in the specified range.
                  The black box bounds is an area consisting of the union of the bounding
                  boxes of all the glyphs corresponding to the characters between start
                  and limit.  This area can be disjoint.                
                <param>
                    firstEndpoint one end of the character range                    
                </param>
                <param>
                    secondEndpoint the other end of the character range.  Can be
                      less than <code>firstEndpoint</code>.                    
                </param>
                <return>
                    a <code>Shape</code> enclosing the black box bounds.  This is
                      in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getBlackBoxBounds" type="Shape" line="1784">
                <params>
                    <param name="firstEndpoint" type="int"/>
                    <param name="secondEndpoint" type="int"/>
                </params>
                <scope line="1786">
                    <declaration name="t" type="int" line="1787"/>
                </scope>
                <scope line="1791"/>
                <declaration name="result" type="GeneralPath" line="1794"/>
                <scope line="1795">
                    <scope line="1796">
                        <declaration name="r" type="Rectangle2D" line="1797"/>
                        <scope line="1798"/>
                    </scope>
                </scope>
                <scope line="1803">
                    <declaration name="tx" type="AffineTransform" line="1804"/>
                </scope>
                <declaration name="lp" type="LayoutPathImpl" line="1807"/>
                <scope line="1808"/>
            </method>
            <javadoc line="1813">
                Returns the distance from the point (x,&amp;nbsp;y) to the caret along
                  the line direction defined in &lt;code&gt;caretInfo&lt;/code&gt;.  Distance is
                  negative if the point is to the left of the caret on a horizontal
                  line, or above the caret on a vertical line.
                  Utility for use by hitTestChar.                
            </javadoc>
            <method name="caretToPointDistance" type="float" line="1820">
                <params>
                    <param name="caretInfo" type="float[]"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <declaration name="lineDistance" type="float" line="1821"/>
                <declaration name="distanceOffBaseline" type="float" line="1822"/>
            </method>
            <javadoc line="1825">
                Returns a &lt;code&gt;TextHitInfo&lt;/code&gt; corresponding to the
                  specified point.
                  Coordinates outside the bounds of the &lt;code&gt;TextLayout&lt;/code&gt;
                  map to hits on the leading edge of the first logical character,
                  or the trailing edge of the last logical character, as appropriate,
                  regardless of the position of that character in the line.  Only the
                  direction along the baseline is used to make this evaluation.                
                <param>
                    x the x offset from the origin of this
                      <code>TextLayout</code>.  This is in standard coordinates.                    
                </param>
                <param>
                    y the y offset from the origin of this
                      <code>TextLayout</code>.  This is in standard coordinates.                    
                </param>
                <param>
                    bounds the bounds of the <code>TextLayout</code>.  This
                      is in baseline-relative coordinates.                    
                </param>
                <return>
                    a hit describing the character and edge (leading or trailing)
                      under the specified point.                    
                </return>
            </javadoc>
            <method name="hitTestChar" type="TextHitInfo" line="1842">
                <params>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                    <param name="bounds" type="Rectangle2D"/>
                </params>
                <declaration name="lp" type="LayoutPathImpl" line="1843"/>
                <declaration name="prev" type="boolean" line="1844"/>
                <scope line="1845">
                    <declaration name="pt" type="Point2D.Float" line="1846"/>
                </scope>
                <scope line="1851">
                    <scope line="1852"/>
                    <scope line="1855"/>
                </scope>
                <scope line="1859">
                    <scope line="1860"/>
                    <scope line="1863"/>
                </scope>
                <declaration name="distance" type="double" line="1867"/>
                <declaration name="index" type="int" line="1868"/>
                <declaration name="trail" type="int" line="1869"/>
                <declaration name="lcm" type="CoreMetrics" line="1870"/>
                <declaration name="icx" type="float" line="1871"/>
                <scope line="1872">
                    <scope line="1873"/>
                    <scope line="1876"/>
                    <declaration name="cm" type="CoreMetrics" line="1879"/>
                    <scope line="1880">
                        <scope line="1882"/>
                        <scope line="1885"/>
                        <scope line="1888"/>
                        <declaration name="dy" type="float" line="1891"/>
                    </scope>
                    <declaration name="cx" type="float" line="1896"/>
                    <declaration name="ca" type="float" line="1897"/>
                    <declaration name="dx" type="float" line="1898"/>
                    <declaration name="nd" type="double" line="1900"/>
                    <scope line="1901"/>
                </scope>
                <declaration name="left" type="boolean" line="1910"/>
                <declaration name="leading" type="boolean" line="1911"/>
                <scope line="1912"/>
                <declaration name="result" type="TextHitInfo" line="1915"/>
            </method>
            <javadoc line="1918">
                Returns a &lt;code&gt;TextHitInfo&lt;/code&gt; corresponding to the
                  specified point.  This method is a convenience overload of
                  &lt;code&gt;hitTestChar&lt;/code&gt; that uses the natural bounds of this
                  &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    x the x offset from the origin of this
                      <code>TextLayout</code>.  This is in standard coordinates.                    
                </param>
                <param>
                    y the y offset from the origin of this
                      <code>TextLayout</code>.  This is in standard coordinates.                    
                </param>
                <return>
                    a hit describing the character and edge (leading or trailing)
                      under the specified point.                    
                </return>
            </javadoc>
            <method name="hitTestChar" type="TextHitInfo" line="1930">
                <params>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
            </method>
            <javadoc line="1933">
                Returns the hash code of this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <return>
                    the hash code of this <code>TextLayout</code>.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="1937">
                <scope line="1938"/>
            </method>
            <javadoc line="1944">
                Returns &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;Object&lt;/code&gt; is a
                  &lt;code&gt;TextLayout&lt;/code&gt; object and if the specified &lt;code&gt;Object&lt;/code&gt;
                  equals this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    obj an <code>Object</code> to test for equality                    
                </param>
                <return>
                    <code>true</code> if the specified <code>Object</code>
                      equals this <code>TextLayout</code>; <code>false</code>
                      otherwise.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1953">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="1956">
                Returns &lt;code&gt;true&lt;/code&gt; if the two layouts are equal.
                  Two layouts are equal if they contain equal glyphvectors in the same order.                
                <param>
                    rhs the <code>TextLayout</code> to compare to this
                      <code>TextLayout</code>                    
                </param>
                <return>
                    <code>true</code> if the specified <code>TextLayout</code>
                      equals this <code>TextLayout</code>.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1964">
                <params>
                    <param name="rhs" type="TextLayout"/>
                </params>
                <scope line="1965"/>
                <scope line="1968"/>
            </method>
            <javadoc line="1974">
                Returns debugging information for this &lt;code&gt;TextLayout&lt;/code&gt;.                
                <return>
                    the <code>textLine</code> of this <code>TextLayout</code>
                      as a <code>String</code>.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1979"/>
            <javadoc line="1983">
                Renders this &lt;code&gt;TextLayout&lt;/code&gt; at the specified location in
                  the specified {@link java.awt.Graphics2D Graphics2D} context.
                  The origin of the layout is placed at x,&amp;nbsp;y.  Rendering may touch
                  any point within &lt;code&gt;getBounds()&lt;/code&gt; of this position.  This
                  leaves the &lt;code&gt;g2&lt;/code&gt; unchanged.  Text is rendered along the
                  baseline path.                
                <param>
                    g2 the <code>Graphics2D</code> context into which to render
                      the layout                    
                </param>
                <param>
                    x the X coordinate of the origin of this <code>TextLayout</code>                    
                </param>
                <param>
                    y the Y coordinate of the origin of this <code>TextLayout</code>                    
                </param>
                <see>
                    #getBounds()                    
                </see>
            </javadoc>
            <method name="draw" type="void" line="1996">
                <params>
                    <param name="g2" type="Graphics2D"/>
                    <param name="x" type="float"/>
                    <param name="y" type="float"/>
                </params>
                <scope line="1997"/>
            </method>
            <javadoc line="2002">
                Package-only method for testing ONLY.  Please don&apos;t abuse.                
            </javadoc>
            <method name="getTextLineForTesting" type="TextLine" line="2005"/>
            <javadoc line="2008">
                Return the index of the first character with a different baseline from the
                  character at start, or limit if all characters between start and limit have
                  the same baseline.                
            </javadoc>
            <method name="sameBaselineUpTo" type="int" line="2013">
                <params>
                    <param name="font" type="Font"/>
                    <param name="text" type="char[]"/>
                    <param name="start" type="int"/>
                    <param name="limit" type="int"/>
                </params>
            </method>
            <method name="getBaselineFromGraphic" type="byte" line="2016">
                <params>
                    <param name="graphic" type="GraphicAttribute"/>
                </params>
                <declaration name="alignment" type="byte" line="2017"/>
                <scope line="2018"/>
                <scope line="2021"/>
            </method>
            <javadoc line="2025">
                Returns a &lt;code&gt;Shape&lt;/code&gt; representing the outline of this
                  &lt;code&gt;TextLayout&lt;/code&gt;.                
                <param>
                    tx an optional {@link AffineTransform} to apply to the
                      outline of this <code>TextLayout</code>.                    
                </param>
                <return>
                    a <code>Shape</code> that is the outline of this
                      <code>TextLayout</code>.  This is in standard coordinates.                    
                </return>
            </javadoc>
            <method name="getOutline" type="Shape" line="2033">
                <params>
                    <param name="tx" type="AffineTransform"/>
                </params>
                <declaration name="result" type="Shape" line="2035"/>
                <declaration name="lp" type="LayoutPathImpl" line="2036"/>
                <scope line="2037"/>
            </method>
            <javadoc line="2042">
                Return the LayoutPath, or null if the layout path is the
                  default path (x maps to advance, y maps to offset).                
                <return>
                    the layout path                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getLayoutPath" type="LayoutPath" line="2048"/>
            <javadoc line="2051">
                Convert a hit to a point in standard coordinates.  The point is
                  on the baseline of the character at the leading or trailing
                  edge of the character, as appropriate.  If the path is
                  broken at the side of the character represented by the hit, the
                  point will be adjacent to the character.                
                <param>
                    hit the hit to check.  This must be a valid hit on
                      the TextLayout.                    
                </param>
                <param>
                    point the returned point. The point is in standard
                      coordinates.                    
                </param>
                <throws>
                    IllegalArgumentException if the hit is not valid for the
                      TextLayout.                    
                </throws>
                <throws>
                    NullPointerException if hit or point is null.                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="hitToPoint" type="void" line="2066">
                <params>
                    <param name="hit" type="TextHitInfo"/>
                    <param name="point" type="Point2D"/>
                </params>
                <scope line="2067"/>
                <declaration name="adv" type="float" line="2072"/>
                <declaration name="off" type="float" line="2073"/>
                <declaration name="ix" type="int" line="2074"/>
                <declaration name="leading" type="boolean" line="2075"/>
                <declaration name="ltr" type="boolean" line="2076"/>
                <scope line="2077"/>
                <scope line="2081"/>
                <declaration name="lp" type="LayoutPath" line="2087"/>
                <scope line="2088"/>
            </method>
        </class>
    </source>