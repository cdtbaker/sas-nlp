<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.util.Map"/>
        <import package="java.util.Set"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Collections"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Iterator"/>
        <import package="sun.awt.SunHints"/>
        <import package="java.lang.ref.WeakReference"/>
        <class name="RenderingHints" line="10">
            <implements interface="Map">
                <type_params>
                    <type_param name="Object"/>
                    <type_param name="Object"/>
                </type_params>
            </implements>
            <implements interface="Cloneable"/>
            <javadoc line="10">
                The {@code RenderingHints} class defines and manages collections of
                  keys and associated values which allow an application to provide input
                  into the choice of algorithms used by other classes which perform
                  rendering and image manipulation services.
                  The {@link java.awt.Graphics2D} class, and classes that implement{@link java.awt.image.BufferedImageOp} and{@link java.awt.image.RasterOp} all provide methods to get and
                  possibly to set individual or groups of {@code RenderingHints}keys and their associated values.
                  When those implementations perform any rendering or image manipulation
                  operations they should examine the values of any {@code RenderingHints}that were requested by the caller and tailor the algorithms used
                  accordingly and to the best of their ability.
                  &lt;p&gt;
                  Note that since these keys and values are &lt;i&gt;hints&lt;/i&gt;, there is
                  no requirement that a given implementation supports all possible
                  choices indicated below or that it can respond to requests to
                  modify its choice of algorithm.
                  The values of the various hint keys may also interact such that
                  while all variants of a given key are supported in one situation,
                  the implementation may be more restricted when the values associated
                  with other keys are modified.
                  For example, some implementations may be able to provide several
                  types of dithering when the antialiasing hint is turned off, but
                  have little control over dithering when antialiasing is on.
                  The full set of supported keys and hints may also vary by destination
                  since runtimes may use different underlying modules to render to
                  the screen, or to {@link java.awt.image.BufferedImage} objects,
                  or while printing.
                  &lt;p&gt;
                  Implementations are free to ignore the hints completely, but should
                  try to use an implementation algorithm that is as close as possible
                  to the request.
                  If an implementation supports a given algorithm when any value is used
                  for an associated hint key, then minimally it must do so when the
                  value for that key is the exact value that specifies the algorithm.
                  &lt;p&gt;
                  The keys used to control the hints are all special values that
                  subclass the associated {@link RenderingHints.Key} class.
                  Many common hints are expressed below as static constants in this
                  class, but the list is not meant to be exhaustive.
                  Other hints may be created by other packages by defining new objects
                  which subclass the {@code Key} class and defining the associated values.                
            </javadoc>
            <class name="Key" line="52">
                <javadoc line="52">
                    Defines the base type of all keys used along with the{@link RenderingHints} class to control various
                      algorithm choices in the rendering and imaging pipelines.
                      Instances of this class are immutable and unique which
                      means that tests for matches can be made using the{@code ==} operator instead of the more expensive{@code equals()} method.                    
                </javadoc>
                <declaration name="identitymap" type="HashMap" line="59"/>
                <method name="getIdentity" type="String" line="60"/>
                <method name="recordIdentity" type="void" line="63">
                    <params>
                        <param name="k" type="Key"/>
                    </params>
                    <declaration name="identity" type="Object" line="64"/>
                    <declaration name="otherref" type="Object" line="65"/>
                    <scope line="66">
                        <declaration name="otherkey" type="Key" line="67"/>
                        <scope line="68"/>
                    </scope>
                </method>
                <declaration name="privatekey" type="int" line="74"/>
                <javadoc line="75">
                    Construct a key using the indicated private key.  Each
                      subclass of Key maintains its own unique domain of integer
                      keys.  No two objects with the same integer key and of the
                      same specific subclass can be constructed.  An exception
                      will be thrown if an attempt is made to construct another
                      object of a given class with the same integer key as a
                      pre-existing instance of that subclass of Key.                    
                    <param>
                        privatekey the specified key                        
                    </param>
                </javadoc>
                <method name="Key" type="constructor" line="85">
                    <params>
                        <param name="privatekey" type="int"/>
                    </params>
                </method>
                <method name="isCompatibleValue" type="boolean" line="89"/>
                <javadoc line="89">
                    Returns true if the specified object is a valid value
                      for this Key.                    
                    <param>
                        val the <code>Object</code> to test for validity                        
                    </param>
                    <return>
                        <code>true</code> if <code>val</code> is valid;
                          <code>false</code> otherwise.                        
                    </return>
                </javadoc>
                <javadoc line="97">
                    Returns the private integer key that the subclass
                      instantiated this Key with.                    
                    <return>
                        the private integer key that the subclass
                          instantiated this Key with.                        
                    </return>
                </javadoc>
                <method name="intKey" type="int" line="103"/>
                <javadoc line="106">
                    The hash code for all Key objects will be the same as the
                      system identity code of the object as defined by the
                      System.identityHashCode() method.                    
                </javadoc>
                <method name="hashCode" type="int" line="111"/>
                <javadoc line="114">
                    The equals method for all Key objects will return the same
                      result as the equality operator &apos;==&apos;.                    
                </javadoc>
                <method name="equals" type="boolean" line="118">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
            </class>
            <declaration name="hintmap" type="HashMap" line="122"/>
            <declaration name="KEY_ANTIALIASING" type="Key" line="123"/>
            <javadoc line="123">
                Antialiasing hint key.
                  The {@code ANTIALIASING} hint controls whether or not the
                  geometry rendering methods of a {@link Graphics2D} object
                  will attempt to reduce aliasing artifacts along the edges
                  of shapes.
                  &lt;p&gt;
                  A typical antialiasing algorithm works by blending the existing
                  colors of the pixels along the boundary of a shape with the
                  requested fill paint according to the estimated partial pixel
                  coverage of the shape.
                  &lt;p&gt;
                  The allowable values for this hint are
                  &lt;ul&gt;
                  &lt;li&gt;{@link #VALUE_ANTIALIAS_ON}&lt;li&gt;{@link #VALUE_ANTIALIAS_OFF}&lt;li&gt;{@link #VALUE_ANTIALIAS_DEFAULT}&lt;/ul&gt;                
            </javadoc>
            <declaration name="VALUE_ANTIALIAS_ON" type="Object" line="140"/>
            <javadoc line="140">
                Antialiasing hint value -- rendering is done with antialiasing.                
                <see>
                    #KEY_ANTIALIASING                    
                </see>
            </javadoc>
            <declaration name="VALUE_ANTIALIAS_OFF" type="Object" line="145"/>
            <javadoc line="145">
                Antialiasing hint value -- rendering is done without antialiasing.                
                <see>
                    #KEY_ANTIALIASING                    
                </see>
            </javadoc>
            <declaration name="VALUE_ANTIALIAS_DEFAULT" type="Object" line="150"/>
            <javadoc line="150">
                Antialiasing hint value -- rendering is done with a default
                  antialiasing mode chosen by the implementation.                
                <see>
                    #KEY_ANTIALIASING                    
                </see>
            </javadoc>
            <declaration name="KEY_RENDERING" type="Key" line="156"/>
            <javadoc line="156">
                Rendering hint key.
                  The {@code RENDERING} hint is a general hint that provides
                  a high level recommendation as to whether to bias algorithm
                  choices more for speed or quality when evaluating tradeoffs.
                  This hint could be consulted for any rendering or image
                  manipulation operation, but decisions will usually honor
                  other, more specific hints in preference to this hint.
                  &lt;p&gt;
                  The allowable values for this hint are
                  &lt;ul&gt;
                  &lt;li&gt;{@link #VALUE_RENDER_SPEED}&lt;li&gt;{@link #VALUE_RENDER_QUALITY}&lt;li&gt;{@link #VALUE_RENDER_DEFAULT}&lt;/ul&gt;                
            </javadoc>
            <declaration name="VALUE_RENDER_SPEED" type="Object" line="170"/>
            <javadoc line="170">
                Rendering hint value -- rendering algorithms are chosen
                  with a preference for output speed.                
                <see>
                    #KEY_RENDERING                    
                </see>
            </javadoc>
            <declaration name="VALUE_RENDER_QUALITY" type="Object" line="176"/>
            <javadoc line="176">
                Rendering hint value -- rendering algorithms are chosen
                  with a preference for output quality.                
                <see>
                    #KEY_RENDERING                    
                </see>
            </javadoc>
            <declaration name="VALUE_RENDER_DEFAULT" type="Object" line="182"/>
            <javadoc line="182">
                Rendering hint value -- rendering algorithms are chosen
                  by the implementation for a good tradeoff of performance
                  vs. quality.                
                <see>
                    #KEY_RENDERING                    
                </see>
            </javadoc>
            <declaration name="KEY_DITHERING" type="Key" line="189"/>
            <javadoc line="189">
                Dithering hint key.
                  The {@code DITHERING} hint controls how closely to approximate
                  a color when storing into a destination with limited color
                  resolution.
                  &lt;p&gt;
                  Some rendering destinations may support a limited number of
                  color choices which may not be able to accurately represent
                  the full spectrum of colors that can result during rendering
                  operations.
                  For such a destination the {@code DITHERING} hint controls
                  whether rendering is done with a flat solid fill of a single
                  pixel value which is the closest supported color to what was
                  requested, or whether shapes will be filled with a pattern of
                  colors which combine to better approximate that color.
                  &lt;p&gt;
                  The allowable values for this hint are
                  &lt;ul&gt;
                  &lt;li&gt;{@link #VALUE_DITHER_DISABLE}&lt;li&gt;{@link #VALUE_DITHER_ENABLE}&lt;li&gt;{@link #VALUE_DITHER_DEFAULT}&lt;/ul&gt;                
            </javadoc>
            <declaration name="VALUE_DITHER_DISABLE" type="Object" line="210"/>
            <javadoc line="210">
                Dithering hint value -- do not dither when rendering geometry.                
                <see>
                    #KEY_DITHERING                    
                </see>
            </javadoc>
            <declaration name="VALUE_DITHER_ENABLE" type="Object" line="215"/>
            <javadoc line="215">
                Dithering hint value -- dither when rendering geometry, if needed.                
                <see>
                    #KEY_DITHERING                    
                </see>
            </javadoc>
            <declaration name="VALUE_DITHER_DEFAULT" type="Object" line="220"/>
            <javadoc line="220">
                Dithering hint value -- use a default for dithering chosen by
                  the implementation.                
                <see>
                    #KEY_DITHERING                    
                </see>
            </javadoc>
            <declaration name="KEY_TEXT_ANTIALIASING" type="Key" line="226"/>
            <javadoc line="226">
                Text antialiasing hint key.
                  The {@code TEXT_ANTIALIASING} hint can control the use of
                  antialiasing algorithms for text independently of the
                  choice used for shape rendering.
                  Often an application may want to use antialiasing for text
                  only and not for other shapes.
                  Additionally, the algorithms for reducing the aliasing
                  artifacts for text are often more sophisticated than those
                  that have been developed for general rendering so this
                  hint key provides additional values which can control
                  the choices of some of those text-specific algorithms.
                  If left in the {@code DEFAULT} state, this hint will
                  generally defer to the value of the regular{@link #KEY_ANTIALIASING} hint key.
                  &lt;p&gt;
                  The allowable values for this hint are
                  &lt;ul&gt;
                  &lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_ON}&lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_OFF}&lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_DEFAULT}&lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_GASP}&lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB}&lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_LCD_HBGR}&lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_LCD_VRGB}&lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_LCD_VBGR}&lt;/ul&gt;                
            </javadoc>
            <declaration name="VALUE_TEXT_ANTIALIAS_ON" type="Object" line="246"/>
            <javadoc line="246">
                Text antialiasing hint value -- text rendering is done with
                  some form of antialiasing.                
                <see>
                    #KEY_TEXT_ANTIALIASING                    
                </see>
            </javadoc>
            <declaration name="VALUE_TEXT_ANTIALIAS_OFF" type="Object" line="252"/>
            <javadoc line="252">
                Text antialiasing hint value -- text rendering is done without
                  any form of antialiasing.                
                <see>
                    #KEY_TEXT_ANTIALIASING                    
                </see>
            </javadoc>
            <declaration name="VALUE_TEXT_ANTIALIAS_DEFAULT" type="Object" line="258"/>
            <javadoc line="258">
                Text antialiasing hint value -- text rendering is done according
                  to the {@link #KEY_ANTIALIASING} hint or a default chosen by the
                  implementation.                
                <see>
                    #KEY_TEXT_ANTIALIASING                    
                </see>
            </javadoc>
            <declaration name="VALUE_TEXT_ANTIALIAS_GASP" type="Object" line="265"/>
            <javadoc line="265">
                Text antialiasing hint value -- text rendering is requested to
                  use information in the font resource which specifies for each point
                  size whether to apply {@link #VALUE_TEXT_ANTIALIAS_ON} or{@link #VALUE_TEXT_ANTIALIAS_OFF}.
                  &lt;p&gt;
                  TrueType fonts typically provide this information in the &apos;gasp&apos; table.
                  In the absence of this information, the behaviour for a particular
                  font and size is determined by implementation defaults.
                  &lt;p&gt;
                  &lt;i&gt;Note:&lt;/i&gt;A font designer will typically carefully hint a font for
                  the most common user interface point sizes. Consequently the &apos;gasp&apos;
                  table will likely specify to use only hinting at those sizes and not
                  &quot;smoothing&quot;. So in many cases the resulting text display is
                  equivalent to {@code VALUE_TEXT_ANTIALIAS_OFF}.
                  This may be unexpected but is correct.
                  &lt;p&gt;
                  Logical fonts which are composed of multiple physical fonts will for
                  consistency will use the setting most appropriate for the overall
                  composite font.                
                <see>
                    #KEY_TEXT_ANTIALIASING                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="VALUE_TEXT_ANTIALIAS_LCD_HRGB" type="Object" line="288"/>
            <javadoc line="288">
                Text antialiasing hint value -- request that text be displayed
                  optimised for an LCD display with subpixels in order from display
                  left to right of R,G,B such that the horizontal subpixel resolution
                  is three times that of the full pixel horizontal resolution (HRGB).
                  This is the most common configuration.
                  Selecting this hint for displays with one of the other LCD subpixel
                  configurations will likely result in unfocused text.
                  &lt;p&gt;
                  &lt;i&gt;Notes:&lt;/i&gt;&lt;br&gt;
                  An implementation when choosing whether to apply any of the
                  LCD text hint values may take into account factors including requiring
                  color depth of the destination to be at least 15 bits per pixel
                  (ie 5 bits per color component),
                  characteristics of a font such as whether embedded bitmaps may
                  produce better results, or when displaying to a non-local networked
                  display device enabling it only if suitable protocols are available,
                  or ignoring the hint if performing very high resolution rendering
                  or the target device is not appropriate: eg when printing.
                  &lt;p&gt;
                  These hints can equally be applied when rendering to software images,
                  but these images may not then be suitable for general export, as the
                  text will have been rendered appropriately for a specific subpixel
                  organisation. Also lossy images are not a good choice, nor image
                  formats such as GIF which have limited colors.
                  So unless the image is destined solely for rendering on a
                  display device with the same configuration, some other text
                  anti-aliasing hint such as{@link #VALUE_TEXT_ANTIALIAS_ON}may be a better choice.
                  &lt;p&gt;Selecting a value which does not match the LCD display in use
                  will likely lead to a degradation in text quality.
                  On display devices (ie CRTs) which do not have the same characteristics
                  as LCD displays, the overall effect may appear similar to standard text
                  anti-aliasing, but the quality may be degraded by color distortion.
                  Analog connected LCD displays may also show little advantage over
                  standard text-antialiasing and be similar to CRTs.
                  &lt;p&gt;
                  In other words for the best results use an LCD display with a digital
                  display connector and specify the appropriate sub-pixel configuration.                
                <see>
                    #KEY_TEXT_ANTIALIASING                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="VALUE_TEXT_ANTIALIAS_LCD_HBGR" type="Object" line="330"/>
            <javadoc line="330">
                Text antialiasing hint value -- request that text be displayed
                  optimised for an LCD display with subpixels in order from display
                  left to right of B,G,R such that the horizontal subpixel resolution
                  is three times that of the full pixel horizontal resolution (HBGR).
                  This is a much less common configuration than HRGB.
                  Selecting this hint for displays with one of the other LCD subpixel
                  configurations will likely result in unfocused text.
                  See {@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB},
                  for more information on when this hint is applied.                
                <see>
                    #KEY_TEXT_ANTIALIASING                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="VALUE_TEXT_ANTIALIAS_LCD_VRGB" type="Object" line="344"/>
            <javadoc line="344">
                Text antialiasing hint value -- request that text be displayed
                  optimised for an LCD display with subpixel organisation from display
                  top to bottom of R,G,B such that the vertical subpixel resolution is
                  three times that of the full pixel vertical resolution (VRGB).
                  Vertical orientation is very uncommon and probably mainly useful
                  for a physically rotated display.
                  Selecting this hint for displays with one of the other LCD subpixel
                  configurations will likely result in unfocused text.
                  See {@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB},
                  for more information on when this hint is applied.                
                <see>
                    #KEY_TEXT_ANTIALIASING                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="VALUE_TEXT_ANTIALIAS_LCD_VBGR" type="Object" line="359"/>
            <javadoc line="359">
                Text antialiasing hint value -- request that text be displayed
                  optimised for an LCD display with subpixel organisation from display
                  top to bottom of B,G,R such that the vertical subpixel resolution is
                  three times that of the full pixel vertical resolution (VBGR).
                  Vertical orientation is very uncommon and probably mainly useful
                  for a physically rotated display.
                  Selecting this hint for displays with one of the other LCD subpixel
                  configurations will likely result in unfocused text.
                  See {@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB},
                  for more information on when this hint is applied.                
                <see>
                    #KEY_TEXT_ANTIALIASING                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="KEY_TEXT_LCD_CONTRAST" type="Key" line="374"/>
            <javadoc line="374">
                LCD text contrast rendering hint key.
                  The value is an &lt;code&gt;Integer&lt;/code&gt; object which is used as a text
                  contrast adjustment when used in conjunction with an LCD text
                  anti-aliasing hint such as{@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB}.
                  &lt;ul&gt;
                  &lt;li&gt;Values should be a positive integer in the range 100 to 250.
                  &lt;li&gt;A lower value (eg 100) corresponds to higher contrast text when
                  displaying dark text on a light background.
                  &lt;li&gt;A higher value (eg 200) corresponds to lower contrast text when
                  displaying dark text on a light background.
                  &lt;li&gt;A typical useful value is in the narrow range 140-180.
                  &lt;li&gt;If no value is specified, a system or implementation default value
                  will be applied.
                  &lt;/ul&gt;
                  The default value can be expected to be adequate for most purposes,
                  so clients should rarely need to specify a value for this hint unless
                  they have concrete information as to an appropriate value.
                  A higher value does not mean a higher contrast, in fact the opposite
                  is true.
                  The correction is applied in a similar manner to a gamma adjustment
                  for non-linear perceptual luminance response of display systems, but
                  does not indicate a full correction for this.                
                <see>
                    #KEY_TEXT_ANTIALIASING                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="KEY_FRACTIONALMETRICS" type="Key" line="401"/>
            <javadoc line="401">
                Font fractional metrics hint key.
                  The {@code FRACTIONALMETRICS} hint controls whether the positioning
                  of individual character glyphs takes into account the sub-pixel
                  accuracy of the scaled character advances of the font or whether
                  such advance vectors are rounded to an integer number of whole
                  device pixels.
                  This hint only recommends how much accuracy should be used to
                  position the glyphs and does not specify or recommend whether or
                  not the actual rasterization or pixel bounds of the glyph should
                  be modified to match.
                  &lt;p&gt;
                  Rendering text to a low resolution device like a screen will
                  necessarily involve a number of rounding operations as the
                  high quality and very precise definition of the shape and
                  metrics of the character glyphs must be matched to discrete
                  device pixels.
                  Ideally the positioning of glyphs during text layout would be
                  calculated by scaling the design metrics in the font according
                  to the point size, but then the scaled advance width will not
                  necessarily be an integer number of pixels.
                  If the glyphs are positioned with sub-pixel accuracy according
                  to these scaled design metrics then the rasterization would
                  ideally need to be adjusted for each possible sub-pixel origin.
                  &lt;p&gt;
                  Unfortunately, scaling each glyph customized to its exact
                  subpixel origin during text layout would be prohibitively
                  expensive so a simplified system based on integer device
                  positions is typically used to lay out the text.
                  The rasterization of the glyph and the scaled advance width
                  are both adjusted together to yield text that looks good at
                  device resolution and has consistent integer pixel distances
                  between glyphs that help the glyphs look uniformly and
                  consistently spaced and readable.
                  &lt;p&gt;
                  This process of rounding advance widths for rasterized glyphs
                  to integer distances means that the character density and the
                  overall length of a string of text will be different from the
                  theoretical design measurements due to the accumulation of
                  a series of small differences in the adjusted widths of
                  each glyph.
                  The specific differences will be different for each glyph,
                  some being wider and some being narrower than their theoretical
                  design measurements.
                  Thus the overall difference in character density and length
                  will vary by a number of factors including the font, the
                  specific device resolution being targeted, and the glyphs
                  chosen to represent the string being rendered.
                  As a result, rendering the same string at multiple device
                  resolutions can yield widely varying metrics for whole strings.
                  &lt;p&gt;
                  When {@code FRACTIONALMETRICS} are enabled, the true font design
                  metrics are scaled by the point size and used for layout with
                  sub-pixel accuracy.
                  The average density of glyphs and total length of a long
                  string of characters will therefore more closely match the
                  theoretical design of the font, but readability may be affected
                  since individual pairs of characters may not always appear to
                  be consistent distances apart depending on how the sub-pixel
                  accumulation of the glyph origins meshes with the device pixel
                  grid.
                  Enabling this hint may be desirable when text layout is being
                  performed that must be consistent across a wide variety of
                  output resolutions.
                  Specifically, this hint may be desirable in situations where
                  the layout of text is being previewed on a low resolution
                  device like a screen for output that will eventually be
                  rendered on a high resolution printer or typesetting device.
                  &lt;p&gt;
                  When disabled, the scaled design metrics are rounded or adjusted
                  to integer distances for layout.
                  The distances between any specific pair of glyphs will be more
                  uniform on the device, but the density and total length of long
                  strings may no longer match the theoretical intentions of the
                  font designer.
                  Disabling this hint will typically produce more readable results
                  on low resolution devices like computer monitors.
                  &lt;p&gt;
                  The allowable values for this key are
                  &lt;ul&gt;
                  &lt;li&gt;{@link #VALUE_FRACTIONALMETRICS_OFF}&lt;li&gt;{@link #VALUE_FRACTIONALMETRICS_ON}&lt;li&gt;{@link #VALUE_FRACTIONALMETRICS_DEFAULT}&lt;/ul&gt;                
            </javadoc>
            <declaration name="VALUE_FRACTIONALMETRICS_OFF" type="Object" line="484"/>
            <javadoc line="484">
                Font fractional metrics hint value -- character glyphs are
                  positioned with advance widths rounded to pixel boundaries.                
                <see>
                    #KEY_FRACTIONALMETRICS                    
                </see>
            </javadoc>
            <declaration name="VALUE_FRACTIONALMETRICS_ON" type="Object" line="490"/>
            <javadoc line="490">
                Font fractional metrics hint value -- character glyphs are
                  positioned with sub-pixel accuracy.                
                <see>
                    #KEY_FRACTIONALMETRICS                    
                </see>
            </javadoc>
            <declaration name="VALUE_FRACTIONALMETRICS_DEFAULT" type="Object" line="496"/>
            <javadoc line="496">
                Font fractional metrics hint value -- character glyphs are
                  positioned with accuracy chosen by the implementation.                
                <see>
                    #KEY_FRACTIONALMETRICS                    
                </see>
            </javadoc>
            <declaration name="KEY_INTERPOLATION" type="Key" line="502"/>
            <javadoc line="502">
                Interpolation hint key.
                  The {@code INTERPOLATION} hint controls how image pixels are
                  filtered or resampled during an image rendering operation.
                  &lt;p&gt;
                  Implicitly images are defined to provide color samples at
                  integer coordinate locations.
                  When images are rendered upright with no scaling onto a
                  destination, the choice of which image pixels map to which
                  device pixels is obvious and the samples at the integer
                  coordinate locations in the image are transfered to the
                  pixels at the corresponding integer locations on the device
                  pixel grid one for one.
                  When images are rendered in a scaled, rotated, or otherwise
                  transformed coordinate system, then the mapping of device
                  pixel coordinates back to the image can raise the question
                  of what color sample to use for the continuous coordinates
                  that lie between the integer locations of the provided image
                  samples.
                  Interpolation algorithms define functions which provide a
                  color sample for any continuous coordinate in an image based
                  on the color samples at the surrounding integer coordinates.
                  &lt;p&gt;
                  The allowable values for this hint are
                  &lt;ul&gt;
                  &lt;li&gt;{@link #VALUE_INTERPOLATION_NEAREST_NEIGHBOR}&lt;li&gt;{@link #VALUE_INTERPOLATION_BILINEAR}&lt;li&gt;{@link #VALUE_INTERPOLATION_BICUBIC}&lt;/ul&gt;                
            </javadoc>
            <declaration name="VALUE_INTERPOLATION_NEAREST_NEIGHBOR" type="Object" line="530"/>
            <javadoc line="530">
                Interpolation hint value -- the color sample of the nearest
                  neighboring integer coordinate sample in the image is used.
                  Conceptually the image is viewed as a grid of unit-sized
                  square regions of color centered around the center of each
                  image pixel.
                  &lt;p&gt;
                  As the image is scaled up, it will look correspondingly blocky.
                  As the image is scaled down, the colors for source pixels will
                  be either used unmodified, or skipped entirely in the output
                  representation.                
                <see>
                    #KEY_INTERPOLATION                    
                </see>
            </javadoc>
            <declaration name="VALUE_INTERPOLATION_BILINEAR" type="Object" line="544"/>
            <javadoc line="544">
                Interpolation hint value -- the color samples of the 4 nearest
                  neighboring integer coordinate samples in the image are
                  interpolated linearly to produce a color sample.
                  Conceptually the image is viewed as a set of infinitely small
                  point color samples which have value only at the centers of
                  integer coordinate pixels and the space between those pixel
                  centers is filled with linear ramps of colors that connect
                  adjacent discrete samples in a straight line.
                  &lt;p&gt;
                  As the image is scaled up, there are no blocky edges between
                  the colors in the image as there are with{@link #VALUE_INTERPOLATION_NEAREST_NEIGHBOR NEAREST_NEIGHBOR},
                  but the blending may show some subtle discontinuities along the
                  horizontal and vertical edges that line up with the samples
                  caused by a sudden change in the slope of the interpolation
                  from one side of a sample to the other.
                  As the image is scaled down, more image pixels have their
                  color samples represented in the resulting output since each
                  output pixel recieves color information from up to 4 image
                  pixels.                
                <see>
                    #KEY_INTERPOLATION                    
                </see>
            </javadoc>
            <declaration name="VALUE_INTERPOLATION_BICUBIC" type="Object" line="567"/>
            <javadoc line="567">
                Interpolation hint value -- the color samples of 9 nearby
                  integer coordinate samples in the image are interpolated using
                  a cubic function in both {@code X} and {@code Y} to produce
                  a color sample.
                  Conceptually the view of the image is very similar to the view
                  used in the {@link #VALUE_INTERPOLATION_BILINEAR BILINEAR}algorithm except that the ramps of colors that connect between
                  the samples are curved and have better continuity of slope
                  as they cross over between sample boundaries.
                  &lt;p&gt;
                  As the image is scaled up, there are no blocky edges and the
                  interpolation should appear smoother and with better depictions
                  of any edges in the original image than with {@code BILINEAR}.
                  As the image is scaled down, even more of the original color
                  samples from the original image will have their color information
                  carried through and represented.                
                <see>
                    #KEY_INTERPOLATION                    
                </see>
            </javadoc>
            <declaration name="KEY_ALPHA_INTERPOLATION" type="Key" line="586"/>
            <javadoc line="586">
                Alpha interpolation hint key.
                  The {@code ALPHA_INTERPOLATION} hint is a general hint that
                  provides a high level recommendation as to whether to bias
                  alpha blending algorithm choices more for speed or quality
                  when evaluating tradeoffs.
                  &lt;p&gt;
                  This hint could control the choice of alpha blending
                  calculations that sacrifice some precision to use fast
                  lookup tables or lower precision SIMD instructions.
                  This hint could also control whether or not the color
                  and alpha values are converted into a linear color space
                  during the calculations for a more linear visual effect
                  at the expense of additional per-pixel calculations.
                  &lt;p&gt;
                  The allowable values for this hint are
                  &lt;ul&gt;
                  &lt;li&gt;{@link #VALUE_ALPHA_INTERPOLATION_SPEED}&lt;li&gt;{@link #VALUE_ALPHA_INTERPOLATION_QUALITY}&lt;li&gt;{@link #VALUE_ALPHA_INTERPOLATION_DEFAULT}&lt;/ul&gt;                
            </javadoc>
            <declaration name="VALUE_ALPHA_INTERPOLATION_SPEED" type="Object" line="606"/>
            <javadoc line="606">
                Alpha interpolation hint value -- alpha blending algorithms
                  are chosen with a preference for calculation speed.                
                <see>
                    #KEY_ALPHA_INTERPOLATION                    
                </see>
            </javadoc>
            <declaration name="VALUE_ALPHA_INTERPOLATION_QUALITY" type="Object" line="612"/>
            <javadoc line="612">
                Alpha interpolation hint value -- alpha blending algorithms
                  are chosen with a preference for precision and visual quality.                
                <see>
                    #KEY_ALPHA_INTERPOLATION                    
                </see>
            </javadoc>
            <declaration name="VALUE_ALPHA_INTERPOLATION_DEFAULT" type="Object" line="618"/>
            <javadoc line="618">
                Alpha interpolation hint value -- alpha blending algorithms
                  are chosen by the implementation for a good tradeoff of
                  performance vs. quality.                
                <see>
                    #KEY_ALPHA_INTERPOLATION                    
                </see>
            </javadoc>
            <declaration name="KEY_COLOR_RENDERING" type="Key" line="625"/>
            <javadoc line="625">
                Color rendering hint key.
                  The {@code COLOR_RENDERING} hint controls the accuracy of
                  approximation and conversion when storing colors into a
                  destination image or surface.
                  &lt;p&gt;
                  When a rendering or image manipulation operation produces
                  a color value that must be stored into a destination, it
                  must first convert that color into a form suitable for
                  storing into the destination image or surface.
                  Minimally, the color components must be converted to bit
                  representations and ordered in the correct order or an
                  index into a color lookup table must be chosen before
                  the data can be stored into the destination memory.
                  Without this minimal conversion, the data in the destination
                  would likely represent random, incorrect or possibly even
                  unsupported values.
                  Algorithms to quickly convert the results of rendering
                  operations into the color format of most common destinations
                  are well known and fairly optimal to execute.
                  &lt;p&gt;
                  Simply performing the most basic color format conversion to
                  store colors into a destination can potentially ignore a
                  difference in the calibration of the{@link java.awt.color.ColorSpace}of the source and destination or other factors such as the
                  linearity of the gamma correction.
                  Unless the source and destination {@code ColorSpace} are
                  identical, to correctly perform a rendering operation with
                  the most care taken for the accuracy of the colors being
                  represented, the source colors should be converted to a
                  device independent {@code ColorSpace} and the results then
                  converted back to the destination {@code ColorSpace}.
                  Furthermore, if calculations such as the blending of multiple
                  source colors are to be performed during the rendering
                  operation, greater visual clarity can be achieved if the
                  intermediate device independent {@code ColorSpace} is
                  chosen to have a linear relationship between the values
                  being calculated and the perception of the human eye to
                  the response curves of the output device.
                  &lt;p&gt;
                  The allowable values for this hint are
                  &lt;ul&gt;
                  &lt;li&gt;{@link #VALUE_COLOR_RENDER_SPEED}&lt;li&gt;{@link #VALUE_COLOR_RENDER_QUALITY}&lt;li&gt;{@link #VALUE_COLOR_RENDER_DEFAULT}&lt;/ul&gt;                
            </javadoc>
            <declaration name="VALUE_COLOR_RENDER_SPEED" type="Object" line="669"/>
            <javadoc line="669">
                Color rendering hint value -- perform the fastest color
                  conversion to the format of the output device.                
                <see>
                    #KEY_COLOR_RENDERING                    
                </see>
            </javadoc>
            <declaration name="VALUE_COLOR_RENDER_QUALITY" type="Object" line="675"/>
            <javadoc line="675">
                Color rendering hint value -- perform the color conversion
                  calculations with the highest accuracy and visual quality.                
                <see>
                    #KEY_COLOR_RENDERING                    
                </see>
            </javadoc>
            <declaration name="VALUE_COLOR_RENDER_DEFAULT" type="Object" line="681"/>
            <javadoc line="681">
                Color rendering hint value -- perform color conversion
                  calculations as chosen by the implementation to represent
                  the best available tradeoff between performance and
                  accuracy.                
                <see>
                    #KEY_COLOR_RENDERING                    
                </see>
            </javadoc>
            <declaration name="KEY_STROKE_CONTROL" type="Key" line="689"/>
            <javadoc line="689">
                Stroke normalization control hint key.
                  The {@code STROKE_CONTROL} hint controls whether a rendering
                  implementation should or is allowed to modify the geometry
                  of rendered shapes for various purposes.
                  &lt;p&gt;
                  Some implementations may be able to use an optimized platform
                  rendering library which may be faster than traditional software
                  rendering algorithms on a given platform, but which may also
                  not support floating point coordinates.
                  Some implementations may also have sophisticated algorithms
                  which perturb the coordinates of a path so that wide lines
                  appear more uniform in width and spacing.
                  &lt;p&gt;
                  If an implementation performs any type of modification or
                  &quot;normalization&quot; of a path, it should never move the coordinates
                  by more than half a pixel in any direction.
                  &lt;p&gt;
                  The allowable values for this hint are
                  &lt;ul&gt;
                  &lt;li&gt;{@link #VALUE_STROKE_NORMALIZE}&lt;li&gt;{@link #VALUE_STROKE_PURE}&lt;li&gt;{@link #VALUE_STROKE_DEFAULT}&lt;/ul&gt;                
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="VALUE_STROKE_DEFAULT" type="Object" line="713"/>
            <javadoc line="713">
                Stroke normalization control hint value -- geometry may be
                  modified or left pure depending on the tradeoffs in a given
                  implementation.
                  Typically this setting allows an implementation to use a fast
                  integer coordinate based platform rendering library, but does
                  not specifically request normalization for uniformity or
                  aesthetics.                
                <see>
                    #KEY_STROKE_CONTROL                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="VALUE_STROKE_NORMALIZE" type="Object" line="725"/>
            <javadoc line="725">
                Stroke normalization control hint value -- geometry should
                  be normalized to improve uniformity or spacing of lines and
                  overall aesthetics.
                  Note that different normalization algorithms may be more
                  successful than others for given input paths.                
                <see>
                    #KEY_STROKE_CONTROL                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="VALUE_STROKE_PURE" type="Object" line="735"/>
            <javadoc line="735">
                Stroke normalization control hint value -- geometry should
                  be left unmodified and rendered with sub-pixel accuracy.                
                <see>
                    #KEY_STROKE_CONTROL                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <javadoc line="742">
                Constructs a new object with keys and values initialized
                  from the specified Map object which may be null.                
                <param>
                    init a map of key/value pairs to initialize the hints
                      or null if the object should be empty                    
                </param>
            </javadoc>
            <method name="RenderingHints" type="constructor" line="748">
                <params>
                    <param name="init" type="Map<Key,?>"/>
                </params>
                <scope line="749"/>
            </method>
            <javadoc line="753">
                Constructs a new object with the specified key/value pair.                
                <param>
                    key the key of the particular hint property                    
                </param>
                <param>
                    value the value of the hint property specified with
                      <code>key</code>                    
                </param>
            </javadoc>
            <method name="RenderingHints" type="constructor" line="759">
                <params>
                    <param name="key" type="Key"/>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="762">
                Returns the number of key-value mappings in this
                  &lt;code&gt;RenderingHints&lt;/code&gt;.                
                <return>
                    the number of key-value mappings in this
                      <code>RenderingHints</code>.                    
                </return>
            </javadoc>
            <method name="size" type="int" line="768"/>
            <javadoc line="771">
                Returns &lt;code&gt;true&lt;/code&gt; if this
                  &lt;code&gt;RenderingHints&lt;/code&gt; contains no key-value mappings.                
                <return>
                    <code>true</code> if this
                      <code>RenderingHints</code> contains no key-value mappings.                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="777"/>
            <javadoc line="780">
                Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;RenderingHints&lt;/code&gt;
                  contains a mapping for the specified key.                
                <param>
                    key key whose presence in this
                      <code>RenderingHints</code> is to be tested.                    
                </param>
                <return>
                    <code>true</code> if this <code>RenderingHints</code>
                      contains a mapping for the specified key.                    
                </return>
                <exception>
                    <code>ClassCastException</code> if the key can not
                      be cast to <code>RenderingHints.Key</code>                    
                </exception>
            </javadoc>
            <method name="containsKey" type="boolean" line="790">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="793">
                Returns true if this RenderingHints maps one or more keys to the
                  specified value.
                  More formally, returns &lt;code&gt;true&lt;/code&gt; if and only
                  if this &lt;code&gt;RenderingHints&lt;/code&gt;
                  contains at least one mapping to a value &lt;code&gt;v&lt;/code&gt; such that
                  &lt;pre&gt;
                  (value==null ? v==null : value.equals(v))
                  &lt;/pre&gt;.
                  This operation will probably require time linear in the
                  &lt;code&gt;RenderingHints&lt;/code&gt; size for most implementations
                  of &lt;code&gt;RenderingHints&lt;/code&gt;.                
                <param>
                    value value whose presence in this
                      <code>RenderingHints</code> is to be tested.                    
                </param>
                <return>
                    <code>true</code> if this <code>RenderingHints</code>
                      maps one or more keys to the specified value.                    
                </return>
            </javadoc>
            <method name="containsValue" type="boolean" line="810">
                <params>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="813">
                Returns the value to which the specified key is mapped.                
                <param>
                    key   a rendering hint key                    
                </param>
                <return>
                    the value to which the key is mapped in this object or
                      <code>null</code> if the key is not mapped to any value in
                      this object.                    
                </return>
                <exception>
                    <code>ClassCastException</code> if the key can not
                      be cast to <code>RenderingHints.Key</code>                    
                </exception>
                <see>
                    #put(Object,Object)                    
                </see>
            </javadoc>
            <method name="get" type="Object" line="823">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="826">
                Maps the specified &lt;code&gt;key&lt;/code&gt; to the specified
                  &lt;code&gt;value&lt;/code&gt; in this &lt;code&gt;RenderingHints&lt;/code&gt; object.
                  Neither the key nor the value can be &lt;code&gt;null&lt;/code&gt;.
                  The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method
                  with a key that is equal to the original key.                
                <param>
                    key     the rendering hint key.                    
                </param>
                <param>
                    value   the rendering hint value.                    
                </param>
                <return>
                    the previous value of the specified key in this object
                      or <code>null</code> if it did not have one.                    
                </return>
                <exception>
                    <code>NullPointerException</code> if the key is
                      <code>null</code>.                    
                </exception>
                <exception>
                    <code>ClassCastException</code> if the key can not
                      be cast to <code>RenderingHints.Key</code>                    
                </exception>
                <exception>
                    <code>IllegalArgumentException</code> if the{@link Key#isCompatibleValue(java.lang.Object)Key.isCompatibleValue()}method of the specified key returns false for the
                      specified value                    
                </exception>
                <see>
                    #get(Object)                    
                </see>
            </javadoc>
            <method name="put" type="Object" line="844">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
                <scope line="845"/>
            </method>
            <javadoc line="850">
                Adds all of the keys and corresponding values from the specified
                  &lt;code&gt;RenderingHints&lt;/code&gt; object to this
                  &lt;code&gt;RenderingHints&lt;/code&gt; object. Keys that are present in
                  this &lt;code&gt;RenderingHints&lt;/code&gt; object, but not in the specified
                  &lt;code&gt;RenderingHints&lt;/code&gt; object are not affected.                
                <param>
                    hints the set of key/value pairs to be added to this
                      <code>RenderingHints</code> object                    
                </param>
            </javadoc>
            <method name="add" type="void" line="859">
                <params>
                    <param name="hints" type="RenderingHints"/>
                </params>
            </method>
            <javadoc line="862">
                Clears this &lt;code&gt;RenderingHints&lt;/code&gt; object of all key/value
                  pairs.                
            </javadoc>
            <method name="clear" type="void" line="866"/>
            <javadoc line="869">
                Removes the key and its corresponding value from this
                  &lt;code&gt;RenderingHints&lt;/code&gt; object. This method does nothing if the
                  key is not in this &lt;code&gt;RenderingHints&lt;/code&gt; object.                
                <param>
                    key   the rendering hints key that needs to be removed                    
                </param>
                <exception>
                    <code>ClassCastException</code> if the key can not
                      be cast to <code>RenderingHints.Key</code>                    
                </exception>
                <return>
                    the value to which the key had previously been mapped in this
                      <code>RenderingHints</code> object, or <code>null</code>
                      if the key did not have a mapping.                    
                </return>
            </javadoc>
            <method name="remove" type="Object" line="880">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="883">
                Copies all of the mappings from the specified &lt;code&gt;Map&lt;/code&gt;
                  to this &lt;code&gt;RenderingHints&lt;/code&gt;.  These mappings replace
                  any mappings that this &lt;code&gt;RenderingHints&lt;/code&gt; had for any
                  of the keys currently in the specified &lt;code&gt;Map&lt;/code&gt;.                
                <param>
                    m the specified <code>Map</code>                    
                </param>
                <exception>
                    <code>ClassCastException</code> class of a key or value
                      in the specified <code>Map</code> prevents it from being
                      stored in this <code>RenderingHints</code>.                    
                </exception>
                <exception>
                    <code>IllegalArgumentException</code> some aspect
                      of a key or value in the specified <code>Map</code>
                      prevents it from being stored in
                      this <code>RenderingHints</code>.                    
                </exception>
            </javadoc>
            <method name="putAll" type="void" line="897">
                <params>
                    <param name="m" type="Map<?,?>"/>
                </params>
                <scope line="898"/>
                <scope line="901"/>
            </method>
            <javadoc line="905">
                Returns a &lt;code&gt;Set&lt;/code&gt; view of the Keys contained in this
                  &lt;code&gt;RenderingHints&lt;/code&gt;.  The Set is backed by the
                  &lt;code&gt;RenderingHints&lt;/code&gt;, so changes to the
                  &lt;code&gt;RenderingHints&lt;/code&gt; are reflected in the &lt;code&gt;Set&lt;/code&gt;,
                  and vice-versa.  If the &lt;code&gt;RenderingHints&lt;/code&gt; is modified
                  while an iteration over the &lt;code&gt;Set&lt;/code&gt; is in progress,
                  the results of the iteration are undefined.  The &lt;code&gt;Set&lt;/code&gt;
                  supports element removal, which removes the corresponding
                  mapping from the &lt;code&gt;RenderingHints&lt;/code&gt;, via the
                  &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Set.remove&lt;/code&gt;,
                  &lt;code&gt;removeAll&lt;/code&gt; &lt;code&gt;retainAll&lt;/code&gt;, and
                  &lt;code&gt;clear&lt;/code&gt; operations.  It does not support
                  the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.                
                <return>
                    a <code>Set</code> view of the keys contained
                      in this <code>RenderingHints</code>.                    
                </return>
            </javadoc>
            <method name="keySet" type="Set<Object>" line="922"/>
            <javadoc line="925">
                Returns a &lt;code&gt;Collection&lt;/code&gt; view of the values
                  contained in this &lt;code&gt;RenderinHints&lt;/code&gt;.
                  The &lt;code&gt;Collection&lt;/code&gt; is backed by the
                  &lt;code&gt;RenderingHints&lt;/code&gt;, so changes to
                  the &lt;code&gt;RenderingHints&lt;/code&gt; are reflected in
                  the &lt;code&gt;Collection&lt;/code&gt;, and vice-versa.
                  If the &lt;code&gt;RenderingHints&lt;/code&gt; is modified while
                  an iteration over the &lt;code&gt;Collection&lt;/code&gt; is
                  in progress, the results of the iteration are undefined.
                  The &lt;code&gt;Collection&lt;/code&gt; supports element removal,
                  which removes the corresponding mapping from the
                  &lt;code&gt;RenderingHints&lt;/code&gt;, via the
                  &lt;code&gt;Iterator.remove&lt;/code&gt;,
                  &lt;code&gt;Collection.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;,
                  &lt;code&gt;retainAll&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations.
                  It does not support the &lt;code&gt;add&lt;/code&gt; or
                  &lt;code&gt;addAll&lt;/code&gt; operations.                
                <return>
                    a <code>Collection</code> view of the values
                      contained in this <code>RenderingHints</code>.                    
                </return>
            </javadoc>
            <method name="values" type="Collection<Object>" line="946"/>
            <javadoc line="949">
                Returns a &lt;code&gt;Set&lt;/code&gt; view of the mappings contained
                  in this &lt;code&gt;RenderingHints&lt;/code&gt;.  Each element in the
                  returned &lt;code&gt;Set&lt;/code&gt; is a &lt;code&gt;Map.Entry&lt;/code&gt;.
                  The &lt;code&gt;Set&lt;/code&gt; is backed by the &lt;code&gt;RenderingHints&lt;/code&gt;,
                  so changes to the &lt;code&gt;RenderingHints&lt;/code&gt; are reflected
                  in the &lt;code&gt;Set&lt;/code&gt;, and vice-versa.  If the
                  &lt;code&gt;RenderingHints&lt;/code&gt; is modified while
                  while an iteration over the &lt;code&gt;Set&lt;/code&gt; is in progress,
                  the results of the iteration are undefined.
                  &lt;p&gt;
                  The entrySet returned from a &lt;code&gt;RenderingHints&lt;/code&gt; object
                  is not modifiable.                
                <return>
                    a <code>Set</code> view of the mappings contained in
                      this <code>RenderingHints</code>.                    
                </return>
            </javadoc>
            <method name="entrySet" type="Set<Map.Entry<Object,Object>>" line="965"/>
            <javadoc line="968">
                Compares the specified &lt;code&gt;Object&lt;/code&gt; with this
                  &lt;code&gt;RenderingHints&lt;/code&gt; for equality.
                  Returns &lt;code&gt;true&lt;/code&gt; if the specified object is also a
                  &lt;code&gt;Map&lt;/code&gt; and the two &lt;code&gt;Map&lt;/code&gt; objects represent
                  the same mappings.  More formally, two &lt;code&gt;Map&lt;/code&gt; objects
                  &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; represent the same mappings
                  if &lt;code&gt;t1.keySet().equals(t2.keySet())&lt;/code&gt; and for every
                  key &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;t1.keySet()&lt;/code&gt;,
                  &lt;pre&gt;
                  (t1.get(k)==null ? t2.get(k)==null : t1.get(k).equals(t2.get(k)))
                  &lt;/pre&gt;.
                  This ensures that the &lt;code&gt;equals&lt;/code&gt; method works properly across
                  different implementations of the &lt;code&gt;Map&lt;/code&gt; interface.                
                <param>
                    o <code>Object</code> to be compared for equality with
                      this <code>RenderingHints</code>.                    
                </param>
                <return>
                    <code>true</code> if the specified <code>Object</code>
                      is equal to this <code>RenderingHints</code>.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="987">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="988"/>
                <scope line="991"/>
            </method>
            <javadoc line="996">
                Returns the hash code value for this &lt;code&gt;RenderingHints&lt;/code&gt;.
                  The hash code of a &lt;code&gt;RenderingHints&lt;/code&gt; is defined to be
                  the sum of the hashCodes of each &lt;code&gt;Entry&lt;/code&gt; in the
                  &lt;code&gt;RenderingHints&lt;/code&gt; object&apos;s entrySet view.  This ensures that
                  &lt;code&gt;t1.equals(t2)&lt;/code&gt; implies that
                  &lt;code&gt;t1.hashCode()==t2.hashCode()&lt;/code&gt; for any two &lt;code&gt;Map&lt;/code&gt;
                  objects &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, as required by the general
                  contract of &lt;code&gt;Object.hashCode&lt;/code&gt;.                
                <return>
                    the hash code value for this <code>RenderingHints</code>.                    
                </return>
                <see>
                    java.util.Map.Entry#hashCode()                    
                </see>
                <see>
                    Object#hashCode()                    
                </see>
                <see>
                    Object#equals(Object)                    
                </see>
                <see>
                    #equals(Object)                    
                </see>
            </javadoc>
            <method name="hashCode" type="int" line="1011"/>
            <javadoc line="1014">
                Creates a clone of this &lt;code&gt;RenderingHints&lt;/code&gt; object
                  that has the same contents as this &lt;code&gt;RenderingHints&lt;/code&gt;
                  object.                
                <return>
                    a clone of this instance.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="1020">
                <declaration name="rh" type="RenderingHints" line="1021"/>
                <scope line="1022">
                    <scope line="1024"/>
                </scope>
                <scope line="1028"/>
            </method>
            <javadoc line="1033">
                Returns a rather long string representation of the hashmap
                  which contains the mappings of keys to values for this
                  &lt;code&gt;RenderingHints&lt;/code&gt; object.                
                <return>
                    a string representation of this object.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1039">
                <scope line="1040"/>
            </method>
        </class>
    </source>