<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.awt.dnd.DropTarget"/>
        <import package="java.awt.event"/>
        <import package="java.awt.peer.ContainerPeer"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.peer.LightweightPeer"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.ObjectStreamField"/>
        <import package="java.io.PrintStream"/>
        <import package="java.io.PrintWriter"/>
        <import package="java.security.AccessController"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.EventListener"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Set"/>
        <import package="javax.accessibility"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.AWTAccessor"/>
        <import package="sun.awt.CausedFocusEvent"/>
        <import package="sun.awt.PeerEvent"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.dnd.SunDropTargetEvent"/>
        <import package="sun.java2d.pipe.Region"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <class name="Container" line="67">
            <extends class="Component"/>
            <comment line="164">
                keeps track of the threads that are printing this component                
            </comment>
            <comment line="166">
                True if there is at least one thread that&apos;s printing this component                
            </comment>
            <comment line="171">
                                
            </comment>
            <comment line="176">
                                
            </comment>
            <comment line="203">
                Number of HW or LW components in this container (including
                 all descendant containers).                
            </comment>
            <comment line="347">
                NOTE: This method may be called by privileged threads.
                       This functionality is implemented in a package-private method
                       to insure that it cannot be overridden by client subclasses.
                       DO NOT INVOKE CLIENT CODE ON THIS THREAD!                
            </comment>
            <comment line="355">
                Wrapper for getComponents() method with a proper synchronization.                
            </comment>
            <comment line="1319">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1356">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1381">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1390">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1397">
                Should only be called while holding tree lock                
            </comment>
            <comment line="2199">
                REMIND: remove when filtering is done at lower level                
            </comment>
            <comment line="2265">
                Dispatches an event to this component or one of its sub components.
                 Create ANCESTOR_RESIZED and ANCESTOR_MOVED events in response to
                 COMPONENT_RESIZED and COMPONENT_MOVED events. We have to do this
                 here instead of in processComponentEvent because ComponentEvents
                 may not be enabled for this Container.
                 @param e the event                
            </comment>
            <comment line="2306">
                Dispatches an event to this component, without trying to forward
                 it to any subcomponents
                 @param e the event                
            </comment>
            <comment line="2843">
                The following code was added to support modal JInternalFrames
                 Unfortunately this code has to be added here so that we can get access to
                 some private AWT classes like SequencedEvent.
                
                 The native container of the LW component has this field set
                 to tell it that it should block Mouse events for all LW
                 children except for the modal component.
                
                 In the case of nested Modal components, we store the previous
                 modal component in the new modal components value of modalComp;                
            </comment>
            <comment line="2969">
                                
            </comment>
            <comment line="3638">
                Serialization support. A Container is responsible for restoring the
                 parent fields of its component children.                
            </comment>
            <comment line="3769">
                --- Accessibility Support ---                
            </comment>
            <comment line="3866">
                inner class AccessibleAWTContainer                
            </comment>
            <comment line="3974">
                ************************** MIXING CODE *******************************                
            </comment>
            <comment line="4048">
                This method is overriden to handle opaque children in non-opaque
                 containers.                
            </comment>
            <comment line="4349">
                ****************** END OF MIXING CODE ********************************                
            </comment>
            <comment line="4365">
                JDK 1.1 serialVersionUID                
            </comment>
            <comment line="4369">
                Our own mouse event for when we&apos;re dragged over from another hw
                 container                
            </comment>
            <comment line="4383">
                Clean up any resources allocated when dispatcher was created;
                 should be called from Container.removeNotify                
            </comment>
            <comment line="4434">
                This method effectively returns whether or not a mouse button was down
                 just BEFORE the event happened.  A better method name might be
                 wasAMouseButtonDownBeforeThisEvent().                
            </comment>
            <comment line="4575">
                Generates enterexit events as mouse moves over lw components
                 @param targetOver        Target mouse is over (including native container)
                 @param e                 Mouse event in native container                
            </comment>
            <comment line="4631">
                Listens to global mouse drag events so even drags originating
                 from other heavyweight containers will generate enterexit
                 events in this container                
            </comment>
            <comment line="4663">
                (Implementation of AWTEventListener)
                 Listen for drag events posted in other hw components so we can
                 track enterexit regardless of where a drag originated                
            </comment>
            <comment line="4845">
                --- member variables -------------------------------                
            </comment>
            <javadoc line="67">
                A generic Abstract Window Toolkit(AWT) container object is a component
                  that can contain other AWT components.
                  &lt;p&gt;
                  Components added to a container are tracked in a list.  The order
                  of the list will define the components&apos; front-to-back stacking order
                  within the container.  If no index is specified when adding a
                  component to a container, it will be added to the end of the list
                  (and hence to the bottom of the stacking order).
                  &lt;p&gt;
                  &lt;b&gt;Note&lt;/b&gt;: For details on the focus subsystem, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                  &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
                  for more information.                
                <author>
                    Arthur van Hoff                    
                </author>
                <author>
                    Sami Shaio                    
                </author>
                <see>
                    #add(java.awt.Component,int)                    
                </see>
                <see>
                    #getComponent(int)                    
                </see>
                <see>
                    LayoutManager                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="log" type="PlatformLogger" line="93"/>
            <declaration name="eventLog" type="PlatformLogger" line="94"/>
            <declaration name="EMPTY_ARRAY" type="Component[]" line="96"/>
            <declaration name="component" type="java.util.List&lt;Component&gt;" line="98"/>
            <javadoc line="98">
                The components in this container.                
                <see>
                    #add                    
                </see>
                <see>
                    #getComponents                    
                </see>
            </javadoc>
            <declaration name="layoutMgr" type="LayoutManager" line="105"/>
            <javadoc line="105">
                Layout manager for this container.                
                <see>
                    #doLayout                    
                </see>
                <see>
                    #setLayout                    
                </see>
                <see>
                    #getLayout                    
                </see>
            </javadoc>
            <declaration name="dispatcher" type="LightweightDispatcher" line="113"/>
            <javadoc line="113">
                Event router for lightweight components.  If this container
                  is native, this dispatcher takes care of forwarding and
                  retargeting the events to lightweight components contained
                  (if any).                
            </javadoc>
            <declaration name="focusTraversalPolicy" type="FocusTraversalPolicy" line="121"/>
            <javadoc line="121">
                The focus traversal policy that will manage keyboard traversal of this
                  Container&apos;s children, if this Container is a focus cycle root. If the
                  value is null, this Container inherits its policy from its focus-cycle-
                  root ancestor. If all such ancestors of this Container have null
                  policies, then the current KeyboardFocusManager&apos;s default policy is
                  used. If the value is non-null, this policy will be inherited by all
                  focus-cycle-root children that have no keyboard-traversal policy of
                  their own (as will, recursively, their focus-cycle-root children).
                  &lt;p&gt;
                  If this Container is not a focus cycle root, the value will be
                  remembered, but will not be used or inherited by this or any other
                  Containers until this Container is made a focus cycle root.                
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="focusCycleRoot" type="boolean" line="141"/>
            <javadoc line="141">
                Indicates whether this Component is the root of a focus traversal cycle.
                  Once focus enters a traversal cycle, typically it cannot leave it via
                  focus traversal unless one of the up- or down-cycle keys is pressed.
                  Normal traversal is limited to this Container, and all of this
                  Container&apos;s descendants that are not descendants of inferior focus cycle
                  roots.                
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #isFocusCycleRoot                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="focusTraversalPolicyProvider" type="boolean" line="156"/>
            <javadoc line="156">
                Stores the value of focusTraversalPolicyProvider property.                
                <since>
                    1.5                    
                </since>
                <see>
                    #setFocusTraversalPolicyProvider                    
                </see>
            </javadoc>
            <declaration name="printingThreads" type="Set" line="164"/>
            <declaration name="printing" type="boolean" line="166"/>
            <declaration name="containerListener" type="ContainerListener" line="168"/>
            <declaration name="listeningChildren" type="int" line="171"/>
            <declaration name="listeningBoundsChildren" type="int" line="172"/>
            <declaration name="descendantsCount" type="int" line="173"/>
            <declaration name="preserveBackgroundColor" type="Color" line="176"/>
            <declaration name="serialVersionUID" type="long" line="178"/>
            <javadoc line="178">
                JDK 1.1 serialVersionUID                
            </javadoc>
            <declaration name="INCLUDE_SELF" type="boolean" line="183"/>
            <javadoc line="183">
                A constant which toggles one of the controllable behaviors
                  of &lt;code&gt;getMouseEventTarget&lt;/code&gt;. It is used to specify whether
                  the method can return the Container on which it is originally called
                  in case if none of its children are the current mouse event targets.                
                <see>
                    #getMouseEventTarget(int,int,boolean,boolean,boolean)                    
                </see>
            </javadoc>
            <declaration name="SEARCH_HEAVYWEIGHTS" type="boolean" line="193"/>
            <javadoc line="193">
                A constant which toggles one of the controllable behaviors
                  of &lt;code&gt;getMouseEventTarget&lt;/code&gt;. It is used to specify whether
                  the method should search only lightweight components.                
                <see>
                    #getMouseEventTarget(int,int,boolean,boolean,boolean)                    
                </see>
            </javadoc>
            <declaration name="numOfHWComponents" type="int" line="206"/>
            <declaration name="numOfLWComponents" type="int" line="207"/>
            <declaration name="mixingLog" type="PlatformLogger" line="209"/>
            <declaration name="serialPersistentFields" type="ObjectStreamField[]" line="211"/>
            <javadoc line="211">
                @serialField ncomponents                     int
                  The number of components in this container.
                  This value can be null.                
                <serialField>
                    component                       Component[]
                      The components in this container.                    
                </serialField>
                <serialField>
                    layoutMgr                       LayoutManager
                      Layout manager for this container.                    
                </serialField>
                <serialField>
                    dispatcher                      LightweightDispatcher
                      Event router for lightweight components.  If this container
                      is native, this dispatcher takes care of forwarding and
                      retargeting the events to lightweight components contained
                      (if any).                    
                </serialField>
                <serialField>
                    maxSize                         Dimension
                      Maximum size of this Container.                    
                </serialField>
                <serialField>
                    focusCycleRoot                  boolean
                      Indicates whether this Component is the root of a focus traversal cycle.
                      Once focus enters a traversal cycle, typically it cannot leave it via
                      focus traversal unless one of the up- or down-cycle keys is pressed.
                      Normal traversal is limited to this Container, and all of this
                      Container's descendants that are not descendants of inferior focus cycle
                      roots.                    
                </serialField>
                <serialField>
                    containerSerializedDataVersion  int
                      Container Serial Data Version.                    
                </serialField>
                <serialField>
                    focusTraversalPolicyProvider    boolean
                      Stores the value of focusTraversalPolicyProvider property.                    
                </serialField>
            </javadoc>
            <scope line="249">
                <scope line="252"/>
                <anonymous_class line="256">
                    <method name="validateUnconditionally" type="void" line="258">
                        <params>
                            <param name="cont" type="Container"/>
                        </params>
                    </method>
                </anonymous_class>
            </scope>
            <method name="initIDs" type="void" line="264"/>
            <javadoc line="264">
                Initialize JNI field and method IDs for fields that may be
                  called from C.                
            </javadoc>
            <javadoc line="270">
                Constructs a new Container. Containers can be extended directly,
                  but are lightweight in this case and must be contained by a parent
                  somewhere higher up in the component tree that is native.
                  (such as Frame for example).                
            </javadoc>
            <method name="Container" type="constructor" line="276"/>
            <method name="initializeFocusTraversalKeys" type="void" line="279"/>
            <javadoc line="283">
                Gets the number of components in this panel.
                  &lt;p&gt;
                  Note: This method should be called under AWT tree lock.                
                <return>
                    the number of components in this panel.                    
                </return>
                <see>
                    #getComponent                    
                </see>
                <since>
                    JDK1.1                    
                </since>
                <see>
                    Component#getTreeLock()                    
                </see>
            </javadoc>
            <method name="getComponentCount" type="int" line="293"/>
            <javadoc line="297">
                @deprecated As of JDK version 1.1,
                  replaced by getComponentCount().                
            </javadoc>
            <method name="countComponents" type="int" line="302">
                <comment line="304">
                    This method is not synchronized under AWT tree lock.
                     Instead, the calling code is responsible for the
                     synchronization. See 6784816 for details.                    
                </comment>
            </method>
            <javadoc line="309">
                Gets the nth component in this container.
                  &lt;p&gt;
                  Note: This method should be called under AWT tree lock.                
                <param>
                    n   the index of the component to get.                    
                </param>
                <return>
                    the n<sup>th</sup> component in this container.                    
                </return>
                <exception>
                    ArrayIndexOutOfBoundsExceptionif the n<sup>th</sup> value does not exist.                    
                </exception>
                <see>
                    Component#getTreeLock()                    
                </see>
            </javadoc>
            <method name="getComponent" type="Component" line="320">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="322">
                    This method is not synchronized under AWT tree lock.
                     Instead, the calling code is responsible for the
                     synchronization. See 6784816 for details.                    
                </comment>
                <scope line="324"/>
                <scope line="326"/>
            </method>
            <javadoc line="331">
                Gets all the components in this container.
                  &lt;p&gt;
                  Note: This method should be called under AWT tree lock.                
                <return>
                    an array of all the components in this container.                    
                </return>
                <see>
                    Component#getTreeLock()                    
                </see>
            </javadoc>
            <method name="getComponents" type="Component[]" line="339">
                <comment line="341">
                    This method is not synchronized under AWT tree lock.
                     Instead, the calling code is responsible for the
                     synchronization. See 6784816 for details.                    
                </comment>
            </method>
            <method name="getComponents_NoClientCode" type="Component[]" line="350"/>
            <method name="getComponentsSync" type="Component[]" line="357">
                <scope line="358"/>
            </method>
            <javadoc line="363">
                Determines the insets of this container, which indicate the size
                  of the container&apos;s border.
                  &lt;p&gt;
                  A &lt;code&gt;Frame&lt;/code&gt; object, for example, has a top inset that
                  corresponds to the height of the frame&apos;s title bar.                
                <return>
                    the insets of this container.                    
                </return>
                <see>
                    Insets                    
                </see>
                <see>
                    LayoutManager                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getInsets" type="Insets" line="374"/>
            <javadoc line="378">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;getInsets()&lt;/code&gt;.                
            </javadoc>
            <method name="insets" type="Insets" line="383">
                <declaration name="peer" type="ComponentPeer" line="384"/>
                <scope line="385">
                    <declaration name="cpeer" type="ContainerPeer" line="386"/>
                </scope>
            </method>
            <javadoc line="392">
                Appends the specified component to the end of this container.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp   the component to be added                    
                </param>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <see>
                    #addImpl                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
                <return>
                    the component argument                    
                </return>
            </javadoc>
            <method name="add" type="Component" line="409">
                <params>
                    <param name="comp" type="Component"/>
                </params>
            </method>
            <javadoc line="414">
                Adds the specified component to this container.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method is obsolete as of 1.1.  Please use the
                  method &lt;code&gt;add(Component, Object)&lt;/code&gt; instead.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <see>
                    #add(Component,Object)                    
                </see>
                <see>
                    #invalidate                    
                </see>
            </javadoc>
            <method name="add" type="Component" line="430">
                <params>
                    <param name="name" type="String"/>
                    <param name="comp" type="Component"/>
                </params>
            </method>
            <javadoc line="435">
                Adds the specified component to this container at the given
                  position.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp   the component to be added                    
                </param>
                <param>
                    index    the position at which to insert the component,
                      or <code>-1</code> to append the component to the end                    
                </param>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <exception>
                    IllegalArgumentException if {@code index} is invalid (see{@link #addImpl} for details)                    
                </exception>
                <return>
                    the component <code>comp</code>                    
                </return>
                <see>
                    #addImpl                    
                </see>
                <see>
                    #remove                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
            </javadoc>
            <method name="add" type="Component" line="459">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="464">
                Checks that the component
                  isn&apos;t supposed to be added into itself.                
            </javadoc>
            <method name="checkAddToSelf" type="void" line="468">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="469">
                    <scope line="470">
                        <scope line="471"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="478">
                Checks that the component is not a Window instance.                
            </javadoc>
            <method name="checkNotAWindow" type="void" line="481">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="482"/>
            </method>
            <javadoc line="487">
                Checks that the component comp can be added to this container
                  Checks :  index in bounds of container&apos;s size,
                  comp is not one of this container&apos;s parents,
                  and comp is not a window.
                  Comp and container must be on the same GraphicsDevice.
                  if comp is container, all sub-components must be on
                  same GraphicsDevice.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="checkAdding" type="void" line="498">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="index" type="int"/>
                </params>
                <declaration name="thisGC" type="GraphicsConfiguration" line="501"/>
                <scope line="503"/>
                <scope line="506">
                    <scope line="507"/>
                </scope>
                <declaration name="thisTopLevel" type="Window" line="515"/>
                <declaration name="compTopLevel" type="Window" line="516"/>
                <scope line="517"/>
                <scope line="520"/>
            </method>
            <javadoc line="525">
                Removes component comp from this container without making unneccessary changes
                  and generating unneccessary events. This function intended to perform optimized
                  remove, for example, if newParent and current parent are the same it just changes
                  index without calling removeNotify.
                  Note: Should be called while holding treeLock
                  Returns whether removeNotify was invoked                
                <since>
                    : 1.5                    
                </since>
            </javadoc>
            <method name="removeDelicately" type="boolean" line="534">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="newParent" type="Container"/>
                    <param name="newIndex" type="int"/>
                </params>
                <comment line="561">
                    We should remove component and then
                     add it by the newIndex without newIndex decrement if even we shift components to the left
                     after remove. Consult the rules below:
                     2-&gt;4: 012345 -&gt; 013425, 2-&gt;5: 012345 -&gt; 013452
                     4-&gt;2: 012345 -&gt; 014235                    
                </comment>
                <comment line="569">
                    was actually removed                    
                </comment>
                <declaration name="index" type="int" line="537"/>
                <declaration name="needRemoveNotify" type="boolean" line="538"/>
                <scope line="539"/>
                <scope line="542">
                    <scope line="543"/>
                    <scope line="553"/>
                </scope>
                <scope line="559"/>
                <scope line="568">
                    <scope line="571">
                        <declaration name="e" type="ContainerEvent" line="572"/>
                    </scope>
                    <scope line="581"/>
                </scope>
            </method>
            <javadoc line="588">
                Checks whether this container can contain component which is focus owner.
                  Verifies that container is enable and showing, and if it is focus cycle root
                  its FTP allows component to be focus owner                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="canContainFocusOwner" type="boolean" line="594">
                <params>
                    <param name="focusOwnerCandidate" type="Component"/>
                </params>
                <scope line="597"/>
                <scope line="600">
                    <declaration name="policy" type="FocusTraversalPolicy" line="601"/>
                    <scope line="602">
                        <scope line="603"/>
                    </scope>
                </scope>
                <scope line="608">
                    <scope line="609"/>
                </scope>
            </method>
            <javadoc line="616">
                Checks whether or not this container has heavyweight children.
                  Note: Should be called while holding tree lock                
                <return>
                    true if there is at least one heavyweight children in a container, false otherwise                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hasHeavyweightDescendants" type="boolean" line="622"/>
            <javadoc line="627">
                Checks whether or not this container has lightweight children.
                  Note: Should be called while holding tree lock                
                <return>
                    true if there is at least one lightweight children in a container, false otherwise                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="hasLightweightDescendants" type="boolean" line="633"/>
            <javadoc line="638">
                Returns closest heavyweight component to this container. If this container is heavyweight
                  returns this.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getHeavyweightContainer" type="Container" line="643">
                <scope line="645"/>
                <scope line="647"/>
            </method>
            <javadoc line="652">
                Detects whether or not remove from current parent and adding to new parent requires call of
                  removeNotify on the component. Since removeNotify destroys native window this might (not)
                  be required. For example, if new container and old containers are the same we don&apos;t need to
                  destroy native window.                
                <since>
                    : 1.5                    
                </since>
            </javadoc>
            <method name="isRemoveNotifyNeeded" type="boolean" line="659">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="oldContainer" type="Container"/>
                    <param name="newContainer" type="Container"/>
                </params>
                <comment line="661">
                    Component didn&apos;t have parent - no removeNotify                    
                </comment>
                <comment line="664">
                    Component didn&apos;t have peer - no removeNotify                    
                </comment>
                <comment line="668">
                    Component has peer but new Container doesn&apos;t - call removeNotify                    
                </comment>
                <comment line="672">
                    If component is lightweight non-Container or lightweight Container with all but heavyweight
                     children there is no need to call remove notify                    
                </comment>
                <comment line="682">
                    If this point is reached, then the comp is either a HW or a LW container with HW descendants.                    
                </comment>
                <comment line="684">
                    All three components have peers, check for peer change                    
                </comment>
                <comment line="688">
                    Native containers change - check whether or not current platform supports
                     changing of widget hierarchy on native level without recreation.
                     The current implementation forbids reparenting of LW containers with HW descendants
                     into another native container w/o destroying the peers. Actually such an operation
                     is quite rare. If we ever need to save the peers, we&apos;ll have to slightly change the
                     addDelicately() method in order to handle such LW containers recursively, reparenting
                     each HW descendant independently.                    
                </comment>
                <scope line="660"/>
                <scope line="663"/>
                <scope line="666"/>
                <scope line="673">
                    <declaration name="isContainer" type="boolean" line="674"/>
                    <scope line="676"/>
                </scope>
                <declaration name="newNativeContainer" type="Container" line="684"/>
                <declaration name="oldNativeContainer" type="Container" line="685"/>
                <scope line="686"/>
                <scope line="695"/>
            </method>
            <javadoc line="700">
                Moves the specified component to the specified z-order index in
                  the container. The z-order determines the order that components
                  are painted; the component with the highest z-order paints first
                  and the component with the lowest z-order paints last.
                  Where components overlap, the component with the lower
                  z-order paints over the component with the higher z-order.
                  &lt;p&gt;
                  If the component is a child of some other container, it is
                  removed from that container before being added to this container.
                  The important difference between this method and
                  &lt;code&gt;java.awt.Container.add(Component, int)&lt;/code&gt; is that this method
                  doesn&apos;t call &lt;code&gt;removeNotify&lt;/code&gt; on the component while
                  removing it from its previous container unless necessary and when
                  allowed by the underlying native windowing system. This way, if the
                  component has the keyboard focus, it maintains the focus when
                  moved to the new position.
                  &lt;p&gt;
                  This property is guaranteed to apply only to lightweight
                  non-&lt;code&gt;Container&lt;/code&gt; components.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy.
                  &lt;p&gt;
                  &lt;b&gt;Note&lt;/b&gt;: Not all platforms support changing the z-order of
                  heavyweight components from one container into another without
                  the call to &lt;code&gt;removeNotify&lt;/code&gt;. There is no way to detect
                  whether a platform supports this, so developers shouldn&apos;t make
                  any assumptions.                
                <param>
                    comp the component to be moved                    
                </param>
                <param>
                    index the position in the container's list to
                      insert the component, where <code>getComponentCount()</code>
                      appends to the end                    
                </param>
                <exception>
                    NullPointerException if <code>comp</code> is
                      <code>null</code>                    
                </exception>
                <exception>
                    IllegalArgumentException if <code>comp</code> is one of the
                      container's parents                    
                </exception>
                <exception>
                    IllegalArgumentException if <code>index</code> is not in
                      the range <code>[0, getComponentCount()]</code> for moving
                      between containers, or not in the range
                      <code>[0, getComponentCount()-1]</code> for moving inside
                      a container                    
                </exception>
                <exception>
                    IllegalArgumentException if adding a container to itself                    
                </exception>
                <exception>
                    IllegalArgumentException if adding a <code>Window</code>
                      to a container                    
                </exception>
                <see>
                    #getComponentZOrder(java.awt.Component)                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setComponentZOrder" type="void" line="750">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="index" type="int"/>
                </params>
                <comment line="753">
                    Store parent because remove will clear it                    
                </comment>
                <comment line="767">
                    If the oldZindex == -1, the component gets inserted,
                     rather than it changes its z-order.                    
                </comment>
                <comment line="770">
                    The new &apos;index&apos; cannot be == -1.
                     It gets checked at the checkAdding() method.
                     Therefore both oldZIndex and index denote
                     some existing positions at this point and
                     this is actually a Z-order changing.                    
                </comment>
                <scope line="751">
                    <declaration name="curParent" type="Container" line="753"/>
                    <declaration name="oldZindex" type="int" line="754"/>
                    <scope line="756"/>
                    <declaration name="peerRecreated" type="boolean" line="761"/>
                    <scope line="768"/>
                </scope>
            </method>
            <javadoc line="779">
                Traverses the tree of components and reparents children heavyweight component
                  to new heavyweight parent.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="reparentTraverse" type="void" line="784">
                <params>
                    <param name="parentPeer" type="ContainerPeer"/>
                    <param name="child" type="Container"/>
                </params>
                <comment line="791">
                    If components is lightweight check if it is container
                     If it is container it might contain heavyweight children we need to reparent                    
                </comment>
                <comment line="797">
                    Q: Need to update NativeInLightFixer?                    
                </comment>
                <scope line="787">
                    <declaration name="comp" type="Component" line="788"/>
                    <scope line="789">
                        <scope line="792"/>
                    </scope>
                    <scope line="795"/>
                </scope>
            </method>
            <javadoc line="802">
                Reparents child component peer to this container peer.
                  Container must be heavyweight.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="reparentChild" type="void" line="807">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <comment line="814">
                    If component is lightweight container we need to reparent all its explicit  heavyweight children                    
                </comment>
                <comment line="816">
                    Traverse component&apos;s tree till depth-first until encountering heavyweight component                    
                </comment>
                <scope line="809"/>
                <scope line="812">
                    <scope line="814"/>
                </scope>
                <scope line="818"/>
            </method>
            <javadoc line="823">
                Adds component to this container. Tries to minimize side effects of this adding -
                  doesn&apos;t call remove notify if it is not required.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="addDelicately" type="void" line="828">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="curParent" type="Container"/>
                    <param name="index" type="int"/>
                </params>
                <comment line="832">
                    Check if moving between containers                    
                </comment>
                <comment line="834">
                    index == -1 means add to the end.                    
                </comment>
                <comment line="856">
                    Remove notify was called or it didn&apos;t have peer - create new one                    
                </comment>
                <comment line="858">
                    Both container and child have peers, it means child peer should be reparented.                    
                </comment>
                <comment line="859">
                    In both cases we need to reparent native widgets.                    
                </comment>
                <comment line="863">
                    Native container changed - need to reparent native widgets                    
                </comment>
                <comment line="869">
                    If component is heavyweight and one of the containers is lightweight
                     the location of the component should be fixed.                    
                </comment>
                <comment line="876">
                                        
                </comment>
                <comment line="896">
                    If component is focus owner or parent container of focus owner check that after reparenting
                     focus owner moved out if new container prohibit this kind of focus owner.                    
                </comment>
                <scope line="832">
                    <scope line="834"/>
                    <scope line="836"/>
                </scope>
                <scope line="847">
                    <scope line="848"/>
                </scope>
                <scope line="854">
                    <scope line="855"/>
                    <scope line="857">
                        <declaration name="newNativeContainer" type="Container" line="859"/>
                        <declaration name="oldNativeContainer" type="Container" line="860"/>
                        <scope line="861"/>
                        <scope line="867"/>
                    </scope>
                </scope>
                <scope line="874">
                    <scope line="876">
                        <scope line="877"/>
                        <scope line="879"/>
                    </scope>
                    <scope line="885">
                        <declaration name="e" type="ContainerEvent" line="886"/>
                    </scope>
                    <scope line="897"/>
                    <scope line="899">
                        <declaration name="focusOwner" type="Component" line="900"/>
                        <scope line="901"/>
                    </scope>
                </scope>
                <scope line="905"/>
                <scope line="911"/>
            </method>
            <javadoc line="916">
                Returns the z-order index of the component inside the container.
                  The higher a component is in the z-order hierarchy, the lower
                  its index.  The component with the lowest z-order index is
                  painted last, above all other child components.                
                <param>
                    comp the component being queried                    
                </param>
                <return>
                    the z-order index of the component; otherwise
                      returns -1 if the component is <code>null</code>
                      or doesn't belong to the container                    
                </return>
                <see>
                    #setComponentZOrder(java.awt.Component,int)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getComponentZOrder" type="int" line="929">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <comment line="935">
                    Quick check - container should be immediate parent of the component                    
                </comment>
                <scope line="930"/>
                <scope line="933">
                    <scope line="935"/>
                </scope>
            </method>
            <javadoc line="942">
                Adds the specified component to the end of this container.
                  Also notifies the layout manager to add the component to
                  this container&apos;s layout using the specified constraints object.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp the component to be added                    
                </param>
                <param>
                    constraints an object expressing
                      layout contraints for this component                    
                </param>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <see>
                    #addImpl                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
                <see>
                    LayoutManager                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="add" type="void" line="965">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="constraints" type="Object"/>
                </params>
            </method>
            <javadoc line="969">
                Adds the specified component to this container with the specified
                  constraints at the specified index.  Also notifies the layout
                  manager to add the component to the this container&apos;s layout using
                  the specified constraints object.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp the component to be added                    
                </param>
                <param>
                    constraints an object expressing layout contraints for this                    
                </param>
                <param>
                    index the position in the container's list at which to insert
                      the component; <code>-1</code> means insert at the end
                      component                    
                </param>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <exception>
                    IllegalArgumentException if {@code index} is invalid (see{@link #addImpl} for details)                    
                </exception>
                <see>
                    #addImpl                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
                <see>
                    #remove                    
                </see>
                <see>
                    LayoutManager                    
                </see>
            </javadoc>
            <method name="add" type="void" line="997">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="constraints" type="Object"/>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="1001">
                Adds the specified component to this container at the specified
                  index. This method also notifies the layout manager to add
                  the component to this container&apos;s layout using the specified
                  constraints object via the &lt;code&gt;addLayoutComponent&lt;/code&gt;
                  method.
                  &lt;p&gt;
                  The constraints are
                  defined by the particular layout manager being used.  For
                  example, the &lt;code&gt;BorderLayout&lt;/code&gt; class defines five
                  constraints: &lt;code&gt;BorderLayout.NORTH&lt;/code&gt;,
                  &lt;code&gt;BorderLayout.SOUTH&lt;/code&gt;, &lt;code&gt;BorderLayout.EAST&lt;/code&gt;,
                  &lt;code&gt;BorderLayout.WEST&lt;/code&gt;, and &lt;code&gt;BorderLayout.CENTER&lt;/code&gt;.
                  &lt;p&gt;
                  The &lt;code&gt;GridBagLayout&lt;/code&gt; class requires a
                  &lt;code&gt;GridBagConstraints&lt;/code&gt; object.  Failure to pass
                  the correct type of constraints object results in an
                  &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
                  &lt;p&gt;
                  If the current layout manager implements {@code LayoutManager2}, then{@link LayoutManager2#addLayoutComponent(Component,Object)} is invoked on
                  it. If the current layout manager does not implement{@code LayoutManager2}, and constraints is a {@code String}, then{@link LayoutManager#addLayoutComponent(String,Component)} is invoked on it.
                  &lt;p&gt;
                  If the component is not an ancestor of this container and has a non-null
                  parent, it is removed from its current parent before it is added to this
                  container.
                  &lt;p&gt;
                  This is the method to override if a program needs to track
                  every add request to a container as all other add methods defer
                  to this one. An overriding method should
                  usually include a call to the superclass&apos;s version of the method:
                  &lt;p&gt;
                  &lt;blockquote&gt;
                  &lt;code&gt;super.addImpl(comp, constraints, index)&lt;/code&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp       the component to be added                    
                </param>
                <param>
                    constraints an object expressing layout constraints
                      for this component                    
                </param>
                <param>
                    index the position in the container's list at which to
                      insert the component, where <code>-1</code>
                      means append to the end                    
                </param>
                <exception>
                    IllegalArgumentException if {@code index} is invalid;
                      if {@code comp} is a child of this container, the valid
                      range is {@code [-1, getComponentCount()-1]}; if component is
                      not a child of this container, the valid range is{@code [-1, getComponentCount()]}                    
                </exception>
                <exception>
                    IllegalArgumentException if {@code comp} is an ancestor of
                      this container                    
                </exception>
                <exception>
                    IllegalArgumentException if adding a window to a container                    
                </exception>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <see>
                    #add(Component)                    
                </see>
                <see>
                    #add(Component,int)                    
                </see>
                <see>
                    #add(Component,java.lang.Object)                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    LayoutManager                    
                </see>
                <see>
                    LayoutManager2                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="addImpl" type="void" line="1068">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="constraints" type="Object"/>
                    <param name="index" type="int"/>
                </params>
                <comment line="1071">
                    Check for correct arguments:  index in bounds,
                     comp cannot be one of this container&apos;s parents,
                     and comp cannot be a window.
                     comp and container must be on the same GraphicsDevice.
                     if comp is container, all sub-components must be on
                     same GraphicsDevice.                    
                </comment>
                <comment line="1090">
                                        
                </comment>
                <comment line="1098">
                    index == -1 means add to the end.                    
                </comment>
                <comment line="1118">
                                        
                </comment>
                <scope line="1069">
                    <declaration name="thisGC" type="GraphicsConfiguration" line="1077"/>
                    <scope line="1079"/>
                    <scope line="1085"/>
                    <scope line="1090">
                        <scope line="1092"/>
                    </scope>
                    <scope line="1098"/>
                    <scope line="1100"/>
                    <scope line="1113"/>
                    <scope line="1118">
                        <scope line="1119"/>
                        <scope line="1121"/>
                    </scope>
                    <scope line="1127">
                        <declaration name="e" type="ContainerEvent" line="1128"/>
                    </scope>
                    <scope line="1137"/>
                </scope>
            </method>
            <method name="updateGraphicsData" type="boolean" line="1144">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <declaration name="ret" type="boolean" line="1147"/>
                <scope line="1149">
                    <scope line="1150"/>
                </scope>
            </method>
            <javadoc line="1157">
                Checks that all Components that this Container contains are on
                  the same GraphicsDevice as this Container.  If not, throws an
                  IllegalArgumentException.                
            </javadoc>
            <method name="checkGD" type="void" line="1162">
                <params>
                    <param name="stringID" type="String"/>
                </params>
                <scope line="1163">
                    <scope line="1164"/>
                </scope>
            </method>
            <javadoc line="1170">
                Removes the component, specified by &lt;code&gt;index&lt;/code&gt;,
                  from this container.
                  This method also notifies the layout manager to remove the
                  component from this container&apos;s layout via the
                  &lt;code&gt;removeLayoutComponent&lt;/code&gt; method.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  reflect the changes.                
                <param>
                    index   the index of the component to be removed                    
                </param>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code index} is not in
                      range {@code [0, getComponentCount()-1]}                    
                </throws>
                <see>
                    #add                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    #getComponentCount                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="remove" type="void" line="1192">
                <params>
                    <param name="index" type="int"/>
                </params>
                <scope line="1193">
                    <scope line="1194"/>
                    <declaration name="comp" type="Component" line="1197"/>
                    <scope line="1198"/>
                    <scope line="1201"/>
                    <scope line="1218">
                        <declaration name="e" type="ContainerEvent" line="1219"/>
                    </scope>
                    <scope line="1228"/>
                </scope>
            </method>
            <javadoc line="1234">
                Removes the specified component from this container.
                  This method also notifies the layout manager to remove the
                  component from this container&apos;s layout via the
                  &lt;code&gt;removeLayoutComponent&lt;/code&gt; method.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  reflect the changes.                
                <param>
                    comp the component to be removed                    
                </param>
                <throws>
                    NullPointerException if {@code comp} is {@code null}                    
                </throws>
                <see>
                    #add                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    #remove(int)                    
                </see>
            </javadoc>
            <method name="remove" type="void" line="1252">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="1253">
                    <scope line="1254">
                        <declaration name="index" type="int" line="1255"/>
                        <scope line="1256"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1263">
                Removes all the components from this container.
                  This method also notifies the layout manager to remove the
                  components from this container&apos;s layout via the
                  &lt;code&gt;removeLayoutComponent&lt;/code&gt; method.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  reflect the changes.                
                <see>
                    #add                    
                </see>
                <see>
                    #remove                    
                </see>
                <see>
                    #invalidate                    
                </see>
            </javadoc>
            <method name="removeAll" type="void" line="1278">
                <scope line="1279">
                    <scope line="1286">
                        <declaration name="comp" type="Component" line="1287"/>
                        <scope line="1289"/>
                        <scope line="1292"/>
                        <scope line="1299">
                            <declaration name="e" type="ContainerEvent" line="1300"/>
                        </scope>
                    </scope>
                    <scope line="1311"/>
                </scope>
            </method>
            <method name="numListening" type="int" line="1319">
                <params>
                    <param name="mask" type="long"/>
                </params>
                <comment line="1325">
                    Verify listeningChildren is correct                    
                </comment>
                <comment line="1337">
                    Verify listeningBoundsChildren is correct                    
                </comment>
                <comment line="1348">
                    assert false;                    
                </comment>
                <declaration name="superListening" type="int" line="1320"/>
                <scope line="1322">
                    <scope line="1323">
                        <declaration name="sum" type="int" line="1325"/>
                        <scope line="1326"/>
                        <scope line="1329"/>
                    </scope>
                </scope>
                <scope line="1334">
                    <scope line="1335">
                        <declaration name="sum" type="int" line="1337"/>
                        <scope line="1338"/>
                        <scope line="1341"/>
                    </scope>
                </scope>
                <scope line="1346">
                    <scope line="1348"/>
                </scope>
            </method>
            <method name="adjustListeningChildren" type="void" line="1356">
                <params>
                    <param name="mask" type="long"/>
                    <param name="num" type="int"/>
                </params>
                <scope line="1357">
                    <declaration name="toAssert" type="boolean" line="1358"/>
                    <scope line="1362"/>
                </scope>
                <scope line="1370"/>
                <scope line="1373"/>
            </method>
            <method name="adjustDescendants" type="void" line="1381">
                <params>
                    <param name="num" type="int"/>
                </params>
            </method>
            <method name="adjustDecendantsOnParent" type="void" line="1390">
                <params>
                    <param name="num" type="int"/>
                </params>
                <scope line="1391"/>
            </method>
            <method name="countHierarchyMembers" type="int" line="1397">
                <comment line="1400">
                    Verify descendantsCount is correct                    
                </comment>
                <scope line="1398">
                    <declaration name="sum" type="int" line="1400"/>
                    <scope line="1401"/>
                    <scope line="1404"/>
                </scope>
            </method>
            <method name="getListenersCount" type="int" line="1411">
                <params>
                    <param name="id" type="int"/>
                    <param name="enabledOnToolkit" type="boolean"/>
                </params>
                <scope line="1413"/>
            </method>
            <method name="createHierarchyEvents" type="int" line="1429">
                <params>
                    <param name="id" type="int"/>
                    <param name="changed" type="Component"/>
                    <param name="changedParent" type="Container"/>
                    <param name="changeFlags" type="long"/>
                    <param name="enabledOnToolkit" type="boolean"/>
                </params>
                <declaration name="listeners" type="int" line="1431"/>
                <scope line="1433"/>
            </method>
            <method name="createChildHierarchyEvents" type="void" line="1444">
                <params>
                    <param name="id" type="int"/>
                    <param name="changeFlags" type="long"/>
                    <param name="enabledOnToolkit" type="boolean"/>
                </params>
                <scope line="1446"/>
                <declaration name="listeners" type="int" line="1449"/>
                <scope line="1451"/>
            </method>
            <javadoc line="1457">
                Gets the layout manager for this container.                
                <see>
                    #doLayout                    
                </see>
                <see>
                    #setLayout                    
                </see>
            </javadoc>
            <method name="getLayout" type="LayoutManager" line="1462"/>
            <javadoc line="1466">
                Sets the layout manager for this container.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy.                
                <param>
                    mgr the specified layout manager                    
                </param>
                <see>
                    #doLayout                    
                </see>
                <see>
                    #getLayout                    
                </see>
                <see>
                    #invalidate                    
                </see>
            </javadoc>
            <method name="setLayout" type="void" line="1477">
                <params>
                    <param name="mgr" type="LayoutManager"/>
                </params>
            </method>
            <javadoc line="1482">
                Causes this container to lay out its components.  Most programs
                  should not call this method directly, but should invoke
                  the &lt;code&gt;validate&lt;/code&gt; method instead.                
                <see>
                    LayoutManager#layoutContainer                    
                </see>
                <see>
                    #setLayout                    
                </see>
                <see>
                    #validate                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="doLayout" type="void" line="1491"/>
            <javadoc line="1495">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;doLayout()&lt;/code&gt;.                
            </javadoc>
            <method name="layout" type="void" line="1500">
                <declaration name="layoutMgr" type="LayoutManager" line="1501"/>
                <scope line="1502"/>
            </method>
            <javadoc line="1507">
                Indicates if this container is a &lt;i&gt;validate root&lt;/i&gt;.
                  &lt;p&gt;
                  Layout-related changes, such as bounds of the validate root descendants,
                  do not affect the layout of the validate root parent. This peculiarity
                  enables the {@code invalidate()} method to stop invalidating the
                  component hierarchy when the method encounters a validate root. However,
                  to preserve backward compatibility this new optimized behavior is
                  enabled only when the {@code java.awt.smartInvalidate} system property
                  value is set to {@code true}.
                  &lt;p&gt;
                  If a component hierarchy contains validate roots and the new optimized{@code invalidate()} behavior is enabled, the {@code validate()} method
                  must be invoked on the validate root of a previously invalidated
                  component to restore the validity of the hierarchy later. Otherwise,
                  calling the {@code validate()} method on the top-level container (such
                  as a {@code Frame} object) should be used to restore the validity of the
                  component hierarchy.
                  &lt;p&gt;
                  The {@code Window} class and the {@code Applet} class are the validate
                  roots in AWT.  Swing introduces more validate roots.                
                <return>
                    whether this container is a validate root                    
                </return>
                <see>
                    #invalidate                    
                </see>
                <see>
                    java.awt.Component#invalidate                    
                </see>
                <see>
                    javax.swing.JComponent#isValidateRoot                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="isValidateRoot" type="boolean" line="1536"/>
            <declaration name="isJavaAwtSmartInvalidate" type="boolean" line="1540"/>
            <scope line="1541"/>
            <javadoc line="1547">
                Invalidates the parent of the container unless the container
                  is a validate root.                
            </javadoc>
            <method name="invalidateParent" type="void" line="1552">
                <scope line="1553"/>
            </method>
            <javadoc line="1558">
                Invalidates the container.
                  &lt;p&gt;
                  If the {@code LayoutManager} installed on this container is an instance
                  of the {@code LayoutManager2} interface, then
                  the {@link LayoutManager2#invalidateLayout(Container)} method is invoked
                  on it supplying this {@code Container} as the argument.
                  &lt;p&gt;
                  Afterwards this method marks this container invalid, and invalidates its
                  ancestors. See the {@link Component#invalidate} method for more details.                
                <see>
                    #validate                    
                </see>
                <see>
                    #layout                    
                </see>
                <see>
                    LayoutManager2                    
                </see>
            </javadoc>
            <method name="invalidate" type="void" line="1574">
                <declaration name="layoutMgr" type="LayoutManager" line="1575"/>
                <scope line="1576">
                    <declaration name="lm" type="LayoutManager2" line="1577"/>
                </scope>
            </method>
            <javadoc line="1583">
                Validates this container and all of its subcomponents.
                  &lt;p&gt;
                  Validating a container means laying out its subcomponents.
                  Layout-related changes, such as setting the bounds of a component, or
                  adding a component to the container, invalidate the container
                  automatically.  Note that the ancestors of the container may be
                  invalidated also (see {@link Component#invalidate} for details.)
                  Therefore, to restore the validity of the hierarchy, the {@codevalidate()} method should be invoked on the top-most invalid
                  container of the hierarchy.
                  &lt;p&gt;
                  Validating the container may be a quite time-consuming operation. For
                  performance reasons a developer may postpone the validation of the
                  hierarchy till a set of layout-related operations completes, e.g. after
                  adding all the children to the container.
                  &lt;p&gt;
                  If this {@code Container} is not valid, this method invokes
                  the {@code validateTree} method and marks this {@code Container}as valid. Otherwise, no action is performed.                
                <see>
                    #add(java.awt.Component)                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    Container#isValidateRoot                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
                <see>
                    #validateTree                    
                </see>
            </javadoc>
            <method name="validate" type="void" line="1610">
                <comment line="1627">
                    Avoid updating cursor if this is an internal call.
                     See validateUnconditionally() for details.                    
                </comment>
                <declaration name="updateCur" type="boolean" line="1611"/>
                <scope line="1612">
                    <scope line="1615">
                        <declaration name="p" type="ContainerPeer" line="1616"/>
                        <scope line="1617"/>
                        <scope line="1620"/>
                        <scope line="1624">
                            <scope line="1628"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1634"/>
            </method>
            <declaration name="descendUnconditionallyWhenValidating" type="boolean" line="1639"/>
            <javadoc line="1639">
                Indicates whether valid containers should also traverse their
                  children and call the validateTree() method on them.
                  Synchronization: TreeLock.
                  The field is allowed to be static as long as the TreeLock itself is
                  static.                
                <see>
                    #validateUnconditionally()                    
                </see>
            </javadoc>
            <javadoc line="1652">
                Unconditionally validate the component hierarchy.                
            </javadoc>
            <method name="validateUnconditionally" type="void" line="1655">
                <declaration name="updateCur" type="boolean" line="1656"/>
                <scope line="1657">
                    <scope line="1661"/>
                </scope>
                <scope line="1667"/>
            </method>
            <javadoc line="1672">
                Recursively descends the container tree and recomputes the
                  layout for any subtrees marked as needing it (those marked as
                  invalid).  Synchronization should be provided by the method
                  that calls this one:  &lt;code&gt;validate&lt;/code&gt;.                
                <see>
                    #doLayout                    
                </see>
                <see>
                    #validate                    
                </see>
            </javadoc>
            <method name="validateTree" type="void" line="1681">
                <scope line="1683">
                    <scope line="1684"/>
                    <scope line="1687"/>
                    <scope line="1690">
                        <declaration name="comp" type="Component" line="1691"/>
                        <scope line="1696"/>
                        <scope line="1698"/>
                    </scope>
                    <scope line="1702"/>
                </scope>
            </method>
            <javadoc line="1709">
                Recursively descends the container tree and invalidates all
                  contained components.                
            </javadoc>
            <method name="invalidateTree" type="void" line="1713">
                <scope line="1714">
                    <scope line="1715">
                        <declaration name="comp" type="Component" line="1716"/>
                        <scope line="1717"/>
                        <scope line="1720"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1728">
                Sets the font of this container.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy.                
                <param>
                    f The font to become this container's font.                    
                </param>
                <see>
                    Component#getFont                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="setFont" type="void" line="1739">
                <params>
                    <param name="f" type="Font"/>
                </params>
                <declaration name="shouldinvalidate" type="boolean" line="1740"/>
                <declaration name="oldfont" type="Font" line="1742"/>
                <declaration name="newfont" type="Font" line="1744"/>
                <scope line="1746"/>
            </method>
            <javadoc line="1751">
                Returns the preferred size of this container.  If the preferred size has
                  not been set explicitly by {@link Component#setPreferredSize(Dimension)}and this {@code Container} has a {@code non-null} {@link LayoutManager},
                  then {@link LayoutManager#preferredLayoutSize(Container)}is used to calculate the preferred size.
                  &lt;p&gt;Note: some implementations may cache the value returned from the{@code LayoutManager}.  Implementations that cache need not invoke{@code preferredLayoutSize} on the {@code LayoutManager} every time
                  this method is invoked, rather the {@code LayoutManager} will only
                  be queried after the {@code Container} becomes invalid.                
                <return>
                    an instance of <code>Dimension</code> that represents
                      the preferred size of this container.                    
                </return>
                <see>
                    #getMinimumSize                    
                </see>
                <see>
                    #getMaximumSize                    
                </see>
                <see>
                    #getLayout                    
                </see>
                <see>
                    LayoutManager#preferredLayoutSize(Container)                    
                </see>
                <see>
                    Component#getPreferredSize                    
                </see>
            </javadoc>
            <method name="getPreferredSize" type="Dimension" line="1772"/>
            <javadoc line="1776">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;getPreferredSize()&lt;/code&gt;.                
            </javadoc>
            <method name="preferredSize" type="Dimension" line="1781">
                <comment line="1783">
                    Avoid grabbing the lock if a reasonable cached size value
                     is available.                    
                </comment>
                <declaration name="dim" type="Dimension" line="1785"/>
                <scope line="1786">
                    <scope line="1787"/>
                </scope>
                <scope line="1794"/>
                <scope line="1797"/>
            </method>
            <javadoc line="1802">
                Returns the minimum size of this container.  If the minimum size has
                  not been set explicitly by {@link Component#setMinimumSize(Dimension)}and this {@code Container} has a {@code non-null} {@link LayoutManager},
                  then {@link LayoutManager#minimumLayoutSize(Container)}is used to calculate the minimum size.
                  &lt;p&gt;Note: some implementations may cache the value returned from the{@code LayoutManager}.  Implementations that cache need not invoke{@code minimumLayoutSize} on the {@code LayoutManager} every time
                  this method is invoked, rather the {@code LayoutManager} will only
                  be queried after the {@code Container} becomes invalid.                
                <return>
                    an instance of <code>Dimension</code> that represents
                      the minimum size of this container.                    
                </return>
                <see>
                    #getPreferredSize                    
                </see>
                <see>
                    #getMaximumSize                    
                </see>
                <see>
                    #getLayout                    
                </see>
                <see>
                    LayoutManager#minimumLayoutSize(Container)                    
                </see>
                <see>
                    Component#getMinimumSize                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getMinimumSize" type="Dimension" line="1824"/>
            <javadoc line="1828">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;getMinimumSize()&lt;/code&gt;.                
            </javadoc>
            <method name="minimumSize" type="Dimension" line="1833">
                <comment line="1835">
                    Avoid grabbing the lock if a reasonable cached size value
                     is available.                    
                </comment>
                <declaration name="dim" type="Dimension" line="1837"/>
                <scope line="1838">
                    <scope line="1839"/>
                </scope>
                <scope line="1846"/>
                <scope line="1849"/>
            </method>
            <javadoc line="1854">
                Returns the maximum size of this container.  If the maximum size has
                  not been set explicitly by {@link Component#setMaximumSize(Dimension)}and the {@link LayoutManager} installed on this {@code Container}is an instance of {@link LayoutManager2}, then{@link LayoutManager2#maximumLayoutSize(Container)}is used to calculate the maximum size.
                  &lt;p&gt;Note: some implementations may cache the value returned from the{@code LayoutManager2}.  Implementations that cache need not invoke{@code maximumLayoutSize} on the {@code LayoutManager2} every time
                  this method is invoked, rather the {@code LayoutManager2} will only
                  be queried after the {@code Container} becomes invalid.                
                <return>
                    an instance of <code>Dimension</code> that represents
                      the maximum size of this container.                    
                </return>
                <see>
                    #getPreferredSize                    
                </see>
                <see>
                    #getMinimumSize                    
                </see>
                <see>
                    #getLayout                    
                </see>
                <see>
                    LayoutManager2#maximumLayoutSize(Container)                    
                </see>
                <see>
                    Component#getMaximumSize                    
                </see>
            </javadoc>
            <method name="getMaximumSize" type="Dimension" line="1876">
                <comment line="1878">
                    Avoid grabbing the lock if a reasonable cached size value
                     is available.                    
                </comment>
                <declaration name="dim" type="Dimension" line="1880"/>
                <scope line="1881">
                    <scope line="1882">
                        <scope line="1883">
                            <declaration name="lm" type="LayoutManager2" line="1884"/>
                        </scope>
                        <scope line="1886"/>
                    </scope>
                </scope>
                <scope line="1892"/>
                <scope line="1895"/>
            </method>
            <javadoc line="1900">
                Returns the alignment along the x axis.  This specifies how
                  the component would like to be aligned relative to other
                  components.  The value should be a number between 0 and 1
                  where 0 represents alignment along the origin, 1 is aligned
                  the furthest away from the origin, 0.5 is centered, etc.                
            </javadoc>
            <method name="getAlignmentX" type="float" line="1907">
                <declaration name="xAlign" type="float" line="1908"/>
                <scope line="1909">
                    <scope line="1910">
                        <declaration name="lm" type="LayoutManager2" line="1911"/>
                    </scope>
                </scope>
                <scope line="1914"/>
            </method>
            <javadoc line="1920">
                Returns the alignment along the y axis.  This specifies how
                  the component would like to be aligned relative to other
                  components.  The value should be a number between 0 and 1
                  where 0 represents alignment along the origin, 1 is aligned
                  the furthest away from the origin, 0.5 is centered, etc.                
            </javadoc>
            <method name="getAlignmentY" type="float" line="1927">
                <declaration name="yAlign" type="float" line="1928"/>
                <scope line="1929">
                    <scope line="1930">
                        <declaration name="lm" type="LayoutManager2" line="1931"/>
                    </scope>
                </scope>
                <scope line="1934"/>
            </method>
            <javadoc line="1940">
                Paints the container. This forwards the paint to any lightweight
                  components that are children of this container. If this method is
                  reimplemented, super.paint(g) should be called so that lightweight
                  components are properly rendered. If a child component is entirely
                  clipped by the current clipping setting in g, paint() will not be
                  forwarded to that child.                
                <param>
                    g the specified Graphics window                    
                </param>
                <see>
                    Component#update(Graphics)                    
                </see>
            </javadoc>
            <method name="paint" type="void" line="1951">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="1962">
                    The container is showing on screen and
                     this paint() is not called from print().
                     Paint self and forward the paint to lightweight subcomponents.                    
                </comment>
                <comment line="1966">
                    super.paint(); -- Don&apos;t bother, since it&apos;s a NOP.                    
                </comment>
                <scope line="1952">
                    <scope line="1953">
                        <scope line="1954">
                            <scope line="1955"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1972">
                Updates the container.  This forwards the update to any lightweight
                  components that are children of this container.  If this method is
                  reimplemented, super.update(g) should be called so that lightweight
                  components are properly rendered.  If a child component is entirely
                  clipped by the current clipping setting in g, update() will not be
                  forwarded to that child.                
                <param>
                    g the specified Graphics window                    
                </param>
                <see>
                    Component#update(Graphics)                    
                </see>
            </javadoc>
            <method name="update" type="void" line="1983">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1984">
                    <scope line="1985"/>
                </scope>
            </method>
            <javadoc line="1992">
                Prints the container. This forwards the print to any lightweight
                  components that are children of this container. If this method is
                  reimplemented, super.print(g) should be called so that lightweight
                  components are properly rendered. If a child component is entirely
                  clipped by the current clipping setting in g, print() will not be
                  forwarded to that child.                
                <param>
                    g the specified Graphics window                    
                </param>
                <see>
                    Component#update(Graphics)                    
                </see>
            </javadoc>
            <method name="print" type="void" line="2003">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="2015">
                    By default, Component.print() calls paint()                    
                </comment>
                <scope line="2004">
                    <declaration name="t" type="Thread" line="2005"/>
                    <scope line="2006">
                        <scope line="2007">
                            <scope line="2008"/>
                        </scope>
                    </scope>
                    <scope line="2015">
                        <scope line="2016"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2027">
                Paints each of the components in this container.                
                <param>
                    g   the graphics context.                    
                </param>
                <see>
                    Component#paint                    
                </see>
                <see>
                    Component#paintAll                    
                </see>
            </javadoc>
            <method name="paintComponents" type="void" line="2033">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="2034"/>
            </method>
            <javadoc line="2040">
                Simulates the peer callbacks into java.awt for printing of
                  lightweight Containers.                
                <param>
                    g   the graphics context to use for printing.                    
                </param>
                <see>
                    Component#printAll                    
                </see>
                <see>
                    #printComponents                    
                </see>
            </javadoc>
            <method name="lightweightPaint" type="void" line="2047">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <javadoc line="2052">
                Prints all the heavyweight subcomponents.                
            </javadoc>
            <method name="paintHeavyweightComponents" type="void" line="2055">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="2056"/>
            </method>
            <javadoc line="2063">
                Prints each of the components in this container.                
                <param>
                    g   the graphics context.                    
                </param>
                <see>
                    Component#print                    
                </see>
                <see>
                    Component#printAll                    
                </see>
            </javadoc>
            <method name="printComponents" type="void" line="2069">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="2070"/>
            </method>
            <javadoc line="2076">
                Simulates the peer callbacks into java.awt for printing of
                  lightweight Containers.                
                <param>
                    g   the graphics context to use for printing.                    
                </param>
                <see>
                    Component#printAll                    
                </see>
                <see>
                    #printComponents                    
                </see>
            </javadoc>
            <method name="lightweightPrint" type="void" line="2083">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <javadoc line="2088">
                Prints all the heavyweight subcomponents.                
            </javadoc>
            <method name="printHeavyweightComponents" type="void" line="2091">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="2092"/>
            </method>
            <javadoc line="2099">
                Adds the specified container listener to receive container events
                  from this container.
                  If l is null, no exception is thrown and no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the container listener                    
                </param>
                <see>
                    #removeContainerListener                    
                </see>
                <see>
                    #getContainerListeners                    
                </see>
            </javadoc>
            <method name="addContainerListener" type="void" line="2111">
                <params>
                    <param name="l" type="ContainerListener"/>
                </params>
                <scope line="2112"/>
            </method>
            <javadoc line="2119">
                Removes the specified container listener so it no longer receives
                  container events from this container.
                  If l is null, no exception is thrown and no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the container listener                    
                </param>
                <see>
                    #addContainerListener                    
                </see>
                <see>
                    #getContainerListeners                    
                </see>
            </javadoc>
            <method name="removeContainerListener" type="void" line="2131">
                <params>
                    <param name="l" type="ContainerListener"/>
                </params>
                <scope line="2132"/>
            </method>
            <javadoc line="2138">
                Returns an array of all the container listeners
                  registered on this container.                
                <return>
                    all of this container's <code>ContainerListener</code>s
                      or an empty array if no container
                      listeners are currently registered                    
                </return>
                <see>
                    #addContainerListener                    
                </see>
                <see>
                    #removeContainerListener                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getContainerListeners" type="ContainerListener[]" line="2150"/>
            <javadoc line="2154">
                Returns an array of all the objects currently registered
                  as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
                  upon this &lt;code&gt;Container&lt;/code&gt;.
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
                  &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
                  &lt;p&gt;
                  You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
                  with a class literal, such as
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
                  For example, you can query a
                  &lt;code&gt;Container&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;
                  for its container listeners with the following code:
                  &lt;pre&gt;ContainerListener[] cls = (ContainerListener[])(c.getListeners(ContainerListener.class));&lt;/pre&gt;
                  If no such listeners exist, this method returns an empty array.                
                <param>
                    listenerType the type of listeners requested; this parameter
                      should specify an interface that descends from
                      <code>java.util.EventListener</code>                    
                </param>
                <return>
                    an array of all objects registered as
                      <code><em>Foo</em>Listener</code>s on this container,
                      or an empty array if no such listeners have been added                    
                </return>
                <exception>
                    ClassCastException if <code>listenerType</code>
                      doesn't specify a class or interface that implements
                      <code>java.util.EventListener</code>                    
                </exception>
                <exception>
                    NullPointerException if {@code listenerType} is {@code null}                    
                </exception>
                <see>
                    #getContainerListeners                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getListeners" type="T[]" line="2188">
                <params>
                    <param name="listenerType" type="Class<T>"/>
                </params>
                <declaration name="l" type="EventListener" line="2189"/>
                <scope line="2190"/>
                <scope line="2192"/>
            </method>
            <method name="eventEnabled" type="boolean" line="2199">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <declaration name="id" type="int" line="2200"/>
                <scope line="2203">
                    <scope line="2205"/>
                </scope>
            </method>
            <javadoc line="2213">
                Processes events on this container. If the event is a
                  &lt;code&gt;ContainerEvent&lt;/code&gt;, it invokes the
                  &lt;code&gt;processContainerEvent&lt;/code&gt; method, else it invokes
                  its superclass&apos;s &lt;code&gt;processEvent&lt;/code&gt;.
                  &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
                  the behavior is unspecified and may result in an
                  exception.                
                <param>
                    e the event                    
                </param>
            </javadoc>
            <method name="processEvent" type="void" line="2224">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <scope line="2225"/>
            </method>
            <javadoc line="2232">
                Processes container events occurring on this container by
                  dispatching them to any registered ContainerListener objects.
                  NOTE: This method will not be called unless container events
                  are enabled for this component; this happens when one of the
                  following occurs:
                  &lt;ul&gt;
                  &lt;li&gt;A ContainerListener object is registered via
                  &lt;code&gt;addContainerListener&lt;/code&gt;
                  &lt;li&gt;Container events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
                  the behavior is unspecified and may result in an
                  exception.                
                <param>
                    e the container event                    
                </param>
                <see>
                    Component#enableEvents                    
                </see>
            </javadoc>
            <method name="processContainerEvent" type="void" line="2250">
                <params>
                    <param name="e" type="ContainerEvent"/>
                </params>
                <declaration name="listener" type="ContainerListener" line="2251"/>
                <scope line="2252"/>
            </method>
            <method name="dispatchEventImpl" type="void" line="2272">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <comment line="2275">
                    event was sent to a lightweight component.  The
                     native-produced event sent to the native container
                     must be properly disposed of by the peer, so it
                     gets forwarded.  If the native host has been removed
                     as a result of the sending the lightweight event,
                     the peer reference will be null.                    
                </comment>
                <scope line="2273">
                    <scope line="2281"/>
                </scope>
                <scope line="2289"/>
            </method>
            <method name="dispatchEventToSelf" type="void" line="2310">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
            </method>
            <javadoc line="2314">
                Fetchs the top-most (deepest) lightweight component that is interested
                  in receiving mouse events.                
            </javadoc>
            <method name="getMouseEventTarget" type="Component" line="2318">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="includeSelf" type="boolean"/>
                </params>
            </method>
            <javadoc line="2324">
                Fetches the top-most (deepest) component to receive SunDropTargetEvents.                
            </javadoc>
            <method name="getDropTargetEventTarget" type="Component" line="2327">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="includeSelf" type="boolean"/>
                </params>
            </method>
            <javadoc line="2333">
                A private version of getMouseEventTarget which has two additional
                  controllable behaviors. This method searches for the top-most
                  descendant of this container that contains the given coordinates
                  and is accepted by the given filter. The search will be constrained to
                  lightweight descendants if the last argument is &lt;code&gt;false&lt;/code&gt;.                
                <param>
                    filter EventTargetFilter instance to determine whether the
                      given component is a valid target for this event.                    
                </param>
                <param>
                    searchHeavyweights if <code>false</code>, the method
                      will bypass heavyweight components during the search.                    
                </param>
            </javadoc>
            <method name="getMouseEventTarget" type="Component" line="2347">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="includeSelf" type="boolean"/>
                    <param name="filter" type="EventTargetFilter"/>
                    <param name="searchHeavyweights" type="boolean"/>
                </params>
                <declaration name="comp" type="Component" line="2348"/>
                <scope line="2349"/>
                <scope line="2355"/>
            </method>
            <javadoc line="2364">
                A private version of getMouseEventTarget which has three additional
                  controllable behaviors. This method searches for the top-most
                  descendant of this container that contains the given coordinates
                  and is accepted by the given filter. The search will be constrained to
                  descendants of only lightweight children or only heavyweight children
                  of this container depending on searchHeavyweightChildren. The search will
                  be constrained to only lightweight descendants of the searched children
                  of this container if searchHeavyweightDescendants is &lt;code&gt;false&lt;/code&gt;.                
                <param>
                    filter EventTargetFilter instance to determine whether the
                      selected component is a valid target for this event.                    
                </param>
                <param>
                    searchHeavyweightChildren if <code>true</code>, the method
                      will bypass immediate lightweight children during the search.
                      If <code>false</code>, the methods will bypass immediate
                      heavyweight children during the search.                    
                </param>
                <param>
                    searchHeavyweightDescendants if <code>false</code>, the method
                      will bypass heavyweight descendants which are not immediate
                      children during the search. If <code>true</code>, the method
                      will traverse both lightweight and heavyweight descendants during
                      the search.                    
                </param>
            </javadoc>
            <method name="getMouseEventTargetImpl" type="Component" line="2389">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="includeSelf" type="boolean"/>
                    <param name="filter" type="EventTargetFilter"/>
                    <param name="searchHeavyweightChildren" type="boolean"/>
                    <param name="searchHeavyweightDescendants" type="boolean"/>
                </params>
                <comment line="2402">
                    found a component that intersects the point, see if there
                     is a deeper possibility.                    
                </comment>
                <comment line="2417">
                    there isn&apos;t a deeper target, but this component
                     is a target                    
                </comment>
                <comment line="2431">
                    didn&apos;t find a child target, return this component if it&apos;s
                     a possible target                    
                </comment>
                <comment line="2436">
                    no possible target                    
                </comment>
                <scope line="2390">
                    <scope line="2392">
                        <declaration name="comp" type="Component" line="2393"/>
                        <scope line="2399">
                            <scope line="2403">
                                <declaration name="child" type="Container" line="2404"/>
                                <declaration name="deeper" type="Component" line="2405"/>
                                <scope line="2411"/>
                            </scope>
                            <scope line="2414">
                                <scope line="2415"/>
                            </scope>
                        </scope>
                    </scope>
                    <declaration name="isPeerOK" type="boolean" line="2424"/>
                    <declaration name="isMouseOverMe" type="boolean" line="2425"/>
                    <scope line="2432"/>
                </scope>
            </method>
            <interface name="EventTargetFilter">
                <method name="accept" type="boolean" line="2441"/>
            </interface>
            <class name="MouseEventTargetFilter" line="2444">
                <implements interface="EventTargetFilter"/>
                <declaration name="FILTER" type="EventTargetFilter" line="2445"/>
                <method name="MouseEventTargetFilter" type="constructor" line="2447"/>
                <method name="accept" type="boolean" line="2449">
                    <params>
                        <param name="comp" type="Component"/>
                    </params>
                </method>
            </class>
            <class name="DropTargetEventTargetFilter" line="2459">
                <implements interface="EventTargetFilter"/>
                <declaration name="FILTER" type="EventTargetFilter" line="2460"/>
                <method name="DropTargetEventTargetFilter" type="constructor" line="2462"/>
                <method name="accept" type="boolean" line="2464">
                    <params>
                        <param name="comp" type="Component"/>
                    </params>
                    <declaration name="dt" type="DropTarget" line="2465"/>
                </method>
            </class>
            <javadoc line="2470">
                This is called by lightweight components that want the containing
                  windowed parent to enable some kind of events on their behalf.
                  This is needed for events that are normally only dispatched to
                  windows to be accepted so that they can be forwarded downward to
                  the lightweight component that has enabled them.                
            </javadoc>
            <method name="proxyEnableEvents" type="void" line="2477">
                <params>
                    <param name="events" type="long"/>
                </params>
                <comment line="2480">
                    this container is lightweight.... continue sending it
                     upward.                    
                </comment>
                <comment line="2486">
                    This is a native container, so it needs to host
                     one of it&apos;s children.  If this function is called before
                     a peer has been created we don&apos;t yet have a dispatcher
                     because it has not yet been determined if this instance
                     is lightweight.                    
                </comment>
                <scope line="2478">
                    <scope line="2481"/>
                </scope>
                <scope line="2484">
                    <scope line="2490"/>
                </scope>
            </method>
            <javadoc line="2496">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;dispatchEvent(AWTEvent e)&lt;/code&gt;                
            </javadoc>
            <method name="deliverEvent" type="void" line="2501">
                <params>
                    <param name="e" type="Event"/>
                </params>
                <declaration name="comp" type="Component" line="2502"/>
                <scope line="2503"/>
                <scope line="2506"/>
            </method>
            <javadoc line="2511">
                Locates the component that contains the x,y position.  The
                  top-most child component is returned in the case where there
                  is overlap in the components.  This is determined by finding
                  the component closest to the index 0 that claims to contain
                  the given point via Component.contains(), except that Components
                  which have native peers take precedence over those which do not
                  (i.e., lightweight Components).                
                <param>
                    x the <i>x</i> coordinate                    
                </param>
                <param>
                    y the <i>y</i> coordinate                    
                </param>
                <return>
                    null if the component does not contain the position.
                      If there is no child component at the requested point and the
                      point is within the bounds of the container the container itself
                      is returned; otherwise the top-most child is returned.                    
                </return>
                <see>
                    Component#contains                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getComponentAt" type="Component" line="2529">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <javadoc line="2533">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;getComponentAt(int, int)&lt;/code&gt;.                
            </javadoc>
            <method name="locate" type="Component" line="2538">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <comment line="2544">
                    Two passes: see comment in sun.awt.SunGraphicsCallback                    
                </comment>
                <scope line="2539"/>
                <scope line="2542">
                    <scope line="2544">
                        <declaration name="comp" type="Component" line="2545"/>
                        <scope line="2547">
                            <scope line="2548"/>
                        </scope>
                    </scope>
                    <scope line="2553">
                        <declaration name="comp" type="Component" line="2554"/>
                        <scope line="2556">
                            <scope line="2557"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="2566">
                Gets the component that contains the specified point.                
                <param>
                    p   the point.                    
                </param>
                <return>
                    returns the component that contains the point,
                      or <code>null</code> if the component does
                      not contain the point.                    
                </return>
                <see>
                    Component#contains                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getComponentAt" type="Component" line="2575">
                <params>
                    <param name="p" type="Point"/>
                </params>
            </method>
            <javadoc line="2579">
                Returns the position of the mouse pointer in this &lt;code&gt;Container&lt;/code&gt;&apos;s
                  coordinate space if the &lt;code&gt;Container&lt;/code&gt; is under the mouse pointer,
                  otherwise returns &lt;code&gt;null&lt;/code&gt;.
                  This method is similar to {@link Component#getMousePosition()} with the exception
                  that it can take the &lt;code&gt;Container&lt;/code&gt;&apos;s children into account.
                  If &lt;code&gt;allowChildren&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this method will return
                  a non-null value only if the mouse pointer is above the &lt;code&gt;Container&lt;/code&gt;
                  directly, not above the part obscured by children.
                  If &lt;code&gt;allowChildren&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this method returns
                  a non-null value if the mouse pointer is above &lt;code&gt;Container&lt;/code&gt; or any
                  of its descendants.                
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless() returns true                    
                </exception>
                <param>
                    allowChildren true if children should be taken into account                    
                </param>
                <see>
                    Component#getMousePosition                    
                </see>
                <return>
                    mouse coordinates relative to this <code>Component</code>, or null                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getMousePosition" type="Point" line="2598">
                <params>
                    <param name="allowChildren" type="boolean"/>
                </params>
                <scope line="2599"/>
                <anonymous_class line="2603">
                    <method name="run" type="Object" line="2604"/>
                </anonymous_class>
                <declaration name="pi" type="PointerInfo" line="2602"/>
                <scope line="2609">
                    <declaration name="inTheSameWindow" type="Component" line="2610"/>
                    <scope line="2611"/>
                </scope>
            </method>
            <method name="isSameOrAncestorOf" type="boolean" line="2618">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="allowChildren" type="boolean"/>
                </params>
            </method>
            <javadoc line="2622">
                Locates the visible child component that contains the specified
                  position.  The top-most child component is returned in the case
                  where there is overlap in the components.  If the containing child
                  component is a Container, this method will continue searching for
                  the deepest nested child component.  Components which are not
                  visible are ignored during the search.&lt;p&gt;
                  The findComponentAt method is different from getComponentAt in
                  that getComponentAt only searches the Container&apos;s immediate
                  children; if the containing component is a Container,
                  findComponentAt will search that child to find a nested component.                
                <param>
                    x the <i>x</i> coordinate                    
                </param>
                <param>
                    y the <i>y</i> coordinate                    
                </param>
                <return>
                    null if the component does not contain the position.
                      If there is no child component at the requested point and the
                      point is within the bounds of the container the container itself
                      is returned.                    
                </return>
                <see>
                    Component#contains                    
                </see>
                <see>
                    #getComponentAt                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="findComponentAt" type="Component" line="2645">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <javadoc line="2649">
                Private version of findComponentAt which has a controllable
                  behavior. Setting &apos;ignoreEnabled&apos; to &apos;false&apos; bypasses disabled
                  Components during the search. This behavior is used by the
                  lightweight cursor support in sun.awt.GlobalCursorManager.
                  The cursor code calls this function directly via native code.
                  The addition of this feature is temporary, pending the
                  adoption of new, public API which exports this feature.                
            </javadoc>
            <method name="findComponentAt" type="Component" line="2659">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="ignoreEnabled" type="boolean"/>
                </params>
                <scope line="2660">
                    <scope line="2661"/>
                </scope>
            </method>
            <method name="findComponentAtImpl" type="Component" line="2668">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="ignoreEnabled" type="boolean"/>
                </params>
                <comment line="2676">
                    Two passes: see comment in sun.awt.SunGraphicsCallback                    
                </comment>
                <scope line="2671"/>
                <scope line="2676">
                    <declaration name="comp" type="Component" line="2677"/>
                    <scope line="2679">
                        <scope line="2680"/>
                        <scope line="2684"/>
                        <scope line="2689"/>
                    </scope>
                </scope>
                <scope line="2694">
                    <declaration name="comp" type="Component" line="2695"/>
                    <scope line="2697">
                        <scope line="2698"/>
                        <scope line="2702"/>
                        <scope line="2707"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2716">
                Locates the visible child component that contains the specified
                  point.  The top-most child component is returned in the case
                  where there is overlap in the components.  If the containing child
                  component is a Container, this method will continue searching for
                  the deepest nested child component.  Components which are not
                  visible are ignored during the search.&lt;p&gt;
                  The findComponentAt method is different from getComponentAt in
                  that getComponentAt only searches the Container&apos;s immediate
                  children; if the containing component is a Container,
                  findComponentAt will search that child to find a nested component.                
                <param>
                    p   the point.                    
                </param>
                <return>
                    null if the component does not contain the position.
                      If there is no child component at the requested point and the
                      point is within the bounds of the container the container itself
                      is returned.                    
                </return>
                <throws>
                    NullPointerException if {@code p} is {@code null}                    
                </throws>
                <see>
                    Component#contains                    
                </see>
                <see>
                    #getComponentAt                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="findComponentAt" type="Component" line="2739">
                <params>
                    <param name="p" type="Point"/>
                </params>
            </method>
            <javadoc line="2743">
                Makes this Container displayable by connecting it to
                  a native screen resource.  Making a container displayable will
                  cause all of its children to be made displayable.
                  This method is called internally by the toolkit and should
                  not be called directly by programs.                
                <see>
                    Component#isDisplayable                    
                </see>
                <see>
                    #removeNotify                    
                </see>
            </javadoc>
            <method name="addNotify" type="void" line="2752">
                <comment line="2755">
                    addNotify() on the children may cause proxy event enabling
                     on this instance, so we first call super.addNotify() and
                     possibly create an lightweight event dispatcher before calling
                     addNotify() on the children which may be lightweight.                    
                </comment>
                <comment line="2764">
                    We shouldn&apos;t use iterator because of the Swing menu
                     implementation specifics:
                     the menu is being assigned as a child to JLayeredPane
                     instead of particular component so always affect
                     collection of component if menu is becoming shown or hidden.                    
                </comment>
                <scope line="2753">
                    <scope line="2759"/>
                    <scope line="2768"/>
                </scope>
            </method>
            <javadoc line="2774">
                Makes this Container undisplayable by removing its connection
                  to its native screen resource.  Making a container undisplayable
                  will cause all of its children to be made undisplayable.
                  This method is called by the toolkit internally and should
                  not be called directly by programs.                
                <see>
                    Component#isDisplayable                    
                </see>
                <see>
                    #addNotify                    
                </see>
            </javadoc>
            <method name="removeNotify" type="void" line="2783">
                <comment line="2786">
                    We shouldn&apos;t use iterator because of the Swing menu
                     implementation specifics:
                     the menu is being assigned as a child to JLayeredPane
                     instead of particular component so always affect
                     collection of component if menu is becoming shown or hidden.                    
                </comment>
                <comment line="2794">
                    Fix for 6607170.
                     We want to suppress focus change on disposal
                     of the focused component. But because of focus
                     is asynchronous, we should suppress focus change
                     on every component in case it receives native focus
                     in the process of disposal.                    
                </comment>
                <comment line="2805">
                    If some of the children had focus before disposal then it still has.
                     Auto-transfer focus to the next (or previous) component if auto-transfer
                     is enabled.                    
                </comment>
                <scope line="2784">
                    <scope line="2790">
                        <declaration name="comp" type="Component" line="2791"/>
                        <scope line="2792"/>
                    </scope>
                    <scope line="2807">
                        <scope line="2808"/>
                    </scope>
                    <scope line="2812"/>
                </scope>
            </method>
            <javadoc line="2820">
                Checks if the component is contained in the component hierarchy of
                  this container.                
                <param>
                    c the component                    
                </param>
                <return>
                    <code>true</code> if it is an ancestor;
                      <code>false</code> otherwise.                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="isAncestorOf" type="boolean" line="2828">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="p" type="Container" line="2829"/>
                <scope line="2830"/>
                <scope line="2833">
                    <scope line="2834"/>
                </scope>
            </method>
            <declaration name="modalComp" type="Component" line="2855"/>
            <declaration name="modalAppContext" type="AppContext" line="2856"/>
            <method name="startLWModal" type="void" line="2858">
                <comment line="2860">
                    Store the app context on which this component is being shown.
                     Event dispatch thread of this app context will be sleeping until
                     we wake it by any event from hideAndDisposeHandler().                    
                </comment>
                <comment line="2865">
                    keep the KeyEvents from being dispatched
                     until the focus has been transfered                    
                </comment>
                <comment line="2873">
                    We have two mechanisms for blocking: 1. If we&apos;re on the
                     EventDispatchThread, start a new event pump. 2. If we&apos;re
                     on any other thread, call wait() on the treelock.                    
                </comment>
                <declaration name="time" type="long" line="2866"/>
                <declaration name="predictedFocusOwner" type="Component" line="2867"/>
                <scope line="2868"/>
                <declaration name="nativeContainer" type="Container" line="2875"/>
                <scope line="2876">
                    <scope line="2878"/>
                    <scope line="2883"/>
                </scope>
                <anonymous_class line="2888">
                    <method name="run" type="void" line="2889">
                        <declaration name="dispatchThread" type="EventDispatchThread" line="2890"/>
                        <anonymous_class line="2893">
                            <method name="evaluate" type="boolean" line="2894"/>
                        </anonymous_class>
                    </method>
                </anonymous_class>
                <declaration name="pumpEventsForHierarchy" type="Runnable" line="2888"/>
                <scope line="2901">
                    <declaration name="currentSequencedEvent" type="SequencedEvent" line="2902"/>
                    <scope line="2905"/>
                </scope>
                <scope line="2910">
                    <scope line="2911">
                        <scope line="2918">
                            <scope line="2919"/>
                            <scope line="2921"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2927"/>
                <scope line="2931"/>
            </method>
            <method name="stopLWModal" type="void" line="2937">
                <comment line="2952">
                    Wake up event dispatch thread on which the dialog was
                     initially shown                    
                </comment>
                <scope line="2938">
                    <scope line="2939">
                        <declaration name="nativeContainer" type="Container" line="2940"/>
                        <scope line="2941">
                            <scope line="2942"/>
                            <scope line="2947"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <class name="WakingRunnable" line="2963">
                <implements interface="Runnable"/>
                <method name="run" type="void" line="2964"/>
            </class>
            <javadoc line="2970">
                Returns a string representing the state of this &lt;code&gt;Container&lt;/code&gt;.
                  This method is intended to be used only for debugging purposes, and the
                  content and format of the returned string may vary between
                  implementations. The returned string may be empty but may not be
                  &lt;code&gt;null&lt;/code&gt;.                
                <return>
                    the parameter string of this container                    
                </return>
            </javadoc>
            <method name="paramString" type="String" line="2979">
                <declaration name="str" type="String" line="2980"/>
                <declaration name="layoutMgr" type="LayoutManager" line="2981"/>
                <scope line="2982"/>
            </method>
            <javadoc line="2988">
                Prints a listing of this container to the specified output
                  stream. The listing starts at the specified indentation.
                  &lt;p&gt;
                  The immediate children of the container are printed with
                  an indentation of &lt;code&gt;indent+1&lt;/code&gt;.  The children
                  of those children are printed at &lt;code&gt;indent+2&lt;/code&gt;
                  and so on.                
                <param>
                    out      a print stream                    
                </param>
                <param>
                    indent   the number of spaces to indent                    
                </param>
                <throws>
                    NullPointerException if {@code out} is {@code null}                    
                </throws>
                <see>
                    Component#list(java.io.PrintStream,int)                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="list" type="void" line="3003">
                <params>
                    <param name="out" type="PrintStream"/>
                    <param name="indent" type="int"/>
                </params>
                <scope line="3005">
                    <scope line="3006">
                        <declaration name="comp" type="Component" line="3007"/>
                        <scope line="3008"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3015">
                Prints out a list, starting at the specified indentation,
                  to the specified print writer.
                  &lt;p&gt;
                  The immediate children of the container are printed with
                  an indentation of &lt;code&gt;indent+1&lt;/code&gt;.  The children
                  of those children are printed at &lt;code&gt;indent+2&lt;/code&gt;
                  and so on.                
                <param>
                    out      a print writer                    
                </param>
                <param>
                    indent   the number of spaces to indent                    
                </param>
                <throws>
                    NullPointerException if {@code out} is {@code null}                    
                </throws>
                <see>
                    Component#list(java.io.PrintWriter,int)                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="list" type="void" line="3030">
                <params>
                    <param name="out" type="PrintWriter"/>
                    <param name="indent" type="int"/>
                </params>
                <scope line="3032">
                    <scope line="3033">
                        <declaration name="comp" type="Component" line="3034"/>
                        <scope line="3035"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3042">
                Sets the focus traversal keys for a given traversal operation for this
                  Container.
                  &lt;p&gt;
                  The default values for a Container&apos;s focus traversal keys are
                  implementation-dependent. Sun recommends that all implementations for a
                  particular native platform use the same default values. The
                  recommendations for Windows and Unix are listed below. These
                  recommendations are used in the Sun AWT implementations.
                  &lt;table border=1 summary=&quot;Recommended default values for a Container&apos;s focus traversal keys&quot;&gt;
                  &lt;tr&gt;
                  &lt;th&gt;Identifier&lt;/th&gt;
                  &lt;th&gt;Meaning&lt;/th&gt;
                  &lt;th&gt;Default&lt;/th&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS&lt;/td&gt;
                  &lt;td&gt;Normal forward keyboard traversal&lt;/td&gt;
                  &lt;td&gt;TAB on KEY_PRESSED, CTRL-TAB on KEY_PRESSED&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS&lt;/td&gt;
                  &lt;td&gt;Normal reverse keyboard traversal&lt;/td&gt;
                  &lt;td&gt;SHIFT-TAB on KEY_PRESSED, CTRL-SHIFT-TAB on KEY_PRESSED&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS&lt;/td&gt;
                  &lt;td&gt;Go up one focus traversal cycle&lt;/td&gt;
                  &lt;td&gt;none&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS&lt;td&gt;
                  &lt;td&gt;Go down one focus traversal cycle&lt;/td&gt;
                  &lt;td&gt;none&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  To disable a traversal key, use an empty Set; Collections.EMPTY_SET is
                  recommended.
                  &lt;p&gt;
                  Using the AWTKeyStroke API, client code can specify on which of two
                  specific KeyEvents, KEY_PRESSED or KEY_RELEASED, the focus traversal
                  operation will occur. Regardless of which KeyEvent is specified,
                  however, all KeyEvents related to the focus traversal key, including the
                  associated KEY_TYPED event, will be consumed, and will not be dispatched
                  to any Container. It is a runtime error to specify a KEY_TYPED event as
                  mapping to a focus traversal operation, or to map the same event to
                  multiple default focus traversal operations.
                  &lt;p&gt;
                  If a value of null is specified for the Set, this Container inherits the
                  Set from its parent. If all ancestors of this Container have null
                  specified for the Set, then the current KeyboardFocusManager&apos;s default
                  Set is used.                
                <param>
                    id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </param>
                <param>
                    keystrokes the Set of AWTKeyStroke for the specified operation                    
                </param>
                <see>
                    #getFocusTraversalKeys                    
                </see>
                <see>
                    KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <throws>
                    IllegalArgumentException if id is not one of
                      KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, or if keystrokes
                      contains null, or if any Object in keystrokes is not an
                      AWTKeyStroke, or if any keystroke represents a KEY_TYPED event,
                      or if any keystroke already maps to another focus traversal
                      operation for this Container                    
                </throws>
                <since>
                    1.4                    
                </since>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setFocusTraversalKeys" type="void" line="3122">
                <params>
                    <param name="id" type="int"/>
                    <param name="keystrokes" type="Set<? extends AWTKeyStroke>"/>
                </params>
                <comment line="3128">
                    Don&apos;t call super.setFocusTraversalKey. The Component parameter check
                     does not allow DOWN_CYCLE_TRAVERSAL_KEYS, but we do.                    
                </comment>
                <scope line="3123"/>
            </method>
            <javadoc line="3132">
                Returns the Set of focus traversal keys for a given traversal operation
                  for this Container. (See
                  &lt;code&gt;setFocusTraversalKeys&lt;/code&gt; for a full description of each key.)
                  &lt;p&gt;
                  If a Set of traversal keys has not been explicitly defined for this
                  Container, then this Container&apos;s parent&apos;s Set is returned. If no Set
                  has been explicitly defined for any of this Container&apos;s ancestors, then
                  the current KeyboardFocusManager&apos;s default Set is returned.                
                <param>
                    id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </param>
                <return>
                    the Set of AWTKeyStrokes for the specified operation. The Set
                      will be unmodifiable, and may be empty. null will never be
                      returned.                    
                </return>
                <see>
                    #setFocusTraversalKeys                    
                </see>
                <see>
                    KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <throws>
                    IllegalArgumentException if id is not one of
                      KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getFocusTraversalKeys" type="Set<AWTKeyStroke>" line="3161">
                <params>
                    <param name="id" type="int"/>
                </params>
                <comment line="3167">
                    Don&apos;t call super.getFocusTraversalKey. The Component parameter check
                     does not allow DOWN_CYCLE_TRAVERSAL_KEY, but we do.                    
                </comment>
                <scope line="3162"/>
            </method>
            <javadoc line="3171">
                Returns whether the Set of focus traversal keys for the given focus
                  traversal operation has been explicitly defined for this Container. If
                  this method returns &lt;code&gt;false&lt;/code&gt;, this Container is inheriting the
                  Set from an ancestor, or from the current KeyboardFocusManager.                
                <param>
                    id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </param>
                <return>
                    <code>true</code> if the the Set of focus traversal keys for the
                      given focus traversal operation has been explicitly defined for
                      this Component; <code>false</code> otherwise.                    
                </return>
                <throws>
                    IllegalArgumentException if id is not one of
                      KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="areFocusTraversalKeysSet" type="boolean" line="3191">
                <params>
                    <param name="id" type="int"/>
                </params>
                <scope line="3192"/>
            </method>
            <javadoc line="3199">
                Returns whether the specified Container is the focus cycle root of this
                  Container&apos;s focus traversal cycle. Each focus traversal cycle has only
                  a single focus cycle root and each Container which is not a focus cycle
                  root belongs to only a single focus traversal cycle. Containers which
                  are focus cycle roots belong to two cycles: one rooted at the Container
                  itself, and one rooted at the Container&apos;s nearest focus-cycle-root
                  ancestor. This method will return &lt;code&gt;true&lt;/code&gt; for both such
                  Containers in this case.                
                <param>
                    container the Container to be tested                    
                </param>
                <return>
                    <code>true</code> if the specified Container is a focus-cycle-
                      root of this Container; <code>false</code> otherwise                    
                </return>
                <see>
                    #isFocusCycleRoot()                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFocusCycleRoot" type="boolean" line="3215">
                <params>
                    <param name="container" type="Container"/>
                </params>
                <scope line="3216"/>
                <scope line="3218"/>
            </method>
            <method name="findTraversalRoot" type="Container" line="3223">
                <comment line="3225">
                    I potentially have two roots, myself and my root parent
                     If I am the current root, then use me
                     If none of my parents are roots, then use me
                     If my root parent is the current root, then use my root parent
                     If neither I nor my root parent is the current root, then
                     use my root parent (a guess)                    
                </comment>
                <declaration name="currentFocusCycleRoot" type="Container" line="3231"/>
                <declaration name="root" type="Container" line="3233"/>
                <scope line="3235"/>
                <scope line="3237">
                    <scope line="3239"/>
                </scope>
                <scope line="3244"/>
            </method>
            <method name="containsFocus" type="boolean" line="3251">
                <declaration name="focusOwner" type="Component" line="3252"/>
            </method>
            <javadoc line="3257">
                Check if this component is the child of this container or its children.
                  Note: this function acquires treeLock
                  Note: this function traverses children tree only in one Window.                
                <param>
                    comp a component in test, must not be null                    
                </param>
            </javadoc>
            <method name="isParentOf" type="boolean" line="3263">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="3264">
                    <scope line="3265"/>
                </scope>
            </method>
            <method name="clearMostRecentFocusOwnerOnHide" type="void" line="3272">
                <comment line="3282">
                    This synchronized should always be the second in a pair
                     (tree lock, KeyboardFocusManager.class)                    
                </comment>
                <declaration name="reset" type="boolean" line="3273"/>
                <declaration name="window" type="Window" line="3274"/>
                <scope line="3276">
                    <scope line="3278">
                        <declaration name="comp" type="Component" line="3279"/>
                        <scope line="3283">
                            <declaration name="storedComp" type="Component" line="3284"/>
                            <scope line="3285"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="3292"/>
            </method>
            <method name="clearCurrentFocusCycleRootOnHide" type="void" line="3297">
                <declaration name="kfm" type="KeyboardFocusManager" line="3298"/>
                <declaration name="cont" type="Container" line="3300"/>
                <scope line="3302"/>
            </method>
            <method name="getTraversalRoot" type="Container" line="3307">
                <scope line="3308"/>
            </method>
            <javadoc line="3315">
                Sets the focus traversal policy that will manage keyboard traversal of
                  this Container&apos;s children, if this Container is a focus cycle root. If
                  the argument is null, this Container inherits its policy from its focus-
                  cycle-root ancestor. If the argument is non-null, this policy will be
                  inherited by all focus-cycle-root children that have no keyboard-
                  traversal policy of their own (as will, recursively, their focus-cycle-
                  root children).
                  &lt;p&gt;
                  If this Container is not a focus cycle root, the policy will be
                  remembered, but will not be used or inherited by this or any other
                  Containers until this Container is made a focus cycle root.                
                <param>
                    policy the new focus traversal policy for this Container                    
                </param>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #isFocusCycleRoot                    
                </see>
                <since>
                    1.4                    
                </since>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setFocusTraversalPolicy" type="void" line="3336">
                <params>
                    <param name="policy" type="FocusTraversalPolicy"/>
                </params>
                <declaration name="oldPolicy" type="FocusTraversalPolicy" line="3337"/>
                <scope line="3338"/>
            </method>
            <javadoc line="3345">
                Returns the focus traversal policy that will manage keyboard traversal
                  of this Container&apos;s children, or null if this Container is not a focus
                  cycle root. If no traversal policy has been explicitly set for this
                  Container, then this Container&apos;s focus-cycle-root ancestor&apos;s policy is
                  returned.                
                <return>
                    this Container's focus traversal policy, or null if this
                      Container is not a focus cycle root.                    
                </return>
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #isFocusCycleRoot                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getFocusTraversalPolicy" type="FocusTraversalPolicy" line="3359">
                <scope line="3360"/>
                <declaration name="policy" type="FocusTraversalPolicy" line="3364"/>
                <scope line="3365"/>
                <declaration name="rootAncestor" type="Container" line="3369"/>
                <scope line="3370"/>
                <scope line="3372"/>
            </method>
            <javadoc line="3378">
                Returns whether the focus traversal policy has been explicitly set for
                  this Container. If this method returns &lt;code&gt;false&lt;/code&gt;, this
                  Container will inherit its focus traversal policy from an ancestor.                
                <return>
                    <code>true</code> if the focus traversal policy has been
                      explicitly set for this Container; <code>false</code> otherwise.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFocusTraversalPolicySet" type="boolean" line="3387"/>
            <javadoc line="3391">
                Sets whether this Container is the root of a focus traversal cycle. Once
                  focus enters a traversal cycle, typically it cannot leave it via focus
                  traversal unless one of the up- or down-cycle keys is pressed. Normal
                  traversal is limited to this Container, and all of this Container&apos;s
                  descendants that are not descendants of inferior focus cycle roots. Note
                  that a FocusTraversalPolicy may bend these restrictions, however. For
                  example, ContainerOrderFocusTraversalPolicy supports implicit down-cycle
                  traversal.
                  &lt;p&gt;
                  The alternative way to specify the traversal order of this Container&apos;s
                  children is to make this Container a
                  &lt;a href=&quot;doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;.                
                <param>
                    focusCycleRoot indicates whether this Container is the root of a
                      focus traversal cycle                    
                </param>
                <see>
                    #isFocusCycleRoot()                    
                </see>
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    ContainerOrderFocusTraversalPolicy                    
                </see>
                <see>
                    #setFocusTraversalPolicyProvider                    
                </see>
                <since>
                    1.4                    
                </since>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setFocusCycleRoot" type="void" line="3416">
                <params>
                    <param name="focusCycleRoot" type="boolean"/>
                </params>
                <declaration name="oldFocusCycleRoot" type="boolean" line="3417"/>
                <scope line="3418"/>
            </method>
            <javadoc line="3426">
                Returns whether this Container is the root of a focus traversal cycle.
                  Once focus enters a traversal cycle, typically it cannot leave it via
                  focus traversal unless one of the up- or down-cycle keys is pressed.
                  Normal traversal is limited to this Container, and all of this
                  Container&apos;s descendants that are not descendants of inferior focus
                  cycle roots. Note that a FocusTraversalPolicy may bend these
                  restrictions, however. For example, ContainerOrderFocusTraversalPolicy
                  supports implicit down-cycle traversal.                
                <return>
                    whether this Container is the root of a focus traversal cycle                    
                </return>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    ContainerOrderFocusTraversalPolicy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFocusCycleRoot" type="boolean" line="3443"/>
            <javadoc line="3447">
                Sets whether this container will be used to provide focus
                  traversal policy. Container with this property as
                  &lt;code&gt;true&lt;/code&gt; will be used to acquire focus traversal policy
                  instead of closest focus cycle root ancestor.                
                <param>
                    provider indicates whether this container will be used to
                      provide focus traversal policy                    
                </param>
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    #isFocusTraversalPolicyProvider                    
                </see>
                <since>
                    1.5                    
                </since>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="setFocusTraversalPolicyProvider" type="void" line="3461">
                <params>
                    <param name="provider" type="boolean"/>
                </params>
                <declaration name="oldProvider" type="boolean" line="3462"/>
                <scope line="3463"/>
            </method>
            <javadoc line="3470">
                Returns whether this container provides focus traversal
                  policy. If this property is set to &lt;code&gt;true&lt;/code&gt; then when
                  keyboard focus manager searches container hierarchy for focus
                  traversal policy and encounters this container before any other
                  container with this property as true or focus cycle roots then
                  its focus traversal policy will be used instead of focus cycle
                  root&apos;s policy.                
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #setFocusTraversalPolicyProvider                    
                </see>
                <return>
                    <code>true</code> if this container provides focus traversal
                      policy, <code>false</code> otherwise                    
                </return>
                <since>
                    1.5                    
                </since>
                <beaninfo>
                    bound: true                    
                </beaninfo>
            </javadoc>
            <method name="isFocusTraversalPolicyProvider" type="boolean" line="3488"/>
            <javadoc line="3492">
                Transfers the focus down one focus traversal cycle. If this Container is
                  a focus cycle root, then the focus owner is set to this Container&apos;s
                  default Component to focus, and the current focus cycle root is set to
                  this Container. If this Container is not a focus cycle root, then no
                  focus traversal operation occurs.                
                <see>
                    Component#requestFocus()                    
                </see>
                <see>
                    #isFocusCycleRoot                    
                </see>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="transferFocusDownCycle" type="void" line="3504">
                <scope line="3505">
                    <declaration name="toFocus" type="Component" line="3508"/>
                    <scope line="3510"/>
                </scope>
            </method>
            <method name="preProcessKeyEvent" type="void" line="3516">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <declaration name="parent" type="Container" line="3517"/>
                <scope line="3518"/>
            </method>
            <method name="postProcessKeyEvent" type="void" line="3523">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <declaration name="parent" type="Container" line="3524"/>
                <scope line="3525"/>
            </method>
            <method name="postsOldMouseEvents" type="boolean" line="3530"/>
            <javadoc line="3534">
                Sets the &lt;code&gt;ComponentOrientation&lt;/code&gt; property of this container
                  and all components contained within it.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy.                
                <param>
                    o the new component orientation of this container and
                      the components contained within it.                    
                </param>
                <exception>
                    NullPointerException if <code>orientation</code> is null.                    
                </exception>
                <see>
                    Component#setComponentOrientation                    
                </see>
                <see>
                    Component#getComponentOrientation                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="applyComponentOrientation" type="void" line="3549">
                <params>
                    <param name="o" type="ComponentOrientation"/>
                </params>
                <scope line="3551">
                    <scope line="3552">
                        <declaration name="comp" type="Component" line="3553"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3559">
                Adds a PropertyChangeListener to the listener list. The listener is
                  registered for all bound properties of this class, including the
                  following:
                  &lt;ul&gt;
                  &lt;li&gt;this Container&apos;s font (&quot;font&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s background color (&quot;background&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focusability (&quot;focusable&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus traversal keys enabled state
                  (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of FORWARD_TRAVERSAL_KEYS
                  (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of BACKWARD_TRAVERSAL_KEYS
                  (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of UP_CYCLE_TRAVERSAL_KEYS
                  (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
                  (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
                  &lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus-cycle-root state (&quot;focusCycleRoot&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  Note that if this Container is inheriting a bound property, then no
                  event will be fired in response to a change in the inherited property.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    listener  the PropertyChangeListener to be added                    
                </param>
                <see>
                    Component#removePropertyChangeListener                    
                </see>
                <see>
                    #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)                    
                </see>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="3592">
                <params>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
            </method>
            <javadoc line="3596">
                Adds a PropertyChangeListener to the listener list for a specific
                  property. The specified property may be user-defined, or one of the
                  following defaults:
                  &lt;ul&gt;
                  &lt;li&gt;this Container&apos;s font (&quot;font&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s background color (&quot;background&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focusability (&quot;focusable&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus traversal keys enabled state
                  (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of FORWARD_TRAVERSAL_KEYS
                  (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of BACKWARD_TRAVERSAL_KEYS
                  (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of UP_CYCLE_TRAVERSAL_KEYS
                  (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
                  (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
                  &lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus-cycle-root state (&quot;focusCycleRoot&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus-traversal-policy-provider state(&quot;focusTraversalPolicyProvider&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus-traversal-policy-provider state(&quot;focusTraversalPolicyProvider&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  Note that if this Container is inheriting a bound property, then no
                  event will be fired in response to a change in the inherited property.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    propertyName one of the property names listed above                    
                </param>
                <param>
                    listener the PropertyChangeListener to be added                    
                </param>
                <see>
                    #addPropertyChangeListener(java.beans.PropertyChangeListener)                    
                </see>
                <see>
                    Component#removePropertyChangeListener                    
                </see>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="3633">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
            </method>
            <declaration name="containerSerializedDataVersion" type="int" line="3640"/>
            <javadoc line="3640">
                Container Serial Data Version.                
            </javadoc>
            <javadoc line="3645">
                Serializes this &lt;code&gt;Container&lt;/code&gt; to the specified
                  &lt;code&gt;ObjectOutputStream&lt;/code&gt;.
                  &lt;ul&gt;
                  &lt;li&gt;Writes default serializable fields to the stream.&lt;/li&gt;
                  &lt;li&gt;Writes a list of serializable ContainerListener(s) as optional
                  data. The non-serializable ContainerListner(s) are detected and
                  no attempt is made to serialize them.&lt;/li&gt;
                  &lt;li&gt;Write this Container&apos;s FocusTraversalPolicy if and only if it
                  is Serializable; otherwise, &lt;code&gt;null&lt;/code&gt; is written.&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    s the <code>ObjectOutputStream</code> to write                    
                </param>
                <serialData>
                    <code>null</code> terminated sequence of 0 or more pairs;
                      the pair consists of a <code>String</code> and <code>Object</code>;
                      the <code>String</code> indicates the type of object and
                      is one of the following:
                      <code>containerListenerK</code> indicating an
                      <code>ContainerListener</code> object;
                      the <code>Container</code>'s <code>FocusTraversalPolicy</code>,
                      or <code>null</code>                    
                </serialData>
                <see>
                    AWTEventMulticaster#save(java.io.ObjectOutputStream,java.lang.String,java.util.EventListener)                    
                </see>
                <see>
                    Container#containerListenerK                    
                </see>
                <see>
                    #readObject(ObjectInputStream)                    
                </see>
            </javadoc>
            <method name="writeObject" type="void" line="3671">
                <params>
                    <param name="s" type="ObjectOutputStream"/>
                </params>
                <declaration name="f" type="ObjectOutputStream.PutField" line="3672"/>
                <scope line="3686"/>
                <scope line="3688"/>
            </method>
            <javadoc line="3693">
                Deserializes this &lt;code&gt;Container&lt;/code&gt; from the specified
                  &lt;code&gt;ObjectInputStream&lt;/code&gt;.
                  &lt;ul&gt;
                  &lt;li&gt;Reads default serializable fields from the stream.&lt;/li&gt;
                  &lt;li&gt;Reads a list of serializable ContainerListener(s) as optional
                  data. If the list is null, no Listeners are installed.&lt;/li&gt;
                  &lt;li&gt;Reads this Container&apos;s FocusTraversalPolicy, which may be null,
                  as optional data.&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    s the <code>ObjectInputStream</code> to read                    
                </param>
                <serial>
                                        
                </serial>
                <see>
                    #addContainerListener                    
                </see>
                <see>
                    #writeObject(ObjectOutputStream)                    
                </see>
            </javadoc>
            <method name="readObject" type="void" line="3711">
                <params>
                    <param name="s" type="ObjectInputStream"/>
                </params>
                <comment line="3722">
                    Old stream. Doesn&apos;t contain maxSize among Component&apos;s fields.                    
                </comment>
                <comment line="3746">
                    skip value for unrecognized key                    
                </comment>
                <comment line="3757">
                    JDK 1.1/1.2/1.3 instances will not have this optional data.
                     e.eof will be true to indicate that there is no more data
                     available for this object. If e.eof is not true, throw the
                     exception as it might have been caused by reasons unrelated to
                     focusTraversalPolicy.                    
                </comment>
                <declaration name="f" type="ObjectInputStream.GetField" line="3712"/>
                <declaration name="tmpComponent" type="Component[]" line="3713"/>
                <declaration name="ncomponents" type="int" line="3714"/>
                <scope line="3716"/>
                <scope line="3722"/>
                <declaration name="component" type="java.util.List&lt;Component&gt;" line="3728"/>
                <scope line="3729"/>
                <declaration name="keyOrNull" type="Object" line="3738"/>
                <scope line="3739">
                    <declaration name="key" type="String" line="3740"/>
                    <scope line="3742"/>
                    <scope line="3744"/>
                </scope>
                <scope line="3750">
                    <declaration name="policy" type="Object" line="3751"/>
                    <scope line="3752"/>
                </scope>
                <scope line="3755">
                    <scope line="3762"/>
                </scope>
            </method>
            <class name="AccessibleAWTContainer" line="3772">
                <extends class="AccessibleAWTComponent"/>
                <javadoc line="3772">
                    Inner class of Container used to provide default support for
                      accessibility.  This class is not meant to be used directly by
                      application developers, but is instead meant only to be
                      subclassed by container developers.
                      &lt;p&gt;
                      The class used to obtain the accessible role for this object,
                      as well as implementing many of the methods in the
                      AccessibleContainer interface.                    
                    <since>
                        1.3                        
                    </since>
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3785"/>
                <javadoc line="3785">
                    JDK1.3 serialVersionUID                    
                </javadoc>
                <javadoc line="3790">
                    Returns the number of accessible children in the object.  If all
                      of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
                      then this method should return the number of children of this object.                    
                    <return>
                        the number of accessible children in the object                        
                    </return>
                </javadoc>
                <method name="getAccessibleChildrenCount" type="int" line="3797"/>
                <javadoc line="3801">
                    Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.                    
                    <param>
                        i zero-based index of child                        
                    </param>
                    <return>
                        the nth <code>Accessible</code> child of the object                        
                    </return>
                </javadoc>
                <method name="getAccessibleChild" type="Accessible" line="3807">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <javadoc line="3811">
                    Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,
                      contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.                    
                    <param>
                        p the point defining the top-left corner of the
                          <code>Accessible</code>, given in the coordinate space
                          of the object's parent                        
                    </param>
                    <return>
                        the <code>Accessible</code>, if it exists,
                          at the specified location; else <code>null</code>                        
                    </return>
                </javadoc>
                <method name="getAccessibleAt" type="Accessible" line="3821">
                    <params>
                        <param name="p" type="Point"/>
                    </params>
                </method>
                <declaration name="accessibleContainerHandler" type="ContainerListener" line="3825"/>
                <class name="AccessibleContainerHandler" line="3827">
                    <implements interface="ContainerListener"/>
                    <javadoc line="3827">
                        Fire &lt;code&gt;PropertyChange&lt;/code&gt; listener, if one is registered,
                          when children are added or removed.                        
                        <since>
                            1.3                            
                        </since>
                    </javadoc>
                    <method name="componentAdded" type="void" line="3834">
                        <params>
                            <param name="e" type="ContainerEvent"/>
                        </params>
                        <declaration name="c" type="Component" line="3835"/>
                        <scope line="3836"/>
                    </method>
                    <method name="componentRemoved" type="void" line="3842">
                        <params>
                            <param name="e" type="ContainerEvent"/>
                        </params>
                        <declaration name="c" type="Component" line="3843"/>
                        <scope line="3844"/>
                    </method>
                </class>
                <javadoc line="3852">
                    Adds a PropertyChangeListener to the listener list.                    
                    <param>
                        listener  the PropertyChangeListener to be added                        
                    </param>
                </javadoc>
                <method name="addPropertyChangeListener" type="void" line="3857">
                    <params>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                    <scope line="3858"/>
                </method>
            </class>
            <javadoc line="3867">
                Returns the &lt;code&gt;Accessible&lt;/code&gt; child contained at the local
                  coordinate &lt;code&gt;Point&lt;/code&gt;, if one exists.  Otherwise
                  returns &lt;code&gt;null&lt;/code&gt;.                
                <param>
                    p the point defining the top-left corner of the
                      <code>Accessible</code>, given in the coordinate space
                      of the object's parent                    
                </param>
                <return>
                    the <code>Accessible</code> at the specified location,
                      if it exists; otherwise <code>null</code>                    
                </return>
            </javadoc>
            <method name="getAccessibleAt" type="Accessible" line="3878">
                <params>
                    <param name="p" type="Point"/>
                </params>
                <scope line="3879">
                    <scope line="3880">
                        <declaration name="a" type="Accessible" line="3881"/>
                        <declaration name="ac" type="AccessibleContext" line="3882"/>
                        <scope line="3883">
                            <declaration name="acmp" type="AccessibleComponent" line="3884"/>
                            <declaration name="location" type="Point" line="3885"/>
                            <declaration name="nchildren" type="int" line="3886"/>
                            <scope line="3887">
                                <scope line="3889">
                                    <scope line="3891">
                                        <scope line="3893">
                                            <declaration name="np" type="Point" line="3895"/>
                                            <scope line="3897"/>
                                        </scope>
                                    </scope>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="3906">
                        <declaration name="ret" type="Component" line="3907"/>
                        <scope line="3908"/>
                        <scope line="3910">
                            <declaration name="ncomponents" type="int" line="3911"/>
                            <scope line="3912">
                                <declaration name="comp" type="Component" line="3913"/>
                                <scope line="3914">
                                    <declaration name="location" type="Point" line="3915"/>
                                    <scope line="3916"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="3922"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3930">
                Returns the number of accessible children in the object.  If all
                  of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
                  then this method should return the number of children of this object.                
                <return>
                    the number of accessible children in the object                    
                </return>
            </javadoc>
            <method name="getAccessibleChildrenCount" type="int" line="3937">
                <scope line="3938">
                    <declaration name="count" type="int" line="3939"/>
                    <declaration name="children" type="Component[]" line="3940"/>
                    <scope line="3941">
                        <scope line="3942"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3950">
                Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.                
                <param>
                    i zero-based index of child                    
                </param>
                <return>
                    the nth <code>Accessible</code> child of the object                    
                </return>
            </javadoc>
            <method name="getAccessibleChild" type="Accessible" line="3956">
                <params>
                    <param name="i" type="int"/>
                </params>
                <scope line="3957">
                    <declaration name="children" type="Component[]" line="3958"/>
                    <declaration name="count" type="int" line="3959"/>
                    <scope line="3960">
                        <scope line="3961">
                            <scope line="3962"/>
                            <scope line="3964"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="increaseComponentCount" type="void" line="3975">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="3976">
                    <scope line="3977"/>
                    <declaration name="addHW" type="int" line="3983"/>
                    <declaration name="addLW" type="int" line="3984"/>
                    <scope line="3986"/>
                    <scope line="3990"/>
                    <scope line="3992"/>
                    <scope line="3996"/>
                </scope>
            </method>
            <method name="decreaseComponentCount" type="void" line="4003">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="4004">
                    <scope line="4005"/>
                    <declaration name="subHW" type="int" line="4011"/>
                    <declaration name="subLW" type="int" line="4012"/>
                    <scope line="4014"/>
                    <scope line="4018"/>
                    <scope line="4020"/>
                    <scope line="4024"/>
                </scope>
            </method>
            <method name="getTopmostComponentIndex" type="int" line="4031">
                <scope line="4033"/>
            </method>
            <method name="getBottommostComponentIndex" type="int" line="4039">
                <scope line="4041"/>
            </method>
            <method name="getOpaqueShape" type="Region" line="4052">
                <scope line="4056">
                    <declaration name="s" type="Region" line="4057"/>
                    <scope line="4058">
                        <declaration name="c" type="Component" line="4059"/>
                        <scope line="4060"/>
                    </scope>
                </scope>
            </method>
            <method name="recursiveSubtractAndApplyShape" type="void" line="4069">
                <params>
                    <param name="shape" type="Region"/>
                </params>
            </method>
            <method name="recursiveSubtractAndApplyShape" type="void" line="4073">
                <params>
                    <param name="shape" type="Region"/>
                    <param name="fromZorder" type="int"/>
                </params>
            </method>
            <method name="recursiveSubtractAndApplyShape" type="void" line="4077">
                <params>
                    <param name="shape" type="Region"/>
                    <param name="fromZorder" type="int"/>
                    <param name="toZorder" type="int"/>
                </params>
                <comment line="4090">
                    An invalid container with not-null layout should be ignored
                     by the mixing code, the container will be validated later
                     and the mixing code will be executed later.                    
                </comment>
                <scope line="4079"/>
                <scope line="4083"/>
                <scope line="4086"/>
                <scope line="4092"/>
                <scope line="4095">
                    <declaration name="comp" type="Component" line="4096"/>
                    <scope line="4097"/>
                    <scope line="4100"/>
                </scope>
            </method>
            <method name="recursiveApplyCurrentShape" type="void" line="4106"/>
            <method name="recursiveApplyCurrentShape" type="void" line="4110">
                <params>
                    <param name="fromZorder" type="int"/>
                </params>
            </method>
            <method name="recursiveApplyCurrentShape" type="void" line="4114">
                <params>
                    <param name="fromZorder" type="int"/>
                    <param name="toZorder" type="int"/>
                </params>
                <comment line="4124">
                    An invalid container with not-null layout should be ignored
                     by the mixing code, the container will be validated later
                     and the mixing code will be executed later.                    
                </comment>
                <scope line="4116"/>
                <scope line="4120"/>
                <scope line="4126"/>
                <scope line="4129">
                    <declaration name="comp" type="Component" line="4130"/>
                    <scope line="4131"/>
                    <scope line="4135"/>
                </scope>
            </method>
            <method name="recursiveShowHeavyweightChildren" type="void" line="4141">
                <scope line="4142"/>
                <scope line="4145">
                    <declaration name="comp" type="Component" line="4146"/>
                    <scope line="4147">
                        <scope line="4148"/>
                    </scope>
                    <scope line="4151">
                        <scope line="4152">
                            <declaration name="peer" type="ComponentPeer" line="4153"/>
                            <scope line="4154"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="recursiveHideHeavyweightChildren" type="void" line="4162">
                <scope line="4163"/>
                <scope line="4166">
                    <declaration name="comp" type="Component" line="4167"/>
                    <scope line="4168">
                        <scope line="4169"/>
                    </scope>
                    <scope line="4172">
                        <scope line="4173">
                            <declaration name="peer" type="ComponentPeer" line="4174"/>
                            <scope line="4175"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="recursiveRelocateHeavyweightChildren" type="void" line="4183">
                <params>
                    <param name="origin" type="Point"/>
                </params>
                <scope line="4184">
                    <declaration name="comp" type="Component" line="4185"/>
                    <scope line="4186">
                        <scope line="4189">
                            <declaration name="newOrigin" type="Point" line="4190"/>
                        </scope>
                    </scope>
                    <scope line="4194">
                        <declaration name="peer" type="ComponentPeer" line="4195"/>
                        <scope line="4196"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="4205">
                Checks if the container and its direct lightweight containers are
                  visible.
                  Consider the heavyweight container hides or shows the HW descendants
                  automatically. Therefore we care of LW containers&apos; visibility only.
                  This method MUST be invoked under the TreeLock.                
            </javadoc>
            <method name="isRecursivelyVisibleUpToHeavyweightContainer" type="boolean" line="4214">
                <scope line="4215"/>
                <scope line="4222">
                    <scope line="4223"/>
                </scope>
            </method>
            <method name="mixOnShowing" type="void" line="4231">
                <scope line="4232">
                    <scope line="4233"/>
                    <declaration name="isLightweight" type="boolean" line="4237"/>
                    <scope line="4239"/>
                    <scope line="4243"/>
                    <scope line="4247"/>
                </scope>
            </method>
            <method name="mixOnHiding" type="void" line="4256">
                <params>
                    <param name="isLightweight" type="boolean"/>
                </params>
                <scope line="4257">
                    <scope line="4258"/>
                    <scope line="4262"/>
                </scope>
            </method>
            <method name="mixOnReshaping" type="void" line="4270">
                <scope line="4271">
                    <scope line="4272"/>
                    <declaration name="isMixingNeeded" type="boolean" line="4276"/>
                    <scope line="4278">
                        <declaration name="origin" type="Point" line="4279"/>
                        <scope line="4283"/>
                        <scope line="4289"/>
                    </scope>
                    <scope line="4296"/>
                </scope>
            </method>
            <method name="mixOnZOrderChanging" type="void" line="4305">
                <params>
                    <param name="oldZorder" type="int"/>
                    <param name="newZorder" type="int"/>
                </params>
                <scope line="4306">
                    <scope line="4307"/>
                    <scope line="4312"/>
                    <declaration name="becameHigher" type="boolean" line="4316"/>
                    <scope line="4318"/>
                </scope>
            </method>
            <method name="mixOnValidating" type="void" line="4326">
                <scope line="4327">
                    <scope line="4328"/>
                    <scope line="4332"/>
                    <scope line="4336"/>
                    <scope line="4340"/>
                </scope>
            </method>
        </class>
        <class name="LightweightDispatcher" line="4352">
            <comment line="164">
                keeps track of the threads that are printing this component                
            </comment>
            <comment line="166">
                True if there is at least one thread that&apos;s printing this component                
            </comment>
            <comment line="171">
                                
            </comment>
            <comment line="176">
                                
            </comment>
            <comment line="203">
                Number of HW or LW components in this container (including
                 all descendant containers).                
            </comment>
            <comment line="347">
                NOTE: This method may be called by privileged threads.
                       This functionality is implemented in a package-private method
                       to insure that it cannot be overridden by client subclasses.
                       DO NOT INVOKE CLIENT CODE ON THIS THREAD!                
            </comment>
            <comment line="355">
                Wrapper for getComponents() method with a proper synchronization.                
            </comment>
            <comment line="1319">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1356">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1381">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1390">
                Should only be called while holding tree lock                
            </comment>
            <comment line="1397">
                Should only be called while holding tree lock                
            </comment>
            <comment line="2199">
                REMIND: remove when filtering is done at lower level                
            </comment>
            <comment line="2265">
                Dispatches an event to this component or one of its sub components.
                 Create ANCESTOR_RESIZED and ANCESTOR_MOVED events in response to
                 COMPONENT_RESIZED and COMPONENT_MOVED events. We have to do this
                 here instead of in processComponentEvent because ComponentEvents
                 may not be enabled for this Container.
                 @param e the event                
            </comment>
            <comment line="2306">
                Dispatches an event to this component, without trying to forward
                 it to any subcomponents
                 @param e the event                
            </comment>
            <comment line="2843">
                The following code was added to support modal JInternalFrames
                 Unfortunately this code has to be added here so that we can get access to
                 some private AWT classes like SequencedEvent.
                
                 The native container of the LW component has this field set
                 to tell it that it should block Mouse events for all LW
                 children except for the modal component.
                
                 In the case of nested Modal components, we store the previous
                 modal component in the new modal components value of modalComp;                
            </comment>
            <comment line="2969">
                                
            </comment>
            <comment line="3638">
                Serialization support. A Container is responsible for restoring the
                 parent fields of its component children.                
            </comment>
            <comment line="3769">
                --- Accessibility Support ---                
            </comment>
            <comment line="3866">
                inner class AccessibleAWTContainer                
            </comment>
            <comment line="3974">
                ************************** MIXING CODE *******************************                
            </comment>
            <comment line="4048">
                This method is overriden to handle opaque children in non-opaque
                 containers.                
            </comment>
            <comment line="4349">
                ****************** END OF MIXING CODE ********************************                
            </comment>
            <comment line="4365">
                JDK 1.1 serialVersionUID                
            </comment>
            <comment line="4369">
                Our own mouse event for when we&apos;re dragged over from another hw
                 container                
            </comment>
            <comment line="4383">
                Clean up any resources allocated when dispatcher was created;
                 should be called from Container.removeNotify                
            </comment>
            <comment line="4434">
                This method effectively returns whether or not a mouse button was down
                 just BEFORE the event happened.  A better method name might be
                 wasAMouseButtonDownBeforeThisEvent().                
            </comment>
            <comment line="4575">
                Generates enterexit events as mouse moves over lw components
                 @param targetOver        Target mouse is over (including native container)
                 @param e                 Mouse event in native container                
            </comment>
            <comment line="4631">
                Listens to global mouse drag events so even drags originating
                 from other heavyweight containers will generate enterexit
                 events in this container                
            </comment>
            <comment line="4663">
                (Implementation of AWTEventListener)
                 Listen for drag events posted in other hw components so we can
                 track enterexit regardless of where a drag originated                
            </comment>
            <comment line="4845">
                --- member variables -------------------------------                
            </comment>
            <implements interface="java.io.Serializable"/>
            <implements interface="AWTEventListener"/>
            <javadoc line="4352">
                Class to manage the dispatching of MouseEvents to the lightweight descendants
                  and SunDropTargetEvents to both lightweight and heavyweight descendants
                  contained by a native container.
                  NOTE: the class name is not appropriate anymore, but we cannot change it
                  because we must keep serialization compatibility.                
                <author>
                    Timothy Prinzing                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="4367"/>
            <declaration name="LWD_MOUSE_DRAGGED_OVER" type="int" line="4372"/>
            <declaration name="eventLog" type="PlatformLogger" line="4374"/>
            <method name="LightweightDispatcher" type="constructor" line="4376">
                <params>
                    <param name="nativeContainer" type="Container"/>
                </params>
            </method>
            <method name="dispose" type="void" line="4386">
                <comment line="4388">
                    System.out.println(&quot;Disposing lw dispatcher&quot;);                    
                </comment>
            </method>
            <javadoc line="4392">
                Enables events to subcomponents.                
            </javadoc>
            <method name="enableEvents" type="void" line="4395">
                <params>
                    <param name="events" type="long"/>
                </params>
            </method>
            <javadoc line="4399">
                Dispatches an event to a sub-component if necessary, and
                  returns whether or not the event was forwarded to a
                  sub-component.                
                <param>
                    e the event                    
                </param>
            </javadoc>
            <method name="dispatchEvent" type="boolean" line="4406">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <comment line="4410">
                    Fix for BugTraq Id 4389284.
                     Dispatch SunDropTargetEvents regardless of eventMask value.
                     Do not update cursor on dispatching SunDropTargetEvents.                    
                </comment>
                <declaration name="ret" type="boolean" line="4407"/>
                <scope line="4414">
                    <declaration name="sdde" type="SunDropTargetEvent" line="4416"/>
                </scope>
                <scope line="4419">
                    <scope line="4420">
                        <declaration name="me" type="MouseEvent" line="4421"/>
                    </scope>
                    <scope line="4425"/>
                </scope>
            </method>
            <method name="isMouseGrab" type="boolean" line="4437">
                <params>
                    <param name="e" type="MouseEvent"/>
                </params>
                <comment line="4456">
                                        
                </comment>
                <declaration name="modifiers" type="int" line="4438"/>
                <scope line="4442"/>
            </method>
            <javadoc line="4461">
                This method attempts to distribute a mouse event to a lightweight
                  component.  It tries to avoid doing any unnecessary probes down
                  into the component tree to minimize the overhead of determining
                  where to route the event, since mouse movement events tend to
                  come in large and frequent amounts.                
            </javadoc>
            <method name="processMouseEvent" type="boolean" line="4468">
                <params>
                    <param name="e" type="MouseEvent"/>
                </params>
                <comment line="4471">
                    sensitive to mouse events                    
                </comment>
                <comment line="4477">
                    4508327 : MOUSE_CLICKED should only go to the recipient of
                     the accompanying MOUSE_PRESSED, so don&apos;t reset mouseEventTarget on a
                     MOUSE_CLICKED.                    
                </comment>
                <comment line="4496">
                    4508327: MOUSE_CLICKED should never be dispatched to a Component
                     other than that which received the MOUSE_PRESSED event.  If the
                     mouse is now over a different Component, don&apos;t dispatch the event.
                     The previous fix for a similar problem was associated with bug
                     4155217.                    
                </comment>
                <comment line="4514">
                    This may send it somewhere that doesn&apos;t have MouseWheelEvents
                     enabled.  In this case, Component.dispatchEventImpl() will
                     retarget the event to a parent that DOES have the events enabled.                    
                </comment>
                <comment line="4525">
                    Consuming of wheel events is implemented in &quot;retargetMouseEvent&quot;.                    
                </comment>
                <declaration name="id" type="int" line="4469"/>
                <declaration name="mouseOver" type="Component" line="4470"/>
                <scope line="4479"/>
                <scope line="4483">
                    <scope line="4500"/>
                    <scope line="4508"/>
                    <scope line="4516"/>
                    <scope line="4525"/>
                </scope>
            </method>
            <method name="processDropTargetEvent" type="boolean" line="4532">
                <params>
                    <param name="e" type="SunDropTargetEvent"/>
                </params>
                <comment line="4538">
                    Fix for BugTraq ID 4395290.
                     It is possible that SunDropTargetEvent&apos;s Point is outside of the
                     native container bounds. In this case we truncate coordinates.                    
                </comment>
                <comment line="4556">
                    not necessarily sensitive to mouse events                    
                </comment>
                <declaration name="id" type="int" line="4533"/>
                <declaration name="x" type="int" line="4534"/>
                <declaration name="y" type="int" line="4535"/>
                <scope line="4542">
                    <declaration name="d" type="Dimension" line="4543"/>
                    <scope line="4544"/>
                    <scope line="4546"/>
                    <scope line="4549"/>
                    <scope line="4551"/>
                </scope>
                <declaration name="mouseOver" type="Component" line="4555"/>
                <scope line="4560"/>
            </method>
            <method name="trackMouseEnterExit" type="void" line="4579">
                <params>
                    <param name="targetOver" type="Component"/>
                    <param name="e" type="MouseEvent"/>
                </params>
                <comment line="4587">
                    This can happen if a lightweight component which initiated the
                     drag has an associated drop target. MOUSE_ENTERED comes when the
                     mouse is in the native container already. To propagate this event
                     properly we should null out targetLastEntered.                    
                </comment>
                <comment line="4596">
                    any event but an exit or drag means we&apos;re in the native container                    
                </comment>
                <comment line="4616">
                    consume native exit event if we generate one                    
                </comment>
                <comment line="4624">
                    consume native enter event if we generate one                    
                </comment>
                <declaration name="targetEnter" type="Component" line="4580"/>
                <declaration name="id" type="int" line="4581"/>
                <scope line="4585"/>
                <scope line="4594"/>
                <scope line="4598"/>
                <scope line="4603"/>
                <scope line="4607"/>
                <scope line="4611"/>
                <scope line="4614"/>
                <scope line="4619"/>
                <scope line="4622"/>
            </method>
            <method name="startListeningForOtherDrags" type="void" line="4635">
                <comment line="4637">
                    System.out.println(&quot;Adding AWTEventListener&quot;);                    
                </comment>
                <anonymous_class line="4638">
                    <method name="run" type="Object" line="4639"/>
                </anonymous_class>
            </method>
            <method name="stopListeningForOtherDrags" type="void" line="4650">
                <comment line="4652">
                    System.out.println(&quot;Removing AWTEventListener&quot;);                    
                </comment>
                <anonymous_class line="4653">
                    <method name="run" type="Object" line="4654"/>
                </anonymous_class>
            </method>
            <method name="eventDispatched" type="void" line="4667">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <comment line="4675">
                    only interested in drags from other hw components                    
                </comment>
                <comment line="4685">
                    component may have disappeared since drag event posted
                     (i.e. Swing hierarchical menus)                    
                </comment>
                <comment line="4691">
                    see 5083555
                     check if srcComponent is in any modal blocked window                    
                </comment>
                <comment line="4701">
                    create an internal &apos;dragged-over&apos; event indicating
                     we are being dragged over from another hw component                    
                </comment>
                <comment line="4717">
                    translate coordinates to this native container                    
                </comment>
                <comment line="4749">
                    System.out.println(&quot;Track event: &quot; + me);
                     feed the &apos;dragged-over&apos; event directly to the enter/exit
                     code (not a real event so don&apos;t pass it to dispatchEvent)                    
                </comment>
                <declaration name="isForeignDrag" type="boolean" line="4668"/>
                <scope line="4673"/>
                <declaration name="srcEvent" type="MouseEvent" line="4678"/>
                <declaration name="me" type="MouseEvent" line="4679"/>
                <scope line="4681">
                    <declaration name="srcComponent" type="Component" line="4682"/>
                    <scope line="4686"/>
                    <declaration name="c" type="Component" line="4692"/>
                    <scope line="4693"/>
                    <scope line="4696"/>
                    <declaration name="ptSrcOrigin" type="Point" line="4717"/>
                    <scope line="4719">
                        <declaration name="mouseEvent" type="MouseEvent" line="4720"/>
                        <anonymous_class line="4721">
                            <method name="run" type="void" line="4722">
                                <scope line="4723"/>
                                <declaration name="ptDstOrigin" type="Point" line="4727"/>
                                <declaration name="targetOver" type="Component" line="4730"/>
                            </method>
                        </anonymous_class>
                        <declaration name="r" type="Runnable" line="4721"/>
                    </scope>
                    <scope line="4739">
                        <scope line="4740"/>
                        <declaration name="ptDstOrigin" type="Point" line="4744"/>
                    </scope>
                </scope>
                <declaration name="targetOver" type="Component" line="4751"/>
            </method>
            <javadoc line="4757">
                Sends a mouse event to the current mouse event recipient using
                  the given event (sent to the windowed host) as a srcEvent.  If
                  the mouse event target is still in the component tree, the
                  coordinates of the event are translated to those of the target.
                  If the target has been removed, we don&apos;t bother to send the
                  message.                
            </javadoc>
            <method name="retargetMouseEvent" type="void" line="4765">
                <params>
                    <param name="target" type="Component"/>
                    <param name="id" type="int"/>
                    <param name="e" type="MouseEvent"/>
                </params>
                <comment line="4768">
                    mouse is over another hw component or target is disabled                    
                </comment>
                <comment line="4821">
                    avoid recursively calling LightweightDispatcher...                    
                </comment>
                <comment line="4837">
                    An exception for wheel bubbling to the native system.
                    In &quot;processMouseEvent&quot; total event consuming for wheel events is skipped.
                    Protection from bubbling of Java-accepted wheel events.                    
                </comment>
                <scope line="4766"/>
                <declaration name="x" type="int" line="4770"/>
                <declaration name="component" type="Component" line="4771"/>
                <scope line="4775"/>
                <declaration name="retargeted" type="MouseEvent" line="4779"/>
                <scope line="4780">
                    <scope line="4781"/>
                    <scope line="4787"/>
                    <scope line="4803"/>
                    <scope line="4819"/>
                    <scope line="4822">
                        <scope line="4825">
                            <scope line="4826"/>
                            <scope line="4828"/>
                        </scope>
                        <scope line="4831"/>
                    </scope>
                    <scope line="4835"/>
                </scope>
            </method>
            <declaration name="nativeContainer" type="Container" line="4846"/>
            <javadoc line="4846">
                The windowed container that might be hosting events for
                  subcomponents.                
            </javadoc>
            <declaration name="focus" type="Component" line="4852"/>
            <javadoc line="4852">
                This variable is not used, but kept for serialization compatibility                
            </javadoc>
            <declaration name="mouseEventTarget" type="Component" line="4857"/>
            <javadoc line="4857">
                The current subcomponent being hosted by this windowed
                  component that has events being forwarded to it.  If this
                  is null, there are currently no events being forwarded to
                  a subcomponent.                
            </javadoc>
            <declaration name="targetLastEntered" type="Component" line="4865"/>
            <javadoc line="4865">
                The last component entered                
            </javadoc>
            <declaration name="isMouseInNativeContainer" type="boolean" line="4870"/>
            <javadoc line="4870">
                Is the mouse over the native container                
            </javadoc>
            <declaration name="nativeCursor" type="Cursor" line="4875"/>
            <javadoc line="4875">
                This variable is not used, but kept for serialization compatibility                
            </javadoc>
            <declaration name="eventMask" type="long" line="4880"/>
            <javadoc line="4880">
                The event mask for contained lightweight components.  Lightweight
                  components need a windowed container to host window-related
                  events.  This separate mask indicates events that have been
                  requested by contained lightweight components without effecting
                  the mask of the windowed component itself.                
            </javadoc>
            <declaration name="PROXY_EVENT_MASK" type="long" line="4889"/>
            <javadoc line="4889">
                The kind of events routed to lightweight components from windowed
                  hosts.                
            </javadoc>
            <declaration name="MOUSE_MASK" type="long" line="4900"/>
        </class>
    </source>