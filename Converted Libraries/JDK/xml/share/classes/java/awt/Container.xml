<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.awt.dnd.DropTarget"/>
        <import package="java.awt.event"/>
        <import package="java.awt.peer.ContainerPeer"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.peer.LightweightPeer"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.ObjectStreamField"/>
        <import package="java.io.PrintStream"/>
        <import package="java.io.PrintWriter"/>
        <import package="java.security.AccessController"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.EventListener"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Set"/>
        <import package="javax.accessibility"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.AWTAccessor"/>
        <import package="sun.awt.CausedFocusEvent"/>
        <import package="sun.awt.PeerEvent"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.dnd.SunDropTargetEvent"/>
        <import package="sun.java2d.pipe.Region"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <class name="Container" line="29">
            <extends class="Component"/>
            <javadoc line="29">
                A generic Abstract Window Toolkit(AWT) container object is a component
                  that can contain other AWT components.
                  &lt;p&gt;
                  Components added to a container are tracked in a list.  The order
                  of the list will define the components&apos; front-to-back stacking order
                  within the container.  If no index is specified when adding a
                  component to a container, it will be added to the end of the list
                  (and hence to the bottom of the stacking order).
                  &lt;p&gt;
                  &lt;b&gt;Note&lt;/b&gt;: For details on the focus subsystem, see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                  &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
                  for more information.                
                <author>
                    Arthur van Hoff                    
                </author>
                <author>
                    Sami Shaio                    
                </author>
                <see>
                    #add(java.awt.Component,int)                    
                </see>
                <see>
                    #getComponent(int)                    
                </see>
                <see>
                    LayoutManager                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="log" type="PlatformLogger" line="53"/>
            <declaration name="eventLog" type="PlatformLogger" line="54"/>
            <declaration name="EMPTY_ARRAY" type="Component[]" line="55"/>
            <declaration name="component" type="java.util.List&lt;Component&gt;" line="56"/>
            <javadoc line="56">
                The components in this container.                
                <see>
                    #add                    
                </see>
                <see>
                    #getComponents                    
                </see>
            </javadoc>
            <declaration name="layoutMgr" type="LayoutManager" line="62"/>
            <javadoc line="62">
                Layout manager for this container.                
                <see>
                    #doLayout                    
                </see>
                <see>
                    #setLayout                    
                </see>
                <see>
                    #getLayout                    
                </see>
            </javadoc>
            <declaration name="dispatcher" type="LightweightDispatcher" line="69"/>
            <javadoc line="69">
                Event router for lightweight components.  If this container
                  is native, this dispatcher takes care of forwarding and
                  retargeting the events to lightweight components contained
                  (if any).                
            </javadoc>
            <declaration name="focusTraversalPolicy" type="FocusTraversalPolicy" line="76"/>
            <javadoc line="76">
                The focus traversal policy that will manage keyboard traversal of this
                  Container&apos;s children, if this Container is a focus cycle root. If the
                  value is null, this Container inherits its policy from its focus-cycle-
                  root ancestor. If all such ancestors of this Container have null
                  policies, then the current KeyboardFocusManager&apos;s default policy is
                  used. If the value is non-null, this policy will be inherited by all
                  focus-cycle-root children that have no keyboard-traversal policy of
                  their own (as will, recursively, their focus-cycle-root children).
                  &lt;p&gt;
                  If this Container is not a focus cycle root, the value will be
                  remembered, but will not be used or inherited by this or any other
                  Containers until this Container is made a focus cycle root.                
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="focusCycleRoot" type="boolean" line="94"/>
            <javadoc line="94">
                Indicates whether this Component is the root of a focus traversal cycle.
                  Once focus enters a traversal cycle, typically it cannot leave it via
                  focus traversal unless one of the up- or down-cycle keys is pressed.
                  Normal traversal is limited to this Container, and all of this
                  Container&apos;s descendants that are not descendants of inferior focus cycle
                  roots.                
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #isFocusCycleRoot                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="focusTraversalPolicyProvider" type="boolean" line="106"/>
            <javadoc line="106">
                Stores the value of focusTraversalPolicyProvider property.                
                <since>
                    1.5                    
                </since>
                <see>
                    #setFocusTraversalPolicyProvider                    
                </see>
            </javadoc>
            <declaration name="printingThreads" type="Set" line="112"/>
            <declaration name="printing" type="boolean" line="113"/>
            <declaration name="containerListener" type="ContainerListener" line="114"/>
            <declaration name="listeningChildren" type="int" line="115"/>
            <declaration name="listeningBoundsChildren" type="int" line="116"/>
            <declaration name="descendantsCount" type="int" line="117"/>
            <declaration name="preserveBackgroundColor" type="Color" line="118"/>
            <declaration name="serialVersionUID" type="long" line="119"/>
            <javadoc line="119">
                JDK 1.1 serialVersionUID                
            </javadoc>
            <declaration name="INCLUDE_SELF" type="boolean" line="123"/>
            <javadoc line="123">
                A constant which toggles one of the controllable behaviors
                  of &lt;code&gt;getMouseEventTarget&lt;/code&gt;. It is used to specify whether
                  the method can return the Container on which it is originally called
                  in case if none of its children are the current mouse event targets.                
                <see>
                    #getMouseEventTarget(int,int,boolean,boolean,boolean)                    
                </see>
            </javadoc>
            <declaration name="SEARCH_HEAVYWEIGHTS" type="boolean" line="131"/>
            <javadoc line="131">
                A constant which toggles one of the controllable behaviors
                  of &lt;code&gt;getMouseEventTarget&lt;/code&gt;. It is used to specify whether
                  the method should search only lightweight components.                
                <see>
                    #getMouseEventTarget(int,int,boolean,boolean,boolean)                    
                </see>
            </javadoc>
            <declaration name="numOfHWComponents" type="int" line="138"/>
            <declaration name="numOfLWComponents" type="int" line="139"/>
            <declaration name="mixingLog" type="PlatformLogger" line="140"/>
            <declaration name="serialPersistentFields" type="ObjectStreamField[]" line="141"/>
            <javadoc line="141">
                @serialField ncomponents                     int
                  The number of components in this container.
                  This value can be null.                
                <serialField>
                    component                       Component[]
                      The components in this container.                    
                </serialField>
                <serialField>
                    layoutMgr                       LayoutManager
                      Layout manager for this container.                    
                </serialField>
                <serialField>
                    dispatcher                      LightweightDispatcher
                      Event router for lightweight components.  If this container
                      is native, this dispatcher takes care of forwarding and
                      retargeting the events to lightweight components contained
                      (if any).                    
                </serialField>
                <serialField>
                    maxSize                         Dimension
                      Maximum size of this Container.                    
                </serialField>
                <serialField>
                    focusCycleRoot                  boolean
                      Indicates whether this Component is the root of a focus traversal cycle.
                      Once focus enters a traversal cycle, typically it cannot leave it via
                      focus traversal unless one of the up- or down-cycle keys is pressed.
                      Normal traversal is limited to this Container, and all of this
                      Container's descendants that are not descendants of inferior focus cycle
                      roots.                    
                </serialField>
                <serialField>
                    containerSerializedDataVersion  int
                      Container Serial Data Version.                    
                </serialField>
                <serialField>
                    focusTraversalPolicyProvider    boolean
                      Stores the value of focusTraversalPolicyProvider property.                    
                </serialField>
            </javadoc>
            <scope line="169">
                <scope line="171"/>
                <anonymous_class line="174">
                    <method name="validateUnconditionally" type="void" line="175">
                        <params>
                            <param name="cont" type="Container"/>
                        </params>
                    </method>
                </anonymous_class>
            </scope>
            <method name="initIDs" type="void" line="181"/>
            <javadoc line="181">
                Initialize JNI field and method IDs for fields that may be
                  called from C.                
            </javadoc>
            <javadoc line="186">
                Constructs a new Container. Containers can be extended directly,
                  but are lightweight in this case and must be contained by a parent
                  somewhere higher up in the component tree that is native.
                  (such as Frame for example).                
            </javadoc>
            <method name="Container" type="constructor" line="192"/>
            <method name="initializeFocusTraversalKeys" type="void" line="194"/>
            <javadoc line="197">
                Gets the number of components in this panel.
                  &lt;p&gt;
                  Note: This method should be called under AWT tree lock.                
                <return>
                    the number of components in this panel.                    
                </return>
                <see>
                    #getComponent                    
                </see>
                <since>
                    JDK1.1                    
                </since>
                <see>
                    Component#getTreeLock()                    
                </see>
            </javadoc>
            <method name="getComponentCount" type="int" line="206"/>
            <javadoc line="209">
                @deprecated As of JDK version 1.1,
                  replaced by getComponentCount().                
            </javadoc>
            <method name="countComponents" type="int" line="213"/>
            <javadoc line="216">
                Gets the nth component in this container.
                  &lt;p&gt;
                  Note: This method should be called under AWT tree lock.                
                <param>
                    n   the index of the component to get.                    
                </param>
                <return>
                    the n<sup>th</sup> component in this container.                    
                </return>
                <exception>
                    ArrayIndexOutOfBoundsExceptionif the n<sup>th</sup> value does not exist.                    
                </exception>
                <see>
                    Component#getTreeLock()                    
                </see>
            </javadoc>
            <method name="getComponent" type="Component" line="225">
                <params>
                    <param name="n" type="int"/>
                </params>
                <scope line="226"/>
                <scope line="229"/>
            </method>
            <javadoc line="233">
                Gets all the components in this container.
                  &lt;p&gt;
                  Note: This method should be called under AWT tree lock.                
                <return>
                    an array of all the components in this container.                    
                </return>
                <see>
                    Component#getTreeLock()                    
                </see>
            </javadoc>
            <method name="getComponents" type="Component[]" line="240"/>
            <method name="getComponents_NoClientCode" type="Component[]" line="243"/>
            <method name="getComponentsSync" type="Component[]" line="246">
                <scope line="247"/>
            </method>
            <javadoc line="251">
                Determines the insets of this container, which indicate the size
                  of the container&apos;s border.
                  &lt;p&gt;
                  A &lt;code&gt;Frame&lt;/code&gt; object, for example, has a top inset that
                  corresponds to the height of the frame&apos;s title bar.                
                <return>
                    the insets of this container.                    
                </return>
                <see>
                    Insets                    
                </see>
                <see>
                    LayoutManager                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getInsets" type="Insets" line="262"/>
            <javadoc line="265">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;getInsets()&lt;/code&gt;.                
            </javadoc>
            <method name="insets" type="Insets" line="269">
                <declaration name="peer" type="ComponentPeer" line="270"/>
                <scope line="271">
                    <declaration name="cpeer" type="ContainerPeer" line="272"/>
                </scope>
            </method>
            <javadoc line="277">
                Appends the specified component to the end of this container.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp   the component to be added                    
                </param>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <see>
                    #addImpl                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
                <return>
                    the component argument                    
                </return>
            </javadoc>
            <method name="add" type="Component" line="293">
                <params>
                    <param name="comp" type="Component"/>
                </params>
            </method>
            <javadoc line="297">
                Adds the specified component to this container.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method is obsolete as of 1.1.  Please use the
                  method &lt;code&gt;add(Component, Object)&lt;/code&gt; instead.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <see>
                    #add(Component,Object)                    
                </see>
                <see>
                    #invalidate                    
                </see>
            </javadoc>
            <method name="add" type="Component" line="312">
                <params>
                    <param name="name" type="String"/>
                    <param name="comp" type="Component"/>
                </params>
            </method>
            <javadoc line="316">
                Adds the specified component to this container at the given
                  position.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp   the component to be added                    
                </param>
                <param>
                    index    the position at which to insert the component,
                      or <code>-1</code> to append the component to the end                    
                </param>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <exception>
                    IllegalArgumentException if {@code index} is invalid (see{@link #addImpl} for details)                    
                </exception>
                <return>
                    the component <code>comp</code>                    
                </return>
                <see>
                    #addImpl                    
                </see>
                <see>
                    #remove                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
            </javadoc>
            <method name="add" type="Component" line="337">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="341">
                Checks that the component
                  isn&apos;t supposed to be added into itself.                
            </javadoc>
            <method name="checkAddToSelf" type="void" line="345">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="346">
                    <scope line="347">
                        <scope line="348"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="354">
                Checks that the component is not a Window instance.                
            </javadoc>
            <method name="checkNotAWindow" type="void" line="357">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="358"/>
            </method>
            <javadoc line="362">
                Checks that the component comp can be added to this container
                  Checks :  index in bounds of container&apos;s size,
                  comp is not one of this container&apos;s parents,
                  and comp is not a window.
                  Comp and container must be on the same GraphicsDevice.
                  if comp is container, all sub-components must be on
                  same GraphicsDevice.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="checkAdding" type="void" line="372">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="index" type="int"/>
                </params>
                <declaration name="thisGC" type="GraphicsConfiguration" line="374"/>
                <scope line="375"/>
                <scope line="378">
                    <scope line="379"/>
                </scope>
                <declaration name="thisTopLevel" type="Window" line="385"/>
                <declaration name="compTopLevel" type="Window" line="386"/>
                <scope line="387"/>
                <scope line="390"/>
            </method>
            <javadoc line="394">
                Removes component comp from this container without making unneccessary changes
                  and generating unneccessary events. This function intended to perform optimized
                  remove, for example, if newParent and current parent are the same it just changes
                  index without calling removeNotify.
                  Note: Should be called while holding treeLock
                  Returns whether removeNotify was invoked                
                <since>
                    : 1.5                    
                </since>
            </javadoc>
            <method name="removeDelicately" type="boolean" line="403">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="newParent" type="Container"/>
                    <param name="newIndex" type="int"/>
                </params>
                <declaration name="index" type="int" line="405"/>
                <declaration name="needRemoveNotify" type="boolean" line="406"/>
                <scope line="407"/>
                <scope line="410">
                    <scope line="411"/>
                    <scope line="418"/>
                </scope>
                <scope line="424"/>
                <scope line="428">
                    <scope line="429">
                        <declaration name="e" type="ContainerEvent" line="430"/>
                    </scope>
                    <scope line="434"/>
                </scope>
            </method>
            <javadoc line="440">
                Checks whether this container can contain component which is focus owner.
                  Verifies that container is enable and showing, and if it is focus cycle root
                  its FTP allows component to be focus owner                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="canContainFocusOwner" type="boolean" line="446">
                <params>
                    <param name="focusOwnerCandidate" type="Component"/>
                </params>
                <scope line="447"/>
                <scope line="450">
                    <declaration name="policy" type="FocusTraversalPolicy" line="451"/>
                    <scope line="452">
                        <scope line="453"/>
                    </scope>
                </scope>
                <scope line="458">
                    <scope line="459"/>
                </scope>
            </method>
            <javadoc line="465">
                Checks whether or not this container has heavyweight children.
                  Note: Should be called while holding tree lock                
                <return>
                    true if there is at least one heavyweight children in a container, false otherwise                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hasHeavyweightDescendants" type="boolean" line="471"/>
            <javadoc line="475">
                Checks whether or not this container has lightweight children.
                  Note: Should be called while holding tree lock                
                <return>
                    true if there is at least one lightweight children in a container, false otherwise                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="hasLightweightDescendants" type="boolean" line="481"/>
            <javadoc line="485">
                Returns closest heavyweight component to this container. If this container is heavyweight
                  returns this.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getHeavyweightContainer" type="Container" line="490">
                <scope line="492"/>
                <scope line="495"/>
            </method>
            <javadoc line="499">
                Detects whether or not remove from current parent and adding to new parent requires call of
                  removeNotify on the component. Since removeNotify destroys native window this might (not)
                  be required. For example, if new container and old containers are the same we don&apos;t need to
                  destroy native window.                
                <since>
                    : 1.5                    
                </since>
            </javadoc>
            <method name="isRemoveNotifyNeeded" type="boolean" line="506">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="oldContainer" type="Container"/>
                    <param name="newContainer" type="Container"/>
                </params>
                <scope line="507"/>
                <scope line="510"/>
                <scope line="513"/>
                <scope line="516">
                    <declaration name="isContainer" type="boolean" line="517"/>
                    <scope line="518"/>
                </scope>
                <declaration name="newNativeContainer" type="Container" line="522"/>
                <declaration name="oldNativeContainer" type="Container" line="523"/>
                <scope line="524"/>
                <scope line="527"/>
            </method>
            <javadoc line="531">
                Moves the specified component to the specified z-order index in
                  the container. The z-order determines the order that components
                  are painted; the component with the highest z-order paints first
                  and the component with the lowest z-order paints last.
                  Where components overlap, the component with the lower
                  z-order paints over the component with the higher z-order.
                  &lt;p&gt;
                  If the component is a child of some other container, it is
                  removed from that container before being added to this container.
                  The important difference between this method and
                  &lt;code&gt;java.awt.Container.add(Component, int)&lt;/code&gt; is that this method
                  doesn&apos;t call &lt;code&gt;removeNotify&lt;/code&gt; on the component while
                  removing it from its previous container unless necessary and when
                  allowed by the underlying native windowing system. This way, if the
                  component has the keyboard focus, it maintains the focus when
                  moved to the new position.
                  &lt;p&gt;
                  This property is guaranteed to apply only to lightweight
                  non-&lt;code&gt;Container&lt;/code&gt; components.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy.
                  &lt;p&gt;
                  &lt;b&gt;Note&lt;/b&gt;: Not all platforms support changing the z-order of
                  heavyweight components from one container into another without
                  the call to &lt;code&gt;removeNotify&lt;/code&gt;. There is no way to detect
                  whether a platform supports this, so developers shouldn&apos;t make
                  any assumptions.                
                <param>
                    comp the component to be moved                    
                </param>
                <param>
                    index the position in the container's list to
                      insert the component, where <code>getComponentCount()</code>
                      appends to the end                    
                </param>
                <exception>
                    NullPointerException if <code>comp</code> is
                      <code>null</code>                    
                </exception>
                <exception>
                    IllegalArgumentException if <code>comp</code> is one of the
                      container's parents                    
                </exception>
                <exception>
                    IllegalArgumentException if <code>index</code> is not in
                      the range <code>[0, getComponentCount()]</code> for moving
                      between containers, or not in the range
                      <code>[0, getComponentCount()-1]</code> for moving inside
                      a container                    
                </exception>
                <exception>
                    IllegalArgumentException if adding a container to itself                    
                </exception>
                <exception>
                    IllegalArgumentException if adding a <code>Window</code>
                      to a container                    
                </exception>
                <see>
                    #getComponentZOrder(java.awt.Component)                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setComponentZOrder" type="void" line="580">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="index" type="int"/>
                </params>
                <scope line="581">
                    <declaration name="curParent" type="Container" line="582"/>
                    <declaration name="oldZindex" type="int" line="583"/>
                    <scope line="584"/>
                    <declaration name="peerRecreated" type="boolean" line="588"/>
                    <scope line="590"/>
                </scope>
            </method>
            <javadoc line="595">
                Traverses the tree of components and reparents children heavyweight component
                  to new heavyweight parent.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="reparentTraverse" type="void" line="600">
                <params>
                    <param name="parentPeer" type="ContainerPeer"/>
                    <param name="child" type="Container"/>
                </params>
                <scope line="602">
                    <declaration name="comp" type="Component" line="603"/>
                    <scope line="604">
                        <scope line="605"/>
                    </scope>
                    <scope line="609"/>
                </scope>
            </method>
            <javadoc line="614">
                Reparents child component peer to this container peer.
                  Container must be heavyweight.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="reparentChild" type="void" line="619">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="621"/>
                <scope line="624">
                    <scope line="625"/>
                </scope>
                <scope line="629"/>
            </method>
            <javadoc line="633">
                Adds component to this container. Tries to minimize side effects of this adding -
                  doesn&apos;t call remove notify if it is not required.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="addDelicately" type="void" line="638">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="curParent" type="Container"/>
                    <param name="index" type="int"/>
                </params>
                <scope line="640">
                    <scope line="641"/>
                    <scope line="644"/>
                </scope>
                <scope line="653">
                    <scope line="654"/>
                </scope>
                <scope line="659">
                    <scope line="660"/>
                    <scope line="663">
                        <declaration name="newNativeContainer" type="Container" line="664"/>
                        <declaration name="oldNativeContainer" type="Container" line="665"/>
                        <scope line="666"/>
                        <scope line="670"/>
                    </scope>
                </scope>
                <scope line="675">
                    <scope line="676">
                        <scope line="677"/>
                        <scope line="680"/>
                    </scope>
                    <scope line="684">
                        <declaration name="e" type="ContainerEvent" line="685"/>
                    </scope>
                    <scope line="689"/>
                    <scope line="692">
                        <declaration name="focusOwner" type="Component" line="693"/>
                        <scope line="694"/>
                    </scope>
                </scope>
                <scope line="699"/>
                <scope line="702"/>
            </method>
            <javadoc line="706">
                Returns the z-order index of the component inside the container.
                  The higher a component is in the z-order hierarchy, the lower
                  its index.  The component with the lowest z-order index is
                  painted last, above all other child components.                
                <param>
                    comp the component being queried                    
                </param>
                <return>
                    the z-order index of the component; otherwise
                      returns -1 if the component is <code>null</code>
                      or doesn't belong to the container                    
                </return>
                <see>
                    #setComponentZOrder(java.awt.Component,int)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getComponentZOrder" type="int" line="718">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="719"/>
                <scope line="722">
                    <scope line="723"/>
                </scope>
            </method>
            <javadoc line="729">
                Adds the specified component to the end of this container.
                  Also notifies the layout manager to add the component to
                  this container&apos;s layout using the specified constraints object.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp the component to be added                    
                </param>
                <param>
                    constraints an object expressing
                      layout contraints for this component                    
                </param>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <see>
                    #addImpl                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
                <see>
                    LayoutManager                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="add" type="void" line="750">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="constraints" type="Object"/>
                </params>
            </method>
            <javadoc line="753">
                Adds the specified component to this container with the specified
                  constraints at the specified index.  Also notifies the layout
                  manager to add the component to the this container&apos;s layout using
                  the specified constraints object.
                  This is a convenience method for {@link #addImpl}.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp the component to be added                    
                </param>
                <param>
                    constraints an object expressing layout contraints for this                    
                </param>
                <param>
                    index the position in the container's list at which to insert
                      the component; <code>-1</code> means insert at the end
                      component                    
                </param>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <exception>
                    IllegalArgumentException if {@code index} is invalid (see{@link #addImpl} for details)                    
                </exception>
                <see>
                    #addImpl                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
                <see>
                    #remove                    
                </see>
                <see>
                    LayoutManager                    
                </see>
            </javadoc>
            <method name="add" type="void" line="778">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="constraints" type="Object"/>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="781">
                Adds the specified component to this container at the specified
                  index. This method also notifies the layout manager to add
                  the component to this container&apos;s layout using the specified
                  constraints object via the &lt;code&gt;addLayoutComponent&lt;/code&gt;
                  method.
                  &lt;p&gt;
                  The constraints are
                  defined by the particular layout manager being used.  For
                  example, the &lt;code&gt;BorderLayout&lt;/code&gt; class defines five
                  constraints: &lt;code&gt;BorderLayout.NORTH&lt;/code&gt;,
                  &lt;code&gt;BorderLayout.SOUTH&lt;/code&gt;, &lt;code&gt;BorderLayout.EAST&lt;/code&gt;,
                  &lt;code&gt;BorderLayout.WEST&lt;/code&gt;, and &lt;code&gt;BorderLayout.CENTER&lt;/code&gt;.
                  &lt;p&gt;
                  The &lt;code&gt;GridBagLayout&lt;/code&gt; class requires a
                  &lt;code&gt;GridBagConstraints&lt;/code&gt; object.  Failure to pass
                  the correct type of constraints object results in an
                  &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
                  &lt;p&gt;
                  If the current layout manager implements {@code LayoutManager2}, then{@link LayoutManager2#addLayoutComponent(Component,Object)} is invoked on
                  it. If the current layout manager does not implement{@code LayoutManager2}, and constraints is a {@code String}, then{@link LayoutManager#addLayoutComponent(String,Component)} is invoked on it.
                  &lt;p&gt;
                  If the component is not an ancestor of this container and has a non-null
                  parent, it is removed from its current parent before it is added to this
                  container.
                  &lt;p&gt;
                  This is the method to override if a program needs to track
                  every add request to a container as all other add methods defer
                  to this one. An overriding method should
                  usually include a call to the superclass&apos;s version of the method:
                  &lt;p&gt;
                  &lt;blockquote&gt;
                  &lt;code&gt;super.addImpl(comp, constraints, index)&lt;/code&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  display the added component.                
                <param>
                    comp       the component to be added                    
                </param>
                <param>
                    constraints an object expressing layout constraints
                      for this component                    
                </param>
                <param>
                    index the position in the container's list at which to
                      insert the component, where <code>-1</code>
                      means append to the end                    
                </param>
                <exception>
                    IllegalArgumentException if {@code index} is invalid;
                      if {@code comp} is a child of this container, the valid
                      range is {@code [-1, getComponentCount()-1]}; if component is
                      not a child of this container, the valid range is{@code [-1, getComponentCount()]}                    
                </exception>
                <exception>
                    IllegalArgumentException if {@code comp} is an ancestor of
                      this container                    
                </exception>
                <exception>
                    IllegalArgumentException if adding a window to a container                    
                </exception>
                <exception>
                    NullPointerException if {@code comp} is {@code null}                    
                </exception>
                <see>
                    #add(Component)                    
                </see>
                <see>
                    #add(Component,int)                    
                </see>
                <see>
                    #add(Component,java.lang.Object)                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    LayoutManager                    
                </see>
                <see>
                    LayoutManager2                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="addImpl" type="void" line="842">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="constraints" type="Object"/>
                    <param name="index" type="int"/>
                </params>
                <scope line="843">
                    <declaration name="thisGC" type="GraphicsConfiguration" line="844"/>
                    <scope line="845"/>
                    <scope line="850"/>
                    <scope line="853">
                        <scope line="855"/>
                    </scope>
                    <scope line="859"/>
                    <scope line="862"/>
                    <scope line="871"/>
                    <scope line="874">
                        <scope line="875"/>
                        <scope line="878"/>
                    </scope>
                    <scope line="882">
                        <declaration name="e" type="ContainerEvent" line="883"/>
                    </scope>
                    <scope line="887"/>
                </scope>
            </method>
            <method name="updateGraphicsData" type="boolean" line="892">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <declaration name="ret" type="boolean" line="894"/>
                <scope line="895">
                    <scope line="896"/>
                </scope>
            </method>
            <javadoc line="902">
                Checks that all Components that this Container contains are on
                  the same GraphicsDevice as this Container.  If not, throws an
                  IllegalArgumentException.                
            </javadoc>
            <method name="checkGD" type="void" line="907">
                <params>
                    <param name="stringID" type="String"/>
                </params>
                <scope line="908">
                    <scope line="909"/>
                </scope>
            </method>
            <javadoc line="914">
                Removes the component, specified by &lt;code&gt;index&lt;/code&gt;,
                  from this container.
                  This method also notifies the layout manager to remove the
                  component from this container&apos;s layout via the
                  &lt;code&gt;removeLayoutComponent&lt;/code&gt; method.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  reflect the changes.                
                <param>
                    index   the index of the component to be removed                    
                </param>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code index} is not in
                      range {@code [0, getComponentCount()-1]}                    
                </throws>
                <see>
                    #add                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    #getComponentCount                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="remove" type="void" line="934">
                <params>
                    <param name="index" type="int"/>
                </params>
                <scope line="935">
                    <scope line="936"/>
                    <declaration name="comp" type="Component" line="939"/>
                    <scope line="940"/>
                    <scope line="943"/>
                    <scope line="953">
                        <declaration name="e" type="ContainerEvent" line="954"/>
                    </scope>
                    <scope line="958"/>
                </scope>
            </method>
            <javadoc line="963">
                Removes the specified component from this container.
                  This method also notifies the layout manager to remove the
                  component from this container&apos;s layout via the
                  &lt;code&gt;removeLayoutComponent&lt;/code&gt; method.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  reflect the changes.                
                <param>
                    comp the component to be removed                    
                </param>
                <throws>
                    NullPointerException if {@code comp} is {@code null}                    
                </throws>
                <see>
                    #add                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    #validate                    
                </see>
                <see>
                    #remove(int)                    
                </see>
            </javadoc>
            <method name="remove" type="void" line="980">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="981">
                    <scope line="982">
                        <declaration name="index" type="int" line="983"/>
                        <scope line="984"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="990">
                Removes all the components from this container.
                  This method also notifies the layout manager to remove the
                  components from this container&apos;s layout via the
                  &lt;code&gt;removeLayoutComponent&lt;/code&gt; method.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy. If the container has already been
                  displayed, the hierarchy must be validated thereafter in order to
                  reflect the changes.                
                <see>
                    #add                    
                </see>
                <see>
                    #remove                    
                </see>
                <see>
                    #invalidate                    
                </see>
            </javadoc>
            <method name="removeAll" type="void" line="1004">
                <scope line="1005">
                    <scope line="1009">
                        <declaration name="comp" type="Component" line="1010"/>
                        <scope line="1011"/>
                        <scope line="1014"/>
                        <scope line="1019">
                            <declaration name="e" type="ContainerEvent" line="1020"/>
                        </scope>
                    </scope>
                    <scope line="1025"/>
                </scope>
            </method>
            <method name="numListening" type="int" line="1031">
                <params>
                    <param name="mask" type="long"/>
                </params>
                <declaration name="superListening" type="int" line="1032"/>
                <scope line="1033">
                    <scope line="1034">
                        <declaration name="sum" type="int" line="1035"/>
                        <scope line="1036"/>
                        <scope line="1039"/>
                    </scope>
                </scope>
                <scope line="1045">
                    <scope line="1046">
                        <declaration name="sum" type="int" line="1047"/>
                        <scope line="1048"/>
                        <scope line="1051"/>
                    </scope>
                </scope>
                <scope line="1057">
                    <scope line="1058"/>
                </scope>
            </method>
            <method name="adjustListeningChildren" type="void" line="1064">
                <params>
                    <param name="mask" type="long"/>
                    <param name="num" type="int"/>
                </params>
                <scope line="1065">
                    <declaration name="toAssert" type="boolean" line="1066"/>
                    <scope line="1067"/>
                </scope>
                <scope line="1072"/>
                <scope line="1075"/>
            </method>
            <method name="adjustDescendants" type="void" line="1080">
                <params>
                    <param name="num" type="int"/>
                </params>
            </method>
            <method name="adjustDecendantsOnParent" type="void" line="1085">
                <params>
                    <param name="num" type="int"/>
                </params>
                <scope line="1086"/>
            </method>
            <method name="countHierarchyMembers" type="int" line="1090">
                <scope line="1091">
                    <declaration name="sum" type="int" line="1092"/>
                    <scope line="1093"/>
                    <scope line="1096"/>
                </scope>
            </method>
            <method name="getListenersCount" type="int" line="1102">
                <params>
                    <param name="id" type="int"/>
                    <param name="enabledOnToolkit" type="boolean"/>
                </params>
                <scope line="1104"/>
            </method>
            <method name="createHierarchyEvents" type="int" line="1117">
                <params>
                    <param name="id" type="int"/>
                    <param name="changed" type="Component"/>
                    <param name="changedParent" type="Container"/>
                    <param name="changeFlags" type="long"/>
                    <param name="enabledOnToolkit" type="boolean"/>
                </params>
                <declaration name="listeners" type="int" line="1119"/>
                <scope line="1120"/>
            </method>
            <method name="createChildHierarchyEvents" type="void" line="1125">
                <params>
                    <param name="id" type="int"/>
                    <param name="changeFlags" type="long"/>
                    <param name="enabledOnToolkit" type="boolean"/>
                </params>
                <scope line="1127"/>
                <declaration name="listeners" type="int" line="1130"/>
                <scope line="1131"/>
            </method>
            <javadoc line="1135">
                Gets the layout manager for this container.                
                <see>
                    #doLayout                    
                </see>
                <see>
                    #setLayout                    
                </see>
            </javadoc>
            <method name="getLayout" type="LayoutManager" line="1140"/>
            <javadoc line="1143">
                Sets the layout manager for this container.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy.                
                <param>
                    mgr the specified layout manager                    
                </param>
                <see>
                    #doLayout                    
                </see>
                <see>
                    #getLayout                    
                </see>
                <see>
                    #invalidate                    
                </see>
            </javadoc>
            <method name="setLayout" type="void" line="1153">
                <params>
                    <param name="mgr" type="LayoutManager"/>
                </params>
            </method>
            <javadoc line="1157">
                Causes this container to lay out its components.  Most programs
                  should not call this method directly, but should invoke
                  the &lt;code&gt;validate&lt;/code&gt; method instead.                
                <see>
                    LayoutManager#layoutContainer                    
                </see>
                <see>
                    #setLayout                    
                </see>
                <see>
                    #validate                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="doLayout" type="void" line="1166"/>
            <javadoc line="1169">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;doLayout()&lt;/code&gt;.                
            </javadoc>
            <method name="layout" type="void" line="1173">
                <declaration name="layoutMgr" type="LayoutManager" line="1174"/>
                <scope line="1175"/>
            </method>
            <javadoc line="1179">
                Indicates if this container is a &lt;i&gt;validate root&lt;/i&gt;.
                  &lt;p&gt;
                  Layout-related changes, such as bounds of the validate root descendants,
                  do not affect the layout of the validate root parent. This peculiarity
                  enables the {@code invalidate()} method to stop invalidating the
                  component hierarchy when the method encounters a validate root. However,
                  to preserve backward compatibility this new optimized behavior is
                  enabled only when the {@code java.awt.smartInvalidate} system property
                  value is set to {@code true}.
                  &lt;p&gt;
                  If a component hierarchy contains validate roots and the new optimized{@code invalidate()} behavior is enabled, the {@code validate()} method
                  must be invoked on the validate root of a previously invalidated
                  component to restore the validity of the hierarchy later. Otherwise,
                  calling the {@code validate()} method on the top-level container (such
                  as a {@code Frame} object) should be used to restore the validity of the
                  component hierarchy.
                  &lt;p&gt;
                  The {@code Window} class and the {@code Applet} class are the validate
                  roots in AWT.  Swing introduces more validate roots.                
                <return>
                    whether this container is a validate root                    
                </return>
                <see>
                    #invalidate                    
                </see>
                <see>
                    java.awt.Component#invalidate                    
                </see>
                <see>
                    javax.swing.JComponent#isValidateRoot                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="isValidateRoot" type="boolean" line="1206"/>
            <declaration name="isJavaAwtSmartInvalidate" type="boolean" line="1209"/>
            <scope line="1210"/>
            <javadoc line="1213">
                Invalidates the parent of the container unless the container
                  is a validate root.                
            </javadoc>
            <method name="invalidateParent" type="void" line="1217">
                <scope line="1218"/>
            </method>
            <javadoc line="1222">
                Invalidates the container.
                  &lt;p&gt;
                  If the {@code LayoutManager} installed on this container is an instance
                  of the {@code LayoutManager2} interface, then
                  the {@link LayoutManager2#invalidateLayout(Container)} method is invoked
                  on it supplying this {@code Container} as the argument.
                  &lt;p&gt;
                  Afterwards this method marks this container invalid, and invalidates its
                  ancestors. See the {@link Component#invalidate} method for more details.                
                <see>
                    #validate                    
                </see>
                <see>
                    #layout                    
                </see>
                <see>
                    LayoutManager2                    
                </see>
            </javadoc>
            <method name="invalidate" type="void" line="1236">
                <declaration name="layoutMgr" type="LayoutManager" line="1237"/>
                <scope line="1238">
                    <declaration name="lm" type="LayoutManager2" line="1239"/>
                </scope>
            </method>
            <javadoc line="1244">
                Validates this container and all of its subcomponents.
                  &lt;p&gt;
                  Validating a container means laying out its subcomponents.
                  Layout-related changes, such as setting the bounds of a component, or
                  adding a component to the container, invalidate the container
                  automatically.  Note that the ancestors of the container may be
                  invalidated also (see {@link Component#invalidate} for details.)
                  Therefore, to restore the validity of the hierarchy, the 
                   method should be invoked on the top-most invalid
                  container of the hierarchy.
                  &lt;p&gt;
                  Validating the container may be a quite time-consuming operation. For
                  performance reasons a developer may postpone the validation of the
                  hierarchy till a set of layout-related operations completes, e.g. after
                  adding all the children to the container.
                  &lt;p&gt;
                  If this {@code Container} is not valid, this method invokes
                  the {@code validateTree} method and marks this {@code Container}as valid. Otherwise, no action is performed.                
                <see>
                    #add(java.awt.Component)                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <see>
                    Container#isValidateRoot                    
                </see>
                <see>
                    javax.swing.JComponent#revalidate()                    
                </see>
                <see>
                    #validateTree                    
                </see>
            </javadoc>
            <method name="validate" type="void" line="1268">
                <declaration name="updateCur" type="boolean" line="1269"/>
                <scope line="1270">
                    <scope line="1271">
                        <declaration name="p" type="ContainerPeer" line="1272"/>
                        <scope line="1273"/>
                        <scope line="1276"/>
                        <scope line="1280">
                            <scope line="1282"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1288"/>
            </method>
            <declaration name="descendUnconditionallyWhenValidating" type="boolean" line="1292"/>
            <javadoc line="1292">
                Indicates whether valid containers should also traverse their
                  children and call the validateTree() method on them.
                  Synchronization: TreeLock.
                  The field is allowed to be static as long as the TreeLock itself is
                  static.                
                <see>
                    #validateUnconditionally()                    
                </see>
            </javadoc>
            <javadoc line="1301">
                Unconditionally validate the component hierarchy.                
            </javadoc>
            <method name="validateUnconditionally" type="void" line="1304">
                <declaration name="updateCur" type="boolean" line="1305"/>
                <scope line="1306">
                    <scope line="1309"/>
                </scope>
                <scope line="1314"/>
            </method>
            <javadoc line="1318">
                Recursively descends the container tree and recomputes the
                  layout for any subtrees marked as needing it (those marked as
                  invalid).  Synchronization should be provided by the method
                  that calls this one:  &lt;code&gt;validate&lt;/code&gt;.                
                <see>
                    #doLayout                    
                </see>
                <see>
                    #validate                    
                </see>
            </javadoc>
            <method name="validateTree" type="void" line="1326">
                <scope line="1328">
                    <scope line="1329"/>
                    <scope line="1332"/>
                    <scope line="1335">
                        <declaration name="comp" type="Component" line="1336"/>
                        <scope line="1337"/>
                        <scope line="1340"/>
                    </scope>
                    <scope line="1344"/>
                </scope>
            </method>
            <javadoc line="1350">
                Recursively descends the container tree and invalidates all
                  contained components.                
            </javadoc>
            <method name="invalidateTree" type="void" line="1354">
                <scope line="1355">
                    <scope line="1356">
                        <declaration name="comp" type="Component" line="1357"/>
                        <scope line="1358"/>
                        <scope line="1361"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1368">
                Sets the font of this container.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy.                
                <param>
                    f The font to become this container's font.                    
                </param>
                <see>
                    Component#getFont                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="setFont" type="void" line="1378">
                <params>
                    <param name="f" type="Font"/>
                </params>
                <declaration name="shouldinvalidate" type="boolean" line="1379"/>
                <declaration name="oldfont" type="Font" line="1380"/>
                <declaration name="newfont" type="Font" line="1382"/>
                <scope line="1383"/>
            </method>
            <javadoc line="1387">
                Returns the preferred size of this container.  If the preferred size has
                  not been set explicitly by {@link Component#setPreferredSize(Dimension)}and this {@code Container} has a {@code non-null} {@link LayoutManager},
                  then {@link LayoutManager#preferredLayoutSize(Container)}is used to calculate the preferred size.
                  &lt;p&gt;Note: some implementations may cache the value returned from the{@code LayoutManager}.  Implementations that cache need not invoke{@code preferredLayoutSize} on the {@code LayoutManager} every time
                  this method is invoked, rather the {@code LayoutManager} will only
                  be queried after the {@code Container} becomes invalid.                
                <return>
                    an instance of <code>Dimension</code> that represents
                      the preferred size of this container.                    
                </return>
                <see>
                    #getMinimumSize                    
                </see>
                <see>
                    #getMaximumSize                    
                </see>
                <see>
                    #getLayout                    
                </see>
                <see>
                    LayoutManager#preferredLayoutSize(Container)                    
                </see>
                <see>
                    Component#getPreferredSize                    
                </see>
            </javadoc>
            <method name="getPreferredSize" type="Dimension" line="1402"/>
            <javadoc line="1405">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;getPreferredSize()&lt;/code&gt;.                
            </javadoc>
            <method name="preferredSize" type="Dimension" line="1409">
                <declaration name="dim" type="Dimension" line="1410"/>
                <scope line="1411">
                    <scope line="1412"/>
                </scope>
                <scope line="1417"/>
                <scope line="1420"/>
            </method>
            <javadoc line="1424">
                Returns the minimum size of this container.  If the minimum size has
                  not been set explicitly by {@link Component#setMinimumSize(Dimension)}and this {@code Container} has a {@code non-null} {@link LayoutManager},
                  then {@link LayoutManager#minimumLayoutSize(Container)}is used to calculate the minimum size.
                  &lt;p&gt;Note: some implementations may cache the value returned from the{@code LayoutManager}.  Implementations that cache need not invoke{@code minimumLayoutSize} on the {@code LayoutManager} every time
                  this method is invoked, rather the {@code LayoutManager} will only
                  be queried after the {@code Container} becomes invalid.                
                <return>
                    an instance of <code>Dimension</code> that represents
                      the minimum size of this container.                    
                </return>
                <see>
                    #getPreferredSize                    
                </see>
                <see>
                    #getMaximumSize                    
                </see>
                <see>
                    #getLayout                    
                </see>
                <see>
                    LayoutManager#minimumLayoutSize(Container)                    
                </see>
                <see>
                    Component#getMinimumSize                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getMinimumSize" type="Dimension" line="1440"/>
            <javadoc line="1443">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;getMinimumSize()&lt;/code&gt;.                
            </javadoc>
            <method name="minimumSize" type="Dimension" line="1447">
                <declaration name="dim" type="Dimension" line="1448"/>
                <scope line="1449">
                    <scope line="1450"/>
                </scope>
                <scope line="1455"/>
                <scope line="1458"/>
            </method>
            <javadoc line="1462">
                Returns the maximum size of this container.  If the maximum size has
                  not been set explicitly by {@link Component#setMaximumSize(Dimension)}and the {@link LayoutManager} installed on this {@code Container}is an instance of {@link LayoutManager2}, then{@link LayoutManager2#maximumLayoutSize(Container)}is used to calculate the maximum size.
                  &lt;p&gt;Note: some implementations may cache the value returned from the{@code LayoutManager2}.  Implementations that cache need not invoke{@code maximumLayoutSize} on the {@code LayoutManager2} every time
                  this method is invoked, rather the {@code LayoutManager2} will only
                  be queried after the {@code Container} becomes invalid.                
                <return>
                    an instance of <code>Dimension</code> that represents
                      the maximum size of this container.                    
                </return>
                <see>
                    #getPreferredSize                    
                </see>
                <see>
                    #getMinimumSize                    
                </see>
                <see>
                    #getLayout                    
                </see>
                <see>
                    LayoutManager2#maximumLayoutSize(Container)                    
                </see>
                <see>
                    Component#getMaximumSize                    
                </see>
            </javadoc>
            <method name="getMaximumSize" type="Dimension" line="1476">
                <declaration name="dim" type="Dimension" line="1477"/>
                <scope line="1478">
                    <scope line="1479">
                        <scope line="1480">
                            <declaration name="lm" type="LayoutManager2" line="1481"/>
                        </scope>
                        <scope line="1484"/>
                    </scope>
                </scope>
                <scope line="1490"/>
                <scope line="1493"/>
            </method>
            <javadoc line="1497">
                Returns the alignment along the x axis.  This specifies how
                  the component would like to be aligned relative to other
                  components.  The value should be a number between 0 and 1
                  where 0 represents alignment along the origin, 1 is aligned
                  the furthest away from the origin, 0.5 is centered, etc.                
            </javadoc>
            <method name="getAlignmentX" type="float" line="1504">
                <declaration name="xAlign" type="float" line="1505"/>
                <scope line="1506">
                    <scope line="1507">
                        <declaration name="lm" type="LayoutManager2" line="1508"/>
                    </scope>
                </scope>
                <scope line="1512"/>
            </method>
            <javadoc line="1517">
                Returns the alignment along the y axis.  This specifies how
                  the component would like to be aligned relative to other
                  components.  The value should be a number between 0 and 1
                  where 0 represents alignment along the origin, 1 is aligned
                  the furthest away from the origin, 0.5 is centered, etc.                
            </javadoc>
            <method name="getAlignmentY" type="float" line="1524">
                <declaration name="yAlign" type="float" line="1525"/>
                <scope line="1526">
                    <scope line="1527">
                        <declaration name="lm" type="LayoutManager2" line="1528"/>
                    </scope>
                </scope>
                <scope line="1532"/>
            </method>
            <javadoc line="1537">
                Paints the container. This forwards the paint to any lightweight
                  components that are children of this container. If this method is
                  reimplemented, super.paint(g) should be called so that lightweight
                  components are properly rendered. If a child component is entirely
                  clipped by the current clipping setting in g, paint() will not be
                  forwarded to that child.                
                <param>
                    g the specified Graphics window                    
                </param>
                <see>
                    Component#update(Graphics)                    
                </see>
            </javadoc>
            <method name="paint" type="void" line="1547">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1548">
                    <scope line="1549">
                        <scope line="1550">
                            <scope line="1551"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1559">
                Updates the container.  This forwards the update to any lightweight
                  components that are children of this container.  If this method is
                  reimplemented, super.update(g) should be called so that lightweight
                  components are properly rendered.  If a child component is entirely
                  clipped by the current clipping setting in g, update() will not be
                  forwarded to that child.                
                <param>
                    g the specified Graphics window                    
                </param>
                <see>
                    Component#update(Graphics)                    
                </see>
            </javadoc>
            <method name="update" type="void" line="1569">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1570">
                    <scope line="1571"/>
                </scope>
            </method>
            <javadoc line="1577">
                Prints the container. This forwards the print to any lightweight
                  components that are children of this container. If this method is
                  reimplemented, super.print(g) should be called so that lightweight
                  components are properly rendered. If a child component is entirely
                  clipped by the current clipping setting in g, print() will not be
                  forwarded to that child.                
                <param>
                    g the specified Graphics window                    
                </param>
                <see>
                    Component#update(Graphics)                    
                </see>
            </javadoc>
            <method name="print" type="void" line="1587">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1588">
                    <declaration name="t" type="Thread" line="1589"/>
                    <scope line="1590">
                        <scope line="1591">
                            <scope line="1592"/>
                        </scope>
                    </scope>
                    <scope line="1600">
                        <scope line="1601"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1609">
                Paints each of the components in this container.                
                <param>
                    g   the graphics context.                    
                </param>
                <see>
                    Component#paint                    
                </see>
                <see>
                    Component#paintAll                    
                </see>
            </javadoc>
            <method name="paintComponents" type="void" line="1615">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1616"/>
            </method>
            <javadoc line="1620">
                Simulates the peer callbacks into java.awt for printing of
                  lightweight Containers.                
                <param>
                    g   the graphics context to use for printing.                    
                </param>
                <see>
                    Component#printAll                    
                </see>
                <see>
                    #printComponents                    
                </see>
            </javadoc>
            <method name="lightweightPaint" type="void" line="1627">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <javadoc line="1631">
                Prints all the heavyweight subcomponents.                
            </javadoc>
            <method name="paintHeavyweightComponents" type="void" line="1634">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1635"/>
            </method>
            <javadoc line="1639">
                Prints each of the components in this container.                
                <param>
                    g   the graphics context.                    
                </param>
                <see>
                    Component#print                    
                </see>
                <see>
                    Component#printAll                    
                </see>
            </javadoc>
            <method name="printComponents" type="void" line="1645">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1646"/>
            </method>
            <javadoc line="1650">
                Simulates the peer callbacks into java.awt for printing of
                  lightweight Containers.                
                <param>
                    g   the graphics context to use for printing.                    
                </param>
                <see>
                    Component#printAll                    
                </see>
                <see>
                    #printComponents                    
                </see>
            </javadoc>
            <method name="lightweightPrint" type="void" line="1657">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <javadoc line="1661">
                Prints all the heavyweight subcomponents.                
            </javadoc>
            <method name="printHeavyweightComponents" type="void" line="1664">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <scope line="1665"/>
            </method>
            <javadoc line="1669">
                Adds the specified container listener to receive container events
                  from this container.
                  If l is null, no exception is thrown and no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the container listener                    
                </param>
                <see>
                    #removeContainerListener                    
                </see>
                <see>
                    #getContainerListeners                    
                </see>
            </javadoc>
            <method name="addContainerListener" type="void" line="1679">
                <params>
                    <param name="l" type="ContainerListener"/>
                </params>
                <scope line="1680"/>
            </method>
            <javadoc line="1686">
                Removes the specified container listener so it no longer receives
                  container events from this container.
                  If l is null, no exception is thrown and no action is performed.
                  &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
                  &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&apos;s threading model.                
                <param>
                    l the container listener                    
                </param>
                <see>
                    #addContainerListener                    
                </see>
                <see>
                    #getContainerListeners                    
                </see>
            </javadoc>
            <method name="removeContainerListener" type="void" line="1696">
                <params>
                    <param name="l" type="ContainerListener"/>
                </params>
                <scope line="1697"/>
            </method>
            <javadoc line="1702">
                Returns an array of all the container listeners
                  registered on this container.                
                <return>
                    all of this container's <code>ContainerListener</code>s
                      or an empty array if no container
                      listeners are currently registered                    
                </return>
                <see>
                    #addContainerListener                    
                </see>
                <see>
                    #removeContainerListener                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getContainerListeners" type="ContainerListener[]" line="1712"/>
            <javadoc line="1715">
                Returns an array of all the objects currently registered
                  as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
                  upon this &lt;code&gt;Container&lt;/code&gt;.
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
                  &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
                  &lt;p&gt;
                  You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
                  with a class literal, such as
                  &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
                  For example, you can query a
                  &lt;code&gt;Container&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;
                  for its container listeners with the following code:
                  &lt;pre&gt;ContainerListener[] cls = (ContainerListener[])(c.getListeners(ContainerListener.class));&lt;/pre&gt;
                  If no such listeners exist, this method returns an empty array.                
                <param>
                    listenerType the type of listeners requested; this parameter
                      should specify an interface that descends from
                      <code>java.util.EventListener</code>                    
                </param>
                <return>
                    an array of all objects registered as
                      <code><em>Foo</em>Listener</code>s on this container,
                      or an empty array if no such listeners have been added                    
                </return>
                <exception>
                    ClassCastException if <code>listenerType</code>
                      doesn't specify a class or interface that implements
                      <code>java.util.EventListener</code>                    
                </exception>
                <exception>
                    NullPointerException if {@code listenerType} is {@code null}                    
                </exception>
                <see>
                    #getContainerListeners                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="getListeners" type="T[]" line="1743">
                <params>
                    <param name="listenerType" type="Class<T>"/>
                </params>
                <declaration name="l" type="EventListener" line="1744"/>
                <scope line="1745"/>
                <scope line="1748"/>
            </method>
            <method name="eventEnabled" type="boolean" line="1753">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <declaration name="id" type="int" line="1754"/>
                <scope line="1755">
                    <scope line="1756"/>
                </scope>
            </method>
            <javadoc line="1763">
                Processes events on this container. If the event is a
                  &lt;code&gt;ContainerEvent&lt;/code&gt;, it invokes the
                  &lt;code&gt;processContainerEvent&lt;/code&gt; method, else it invokes
                  its superclass&apos;s &lt;code&gt;processEvent&lt;/code&gt;.
                  &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
                  the behavior is unspecified and may result in an
                  exception.                
                <param>
                    e the event                    
                </param>
            </javadoc>
            <method name="processEvent" type="void" line="1773">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <scope line="1774"/>
            </method>
            <javadoc line="1780">
                Processes container events occurring on this container by
                  dispatching them to any registered ContainerListener objects.
                  NOTE: This method will not be called unless container events
                  are enabled for this component; this happens when one of the
                  following occurs:
                  &lt;ul&gt;
                  &lt;li&gt;A ContainerListener object is registered via
                  &lt;code&gt;addContainerListener&lt;/code&gt;
                  &lt;li&gt;Container events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;Note that if the event parameter is &lt;code&gt;null&lt;/code&gt;
                  the behavior is unspecified and may result in an
                  exception.                
                <param>
                    e the container event                    
                </param>
                <see>
                    Component#enableEvents                    
                </see>
            </javadoc>
            <method name="processContainerEvent" type="void" line="1797">
                <params>
                    <param name="e" type="ContainerEvent"/>
                </params>
                <declaration name="listener" type="ContainerListener" line="1798"/>
                <scope line="1799"/>
            </method>
            <method name="dispatchEventImpl" type="void" line="1810">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <scope line="1811">
                    <scope line="1813"/>
                </scope>
                <scope line="1819"/>
            </method>
            <method name="dispatchEventToSelf" type="void" line="1832">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
            </method>
            <javadoc line="1835">
                Fetchs the top-most (deepest) lightweight component that is interested
                  in receiving mouse events.                
            </javadoc>
            <method name="getMouseEventTarget" type="Component" line="1839">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="includeSelf" type="boolean"/>
                </params>
            </method>
            <javadoc line="1842">
                Fetches the top-most (deepest) component to receive SunDropTargetEvents.                
            </javadoc>
            <method name="getDropTargetEventTarget" type="Component" line="1845">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="includeSelf" type="boolean"/>
                </params>
            </method>
            <javadoc line="1848">
                A private version of getMouseEventTarget which has two additional
                  controllable behaviors. This method searches for the top-most
                  descendant of this container that contains the given coordinates
                  and is accepted by the given filter. The search will be constrained to
                  lightweight descendants if the last argument is &lt;code&gt;false&lt;/code&gt;.                
                <param>
                    filter EventTargetFilter instance to determine whether the
                      given component is a valid target for this event.                    
                </param>
                <param>
                    searchHeavyweights if <code>false</code>, the method
                      will bypass heavyweight components during the search.                    
                </param>
            </javadoc>
            <method name="getMouseEventTarget" type="Component" line="1859">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="includeSelf" type="boolean"/>
                    <param name="filter" type="EventTargetFilter"/>
                    <param name="searchHeavyweights" type="boolean"/>
                </params>
                <declaration name="comp" type="Component" line="1860"/>
                <scope line="1861"/>
                <scope line="1864"/>
            </method>
            <javadoc line="1869">
                A private version of getMouseEventTarget which has three additional
                  controllable behaviors. This method searches for the top-most
                  descendant of this container that contains the given coordinates
                  and is accepted by the given filter. The search will be constrained to
                  descendants of only lightweight children or only heavyweight children
                  of this container depending on searchHeavyweightChildren. The search will
                  be constrained to only lightweight descendants of the searched children
                  of this container if searchHeavyweightDescendants is &lt;code&gt;false&lt;/code&gt;.                
                <param>
                    filter EventTargetFilter instance to determine whether the
                      selected component is a valid target for this event.                    
                </param>
                <param>
                    searchHeavyweightChildren if <code>true</code>, the method
                      will bypass immediate lightweight children during the search.
                      If <code>false</code>, the methods will bypass immediate
                      heavyweight children during the search.                    
                </param>
                <param>
                    searchHeavyweightDescendants if <code>false</code>, the method
                      will bypass heavyweight descendants which are not immediate
                      children during the search. If <code>true</code>, the method
                      will traverse both lightweight and heavyweight descendants during
                      the search.                    
                </param>
            </javadoc>
            <method name="getMouseEventTargetImpl" type="Component" line="1890">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="includeSelf" type="boolean"/>
                    <param name="filter" type="EventTargetFilter"/>
                    <param name="searchHeavyweightChildren" type="boolean"/>
                    <param name="searchHeavyweightDescendants" type="boolean"/>
                </params>
                <scope line="1891">
                    <scope line="1892">
                        <declaration name="comp" type="Component" line="1893"/>
                        <scope line="1894">
                            <scope line="1895">
                                <declaration name="child" type="Container" line="1896"/>
                                <declaration name="deeper" type="Component" line="1897"/>
                                <scope line="1898"/>
                            </scope>
                            <scope line="1902">
                                <scope line="1903"/>
                            </scope>
                        </scope>
                    </scope>
                    <declaration name="isPeerOK" type="boolean" line="1909"/>
                    <declaration name="isMouseOverMe" type="boolean" line="1910"/>
                    <scope line="1913"/>
                </scope>
            </method>
            <interface name="EventTargetFilter">
                <method name="accept" type="boolean" line="1920"/>
            </interface>
            <class name="MouseEventTargetFilter" line="1922">
                <implements interface="EventTargetFilter"/>
                <declaration name="FILTER" type="EventTargetFilter" line="1923"/>
                <method name="MouseEventTargetFilter" type="constructor" line="1924"/>
                <method name="accept" type="boolean" line="1926">
                    <params>
                        <param name="comp" type="Component"/>
                    </params>
                </method>
            </class>
            <class name="DropTargetEventTargetFilter" line="1930">
                <implements interface="EventTargetFilter"/>
                <declaration name="FILTER" type="EventTargetFilter" line="1931"/>
                <method name="DropTargetEventTargetFilter" type="constructor" line="1932"/>
                <method name="accept" type="boolean" line="1934">
                    <params>
                        <param name="comp" type="Component"/>
                    </params>
                    <declaration name="dt" type="DropTarget" line="1935"/>
                </method>
            </class>
            <javadoc line="1939">
                This is called by lightweight components that want the containing
                  windowed parent to enable some kind of events on their behalf.
                  This is needed for events that are normally only dispatched to
                  windows to be accepted so that they can be forwarded downward to
                  the lightweight component that has enabled them.                
            </javadoc>
            <method name="proxyEnableEvents" type="void" line="1946">
                <params>
                    <param name="events" type="long"/>
                </params>
                <scope line="1947">
                    <scope line="1948"/>
                </scope>
                <scope line="1952">
                    <scope line="1953"/>
                </scope>
            </method>
            <javadoc line="1958">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;dispatchEvent(AWTEvent e)&lt;/code&gt;                
            </javadoc>
            <method name="deliverEvent" type="void" line="1962">
                <params>
                    <param name="e" type="Event"/>
                </params>
                <declaration name="comp" type="Component" line="1963"/>
                <scope line="1964"/>
                <scope line="1968"/>
            </method>
            <javadoc line="1972">
                Locates the component that contains the x,y position.  The
                  top-most child component is returned in the case where there
                  is overlap in the components.  This is determined by finding
                  the component closest to the index 0 that claims to contain
                  the given point via Component.contains(), except that Components
                  which have native peers take precedence over those which do not
                  (i.e., lightweight Components).                
                <param>
                    x the <i>x</i> coordinate                    
                </param>
                <param>
                    y the <i>y</i> coordinate                    
                </param>
                <return>
                    null if the component does not contain the position.
                      If there is no child component at the requested point and the
                      point is within the bounds of the container the container itself
                      is returned; otherwise the top-most child is returned.                    
                </return>
                <see>
                    Component#contains                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getComponentAt" type="Component" line="1989">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <javadoc line="1992">
                @deprecated As of JDK version 1.1,
                  replaced by &lt;code&gt;getComponentAt(int, int)&lt;/code&gt;.                
            </javadoc>
            <method name="locate" type="Component" line="1996">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <scope line="1997"/>
                <scope line="2000">
                    <scope line="2001">
                        <declaration name="comp" type="Component" line="2002"/>
                        <scope line="2003">
                            <scope line="2004"/>
                        </scope>
                    </scope>
                    <scope line="2009">
                        <declaration name="comp" type="Component" line="2010"/>
                        <scope line="2011">
                            <scope line="2012"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="2020">
                Gets the component that contains the specified point.                
                <param>
                    p   the point.                    
                </param>
                <return>
                    returns the component that contains the point,
                      or <code>null</code> if the component does
                      not contain the point.                    
                </return>
                <see>
                    Component#contains                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getComponentAt" type="Component" line="2029">
                <params>
                    <param name="p" type="Point"/>
                </params>
            </method>
            <javadoc line="2032">
                Returns the position of the mouse pointer in this &lt;code&gt;Container&lt;/code&gt;&apos;s
                  coordinate space if the &lt;code&gt;Container&lt;/code&gt; is under the mouse pointer,
                  otherwise returns &lt;code&gt;null&lt;/code&gt;.
                  This method is similar to {@link Component#getMousePosition()} with the exception
                  that it can take the &lt;code&gt;Container&lt;/code&gt;&apos;s children into account.
                  If &lt;code&gt;allowChildren&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this method will return
                  a non-null value only if the mouse pointer is above the &lt;code&gt;Container&lt;/code&gt;
                  directly, not above the part obscured by children.
                  If &lt;code&gt;allowChildren&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this method returns
                  a non-null value if the mouse pointer is above &lt;code&gt;Container&lt;/code&gt; or any
                  of its descendants.                
                <exception>
                    HeadlessException if GraphicsEnvironment.isHeadless() returns true                    
                </exception>
                <param>
                    allowChildren true if children should be taken into account                    
                </param>
                <see>
                    Component#getMousePosition                    
                </see>
                <return>
                    mouse coordinates relative to this <code>Component</code>, or null                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getMousePosition" type="Point" line="2050">
                <params>
                    <param name="allowChildren" type="boolean"/>
                </params>
                <scope line="2051"/>
                <anonymous_class line="2054">
                    <method name="run" type="Object" line="2055"/>
                </anonymous_class>
                <declaration name="pi" type="PointerInfo" line="2054"/>
                <scope line="2060">
                    <declaration name="inTheSameWindow" type="Component" line="2061"/>
                    <scope line="2062"/>
                </scope>
            </method>
            <method name="isSameOrAncestorOf" type="boolean" line="2068">
                <params>
                    <param name="comp" type="Component"/>
                    <param name="allowChildren" type="boolean"/>
                </params>
            </method>
            <javadoc line="2071">
                Locates the visible child component that contains the specified
                  position.  The top-most child component is returned in the case
                  where there is overlap in the components.  If the containing child
                  component is a Container, this method will continue searching for
                  the deepest nested child component.  Components which are not
                  visible are ignored during the search.&lt;p&gt;
                  The findComponentAt method is different from getComponentAt in
                  that getComponentAt only searches the Container&apos;s immediate
                  children; if the containing component is a Container,
                  findComponentAt will search that child to find a nested component.                
                <param>
                    x the <i>x</i> coordinate                    
                </param>
                <param>
                    y the <i>y</i> coordinate                    
                </param>
                <return>
                    null if the component does not contain the position.
                      If there is no child component at the requested point and the
                      point is within the bounds of the container the container itself
                      is returned.                    
                </return>
                <see>
                    Component#contains                    
                </see>
                <see>
                    #getComponentAt                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="findComponentAt" type="Component" line="2092">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
            </method>
            <javadoc line="2095">
                Private version of findComponentAt which has a controllable
                  behavior. Setting &apos;ignoreEnabled&apos; to &apos;false&apos; bypasses disabled
                  Components during the search. This behavior is used by the
                  lightweight cursor support in sun.awt.GlobalCursorManager.
                  The cursor code calls this function directly via native code.
                  The addition of this feature is temporary, pending the
                  adoption of new, public API which exports this feature.                
            </javadoc>
            <method name="findComponentAt" type="Component" line="2104">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="ignoreEnabled" type="boolean"/>
                </params>
                <scope line="2105">
                    <scope line="2106"/>
                </scope>
            </method>
            <method name="findComponentAtImpl" type="Component" line="2112">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="ignoreEnabled" type="boolean"/>
                </params>
                <scope line="2114"/>
                <scope line="2117">
                    <declaration name="comp" type="Component" line="2118"/>
                    <scope line="2119">
                        <scope line="2120"/>
                        <scope line="2123"/>
                        <scope line="2126"/>
                    </scope>
                </scope>
                <scope line="2131">
                    <declaration name="comp" type="Component" line="2132"/>
                    <scope line="2133">
                        <scope line="2134"/>
                        <scope line="2137"/>
                        <scope line="2140"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2147">
                Locates the visible child component that contains the specified
                  point.  The top-most child component is returned in the case
                  where there is overlap in the components.  If the containing child
                  component is a Container, this method will continue searching for
                  the deepest nested child component.  Components which are not
                  visible are ignored during the search.&lt;p&gt;
                  The findComponentAt method is different from getComponentAt in
                  that getComponentAt only searches the Container&apos;s immediate
                  children; if the containing component is a Container,
                  findComponentAt will search that child to find a nested component.                
                <param>
                    p   the point.                    
                </param>
                <return>
                    null if the component does not contain the position.
                      If there is no child component at the requested point and the
                      point is within the bounds of the container the container itself
                      is returned.                    
                </return>
                <throws>
                    NullPointerException if {@code p} is {@code null}                    
                </throws>
                <see>
                    Component#contains                    
                </see>
                <see>
                    #getComponentAt                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="findComponentAt" type="Component" line="2168">
                <params>
                    <param name="p" type="Point"/>
                </params>
            </method>
            <javadoc line="2171">
                Makes this Container displayable by connecting it to
                  a native screen resource.  Making a container displayable will
                  cause all of its children to be made displayable.
                  This method is called internally by the toolkit and should
                  not be called directly by programs.                
                <see>
                    Component#isDisplayable                    
                </see>
                <see>
                    #removeNotify                    
                </see>
            </javadoc>
            <method name="addNotify" type="void" line="2180">
                <scope line="2181">
                    <scope line="2183"/>
                    <scope line="2186"/>
                </scope>
            </method>
            <javadoc line="2191">
                Makes this Container undisplayable by removing its connection
                  to its native screen resource.  Making a container undisplayable
                  will cause all of its children to be made undisplayable.
                  This method is called by the toolkit internally and should
                  not be called directly by programs.                
                <see>
                    Component#isDisplayable                    
                </see>
                <see>
                    #addNotify                    
                </see>
            </javadoc>
            <method name="removeNotify" type="void" line="2200">
                <scope line="2201">
                    <scope line="2202">
                        <declaration name="comp" type="Component" line="2203"/>
                        <scope line="2204"/>
                    </scope>
                    <scope line="2210">
                        <scope line="2211"/>
                    </scope>
                    <scope line="2215"/>
                </scope>
            </method>
            <javadoc line="2222">
                Checks if the component is contained in the component hierarchy of
                  this container.                
                <param>
                    c the component                    
                </param>
                <return>
                    <code>true</code> if it is an ancestor;
                      <code>false</code> otherwise.                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="isAncestorOf" type="boolean" line="2230">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <declaration name="p" type="Container" line="2231"/>
                <scope line="2232"/>
                <scope line="2235">
                    <scope line="2236"/>
                </scope>
            </method>
            <declaration name="modalComp" type="Component" line="2243"/>
            <declaration name="modalAppContext" type="AppContext" line="2244"/>
            <method name="startLWModal" type="void" line="2245">
                <declaration name="time" type="long" line="2247"/>
                <declaration name="predictedFocusOwner" type="Component" line="2248"/>
                <scope line="2249"/>
                <declaration name="nativeContainer" type="Container" line="2252"/>
                <scope line="2253">
                    <scope line="2255"/>
                    <scope line="2260"/>
                </scope>
                <anonymous_class line="2264">
                    <method name="run" type="void" line="2265">
                        <declaration name="dispatchThread" type="EventDispatchThread" line="2266"/>
                        <anonymous_class line="2267">
                            <method name="evaluate" type="boolean" line="2268"/>
                        </anonymous_class>
                    </method>
                </anonymous_class>
                <declaration name="pumpEventsForHierarchy" type="Runnable" line="2264"/>
                <scope line="2276">
                    <declaration name="currentSequencedEvent" type="SequencedEvent" line="2277"/>
                    <scope line="2278"/>
                </scope>
                <scope line="2283">
                    <scope line="2284">
                        <scope line="2286">
                            <scope line="2287"/>
                            <scope line="2290"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2296"/>
                <scope line="2300"/>
            </method>
            <method name="stopLWModal" type="void" line="2304">
                <scope line="2305">
                    <scope line="2306">
                        <declaration name="nativeContainer" type="Container" line="2307"/>
                        <scope line="2308">
                            <scope line="2309"/>
                            <scope line="2314"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <class name="WakingRunnable" line="2324">
                <implements interface="Runnable"/>
                <method name="run" type="void" line="2325"/>
            </class>
            <javadoc line="2328">
                Returns a string representing the state of this &lt;code&gt;Container&lt;/code&gt;.
                  This method is intended to be used only for debugging purposes, and the
                  content and format of the returned string may vary between
                  implementations. The returned string may be empty but may not be
                  &lt;code&gt;null&lt;/code&gt;.                
                <return>
                    the parameter string of this container                    
                </return>
            </javadoc>
            <method name="paramString" type="String" line="2336">
                <declaration name="str" type="String" line="2337"/>
                <declaration name="layoutMgr" type="LayoutManager" line="2338"/>
                <scope line="2339"/>
            </method>
            <javadoc line="2344">
                Prints a listing of this container to the specified output
                  stream. The listing starts at the specified indentation.
                  &lt;p&gt;
                  The immediate children of the container are printed with
                  an indentation of &lt;code&gt;indent+1&lt;/code&gt;.  The children
                  of those children are printed at &lt;code&gt;indent+2&lt;/code&gt;
                  and so on.                
                <param>
                    out      a print stream                    
                </param>
                <param>
                    indent   the number of spaces to indent                    
                </param>
                <throws>
                    NullPointerException if {@code out} is {@code null}                    
                </throws>
                <see>
                    Component#list(java.io.PrintStream,int)                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="list" type="void" line="2358">
                <params>
                    <param name="out" type="PrintStream"/>
                    <param name="indent" type="int"/>
                </params>
                <scope line="2360">
                    <scope line="2361">
                        <declaration name="comp" type="Component" line="2362"/>
                        <scope line="2363"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2369">
                Prints out a list, starting at the specified indentation,
                  to the specified print writer.
                  &lt;p&gt;
                  The immediate children of the container are printed with
                  an indentation of &lt;code&gt;indent+1&lt;/code&gt;.  The children
                  of those children are printed at &lt;code&gt;indent+2&lt;/code&gt;
                  and so on.                
                <param>
                    out      a print writer                    
                </param>
                <param>
                    indent   the number of spaces to indent                    
                </param>
                <throws>
                    NullPointerException if {@code out} is {@code null}                    
                </throws>
                <see>
                    Component#list(java.io.PrintWriter,int)                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="list" type="void" line="2383">
                <params>
                    <param name="out" type="PrintWriter"/>
                    <param name="indent" type="int"/>
                </params>
                <scope line="2385">
                    <scope line="2386">
                        <declaration name="comp" type="Component" line="2387"/>
                        <scope line="2388"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2394">
                Sets the focus traversal keys for a given traversal operation for this
                  Container.
                  &lt;p&gt;
                  The default values for a Container&apos;s focus traversal keys are
                  implementation-dependent. Sun recommends that all implementations for a
                  particular native platform use the same default values. The
                  recommendations for Windows and Unix are listed below. These
                  recommendations are used in the Sun AWT implementations.
                  &lt;table border=1 summary=&quot;Recommended default values for a Container&apos;s focus traversal keys&quot;&gt;
                  &lt;tr&gt;
                  &lt;th&gt;Identifier&lt;/th&gt;
                  &lt;th&gt;Meaning&lt;/th&gt;
                  &lt;th&gt;Default&lt;/th&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS&lt;/td&gt;
                  &lt;td&gt;Normal forward keyboard traversal&lt;/td&gt;
                  &lt;td&gt;TAB on KEY_PRESSED, CTRL-TAB on KEY_PRESSED&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS&lt;/td&gt;
                  &lt;td&gt;Normal reverse keyboard traversal&lt;/td&gt;
                  &lt;td&gt;SHIFT-TAB on KEY_PRESSED, CTRL-SHIFT-TAB on KEY_PRESSED&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS&lt;/td&gt;
                  &lt;td&gt;Go up one focus traversal cycle&lt;/td&gt;
                  &lt;td&gt;none&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS&lt;td&gt;
                  &lt;td&gt;Go down one focus traversal cycle&lt;/td&gt;
                  &lt;td&gt;none&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  To disable a traversal key, use an empty Set; Collections.EMPTY_SET is
                  recommended.
                  &lt;p&gt;
                  Using the AWTKeyStroke API, client code can specify on which of two
                  specific KeyEvents, KEY_PRESSED or KEY_RELEASED, the focus traversal
                  operation will occur. Regardless of which KeyEvent is specified,
                  however, all KeyEvents related to the focus traversal key, including the
                  associated KEY_TYPED event, will be consumed, and will not be dispatched
                  to any Container. It is a runtime error to specify a KEY_TYPED event as
                  mapping to a focus traversal operation, or to map the same event to
                  multiple default focus traversal operations.
                  &lt;p&gt;
                  If a value of null is specified for the Set, this Container inherits the
                  Set from its parent. If all ancestors of this Container have null
                  specified for the Set, then the current KeyboardFocusManager&apos;s default
                  Set is used.                
                <param>
                    id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </param>
                <param>
                    keystrokes the Set of AWTKeyStroke for the specified operation                    
                </param>
                <see>
                    #getFocusTraversalKeys                    
                </see>
                <see>
                    KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <throws>
                    IllegalArgumentException if id is not one of
                      KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, or if keystrokes
                      contains null, or if any Object in keystrokes is not an
                      AWTKeyStroke, or if any keystroke represents a KEY_TYPED event,
                      or if any keystroke already maps to another focus traversal
                      operation for this Container                    
                </throws>
                <since>
                    1.4                    
                </since>
                <beaninfobound>
                    : true                    
                </beaninfobound>
            </javadoc>
            <method name="setFocusTraversalKeys" type="void" line="2468">
                <params>
                    <param name="id" type="int"/>
                    <param name="keystrokes" type="Set<? extends AWTKeyStroke>"/>
                </params>
                <scope line="2469"/>
            </method>
            <javadoc line="2474">
                Returns the Set of focus traversal keys for a given traversal operation
                  for this Container. (See
                  &lt;code&gt;setFocusTraversalKeys&lt;/code&gt; for a full description of each key.)
                  &lt;p&gt;
                  If a Set of traversal keys has not been explicitly defined for this
                  Container, then this Container&apos;s parent&apos;s Set is returned. If no Set
                  has been explicitly defined for any of this Container&apos;s ancestors, then
                  the current KeyboardFocusManager&apos;s default Set is returned.                
                <param>
                    id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </param>
                <return>
                    the Set of AWTKeyStrokes for the specified operation. The Set
                      will be unmodifiable, and may be empty. null will never be
                      returned.                    
                </return>
                <see>
                    #setFocusTraversalKeys                    
                </see>
                <see>
                    KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <see>
                    KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS                    
                </see>
                <throws>
                    IllegalArgumentException if id is not one of
                      KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getFocusTraversalKeys" type="Set<AWTKeyStroke>" line="2502">
                <params>
                    <param name="id" type="int"/>
                </params>
                <scope line="2503"/>
            </method>
            <javadoc line="2508">
                Returns whether the Set of focus traversal keys for the given focus
                  traversal operation has been explicitly defined for this Container. If
                  this method returns &lt;code&gt;false&lt;/code&gt;, this Container is inheriting the
                  Set from an ancestor, or from the current KeyboardFocusManager.                
                <param>
                    id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </param>
                <return>
                    <code>true</code> if the the Set of focus traversal keys for the
                      given focus traversal operation has been explicitly defined for
                      this Component; <code>false</code> otherwise.                    
                </return>
                <throws>
                    IllegalArgumentException if id is not one of
                      KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
                      KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
                      KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="areFocusTraversalKeysSet" type="boolean" line="2527">
                <params>
                    <param name="id" type="int"/>
                </params>
                <scope line="2528"/>
            </method>
            <javadoc line="2533">
                Returns whether the specified Container is the focus cycle root of this
                  Container&apos;s focus traversal cycle. Each focus traversal cycle has only
                  a single focus cycle root and each Container which is not a focus cycle
                  root belongs to only a single focus traversal cycle. Containers which
                  are focus cycle roots belong to two cycles: one rooted at the Container
                  itself, and one rooted at the Container&apos;s nearest focus-cycle-root
                  ancestor. This method will return &lt;code&gt;true&lt;/code&gt; for both such
                  Containers in this case.                
                <param>
                    container the Container to be tested                    
                </param>
                <return>
                    <code>true</code> if the specified Container is a focus-cycle-
                      root of this Container; <code>false</code> otherwise                    
                </return>
                <see>
                    #isFocusCycleRoot()                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFocusCycleRoot" type="boolean" line="2548">
                <params>
                    <param name="container" type="Container"/>
                </params>
                <scope line="2549"/>
                <scope line="2552"/>
            </method>
            <method name="findTraversalRoot" type="Container" line="2556">
                <declaration name="currentFocusCycleRoot" type="Container" line="2557"/>
                <declaration name="root" type="Container" line="2558"/>
                <scope line="2559"/>
                <scope line="2562">
                    <scope line="2564"/>
                </scope>
                <scope line="2568"/>
            </method>
            <method name="containsFocus" type="boolean" line="2573">
                <declaration name="focusOwner" type="Component" line="2574"/>
            </method>
            <javadoc line="2577">
                Check if this component is the child of this container or its children.
                  Note: this function acquires treeLock
                  Note: this function traverses children tree only in one Window.                
                <param>
                    comp a component in test, must not be null                    
                </param>
            </javadoc>
            <method name="isParentOf" type="boolean" line="2583">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="2584">
                    <scope line="2585"/>
                </scope>
            </method>
            <method name="clearMostRecentFocusOwnerOnHide" type="void" line="2591">
                <declaration name="reset" type="boolean" line="2592"/>
                <declaration name="window" type="Window" line="2593"/>
                <scope line="2594">
                    <scope line="2596">
                        <declaration name="comp" type="Component" line="2597"/>
                        <scope line="2599">
                            <declaration name="storedComp" type="Component" line="2600"/>
                            <scope line="2601"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2607"/>
            </method>
            <method name="clearCurrentFocusCycleRootOnHide" type="void" line="2611">
                <declaration name="kfm" type="KeyboardFocusManager" line="2612"/>
                <declaration name="cont" type="Container" line="2613"/>
                <scope line="2614"/>
            </method>
            <method name="getTraversalRoot" type="Container" line="2618">
                <scope line="2619"/>
            </method>
            <javadoc line="2624">
                Sets the focus traversal policy that will manage keyboard traversal of
                  this Container&apos;s children, if this Container is a focus cycle root. If
                  the argument is null, this Container inherits its policy from its focus-
                  cycle-root ancestor. If the argument is non-null, this policy will be
                  inherited by all focus-cycle-root children that have no keyboard-
                  traversal policy of their own (as will, recursively, their focus-cycle-
                  root children).
                  &lt;p&gt;
                  If this Container is not a focus cycle root, the policy will be
                  remembered, but will not be used or inherited by this or any other
                  Containers until this Container is made a focus cycle root.                
                <param>
                    policy the new focus traversal policy for this Container                    
                </param>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #isFocusCycleRoot                    
                </see>
                <since>
                    1.4                    
                </since>
                <beaninfobound>
                    : true                    
                </beaninfobound>
            </javadoc>
            <method name="setFocusTraversalPolicy" type="void" line="2643">
                <params>
                    <param name="policy" type="FocusTraversalPolicy"/>
                </params>
                <declaration name="oldPolicy" type="FocusTraversalPolicy" line="2644"/>
                <scope line="2645"/>
            </method>
            <javadoc line="2651">
                Returns the focus traversal policy that will manage keyboard traversal
                  of this Container&apos;s children, or null if this Container is not a focus
                  cycle root. If no traversal policy has been explicitly set for this
                  Container, then this Container&apos;s focus-cycle-root ancestor&apos;s policy is
                  returned.                
                <return>
                    this Container's focus traversal policy, or null if this
                      Container is not a focus cycle root.                    
                </return>
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #isFocusCycleRoot                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getFocusTraversalPolicy" type="FocusTraversalPolicy" line="2664">
                <scope line="2665"/>
                <declaration name="policy" type="FocusTraversalPolicy" line="2668"/>
                <scope line="2669"/>
                <declaration name="rootAncestor" type="Container" line="2672"/>
                <scope line="2673"/>
                <scope line="2676"/>
            </method>
            <javadoc line="2680">
                Returns whether the focus traversal policy has been explicitly set for
                  this Container. If this method returns &lt;code&gt;false&lt;/code&gt;, this
                  Container will inherit its focus traversal policy from an ancestor.                
                <return>
                    <code>true</code> if the focus traversal policy has been
                      explicitly set for this Container; <code>false</code> otherwise.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFocusTraversalPolicySet" type="boolean" line="2688"/>
            <javadoc line="2691">
                Sets whether this Container is the root of a focus traversal cycle. Once
                  focus enters a traversal cycle, typically it cannot leave it via focus
                  traversal unless one of the up- or down-cycle keys is pressed. Normal
                  traversal is limited to this Container, and all of this Container&apos;s
                  descendants that are not descendants of inferior focus cycle roots. Note
                  that a FocusTraversalPolicy may bend these restrictions, however. For
                  example, ContainerOrderFocusTraversalPolicy supports implicit down-cycle
                  traversal.
                  &lt;p&gt;
                  The alternative way to specify the traversal order of this Container&apos;s
                  children is to make this Container a
                  &lt;a href=&quot;doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;.                
                <param>
                    focusCycleRoot indicates whether this Container is the root of a
                      focus traversal cycle                    
                </param>
                <see>
                    #isFocusCycleRoot()                    
                </see>
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    ContainerOrderFocusTraversalPolicy                    
                </see>
                <see>
                    #setFocusTraversalPolicyProvider                    
                </see>
                <since>
                    1.4                    
                </since>
                <beaninfobound>
                    : true                    
                </beaninfobound>
            </javadoc>
            <method name="setFocusCycleRoot" type="void" line="2714">
                <params>
                    <param name="focusCycleRoot" type="boolean"/>
                </params>
                <declaration name="oldFocusCycleRoot" type="boolean" line="2715"/>
                <scope line="2716"/>
            </method>
            <javadoc line="2722">
                Returns whether this Container is the root of a focus traversal cycle.
                  Once focus enters a traversal cycle, typically it cannot leave it via
                  focus traversal unless one of the up- or down-cycle keys is pressed.
                  Normal traversal is limited to this Container, and all of this
                  Container&apos;s descendants that are not descendants of inferior focus
                  cycle roots. Note that a FocusTraversalPolicy may bend these
                  restrictions, however. For example, ContainerOrderFocusTraversalPolicy
                  supports implicit down-cycle traversal.                
                <return>
                    whether this Container is the root of a focus traversal cycle                    
                </return>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    ContainerOrderFocusTraversalPolicy                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isFocusCycleRoot" type="boolean" line="2738"/>
            <javadoc line="2741">
                Sets whether this container will be used to provide focus
                  traversal policy. Container with this property as
                  &lt;code&gt;true&lt;/code&gt; will be used to acquire focus traversal policy
                  instead of closest focus cycle root ancestor.                
                <param>
                    provider indicates whether this container will be used to
                      provide focus traversal policy                    
                </param>
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    #isFocusTraversalPolicyProvider                    
                </see>
                <since>
                    1.5                    
                </since>
                <beaninfobound>
                    : true                    
                </beaninfobound>
            </javadoc>
            <method name="setFocusTraversalPolicyProvider" type="void" line="2754">
                <params>
                    <param name="provider" type="boolean"/>
                </params>
                <declaration name="oldProvider" type="boolean" line="2755"/>
                <scope line="2756"/>
            </method>
            <javadoc line="2762">
                Returns whether this container provides focus traversal
                  policy. If this property is set to &lt;code&gt;true&lt;/code&gt; then when
                  keyboard focus manager searches container hierarchy for focus
                  traversal policy and encounters this container before any other
                  container with this property as true or focus cycle roots then
                  its focus traversal policy will be used instead of focus cycle
                  root&apos;s policy.                
                <see>
                    #setFocusTraversalPolicy                    
                </see>
                <see>
                    #getFocusTraversalPolicy                    
                </see>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <see>
                    #setFocusTraversalPolicyProvider                    
                </see>
                <return>
                    <code>true</code> if this container provides focus traversal
                      policy, <code>false</code> otherwise                    
                </return>
                <since>
                    1.5                    
                </since>
                <beaninfobound>
                    : true                    
                </beaninfobound>
            </javadoc>
            <method name="isFocusTraversalPolicyProvider" type="boolean" line="2779"/>
            <javadoc line="2782">
                Transfers the focus down one focus traversal cycle. If this Container is
                  a focus cycle root, then the focus owner is set to this Container&apos;s
                  default Component to focus, and the current focus cycle root is set to
                  this Container. If this Container is not a focus cycle root, then no
                  focus traversal operation occurs.                
                <see>
                    Component#requestFocus()                    
                </see>
                <see>
                    #isFocusCycleRoot                    
                </see>
                <see>
                    #setFocusCycleRoot                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="transferFocusDownCycle" type="void" line="2793">
                <scope line="2794">
                    <declaration name="toFocus" type="Component" line="2796"/>
                    <scope line="2797"/>
                </scope>
            </method>
            <method name="preProcessKeyEvent" type="void" line="2802">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <declaration name="parent" type="Container" line="2803"/>
                <scope line="2804"/>
            </method>
            <method name="postProcessKeyEvent" type="void" line="2808">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <declaration name="parent" type="Container" line="2809"/>
                <scope line="2810"/>
            </method>
            <method name="postsOldMouseEvents" type="boolean" line="2814"/>
            <javadoc line="2817">
                Sets the &lt;code&gt;ComponentOrientation&lt;/code&gt; property of this container
                  and all components contained within it.
                  &lt;p&gt;
                  This method changes layout-related information, and therefore,
                  invalidates the component hierarchy.                
                <param>
                    o the new component orientation of this container and
                      the components contained within it.                    
                </param>
                <exception>
                    NullPointerException if <code>orientation</code> is null.                    
                </exception>
                <see>
                    Component#setComponentOrientation                    
                </see>
                <see>
                    Component#getComponentOrientation                    
                </see>
                <see>
                    #invalidate                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="applyComponentOrientation" type="void" line="2831">
                <params>
                    <param name="o" type="ComponentOrientation"/>
                </params>
                <scope line="2833">
                    <scope line="2834">
                        <declaration name="comp" type="Component" line="2835"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2840">
                Adds a PropertyChangeListener to the listener list. The listener is
                  registered for all bound properties of this class, including the
                  following:
                  &lt;ul&gt;
                  &lt;li&gt;this Container&apos;s font (&quot;font&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s background color (&quot;background&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focusability (&quot;focusable&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus traversal keys enabled state
                  (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of FORWARD_TRAVERSAL_KEYS
                  (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of BACKWARD_TRAVERSAL_KEYS
                  (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of UP_CYCLE_TRAVERSAL_KEYS
                  (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
                  (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
                  &lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus-cycle-root state (&quot;focusCycleRoot&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  Note that if this Container is inheriting a bound property, then no
                  event will be fired in response to a change in the inherited property.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    listener  the PropertyChangeListener to be added                    
                </param>
                <see>
                    Component#removePropertyChangeListener                    
                </see>
                <see>
                    #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)                    
                </see>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="2871">
                <params>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
            </method>
            <javadoc line="2874">
                Adds a PropertyChangeListener to the listener list for a specific
                  property. The specified property may be user-defined, or one of the
                  following defaults:
                  &lt;ul&gt;
                  &lt;li&gt;this Container&apos;s font (&quot;font&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s background color (&quot;background&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focusability (&quot;focusable&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus traversal keys enabled state
                  (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of FORWARD_TRAVERSAL_KEYS
                  (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of BACKWARD_TRAVERSAL_KEYS
                  (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of UP_CYCLE_TRAVERSAL_KEYS
                  (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
                  (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
                  &lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus-cycle-root state (&quot;focusCycleRoot&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus-traversal-policy-provider state(&quot;focusTraversalPolicyProvider&quot;)&lt;/li&gt;
                  &lt;li&gt;this Container&apos;s focus-traversal-policy-provider state(&quot;focusTraversalPolicyProvider&quot;)&lt;/li&gt;
                  &lt;/ul&gt;
                  Note that if this Container is inheriting a bound property, then no
                  event will be fired in response to a change in the inherited property.
                  &lt;p&gt;
                  If listener is null, no exception is thrown and no action is performed.                
                <param>
                    propertyName one of the property names listed above                    
                </param>
                <param>
                    listener the PropertyChangeListener to be added                    
                </param>
                <see>
                    #addPropertyChangeListener(java.beans.PropertyChangeListener)                    
                </see>
                <see>
                    Component#removePropertyChangeListener                    
                </see>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="2908">
                <params>
                    <param name="propertyName" type="String"/>
                    <param name="listener" type="PropertyChangeListener"/>
                </params>
            </method>
            <declaration name="containerSerializedDataVersion" type="int" line="2911"/>
            <javadoc line="2911">
                Container Serial Data Version.                
            </javadoc>
            <javadoc line="2915">
                Serializes this &lt;code&gt;Container&lt;/code&gt; to the specified
                  &lt;code&gt;ObjectOutputStream&lt;/code&gt;.
                  &lt;ul&gt;
                  &lt;li&gt;Writes default serializable fields to the stream.&lt;/li&gt;
                  &lt;li&gt;Writes a list of serializable ContainerListener(s) as optional
                  data. The non-serializable ContainerListner(s) are detected and
                  no attempt is made to serialize them.&lt;/li&gt;
                  &lt;li&gt;Write this Container&apos;s FocusTraversalPolicy if and only if it
                  is Serializable; otherwise, &lt;code&gt;null&lt;/code&gt; is written.&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    s the <code>ObjectOutputStream</code> to write                    
                </param>
                <serialData>
                    <code>null</code> terminated sequence of 0 or more pairs;
                      the pair consists of a <code>String</code> and <code>Object</code>;
                      the <code>String</code> indicates the type of object and
                      is one of the following:
                      <code>containerListenerK</code> indicating an
                      <code>ContainerListener</code> object;
                      the <code>Container</code>'s <code>FocusTraversalPolicy</code>,
                      or <code>null</code>                    
                </serialData>
                <see>
                    AWTEventMulticaster#save(java.io.ObjectOutputStream,java.lang.String,java.util.EventListener)                    
                </see>
                <see>
                    Container#containerListenerK                    
                </see>
                <see>
                    #readObject(ObjectInputStream)                    
                </see>
            </javadoc>
            <method name="writeObject" type="void" line="2939">
                <params>
                    <param name="s" type="ObjectOutputStream"/>
                </params>
                <declaration name="f" type="ObjectOutputStream.PutField" line="2940"/>
                <scope line="2952"/>
                <scope line="2955"/>
            </method>
            <javadoc line="2959">
                Deserializes this &lt;code&gt;Container&lt;/code&gt; from the specified
                  &lt;code&gt;ObjectInputStream&lt;/code&gt;.
                  &lt;ul&gt;
                  &lt;li&gt;Reads default serializable fields from the stream.&lt;/li&gt;
                  &lt;li&gt;Reads a list of serializable ContainerListener(s) as optional
                  data. If the list is null, no Listeners are installed.&lt;/li&gt;
                  &lt;li&gt;Reads this Container&apos;s FocusTraversalPolicy, which may be null,
                  as optional data.&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    s the <code>ObjectInputStream</code> to read                    
                </param>
                <serial>
                                        
                </serial>
                <see>
                    #addContainerListener                    
                </see>
                <see>
                    #writeObject(ObjectOutputStream)                    
                </see>
            </javadoc>
            <method name="readObject" type="void" line="2974">
                <params>
                    <param name="s" type="ObjectInputStream"/>
                </params>
                <declaration name="f" type="ObjectInputStream.GetField" line="2975"/>
                <declaration name="tmpComponent" type="Component[]" line="2976"/>
                <declaration name="ncomponents" type="int" line="2977"/>
                <scope line="2979"/>
                <scope line="2984"/>
                <declaration name="component" type="java.util.List&lt;Component&gt;" line="2990"/>
                <scope line="2991"/>
                <declaration name="keyOrNull" type="Object" line="2997"/>
                <scope line="2998">
                    <declaration name="key" type="String" line="2999"/>
                    <scope line="3000"/>
                    <scope line="3003"/>
                </scope>
                <scope line="3007">
                    <declaration name="policy" type="Object" line="3008"/>
                    <scope line="3009"/>
                </scope>
                <scope line="3013">
                    <scope line="3014"/>
                </scope>
            </method>
            <class name="AccessibleAWTContainer" line="3019">
                <extends class="AccessibleAWTComponent"/>
                <javadoc line="3019">
                    Inner class of Container used to provide default support for
                      accessibility.  This class is not meant to be used directly by
                      application developers, but is instead meant only to be
                      subclassed by container developers.
                      &lt;p&gt;
                      The class used to obtain the accessible role for this object,
                      as well as implementing many of the methods in the
                      AccessibleContainer interface.                    
                    <since>
                        1.3                        
                    </since>
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3031"/>
                <javadoc line="3031">
                    JDK1.3 serialVersionUID                    
                </javadoc>
                <javadoc line="3035">
                    Returns the number of accessible children in the object.  If all
                      of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
                      then this method should return the number of children of this object.                    
                    <return>
                        the number of accessible children in the object                        
                    </return>
                </javadoc>
                <method name="getAccessibleChildrenCount" type="int" line="3041"/>
                <javadoc line="3044">
                    Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.                    
                    <param>
                        i zero-based index of child                        
                    </param>
                    <return>
                        the nth <code>Accessible</code> child of the object                        
                    </return>
                </javadoc>
                <method name="getAccessibleChild" type="Accessible" line="3049">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <javadoc line="3052">
                    Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,
                      contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.                    
                    <param>
                        p the point defining the top-left corner of the
                          <code>Accessible</code>, given in the coordinate space
                          of the object's parent                        
                    </param>
                    <return>
                        the <code>Accessible</code>, if it exists,
                          at the specified location; else <code>null</code>                        
                    </return>
                </javadoc>
                <method name="getAccessibleAt" type="Accessible" line="3061">
                    <params>
                        <param name="p" type="Point"/>
                    </params>
                </method>
                <declaration name="accessibleContainerHandler" type="ContainerListener" line="3064"/>
                <class name="AccessibleContainerHandler" line="3065">
                    <implements interface="ContainerListener"/>
                    <javadoc line="3065">
                        Fire &lt;code&gt;PropertyChange&lt;/code&gt; listener, if one is registered,
                          when children are added or removed.                        
                        <since>
                            1.3                            
                        </since>
                    </javadoc>
                    <method name="componentAdded" type="void" line="3071">
                        <params>
                            <param name="e" type="ContainerEvent"/>
                        </params>
                        <declaration name="c" type="Component" line="3072"/>
                        <scope line="3073"/>
                    </method>
                    <method name="componentRemoved" type="void" line="3077">
                        <params>
                            <param name="e" type="ContainerEvent"/>
                        </params>
                        <declaration name="c" type="Component" line="3078"/>
                        <scope line="3079"/>
                    </method>
                </class>
                <javadoc line="3084">
                    Adds a PropertyChangeListener to the listener list.                    
                    <param>
                        listener  the PropertyChangeListener to be added                        
                    </param>
                </javadoc>
                <method name="addPropertyChangeListener" type="void" line="3088">
                    <params>
                        <param name="listener" type="PropertyChangeListener"/>
                    </params>
                    <scope line="3089"/>
                </method>
            </class>
            <javadoc line="3096">
                Returns the &lt;code&gt;Accessible&lt;/code&gt; child contained at the local
                  coordinate &lt;code&gt;Point&lt;/code&gt;, if one exists.  Otherwise
                  returns &lt;code&gt;null&lt;/code&gt;.                
                <param>
                    p the point defining the top-left corner of the
                      <code>Accessible</code>, given in the coordinate space
                      of the object's parent                    
                </param>
                <return>
                    the <code>Accessible</code> at the specified location,
                      if it exists; otherwise <code>null</code>                    
                </return>
            </javadoc>
            <method name="getAccessibleAt" type="Accessible" line="3106">
                <params>
                    <param name="p" type="Point"/>
                </params>
                <scope line="3107">
                    <scope line="3108">
                        <declaration name="a" type="Accessible" line="3109"/>
                        <declaration name="ac" type="AccessibleContext" line="3110"/>
                        <scope line="3111">
                            <declaration name="acmp" type="AccessibleComponent" line="3112"/>
                            <declaration name="location" type="Point" line="3113"/>
                            <declaration name="nchildren" type="int" line="3114"/>
                            <scope line="3115">
                                <scope line="3117">
                                    <scope line="3119">
                                        <scope line="3121">
                                            <declaration name="np" type="Point" line="3123"/>
                                            <scope line="3124"/>
                                        </scope>
                                    </scope>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="3134">
                        <declaration name="ret" type="Component" line="3135"/>
                        <scope line="3136"/>
                        <scope line="3139">
                            <declaration name="ncomponents" type="int" line="3140"/>
                            <scope line="3141">
                                <declaration name="comp" type="Component" line="3142"/>
                                <scope line="3143">
                                    <declaration name="location" type="Point" line="3144"/>
                                    <scope line="3145"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="3151"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3158">
                Returns the number of accessible children in the object.  If all
                  of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
                  then this method should return the number of children of this object.                
                <return>
                    the number of accessible children in the object                    
                </return>
            </javadoc>
            <method name="getAccessibleChildrenCount" type="int" line="3164">
                <scope line="3165">
                    <declaration name="count" type="int" line="3166"/>
                    <declaration name="children" type="Component[]" line="3167"/>
                    <scope line="3168">
                        <scope line="3169"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3176">
                Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.                
                <param>
                    i zero-based index of child                    
                </param>
                <return>
                    the nth <code>Accessible</code> child of the object                    
                </return>
            </javadoc>
            <method name="getAccessibleChild" type="Accessible" line="3181">
                <params>
                    <param name="i" type="int"/>
                </params>
                <scope line="3182">
                    <declaration name="children" type="Component[]" line="3183"/>
                    <declaration name="count" type="int" line="3184"/>
                    <scope line="3185">
                        <scope line="3186">
                            <scope line="3187"/>
                            <scope line="3190"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="increaseComponentCount" type="void" line="3198">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="3199">
                    <scope line="3200"/>
                    <declaration name="addHW" type="int" line="3203"/>
                    <declaration name="addLW" type="int" line="3204"/>
                    <scope line="3205"/>
                    <scope line="3209"/>
                    <scope line="3212"/>
                    <scope line="3215"/>
                </scope>
            </method>
            <method name="decreaseComponentCount" type="void" line="3221">
                <params>
                    <param name="c" type="Component"/>
                </params>
                <scope line="3222">
                    <scope line="3223"/>
                    <declaration name="subHW" type="int" line="3226"/>
                    <declaration name="subLW" type="int" line="3227"/>
                    <scope line="3228"/>
                    <scope line="3232"/>
                    <scope line="3235"/>
                    <scope line="3238"/>
                </scope>
            </method>
            <method name="getTopmostComponentIndex" type="int" line="3244">
                <scope line="3246"/>
            </method>
            <method name="getBottommostComponentIndex" type="int" line="3251">
                <scope line="3253"/>
            </method>
            <method name="getOpaqueShape" type="Region" line="3258">
                <scope line="3260">
                    <declaration name="s" type="Region" line="3261"/>
                    <scope line="3262">
                        <declaration name="c" type="Component" line="3263"/>
                        <scope line="3264"/>
                    </scope>
                </scope>
            </method>
            <method name="recursiveSubtractAndApplyShape" type="void" line="3272">
                <params>
                    <param name="shape" type="Region"/>
                </params>
            </method>
            <method name="recursiveSubtractAndApplyShape" type="void" line="3275">
                <params>
                    <param name="shape" type="Region"/>
                    <param name="fromZorder" type="int"/>
                </params>
            </method>
            <method name="recursiveSubtractAndApplyShape" type="void" line="3278">
                <params>
                    <param name="shape" type="Region"/>
                    <param name="fromZorder" type="int"/>
                    <param name="toZorder" type="int"/>
                </params>
                <scope line="3280"/>
                <scope line="3283"/>
                <scope line="3286"/>
                <scope line="3289"/>
                <scope line="3292">
                    <declaration name="comp" type="Component" line="3293"/>
                    <scope line="3294"/>
                    <scope line="3297"/>
                </scope>
            </method>
            <method name="recursiveApplyCurrentShape" type="void" line="3302"/>
            <method name="recursiveApplyCurrentShape" type="void" line="3305">
                <params>
                    <param name="fromZorder" type="int"/>
                </params>
            </method>
            <method name="recursiveApplyCurrentShape" type="void" line="3308">
                <params>
                    <param name="fromZorder" type="int"/>
                    <param name="toZorder" type="int"/>
                </params>
                <scope line="3310"/>
                <scope line="3313"/>
                <scope line="3316"/>
                <scope line="3319">
                    <declaration name="comp" type="Component" line="3320"/>
                    <scope line="3321"/>
                    <scope line="3324"/>
                </scope>
            </method>
            <method name="recursiveShowHeavyweightChildren" type="void" line="3329">
                <scope line="3330"/>
                <scope line="3333">
                    <declaration name="comp" type="Component" line="3334"/>
                    <scope line="3335">
                        <scope line="3336"/>
                    </scope>
                    <scope line="3340">
                        <scope line="3341">
                            <declaration name="peer" type="ComponentPeer" line="3342"/>
                            <scope line="3343"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="recursiveHideHeavyweightChildren" type="void" line="3350">
                <scope line="3351"/>
                <scope line="3354">
                    <declaration name="comp" type="Component" line="3355"/>
                    <scope line="3356">
                        <scope line="3357"/>
                    </scope>
                    <scope line="3361">
                        <scope line="3362">
                            <declaration name="peer" type="ComponentPeer" line="3363"/>
                            <scope line="3364"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="recursiveRelocateHeavyweightChildren" type="void" line="3371">
                <params>
                    <param name="origin" type="Point"/>
                </params>
                <scope line="3372">
                    <declaration name="comp" type="Component" line="3373"/>
                    <scope line="3374">
                        <scope line="3375">
                            <declaration name="newOrigin" type="Point" line="3376"/>
                        </scope>
                    </scope>
                    <scope line="3381">
                        <declaration name="peer" type="ComponentPeer" line="3382"/>
                        <scope line="3383"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3389">
                Checks if the container and its direct lightweight containers are
                  visible.
                  Consider the heavyweight container hides or shows the HW descendants
                  automatically. Therefore we care of LW containers&apos; visibility only.
                  This method MUST be invoked under the TreeLock.                
            </javadoc>
            <method name="isRecursivelyVisibleUpToHeavyweightContainer" type="boolean" line="3396">
                <scope line="3397"/>
                <scope line="3400">
                    <scope line="3401"/>
                </scope>
            </method>
            <method name="mixOnShowing" type="void" line="3407">
                <scope line="3408">
                    <scope line="3409"/>
                    <declaration name="isLightweight" type="boolean" line="3412"/>
                    <scope line="3413"/>
                    <scope line="3416"/>
                    <scope line="3419"/>
                </scope>
            </method>
            <method name="mixOnHiding" type="void" line="3425">
                <params>
                    <param name="isLightweight" type="boolean"/>
                </params>
                <scope line="3426">
                    <scope line="3427"/>
                    <scope line="3430"/>
                </scope>
            </method>
            <method name="mixOnReshaping" type="void" line="3436">
                <scope line="3437">
                    <scope line="3438"/>
                    <declaration name="isMixingNeeded" type="boolean" line="3441"/>
                    <scope line="3442">
                        <declaration name="origin" type="Point" line="3443"/>
                        <scope line="3444"/>
                        <scope line="3448"/>
                    </scope>
                    <scope line="3453"/>
                </scope>
            </method>
            <method name="mixOnZOrderChanging" type="void" line="3459">
                <params>
                    <param name="oldZorder" type="int"/>
                    <param name="newZorder" type="int"/>
                </params>
                <scope line="3460">
                    <scope line="3461"/>
                    <scope line="3464"/>
                    <declaration name="becameHigher" type="boolean" line="3467"/>
                    <scope line="3468"/>
                </scope>
            </method>
            <method name="mixOnValidating" type="void" line="3474">
                <scope line="3475">
                    <scope line="3476"/>
                    <scope line="3479"/>
                    <scope line="3482"/>
                    <scope line="3485"/>
                </scope>
            </method>
        </class>
        <class name="LightweightDispatcher" line="3492">
            <implements interface="java.io.Serializable"/>
            <implements interface="AWTEventListener"/>
            <javadoc line="3492">
                Class to manage the dispatching of MouseEvents to the lightweight descendants
                  and SunDropTargetEvents to both lightweight and heavyweight descendants
                  contained by a native container.
                  NOTE: the class name is not appropriate anymore, but we cannot change it
                  because we must keep serialization compatibility.                
                <author>
                    Timothy Prinzing                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="3501"/>
            <declaration name="LWD_MOUSE_DRAGGED_OVER" type="int" line="3502"/>
            <declaration name="eventLog" type="PlatformLogger" line="3503"/>
            <method name="LightweightDispatcher" type="constructor" line="3504">
                <params>
                    <param name="nativeContainer" type="Container"/>
                </params>
            </method>
            <method name="dispose" type="void" line="3509"/>
            <javadoc line="3513">
                Enables events to subcomponents.                
            </javadoc>
            <method name="enableEvents" type="void" line="3516">
                <params>
                    <param name="events" type="long"/>
                </params>
            </method>
            <javadoc line="3519">
                Dispatches an event to a sub-component if necessary, and
                  returns whether or not the event was forwarded to a
                  sub-component.                
                <param>
                    e the event                    
                </param>
            </javadoc>
            <method name="dispatchEvent" type="boolean" line="3525">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <declaration name="ret" type="boolean" line="3526"/>
                <scope line="3527">
                    <declaration name="sdde" type="SunDropTargetEvent" line="3528"/>
                </scope>
                <scope line="3531">
                    <scope line="3532">
                        <declaration name="me" type="MouseEvent" line="3533"/>
                    </scope>
                    <scope line="3536"/>
                </scope>
            </method>
            <method name="isMouseGrab" type="boolean" line="3542">
                <params>
                    <param name="e" type="MouseEvent"/>
                </params>
                <declaration name="modifiers" type="int" line="3543"/>
                <scope line="3544"/>
            </method>
            <javadoc line="3559">
                This method attempts to distribute a mouse event to a lightweight
                  component.  It tries to avoid doing any unnecessary probes down
                  into the component tree to minimize the overhead of determining
                  where to route the event, since mouse movement events tend to
                  come in large and frequent amounts.                
            </javadoc>
            <method name="processMouseEvent" type="boolean" line="3566">
                <params>
                    <param name="e" type="MouseEvent"/>
                </params>
                <declaration name="id" type="int" line="3567"/>
                <declaration name="mouseOver" type="Component" line="3568"/>
                <scope line="3570"/>
                <scope line="3573">
                    <scope line="3585"/>
                    <scope line="3593"/>
                    <scope line="3598"/>
                    <scope line="3604"/>
                </scope>
            </method>
            <method name="processDropTargetEvent" type="boolean" line="3610">
                <params>
                    <param name="e" type="SunDropTargetEvent"/>
                </params>
                <declaration name="id" type="int" line="3611"/>
                <declaration name="x" type="int" line="3612"/>
                <declaration name="y" type="int" line="3613"/>
                <scope line="3614">
                    <declaration name="d" type="Dimension" line="3615"/>
                    <scope line="3616"/>
                    <scope line="3619"/>
                    <scope line="3622"/>
                    <scope line="3625"/>
                </scope>
                <declaration name="mouseOver" type="Component" line="3629"/>
                <scope line="3631"/>
            </method>
            <method name="trackMouseEnterExit" type="void" line="3644">
                <params>
                    <param name="targetOver" type="Component"/>
                    <param name="e" type="MouseEvent"/>
                </params>
                <declaration name="targetEnter" type="Component" line="3645"/>
                <declaration name="id" type="int" line="3646"/>
                <scope line="3647"/>
                <scope line="3650"/>
                <scope line="3654"/>
                <scope line="3658"/>
                <scope line="3661"/>
                <scope line="3664"/>
                <scope line="3667"/>
                <scope line="3670"/>
                <scope line="3673"/>
            </method>
            <method name="startListeningForOtherDrags" type="void" line="3678">
                <anonymous_class line="3679">
                    <method name="run" type="Object" line="3680"/>
                </anonymous_class>
            </method>
            <method name="stopListeningForOtherDrags" type="void" line="3687">
                <anonymous_class line="3688">
                    <method name="run" type="Object" line="3689"/>
                </anonymous_class>
            </method>
            <method name="eventDispatched" type="void" line="3696">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <declaration name="isForeignDrag" type="boolean" line="3697"/>
                <scope line="3698"/>
                <declaration name="srcEvent" type="MouseEvent" line="3701"/>
                <declaration name="me" type="MouseEvent" line="3702"/>
                <scope line="3703">
                    <declaration name="srcComponent" type="Component" line="3704"/>
                    <scope line="3705"/>
                    <declaration name="c" type="Component" line="3708"/>
                    <scope line="3709"/>
                    <scope line="3712"/>
                    <declaration name="ptSrcOrigin" type="Point" line="3717"/>
                    <scope line="3718">
                        <declaration name="mouseEvent" type="MouseEvent" line="3719"/>
                        <anonymous_class line="3720">
                            <method name="run" type="void" line="3721">
                                <scope line="3722"/>
                                <declaration name="ptDstOrigin" type="Point" line="3725"/>
                                <declaration name="targetOver" type="Component" line="3727"/>
                            </method>
                        </anonymous_class>
                        <declaration name="r" type="Runnable" line="3720"/>
                    </scope>
                    <scope line="3735">
                        <scope line="3736"/>
                        <declaration name="ptDstOrigin" type="Point" line="3739"/>
                    </scope>
                </scope>
                <declaration name="targetOver" type="Component" line="3743"/>
            </method>
            <javadoc line="3746">
                Sends a mouse event to the current mouse event recipient using
                  the given event (sent to the windowed host) as a srcEvent.  If
                  the mouse event target is still in the component tree, the
                  coordinates of the event are translated to those of the target.
                  If the target has been removed, we don&apos;t bother to send the
                  message.                
            </javadoc>
            <method name="retargetMouseEvent" type="void" line="3754">
                <params>
                    <param name="target" type="Component"/>
                    <param name="id" type="int"/>
                    <param name="e" type="MouseEvent"/>
                </params>
            </method>
            <declaration name="nativeContainer" type="Container" line="3798"/>
            <javadoc line="3798">
                The windowed container that might be hosting events for
                  subcomponents.                
            </javadoc>
            <declaration name="focus" type="Component" line="3803"/>
            <javadoc line="3803">
                This variable is not used, but kept for serialization compatibility                
            </javadoc>
            <declaration name="mouseEventTarget" type="Component" line="3807"/>
            <javadoc line="3807">
                The current subcomponent being hosted by this windowed
                  component that has events being forwarded to it.  If this
                  is null, there are currently no events being forwarded to
                  a subcomponent.                
            </javadoc>
            <declaration name="targetLastEntered" type="Component" line="3814"/>
            <javadoc line="3814">
                The last component entered                
            </javadoc>
            <declaration name="isMouseInNativeContainer" type="boolean" line="3818"/>
            <javadoc line="3818">
                Is the mouse over the native container                
            </javadoc>
            <declaration name="nativeCursor" type="Cursor" line="3822"/>
            <javadoc line="3822">
                This variable is not used, but kept for serialization compatibility                
            </javadoc>
            <declaration name="eventMask" type="long" line="3826"/>
            <javadoc line="3826">
                The event mask for contained lightweight components.  Lightweight
                  components need a windowed container to host window-related
                  events.  This separate mask indicates events that have been
                  requested by contained lightweight components without effecting
                  the mask of the windowed component itself.                
            </javadoc>
            <declaration name="PROXY_EVENT_MASK" type="long" line="3834"/>
            <javadoc line="3834">
                The kind of events routed to lightweight components from windowed
                  hosts.                
            </javadoc>
            <declaration name="MOUSE_MASK" type="long" line="3839"/>
        </class>
    </source>