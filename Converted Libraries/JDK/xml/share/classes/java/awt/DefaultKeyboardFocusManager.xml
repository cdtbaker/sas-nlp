<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.awt.event.FocusEvent"/>
        <import package="java.awt.event.KeyEvent"/>
        <import package="java.awt.event.WindowEvent"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.peer.LightweightPeer"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.ListIterator"/>
        <import package="java.util.Set"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.CausedFocusEvent"/>
        <class name="DefaultKeyboardFocusManager" line="16">
            <extends class="KeyboardFocusManager"/>
            <javadoc line="16">
                The default KeyboardFocusManager for AWT applications. Focus traversal is
                  done in response to a Component&apos;s focus traversal keys, and using a
                  Container&apos;s FocusTraversalPolicy.
                  &lt;p&gt;
                  Please see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                  &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
                  for more information.                
                <author>
                    David Mendenhall                    
                </author>
                <see>
                    FocusTraversalPolicy                    
                </see>
                <see>
                    Component#setFocusTraversalKeys                    
                </see>
                <see>
                    Component#getFocusTraversalKeys                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="focusLog" type="PlatformLogger" line="34"/>
            <declaration name="NULL_WINDOW_WR" type="WeakReference&amp;lt;Window&amp;gt;" line="35"/>
            <declaration name="NULL_COMPONENT_WR" type="WeakReference&amp;lt;Component&amp;gt;" line="36"/>
            <declaration name="realOppositeWindowWR" type="WeakReference&amp;lt;Window&amp;gt;" line="37"/>
            <declaration name="realOppositeComponentWR" type="WeakReference&amp;lt;Component&amp;gt;" line="38"/>
            <declaration name="inSendMessage" type="int" line="39"/>
            <declaration name="enqueuedKeyEvents" type="LinkedList" line="40"/>
            <declaration name="consumeNextKeyTyped" type="boolean" line="41"/>
            <class name="TypeAheadMarker" line="42">
                <declaration name="after" type="long" line="43"/>
                <declaration name="untilFocused" type="Component" line="44"/>
                <method name="TypeAheadMarker" type="constructor" line="45">
                    <params>
                        <param name="after" type="long"/>
                        <param name="untilFocused" type="Component"/>
                    </params>
                </method>
                <javadoc line="49">
                    Returns string representation of the marker                    
                </javadoc>
                <method name="toString" type="String" line="52"/>
            </class>
            <method name="getOwningFrameDialog" type="Window" line="56">
                <params>
                    <param name="window" type="Window"/>
                </params>
                <scope line="57"/>
            </method>
            <method name="restoreFocus" type="void" line="62">
                <params>
                    <param name="fe" type="FocusEvent"/>
                    <param name="newFocusedWindow" type="Window"/>
                </params>
                <declaration name="realOppositeComponent" type="Component" line="63"/>
                <declaration name="vetoedComponent" type="Component" line="64"/>
                <scope line="65"/>
                <scope line="67"/>
                <scope line="69"/>
                <scope line="71"/>
            </method>
            <method name="restoreFocus" type="void" line="75">
                <params>
                    <param name="we" type="WindowEvent"/>
                </params>
                <declaration name="realOppositeWindow" type="Window" line="76"/>
                <scope line="77"/>
                <scope line="79"/>
                <scope line="81"/>
            </method>
            <method name="restoreFocus" type="boolean" line="85">
                <params>
                    <param name="aWindow" type="Window"/>
                    <param name="vetoedComponent" type="Component"/>
                    <param name="clearOnFailure" type="boolean"/>
                </params>
                <declaration name="toFocus" type="Component" line="86"/>
                <scope line="87"/>
                <scope line="90"/>
                <scope line="94"/>
            </method>
            <method name="restoreFocus" type="boolean" line="98">
                <params>
                    <param name="toFocus" type="Component"/>
                    <param name="clearOnFailure" type="boolean"/>
                </params>
            </method>
            <method name="doRestoreFocus" type="boolean" line="101">
                <params>
                    <param name="toFocus" type="Component"/>
                    <param name="vetoedComponent" type="Component"/>
                    <param name="clearOnFailure" type="boolean"/>
                </params>
                <scope line="102"/>
                <scope line="105">
                    <declaration name="nextFocus" type="Component" line="106"/>
                    <scope line="107"/>
                    <scope line="110"/>
                    <scope line="114"/>
                </scope>
            </method>
            <class name="DefaultKeyboardFocusManagerSentEvent" line="119">
                <extends class="SentEvent"/>
                <javadoc line="119">
                    A special type of SentEvent which updates a counter in the target
                      KeyboardFocusManager if it is an instance of
                      DefaultKeyboardFocusManager.                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="125"/>
                <method name="DefaultKeyboardFocusManagerSentEvent" type="constructor" line="126">
                    <params>
                        <param name="nested" type="AWTEvent"/>
                        <param name="toNotify" type="AppContext"/>
                    </params>
                </method>
                <method name="dispatch" type="void" line="129">
                    <declaration name="manager" type="KeyboardFocusManager" line="130"/>
                    <declaration name="defaultManager" type="DefaultKeyboardFocusManager" line="131"/>
                    <scope line="132">
                        <scope line="133"/>
                    </scope>
                    <scope line="138">
                        <scope line="139"/>
                    </scope>
                </method>
            </class>
            <javadoc line="145">
                Sends a synthetic AWTEvent to a Component. If the Component is in
                  the current AppContext, then the event is immediately dispatched.
                  If the Component is in a different AppContext, then the event is
                  posted to the other AppContext&apos;s EventQueue, and this method blocks
                  until the event is handled or target AppContext is disposed.
                  Returns true if successfuly dispatched event, false if failed
                  to dispatch.                
            </javadoc>
            <method name="sendMessage" type="boolean" line="154">
                <params>
                    <param name="target" type="Component"/>
                    <param name="e" type="AWTEvent"/>
                </params>
                <declaration name="myAppContext" type="AppContext" line="156"/>
                <declaration name="targetAppContext" type="AppContext" line="157"/>
                <declaration name="se" type="SentEvent" line="158"/>
                <scope line="159"/>
                <scope line="162">
                    <scope line="163"/>
                    <scope line="167">
                        <declaration name="edt" type="EventDispatchThread" line="168"/>
                        <anonymous_class line="169">
                            <method name="evaluate" type="boolean" line="170"/>
                        </anonymous_class>
                    </scope>
                    <scope line="176">
                        <scope line="177">
                            <scope line="178">
                                <scope line="179"/>
                                <scope line="182"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="191">
                This method is called by the AWT event dispatcher requesting that the
                  current KeyboardFocusManager dispatch the specified event on its behalf.
                  DefaultKeyboardFocusManagers dispatch all FocusEvents, all WindowEvents
                  related to focus, and all KeyEvents. These events are dispatched based
                  on the KeyboardFocusManager&apos;s notion of the focus owner and the focused
                  and active Windows, sometimes overriding the source of the specified
                  AWTEvent. If this method returns &lt;code&gt;false&lt;/code&gt;, then the AWT event
                  dispatcher will attempt to dispatch the event itself.                
                <param>
                    e the AWTEvent to be dispatched                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if this method dispatched the event;
                      &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
            </javadoc>
            <method name="dispatchEvent" type="boolean" line="204">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <scope line="208">
                    <declaration name="we" type="WindowEvent" line="209"/>
                    <declaration name="oldFocusedWindow" type="Window" line="210"/>
                    <declaration name="newFocusedWindow" type="Window" line="211"/>
                    <scope line="212"/>
                    <scope line="215"/>
                    <scope line="219">
                        <declaration name="isEventDispatched" type="boolean" line="220"/>
                        <scope line="221"/>
                    </scope>
                    <declaration name="newActiveWindow" type="Window" line="226"/>
                    <declaration name="currentActiveWindow" type="Window" line="227"/>
                    <scope line="228">
                        <scope line="230"/>
                    </scope>
                    <scope line="236"/>
                    <scope line="240">
                        <declaration name="toFocus" type="Component" line="241"/>
                        <scope line="242"/>
                        <declaration name="tempLost" type="Component" line="245"/>
                        <scope line="246"/>
                        <scope line="249"/>
                        <scope line="252"/>
                        <scope line="255"/>
                    </scope>
                    <declaration name="realOppositeWindow" type="Window" line="259"/>
                    <scope line="260"/>
                </scope>
                <scope line="266">
                    <declaration name="we" type="WindowEvent" line="267"/>
                    <declaration name="oldActiveWindow" type="Window" line="268"/>
                    <declaration name="newActiveWindow" type="Window" line="269"/>
                    <scope line="270"/>
                    <scope line="273">
                        <declaration name="isEventDispatched" type="boolean" line="274"/>
                        <scope line="275"/>
                        <scope line="278"/>
                    </scope>
                    <scope line="283"/>
                </scope>
                <scope line="289">
                    <declaration name="fe" type="FocusEvent" line="290"/>
                    <declaration name="cause" type="CausedFocusEvent.Cause" line="291"/>
                    <declaration name="oldFocusOwner" type="Component" line="292"/>
                    <declaration name="newFocusOwner" type="Component" line="293"/>
                    <scope line="294">
                        <scope line="295"/>
                    </scope>
                    <scope line="301">
                        <declaration name="isEventDispatched" type="boolean" line="302"/>
                        <scope line="303">
                            <scope line="305"/>
                        </scope>
                    </scope>
                    <declaration name="newFocusedWindow" type="Window" line="310"/>
                    <declaration name="currentFocusedWindow" type="Window" line="311"/>
                    <scope line="312">
                        <scope line="314"/>
                    </scope>
                    <scope line="319">
                        <scope line="321">
                            <scope line="322"/>
                            <scope line="325"/>
                        </scope>
                    </scope>
                    <scope line="332">
                        <scope line="334"/>
                    </scope>
                    <scope line="339">
                        <scope line="341">
                            <scope line="343"/>
                        </scope>
                    </scope>
                    <declaration name="realOppositeComponent" type="Component" line="350"/>
                    <scope line="351"/>
                </scope>
                <scope line="358">
                    <declaration name="fe" type="FocusEvent" line="359"/>
                    <declaration name="currentFocusOwner" type="Component" line="360"/>
                    <scope line="361"/>
                    <scope line="365"/>
                    <scope line="370"/>
                    <scope line="374">
                        <scope line="376"/>
                    </scope>
                    <scope line="381">
                        <declaration name="owningWindow" type="Window" line="382"/>
                        <scope line="383"/>
                    </scope>
                </scope>
                <scope line="393">
                    <declaration name="we" type="WindowEvent" line="394"/>
                    <declaration name="currentActiveWindow" type="Window" line="395"/>
                    <scope line="396"/>
                    <scope line="399"/>
                    <scope line="403"/>
                </scope>
                <scope line="410">
                    <declaration name="we" type="WindowEvent" line="411"/>
                    <declaration name="currentFocusedWindow" type="Window" line="412"/>
                    <declaration name="losingFocusWindow" type="Window" line="413"/>
                    <declaration name="activeWindow" type="Window" line="414"/>
                    <declaration name="oppositeWindow" type="Window" line="415"/>
                    <scope line="417"/>
                    <scope line="420"/>
                    <declaration name="currentFocusOwner" type="Component" line="423"/>
                    <scope line="424">
                        <declaration name="oppositeComp" type="Component" line="425"/>
                        <scope line="426">
                            <scope line="428"/>
                        </scope>
                        <scope line="432"/>
                    </scope>
                    <scope line="438"/>
                    <scope line="445">
                        <scope line="447"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="462">
                Called by &lt;code&gt;dispatchEvent&lt;/code&gt; if no other
                  KeyEventDispatcher in the dispatcher chain dispatched the KeyEvent, or
                  if no other KeyEventDispatchers are registered. If the event has not
                  been consumed, its target is enabled, and the focus owner is not null,
                  this method dispatches the event to its target. This method will also
                  subsequently dispatch the event to all registered
                  KeyEventPostProcessors. After all this operations are finished,
                  the event is passed to peers for processing.
                  &lt;p&gt;
                  In all cases, this method returns &lt;code&gt;true&lt;/code&gt;, since
                  DefaultKeyboardFocusManager is designed so that neither
                  &lt;code&gt;dispatchEvent&lt;/code&gt;, nor the AWT event dispatcher, should take
                  further action on the event in any situation.                
                <param>
                    e the KeyEvent to be dispatched                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt;                    
                </return>
                <see>
                    Component#dispatchEvent                    
                </see>
            </javadoc>
            <method name="dispatchKeyEvent" type="boolean" line="480">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <declaration name="focusOwner" type="Component" line="481"/>
                <scope line="482">
                    <scope line="483">
                        <declaration name="comp" type="Component" line="484"/>
                        <scope line="485"/>
                    </scope>
                </scope>
                <declaration name="stopPostProcessing" type="boolean" line="490"/>
                <declaration name="processors" type="java.util.List" line="491"/>
                <scope line="492">
                    <scope line="493"/>
                </scope>
                <scope line="497"/>
                <declaration name="source" type="Component" line="500"/>
                <declaration name="peer" type="ComponentPeer" line="501"/>
                <scope line="502">
                    <declaration name="target" type="Container" line="503"/>
                    <scope line="504"/>
                </scope>
                <scope line="508"/>
            </method>
            <javadoc line="513">
                This method will be called by &lt;code&gt;dispatchKeyEvent&lt;/code&gt;. It will
                  handle any unconsumed KeyEvents that map to an AWT
                  &lt;code&gt;MenuShortcut&lt;/code&gt; by consuming the event and activating the
                  shortcut.                
                <param>
                    e the KeyEvent to post-process                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt;                    
                </return>
                <see>
                    #dispatchKeyEvent                    
                </see>
                <see>
                    MenuShortcut                    
                </see>
            </javadoc>
            <method name="postProcessKeyEvent" type="boolean" line="523">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <scope line="524">
                    <declaration name="target" type="Component" line="525"/>
                    <declaration name="p" type="Container" line="526"/>
                    <scope line="527"/>
                </scope>
            </method>
            <method name="pumpApprovedKeyEvents" type="void" line="533">
                <declaration name="ke" type="KeyEvent" line="534"/>
                <scope line="535">
                    <scope line="537">
                        <scope line="538">
                            <scope line="540">
                                <declaration name="marker" type="TypeAheadMarker" line="541"/>
                                <scope line="542"/>
                            </scope>
                            <scope line="546"/>
                        </scope>
                    </scope>
                    <scope line="552"/>
                </scope>
            </method>
            <javadoc line="558">
                Dumps the list of type-ahead queue markers to stderr                
            </javadoc>
            <method name="dumpMarkers" type="void" line="561">
                <scope line="562">
                    <scope line="564">
                        <scope line="565">
                            <declaration name="iter" type="Iterator" line="566"/>
                            <scope line="567">
                                <declaration name="marker" type="TypeAheadMarker" line="568"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="typeAheadAssertions" type="boolean" line="575">
                <params>
                    <param name="target" type="Component"/>
                    <param name="e" type="AWTEvent"/>
                </params>
                <scope line="581">
                    <declaration name="ke" type="KeyEvent" line="582"/>
                    <scope line="583">
                        <scope line="584">
                            <declaration name="marker" type="TypeAheadMarker" line="585"/>
                            <scope line="586"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="598">
                    <declaration name="found" type="boolean" line="599"/>
                    <scope line="600">
                        <scope line="601">
                            <scope line="602"/>
                            <scope line="605"/>
                        </scope>
                    </scope>
                    <scope line="611"/>
                </scope>
            </method>
            <javadoc line="625">
                Returns true if there are some marker associated with component &lt;code&gt;comp&lt;/code&gt;
                  in a markers&apos; queue                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hasMarker" type="boolean" line="630">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="631">
                    <scope line="632"/>
                </scope>
            </method>
            <javadoc line="638">
                Clears markers queue                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="clearMarkers" type="void" line="642">
                <scope line="643"/>
            </method>
            <method name="preDispatchKeyEvent" type="boolean" line="647">
                <params>
                    <param name="ke" type="KeyEvent"/>
                </params>
                <scope line="648">
                    <declaration name="focusOwner" type="Component" line="649"/>
                </scope>
                <scope line="652"/>
                <scope line="656">
                    <declaration name="source" type="Component" line="657"/>
                    <declaration name="target" type="Container" line="658"/>
                    <scope line="659">
                        <declaration name="peer" type="ComponentPeer" line="660"/>
                        <scope line="661"/>
                    </scope>
                </scope>
                <declaration name="dispatchers" type="java.util.List" line="668"/>
                <scope line="669">
                    <scope line="670">
                        <scope line="671"/>
                    </scope>
                </scope>
            </method>
            <method name="consumeNextKeyTyped" type="void" line="678">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
            </method>
            <method name="consumeTraversalKey" type="void" line="681">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
            </method>
            <method name="consumeProcessedKeyEvent" type="boolean" line="685">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <scope line="686"/>
            </method>
            <javadoc line="693">
                This method initiates a focus traversal operation if and only if the
                  KeyEvent represents a focus traversal key for the specified
                  focusedComponent. It is expected that focusedComponent is the current
                  focus owner, although this need not be the case. If it is not,
                  focus traversal will nevertheless proceed as if focusedComponent
                  were the focus owner.                
                <param>
                    focusedComponent the Component that is the basis for a focus
                      traversal operation if the specified event represents a focus
                      traversal key for the Component                    
                </param>
                <param>
                    e the event that may represent a focus traversal key                    
                </param>
            </javadoc>
            <method name="processKeyEvent" type="void" line="705">
                <params>
                    <param name="focusedComponent" type="Component"/>
                    <param name="e" type="KeyEvent"/>
                </params>
                <scope line="706"/>
                <scope line="709"/>
                <scope line="712">
                    <declaration name="stroke" type="AWTKeyStroke" line="713"/>
                    <declaration name="toTest" type="Set" line="714"/>
                    <declaration name="contains" type="boolean" line="715"/>
                    <scope line="719">
                        <scope line="721"/>
                    </scope>
                    <scope line="726"/>
                    <scope line="732">
                        <scope line="734"/>
                    </scope>
                    <scope line="742">
                        <scope line="744"/>
                    </scope>
                    <scope line="749"/>
                    <scope line="755">
                        <scope line="757"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="763">
                Delays dispatching of KeyEvents until the specified Component becomes
                  the focus owner. KeyEvents with timestamps later than the specified
                  timestamp will be enqueued until the specified Component receives a
                  FOCUS_GAINED event, or the AWT cancels the delay request by invoking
                  &lt;code&gt;dequeueKeyEvents&lt;/code&gt; or &lt;code&gt;discardKeyEvents&lt;/code&gt;.                
                <param>
                    after timestamp of current event, or the current, system time if
                      the current event has no timestamp, or the AWT cannot determine
                      which event is currently being handled                    
                </param>
                <param>
                    untilFocused Component which will receive a FOCUS_GAINED event
                      before any pending KeyEvents                    
                </param>
                <see>
                    #dequeueKeyEvents                    
                </see>
                <see>
                    #discardKeyEvents                    
                </see>
            </javadoc>
            <method name="enqueueKeyEvents" type="void" line="777">
                <params>
                    <param name="after" type="long"/>
                    <param name="untilFocused" type="Component"/>
                </params>
                <scope line="778"/>
                <declaration name="insertionIndex" type="int" line="782"/>
                <declaration name="iter" type="ListIterator" line="783"/>
                <scope line="784">
                    <declaration name="marker" type="TypeAheadMarker" line="785"/>
                    <scope line="786"/>
                </scope>
            </method>
            <javadoc line="793">
                Releases for normal dispatching to the current focus owner all
                  KeyEvents which were enqueued because of a call to
                  &lt;code&gt;enqueueKeyEvents&lt;/code&gt; with the same timestamp and Component.
                  If the given timestamp is less than zero, the outstanding enqueue
                  request for the given Component with the &lt;b&gt;oldest&lt;/b&gt; timestamp (if
                  any) should be cancelled.                
                <param>
                    after the timestamp specified in the call to
                      &lt;code&gt;enqueueKeyEvents&lt;/code&gt;, or any value &lt; 0                    
                </param>
                <param>
                    untilFocused the Component specified in the call to
                      &lt;code&gt;enqueueKeyEvents&lt;/code&gt;                    
                </param>
                <see>
                    #enqueueKeyEvents                    
                </see>
                <see>
                    #discardKeyEvents                    
                </see>
            </javadoc>
            <method name="dequeueKeyEvents" type="void" line="807">
                <params>
                    <param name="after" type="long"/>
                    <param name="untilFocused" type="Component"/>
                </params>
                <scope line="808"/>
                <declaration name="marker" type="TypeAheadMarker" line="812"/>
                <declaration name="iter" type="ListIterator" line="813"/>
                <scope line="814">
                    <scope line="815">
                        <scope line="817"/>
                    </scope>
                </scope>
                <scope line="823">
                    <scope line="824">
                        <scope line="826"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="833">
                Discards all KeyEvents which were enqueued because of one or more calls
                  to &lt;code&gt;enqueueKeyEvents&lt;/code&gt; with the specified Component, or one of
                  its descendants.                
                <param>
                    comp the Component specified in one or more calls to
                      &lt;code&gt;enqueueKeyEvents&lt;/code&gt;, or a parent of such a Component                    
                </param>
                <see>
                    #enqueueKeyEvents                    
                </see>
                <see>
                    #dequeueKeyEvents                    
                </see>
            </javadoc>
            <method name="discardKeyEvents" type="void" line="842">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="843"/>
                <declaration name="start" type="long" line="846"/>
                <scope line="847">
                    <declaration name="marker" type="TypeAheadMarker" line="848"/>
                    <declaration name="toTest" type="Component" line="849"/>
                    <declaration name="match" type="boolean" line="850"/>
                    <scope line="851"/>
                    <scope line="855">
                        <scope line="856"/>
                    </scope>
                    <scope line="861"/>
                </scope>
            </method>
            <method name="purgeStampedEvents" type="void" line="868">
                <params>
                    <param name="start" type="long"/>
                    <param name="end" type="long"/>
                </params>
                <scope line="869"/>
                <scope line="872">
                    <declaration name="ke" type="KeyEvent" line="873"/>
                    <declaration name="time" type="long" line="874"/>
                    <scope line="875"/>
                    <scope line="878"/>
                </scope>
            </method>
            <javadoc line="883">
                Focuses the Component before aComponent, typically based on a
                  FocusTraversalPolicy.                
                <param>
                    aComponent the Component that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    FocusTraversalPolicy                    
                </see>
                <see>
                    Component#transferFocusBackward                    
                </see>
            </javadoc>
            <method name="focusPreviousComponent" type="void" line="891">
                <params>
                    <param name="aComponent" type="Component"/>
                </params>
                <scope line="892"/>
            </method>
            <javadoc line="896">
                Focuses the Component after aComponent, typically based on a
                  FocusTraversalPolicy.                
                <param>
                    aComponent the Component that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    FocusTraversalPolicy                    
                </see>
                <see>
                    Component#transferFocus                    
                </see>
            </javadoc>
            <method name="focusNextComponent" type="void" line="904">
                <params>
                    <param name="aComponent" type="Component"/>
                </params>
                <scope line="905"/>
            </method>
            <javadoc line="909">
                Moves the focus up one focus traversal cycle. Typically, the focus owner
                  is set to aComponent&apos;s focus cycle root, and the current focus cycle
                  root is set to the new focus owner&apos;s focus cycle root. If, however,
                  aComponent&apos;s focus cycle root is a Window, then the focus owner is set
                  to the focus cycle root&apos;s default Component to focus, and the current
                  focus cycle root is unchanged.                
                <param>
                    aComponent the Component that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    Component#transferFocusUpCycle                    
                </see>
            </javadoc>
            <method name="upFocusCycle" type="void" line="920">
                <params>
                    <param name="aComponent" type="Component"/>
                </params>
                <scope line="921"/>
            </method>
            <javadoc line="925">
                Moves the focus down one focus traversal cycle. If aContainer is a focus
                  cycle root, then the focus owner is set to aContainer&apos;s default
                  Component to focus, and the current focus cycle root is set to
                  aContainer. If aContainer is not a focus cycle root, then no focus
                  traversal operation occurs.                
                <param>
                    aContainer the Container that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    Container#transferFocusDownCycle                    
                </see>
            </javadoc>
            <method name="downFocusCycle" type="void" line="935">
                <params>
                    <param name="aContainer" type="Container"/>
                </params>
                <scope line="936"/>
            </method>
        </class>
    </source>