<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.awt">
        <import package="java.awt.event.FocusEvent"/>
        <import package="java.awt.event.KeyEvent"/>
        <import package="java.awt.event.WindowEvent"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.peer.LightweightPeer"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.util.LinkedList"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.ListIterator"/>
        <import package="java.util.Set"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.CausedFocusEvent"/>
        <class name="DefaultKeyboardFocusManager" line="44">
            <extends class="KeyboardFocusManager"/>
            <comment line="67">
                null weak references to not create too many objects                
            </comment>
            <comment line="103">
                This series of restoreFocus methods is used for recovering from a
                 rejected focus or activation change. Rejections typically occur when
                 the user attempts to focus a non-focusable Component or Window.                
            </comment>
            <comment line="1021">
                @param e is a KEY_PRESSED event that can be used
                          to track the next KEY_TYPED related.                
            </comment>
            <comment line="1035">
                return true if event was consumed                
            </comment>
            <comment line="1271">
                Notes:                
            </comment>
            <comment line="1272">
                * must be called inside a synchronized block                
            </comment>
            <comment line="1273">
                * if &apos;start&apos; is &lt; 0, then this function does nothing                
            </comment>
            <comment line="1274">
                * if &apos;end&apos; is &lt; 0, then all KeyEvents from &apos;start&apos; to the end of the                
            </comment>
            <comment line="1275">
                queue will be removed                
            </comment>
            <javadoc line="44">
                The default KeyboardFocusManager for AWT applications. Focus traversal is
                  done in response to a Component&apos;s focus traversal keys, and using a
                  Container&apos;s FocusTraversalPolicy.
                  &lt;p&gt;
                  Please see
                  &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;&gt;
                  How to Use the Focus Subsystem&lt;/a&gt;,
                  a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, and the
                  &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
                  for more information.                
                <author>
                    David Mendenhall                    
                </author>
                <see>
                    FocusTraversalPolicy                    
                </see>
                <see>
                    Component#setFocusTraversalKeys                    
                </see>
                <see>
                    Component#getFocusTraversalKeys                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="focusLog" type="PlatformLogger" line="64"/>
            <declaration name="NULL_WINDOW_WR" type="WeakReference&lt;Window&gt;" line="67"/>
            <declaration name="NULL_COMPONENT_WR" type="WeakReference&lt;Component&gt;" line="69"/>
            <declaration name="realOppositeWindowWR" type="WeakReference&lt;Window&gt;" line="71"/>
            <declaration name="realOppositeComponentWR" type="WeakReference&lt;Component&gt;" line="72"/>
            <declaration name="inSendMessage" type="int" line="73"/>
            <declaration name="enqueuedKeyEvents" type="LinkedList" line="74"/>
            <declaration name="consumeNextKeyTyped" type="boolean" line="76"/>
            <class name="TypeAheadMarker" line="78">
                <comment line="184">
                    serialVersionUID                    
                </comment>
                <declaration name="after" type="long" line="79"/>
                <declaration name="untilFocused" type="Component" line="80"/>
                <method name="TypeAheadMarker" type="constructor" line="82">
                    <params>
                        <param name="after" type="long"/>
                        <param name="untilFocused" type="Component"/>
                    </params>
                </method>
                <javadoc line="86">
                    Returns string representation of the marker                    
                </javadoc>
                <method name="toString" type="String" line="89"/>
            </class>
            <method name="getOwningFrameDialog" type="Window" line="94">
                <params>
                    <param name="window" type="Window"/>
                </params>
                <scope line="96"/>
            </method>
            <method name="restoreFocus" type="void" line="107">
                <params>
                    <param name="fe" type="FocusEvent"/>
                    <param name="newFocusedWindow" type="Window"/>
                </params>
                <declaration name="realOppositeComponent" type="Component" line="108"/>
                <declaration name="vetoedComponent" type="Component" line="109"/>
                <scope line="113"/>
                <scope line="115"/>
                <scope line="117"/>
                <scope line="118"/>
            </method>
            <method name="restoreFocus" type="void" line="122">
                <params>
                    <param name="we" type="WindowEvent"/>
                </params>
                <comment line="127">
                    do nothing, everything is done in restoreFocus()                    
                </comment>
                <comment line="131">
                    do nothing, everything is done in restoreFocus()                    
                </comment>
                <declaration name="realOppositeWindow" type="Window" line="123"/>
                <scope line="126"/>
                <scope line="130"/>
                <scope line="132"/>
            </method>
            <method name="restoreFocus" type="boolean" line="137">
                <params>
                    <param name="aWindow" type="Window"/>
                    <param name="vetoedComponent" type="Component"/>
                    <param name="clearOnFailure" type="boolean"/>
                </params>
                <declaration name="toFocus" type="Component" line="138"/>
                <scope line="141"/>
                <scope line="143"/>
                <scope line="146"/>
            </method>
            <method name="restoreFocus" type="boolean" line="150">
                <params>
                    <param name="toFocus" type="Component"/>
                    <param name="clearOnFailure" type="boolean"/>
                </params>
            </method>
            <method name="doRestoreFocus" type="boolean" line="155">
                <params>
                    <param name="toFocus" type="Component"/>
                    <param name="vetoedComponent" type="Component"/>
                    <param name="clearOnFailure" type="boolean"/>
                </params>
                <scope line="158"/>
                <scope line="160">
                    <declaration name="nextFocus" type="Component" line="161"/>
                    <scope line="164"/>
                    <scope line="166"/>
                    <scope line="169"/>
                </scope>
            </method>
            <class name="DefaultKeyboardFocusManagerSentEvent" line="175">
                <extends class="SentEvent"/>
                <comment line="184">
                    serialVersionUID                    
                </comment>
                <javadoc line="175">
                    A special type of SentEvent which updates a counter in the target
                      KeyboardFocusManager if it is an instance of
                      DefaultKeyboardFocusManager.                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="186"/>
                <method name="DefaultKeyboardFocusManagerSentEvent" type="constructor" line="189">
                    <params>
                        <param name="nested" type="AWTEvent"/>
                        <param name="toNotify" type="AppContext"/>
                    </params>
                </method>
                <method name="dispatch" type="void" line="192">
                    <declaration name="manager" type="KeyboardFocusManager" line="193"/>
                    <declaration name="defaultManager" type="DefaultKeyboardFocusManager" line="195"/>
                    <scope line="200">
                        <scope line="201"/>
                    </scope>
                    <scope line="208">
                        <scope line="209"/>
                    </scope>
                </method>
            </class>
            <javadoc line="216">
                Sends a synthetic AWTEvent to a Component. If the Component is in
                  the current AppContext, then the event is immediately dispatched.
                  If the Component is in a different AppContext, then the event is
                  posted to the other AppContext&apos;s EventQueue, and this method blocks
                  until the event is handled or target AppContext is disposed.
                  Returns true if successfuly dispatched event, false if failed
                  to dispatch.                
            </javadoc>
            <method name="sendMessage" type="boolean" line="225">
                <params>
                    <param name="target" type="Component"/>
                    <param name="e" type="AWTEvent"/>
                </params>
                <declaration name="myAppContext" type="AppContext" line="227"/>
                <declaration name="targetAppContext" type="AppContext" line="228"/>
                <declaration name="se" type="SentEvent" line="229"/>
                <scope line="232"/>
                <scope line="234">
                    <scope line="235"/>
                    <scope line="239">
                        <declaration name="edt" type="EventDispatchThread" line="240"/>
                        <anonymous_class line="242">
                            <method name="evaluate" type="boolean" line="243"/>
                        </anonymous_class>
                    </scope>
                    <scope line="247">
                        <scope line="248">
                            <scope line="249">
                                <scope line="250"/>
                                <scope line="252"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="262">
                This method is called by the AWT event dispatcher requesting that the
                  current KeyboardFocusManager dispatch the specified event on its behalf.
                  DefaultKeyboardFocusManagers dispatch all FocusEvents, all WindowEvents
                  related to focus, and all KeyEvents. These events are dispatched based
                  on the KeyboardFocusManager&apos;s notion of the focus owner and the focused
                  and active Windows, sometimes overriding the source of the specified
                  AWTEvent. If this method returns &lt;code&gt;false&lt;/code&gt;, then the AWT event
                  dispatcher will attempt to dispatch the event itself.                
                <param>
                    e the AWTEvent to be dispatched                    
                </param>
                <return>
                    <code>true</code> if this method dispatched the event;
                      <code>false</code> otherwise                    
                </return>
            </javadoc>
            <method name="dispatchEvent" type="boolean" line="276">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <comment line="291">
                    we can not accept focus on such window, so reject it.                    
                </comment>
                <comment line="295">
                    If there exists a current focused window, then notify it                    
                </comment>
                <comment line="296">
                    that it has lost focus.                    
                </comment>
                <comment line="303">
                    Failed to dispatch, clear by ourselfves                    
                </comment>
                <comment line="310">
                    Because the native libraries do not post WINDOW_ACTIVATED                    
                </comment>
                <comment line="311">
                    events, we need to synthesize one if the active Window                    
                </comment>
                <comment line="312">
                    changed.                    
                </comment>
                <comment line="322">
                    Activation change was rejected. Unlikely, but                    
                </comment>
                <comment line="323">
                    possible.                    
                </comment>
                <comment line="332">
                    Focus change was rejected. Will happen if                    
                </comment>
                <comment line="333">
                    newFocusedWindow is not a focusable Window.                    
                </comment>
                <comment line="338">
                    Restore focus to the Component which last held it. We do                    
                </comment>
                <comment line="339">
                    this here so that client code can override our choice in                    
                </comment>
                <comment line="340">
                    a WINDOW_GAINED_FOCUS handler.                    
                </comment>
                <comment line="341">
                                        
                </comment>
                <comment line="342">
                    Make sure that the focus change request doesn&apos;t change the                    
                </comment>
                <comment line="343">
                    focused Window in case we are no longer the focused Window                    
                </comment>
                <comment line="344">
                    when the request is handled.                    
                </comment>
                <comment line="346">
                    Identify which Component should initially gain focus                    
                </comment>
                <comment line="347">
                    in the Window.                    
                </comment>
                <comment line="348">
                                        
                </comment>
                <comment line="349">
                    * If we&apos;re in SendMessage, then this is a synthetic                    
                </comment>
                <comment line="350">
                    WINDOW_GAINED_FOCUS message which was generated by a                    
                </comment>
                <comment line="351">
                    the FOCUS_GAINED handler. Allow the Component to                    
                </comment>
                <comment line="352">
                    which the FOCUS_GAINED message was targeted to                    
                </comment>
                <comment line="353">
                    receive the focus.                    
                </comment>
                <comment line="354">
                    * Otherwise, look up the correct Component here.                    
                </comment>
                <comment line="355">
                    We don&apos;t use Window.getMostRecentFocusOwner because                    
                </comment>
                <comment line="356">
                    window is focused now and &apos;null&apos; will be returned                    
                </comment>
                <comment line="359">
                    Calculating of most recent focus owner and focus                    
                </comment>
                <comment line="360">
                    request should be synchronized on KeyboardFocusManager.class                    
                </comment>
                <comment line="361">
                    to prevent from thread race when user will request                    
                </comment>
                <comment line="362">
                    focus between calculation and our request.                    
                </comment>
                <comment line="363">
                    But if focus transfer is synchronous, this synchronization                    
                </comment>
                <comment line="364">
                    may cause deadlock, thus we don&apos;t synchronize this block.                    
                </comment>
                <comment line="378">
                    The component which last has the focus when this window was focused                    
                </comment>
                <comment line="379">
                    should receive focus first                    
                </comment>
                <comment line="389">
                    If there is a component which requested focus when this window                    
                </comment>
                <comment line="390">
                    was inactive it expects to receive focus after activation.                    
                </comment>
                <comment line="412">
                    If there exists a current active window, then notify it that                    
                </comment>
                <comment line="413">
                    it has lost activation.                    
                </comment>
                <comment line="420">
                    Failed to dispatch, clear by ourselfves                    
                </comment>
                <comment line="425">
                    Activation change was rejected. Unlikely, but                    
                </comment>
                <comment line="426">
                    possible.                    
                </comment>
                <comment line="434">
                    Activation change was rejected. Unlikely, but                    
                </comment>
                <comment line="435">
                    possible.                    
                </comment>
                <comment line="452">
                    We can&apos;t just drop the event - there could be                    
                </comment>
                <comment line="453">
                    type-ahead markers associated with it.                    
                </comment>
                <comment line="458">
                    If there exists a current focus owner, then notify it that                    
                </comment>
                <comment line="459">
                    it has lost focus.                    
                </comment>
                <comment line="467">
                    Failed to dispatch, clear by ourselfves                    
                </comment>
                <comment line="476">
                    Because the native windowing system has a different notion                    
                </comment>
                <comment line="477">
                    of the current focus and activation states, it is possible                    
                </comment>
                <comment line="478">
                    that a Component outside of the focused Window receives a                    
                </comment>
                <comment line="479">
                    FOCUS_GAINED event. We synthesize a WINDOW_GAINED_FOCUS                    
                </comment>
                <comment line="480">
                    event in that case.                    
                </comment>
                <comment line="491">
                    Focus change was rejected. Will happen if                    
                </comment>
                <comment line="492">
                    newFocusedWindow is not a focusable Window.                    
                </comment>
                <comment line="494">
                    Need to recover type-ahead, but don&apos;t bother                    
                </comment>
                <comment line="495">
                    restoring focus. That was done by the                    
                </comment>
                <comment line="496">
                    WINDOW_GAINED_FOCUS handler                    
                </comment>
                <comment line="503">
                    Refuse focus on a disabled component if the focus event                    
                </comment>
                <comment line="504">
                    isn&apos;t of UNKNOWN reason (i.e. not a result of a direct request                    
                </comment>
                <comment line="505">
                    but traversal, activation or system generated).                    
                </comment>
                <comment line="508">
                    we should not accept focus on such component, so reject it.                    
                </comment>
                <comment line="511">
                    If FOCUS_GAINED is for a disposed component (however                    
                </comment>
                <comment line="512">
                    it shouldn&apos;t happen) its toplevel parent is null. In this                    
                </comment>
                <comment line="513">
                    case we have to try to restore focus in the current focused                    
                </comment>
                <comment line="514">
                    window (for the details: 6607170).                    
                </comment>
                <comment line="527">
                    Focus change was rejected. Will happen if                    
                </comment>
                <comment line="528">
                    newFocusOwner is not focus traversable.                    
                </comment>
                <comment line="540">
                    Focus change was rejected. Unlikely, but possible.                    
                </comment>
                <comment line="571">
                    Ignore cases where a Component loses focus to itself.                    
                </comment>
                <comment line="572">
                    If we make a mistake because of retargeting, then the                    
                </comment>
                <comment line="573">
                    FOCUS_GAINED handler will correct it.                    
                </comment>
                <comment line="583">
                    Focus change was rejected. Unlikely, but possible.                    
                </comment>
                <comment line="592">
                    Focus change was rejected. Unlikely, but possible.                    
                </comment>
                <comment line="622">
                    The event is lost in time.                    
                </comment>
                <comment line="623">
                    Allow listeners to precess the event but do not                    
                </comment>
                <comment line="624">
                    change any global states                    
                </comment>
                <comment line="630">
                    Activation change was rejected. Unlikely, but possible.                    
                </comment>
                <comment line="652">
                    Special case -- if the native windowing system posts an                    
                </comment>
                <comment line="653">
                    event claiming that the active Window has lost focus to the                    
                </comment>
                <comment line="654">
                    focused Window, then discard the event. This is an artifact                    
                </comment>
                <comment line="655">
                    of the native windowing system not knowing which Window is                    
                </comment>
                <comment line="656">
                    really focused.                    
                </comment>
                <comment line="665">
                    The focus owner should always receive a FOCUS_LOST event                    
                </comment>
                <comment line="666">
                    before the Window is defocused.                    
                </comment>
                <comment line="686">
                    Focus change was rejected. Unlikely, but possible.                    
                </comment>
                <comment line="698">
                    Then we need to deactive the active Window as well.                    
                </comment>
                <comment line="699">
                    No need to synthesize in other cases, because                    
                </comment>
                <comment line="700">
                    WINDOW_ACTIVATED will handle it if necessary.                    
                </comment>
                <comment line="706">
                    Activation change was rejected. Unlikely,                    
                </comment>
                <comment line="707">
                    but possible.                    
                </comment>
                <scope line="279">
                    <declaration name="we" type="WindowEvent" line="280"/>
                    <declaration name="oldFocusedWindow" type="Window" line="281"/>
                    <declaration name="newFocusedWindow" type="Window" line="282"/>
                    <scope line="283"/>
                    <scope line="290"/>
                    <scope line="297">
                        <declaration name="isEventDispatched" type="boolean" line="298"/>
                        <scope line="304"/>
                    </scope>
                    <declaration name="newActiveWindow" type="Window" line="313"/>
                    <declaration name="currentActiveWindow" type="Window" line="315"/>
                    <scope line="316">
                        <scope line="321"/>
                    </scope>
                    <scope line="331"/>
                    <scope line="345">
                        <declaration name="toFocus" type="Component" line="365"/>
                        <scope line="369"/>
                        <declaration name="tempLost" type="Component" line="373"/>
                        <scope line="374"/>
                        <scope line="380"/>
                        <scope line="384"/>
                        <scope line="388"/>
                    </scope>
                    <declaration name="realOppositeWindow" type="Window" line="395"/>
                    <scope line="396"/>
                </scope>
                <scope line="404">
                    <declaration name="we" type="WindowEvent" line="405"/>
                    <declaration name="oldActiveWindow" type="Window" line="406"/>
                    <declaration name="newActiveWindow" type="Window" line="407"/>
                    <scope line="408"/>
                    <scope line="414">
                        <declaration name="isEventDispatched" type="boolean" line="415"/>
                        <scope line="421"/>
                        <scope line="424"/>
                    </scope>
                    <scope line="433"/>
                </scope>
                <scope line="442">
                    <declaration name="fe" type="FocusEvent" line="443"/>
                    <declaration name="cause" type="CausedFocusEvent.Cause" line="444"/>
                    <declaration name="oldFocusOwner" type="Component" line="446"/>
                    <declaration name="newFocusOwner" type="Component" line="447"/>
                    <scope line="448">
                        <scope line="449"/>
                    </scope>
                    <scope line="460">
                        <declaration name="isEventDispatched" type="boolean" line="461"/>
                        <scope line="468">
                            <scope line="470"/>
                        </scope>
                    </scope>
                    <declaration name="newFocusedWindow" type="Window" line="481"/>
                    <declaration name="currentFocusedWindow" type="Window" line="482"/>
                    <scope line="485">
                        <scope line="490"/>
                    </scope>
                    <scope line="507">
                        <scope line="510">
                            <scope line="515"/>
                            <scope line="517"/>
                        </scope>
                    </scope>
                    <scope line="526">
                        <scope line="530"/>
                    </scope>
                    <scope line="536">
                        <scope line="539">
                            <scope line="542"/>
                        </scope>
                    </scope>
                    <declaration name="realOppositeComponent" type="Component" line="551"/>
                    <scope line="553"/>
                </scope>
                <scope line="563">
                    <declaration name="fe" type="FocusEvent" line="564"/>
                    <declaration name="currentFocusOwner" type="Component" line="565"/>
                    <scope line="566"/>
                    <scope line="574"/>
                    <scope line="582"/>
                    <scope line="588">
                        <scope line="591"/>
                    </scope>
                    <scope line="596">
                        <declaration name="owningWindow" type="Window" line="597"/>
                        <scope line="598"/>
                    </scope>
                </scope>
                <scope line="614">
                    <declaration name="we" type="WindowEvent" line="615"/>
                    <declaration name="currentActiveWindow" type="Window" line="616"/>
                    <scope line="617"/>
                    <scope line="621"/>
                    <scope line="629"/>
                </scope>
                <scope line="638">
                    <declaration name="we" type="WindowEvent" line="639"/>
                    <declaration name="currentFocusedWindow" type="Window" line="640"/>
                    <declaration name="losingFocusWindow" type="Window" line="641"/>
                    <declaration name="activeWindow" type="Window" line="642"/>
                    <declaration name="oppositeWindow" type="Window" line="643"/>
                    <scope line="648"/>
                    <scope line="659"/>
                    <declaration name="currentFocusOwner" type="Component" line="663"/>
                    <scope line="664">
                        <declaration name="oppositeComp" type="Component" line="667"/>
                        <scope line="668">
                            <scope line="670"/>
                        </scope>
                        <scope line="674"/>
                    </scope>
                    <scope line="685"/>
                    <scope line="697">
                        <scope line="705"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="726">
                Called by &lt;code&gt;dispatchEvent&lt;/code&gt; if no other
                  KeyEventDispatcher in the dispatcher chain dispatched the KeyEvent, or
                  if no other KeyEventDispatchers are registered. If the event has not
                  been consumed, its target is enabled, and the focus owner is not null,
                  this method dispatches the event to its target. This method will also
                  subsequently dispatch the event to all registered
                  KeyEventPostProcessors. After all this operations are finished,
                  the event is passed to peers for processing.
                  &lt;p&gt;
                  In all cases, this method returns &lt;code&gt;true&lt;/code&gt;, since
                  DefaultKeyboardFocusManager is designed so that neither
                  &lt;code&gt;dispatchEvent&lt;/code&gt;, nor the AWT event dispatcher, should take
                  further action on the event in any situation.                
                <param>
                    e the KeyEvent to be dispatched                    
                </param>
                <return>
                    <code>true</code>                    
                </return>
                <see>
                    Component#dispatchEvent                    
                </see>
            </javadoc>
            <method name="dispatchKeyEvent" type="boolean" line="745">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <comment line="770">
                    Allow the peer to process KeyEvent                    
                </comment>
                <comment line="775">
                    if focus owner is lightweight then its native container                    
                </comment>
                <comment line="776">
                    processes event                    
                </comment>
                <declaration name="focusOwner" type="Component" line="746"/>
                <scope line="748">
                    <scope line="749">
                        <declaration name="comp" type="Component" line="750"/>
                        <scope line="751"/>
                    </scope>
                </scope>
                <declaration name="stopPostProcessing" type="boolean" line="756"/>
                <declaration name="processors" type="java.util.List" line="757"/>
                <scope line="758">
                    <scope line="761"/>
                </scope>
                <scope line="766"/>
                <declaration name="source" type="Component" line="771"/>
                <declaration name="peer" type="ComponentPeer" line="772"/>
                <scope line="774">
                    <declaration name="target" type="Container" line="777"/>
                    <scope line="778"/>
                </scope>
                <scope line="782"/>
            </method>
            <javadoc line="789">
                This method will be called by &lt;code&gt;dispatchKeyEvent&lt;/code&gt;. It will
                  handle any unconsumed KeyEvents that map to an AWT
                  &lt;code&gt;MenuShortcut&lt;/code&gt; by consuming the event and activating the
                  shortcut.                
                <param>
                    e the KeyEvent to post-process                    
                </param>
                <return>
                    <code>true</code>                    
                </return>
                <see>
                    #dispatchKeyEvent                    
                </see>
                <see>
                    MenuShortcut                    
                </see>
            </javadoc>
            <method name="postProcessKeyEvent" type="boolean" line="800">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <scope line="801">
                    <declaration name="target" type="Component" line="802"/>
                    <declaration name="p" type="Container" line="803"/>
                    <scope line="805"/>
                </scope>
            </method>
            <method name="pumpApprovedKeyEvents" type="void" line="812">
                <comment line="822">
                    Fixed 5064013: may appears that the events have the same time                    
                </comment>
                <comment line="823">
                    if (ke.getWhen() &gt;= marker.after) {                    
                </comment>
                <comment line="824">
                    The fix is rolled out.                    
                </comment>
                <declaration name="ke" type="KeyEvent" line="813"/>
                <scope line="814">
                    <scope line="816">
                        <scope line="817">
                            <scope line="819">
                                <declaration name="marker" type="TypeAheadMarker" line="820"/>
                                <scope line="826"/>
                            </scope>
                            <scope line="830"/>
                        </scope>
                    </scope>
                    <scope line="836"/>
                </scope>
            </method>
            <javadoc line="842">
                Dumps the list of type-ahead queue markers to stderr                
            </javadoc>
            <method name="dumpMarkers" type="void" line="845">
                <scope line="846">
                    <scope line="848">
                        <scope line="849">
                            <declaration name="iter" type="Iterator" line="850"/>
                            <scope line="851">
                                <declaration name="marker" type="TypeAheadMarker" line="852"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="typeAheadAssertions" type="boolean" line="860">
                <params>
                    <param name="target" type="Component"/>
                    <param name="e" type="AWTEvent"/>
                </params>
                <comment line="862">
                    Clear any pending events here as well as in the FOCUS_GAINED                    
                </comment>
                <comment line="863">
                    handler. We need this call here in case a marker was removed in                    
                </comment>
                <comment line="864">
                    response to a call to dequeueKeyEvents.                    
                </comment>
                <comment line="876">
                    Fixed 5064013: may appears that the events have the same time                    
                </comment>
                <comment line="877">
                    if (ke.getWhen() &gt;= marker.after) {                    
                </comment>
                <comment line="878">
                    The fix is rolled out.                    
                </comment>
                <comment line="888">
                    KeyEvent was posted before focus change request                    
                </comment>
                <comment line="895">
                    Search the marker list for the first marker tied to                    
                </comment>
                <comment line="896">
                    the Component which just gained focus. Then remove                    
                </comment>
                <comment line="897">
                    that marker, any markers which immediately follow                    
                </comment>
                <comment line="898">
                    and are tied to the same component, and all markers                    
                </comment>
                <comment line="899">
                    that preceed it. This handles the case where                    
                </comment>
                <comment line="900">
                    multiple focus requests were made for the same                    
                </comment>
                <comment line="901">
                    Component in a row and when we lost some of the                    
                </comment>
                <comment line="902">
                    earlier requests. Since FOCUS_GAINED events will                    
                </comment>
                <comment line="903">
                    not be generated for these additional requests, we                    
                </comment>
                <comment line="904">
                    need to clear those markers too.                    
                </comment>
                <comment line="921">
                    Exception condition - event without marker                    
                </comment>
                <comment line="930">
                    Now, dispatch any pending KeyEvents which have been                    
                </comment>
                <comment line="931">
                    released because of the FOCUS_GAINED event so that we don&apos;t                    
                </comment>
                <comment line="932">
                    have to wait for another event to be posted to the queue.                    
                </comment>
                <scope line="870">
                    <declaration name="ke" type="KeyEvent" line="871"/>
                    <scope line="872">
                        <scope line="873">
                            <declaration name="marker" type="TypeAheadMarker" line="874"/>
                            <scope line="880"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="905">
                    <declaration name="found" type="boolean" line="906"/>
                    <scope line="907">
                        <scope line="910">
                            <scope line="913"/>
                            <scope line="915"/>
                        </scope>
                    </scope>
                    <scope line="920"/>
                </scope>
            </method>
            <javadoc line="942">
                Returns true if there are some marker associated with component &lt;code&gt;comp&lt;/code&gt;
                  in a markers&apos; queue                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hasMarker" type="boolean" line="947">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="948">
                    <scope line="949"/>
                </scope>
            </method>
            <javadoc line="956">
                Clears markers queue                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="clearMarkers" type="void" line="960">
                <scope line="961"/>
            </method>
            <method name="preDispatchKeyEvent" type="boolean" line="966">
                <params>
                    <param name="ke" type="KeyEvent"/>
                </params>
                <comment line="975">
                    Explicitly set the current event and most recent timestamp here in                    
                </comment>
                <comment line="976">
                    addition to the call in Component.dispatchEventImpl. Because                    
                </comment>
                <comment line="977">
                    KeyEvents can be delivered in response to a FOCUS_GAINED event, the                    
                </comment>
                <comment line="978">
                    current timestamp may be incorrect. We need to set it here so that                    
                </comment>
                <comment line="979">
                    KeyEventDispatchers will use the correct time.                    
                </comment>
                <comment line="982">
                    Fix for 4495473.
                     This fix allows to correctly dispatch events when native
                     event proxying mechanism is active.
                     If it is active we should redispatch key events after
                     we detected its correct target.                    
                </comment>
                <comment line="996">
                    Fix for 4478780 - consume event after it was dispatched by peer.                    
                </comment>
                <scope line="967">
                    <declaration name="focusOwner" type="Component" line="968"/>
                </scope>
                <scope line="971"/>
                <scope line="989">
                    <declaration name="source" type="Component" line="990"/>
                    <declaration name="target" type="Container" line="991"/>
                    <scope line="992">
                        <declaration name="peer" type="ComponentPeer" line="993"/>
                        <scope line="994"/>
                    </scope>
                </scope>
                <declaration name="dispatchers" type="java.util.List" line="1005"/>
                <scope line="1006">
                    <scope line="1009">
                        <scope line="1012"/>
                    </scope>
                </scope>
            </method>
            <method name="consumeNextKeyTyped" type="void" line="1024">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
            </method>
            <method name="consumeTraversalKey" type="void" line="1028">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
            </method>
            <method name="consumeProcessedKeyEvent" type="boolean" line="1037">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <scope line="1038"/>
            </method>
            <javadoc line="1046">
                This method initiates a focus traversal operation if and only if the
                  KeyEvent represents a focus traversal key for the specified
                  focusedComponent. It is expected that focusedComponent is the current
                  focus owner, although this need not be the case. If it is not,
                  focus traversal will nevertheless proceed as if focusedComponent
                  were the focus owner.                
                <param>
                    focusedComponent the Component that is the basis for a focus
                      traversal operation if the specified event represents a focus
                      traversal key for the Component                    
                </param>
                <param>
                    e the event that may represent a focus traversal key                    
                </param>
            </javadoc>
            <method name="processKeyEvent" type="void" line="1059">
                <params>
                    <param name="focusedComponent" type="Component"/>
                    <param name="e" type="KeyEvent"/>
                </params>
                <comment line="1060">
                    consume processed event if needed                    
                </comment>
                <comment line="1065">
                    KEY_TYPED events cannot be focus traversal keys                    
                </comment>
                <comment line="1092">
                    Fix for 6637607: consumeNextKeyTyped should be reset.                    
                </comment>
                <scope line="1061"/>
                <scope line="1066"/>
                <scope line="1072">
                    <declaration name="stroke" type="AWTKeyStroke" line="1073"/>
                    <declaration name="toTest" type="Set" line="1077"/>
                    <declaration name="contains" type="boolean" line="1078"/>
                    <scope line="1085">
                        <scope line="1087"/>
                    </scope>
                    <scope line="1091"/>
                    <scope line="1101">
                        <scope line="1103"/>
                    </scope>
                    <scope line="1114">
                        <scope line="1116"/>
                    </scope>
                    <scope line="1123"/>
                    <scope line="1132">
                        <scope line="1134"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1141">
                Delays dispatching of KeyEvents until the specified Component becomes
                  the focus owner. KeyEvents with timestamps later than the specified
                  timestamp will be enqueued until the specified Component receives a
                  FOCUS_GAINED event, or the AWT cancels the delay request by invoking
                  &lt;code&gt;dequeueKeyEvents&lt;/code&gt; or &lt;code&gt;discardKeyEvents&lt;/code&gt;.                
                <param>
                    after timestamp of current event, or the current, system time if
                      the current event has no timestamp, or the AWT cannot determine
                      which event is currently being handled                    
                </param>
                <param>
                    untilFocused Component which will receive a FOCUS_GAINED event
                      before any pending KeyEvents                    
                </param>
                <see>
                    #dequeueKeyEvents                    
                </see>
                <see>
                    #discardKeyEvents                    
                </see>
            </javadoc>
            <method name="enqueueKeyEvents" type="void" line="1157">
                <params>
                    <param name="after" type="long"/>
                    <param name="untilFocused" type="Component"/>
                </params>
                <scope line="1158"/>
                <declaration name="insertionIndex" type="int" line="1165"/>
                <declaration name="iter" type="ListIterator" line="1167"/>
                <scope line="1169">
                    <declaration name="marker" type="TypeAheadMarker" line="1170"/>
                    <scope line="1171"/>
                </scope>
            </method>
            <javadoc line="1181">
                Releases for normal dispatching to the current focus owner all
                  KeyEvents which were enqueued because of a call to
                  &lt;code&gt;enqueueKeyEvents&lt;/code&gt; with the same timestamp and Component.
                  If the given timestamp is less than zero, the outstanding enqueue
                  request for the given Component with the &lt;b&gt;oldest&lt;/b&gt; timestamp (if
                  any) should be cancelled.                
                <param>
                    after the timestamp specified in the call to
                      <code>enqueueKeyEvents</code>, or any value < 0                    
                </param>
                <param>
                    untilFocused the Component specified in the call to
                      <code>enqueueKeyEvents</code>                    
                </param>
                <see>
                    #enqueueKeyEvents                    
                </see>
                <see>
                    #discardKeyEvents                    
                </see>
            </javadoc>
            <method name="dequeueKeyEvents" type="void" line="1197">
                <params>
                    <param name="after" type="long"/>
                    <param name="untilFocused" type="Component"/>
                </params>
                <scope line="1198"/>
                <declaration name="marker" type="TypeAheadMarker" line="1205"/>
                <declaration name="iter" type="ListIterator" line="1206"/>
                <scope line="1209">
                    <scope line="1210">
                        <scope line="1213"/>
                    </scope>
                </scope>
                <scope line="1218">
                    <scope line="1219">
                        <scope line="1223"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1231">
                Discards all KeyEvents which were enqueued because of one or more calls
                  to &lt;code&gt;enqueueKeyEvents&lt;/code&gt; with the specified Component, or one of
                  its descendants.                
                <param>
                    comp the Component specified in one or more calls to
                      <code>enqueueKeyEvents</code>, or a parent of such a Component                    
                </param>
                <see>
                    #enqueueKeyEvents                    
                </see>
                <see>
                    #dequeueKeyEvents                    
                </see>
            </javadoc>
            <method name="discardKeyEvents" type="void" line="1241">
                <params>
                    <param name="comp" type="Component"/>
                </params>
                <scope line="1242"/>
                <declaration name="start" type="long" line="1246"/>
                <scope line="1248">
                    <declaration name="marker" type="TypeAheadMarker" line="1249"/>
                    <declaration name="toTest" type="Component" line="1250"/>
                    <declaration name="match" type="boolean" line="1251"/>
                    <scope line="1252"/>
                    <scope line="1256">
                        <scope line="1257"/>
                    </scope>
                    <scope line="1261"/>
                </scope>
            </method>
            <method name="purgeStampedEvents" type="void" line="1275">
                <params>
                    <param name="start" type="long"/>
                    <param name="end" type="long"/>
                </params>
                <scope line="1276"/>
                <scope line="1280">
                    <declaration name="ke" type="KeyEvent" line="1281"/>
                    <declaration name="time" type="long" line="1282"/>
                    <scope line="1284"/>
                    <scope line="1288"/>
                </scope>
            </method>
            <javadoc line="1294">
                Focuses the Component before aComponent, typically based on a
                  FocusTraversalPolicy.                
                <param>
                    aComponent the Component that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    FocusTraversalPolicy                    
                </see>
                <see>
                    Component#transferFocusBackward                    
                </see>
            </javadoc>
            <method name="focusPreviousComponent" type="void" line="1303">
                <params>
                    <param name="aComponent" type="Component"/>
                </params>
                <scope line="1304"/>
            </method>
            <javadoc line="1309">
                Focuses the Component after aComponent, typically based on a
                  FocusTraversalPolicy.                
                <param>
                    aComponent the Component that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    FocusTraversalPolicy                    
                </see>
                <see>
                    Component#transferFocus                    
                </see>
            </javadoc>
            <method name="focusNextComponent" type="void" line="1318">
                <params>
                    <param name="aComponent" type="Component"/>
                </params>
                <scope line="1319"/>
            </method>
            <javadoc line="1324">
                Moves the focus up one focus traversal cycle. Typically, the focus owner
                  is set to aComponent&apos;s focus cycle root, and the current focus cycle
                  root is set to the new focus owner&apos;s focus cycle root. If, however,
                  aComponent&apos;s focus cycle root is a Window, then the focus owner is set
                  to the focus cycle root&apos;s default Component to focus, and the current
                  focus cycle root is unchanged.                
                <param>
                    aComponent the Component that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    Component#transferFocusUpCycle                    
                </see>
            </javadoc>
            <method name="upFocusCycle" type="void" line="1336">
                <params>
                    <param name="aComponent" type="Component"/>
                </params>
                <scope line="1337"/>
            </method>
            <javadoc line="1342">
                Moves the focus down one focus traversal cycle. If aContainer is a focus
                  cycle root, then the focus owner is set to aContainer&apos;s default
                  Component to focus, and the current focus cycle root is set to
                  aContainer. If aContainer is not a focus cycle root, then no focus
                  traversal operation occurs.                
                <param>
                    aContainer the Container that is the basis for the focus
                      traversal operation                    
                </param>
                <see>
                    Container#transferFocusDownCycle                    
                </see>
            </javadoc>
            <method name="downFocusCycle" type="void" line="1353">
                <params>
                    <param name="aContainer" type="Container"/>
                </params>
                <scope line="1354"/>
            </method>
        </class>
    </source>