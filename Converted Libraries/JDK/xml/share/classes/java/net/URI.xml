<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.net">
        <import package="java.io.IOException"/>
        <import package="java.io.InvalidObjectException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.Serializable"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.CharBuffer"/>
        <import package="java.nio.charset.CharsetDecoder"/>
        <import package="java.nio.charset.CharsetEncoder"/>
        <import package="java.nio.charset.CoderResult"/>
        <import package="java.nio.charset.CodingErrorAction"/>
        <import package="java.nio.charset.CharacterCodingException"/>
        <import package="java.text.Normalizer"/>
        <import package="sun.nio.cs.ThreadLocalCoders"/>
        <import package="java.lang.Character"/>
        <import package="java.lang.NullPointerException"/>
        <class name="URI" line="47">
            <comment line="476">
                Note: Comments containing the word &quot;ASSERT&quot; indicate places where a                
            </comment>
            <comment line="477">
                throw of an InternalError should be replaced by an appropriate assertion                
            </comment>
            <comment line="478">
                statement once asserts are enabled in the build.                
            </comment>
            <comment line="483">
                -- Properties and components of this instance --                
            </comment>
            <comment line="485">
                Components of all URIs: [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]                
            </comment>
            <comment line="486">
                null ==&gt; relative URI                
            </comment>
            <comment line="489">
                Hierarchical URI components: [//&lt;authority&gt;]&lt;path&gt;[?&lt;query&gt;]                
            </comment>
            <comment line="490">
                Registry or server                
            </comment>
            <comment line="492">
                Server-based authority: [&lt;userInfo&gt;@]&lt;host&gt;[:&lt;port&gt;]                
            </comment>
            <comment line="494">
                null ==&gt; registry-based                
            </comment>
            <comment line="495">
                -1 ==&gt; undefined                
            </comment>
            <comment line="497">
                Remaining components of hierarchical URIs                
            </comment>
            <comment line="498">
                null ==&gt; opaque                
            </comment>
            <comment line="501">
                The remaining fields may be computed on demand                
            </comment>
            <comment line="504">
                Zero ==&gt; undefined                
            </comment>
            <comment line="518">
                The only serializable field                
            </comment>
            <comment line="522">
                -- Constructors and factories --                
            </comment>
            <comment line="524">
                Used internally                
            </comment>
            <comment line="865">
                -- Operations --                
            </comment>
            <comment line="1100">
                -- Component access methods --                
            </comment>
            <comment line="1382">
                -- Equality, comparison, hash code, toString, and serialization --                
            </comment>
            <comment line="1634">
                -- Serialization support --                
            </comment>
            <comment line="1679">
                -- End of public methods --                
            </comment>
            <comment line="1682">
                -- Utility methods for string-field comparison and hashing --                
            </comment>
            <comment line="1684">
                These methods return appropriate values for null string arguments,                
            </comment>
            <comment line="1685">
                thereby simplifying the equals, hashCode, and compareTo methods.                
            </comment>
            <comment line="1686">
                                
            </comment>
            <comment line="1687">
                The case-ignoring methods should only be applied to strings whose                
            </comment>
            <comment line="1688">
                characters are all known to be US-ASCII.  Because of this restriction,                
            </comment>
            <comment line="1689">
                these methods are faster than the similar methods in the String class.                
            </comment>
            <comment line="1691">
                US-ASCII only                
            </comment>
            <comment line="1728">
                US-ASCII only                
            </comment>
            <comment line="1749">
                US-ASCII only                
            </comment>
            <comment line="1771">
                US-ASCII only                
            </comment>
            <comment line="1793">
                -- String construction --                
            </comment>
            <comment line="1795">
                If a scheme is given then the path, if given, must be absolute                
            </comment>
            <comment line="1796">
                                
            </comment>
            <comment line="1983">
                -- Normalization, resolution, and relativization --                
            </comment>
            <comment line="1985">
                RFC2396 5.2 (6)                
            </comment>
            <comment line="2016">
                RFC2396 5.2                
            </comment>
            <comment line="2080">
                If the given URI&apos;s path is normal then return the URI;                
            </comment>
            <comment line="2081">
                o.w., return a new URI containing the normalized path.                
            </comment>
            <comment line="2082">
                                
            </comment>
            <comment line="2103">
                If both URIs are hierarchical, their scheme and authority components are                
            </comment>
            <comment line="2104">
                identical, and the base path is a prefix of the child&apos;s path, then                
            </comment>
            <comment line="2105">
                return a relative URI that, when resolved against the base, yields the                
            </comment>
            <comment line="2106">
                child; otherwise, return the child.                
            </comment>
            <comment line="2107">
                                
            </comment>
            <comment line="2135">
                -- Path normalization --                
            </comment>
            <comment line="2137">
                The following algorithm for path normalization avoids the creation of a                
            </comment>
            <comment line="2138">
                string object for each segment, as well as the use of a string buffer to                
            </comment>
            <comment line="2139">
                compute the final result, by using a single char array and editing it in                
            </comment>
            <comment line="2140">
                place.  The array is first split into segments, replacing each slash                
            </comment>
            <comment line="2141">
                with &apos;\0&apos; and creating a segment-index array, each element of which is                
            </comment>
            <comment line="2142">
                the index of the first char in the corresponding segment.  We then walk                
            </comment>
            <comment line="2143">
                through both arrays, removing &quot;.&quot;, &quot;..&quot;, and other segments as necessary                
            </comment>
            <comment line="2144">
                by setting their entries in the index array to -1.  Finally, the two                
            </comment>
            <comment line="2145">
                arrays are used to rejoin the segments and compute the final result.                
            </comment>
            <comment line="2146">
                                
            </comment>
            <comment line="2147">
                This code is based upon src/solaris/native/java/io/canonicalize_md.c                
            </comment>
            <comment line="2150">
                Check the given path to see if it might need normalization.  A path                
            </comment>
            <comment line="2151">
                might need normalization if it contains duplicate slashes, a &quot;.&quot;                
            </comment>
            <comment line="2152">
                segment, or a &quot;..&quot; segment.  Return -1 if no further normalization is                
            </comment>
            <comment line="2153">
                possible, otherwise return the number of segments found.                
            </comment>
            <comment line="2154">
                                
            </comment>
            <comment line="2155">
                This method takes a string argument rather than a char array so that                
            </comment>
            <comment line="2156">
                this test can be performed without invoking path.toCharArray().                
            </comment>
            <comment line="2157">
                                
            </comment>
            <comment line="2205">
                Split the given path into segments, replacing slashes with nulls and                
            </comment>
            <comment line="2206">
                filling in the given segment-index array.                
            </comment>
            <comment line="2207">
                                
            </comment>
            <comment line="2208">
                Preconditions:                
            </comment>
            <comment line="2209">
                segs.length == Number of segments in path                
            </comment>
            <comment line="2210">
                                
            </comment>
            <comment line="2211">
                Postconditions:                
            </comment>
            <comment line="2212">
                All slashes in path replaced by &apos;\0&apos;                
            </comment>
            <comment line="2213">
                segs[i] == Index of first char in segment i (0 &lt;= i &lt; segs.length)                
            </comment>
            <comment line="2214">
                                
            </comment>
            <comment line="2252">
                Join the segments in the given path according to the given segment-index                
            </comment>
            <comment line="2253">
                array, ignoring those segments whose index entries have been set to -1,                
            </comment>
            <comment line="2254">
                and inserting slashes as needed.  Return the length of the resulting                
            </comment>
            <comment line="2255">
                path.                
            </comment>
            <comment line="2256">
                                
            </comment>
            <comment line="2257">
                Preconditions:                
            </comment>
            <comment line="2258">
                segs[i] == -1 implies segment i is to be ignored                
            </comment>
            <comment line="2259">
                path computed by split, as above, with &apos;\0&apos; having replaced &apos;/&apos;                
            </comment>
            <comment line="2260">
                                
            </comment>
            <comment line="2261">
                Postconditions:                
            </comment>
            <comment line="2262">
                path[0] .. path[return value] == Resulting path                
            </comment>
            <comment line="2263">
                                
            </comment>
            <comment line="2304">
                Remove &quot;.&quot; segments from the given path, and remove segment pairs                
            </comment>
            <comment line="2305">
                consisting of a non-&quot;..&quot; segment followed by a &quot;..&quot; segment.                
            </comment>
            <comment line="2306">
                                
            </comment>
            <comment line="2361">
                DEVIATION: If the normalized path is relative, and if the first                
            </comment>
            <comment line="2362">
                segment could be parsed as a scheme name, then prepend a &quot;.&quot; segment                
            </comment>
            <comment line="2363">
                                
            </comment>
            <comment line="2396">
                Normalize the given path string.  A normal path string has no empty                
            </comment>
            <comment line="2397">
                segments (i.e., occurrences of &quot;//&quot;), no segments equal to &quot;.&quot;, and no                
            </comment>
            <comment line="2398">
                segments equal to &quot;..&quot; that are preceded by a segment not equal to &quot;..&quot;.                
            </comment>
            <comment line="2399">
                In contrast to Unix-style pathname normalization, for URI paths we                
            </comment>
            <comment line="2400">
                always retain trailing slashes.                
            </comment>
            <comment line="2401">
                                
            </comment>
            <comment line="2433">
                -- Character classes for parsing --                
            </comment>
            <comment line="2435">
                RFC2396 precisely specifies which characters in the US-ASCII charset are                
            </comment>
            <comment line="2436">
                permissible in the various components of a URI reference.  We here                
            </comment>
            <comment line="2437">
                define a set of mask pairs to aid in enforcing these restrictions.  Each                
            </comment>
            <comment line="2438">
                mask pair consists of two longs, a low mask and a high mask.  Taken                
            </comment>
            <comment line="2439">
                together they represent a 128-bit mask, where bit i is set iff the                
            </comment>
            <comment line="2440">
                character with value i is permitted.                
            </comment>
            <comment line="2441">
                                
            </comment>
            <comment line="2442">
                This approach is more efficient than sequentially searching arrays of                
            </comment>
            <comment line="2443">
                permitted characters.  It could be made still more efficient by                
            </comment>
            <comment line="2444">
                precompiling the mask information so that a character&apos;s presence in a                
            </comment>
            <comment line="2445">
                given mask could be determined by a single table lookup.                
            </comment>
            <comment line="2447">
                Compute the low-order mask for the characters in the given string                
            </comment>
            <comment line="2459">
                Compute the high-order mask for the characters in the given string                
            </comment>
            <comment line="2471">
                Compute a low-order mask for the characters                
            </comment>
            <comment line="2472">
                between first and last, inclusive                
            </comment>
            <comment line="2482">
                Compute a high-order mask for the characters                
            </comment>
            <comment line="2483">
                between first and last, inclusive                
            </comment>
            <comment line="2493">
                Tell whether the given character is permitted by the given mask pair                
            </comment>
            <comment line="2504">
                Character-class masks, in reverse order from RFC2396 because                
            </comment>
            <comment line="2505">
                initializers for static fields cannot make forward references.                
            </comment>
            <comment line="2507">
                digit    = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |                
            </comment>
            <comment line="2508">
                &quot;8&quot; | &quot;9&quot;                
            </comment>
            <comment line="2512">
                upalpha  = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; | &quot;I&quot; |                
            </comment>
            <comment line="2513">
                &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; |                
            </comment>
            <comment line="2514">
                &quot;S&quot; | &quot;T&quot; | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot;                
            </comment>
            <comment line="2518">
                lowalpha = &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; |                
            </comment>
            <comment line="2519">
                &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; |                
            </comment>
            <comment line="2520">
                &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;                
            </comment>
            <comment line="2524">
                alpha         = lowalpha | upalpha                
            </comment>
            <comment line="2528">
                alphanum      = alpha | digit                
            </comment>
            <comment line="2532">
                hex           = digit | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; |                
            </comment>
            <comment line="2533">
                &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;                
            </comment>
            <comment line="2537">
                mark          = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;&apos;&quot; |                
            </comment>
            <comment line="2538">
                &quot;(&quot; | &quot;)&quot;                
            </comment>
            <comment line="2542">
                unreserved    = alphanum | mark                
            </comment>
            <comment line="2546">
                reserved      = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |                
            </comment>
            <comment line="2547">
                &quot;$&quot; | &quot;,&quot; | &quot;[&quot; | &quot;]&quot;                
            </comment>
            <comment line="2548">
                Added per RFC2732: &quot;[&quot;, &quot;]&quot;                
            </comment>
            <comment line="2552">
                The zero&apos;th bit is used to indicate that escape pairs and non-US-ASCII                
            </comment>
            <comment line="2553">
                characters are allowed; this is handled by the scanEscape method below.                
            </comment>
            <comment line="2557">
                uric          = reserved | unreserved | escaped                
            </comment>
            <comment line="2561">
                pchar         = unreserved | escaped |                
            </comment>
            <comment line="2562">
                &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;                
            </comment>
            <comment line="2568">
                All valid path characters                
            </comment>
            <comment line="2572">
                Dash, for use in domainlabel and toplabel                
            </comment>
            <comment line="2576">
                Dot, for use in hostnames                
            </comment>
            <comment line="2580">
                userinfo      = *( unreserved | escaped |                
            </comment>
            <comment line="2581">
                &quot;;&quot; | &quot;:&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot; )                
            </comment>
            <comment line="2587">
                reg_name      = 1*( unreserved | escaped | &quot;$&quot; | &quot;,&quot; |                
            </comment>
            <comment line="2588">
                &quot;;&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; )                
            </comment>
            <comment line="2594">
                All valid characters for server-based authorities                
            </comment>
            <comment line="2600">
                Special case of server authority that represents an IPv6 address                
            </comment>
            <comment line="2601">
                In this case, a % does not signify an escape sequence                
            </comment>
            <comment line="2609">
                scheme        = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )                
            </comment>
            <comment line="2613">
                uric_no_slash = unreserved | escaped | &quot;;&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; |                
            </comment>
            <comment line="2614">
                &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;                
            </comment>
            <comment line="2621">
                -- Escaping and encoding --                
            </comment>
            <comment line="2651">
                Quote any characters in s that are not permitted                
            </comment>
            <comment line="2652">
                by the given mask pair                
            </comment>
            <comment line="2653">
                                
            </comment>
            <comment line="2687">
                Encodes all characters &gt;= \u0080 into escaped, normalized UTF-8 octets,                
            </comment>
            <comment line="2688">
                assuming that s is otherwise legal                
            </comment>
            <comment line="2689">
                                
            </comment>
            <comment line="2739">
                Evaluates all escapes in s, applying UTF-8 decoding if needed.  Assumes                
            </comment>
            <comment line="2740">
                that escapes are well-formed syntactically, i.e., of the form %XX.  If a                
            </comment>
            <comment line="2741">
                sequence of escaped octets is not valid UTF-8 then the erroneous octets                
            </comment>
            <comment line="2742">
                are replaced with &apos;\uFFFD&apos;.                
            </comment>
            <comment line="2743">
                Exception: any &quot;%&quot; found between &quot;[]&quot; is left alone. It is an IPv6 literal                
            </comment>
            <comment line="2744">
                with a scope_id                
            </comment>
            <comment line="2745">
                                
            </comment>
            <comment line="2805">
                -- Parsing --                
            </comment>
            <comment line="2807">
                For convenience we wrap the input URI string in a new instance of the                
            </comment>
            <comment line="2808">
                following internal class.  This saves always having to pass the input                
            </comment>
            <comment line="2809">
                string as an argument to each internal scan/parse method.                
            </comment>
            <implements interface="Comparable">
                <type_params>
                    <type_param name="URI"/>
                </type_params>
            </implements>
            <implements interface="Serializable"/>
            <javadoc line="47">
                Represents a Uniform Resource Identifier (URI) reference.
                  &lt;p&gt; Aside from some minor deviations noted below, an instance of this
                  class represents a URI reference as defined by
                  &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
                  Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
                  Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
                  also supports scope_ids. The syntax and usage of scope_ids is described
                  &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
                  This class provides constructors for creating URI instances from
                  their components or by parsing their string forms, methods for accessing the
                  various components of an instance, and methods for normalizing, resolving,
                  and relativizing URI instances.  Instances of this class are immutable.
                  &lt;h4&gt; URI syntax and components &lt;/h4&gt;
                  At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string
                  form has the syntax
                  &lt;blockquote&gt;
                  [&lt;i&gt;scheme&lt;/i&gt;&lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;&lt;/i&gt;]&lt;i&gt;scheme-specific-part&lt;/i&gt;[&lt;tt&gt;&lt;b&gt;#&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;fragment&lt;/i&gt;]
                  &lt;/blockquote&gt;
                  where square brackets [...] delineate optional components and the characters
                  &lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;b&gt;#&lt;/b&gt;&lt;/tt&gt; stand for themselves.
                  &lt;p&gt; An &lt;i&gt;absolute&lt;/i&gt; URI specifies a scheme; a URI that is not absolute is
                  said to be &lt;i&gt;relative&lt;/i&gt;.  URIs are also classified according to whether
                  they are &lt;i&gt;opaque&lt;/i&gt; or &lt;i&gt;hierarchical&lt;/i&gt;.
                  &lt;p&gt; An &lt;i&gt;opaque&lt;/i&gt; URI is an absolute URI whose scheme-specific part does
                  not begin with a slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;).  Opaque URIs are not
                  subject to further parsing.  Some examples of opaque URIs are:
                  &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;mailto:java-net@java.sun.com&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;news:comp.lang.java&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;urn:isbn:096139210x&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;
                  &lt;p&gt; A &lt;i&gt;hierarchical&lt;/i&gt; URI is either an absolute URI whose
                  scheme-specific part begins with a slash character, or a relative URI, that
                  is, a URI that does not specify a scheme.  Some examples of hierarchical
                  URIs are:
                  &lt;blockquote&gt;
                  &lt;tt&gt;http://java.sun.com/j2se/1.3/&lt;/tt&gt;&lt;br&gt;
                  &lt;tt&gt;docs/guide/collections/designfaq.html#28&lt;/tt&gt;&lt;br&gt;
                  &lt;tt&gt;../../../demo/jfc/SwingSet2/src/SwingSet2.java&lt;/tt&gt;&lt;br&gt;
                  &lt;tt&gt;file:///~/calendar&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt; A hierarchical URI is subject to further parsing according to the syntax
                  &lt;blockquote&gt;
                  [&lt;i&gt;scheme&lt;/i&gt;&lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt;][&lt;tt&gt;&lt;b&gt;//&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;authority&lt;/i&gt;][&lt;i&gt;path&lt;/i&gt;][&lt;tt&gt;&lt;b&gt;?&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;query&lt;/i&gt;][&lt;tt&gt;&lt;b&gt;#&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;fragment&lt;/i&gt;]
                  &lt;/blockquote&gt;
                  where the characters &lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt;, &lt;tt&gt;&lt;b&gt;/&lt;/b&gt;&lt;/tt&gt;,
                  &lt;tt&gt;&lt;b&gt;?&lt;/b&gt;&lt;/tt&gt;, and &lt;tt&gt;&lt;b&gt;#&lt;/b&gt;&lt;/tt&gt; stand for themselves.  The
                  scheme-specific part of a hierarchical URI consists of the characters
                  between the scheme and fragment components.
                  &lt;p&gt; The authority component of a hierarchical URI is, if specified, either
                  &lt;i&gt;server-based&lt;/i&gt; or &lt;i&gt;registry-based&lt;/i&gt;.  A server-based authority
                  parses according to the familiar syntax
                  &lt;blockquote&gt;
                  [&lt;i&gt;user-info&lt;/i&gt;&lt;tt&gt;&lt;b&gt;@&lt;/b&gt;&lt;/tt&gt;]&lt;i&gt;host&lt;/i&gt;[&lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;port&lt;/i&gt;]
                  &lt;/blockquote&gt;
                  where the characters &lt;tt&gt;&lt;b&gt;@&lt;/b&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt; stand for
                  themselves.  Nearly all URI schemes currently in use are server-based.  An
                  authority component that does not parse in this way is considered to be
                  registry-based.
                  &lt;p&gt; The path component of a hierarchical URI is itself said to be absolute
                  if it begins with a slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;); otherwise it is
                  relative.  The path of a hierarchical URI that is either absolute or
                  specifies an authority is always absolute.
                  &lt;p&gt; All told, then, a URI instance has the following nine components:
                  &lt;blockquote&gt;&lt;table summary=&quot;Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment&quot;&gt;
                  &lt;tr&gt;&lt;th&gt;&lt;i&gt;Component&lt;/i&gt;&lt;/th&gt;&lt;th&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;scheme&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;scheme-specific-part&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;authority&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;user-info&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;host&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;port&lt;/td&gt;&lt;td&gt;&lt;tt&gt;int&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;path&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;query&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;fragment&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;
                  In a given instance any particular component is either &lt;i&gt;undefined&lt;/i&gt; or
                  &lt;i&gt;defined&lt;/i&gt; with a distinct value.  Undefined string components are
                  represented by &lt;tt&gt;null&lt;/tt&gt;, while undefined integer components are
                  represented by &lt;tt&gt;-1&lt;/tt&gt;.  A string component may be defined to have the
                  empty string as its value; this is not equivalent to that component being
                  undefined.
                  &lt;p&gt; Whether a particular component is or is not defined in an instance
                  depends upon the type of the URI being represented.  An absolute URI has a
                  scheme component.  An opaque URI has a scheme, a scheme-specific part, and
                  possibly a fragment, but has no other components.  A hierarchical URI always
                  has a path (though it may be empty) and a scheme-specific-part (which at
                  least contains the path), and may have any of the other components.  If the
                  authority component is present and is server-based then the host component
                  will be defined and the user-information and port components may be defined.
                  &lt;h4&gt; Operations on URI instances &lt;/h4&gt;
                  The key operations supported by this class are those of
                  &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.
                  &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary &lt;tt&gt;&quot;.&quot;&lt;/tt&gt;
                  and &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segments from the path component of a hierarchical URI.
                  Each &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; segment is simply removed.  A &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segment is
                  removed only if it is preceded by a non-&lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segment.
                  Normalization has no effect upon opaque URIs.
                  &lt;p&gt; &lt;i&gt;Resolution&lt;/i&gt; is the process of resolving one URI against another,
                  &lt;i&gt;base&lt;/i&gt; URI.  The resulting URI is constructed from components of both
                  URIs in the manner specified by RFC&amp;nbsp;2396, taking components from the
                  base URI for those not specified in the original.  For hierarchical URIs,
                  the path of the original is resolved against the path of the base and then
                  normalized.  The result, for example, of resolving
                  &lt;blockquote&gt;
                  &lt;tt&gt;docs/guide/collections/designfaq.html#28&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;(1)
                  &lt;/blockquote&gt;
                  against the base URI &lt;tt&gt;http://java.sun.com/j2se/1.3/&lt;/tt&gt; is the result
                  URI
                  &lt;blockquote&gt;
                  &lt;tt&gt;http://java.sun.com/j2se/1.3/docs/guide/collections/designfaq.html#28&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  Resolving the relative URI
                  &lt;blockquote&gt;
                  &lt;tt&gt;../../../demo/jfc/SwingSet2/src/SwingSet2.java&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;(2)
                  &lt;/blockquote&gt;
                  against this result yields, in turn,
                  &lt;blockquote&gt;
                  &lt;tt&gt;http://java.sun.com/j2se/1.3/demo/jfc/SwingSet2/src/SwingSet2.java&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  Resolution of both absolute and relative URIs, and of both absolute and
                  relative paths in the case of hierarchical URIs, is supported.  Resolving
                  the URI &lt;tt&gt;file:///~calendar&lt;/tt&gt; against any other URI simply yields the
                  original URI, since it is absolute.  Resolving the relative URI (2) above
                  against the relative base URI (1) yields the normalized, but still relative,
                  URI
                  &lt;blockquote&gt;
                  &lt;tt&gt;demo/jfc/SwingSet2/src/SwingSet2.java&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt; &lt;i&gt;Relativization&lt;/i&gt;, finally, is the inverse of resolution: For any
                  two normalized URIs &lt;i&gt;u&lt;/i&gt; and&amp;nbsp;&lt;i&gt;v&lt;/i&gt;,
                  &lt;blockquote&gt;
                  &lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.relativize(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.resolve(&lt;/tt&gt;&lt;i&gt;v&lt;/i&gt;&lt;tt&gt;)).equals(&lt;/tt&gt;&lt;i&gt;v&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&amp;nbsp;&amp;nbsp;and&lt;br&gt;
                  &lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.resolve(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.relativize(&lt;/tt&gt;&lt;i&gt;v&lt;/i&gt;&lt;tt&gt;)).equals(&lt;/tt&gt;&lt;i&gt;v&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&amp;nbsp;&amp;nbsp;.&lt;br&gt;
                  &lt;/blockquote&gt;
                  This operation is often useful when constructing a document containing URIs
                  that must be made relative to the base URI of the document wherever
                  possible.  For example, relativizing the URI
                  &lt;blockquote&gt;
                  &lt;tt&gt;http://java.sun.com/j2se/1.3/docs/guide/index.html&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  against the base URI
                  &lt;blockquote&gt;
                  &lt;tt&gt;http://java.sun.com/j2se/1.3&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  yields the relative URI &lt;tt&gt;docs/guide/index.html&lt;/tt&gt;.
                  &lt;h4&gt; Character categories &lt;/h4&gt;
                  RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
                  various components of a URI reference.  The following categories, most of
                  which are taken from that specification, are used below to describe these
                  constraints:
                  &lt;blockquote&gt;&lt;table cellspacing=2 summary=&quot;Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other&quot;&gt;
                  &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;alpha&lt;/i&gt;&lt;/th&gt;
                  &lt;td&gt;The US-ASCII alphabetic characters,
                  &lt;tt&gt;&apos;A&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;Z&apos;&lt;/tt&gt;
                  and &lt;tt&gt;&apos;a&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;z&apos;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;digit&lt;/i&gt;&lt;/th&gt;
                  &lt;td&gt;The US-ASCII decimal digit characters,
                  &lt;tt&gt;&apos;0&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;9&apos;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;alphanum&lt;/i&gt;&lt;/th&gt;
                  &lt;td&gt;All &lt;i&gt;alpha&lt;/i&gt; and &lt;i&gt;digit&lt;/i&gt; characters&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;unreserved&lt;/i&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;All &lt;i&gt;alphanum&lt;/i&gt; characters together with those in the string
                  &lt;tt&gt;&quot;_-!.~&apos;()&quot;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;punct&lt;/i&gt;&lt;/th&gt;
                  &lt;td&gt;The characters in the string &lt;tt&gt;&quot;,;:$&amp;+=&quot;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;reserved&lt;/i&gt;&lt;/th&gt;
                  &lt;td&gt;All &lt;i&gt;punct&lt;/i&gt; characters together with those in the string
                  &lt;tt&gt;&quot;?/[]@&quot;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;escaped&lt;/i&gt;&lt;/th&gt;
                  &lt;td&gt;Escaped octets, that is, triplets consisting of the percent
                  character (&lt;tt&gt;&apos;%&apos;&lt;/tt&gt;) followed by two hexadecimal digits
                  (&lt;tt&gt;&apos;0&apos;&lt;/tt&gt;-&lt;tt&gt;&apos;9&apos;&lt;/tt&gt;, &lt;tt&gt;&apos;A&apos;&lt;/tt&gt;-&lt;tt&gt;&apos;F&apos;&lt;/tt&gt;, and
                  &lt;tt&gt;&apos;a&apos;&lt;/tt&gt;-&lt;tt&gt;&apos;f&apos;&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;other&lt;/i&gt;&lt;/th&gt;
                  &lt;td&gt;The Unicode characters that are not in the US-ASCII character set,
                  are not control characters (according to the {@link java.lang.Character#isISOControl(char) Character.isISOControl}method), and are not space characters (according to the {@link java.lang.Character#isSpaceChar(char) Character.isSpaceChar}method)&amp;nbsp;&amp;nbsp;&lt;i&gt;(&lt;b&gt;Deviation from RFC 2396&lt;/b&gt;, which is
                  limited to US-ASCII)&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;
                  &lt;p&gt;&lt;a name=&quot;legal-chars&quot;&gt;&lt;/a&gt; The set of all legal URI characters consists of
                  the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
                  characters.
                  &lt;h4&gt; Escaped octets, quotation, encoding, and decoding &lt;/h4&gt;
                  RFC 2396 allows escaped octets to appear in the user-info, path, query, and
                  fragment components.  Escaping serves two purposes in URIs:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt; To &lt;i&gt;encode&lt;/i&gt; non-US-ASCII characters when a URI is required to
                  conform strictly to RFC&amp;nbsp;2396 by not containing any &lt;i&gt;other&lt;/i&gt;
                  characters.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; To &lt;i&gt;quote&lt;/i&gt; characters that are otherwise illegal in a
                  component.  The user-info, path, query, and fragment components differ
                  slightly in terms of which characters are considered legal and illegal.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  These purposes are served in this class by three related operations:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt;&lt;a name=&quot;encode&quot;&gt;&lt;/a&gt; A character is &lt;i&gt;encoded&lt;/i&gt; by replacing it
                  with the sequence of escaped octets that represent that character in the
                  UTF-8 character set.  The Euro currency symbol (&lt;tt&gt;&apos;&amp;#92;u20AC&apos;&lt;/tt&gt;),
                  for example, is encoded as &lt;tt&gt;&quot;%E2%82%AC&quot;&lt;/tt&gt;.  &lt;i&gt;(&lt;b&gt;Deviation from
                  RFC&amp;nbsp;2396&lt;/b&gt;, which does not specify any particular character
                  set.)&lt;/i&gt; &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt;&lt;a name=&quot;quote&quot;&gt;&lt;/a&gt; An illegal character is &lt;i&gt;quoted&lt;/i&gt; simply by
                  encoding it.  The space character, for example, is quoted by replacing it
                  with &lt;tt&gt;&quot;%20&quot;&lt;/tt&gt;.  UTF-8 contains US-ASCII, hence for US-ASCII
                  characters this transformation has exactly the effect required by
                  RFC&amp;nbsp;2396. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt;&lt;a name=&quot;decode&quot;&gt;&lt;/a&gt;
                  A sequence of escaped octets is &lt;i&gt;decoded&lt;/i&gt; by
                  replacing it with the sequence of characters that it represents in the
                  UTF-8 character set.  UTF-8 contains US-ASCII, hence decoding has the
                  effect of de-quoting any quoted US-ASCII characters as well as that of
                  decoding any encoded non-US-ASCII characters.  If a &lt;a
                  href=&quot;../nio/charset/CharsetDecoder.html#ce&quot;&gt;decoding error&lt;/a&gt; occurs
                  when decoding the escaped octets then the erroneous octets are replaced by
                  &lt;tt&gt;&apos;&amp;#92;uFFFD&apos;&lt;/tt&gt;, the Unicode replacement character.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  These operations are exposed in the constructors and methods of this class
                  as follows:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt; The {@link #URI(java.lang.String) &lt;code&gt;single-argument
                  constructor&lt;/code&gt;} requires any illegal characters in its argument to be
                  quoted and preserves any escaped octets and &lt;i&gt;other&lt;/i&gt; characters that
                  are present.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The {@link #URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)&lt;code&gt;multi-argument constructors&lt;/code&gt;} quote illegal characters as
                  required by the components in which they appear.  The percent character
                  (&lt;tt&gt;&apos;%&apos;&lt;/tt&gt;) is always quoted by these constructors.  Any &lt;i&gt;other&lt;/i&gt;
                  characters are preserved.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The {@link #getRawUserInfo() getRawUserInfo}, {@link #getRawPath()getRawPath}, {@link #getRawQuery() getRawQuery}, {@link #getRawFragment()getRawFragment}, {@link #getRawAuthority() getRawAuthority}, and {@link #getRawSchemeSpecificPart() getRawSchemeSpecificPart} methods return the
                  values of their corresponding components in raw form, without interpreting
                  any escaped octets.  The strings returned by these methods may contain
                  both escaped octets and &lt;i&gt;other&lt;/i&gt; characters, and will not contain any
                  illegal characters.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The {@link #getUserInfo() getUserInfo}, {@link #getPath()getPath}, {@link #getQuery() getQuery}, {@link #getFragment()getFragment}, {@link #getAuthority() getAuthority}, and {@link #getSchemeSpecificPart() getSchemeSpecificPart} methods decode any escaped
                  octets in their corresponding components.  The strings returned by these
                  methods may contain both &lt;i&gt;other&lt;/i&gt; characters and illegal characters,
                  and will not contain any escaped octets.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The {@link #toString() toString} method returns a URI string with
                  all necessary quotation but which may contain &lt;i&gt;other&lt;/i&gt; characters.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The {@link #toASCIIString() toASCIIString} method returns a fully
                  quoted and encoded URI string that does not contain any &lt;i&gt;other&lt;/i&gt;
                  characters.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;h4&gt; Identities &lt;/h4&gt;
                  For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that
                  &lt;blockquote&gt;
                  &lt;tt&gt;new URI(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.toString()).equals(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&amp;nbsp;.
                  &lt;/blockquote&gt;
                  For any URI &lt;i&gt;u&lt;/i&gt; that does not contain redundant syntax such as two
                  slashes before an empty authority (as in &lt;tt&gt;file:///tmp/&lt;/tt&gt;&amp;nbsp;) or a
                  colon following a host name but no port (as in
                  &lt;tt&gt;http://java.sun.com:&lt;/tt&gt;&amp;nbsp;), and that does not encode characters
                  except those that must be quoted, the following identities also hold:
                  &lt;blockquote&gt;
                  &lt;tt&gt;new URI(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getScheme(),&lt;br&gt;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getSchemeSpecificPart(),&lt;br&gt;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getFragment())&lt;br&gt;
                  .equals(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  in all cases,
                  &lt;blockquote&gt;
                  &lt;tt&gt;new URI(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getScheme(),&lt;br&gt;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getUserInfo(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getAuthority(),&lt;br&gt;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getPath(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getQuery(),&lt;br&gt;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getFragment())&lt;br&gt;
                  .equals(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  if &lt;i&gt;u&lt;/i&gt; is hierarchical, and
                  &lt;blockquote&gt;
                  &lt;tt&gt;new URI(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getScheme(),&lt;br&gt;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getUserInfo(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getHost(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getPort(),&lt;br&gt;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getPath(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getQuery(),&lt;br&gt;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getFragment())&lt;br&gt;
                  .equals(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
                  authority.
                  &lt;h4&gt; URIs, URLs, and URNs &lt;/h4&gt;
                  A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
                  resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
                  not every URI is a URL.  This is because there is another subcategory of
                  URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
                  specify how to locate them.  The &lt;tt&gt;mailto&lt;/tt&gt;, &lt;tt&gt;news&lt;/tt&gt;, and
                  &lt;tt&gt;isbn&lt;/tt&gt; URIs shown above are examples of URNs.
                  &lt;p&gt; The conceptual distinction between URIs and URLs is reflected in the
                  differences between this class and the {@link URL} class.
                  &lt;p&gt; An instance of this class represents a URI reference in the syntactic
                  sense defined by RFC&amp;nbsp;2396.  A URI may be either absolute or relative.
                  A URI string is parsed according to the generic syntax without regard to the
                  scheme, if any, that it specifies.  No lookup of the host, if any, is
                  performed, and no scheme-dependent stream handler is constructed.  Equality,
                  hashing, and comparison are defined strictly in terms of the character
                  content of the instance.  In other words, a URI instance is little more than
                  a structured string that supports the syntactic, scheme-independent
                  operations of comparison, normalization, resolution, and relativization.
                  &lt;p&gt; An instance of the {@link URL} class, by contrast, represents the
                  syntactic components of a URL together with some of the information required
                  to access the resource that it describes.  A URL must be absolute, that is,
                  it must always specify a scheme.  A URL string is parsed according to its
                  scheme.  A stream handler is always established for a URL, and in fact it is
                  impossible to create a URL instance for a scheme for which no handler is
                  available.  Equality and hashing depend upon both the scheme and the
                  Internet address of the host, if any; comparison is not defined.  In other
                  words, a URL is a structured string that supports the syntactic operation of
                  resolution as well as the network I/O operations of looking up the host and
                  opening a connection to the specified resource.                
                <author>
                    Mark Reinhold                    
                </author>
                <since>
                    1.4                    
                </since>
                <see>
                    <a href="http://www.ietf.org/rfc/rfc2279.txt"><i>RFC&nbsp;2279: UTF-8, a
                      transformation format of ISO 10646</i></a>, <br><a
                      href="http://www.ietf.org/rfc/rfc2373.txt"><i>RFC&nbsp;2373: IPv6 Addressing
                      Architecture</i></a>, <br><a
                      href="http://www.ietf.org/rfc/rfc2396.txt"><i>RFC&nbsp;2396: Uniform
                      Resource Identifiers (URI): Generic Syntax</i></a>, <br><a
                      href="http://www.ietf.org/rfc/rfc2732.txt"><i>RFC&nbsp;2732: Format for
                      Literal IPv6 Addresses in URLs</i></a>, <br><a
                      href="URISyntaxException.html">URISyntaxException</a>                    
                </see>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="479"/>
            <declaration name="scheme" type="String" line="485"/>
            <declaration name="fragment" type="String" line="486"/>
            <declaration name="authority" type="String" line="489"/>
            <declaration name="userInfo" type="String" line="492"/>
            <declaration name="host" type="String" line="493"/>
            <declaration name="port" type="int" line="494"/>
            <declaration name="path" type="String" line="497"/>
            <declaration name="query" type="String" line="498"/>
            <declaration name="schemeSpecificPart" type="String" line="502"/>
            <declaration name="hash" type="int" line="503"/>
            <declaration name="decodedUserInfo" type="String" line="505"/>
            <declaration name="decodedAuthority" type="String" line="506"/>
            <declaration name="decodedPath" type="String" line="507"/>
            <declaration name="decodedQuery" type="String" line="508"/>
            <declaration name="decodedFragment" type="String" line="509"/>
            <declaration name="decodedSchemeSpecificPart" type="String" line="510"/>
            <declaration name="string" type="String" line="512"/>
            <javadoc line="512">
                The string form of this URI.                
                <serial>
                                        
                </serial>
            </javadoc>
            <method name="URI" type="constructor" line="523"/>
            <javadoc line="525">
                Constructs a URI by parsing the given string.
                  &lt;p&gt; This constructor parses the given string exactly as specified by the
                  grammar in &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
                  Appendix&amp;nbsp;A, &lt;b&gt;&lt;i&gt;except for the following deviations:&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;
                  &lt;ul type=disc&gt;
                  &lt;li&gt;&lt;p&gt; An empty authority component is permitted as long as it is
                  followed by a non-empty path, a query component, or a fragment
                  component.  This allows the parsing of URIs such as
                  &lt;tt&gt;&quot;file:///foo/bar&quot;&lt;/tt&gt;, which seems to be the intent of
                  RFC&amp;nbsp;2396 although the grammar does not permit it.  If the
                  authority component is empty then the user-information, host, and port
                  components are undefined. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Empty relative paths are permitted; this seems to be the
                  intent of RFC&amp;nbsp;2396 although the grammar does not permit it.  The
                  primary consequence of this deviation is that a standalone fragment
                  such as &lt;tt&gt;&quot;#foo&quot;&lt;/tt&gt; parses as a relative URI with an empty path
                  and the given fragment, and can be usefully &lt;a
                  href=&quot;#resolve-frag&quot;&gt;resolved&lt;/a&gt; against a base URI.
                  &lt;li&gt;&lt;p&gt; IPv4 addresses in host components are parsed rigorously, as
                  specified by &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;: Each
                  element of a dotted-quad address must contain no more than three
                  decimal digits.  Each element is further constrained to have a value
                  no greater than 255. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt; &lt;p&gt; Hostnames in host components that comprise only a single
                  domain label are permitted to start with an &lt;i&gt;alphanum&lt;/i&gt;
                  character. This seems to be the intent of &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
                  section&amp;nbsp;3.2.2 although the grammar does not permit it. The
                  consequence of this deviation is that the authority component of a
                  hierarchical URI such as &lt;tt&gt;s://123&lt;/tt&gt;, will parse as a server-based
                  authority. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; IPv6 addresses are permitted for the host component.  An IPv6
                  address must be enclosed in square brackets (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and
                  &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;) as specified by &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;.  The
                  IPv6 address itself must parse according to &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;.  IPv6
                  addresses are further constrained to describe no more than sixteen
                  bytes of address information, a constraint implicit in RFC&amp;nbsp;2373
                  but not expressible in the grammar. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Characters in the &lt;i&gt;other&lt;/i&gt; category are permitted wherever
                  RFC&amp;nbsp;2396 permits &lt;i&gt;escaped&lt;/i&gt; octets, that is, in the
                  user-information, path, query, and fragment components, as well as in
                  the authority component if the authority is registry-based.  This
                  allows URIs to contain Unicode characters beyond those in the US-ASCII
                  character set. &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;                
                <param>
                    str   The string to be parsed into a URI                    
                </param>
                <throws>
                    NullPointerExceptionIf <tt>str</tt> is <tt>null</tt>                    
                </throws>
                <throws>
                    URISyntaxExceptionIf the given string violates RFC&nbsp;2396, as augmented
                      by the above deviations                    
                </throws>
            </javadoc>
            <method name="URI" type="constructor" line="594">
                <params>
                    <param name="str" type="String"/>
                </params>
            </method>
            <javadoc line="598">
                Constructs a hierarchical URI from the given components.
                  &lt;p&gt; If a scheme is given then the path, if also given, must either be
                  empty or begin with a slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;).  Otherwise a
                  component of the new URI may be left undefined by passing &lt;tt&gt;null&lt;/tt&gt;
                  for the corresponding parameter or, in the case of the &lt;tt&gt;port&lt;/tt&gt;
                  parameter, by passing &lt;tt&gt;-1&lt;/tt&gt;.
                  &lt;p&gt; This constructor first builds a URI string from the given components
                  according to the rules specified in &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
                  section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;&lt;p&gt; Initially, the result string is empty. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
                  followed by a colon character (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;).  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If user information, a host, or a port are given then the
                  string &lt;tt&gt;&quot;//&quot;&lt;/tt&gt; is appended.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If user information is given then it is appended, followed by
                  a commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;).  Any character not in the
                  &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
                  categories is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a host is given then it is appended.  If the host is a
                  literal IPv6 address but is not enclosed in square brackets
                  (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;) then the square brackets are added.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a port number is given then a colon character
                  (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;) is appended, followed by the port number in decimal.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
                  the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
                  categories, and not equal to the slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;) or the
                  commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;), is quoted.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
                  (&lt;tt&gt;&apos;?&apos;&lt;/tt&gt;) is appended, followed by the query.  Any character that
                  is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
                  (&lt;tt&gt;&apos;#&apos;&lt;/tt&gt;) is appended, followed by the fragment.  Any character
                  that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ol&gt;
                  &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link #URI(String)} constructor and then invoking the {@link #parseServerAuthority()} method upon the result; this may cause a {@link URISyntaxException} to be thrown.  &lt;/p&gt;                
                <param>
                    scheme    Scheme name                    
                </param>
                <param>
                    userInfo  User name and authorization information                    
                </param>
                <param>
                    host      Host name                    
                </param>
                <param>
                    port      Port number                    
                </param>
                <param>
                    path      Path                    
                </param>
                <param>
                    query     Query                    
                </param>
                <param>
                    fragment  Fragment                    
                </param>
                <throws>
                    URISyntaxExceptionIf both a scheme and a path are given but the path is relative,
                      if the URI string constructed from the given components violates
                      RFC&nbsp;2396, or if the authority component of the string is
                      present but cannot be parsed as a server-based authority                    
                </throws>
            </javadoc>
            <method name="URI" type="constructor" line="675">
                <params>
                    <param name="scheme" type="String"/>
                    <param name="userInfo" type="String"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="path" type="String"/>
                    <param name="query" type="String"/>
                    <param name="fragment" type="String"/>
                </params>
                <declaration name="s" type="String" line="676"/>
            </method>
            <javadoc line="683">
                Constructs a hierarchical URI from the given components.
                  &lt;p&gt; If a scheme is given then the path, if also given, must either be
                  empty or begin with a slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;).  Otherwise a
                  component of the new URI may be left undefined by passing &lt;tt&gt;null&lt;/tt&gt;
                  for the corresponding parameter.
                  &lt;p&gt; This constructor first builds a URI string from the given components
                  according to the rules specified in &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
                  section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
                  followed by a colon character (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;).  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If an authority is given then the string &lt;tt&gt;&quot;//&quot;&lt;/tt&gt; is
                  appended, followed by the authority.  If the authority contains a
                  literal IPv6 address then the address must be enclosed in square
                  brackets (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;).  Any character not in the
                  &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
                  categories, and not equal to the commercial-at character
                  (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;), is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
                  the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
                  categories, and not equal to the slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;) or the
                  commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;), is quoted.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
                  (&lt;tt&gt;&apos;?&apos;&lt;/tt&gt;) is appended, followed by the query.  Any character that
                  is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
                  (&lt;tt&gt;&apos;#&apos;&lt;/tt&gt;) is appended, followed by the fragment.  Any character
                  that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ol&gt;
                  &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link #URI(String)} constructor and then invoking the {@link #parseServerAuthority()} method upon the result; this may cause a {@link URISyntaxException} to be thrown.  &lt;/p&gt;                
                <param>
                    scheme     Scheme name                    
                </param>
                <param>
                    authority  Authority                    
                </param>
                <param>
                    path       Path                    
                </param>
                <param>
                    query      Query                    
                </param>
                <param>
                    fragment   Fragment                    
                </param>
                <throws>
                    URISyntaxExceptionIf both a scheme and a path are given but the path is relative,
                      if the URI string constructed from the given components violates
                      RFC&nbsp;2396, or if the authority component of the string is
                      present but cannot be parsed as a server-based authority                    
                </throws>
            </javadoc>
            <method name="URI" type="constructor" line="748">
                <params>
                    <param name="scheme" type="String"/>
                    <param name="authority" type="String"/>
                    <param name="path" type="String"/>
                    <param name="query" type="String"/>
                    <param name="fragment" type="String"/>
                </params>
                <declaration name="s" type="String" line="749"/>
            </method>
            <javadoc line="756">
                Constructs a hierarchical URI from the given components.
                  &lt;p&gt; A component may be left undefined by passing &lt;tt&gt;null&lt;/tt&gt;.
                  &lt;p&gt; This convenience constructor works as if by invoking the
                  seven-argument constructor as follows:
                  &lt;blockquote&gt;&lt;tt&gt;
                  new&amp;nbsp;{@link #URI(String,String,String,int,String,String,String)URI}(scheme,&amp;nbsp;null,&amp;nbsp;host,&amp;nbsp;-1,&amp;nbsp;path,&amp;nbsp;null,&amp;nbsp;fragment);
                  &lt;/tt&gt;&lt;/blockquote&gt;                
                <param>
                    scheme    Scheme name                    
                </param>
                <param>
                    host      Host name                    
                </param>
                <param>
                    path      Path                    
                </param>
                <param>
                    fragment  Fragment                    
                </param>
                <throws>
                    URISyntaxExceptionIf the URI string constructed from the given components
                      violates RFC&nbsp;2396                    
                </throws>
            </javadoc>
            <method name="URI" type="constructor" line="780">
                <params>
                    <param name="scheme" type="String"/>
                    <param name="host" type="String"/>
                    <param name="path" type="String"/>
                    <param name="fragment" type="String"/>
                </params>
            </method>
            <javadoc line="784">
                Constructs a URI from the given components.
                  &lt;p&gt; A component may be left undefined by passing &lt;tt&gt;null&lt;/tt&gt;.
                  &lt;p&gt; This constructor first builds a URI in string form using the given
                  components as follows:  &lt;/p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
                  followed by a colon character (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;).  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a scheme-specific part is given then it is appended.  Any
                  character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt;
                  is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
                  (&lt;tt&gt;&apos;#&apos;&lt;/tt&gt;) is appended to the string, followed by the fragment.
                  Any character that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ol&gt;
                  &lt;p&gt; The resulting URI string is then parsed in order to create the new
                  URI instance as if by invoking the {@link #URI(String)} constructor;
                  this may cause a {@link URISyntaxException} to be thrown.  &lt;/p&gt;                
                <param>
                    scheme    Scheme name                    
                </param>
                <param>
                    ssp       Scheme-specific part                    
                </param>
                <param>
                    fragment  Fragment                    
                </param>
                <throws>
                    URISyntaxExceptionIf the URI string constructed from the given components
                      violates RFC&nbsp;2396                    
                </throws>
            </javadoc>
            <method name="URI" type="constructor" line="823">
                <params>
                    <param name="scheme" type="String"/>
                    <param name="ssp" type="String"/>
                    <param name="fragment" type="String"/>
                </params>
            </method>
            <javadoc line="830">
                Creates a URI by parsing the given string.
                  &lt;p&gt; This convenience factory method works as if by invoking the {@link #URI(String)} constructor; any {@link URISyntaxException} thrown by the
                  constructor is caught and wrapped in a new {@link IllegalArgumentException} object, which is then thrown.
                  &lt;p&gt; This method is provided for use in situations where it is known that
                  the given string is a legal URI, for example for URI constants declared
                  within in a program, and so it would be considered a programming error
                  for the string not to parse as such.  The constructors, which throw{@link URISyntaxException} directly, should be used situations where a
                  URI is being constructed from user input or from some other source that
                  may be prone to errors.  &lt;/p&gt;                
                <param>
                    str   The string to be parsed into a URI                    
                </param>
                <return>
                    The new URI                    
                </return>
                <throws>
                    NullPointerExceptionIf <tt>str</tt> is <tt>null</tt>                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf the given string violates RFC&nbsp;2396                    
                </throws>
            </javadoc>
            <method name="create" type="URI" line="855">
                <params>
                    <param name="str" type="String"/>
                </params>
                <scope line="856"/>
                <scope line="858"/>
            </method>
            <javadoc line="866">
                Attempts to parse this URI&apos;s authority component, if defined, into
                  user-information, host, and port components.
                  &lt;p&gt; If this URI&apos;s authority component has already been recognized as
                  being server-based then it will already have been parsed into
                  user-information, host, and port components.  In this case, or if this
                  URI has no authority component, this method simply returns this URI.
                  &lt;p&gt; Otherwise this method attempts once more to parse the authority
                  component into user-information, host, and port components, and throws
                  an exception describing why the authority component could not be parsed
                  in that way.
                  &lt;p&gt; This method is provided because the generic URI syntax specified in
                  &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
                  cannot always distinguish a malformed server-based authority from a
                  legitimate registry-based authority.  It must therefore treat some
                  instances of the former as instances of the latter.  The authority
                  component in the URI string &lt;tt&gt;&quot;//foo:bar&quot;&lt;/tt&gt;, for example, is not a
                  legal server-based authority but it is legal as a registry-based
                  authority.
                  &lt;p&gt; In many common situations, for example when working URIs that are
                  known to be either URNs or URLs, the hierarchical URIs being used will
                  always be server-based.  They therefore must either be parsed as such or
                  treated as an error.  In these cases a statement such as
                  &lt;blockquote&gt;
                  &lt;tt&gt;URI &lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt; = new URI(str).parseServerAuthority();&lt;/tt&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt; can be used to ensure that &lt;i&gt;u&lt;/i&gt; always refers to a URI that, if
                  it has an authority component, has a server-based authority with proper
                  user-information, host, and port components.  Invoking this method also
                  ensures that if the authority could not be parsed in that way then an
                  appropriate diagnostic message can be issued based upon the exception
                  that is thrown. &lt;/p&gt;                
                <return>
                    A URI whose authority field has been parsed
                      as a server-based authority                    
                </return>
                <throws>
                    URISyntaxExceptionIf the authority component of this URI is defined
                      but cannot be parsed as a server-based authority
                      according to RFC&nbsp;2396                    
                </throws>
            </javadoc>
            <method name="parseServerAuthority" type="URI" line="915">
                <comment line="916">
                    We could be clever and cache the error message and index from the                    
                </comment>
                <comment line="917">
                    exception thrown during the original parse, but that would require                    
                </comment>
                <comment line="918">
                    either more fields or a more-obscure representation.                    
                </comment>
            </method>
            <javadoc line="926">
                Normalizes this URI&apos;s path.
                  &lt;p&gt; If this URI is opaque, or if its path is already in normal form,
                  then this URI is returned.  Otherwise a new URI is constructed that is
                  identical to this URI except that its path is computed by normalizing
                  this URI&apos;s path in a manner consistent with &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
                  section&amp;nbsp;5.2, step&amp;nbsp;6, sub-steps&amp;nbsp;c through&amp;nbsp;f; that is:
                  &lt;/p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;&lt;p&gt; All &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; segments are removed. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segment is preceded by a non-&lt;tt&gt;&quot;..&quot;&lt;/tt&gt;
                  segment then both of these segments are removed.  This step is
                  repeated until it is no longer applicable. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If the path is relative, and if its first segment contains a
                  colon character (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;), then a &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; segment is
                  prepended.  This prevents a relative URI with a path such as
                  &lt;tt&gt;&quot;a:b/c/d&quot;&lt;/tt&gt; from later being re-parsed as an opaque URI with a
                  scheme of &lt;tt&gt;&quot;a&quot;&lt;/tt&gt; and a scheme-specific part of &lt;tt&gt;&quot;b/c/d&quot;&lt;/tt&gt;.
                  &lt;b&gt;&lt;i&gt;(Deviation from RFC&amp;nbsp;2396)&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;&lt;/li&gt;
                  &lt;/ol&gt;
                  &lt;p&gt; A normalized path will begin with one or more &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segments
                  if there were insufficient non-&lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segments preceding them to
                  allow their removal.  A normalized path will begin with a &lt;tt&gt;&quot;.&quot;&lt;/tt&gt;
                  segment if one was inserted by step 3 above.  Otherwise, a normalized
                  path will not contain any &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; or &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segments. &lt;/p&gt;                
                <return>
                    A URI equivalent to this URI,
                      but whose path is in normal form                    
                </return>
            </javadoc>
            <method name="normalize" type="URI" line="963"/>
            <javadoc line="967">
                Resolves the given URI against this URI.
                  &lt;p&gt; If the given URI is already absolute, or if this URI is opaque, then
                  the given URI is returned.
                  &lt;p&gt;&lt;a name=&quot;resolve-frag&quot;&gt;&lt;/a&gt; If the given URI&apos;s fragment component is
                  defined, its path component is empty, and its scheme, authority, and
                  query components are undefined, then a URI with the given fragment but
                  with all other components equal to those of this URI is returned.  This
                  allows a URI representing a standalone fragment reference, such as
                  &lt;tt&gt;&quot;#foo&quot;&lt;/tt&gt;, to be usefully resolved against a base URI.
                  &lt;p&gt; Otherwise this method constructs a new hierarchical URI in a manner
                  consistent with &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
                  section&amp;nbsp;5.2; that is: &lt;/p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;&lt;p&gt; A new URI is constructed with this URI&apos;s scheme and the given
                  URI&apos;s query and fragment components. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If the given URI has an authority component then the new URI&apos;s
                  authority and path are taken from the given URI. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Otherwise the new URI&apos;s authority component is copied from
                  this URI, and its path is computed as follows: &lt;/p&gt;
                  &lt;ol type=a&gt;
                  &lt;li&gt;&lt;p&gt; If the given URI&apos;s path is absolute then the new URI&apos;s path
                  is taken from the given URI. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Otherwise the given URI&apos;s path is relative, and so the new
                  URI&apos;s path is computed by resolving the path of the given URI
                  against the path of this URI.  This is done by concatenating all but
                  the last segment of this URI&apos;s path, if any, with the given URI&apos;s
                  path and then normalizing the result as if by invoking the {@link #normalize() normalize} method. &lt;/p&gt;&lt;/li&gt;
                  &lt;/ol&gt;&lt;/li&gt;
                  &lt;/ol&gt;
                  &lt;p&gt; The result of this method is absolute if, and only if, either this
                  URI is absolute or the given URI is absolute.  &lt;/p&gt;                
                <param>
                    uri  The URI to be resolved against this URI                    
                </param>
                <return>
                    The resulting URI                    
                </return>
                <throws>
                    NullPointerExceptionIf <tt>uri</tt> is <tt>null</tt>                    
                </throws>
            </javadoc>
            <method name="resolve" type="URI" line="1021">
                <params>
                    <param name="uri" type="URI"/>
                </params>
            </method>
            <javadoc line="1025">
                Constructs a new URI by parsing the given string and then resolving it
                  against this URI.
                  &lt;p&gt; This convenience method works as if invoking it were equivalent to
                  evaluating the expression &lt;tt&gt;{@link #resolve(java.net.URI)resolve}(URI.{@link #create(String) create}(str))&lt;/tt&gt;. &lt;/p&gt;                
                <param>
                    str   The string to be parsed into a URI                    
                </param>
                <return>
                    The resulting URI                    
                </return>
                <throws>
                    NullPointerExceptionIf <tt>str</tt> is <tt>null</tt>                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf the given string violates RFC&nbsp;2396                    
                </throws>
            </javadoc>
            <method name="resolve" type="URI" line="1042">
                <params>
                    <param name="str" type="String"/>
                </params>
            </method>
            <javadoc line="1046">
                Relativizes the given URI against this URI.
                  &lt;p&gt; The relativization of the given URI against this URI is computed as
                  follows: &lt;/p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;&lt;p&gt; If either this URI or the given URI are opaque, or if the
                  scheme and authority components of the two URIs are not identical, or
                  if the path of this URI is not a prefix of the path of the given URI,
                  then the given URI is returned. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Otherwise a new relative hierarchical URI is constructed with
                  query and fragment components taken from the given URI and with a path
                  component computed by removing this URI&apos;s path from the beginning of
                  the given URI&apos;s path. &lt;/p&gt;&lt;/li&gt;
                  &lt;/ol&gt;                
                <param>
                    uri  The URI to be relativized against this URI                    
                </param>
                <return>
                    The resulting URI                    
                </return>
                <throws>
                    NullPointerExceptionIf <tt>uri</tt> is <tt>null</tt>                    
                </throws>
            </javadoc>
            <method name="relativize" type="URI" line="1072">
                <params>
                    <param name="uri" type="URI"/>
                </params>
            </method>
            <javadoc line="1076">
                Constructs a URL from this URI.
                  &lt;p&gt; This convenience method works as if invoking it were equivalent to
                  evaluating the expression &lt;tt&gt;new&amp;nbsp;URL(this.toString())&lt;/tt&gt; after
                  first checking that this URI is absolute. &lt;/p&gt;                
                <return>
                    A URL constructed from this URI                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf this URL is not absolute                    
                </throws>
                <throws>
                    MalformedURLExceptionIf a protocol handler for the URL could not be found,
                      or if some other error occurred while constructing the URL                    
                </throws>
            </javadoc>
            <method name="toURL" type="URL" line="1093"/>
            <javadoc line="1101">
                Returns the scheme component of this URI.
                  &lt;p&gt; The scheme component of a URI, if defined, only contains characters
                  in the &lt;i&gt;alphanum&lt;/i&gt; category and in the string &lt;tt&gt;&quot;-.+&quot;&lt;/tt&gt;.  A
                  scheme always starts with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;p&gt;
                  The scheme component of a URI cannot contain escaped octets, hence this
                  method does not perform any decoding.                
                <return>
                    The scheme component of this URI,
                      or <tt>null</tt> if the scheme is undefined                    
                </return>
            </javadoc>
            <method name="getScheme" type="String" line="1114"/>
            <javadoc line="1118">
                Tells whether or not this URI is absolute.
                  &lt;p&gt; A URI is absolute if, and only if, it has a scheme component. &lt;/p&gt;                
                <return>
                    <tt>true</tt> if, and only if, this URI is absolute                    
                </return>
            </javadoc>
            <method name="isAbsolute" type="boolean" line="1125"/>
            <javadoc line="1129">
                Tells whether or not this URI is opaque.
                  &lt;p&gt; A URI is opaque if, and only if, it is absolute and its
                  scheme-specific part does not begin with a slash character (&apos;/&apos;).
                  An opaque URI has a scheme, a scheme-specific part, and possibly
                  a fragment; all other components are undefined. &lt;/p&gt;                
                <return>
                    <tt>true</tt> if, and only if, this URI is opaque                    
                </return>
            </javadoc>
            <method name="isOpaque" type="boolean" line="1139"/>
            <javadoc line="1143">
                Returns the raw scheme-specific part of this URI.  The scheme-specific
                  part is never undefined, though it may be empty.
                  &lt;p&gt; The scheme-specific part of a URI only contains legal URI
                  characters. &lt;/p&gt;                
                <return>
                    The raw scheme-specific part of this URI
                      (never <tt>null</tt>)                    
                </return>
            </javadoc>
            <method name="getRawSchemeSpecificPart" type="String" line="1153"/>
            <javadoc line="1158">
                Returns the decoded scheme-specific part of this URI.
                  &lt;p&gt; The string returned by this method is equal to that returned by the{@link #getRawSchemeSpecificPart() getRawSchemeSpecificPart} method
                  except that all sequences of escaped octets are &lt;a
                  href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;                
                <return>
                    The decoded scheme-specific part of this URI
                      (never <tt>null</tt>)                    
                </return>
            </javadoc>
            <method name="getSchemeSpecificPart" type="String" line="1169"/>
            <javadoc line="1175">
                Returns the raw authority component of this URI.
                  &lt;p&gt; The authority component of a URI, if defined, only contains the
                  commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;) and characters in the
                  &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
                  categories.  If the authority is server-based then it is further
                  constrained to have valid user-information, host, and port
                  components. &lt;/p&gt;                
                <return>
                    The raw authority component of this URI,
                      or <tt>null</tt> if the authority is undefined                    
                </return>
            </javadoc>
            <method name="getRawAuthority" type="String" line="1188"/>
            <javadoc line="1192">
                Returns the decoded authority component of this URI.
                  &lt;p&gt; The string returned by this method is equal to that returned by the{@link #getRawAuthority() getRawAuthority} method except that all
                  sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;                
                <return>
                    The decoded authority component of this URI,
                      or <tt>null</tt> if the authority is undefined                    
                </return>
            </javadoc>
            <method name="getAuthority" type="String" line="1202"/>
            <javadoc line="1208">
                Returns the raw user-information component of this URI.
                  &lt;p&gt; The user-information component of a URI, if defined, only contains
                  characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and
                  &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;                
                <return>
                    The raw user-information component of this URI,
                      or <tt>null</tt> if the user information is undefined                    
                </return>
            </javadoc>
            <method name="getRawUserInfo" type="String" line="1218"/>
            <javadoc line="1222">
                Returns the decoded user-information component of this URI.
                  &lt;p&gt; The string returned by this method is equal to that returned by the{@link #getRawUserInfo() getRawUserInfo} method except that all
                  sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;                
                <return>
                    The decoded user-information component of this URI,
                      or <tt>null</tt> if the user information is undefined                    
                </return>
            </javadoc>
            <method name="getUserInfo" type="String" line="1232"/>
            <javadoc line="1238">
                Returns the host component of this URI.
                  &lt;p&gt; The host component of a URI, if defined, will have one of the
                  following forms: &lt;/p&gt;
                  &lt;ul type=disc&gt;
                  &lt;li&gt;&lt;p&gt; A domain name consisting of one or more &lt;i&gt;labels&lt;/i&gt;
                  separated by period characters (&lt;tt&gt;&apos;.&apos;&lt;/tt&gt;), optionally followed by
                  a period character.  Each label consists of &lt;i&gt;alphanum&lt;/i&gt; characters
                  as well as hyphen characters (&lt;tt&gt;&apos;-&apos;&lt;/tt&gt;), though hyphens never
                  occur as the first or last characters in a label. The rightmost
                  label of a domain name consisting of two or more labels, begins
                  with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; A dotted-quad IPv4 address of the form
                  &lt;i&gt;digit&lt;/i&gt;&lt;tt&gt;+.&lt;/tt&gt;&lt;i&gt;digit&lt;/i&gt;&lt;tt&gt;+.&lt;/tt&gt;&lt;i&gt;digit&lt;/i&gt;&lt;tt&gt;+.&lt;/tt&gt;&lt;i&gt;digit&lt;/i&gt;&lt;tt&gt;+&lt;/tt&gt;,
                  where no &lt;i&gt;digit&lt;/i&gt; sequence is longer than three characters and no
                  sequence has a value larger than 255. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; An IPv6 address enclosed in square brackets (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and
                  &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;) and consisting of hexadecimal digits, colon characters
                  (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;), and possibly an embedded IPv4 address.  The full
                  syntax of IPv6 addresses is specified in &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6
                  Addressing Architecture&lt;/i&gt;&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  The host component of a URI cannot contain escaped octets, hence this
                  method does not perform any decoding.                
                <return>
                    The host component of this URI,
                      or <tt>null</tt> if the host is undefined                    
                </return>
            </javadoc>
            <method name="getHost" type="String" line="1274"/>
            <javadoc line="1278">
                Returns the port number of this URI.
                  &lt;p&gt; The port component of a URI, if defined, is a non-negative
                  integer. &lt;/p&gt;                
                <return>
                    The port component of this URI,
                      or <tt>-1</tt> if the port is undefined                    
                </return>
            </javadoc>
            <method name="getPort" type="int" line="1287"/>
            <javadoc line="1291">
                Returns the raw path component of this URI.
                  &lt;p&gt; The path component of a URI, if defined, only contains the slash
                  character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;), the commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;),
                  and characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;,
                  and &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;                
                <return>
                    The path component of this URI,
                      or <tt>null</tt> if the path is undefined                    
                </return>
            </javadoc>
            <method name="getRawPath" type="String" line="1302"/>
            <javadoc line="1306">
                Returns the decoded path component of this URI.
                  &lt;p&gt; The string returned by this method is equal to that returned by the{@link #getRawPath() getRawPath} method except that all sequences of
                  escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;                
                <return>
                    The decoded path component of this URI,
                      or <tt>null</tt> if the path is undefined                    
                </return>
            </javadoc>
            <method name="getPath" type="String" line="1316"/>
            <javadoc line="1322">
                Returns the raw query component of this URI.
                  &lt;p&gt; The query component of a URI, if defined, only contains legal URI
                  characters. &lt;/p&gt;                
                <return>
                    The raw query component of this URI,
                      or <tt>null</tt> if the query is undefined                    
                </return>
            </javadoc>
            <method name="getRawQuery" type="String" line="1331"/>
            <javadoc line="1335">
                Returns the decoded query component of this URI.
                  &lt;p&gt; The string returned by this method is equal to that returned by the{@link #getRawQuery() getRawQuery} method except that all sequences of
                  escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;                
                <return>
                    The decoded query component of this URI,
                      or <tt>null</tt> if the query is undefined                    
                </return>
            </javadoc>
            <method name="getQuery" type="String" line="1345"/>
            <javadoc line="1351">
                Returns the raw fragment component of this URI.
                  &lt;p&gt; The fragment component of a URI, if defined, only contains legal URI
                  characters. &lt;/p&gt;                
                <return>
                    The raw fragment component of this URI,
                      or <tt>null</tt> if the fragment is undefined                    
                </return>
            </javadoc>
            <method name="getRawFragment" type="String" line="1360"/>
            <javadoc line="1364">
                Returns the decoded fragment component of this URI.
                  &lt;p&gt; The string returned by this method is equal to that returned by the{@link #getRawFragment() getRawFragment} method except that all
                  sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;                
                <return>
                    The decoded fragment component of this URI,
                      or <tt>null</tt> if the fragment is undefined                    
                </return>
            </javadoc>
            <method name="getFragment" type="String" line="1374"/>
            <javadoc line="1383">
                Tests this URI for equality with another object.
                  &lt;p&gt; If the given object is not a URI then this method immediately
                  returns &lt;tt&gt;false&lt;/tt&gt;.
                  &lt;p&gt; For two URIs to be considered equal requires that either both are
                  opaque or both are hierarchical.  Their schemes must either both be
                  undefined or else be equal without regard to case. Their fragments
                  must either both be undefined or else be equal.
                  &lt;p&gt; For two opaque URIs to be considered equal, their scheme-specific
                  parts must be equal.
                  &lt;p&gt; For two hierarchical URIs to be considered equal, their paths must
                  be equal and their queries must either both be undefined or else be
                  equal.  Their authorities must either both be undefined, or both be
                  registry-based, or both be server-based.  If their authorities are
                  defined and are registry-based, then they must be equal.  If their
                  authorities are defined and are server-based, then their hosts must be
                  equal without regard to case, their port numbers must be equal, and
                  their user-information components must be equal.
                  &lt;p&gt; When testing the user-information, path, query, fragment, authority,
                  or scheme-specific parts of two URIs for equality, the raw forms rather
                  than the encoded forms of these components are compared and the
                  hexadecimal digits of escaped octets are compared without regard to
                  case.
                  &lt;p&gt; This method satisfies the general contract of the {@link java.lang.Object#equals(Object) Object.equals} method. &lt;/p&gt;                
                <param>
                    ob   The object to which this object is to be compared                    
                </param>
                <return>
                    <tt>true</tt> if, and only if, the given object is a URI that
                      is identical to this URI                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1420">
                <params>
                    <param name="ob" type="Object"/>
                </params>
                <comment line="1430">
                    Opaque                    
                </comment>
                <comment line="1434">
                    Hierarchical                    
                </comment>
                <comment line="1438">
                    Authorities                    
                </comment>
                <comment line="1441">
                    Server-based                    
                </comment>
                <comment line="1446">
                    Registry-based                    
                </comment>
                <declaration name="that" type="URI" line="1425"/>
                <scope line="1440"/>
                <scope line="1445"/>
                <scope line="1448"/>
            </method>
            <javadoc line="1455">
                Returns a hash-code value for this URI.  The hash code is based upon all
                  of the URI&apos;s components, and satisfies the general contract of the{@link java.lang.Object#hashCode() Object.hashCode} method.                
                <return>
                    A hash-code value for this URI                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="1462">
                <declaration name="h" type="int" line="1465"/>
                <scope line="1467"/>
                <scope line="1469">
                    <scope line="1472"/>
                    <scope line="1476"/>
                </scope>
            </method>
            <javadoc line="1484">
                Compares this URI to another object, which must be a URI.
                  &lt;p&gt; When comparing corresponding components of two URIs, if one
                  component is undefined but the other is defined then the first is
                  considered to be less than the second.  Unless otherwise noted, string
                  components are ordered according to their natural, case-sensitive
                  ordering as defined by the {@link java.lang.String#compareTo(Object)String.compareTo} method.  String components that are subject to
                  encoding are compared by comparing their raw forms rather than their
                  encoded forms.
                  &lt;p&gt; The ordering of URIs is defined as follows: &lt;/p&gt;
                  &lt;ul type=disc&gt;
                  &lt;li&gt;&lt;p&gt; Two URIs with different schemes are ordered according the
                  ordering of their schemes, without regard to case. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; A hierarchical URI is considered to be less than an opaque URI
                  with an identical scheme. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes are ordered according
                  to the ordering of their scheme-specific parts. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes and scheme-specific
                  parts are ordered according to the ordering of their
                  fragments. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Two hierarchical URIs with identical schemes are ordered
                  according to the ordering of their authority components: &lt;/p&gt;
                  &lt;ul type=disc&gt;
                  &lt;li&gt;&lt;p&gt; If both authority components are server-based then the URIs
                  are ordered according to their user-information components; if these
                  components are identical then the URIs are ordered according to the
                  ordering of their hosts, without regard to case; if the hosts are
                  identical then the URIs are ordered according to the ordering of
                  their ports. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If one or both authority components are registry-based then
                  the URIs are ordered according to the ordering of their authority
                  components. &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Finally, two hierarchical URIs with identical schemes and
                  authority components are ordered according to the ordering of their
                  paths; if their paths are identical then they are ordered according to
                  the ordering of their queries; if the queries are identical then they
                  are ordered according to the order of their fragments. &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt; This method satisfies the general contract of the {@link java.lang.Comparable#compareTo(Object) Comparable.compareTo}method. &lt;/p&gt;                
                <param>
                    thatThe object to which this URI is to be compared                    
                </param>
                <return>
                    A negative integer, zero, or a positive integer as this URI is
                      less than, equal to, or greater than the given URI                    
                </return>
                <throws>
                    ClassCastExceptionIf the given object is not a URI                    
                </throws>
            </javadoc>
            <method name="compareTo" type="int" line="1552">
                <params>
                    <param name="that" type="URI"/>
                </params>
                <comment line="1560">
                    Both opaque                    
                </comment>
                <comment line="1566">
                    Opaque &gt; hierarchical                    
                </comment>
                <comment line="1568">
                    Hierarchical &lt; opaque                    
                </comment>
                <comment line="1571">
                    Hierarchical                    
                </comment>
                <comment line="1573">
                    Both server-based                    
                </comment>
                <comment line="1581">
                    If one or both authorities are registry-based then we simply                    
                </comment>
                <comment line="1582">
                    compare them in the usual, case-sensitive way.  If one is                    
                </comment>
                <comment line="1583">
                    registry-based and one is server-based then the strings are                    
                </comment>
                <comment line="1584">
                    guaranteed to be unequal, hence the comparison will never return                    
                </comment>
                <comment line="1585">
                    zero and the compareTo and equals methods will remain                    
                </comment>
                <comment line="1586">
                    consistent.                    
                </comment>
                <declaration name="c" type="int" line="1553"/>
                <scope line="1558">
                    <scope line="1559"/>
                </scope>
                <scope line="1567"/>
                <scope line="1572"/>
                <scope line="1580"/>
            </method>
            <javadoc line="1595">
                Returns the content of this URI as a string.
                  &lt;p&gt; If this URI was created by invoking one of the constructors in this
                  class then a string equivalent to the original input string, or to the
                  string computed from the originally-given components, as appropriate, is
                  returned.  Otherwise this URI was created by normalization, resolution,
                  or relativization, and so a string is constructed from this URI&apos;s
                  components according to the rules specified in &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
                  section&amp;nbsp;5.2, step&amp;nbsp;7. &lt;/p&gt;                
                <return>
                    The string form of this URI                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1609"/>
            <javadoc line="1614">
                Returns the content of this URI as a US-ASCII string.
                  &lt;p&gt; If this URI does not contain any characters in the &lt;i&gt;other&lt;/i&gt;
                  category then an invocation of this method will return the same value as
                  an invocation of the {@link #toString() toString} method.  Otherwise
                  this method works as if by invoking that method and then &lt;a
                  href=&quot;#encode&quot;&gt;encoding&lt;/a&gt; the result.  &lt;/p&gt;                
                <return>
                    The string form of this URI, encoded as needed
                      so that it only contains characters in the US-ASCII
                      charset                    
                </return>
            </javadoc>
            <method name="toASCIIString" type="String" line="1627"/>
            <javadoc line="1635">
                Saves the content of this URI to the given serial stream.
                  &lt;p&gt; The only serializable field of a URI instance is its &lt;tt&gt;string&lt;/tt&gt;
                  field.  That field is given a value, if it does not have one already,
                  and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}method of the given object-output stream is invoked. &lt;/p&gt;                
                <param>
                    os  The object-output stream to which this object
                      is to be written                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="1648">
                <params>
                    <param name="os" type="ObjectOutputStream"/>
                </params>
                <comment line="1650">
                    Writes the string field only                    
                </comment>
            </method>
            <javadoc line="1653">
                Reconstitutes a URI from the given serial stream.
                  &lt;p&gt; The {@link java.io.ObjectInputStream#defaultReadObject()} method is
                  invoked to read the value of the &lt;tt&gt;string&lt;/tt&gt; field.  The result is
                  then parsed in the usual way.                
                <param>
                    is  The object-input stream from which this object
                      is being read                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="1665">
                <params>
                    <param name="is" type="ObjectInputStream"/>
                </params>
                <comment line="1666">
                    Argh                    
                </comment>
                <scope line="1668"/>
                <scope line="1670">
                    <declaration name="y" type="IOException" line="1671"/>
                </scope>
            </method>
            <method name="toLower" type="int" line="1691">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <method name="equal" type="boolean" line="1697">
                <params>
                    <param name="s" type="String"/>
                    <param name="t" type="String"/>
                </params>
                <scope line="1699">
                    <declaration name="n" type="int" line="1704"/>
                    <scope line="1705">
                        <declaration name="c" type="char" line="1706"/>
                        <declaration name="d" type="char" line="1707"/>
                        <scope line="1708"/>
                    </scope>
                </scope>
            </method>
            <method name="equalIgnoringCase" type="boolean" line="1728">
                <params>
                    <param name="s" type="String"/>
                    <param name="t" type="String"/>
                </params>
                <scope line="1730">
                    <declaration name="n" type="int" line="1731"/>
                    <scope line="1734"/>
                </scope>
            </method>
            <method name="hash" type="int" line="1743">
                <params>
                    <param name="hash" type="int"/>
                    <param name="s" type="String"/>
                </params>
            </method>
            <method name="hashIgnoringCase" type="int" line="1749">
                <params>
                    <param name="hash" type="int"/>
                    <param name="s" type="String"/>
                </params>
                <declaration name="h" type="int" line="1751"/>
                <declaration name="n" type="int" line="1752"/>
            </method>
            <method name="compare" type="int" line="1758">
                <params>
                    <param name="s" type="String"/>
                    <param name="t" type="String"/>
                </params>
                <scope line="1760"/>
                <scope line="1765"/>
            </method>
            <method name="compareIgnoringCase" type="int" line="1771">
                <params>
                    <param name="s" type="String"/>
                    <param name="t" type="String"/>
                </params>
                <scope line="1773">
                    <scope line="1774">
                        <declaration name="sn" type="int" line="1775"/>
                        <declaration name="tn" type="int" line="1776"/>
                        <declaration name="n" type="int" line="1777"/>
                        <scope line="1778">
                            <declaration name="c" type="int" line="1779"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1786"/>
            </method>
            <method name="checkPath" type="void" line="1798">
                <params>
                    <param name="s" type="String"/>
                    <param name="scheme" type="String"/>
                    <param name="path" type="String"/>
                </params>
                <scope line="1799"/>
            </method>
            <method name="appendAuthority" type="void" line="1812">
                <params>
                    <param name="sb" type="StringBuffer"/>
                    <param name="authority" type="String"/>
                    <param name="userInfo" type="String"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
                <comment line="1832">
                    authority should (but may not) contain an embedded IPv6 address                    
                </comment>
                <comment line="1836">
                    the authority contains an IPv6 address                    
                </comment>
                <scope line="1813">
                    <scope line="1815"/>
                    <declaration name="needBrackets" type="boolean" line="1819"/>
                    <scope line="1825"/>
                </scope>
                <scope line="1829">
                    <scope line="1831">
                        <declaration name="end" type="int" line="1833"/>
                        <declaration name="doquote" type="String" line="1834"/>
                        <scope line="1835">
                            <scope line="1837"/>
                            <scope line="1840"/>
                        </scope>
                    </scope>
                    <scope line="1849"/>
                </scope>
            </method>
            <method name="appendSchemeSpecificPart" type="void" line="1865">
                <params>
                    <param name="sb" type="StringBuffer"/>
                    <param name="opaquePart" type="String"/>
                    <param name="authority" type="String"/>
                    <param name="userInfo" type="String"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="path" type="String"/>
                    <param name="query" type="String"/>
                </params>
                <comment line="1867">
                    check if SSP begins with an IPv6 address
                     because we must not quote a literal IPv6 address                    
                </comment>
                <scope line="1866">
                    <scope line="1870">
                        <declaration name="end" type="int" line="1871"/>
                        <scope line="1872">
                            <declaration name="doquote" type="String" line="1873"/>
                            <scope line="1874"/>
                            <scope line="1877"/>
                        </scope>
                    </scope>
                    <scope line="1884"/>
                </scope>
                <scope line="1887">
                    <scope line="1891"/>
                </scope>
            </method>
            <method name="appendFragment" type="void" line="1898">
                <params>
                    <param name="sb" type="StringBuffer"/>
                    <param name="fragment" type="String"/>
                </params>
                <scope line="1899"/>
            </method>
            <method name="toString" type="String" line="1914">
                <params>
                    <param name="scheme" type="String"/>
                    <param name="opaquePart" type="String"/>
                    <param name="authority" type="String"/>
                    <param name="userInfo" type="String"/>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="path" type="String"/>
                    <param name="query" type="String"/>
                    <param name="fragment" type="String"/>
                </params>
                <declaration name="sb" type="StringBuffer" line="1915"/>
                <scope line="1916"/>
            </method>
            <method name="defineSchemeSpecificPart" type="void" line="1927">
                <declaration name="sb" type="StringBuffer" line="1929"/>
            </method>
            <method name="defineString" type="void" line="1936">
                <declaration name="sb" type="StringBuffer" line="1939"/>
                <scope line="1940"/>
                <scope line="1944"/>
                <scope line="1946">
                    <scope line="1947">
                        <scope line="1949"/>
                        <declaration name="needBrackets" type="boolean" line="1953"/>
                        <scope line="1959"/>
                    </scope>
                    <scope line="1963"/>
                    <scope line="1969"/>
                </scope>
                <scope line="1974"/>
            </method>
            <method name="resolvePath" type="String" line="1987">
                <params>
                    <param name="base" type="String"/>
                    <param name="child" type="String"/>
                    <param name="absolute" type="boolean"/>
                </params>
                <comment line="1993">
                    5.2 (6a)                    
                </comment>
                <comment line="1998">
                    5.2 (6a)                    
                </comment>
                <comment line="2001">
                    5.2 (6b)                    
                </comment>
                <comment line="2006">
                    5.2 (6c-f)                    
                </comment>
                <comment line="2009">
                    5.2 (6g): If the result is absolute but the path begins with &quot;../&quot;,                    
                </comment>
                <comment line="2010">
                    then we simply leave the path as-is                    
                </comment>
                <declaration name="i" type="int" line="1988"/>
                <declaration name="cn" type="int" line="1989"/>
                <declaration name="path" type="String" line="1990"/>
                <scope line="1992"/>
                <scope line="1996">
                    <declaration name="sb" type="StringBuffer" line="1997"/>
                </scope>
                <declaration name="np" type="String" line="2007"/>
            </method>
            <method name="resolve" type="URI" line="2016">
                <params>
                    <param name="base" type="URI"/>
                    <param name="child" type="URI"/>
                </params>
                <comment line="2017">
                    check if child if opaque first so that NPE is thrown                    
                </comment>
                <comment line="2018">
                    if child is null.                    
                </comment>
                <comment line="2022">
                    5.2 (2): Reference to current document (lone fragment)                    
                </comment>
                <comment line="2042">
                    5.2 (3): Child is absolute                    
                </comment>
                <comment line="2046">
                    Resolved URI                    
                </comment>
                <comment line="2051">
                    5.2 (4): Authority                    
                </comment>
                <comment line="2060">
                    5.2 (5): Child path is absolute                    
                </comment>
                <comment line="2063">
                    5.2 (6): Resolve relative path                    
                </comment>
                <comment line="2075">
                    5.2 (7): Recombine (nothing to do here)                    
                </comment>
                <scope line="2025">
                    <scope line="2027"/>
                    <declaration name="ru" type="URI" line="2030"/>
                </scope>
                <declaration name="ru" type="URI" line="2046"/>
                <scope line="2052">
                    <declaration name="cp" type="String" line="2058"/>
                    <scope line="2059"/>
                    <scope line="2062"/>
                </scope>
                <scope line="2066"/>
            </method>
            <method name="normalize" type="URI" line="2082">
                <params>
                    <param name="u" type="URI"/>
                </params>
                <declaration name="np" type="String" line="2086"/>
                <declaration name="v" type="URI" line="2090"/>
            </method>
            <method name="relativize" type="URI" line="2107">
                <params>
                    <param name="base" type="URI"/>
                    <param name="child" type="URI"/>
                </params>
                <comment line="2108">
                    check if child if opaque first so that NPE is thrown                    
                </comment>
                <comment line="2109">
                    if child is null.                    
                </comment>
                <declaration name="bp" type="String" line="2116"/>
                <declaration name="cp" type="String" line="2117"/>
                <scope line="2118"/>
                <declaration name="v" type="URI" line="2125"/>
            </method>
            <method name="needsNormalization" type="int" line="2157">
                <params>
                    <param name="path" type="String"/>
                </params>
                <comment line="2159">
                    Number of segments                    
                </comment>
                <comment line="2160">
                    Index of last char in path                    
                </comment>
                <comment line="2161">
                    Index of next char in path                    
                </comment>
                <comment line="2163">
                    Skip initial slashes                    
                </comment>
                <comment line="2170">
                    Scan segments                    
                </comment>
                <comment line="2173">
                    Looking at &quot;.&quot; or &quot;..&quot; ?                    
                </comment>
                <comment line="2184">
                    Find beginning of next segment                    
                </comment>
                <comment line="2189">
                    Skip redundant slashes                    
                </comment>
                <declaration name="normal" type="boolean" line="2158"/>
                <declaration name="ns" type="int" line="2159"/>
                <declaration name="end" type="int" line="2160"/>
                <declaration name="p" type="int" line="2161"/>
                <scope line="2164"/>
                <scope line="2171">
                    <scope line="2179"/>
                    <scope line="2185">
                        <scope line="2190"/>
                    </scope>
                </scope>
            </method>
            <method name="split" type="void" line="2214">
                <params>
                    <param name="path" type="char[]"/>
                    <param name="segs" type="int[]"/>
                </params>
                <comment line="2215">
                    Index of last char in path                    
                </comment>
                <comment line="2216">
                    Index of next char in path                    
                </comment>
                <comment line="2217">
                    Index of current segment                    
                </comment>
                <comment line="2219">
                    Skip initial slashes                    
                </comment>
                <comment line="2228">
                    Note start of segment                    
                </comment>
                <comment line="2231">
                    Find beginning of next segment                    
                </comment>
                <comment line="2237">
                    Skip redundant slashes                    
                </comment>
                <comment line="2247">
                    ASSERT                    
                </comment>
                <declaration name="end" type="int" line="2215"/>
                <declaration name="p" type="int" line="2216"/>
                <declaration name="i" type="int" line="2217"/>
                <scope line="2220"/>
                <scope line="2226">
                    <scope line="2232">
                        <scope line="2238"/>
                    </scope>
                </scope>
            </method>
            <method name="join" type="int" line="2263">
                <params>
                    <param name="path" type="char[]"/>
                    <param name="segs" type="int[]"/>
                </params>
                <comment line="2264">
                    Number of segments                    
                </comment>
                <comment line="2265">
                    Index of last char in path                    
                </comment>
                <comment line="2266">
                    Index of next path char to write                    
                </comment>
                <comment line="2269">
                    Restore initial slash for absolute paths                    
                </comment>
                <comment line="2274">
                    Current segment                    
                </comment>
                <comment line="2276">
                    Ignore this segment                    
                </comment>
                <comment line="2280">
                    We&apos;re already at this segment, so just skip to its end                    
                </comment>
                <comment line="2284">
                    Preserve trailing slash                    
                </comment>
                <comment line="2288">
                    Copy q down to p                    
                </comment>
                <comment line="2292">
                    Preserve trailing slash                    
                </comment>
                <comment line="2296">
                    ASSERT false                    
                </comment>
                <declaration name="ns" type="int" line="2264"/>
                <declaration name="end" type="int" line="2265"/>
                <declaration name="p" type="int" line="2266"/>
                <scope line="2268"/>
                <scope line="2273">
                    <declaration name="q" type="int" line="2274"/>
                    <scope line="2279">
                        <scope line="2283"/>
                    </scope>
                    <scope line="2287">
                        <scope line="2291"/>
                    </scope>
                </scope>
            </method>
            <method name="removeDots" type="void" line="2306">
                <params>
                    <param name="path" type="char[]"/>
                    <param name="segs" type="int[]"/>
                </params>
                <comment line="2311">
                    Number of dots found (0, 1, or 2)                    
                </comment>
                <comment line="2313">
                    Find next occurrence of &quot;.&quot; or &quot;..&quot;                    
                </comment>
                <comment line="2336">
                    Remove this occurrence of &quot;.&quot;                    
                </comment>
                <comment line="2339">
                    If there is a preceding non-&quot;..&quot; segment, remove both that                    
                </comment>
                <comment line="2340">
                    segment and this occurrence of &quot;..&quot;; otherwise, leave this                    
                </comment>
                <comment line="2341">
                    &quot;..&quot; segment as-is.                    
                </comment>
                <declaration name="ns" type="int" line="2307"/>
                <declaration name="end" type="int" line="2308"/>
                <scope line="2310">
                    <declaration name="dots" type="int" line="2311"/>
                    <scope line="2314">
                        <declaration name="p" type="int" line="2315"/>
                        <scope line="2316">
                            <scope line="2317"/>
                            <scope line="2320"/>
                            <scope line="2325"/>
                        </scope>
                    </scope>
                    <scope line="2335"/>
                    <scope line="2338">
                        <declaration name="j" type="int" line="2342"/>
                        <scope line="2343"/>
                        <scope line="2346">
                            <declaration name="q" type="int" line="2347"/>
                            <scope line="2350"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="maybeAddLeadingDot" type="void" line="2363">
                <params>
                    <param name="path" type="char[]"/>
                    <param name="segs" type="int[]"/>
                </params>
                <comment line="2366">
                    The path is absolute                    
                </comment>
                <comment line="2370">
                    Index of first segment                    
                </comment>
                <comment line="2377">
                    The path is empty, or else the original first segment survived,                    
                </comment>
                <comment line="2378">
                    in which case we already know that no leading &quot;.&quot; is needed                    
                </comment>
                <comment line="2384">
                    No colon in first segment, so no &quot;.&quot; needed                    
                </comment>
                <comment line="2387">
                    At this point we know that the first segment is unused,                    
                </comment>
                <comment line="2388">
                    hence we can insert a &quot;.&quot; segment at that position                    
                </comment>
                <declaration name="ns" type="int" line="2369"/>
                <declaration name="f" type="int" line="2370"/>
                <scope line="2371"/>
                <declaration name="p" type="int" line="2381"/>
            </method>
            <method name="normalize" type="String" line="2401">
                <params>
                    <param name="ps" type="String"/>
                </params>
                <comment line="2403">
                    Does this path need normalization?                    
                </comment>
                <comment line="2404">
                    Number of segments                    
                </comment>
                <comment line="2406">
                    Nope -- just return it                    
                </comment>
                <comment line="2409">
                    Path in char-array form                    
                </comment>
                <comment line="2411">
                    Split path into segments                    
                </comment>
                <comment line="2412">
                    Segment-index array                    
                </comment>
                <comment line="2415">
                    Remove dots                    
                </comment>
                <comment line="2418">
                    Prevent scheme-name confusion                    
                </comment>
                <comment line="2421">
                    Join the remaining segments and return the result                    
                </comment>
                <comment line="2424">
                    string was already normalized                    
                </comment>
                <declaration name="ns" type="int" line="2404"/>
                <declaration name="path" type="char[]" line="2409"/>
                <declaration name="segs" type="int[]" line="2412"/>
                <declaration name="s" type="String" line="2422"/>
                <scope line="2423"/>
            </method>
            <method name="lowMask" type="long" line="2447">
                <params>
                    <param name="chars" type="String"/>
                </params>
                <declaration name="n" type="int" line="2448"/>
                <declaration name="m" type="long" line="2449"/>
                <scope line="2450">
                    <declaration name="c" type="char" line="2451"/>
                </scope>
            </method>
            <method name="highMask" type="long" line="2459">
                <params>
                    <param name="chars" type="String"/>
                </params>
                <declaration name="n" type="int" line="2460"/>
                <declaration name="m" type="long" line="2461"/>
                <scope line="2462">
                    <declaration name="c" type="char" line="2463"/>
                </scope>
            </method>
            <method name="lowMask" type="long" line="2472">
                <params>
                    <param name="first" type="char"/>
                    <param name="last" type="char"/>
                </params>
                <declaration name="m" type="long" line="2473"/>
                <declaration name="f" type="int" line="2474"/>
                <declaration name="l" type="int" line="2475"/>
            </method>
            <method name="highMask" type="long" line="2483">
                <params>
                    <param name="first" type="char"/>
                    <param name="last" type="char"/>
                </params>
                <declaration name="m" type="long" line="2484"/>
                <declaration name="f" type="int" line="2485"/>
                <declaration name="l" type="int" line="2486"/>
            </method>
            <method name="match" type="boolean" line="2493">
                <params>
                    <param name="c" type="char"/>
                    <param name="lowMask" type="long"/>
                    <param name="highMask" type="long"/>
                </params>
                <comment line="2494">
                    0 doesn&apos;t have a slot in the mask. So, it never matches.                    
                </comment>
            </method>
            <declaration name="L_DIGIT" type="long" line="2508"/>
            <declaration name="H_DIGIT" type="long" line="2509"/>
            <declaration name="L_UPALPHA" type="long" line="2514"/>
            <declaration name="H_UPALPHA" type="long" line="2515"/>
            <declaration name="L_LOWALPHA" type="long" line="2520"/>
            <declaration name="H_LOWALPHA" type="long" line="2521"/>
            <declaration name="L_ALPHA" type="long" line="2524"/>
            <declaration name="H_ALPHA" type="long" line="2525"/>
            <declaration name="L_ALPHANUM" type="long" line="2528"/>
            <declaration name="H_ALPHANUM" type="long" line="2529"/>
            <declaration name="L_HEX" type="long" line="2533"/>
            <declaration name="H_HEX" type="long" line="2534"/>
            <declaration name="L_MARK" type="long" line="2538"/>
            <declaration name="H_MARK" type="long" line="2539"/>
            <declaration name="L_UNRESERVED" type="long" line="2542"/>
            <declaration name="H_UNRESERVED" type="long" line="2543"/>
            <declaration name="L_RESERVED" type="long" line="2548"/>
            <declaration name="H_RESERVED" type="long" line="2549"/>
            <declaration name="L_ESCAPED" type="long" line="2553"/>
            <declaration name="H_ESCAPED" type="long" line="2554"/>
            <declaration name="L_URIC" type="long" line="2557"/>
            <declaration name="H_URIC" type="long" line="2558"/>
            <declaration name="L_PCHAR" type="long" line="2562"/>
            <declaration name="H_PCHAR" type="long" line="2564"/>
            <declaration name="L_PATH" type="long" line="2568"/>
            <declaration name="H_PATH" type="long" line="2569"/>
            <declaration name="L_DASH" type="long" line="2572"/>
            <declaration name="H_DASH" type="long" line="2573"/>
            <declaration name="L_DOT" type="long" line="2576"/>
            <declaration name="H_DOT" type="long" line="2577"/>
            <declaration name="L_USERINFO" type="long" line="2581"/>
            <declaration name="H_USERINFO" type="long" line="2583"/>
            <declaration name="L_REG_NAME" type="long" line="2588"/>
            <declaration name="H_REG_NAME" type="long" line="2590"/>
            <declaration name="L_SERVER" type="long" line="2594"/>
            <declaration name="H_SERVER" type="long" line="2596"/>
            <declaration name="L_SERVER_PERCENT" type="long" line="2601"/>
            <declaration name="H_SERVER_PERCENT" type="long" line="2603"/>
            <declaration name="L_LEFT_BRACKET" type="long" line="2605"/>
            <declaration name="H_LEFT_BRACKET" type="long" line="2606"/>
            <declaration name="L_SCHEME" type="long" line="2609"/>
            <declaration name="H_SCHEME" type="long" line="2610"/>
            <declaration name="L_URIC_NO_SLASH" type="long" line="2614"/>
            <declaration name="H_URIC_NO_SLASH" type="long" line="2616"/>
            <declaration name="hexDigits" type="char[]" line="2622"/>
            <method name="appendEscape" type="void" line="2627">
                <params>
                    <param name="sb" type="StringBuffer"/>
                    <param name="b" type="byte"/>
                </params>
            </method>
            <method name="appendEncoded" type="void" line="2633">
                <params>
                    <param name="sb" type="StringBuffer"/>
                    <param name="c" type="char"/>
                </params>
                <declaration name="bb" type="ByteBuffer" line="2634"/>
                <scope line="2635"/>
                <scope line="2638"/>
                <scope line="2641">
                    <declaration name="b" type="int" line="2642"/>
                </scope>
            </method>
            <method name="quote" type="String" line="2653">
                <params>
                    <param name="s" type="String"/>
                    <param name="lowMask" type="long"/>
                    <param name="highMask" type="long"/>
                </params>
                <declaration name="n" type="int" line="2654"/>
                <declaration name="sb" type="StringBuffer" line="2655"/>
                <declaration name="allowNonASCII" type="boolean" line="2656"/>
                <scope line="2657">
                    <declaration name="c" type="char" line="2658"/>
                    <scope line="2659">
                        <scope line="2660">
                            <scope line="2661"/>
                        </scope>
                        <scope line="2666"/>
                    </scope>
                    <scope line="2672">
                        <scope line="2673"/>
                    </scope>
                    <scope line="2678"/>
                </scope>
            </method>
            <method name="encode" type="String" line="2689">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="2694">
                    First check whether we actually need to encode                    
                </comment>
                <declaration name="n" type="int" line="2690"/>
                <scope line="2695"/>
                <declaration name="ns" type="String" line="2702"/>
                <declaration name="bb" type="ByteBuffer" line="2703"/>
                <scope line="2704"/>
                <scope line="2707"/>
                <declaration name="sb" type="StringBuffer" line="2711"/>
                <scope line="2712">
                    <declaration name="b" type="int" line="2713"/>
                </scope>
            </method>
            <method name="decode" type="int" line="2722">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <method name="decode" type="byte" line="2733">
                <params>
                    <param name="c1" type="char"/>
                    <param name="c2" type="char"/>
                </params>
            </method>
            <method name="decode" type="String" line="2745">
                <params>
                    <param name="s" type="String"/>
                </params>
                <comment line="2761">
                    This is not horribly efficient, but it will do for now                    
                </comment>
                <comment line="2766">
                    Loop invariant                    
                </comment>
                <declaration name="n" type="int" line="2748"/>
                <declaration name="sb" type="StringBuffer" line="2754"/>
                <declaration name="bb" type="ByteBuffer" line="2755"/>
                <declaration name="cb" type="CharBuffer" line="2756"/>
                <declaration name="dec" type="CharsetDecoder" line="2757"/>
                <declaration name="c" type="char" line="2762"/>
                <declaration name="betweenBrackets" type="boolean" line="2763"/>
                <scope line="2765">
                    <scope line="2767"/>
                    <scope line="2769"/>
                    <scope line="2772"/>
                    <declaration name="ui" type="int" line="2780"/>
                    <scope line="2781"/>
                    <declaration name="cr" type="CoderResult" line="2793"/>
                </scope>
            </method>
            <class name="Parser" line="2810">
                <comment line="2813">
                    URI input string                    
                </comment>
                <comment line="2821">
                    -- Methods for throwing URISyntaxException in various ways --                    
                </comment>
                <comment line="2844">
                    -- Simple access to the input string --                    
                </comment>
                <comment line="2846">
                    Return a substring of the input string                    
                </comment>
                <comment line="2847">
                                        
                </comment>
                <comment line="2852">
                    Return the char at position p,                    
                </comment>
                <comment line="2853">
                    assuming that p &lt; input.length()                    
                </comment>
                <comment line="2854">
                                        
                </comment>
                <comment line="2859">
                    Tells whether start &lt; end and, if so, whether charAt(start) == c                    
                </comment>
                <comment line="2860">
                                        
                </comment>
                <comment line="2865">
                    Tells whether start + s.length() &lt; end and, if so,                    
                </comment>
                <comment line="2866">
                    whether the chars at the start position match s exactly                    
                </comment>
                <comment line="2867">
                                        
                </comment>
                <comment line="2884">
                    -- Scanning --                    
                </comment>
                <comment line="2886">
                    The various scan and parse methods that follow use a uniform                    
                </comment>
                <comment line="2887">
                    convention of taking the current start position and end index as                    
                </comment>
                <comment line="2888">
                    their first two arguments.  The start is inclusive while the end is                    
                </comment>
                <comment line="2889">
                    exclusive, just as in the String class, i.e., a start/end pair                    
                </comment>
                <comment line="2890">
                    denotes the left-open interval [start, end) of the input string.                    
                </comment>
                <comment line="2891">
                                        
                </comment>
                <comment line="2892">
                    These methods never proceed past the end position.  They may return                    
                </comment>
                <comment line="2893">
                    -1 to indicate outright failure, but more often they simply return                    
                </comment>
                <comment line="2894">
                    the position of the first char after the last char scanned.  Thus                    
                </comment>
                <comment line="2895">
                    a typical idiom is                    
                </comment>
                <comment line="2896">
                                        
                </comment>
                <comment line="2897">
                    int p = start;                    
                </comment>
                <comment line="2898">
                    int q = scan(p, end, ...);                    
                </comment>
                <comment line="2899">
                    if (q &gt; p)                    
                </comment>
                <comment line="2900">
                    // We scanned something                    
                </comment>
                <comment line="2901">
                    ...;                    
                </comment>
                <comment line="2902">
                    else if (q == p)                    
                </comment>
                <comment line="2903">
                    // We scanned nothing                    
                </comment>
                <comment line="2904">
                    ...;                    
                </comment>
                <comment line="2905">
                    else if (q == -1)                    
                </comment>
                <comment line="2906">
                    // Something went wrong                    
                </comment>
                <comment line="2907">
                    ...;                    
                </comment>
                <comment line="2910">
                    Scan a specific char: If the char at the given start position is                    
                </comment>
                <comment line="2911">
                    equal to c, return the index of the next char; otherwise, return the                    
                </comment>
                <comment line="2912">
                    start position.                    
                </comment>
                <comment line="2913">
                                        
                </comment>
                <comment line="2920">
                    Scan forward from the given start position.  Stop at the first char                    
                </comment>
                <comment line="2921">
                    in the err string (in which case -1 is returned), or the first char                    
                </comment>
                <comment line="2922">
                    in the stop string (in which case the index of the preceding char is                    
                </comment>
                <comment line="2923">
                    returned), or the end of the input string (in which case the length                    
                </comment>
                <comment line="2924">
                    of the input string is returned).  May return the start position if                    
                </comment>
                <comment line="2925">
                    nothing matches.                    
                </comment>
                <comment line="2926">
                                        
                </comment>
                <comment line="2940">
                    Scan a potential escape sequence, starting at the given position,                    
                </comment>
                <comment line="2941">
                    with the given first char (i.e., charAt(start) == c).                    
                </comment>
                <comment line="2942">
                                        
                </comment>
                <comment line="2943">
                    This method assumes that if escapes are allowed then visible                    
                </comment>
                <comment line="2944">
                    non-US-ASCII chars are also allowed.                    
                </comment>
                <comment line="2945">
                                        
                </comment>
                <comment line="2968">
                    Scan chars that match the given mask pair                    
                </comment>
                <comment line="2969">
                                        
                </comment>
                <comment line="2992">
                    Check that each of the chars in [start, end) matches the given mask                    
                </comment>
                <comment line="2993">
                                        
                </comment>
                <comment line="3004">
                    Check that the char at position p matches the given mask                    
                </comment>
                <comment line="3005">
                                        
                </comment>
                <comment line="3015">
                    -- Parsing --                    
                </comment>
                <comment line="3017">
                    [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]                    
                </comment>
                <comment line="3018">
                                        
                </comment>
                <comment line="3055">
                    [//authority]&lt;path&gt;[?&lt;query&gt;]                    
                </comment>
                <comment line="3056">
                                        
                </comment>
                <comment line="3057">
                    DEVIATION from RFC2396: We allow an empty authority component as                    
                </comment>
                <comment line="3058">
                    long as it&apos;s followed by a non-empty path, query component, or                    
                </comment>
                <comment line="3059">
                    fragment component.  This is so that URIs such as &quot;file:///foo/bar&quot;                    
                </comment>
                <comment line="3060">
                    will parse.  This seems to be the intent of RFC2396, though the                    
                </comment>
                <comment line="3061">
                    grammar does not permit it.  If the authority is empty then the                    
                </comment>
                <comment line="3062">
                    userInfo, host, and port components are undefined.                    
                </comment>
                <comment line="3063">
                                        
                </comment>
                <comment line="3064">
                    DEVIATION from RFC2396: We allow empty relative paths.  This seems                    
                </comment>
                <comment line="3065">
                    to be the intent of RFC2396, but the grammar does not permit it.                    
                </comment>
                <comment line="3066">
                    The primary consequence of this deviation is that &quot;#f&quot; parses as a                    
                </comment>
                <comment line="3067">
                    relative URI with an empty path.                    
                </comment>
                <comment line="3068">
                                        
                </comment>
                <comment line="3098">
                    authority     = server | reg_name                    
                </comment>
                <comment line="3099">
                                        
                </comment>
                <comment line="3100">
                    Ambiguity: An authority that is a registry name rather than a server                    
                </comment>
                <comment line="3101">
                    might have a prefix that parses as a server.  We use the fact that                    
                </comment>
                <comment line="3102">
                    the authority component is always followed by &apos;/&apos; or the end of the                    
                </comment>
                <comment line="3103">
                    input string to resolve this: If the complete authority did not                    
                </comment>
                <comment line="3104">
                    parse as a server then we try to parse it as a registry name.                    
                </comment>
                <comment line="3105">
                                        
                </comment>
                <comment line="3174">
                    [&lt;userinfo&gt;@]&lt;host&gt;[:&lt;port&gt;]                    
                </comment>
                <comment line="3175">
                                        
                </comment>
                <comment line="3240">
                    Scan a string of decimal digits whose value fits in a byte                    
                </comment>
                <comment line="3241">
                                        
                </comment>
                <comment line="3252">
                    Scan an IPv4 address.                    
                </comment>
                <comment line="3253">
                                        
                </comment>
                <comment line="3254">
                    If the strict argument is true then we require that the given                    
                </comment>
                <comment line="3255">
                    interval contain nothing besides an IPv4 address; if it is false                    
                </comment>
                <comment line="3256">
                    then we only require that it start with an IPv4 address.                    
                </comment>
                <comment line="3257">
                                        
                </comment>
                <comment line="3258">
                    If the interval does not contain or start with (depending upon the                    
                </comment>
                <comment line="3259">
                    strict argument) a legal IPv4 address characters then we return -1                    
                </comment>
                <comment line="3260">
                    immediately; otherwise we insist that these characters parse as a                    
                </comment>
                <comment line="3261">
                    legal IPv4 address and throw an exception on failure.                    
                </comment>
                <comment line="3262">
                                        
                </comment>
                <comment line="3263">
                    We assume that any string of decimal digits and dots must be an IPv4                    
                </comment>
                <comment line="3264">
                    address.  It won&apos;t parse as a hostname anyway, so making that                    
                </comment>
                <comment line="3265">
                    assumption here allows more meaningful exceptions to be thrown.                    
                </comment>
                <comment line="3266">
                                        
                </comment>
                <comment line="3292">
                    Take an IPv4 address: Throw an exception if the given interval                    
                </comment>
                <comment line="3293">
                    contains anything except an IPv4 address                    
                </comment>
                <comment line="3294">
                                        
                </comment>
                <comment line="3304">
                    Attempt to parse an IPv4 address, returning -1 on failure but                    
                </comment>
                <comment line="3305">
                    allowing the given interval to contain [:&lt;characters&gt;] after                    
                </comment>
                <comment line="3306">
                    the IPv4 address.                    
                </comment>
                <comment line="3307">
                                        
                </comment>
                <comment line="3334">
                    hostname      = domainlabel [ &quot;.&quot; ] | 1*( domainlabel &quot;.&quot; ) toplabel [ &quot;.&quot; ]                    
                </comment>
                <comment line="3335">
                    domainlabel   = alphanum | alphanum *( alphanum | &quot;-&quot; ) alphanum                    
                </comment>
                <comment line="3336">
                    toplabel      = alpha | alpha *( alphanum | &quot;-&quot; ) alphanum                    
                </comment>
                <comment line="3337">
                                        
                </comment>
                <comment line="3383">
                    IPv6 address parsing, from RFC2373: IPv6 Addressing Architecture                    
                </comment>
                <comment line="3384">
                                        
                </comment>
                <comment line="3385">
                    Bug: The grammar in RFC2373 Appendix B does not allow addresses of                    
                </comment>
                <comment line="3386">
                    the form ::12.34.56.78, which are clearly shown in the examples                    
                </comment>
                <comment line="3387">
                    earlier in the document.  Here is the original grammar:                    
                </comment>
                <comment line="3388">
                                        
                </comment>
                <comment line="3389">
                    IPv6address = hexpart [ &quot;:&quot; IPv4address ]                    
                </comment>
                <comment line="3390">
                    hexpart     = hexseq | hexseq &quot;::&quot; [ hexseq ] | &quot;::&quot; [ hexseq ]                    
                </comment>
                <comment line="3391">
                    hexseq      = hex4 *( &quot;:&quot; hex4)                    
                </comment>
                <comment line="3392">
                    hex4        = 1*4HEXDIG                    
                </comment>
                <comment line="3393">
                                        
                </comment>
                <comment line="3394">
                    We therefore use the following revised grammar:                    
                </comment>
                <comment line="3395">
                                        
                </comment>
                <comment line="3396">
                    IPv6address = hexseq [ &quot;:&quot; IPv4address ]                    
                </comment>
                <comment line="3397">
                    | hexseq [ &quot;::&quot; [ hexpost ] ]                    
                </comment>
                <comment line="3398">
                    | &quot;::&quot; [ hexpost ]                    
                </comment>
                <comment line="3399">
                    hexpost     = hexseq | hexseq &quot;:&quot; IPv4address | IPv4address                    
                </comment>
                <comment line="3400">
                    hexseq      = hex4 *( &quot;:&quot; hex4)                    
                </comment>
                <comment line="3401">
                    hex4        = 1*4HEXDIG                    
                </comment>
                <comment line="3402">
                                        
                </comment>
                <comment line="3403">
                    This covers all and only the following cases:                    
                </comment>
                <comment line="3404">
                                        
                </comment>
                <comment line="3405">
                    hexseq                    
                </comment>
                <comment line="3406">
                    hexseq : IPv4address                    
                </comment>
                <comment line="3407">
                    hexseq ::                    
                </comment>
                <comment line="3408">
                    hexseq :: hexseq                    
                </comment>
                <comment line="3409">
                    hexseq :: hexseq : IPv4address                    
                </comment>
                <comment line="3410">
                    hexseq :: IPv4address                    
                </comment>
                <comment line="3411">
                    :: hexseq                    
                </comment>
                <comment line="3412">
                    :: hexseq : IPv4address                    
                </comment>
                <comment line="3413">
                    :: IPv4address                    
                </comment>
                <comment line="3414">
                    ::                    
                </comment>
                <comment line="3415">
                                        
                </comment>
                <comment line="3416">
                    Additionally we constrain the IPv6 address as follows :-                    
                </comment>
                <comment line="3417">
                                        
                </comment>
                <comment line="3418">
                    i.  IPv6 addresses without compressed zeros should contain                    
                </comment>
                <comment line="3419">
                    exactly 16 bytes.                    
                </comment>
                <comment line="3420">
                                        
                </comment>
                <comment line="3421">
                    ii. IPv6 addresses with compressed zeros should contain                    
                </comment>
                <comment line="3422">
                    less than 16 bytes.                    
                </comment>
                <comment line="3484">
                    Scan a hex sequence; return -1 if one could not be scanned                    
                </comment>
                <comment line="3485">
                                        
                </comment>
                <declaration name="input" type="String" line="2812"/>
                <declaration name="requireServerAuthority" type="boolean" line="2813"/>
                <method name="Parser" type="constructor" line="2815">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <method name="fail" type="void" line="2822">
                    <params>
                        <param name="reason" type="String"/>
                    </params>
                </method>
                <method name="fail" type="void" line="2826">
                    <params>
                        <param name="reason" type="String"/>
                        <param name="p" type="int"/>
                    </params>
                </method>
                <method name="failExpecting" type="void" line="2832">
                    <params>
                        <param name="expected" type="String"/>
                        <param name="p" type="int"/>
                    </params>
                </method>
                <method name="failExpecting" type="void" line="2838">
                    <params>
                        <param name="expected" type="String"/>
                        <param name="prior" type="String"/>
                        <param name="p" type="int"/>
                    </params>
                </method>
                <method name="substring" type="String" line="2847">
                    <params>
                        <param name="start" type="int"/>
                        <param name="end" type="int"/>
                    </params>
                </method>
                <method name="charAt" type="char" line="2854">
                    <params>
                        <param name="p" type="int"/>
                    </params>
                </method>
                <method name="at" type="boolean" line="2860">
                    <params>
                        <param name="start" type="int"/>
                        <param name="end" type="int"/>
                        <param name="c" type="char"/>
                    </params>
                </method>
                <method name="at" type="boolean" line="2867">
                    <params>
                        <param name="start" type="int"/>
                        <param name="end" type="int"/>
                        <param name="s" type="String"/>
                    </params>
                    <declaration name="p" type="int" line="2868"/>
                    <declaration name="sn" type="int" line="2869"/>
                    <declaration name="i" type="int" line="2872"/>
                    <scope line="2873">
                        <scope line="2874"/>
                    </scope>
                </method>
                <method name="scan" type="int" line="2913">
                    <params>
                        <param name="start" type="int"/>
                        <param name="end" type="int"/>
                        <param name="c" type="char"/>
                    </params>
                </method>
                <method name="scan" type="int" line="2926">
                    <params>
                        <param name="start" type="int"/>
                        <param name="end" type="int"/>
                        <param name="err" type="String"/>
                        <param name="stop" type="String"/>
                    </params>
                    <declaration name="p" type="int" line="2927"/>
                    <scope line="2928">
                        <declaration name="c" type="char" line="2929"/>
                    </scope>
                </method>
                <method name="scanEscape" type="int" line="2947">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                        <param name="first" type="char"/>
                    </params>
                    <comment line="2951">
                        Process escape pair                        
                    </comment>
                    <comment line="2961">
                        Allow unescaped but visible non-US-ASCII chars                        
                    </comment>
                    <declaration name="p" type="int" line="2948"/>
                    <declaration name="c" type="char" line="2949"/>
                    <scope line="2950">
                        <scope line="2954"/>
                    </scope>
                    <scope line="2960"/>
                </method>
                <method name="scan" type="int" line="2971">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                        <param name="lowMask" type="long"/>
                        <param name="highMask" type="long"/>
                    </params>
                    <declaration name="p" type="int" line="2972"/>
                    <scope line="2973">
                        <declaration name="c" type="char" line="2974"/>
                        <scope line="2975"/>
                        <scope line="2979">
                            <declaration name="q" type="int" line="2980"/>
                            <scope line="2981"/>
                        </scope>
                    </scope>
                </method>
                <method name="checkChars" type="void" line="2997">
                    <params>
                        <param name="start" type="int"/>
                        <param name="end" type="int"/>
                        <param name="lowMask" type="long"/>
                        <param name="highMask" type="long"/>
                        <param name="what" type="String"/>
                    </params>
                    <declaration name="p" type="int" line="2998"/>
                </method>
                <method name="checkChar" type="void" line="3009">
                    <params>
                        <param name="p" type="int"/>
                        <param name="lowMask" type="long"/>
                        <param name="highMask" type="long"/>
                        <param name="what" type="String"/>
                    </params>
                </method>
                <method name="parse" type="void" line="3018">
                    <params>
                        <param name="rsa" type="boolean"/>
                    </params>
                    <comment line="3020">
                        Start of scheme-specific part                        
                    </comment>
                    <comment line="3029">
                        Skip &apos;:&apos;                        
                    </comment>
                    <declaration name="ssp" type="int" line="3020"/>
                    <declaration name="n" type="int" line="3021"/>
                    <declaration name="p" type="int" line="3022"/>
                    <scope line="3023">
                        <scope line="3031"/>
                        <scope line="3033">
                            <declaration name="q" type="int" line="3034"/>
                        </scope>
                    </scope>
                    <scope line="3040"/>
                    <scope line="3045"/>
                </method>
                <method name="parseHierarchical" type="int" line="3070">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <comment line="3078">
                        DEVIATION: Allow empty authority prior to non-empty                        
                    </comment>
                    <comment line="3079">
                        path, query component or fragment identifier                        
                    </comment>
                    <comment line="3083">
                        DEVIATION: May be empty                        
                    </comment>
                    <declaration name="p" type="int" line="3071"/>
                    <scope line="3072">
                        <declaration name="q" type="int" line="3074"/>
                        <scope line="3075"/>
                        <scope line="3077"/>
                    </scope>
                    <declaration name="q" type="int" line="3083"/>
                    <scope line="3087"/>
                </method>
                <method name="parseAuthority" type="int" line="3107">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <comment line="3116">
                        contains a literal IPv6 address, therefore % is allowed                        
                    </comment>
                    <comment line="3124">
                        Must be a registry-based authority                        
                    </comment>
                    <comment line="3130">
                        Might be (probably is) a server-based authority, so attempt                        
                    </comment>
                    <comment line="3131">
                        to parse it as such.  If the attempt fails, try to treat it                        
                    </comment>
                    <comment line="3132">
                        as a registry-based authority.                        
                    </comment>
                    <comment line="3139">
                        Undo results of failed parse                        
                    </comment>
                    <comment line="3144">
                        If we&apos;re insisting upon a server-based authority,                        
                    </comment>
                    <comment line="3145">
                        then just re-throw the exception                        
                    </comment>
                    <comment line="3148">
                        Save the exception in case it doesn&apos;t parse as a                        
                    </comment>
                    <comment line="3149">
                        registry either                        
                    </comment>
                    <comment line="3158">
                        Registry-based authority                        
                    </comment>
                    <comment line="3161">
                        Re-throw exception; it was probably due to                        
                    </comment>
                    <comment line="3162">
                        a malformed IPv6 address                        
                    </comment>
                    <declaration name="p" type="int" line="3108"/>
                    <declaration name="q" type="int" line="3109"/>
                    <declaration name="ex" type="URISyntaxException" line="3110"/>
                    <declaration name="serverChars" type="boolean" line="3112"/>
                    <declaration name="regChars" type="boolean" line="3113"/>
                    <scope line="3115"/>
                    <scope line="3118"/>
                    <scope line="3123"/>
                    <scope line="3129">
                        <scope line="3133"/>
                        <scope line="3138">
                            <scope line="3143"/>
                            <scope line="3147"/>
                        </scope>
                    </scope>
                    <scope line="3156">
                        <scope line="3157"/>
                        <scope line="3160"/>
                        <scope line="3164"/>
                    </scope>
                </method>
                <method name="parseServer" type="int" line="3177">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <comment line="3181">
                        userinfo                        
                    </comment>
                    <comment line="3186">
                        Skip &apos;@&apos;                        
                    </comment>
                    <comment line="3189">
                        hostname, IPv4 address, or IPv6 address                        
                    </comment>
                    <comment line="3191">
                        DEVIATION from RFC2396: Support IPv6 addresses, per RFC2732                        
                    </comment>
                    <comment line="3195">
                        look for a &quot;%&quot; scope id                        
                    </comment>
                    <comment line="3219">
                        port                        
                    </comment>
                    <declaration name="p" type="int" line="3178"/>
                    <declaration name="q" type="int" line="3179"/>
                    <scope line="3183"/>
                    <scope line="3190">
                        <scope line="3194">
                            <declaration name="r" type="int" line="3196"/>
                            <scope line="3197">
                                <scope line="3199"/>
                            </scope>
                            <scope line="3204"/>
                        </scope>
                        <scope line="3209"/>
                    </scope>
                    <scope line="3212"/>
                    <scope line="3220">
                        <scope line="3223">
                            <scope line="3225"/>
                            <scope line="3227"/>
                        </scope>
                    </scope>
                </method>
                <method name="scanByte" type="int" line="3243">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <declaration name="p" type="int" line="3244"/>
                    <declaration name="q" type="int" line="3245"/>
                </method>
                <method name="scanIPv4Address" type="int" line="3268">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                        <param name="strict" type="boolean"/>
                    </params>
                    <comment line="3275">
                        Per RFC2732: At most three digits per byte                        
                    </comment>
                    <comment line="3276">
                        Further constraint: Each element fits in a byte                        
                    </comment>
                    <declaration name="p" type="int" line="3269"/>
                    <declaration name="q" type="int" line="3270"/>
                    <declaration name="m" type="int" line="3271"/>
                    <scope line="3274"/>
                </method>
                <method name="takeIPv4Address" type="int" line="3296">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                        <param name="expected" type="String"/>
                    </params>
                    <declaration name="p" type="int" line="3297"/>
                </method>
                <method name="parseIPv4Address" type="int" line="3307">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <comment line="3319">
                        IPv4 address is followed by something - check that                        
                    </comment>
                    <comment line="3320">
                        it&apos;s a &quot;:&quot; as this is the only valid character to                        
                    </comment>
                    <comment line="3321">
                        follow an address.                        
                    </comment>
                    <declaration name="p" type="int" line="3308"/>
                    <scope line="3310"/>
                    <scope line="3312"/>
                    <scope line="3314"/>
                    <scope line="3318">
                        <scope line="3322"/>
                    </scope>
                </method>
                <method name="parseHostname" type="int" line="3339">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <comment line="3342">
                        Start of last parsed label                        
                    </comment>
                    <comment line="3345">
                        domainlabel = alphanum [ *( alphanum | &quot;-&quot; ) alphanum ]                        
                    </comment>
                    <comment line="3371">
                        for a fully qualified hostname check that the rightmost                        
                    </comment>
                    <comment line="3372">
                        label starts with an alpha character.                        
                    </comment>
                    <declaration name="p" type="int" line="3340"/>
                    <declaration name="q" type="int" line="3341"/>
                    <declaration name="l" type="int" line="3342"/>
                    <scope line="3344">
                        <scope line="3350">
                            <scope line="3353"/>
                        </scope>
                    </scope>
                    <scope line="3373"/>
                </method>
                <declaration name="ipv6byteCount" type="int" line="3423"/>
                <method name="parseIPv6Reference" type="int" line="3427">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <declaration name="p" type="int" line="3428"/>
                    <declaration name="q" type="int" line="3429"/>
                    <declaration name="compressedZeros" type="boolean" line="3430"/>
                    <scope line="3434">
                        <scope line="3436"/>
                        <scope line="3439"/>
                    </scope>
                    <scope line="3443"/>
                </method>
                <method name="scanHexPost" type="int" line="3461">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <declaration name="p" type="int" line="3462"/>
                    <declaration name="q" type="int" line="3463"/>
                    <scope line="3469">
                        <scope line="3471"/>
                    </scope>
                    <scope line="3476"/>
                </method>
                <method name="scanHexSeq" type="int" line="3487">
                    <params>
                        <param name="start" type="int"/>
                        <param name="n" type="int"/>
                    </params>
                    <comment line="3494">
                        Beginning of IPv4 address                        
                    </comment>
                    <comment line="3504">
                        &quot;::&quot;                        
                    </comment>
                    <comment line="3509">
                        Beginning of IPv4 address                        
                    </comment>
                    <declaration name="p" type="int" line="3488"/>
                    <declaration name="q" type="int" line="3489"/>
                    <scope line="3500">
                        <scope line="3509"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>