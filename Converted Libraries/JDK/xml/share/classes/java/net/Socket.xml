<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.net">
        <import package="java.io.InputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.InterruptedIOException"/>
        <import package="java.nio.channels.SocketChannel"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.security.PrivilegedAction"/>
        <class name="Socket" line="37">
            <implements interface="java.io.Closeable"/>
            <javadoc line="37">
                This class implements client sockets (also called just
                  &quot;sockets&quot;). A socket is an endpoint for communication
                  between two machines.
                  &lt;p&gt;
                  The actual work of the socket is performed by an instance of the
                  &lt;code&gt;SocketImpl&lt;/code&gt; class. An application, by changing
                  the socket factory that creates the socket implementation,
                  can configure itself to create sockets appropriate to the local
                  firewall.                
                <author>
                    unascribed                    
                </author>
                <see>
                    java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)                    
                </see>
                <see>
                    java.net.SocketImpl                    
                </see>
                <see>
                    java.nio.channels.SocketChannel                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="created" type="boolean" line="56"/>
            <javadoc line="56">
                Various states of this socket.                
            </javadoc>
            <declaration name="bound" type="boolean" line="60"/>
            <declaration name="connected" type="boolean" line="61"/>
            <declaration name="closed" type="boolean" line="62"/>
            <declaration name="closeLock" type="Object" line="63"/>
            <declaration name="shutIn" type="boolean" line="64"/>
            <declaration name="shutOut" type="boolean" line="65"/>
            <declaration name="impl" type="SocketImpl" line="67"/>
            <javadoc line="67">
                The implementation of this Socket.                
            </javadoc>
            <declaration name="oldImpl" type="boolean" line="72"/>
            <javadoc line="72">
                Are we using an older SocketImpl?                
            </javadoc>
            <javadoc line="77">
                Creates an unconnected socket, with the
                  system-default type of SocketImpl.                
                <since>
                    JDK1.1                    
                </since>
                <revised>
                    1.4                    
                </revised>
            </javadoc>
            <method name="Socket" type="constructor" line="84"/>
            <javadoc line="88">
                Creates an unconnected socket, specifying the type of proxy, if any,
                  that should be used regardless of any other settings.
                  &lt;P&gt;
                  If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method
                  is called with the proxy host address and port number
                  as its arguments. This could result in a SecurityException.
                  &lt;P&gt;
                  Examples:
                  &lt;UL&gt; &lt;LI&gt;&lt;code&gt;Socket s = new Socket(Proxy.NO_PROXY);&lt;/code&gt; will create
                  a plain socket ignoring any other proxy configuration.&lt;/LI&gt;
                  &lt;LI&gt;&lt;code&gt;Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(&quot;socks.mydom.com&quot;, 1080)));&lt;/code&gt;
                  will create a socket connecting through the specified SOCKS proxy
                  server.&lt;/LI&gt;
                  &lt;/UL&gt;                
                <param>
                    proxy a {@link java.net.Proxy Proxy} object specifying what kind
                      of proxying should be used.                    
                </param>
                <throws>
                    IllegalArgumentException if the proxy is of an invalid type
                      or <code>null</code>.                    
                </throws>
                <throws>
                    SecurityException if a security manager is present and
                      permission to connect to the proxy is
                      denied.                    
                </throws>
                <see>
                    java.net.ProxySelector                    
                </see>
                <see>
                    java.net.Proxy                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="Socket" type="constructor" line="116">
                <params>
                    <param name="proxy" type="Proxy"/>
                </params>
                <comment line="118">
                    Create a copy of Proxy as a security measure                    
                </comment>
                <scope line="118"/>
                <declaration name="p" type="Proxy" line="121"/>
                <scope line="122">
                    <declaration name="security" type="SecurityManager" line="123"/>
                    <declaration name="epoint" type="InetSocketAddress" line="124"/>
                    <scope line="125"/>
                    <scope line="128"/>
                </scope>
                <scope line="139">
                    <scope line="140">
                        <scope line="141"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="151">
                Creates an unconnected Socket with a user-specified
                  SocketImpl.
                  &lt;P&gt;                
                <param>
                    impl an instance of a <B>SocketImpl</B>
                      the subclass wishes to use on the Socket.                    
                </param>
                <exception>
                    SocketException if there is an error in the underlying protocol,
                      such as a TCP error.                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="Socket" type="constructor" line="162">
                <params>
                    <param name="impl" type="SocketImpl"/>
                </params>
                <scope line="164"/>
            </method>
            <javadoc line="170">
                Creates a stream socket and connects it to the specified port
                  number on the named host.
                  &lt;p&gt;
                  If the specified host is &lt;tt&gt;null&lt;/tt&gt; it is the equivalent of
                  specifying the address as &lt;tt&gt;{@link java.net.InetAddress#getByName InetAddress.getByName}(null)&lt;/tt&gt;.
                  In other words, it is equivalent to specifying an address of the
                  loopback interface. &lt;/p&gt;
                  &lt;p&gt;
                  If the application has specified a server socket factory, that
                  factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create
                  the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
                  &lt;p&gt;
                  If there is a security manager, its
                  &lt;code&gt;checkConnect&lt;/code&gt; method is called
                  with the host address and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.                
                <param>
                    host   the host name, or <code>null</code> for the loopback address.                    
                </param>
                <param>
                    port   the port number.                    
                </param>
                <exception>
                    UnknownHostException if the IP address of
                      the host could not be determined.                    
                </exception>
                <exception>
                    IOException  if an I/O error occurs when creating the socket.                    
                </exception>
                <exception>
                    SecurityException  if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </exception>
                <exception>
                    IllegalArgumentException if the port parameter is outside
                      the specified range of valid port values, which is between
                      0 and 65535, inclusive.                    
                </exception>
                <see>
                    java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)                    
                </see>
                <see>
                    java.net.SocketImpl                    
                </see>
                <see>
                    java.net.SocketImplFactory#createSocketImpl()                    
                </see>
                <see>
                    SecurityManager#checkConnect                    
                </see>
            </javadoc>
            <method name="Socket" type="constructor" line="207">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="213">
                Creates a stream socket and connects it to the specified port
                  number at the specified IP address.
                  &lt;p&gt;
                  If the application has specified a socket factory, that factory&apos;s
                  &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the
                  actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
                  &lt;p&gt;
                  If there is a security manager, its
                  &lt;code&gt;checkConnect&lt;/code&gt; method is called
                  with the host address and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.                
                <param>
                    address   the IP address.                    
                </param>
                <param>
                    port      the port number.                    
                </param>
                <exception>
                    IOException  if an I/O error occurs when creating the socket.                    
                </exception>
                <exception>
                    SecurityException  if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </exception>
                <exception>
                    IllegalArgumentException if the port parameter is outside
                      the specified range of valid port values, which is between
                      0 and 65535, inclusive.                    
                </exception>
                <exception>
                    NullPointerException if <code>address</code> is null.                    
                </exception>
                <see>
                    java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)                    
                </see>
                <see>
                    java.net.SocketImpl                    
                </see>
                <see>
                    java.net.SocketImplFactory#createSocketImpl()                    
                </see>
                <see>
                    SecurityManager#checkConnect                    
                </see>
            </javadoc>
            <method name="Socket" type="constructor" line="240">
                <params>
                    <param name="address" type="InetAddress"/>
                    <param name="port" type="int"/>
                </params>
            </method>
            <javadoc line="245">
                Creates a socket and connects it to the specified remote host on
                  the specified remote port. The Socket will also bind() to the local
                  address and port supplied.
                  &lt;p&gt;
                  If the specified host is &lt;tt&gt;null&lt;/tt&gt; it is the equivalent of
                  specifying the address as &lt;tt&gt;{@link java.net.InetAddress#getByName InetAddress.getByName}(null)&lt;/tt&gt;.
                  In other words, it is equivalent to specifying an address of the
                  loopback interface. &lt;/p&gt;
                  &lt;p&gt;
                  A local port number of &lt;code&gt;zero&lt;/code&gt; will let the system pick up a
                  free port in the &lt;code&gt;bind&lt;/code&gt; operation.&lt;/p&gt;
                  &lt;p&gt;
                  If there is a security manager, its
                  &lt;code&gt;checkConnect&lt;/code&gt; method is called
                  with the host address and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.                
                <param>
                    host the name of the remote host, or <code>null</code> for the loopback address.                    
                </param>
                <param>
                    port the remote port                    
                </param>
                <param>
                    localAddr the local address the socket is bound to, or
                      <code>null</code> for the <code>anyLocal</code> address.                    
                </param>
                <param>
                    localPort the local port the socket is bound to, or
                      <code>zero</code> for a system selected free port.                    
                </param>
                <exception>
                    IOException  if an I/O error occurs when creating the socket.                    
                </exception>
                <exception>
                    SecurityException  if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </exception>
                <exception>
                    IllegalArgumentException if the port parameter or localPort
                      parameter is outside the specified range of valid port values,
                      which is between 0 and 65535, inclusive.                    
                </exception>
                <see>
                    SecurityManager#checkConnect                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="Socket" type="constructor" line="279">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="localAddr" type="InetAddress"/>
                    <param name="localPort" type="int"/>
                </params>
            </method>
            <javadoc line="285">
                Creates a socket and connects it to the specified remote address on
                  the specified remote port. The Socket will also bind() to the local
                  address and port supplied.
                  &lt;p&gt;
                  If the specified local address is &lt;tt&gt;null&lt;/tt&gt; it is the equivalent of
                  specifying the address as the AnyLocal address (see &lt;tt&gt;{@link java.net.InetAddress#isAnyLocalAddress InetAddress.isAnyLocalAddress}()&lt;/tt&gt;).
                  &lt;p&gt;
                  A local port number of &lt;code&gt;zero&lt;/code&gt; will let the system pick up a
                  free port in the &lt;code&gt;bind&lt;/code&gt; operation.&lt;/p&gt;
                  &lt;p&gt;
                  If there is a security manager, its
                  &lt;code&gt;checkConnect&lt;/code&gt; method is called
                  with the host address and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.                
                <param>
                    address the remote address                    
                </param>
                <param>
                    port the remote port                    
                </param>
                <param>
                    localAddr the local address the socket is bound to, or
                      <code>null</code> for the <code>anyLocal</code> address.                    
                </param>
                <param>
                    localPort the local port the socket is bound to or
                      <code>zero</code> for a system selected free port.                    
                </param>
                <exception>
                    IOException  if an I/O error occurs when creating the socket.                    
                </exception>
                <exception>
                    SecurityException  if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </exception>
                <exception>
                    IllegalArgumentException if the port parameter or localPort
                      parameter is outside the specified range of valid port values,
                      which is between 0 and 65535, inclusive.                    
                </exception>
                <exception>
                    NullPointerException if <code>address</code> is null.                    
                </exception>
                <see>
                    SecurityManager#checkConnect                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="Socket" type="constructor" line="318">
                <params>
                    <param name="address" type="InetAddress"/>
                    <param name="port" type="int"/>
                    <param name="localAddr" type="InetAddress"/>
                    <param name="localPort" type="int"/>
                </params>
            </method>
            <javadoc line="323">
                Creates a stream socket and connects it to the specified port
                  number on the named host.
                  &lt;p&gt;
                  If the specified host is &lt;tt&gt;null&lt;/tt&gt; it is the equivalent of
                  specifying the address as &lt;tt&gt;{@link java.net.InetAddress#getByName InetAddress.getByName}(null)&lt;/tt&gt;.
                  In other words, it is equivalent to specifying an address of the
                  loopback interface. &lt;/p&gt;
                  &lt;p&gt;
                  If the stream argument is &lt;code&gt;true&lt;/code&gt;, this creates a
                  stream socket. If the stream argument is &lt;code&gt;false&lt;/code&gt;, it
                  creates a datagram socket.
                  &lt;p&gt;
                  If the application has specified a server socket factory, that
                  factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create
                  the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
                  &lt;p&gt;
                  If there is a security manager, its
                  &lt;code&gt;checkConnect&lt;/code&gt; method is called
                  with the host address and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.
                  &lt;p&gt;
                  If a UDP socket is used, TCP/IP related socket options will not apply.                
                <param>
                    host     the host name, or <code>null</code> for the loopback address.                    
                </param>
                <param>
                    port     the port number.                    
                </param>
                <param>
                    stream   a <code>boolean</code> indicating whether this is
                      a stream socket or a datagram socket.                    
                </param>
                <exception>
                    IOException  if an I/O error occurs when creating the socket.                    
                </exception>
                <exception>
                    SecurityException  if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </exception>
                <exception>
                    IllegalArgumentException if the port parameter is outside
                      the specified range of valid port values, which is between
                      0 and 65535, inclusive.                    
                </exception>
                <see>
                    java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)                    
                </see>
                <see>
                    java.net.SocketImpl                    
                </see>
                <see>
                    java.net.SocketImplFactory#createSocketImpl()                    
                </see>
                <see>
                    SecurityManager#checkConnect                    
                </see>
                <deprecated>
                    Use DatagramSocket instead for UDP transport.                    
                </deprecated>
            </javadoc>
            <method name="Socket" type="constructor" line="364">
                <params>
                    <param name="host" type="String"/>
                    <param name="port" type="int"/>
                    <param name="stream" type="boolean"/>
                </params>
            </method>
            <javadoc line="370">
                Creates a socket and connects it to the specified port number at
                  the specified IP address.
                  &lt;p&gt;
                  If the stream argument is &lt;code&gt;true&lt;/code&gt;, this creates a
                  stream socket. If the stream argument is &lt;code&gt;false&lt;/code&gt;, it
                  creates a datagram socket.
                  &lt;p&gt;
                  If the application has specified a server socket factory, that
                  factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create
                  the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
                  &lt;p&gt;If there is a security manager, its
                  &lt;code&gt;checkConnect&lt;/code&gt; method is called
                  with &lt;code&gt;host.getHostAddress()&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;
                  as its arguments. This could result in a SecurityException.
                  &lt;p&gt;
                  If UDP socket is used, TCP/IP related socket options will not apply.                
                <param>
                    host     the IP address.                    
                </param>
                <param>
                    port      the port number.                    
                </param>
                <param>
                    stream    if <code>true</code>, create a stream socket;
                      otherwise, create a datagram socket.                    
                </param>
                <exception>
                    IOException  if an I/O error occurs when creating the socket.                    
                </exception>
                <exception>
                    SecurityException  if a security manager exists and its
                      <code>checkConnect</code> method doesn't allow the operation.                    
                </exception>
                <exception>
                    IllegalArgumentException if the port parameter is outside
                      the specified range of valid port values, which is between
                      0 and 65535, inclusive.                    
                </exception>
                <exception>
                    NullPointerException if <code>host</code> is null.                    
                </exception>
                <see>
                    java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)                    
                </see>
                <see>
                    java.net.SocketImpl                    
                </see>
                <see>
                    java.net.SocketImplFactory#createSocketImpl()                    
                </see>
                <see>
                    SecurityManager#checkConnect                    
                </see>
                <deprecated>
                    Use DatagramSocket instead for UDP transport.                    
                </deprecated>
            </javadoc>
            <method name="Socket" type="constructor" line="407">
                <params>
                    <param name="host" type="InetAddress"/>
                    <param name="port" type="int"/>
                    <param name="stream" type="boolean"/>
                </params>
            </method>
            <method name="Socket" type="constructor" line="413">
                <params>
                    <param name="address" type="SocketAddress"/>
                    <param name="localAddr" type="SocketAddress"/>
                    <param name="stream" type="boolean"/>
                </params>
                <comment line="417">
                    backward compatibility                    
                </comment>
                <scope line="420"/>
                <scope line="426"/>
            </method>
            <javadoc line="432">
                Creates the socket implementation.                
                <param>
                    stream a <code>boolean</code> value : <code>true</code> for a TCP socket,
                      <code>false</code> for UDP.                    
                </param>
                <throws>
                    IOException if creation fails                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="createImpl" type="void" line="440">
                <params>
                    <param name="stream" type="boolean"/>
                </params>
                <scope line="443"/>
                <scope line="446"/>
            </method>
            <method name="checkOldImpl" type="void" line="451">
                <comment line="455">
                    SocketImpl.connect() is a protected method, therefore we need to use
                     getDeclaredMethod, therefore we need permission to access the member                    
                </comment>
                <comment line="471">
                    java.net.SocketImpl class will always have this abstract method.
                     If we have not found it by now in the hierarchy then it does not
                     exist, we are an old style impl.                    
                </comment>
                <anonymous_class line="458">
                    <method name="run" type="Boolean" line="459">
                        <comment line="471">
                            java.net.SocketImpl class will always have this abstract method.
                             If we have not found it by now in the hierarchy then it does not
                             exist, we are an old style impl.                            
                        </comment>
                        <declaration name="cl" type="Class[]" line="460"/>
                        <declaration name="clazz" type="Class" line="463"/>
                        <scope line="464">
                            <scope line="465"/>
                            <scope line="468">
                                <scope line="473"/>
                            </scope>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="482">
                Sets impl to the system-default type of SocketImpl.                
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setImpl" type="void" line="486">
                <comment line="492">
                    No need to do a checkOldImpl() here, we know it&apos;s an up to date
                     SocketImpl!                    
                </comment>
                <scope line="487"/>
                <scope line="490"/>
            </method>
            <javadoc line="500">
                Get the &lt;code&gt;SocketImpl&lt;/code&gt; attached to this socket, creating
                  it if necessary.                
                <return>
                    the <code>SocketImpl</code> attached to that ServerSocket.                    
                </return>
                <throws>
                    SocketException if creation fails                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getImpl" type="SocketImpl" line="508"/>
            <javadoc line="514">
                Connects this socket to the server.                
                <param>
                    endpoint the <code>SocketAddress</code>                    
                </param>
                <throws>
                    IOException if an error occurs during the connection                    
                </throws>
                <throws>
                    java.nio.channels.IllegalBlockingModeExceptionif this socket has an associated channel,
                      and the channel is in non-blocking mode                    
                </throws>
                <throws>
                    IllegalArgumentException if endpoint is null or is a
                      SocketAddress subclass not supported by this socket                    
                </throws>
                <since>
                    1.4                    
                </since>
                <spec>
                    JSR-51                    
                </spec>
            </javadoc>
            <method name="connect" type="void" line="527">
                <params>
                    <param name="endpoint" type="SocketAddress"/>
                </params>
            </method>
            <javadoc line="531">
                Connects this socket to the server with a specified timeout value.
                  A timeout of zero is interpreted as an infinite timeout. The connection
                  will then block until established or an error occurs.                
                <param>
                    endpoint the <code>SocketAddress</code>                    
                </param>
                <param>
                    timeout  the timeout value to be used in milliseconds.                    
                </param>
                <throws>
                    IOException if an error occurs during the connection                    
                </throws>
                <throws>
                    SocketTimeoutException if timeout expires before connecting                    
                </throws>
                <throws>
                    java.nio.channels.IllegalBlockingModeExceptionif this socket has an associated channel,
                      and the channel is in non-blocking mode                    
                </throws>
                <throws>
                    IllegalArgumentException if endpoint is null or is a
                      SocketAddress subclass not supported by this socket                    
                </throws>
                <since>
                    1.4                    
                </since>
                <spec>
                    JSR-51                    
                </spec>
            </javadoc>
            <method name="connect" type="void" line="548">
                <params>
                    <param name="endpoint" type="SocketAddress"/>
                    <param name="timeout" type="int"/>
                </params>
                <comment line="589">
                    If the socket was not bound before the connect, it is now because
                     the kernel will have picked an ephemeral port &amp; a local address                    
                </comment>
                <declaration name="epoint" type="InetSocketAddress" line="564"/>
                <declaration name="addr" type="InetAddress" line="565"/>
                <declaration name="port" type="int" line="566"/>
                <declaration name="security" type="SecurityManager" line="569"/>
                <scope line="570"/>
                <scope line="580"/>
            </method>
            <javadoc line="595">
                Binds the socket to a local address.
                  &lt;P&gt;
                  If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up
                  an ephemeral port and a valid local address to bind the socket.                
                <param>
                    bindpoint the <code>SocketAddress</code> to bind to                    
                </param>
                <throws>
                    IOException if the bind operation fails, or if the socket
                      is already bound.                    
                </throws>
                <throws>
                    IllegalArgumentException if bindpoint is a
                      SocketAddress subclass not supported by this socket                    
                </throws>
                <since>
                    1.4                    
                </since>
                <see>
                    #isBound                    
                </see>
            </javadoc>
            <method name="bind" type="void" line="610">
                <params>
                    <param name="bindpoint" type="SocketAddress"/>
                </params>
                <declaration name="epoint" type="InetSocketAddress" line="618"/>
                <scope line="621"/>
                <declaration name="addr" type="InetAddress" line="624"/>
                <declaration name="port" type="int" line="625"/>
            </method>
            <method name="checkAddress" type="void" line="631">
                <params>
                    <param name="addr" type="InetAddress"/>
                    <param name="op" type="String"/>
                </params>
                <scope line="632"/>
                <scope line="635"/>
            </method>
            <javadoc line="640">
                set the flags after an accept() call.                
            </javadoc>
            <method name="postAccept" type="void" line="643"/>
            <method name="setCreated" type="void" line="649"/>
            <method name="setBound" type="void" line="653"/>
            <method name="setConnected" type="void" line="657"/>
            <javadoc line="661">
                Returns the address to which the socket is connected.
                  &lt;p&gt;
                  If the socket was connected prior to being {@link #close closed},
                  then this method will continue to return the connected address
                  after the socket is closed.                
                <return>
                    the remote IP address to which this socket is connected,
                      or <code>null</code> if the socket is not connected.                    
                </return>
            </javadoc>
            <method name="getInetAddress" type="InetAddress" line="671">
                <scope line="674"/>
                <scope line="676"/>
            </method>
            <javadoc line="681">
                Gets the local address to which the socket is bound.                
                <return>
                    the local address to which the socket is bound, or
                      the {@link InetAddress#isAnyLocalAddress wildcard} address
                      if the socket is closed or not bound yet.                    
                </return>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <method name="getLocalAddress" type="InetAddress" line="689">
                <comment line="691">
                    This is for backward compatibility                    
                </comment>
                <comment line="701">
                    &quot;0.0.0.0&quot;                    
                </comment>
                <declaration name="in" type="InetAddress" line="693"/>
                <scope line="694">
                    <scope line="696"/>
                </scope>
                <scope line="699"/>
            </method>
            <javadoc line="705">
                Returns the remote port number to which this socket is connected.
                  &lt;p&gt;
                  If the socket was connected prior to being {@link #close closed},
                  then this method will continue to return the connected port number
                  after the socket is closed.                
                <return>
                    the remote port number to which this socket is connected, or
                      0 if the socket is not connected yet.                    
                </return>
            </javadoc>
            <method name="getPort" type="int" line="715">
                <comment line="722">
                    Shouldn&apos;t happen as we&apos;re connected                    
                </comment>
                <scope line="718"/>
                <scope line="720"/>
            </method>
            <javadoc line="726">
                Returns the local port number to which this socket is bound.
                  &lt;p&gt;
                  If the socket was bound prior to being {@link #close closed},
                  then this method will continue to return the local port number
                  after the socket is closed.                
                <return>
                    the local port number to which this socket is bound or -1
                      if the socket is not bound yet.                    
                </return>
            </javadoc>
            <method name="getLocalPort" type="int" line="736">
                <comment line="743">
                    shouldn&apos;t happen as we&apos;re bound                    
                </comment>
                <scope line="739"/>
                <scope line="741"/>
            </method>
            <javadoc line="747">
                Returns the address of the endpoint this socket is connected to, or
                  &lt;code&gt;null&lt;/code&gt; if it is unconnected.
                  &lt;p&gt;
                  If the socket was connected prior to being {@link #close closed},
                  then this method will continue to return the connected address
                  after the socket is closed.                
                <return>
                    a <code>SocketAddress</code> representing the remote endpoint of this
                      socket, or <code>null</code> if it is not connected yet.                    
                </return>
                <see>
                    #getInetAddress()                    
                </see>
                <see>
                    #getPort()                    
                </see>
                <see>
                    #connect(SocketAddress,int)                    
                </see>
                <see>
                    #connect(SocketAddress)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getRemoteSocketAddress" type="SocketAddress" line="764"/>
            <javadoc line="770">
                Returns the address of the endpoint this socket is bound to, or
                  &lt;code&gt;null&lt;/code&gt; if it is not bound yet.
                  &lt;p&gt;
                  If a socket bound to an endpoint represented by an
                  &lt;code&gt;InetSocketAddress &lt;/code&gt; is {@link #close closed},
                  then this method will continue to return an &lt;code&gt;InetSocketAddress&lt;/code&gt;
                  after the socket is closed. In that case the returned
                  &lt;code&gt;InetSocketAddress&lt;/code&gt;&apos;s address is the{@link InetAddress#isAnyLocalAddress wildcard} address
                  and its port is the local port that it was bound to.                
                <return>
                    a <code>SocketAddress</code> representing the local endpoint of this
                      socket, or <code>null</code> if it is not bound yet.                    
                </return>
                <see>
                    #getLocalAddress()                    
                </see>
                <see>
                    #getLocalPort()                    
                </see>
                <see>
                    #bind(SocketAddress)                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getLocalSocketAddress" type="SocketAddress" line="790"/>
            <javadoc line="796">
                Returns the unique {@link java.nio.channels.SocketChannel SocketChannel}object associated with this socket, if any.
                  &lt;p&gt; A socket will have a channel if, and only if, the channel itself was
                  created via the {@link java.nio.channels.SocketChannel#openSocketChannel.open} or {@link java.nio.channels.ServerSocketChannel#accept ServerSocketChannel.accept}methods.                
                <return>
                    the socket channel associated with this socket,
                      or <tt>null</tt> if this socket was not created
                      for a channel                    
                </return>
                <since>
                    1.4                    
                </since>
                <spec>
                    JSR-51                    
                </spec>
            </javadoc>
            <method name="getChannel" type="SocketChannel" line="813"/>
            <javadoc line="817">
                Returns an input stream for this socket.
                  &lt;p&gt; If this socket has an associated channel then the resulting input
                  stream delegates all of its operations to the channel.  If the channel
                  is in non-blocking mode then the input stream&apos;s &lt;tt&gt;read&lt;/tt&gt; operations
                  will throw an {@link java.nio.channels.IllegalBlockingModeException}.
                  &lt;p&gt;Under abnormal conditions the underlying connection may be
                  broken by the remote host or the network software (for example
                  a connection reset in the case of TCP connections). When a
                  broken connection is detected by the network software the
                  following applies to the returned input stream :-
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt;The network software may discard bytes that are buffered
                  by the socket. Bytes that aren&apos;t discarded by the network
                  software can be read using {@link java.io.InputStream#read read}.
                  &lt;li&gt;&lt;p&gt;If there are no bytes buffered on the socket, or all
                  buffered bytes have been consumed by{@link java.io.InputStream#read read}, then all subsequent
                  calls to {@link java.io.InputStream#read read} will throw an{@link java.io.IOException IOException}.
                  &lt;li&gt;&lt;p&gt;If there are no bytes buffered on the socket, and the
                  socket has not been closed using {@link #close close}, then{@link java.io.InputStream#available available} will
                  return &lt;code&gt;0&lt;/code&gt;.
                  &lt;/ul&gt;
                  &lt;p&gt; Closing the returned {@link java.io.InputStream InputStream}will close the associated socket.                
                <return>
                    an input stream for reading bytes from this socket.                    
                </return>
                <exception>
                    IOException  if an I/O error occurs when creating the
                      input stream, the socket is closed, the socket is
                      not connected, or the socket input has been shutdown
                      using {@link #shutdownInput()}                    
                </exception>
                <revised>
                    1.4                    
                </revised>
                <spec>
                    JSR-51                    
                </spec>
            </javadoc>
            <method name="getInputStream" type="InputStream" line="862">
                <declaration name="s" type="Socket" line="869"/>
                <declaration name="is" type="InputStream" line="870"/>
                <scope line="871">
                    <anonymous_class line="873">
                        <method name="run" type="InputStream" line="874"/>
                    </anonymous_class>
                </scope>
                <scope line="878"/>
            </method>
            <javadoc line="884">
                Returns an output stream for this socket.
                  &lt;p&gt; If this socket has an associated channel then the resulting output
                  stream delegates all of its operations to the channel.  If the channel
                  is in non-blocking mode then the output stream&apos;s &lt;tt&gt;write&lt;/tt&gt;
                  operations will throw an {@link java.nio.channels.IllegalBlockingModeException}.
                  &lt;p&gt; Closing the returned {@link java.io.OutputStream OutputStream}will close the associated socket.                
                <return>
                    an output stream for writing bytes to this socket.                    
                </return>
                <exception>
                    IOException  if an I/O error occurs when creating the
                      output stream or if the socket is not connected.                    
                </exception>
                <revised>
                    1.4                    
                </revised>
                <spec>
                    JSR-51                    
                </spec>
            </javadoc>
            <method name="getOutputStream" type="OutputStream" line="902">
                <declaration name="s" type="Socket" line="909"/>
                <declaration name="os" type="OutputStream" line="910"/>
                <scope line="911">
                    <anonymous_class line="913">
                        <method name="run" type="OutputStream" line="914"/>
                    </anonymous_class>
                </scope>
                <scope line="918"/>
            </method>
            <javadoc line="924">
                Enable/disable TCP_NODELAY (disable/enable Nagle&apos;s algorithm).                
                <param>
                    on <code>true</code> to enable TCP_NODELAY,
                      <code>false</code> to disable.                    
                </param>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
                <see>
                    #getTcpNoDelay()                    
                </see>
            </javadoc>
            <method name="setTcpNoDelay" type="void" line="937">
                <params>
                    <param name="on" type="boolean"/>
                </params>
            </method>
            <javadoc line="943">
                Tests if TCP_NODELAY is enabled.                
                <return>
                    a <code>boolean</code> indicating whether or not TCP_NODELAY is enabled.                    
                </return>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
                <see>
                    #setTcpNoDelay(boolean)                    
                </see>
            </javadoc>
            <method name="getTcpNoDelay" type="boolean" line="952"/>
            <javadoc line="958">
                Enable/disable SO_LINGER with the specified linger time in seconds.
                  The maximum timeout value is platform specific.
                  The setting only affects socket close.                
                <param>
                    on     whether or not to linger on.                    
                </param>
                <param>
                    linger how long to linger for, if on is true.                    
                </param>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <exception>
                    IllegalArgumentException if the linger value is negative.                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
                <see>
                    #getSoLinger()                    
                </see>
            </javadoc>
            <method name="setSoLinger" type="void" line="972">
                <params>
                    <param name="on" type="boolean"/>
                    <param name="linger" type="int"/>
                </params>
                <scope line="975"/>
                <scope line="977">
                    <scope line="978"/>
                </scope>
            </method>
            <javadoc line="987">
                Returns setting for SO_LINGER. -1 returns implies that the
                  option is disabled.
                  The setting only affects socket close.                
                <return>
                    the setting for SO_LINGER.                    
                </return>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
                <see>
                    #setSoLinger(boolean,int)                    
                </see>
            </javadoc>
            <method name="getSoLinger" type="int" line="999">
                <declaration name="o" type="Object" line="1002"/>
                <scope line="1003"/>
                <scope line="1005"/>
            </method>
            <javadoc line="1010">
                Send one byte of urgent data on the socket. The byte to be sent is the lowest eight
                  bits of the data parameter. The urgent byte is
                  sent after any preceding writes to the socket OutputStream
                  and before any future writes to the OutputStream.                
                <param>
                    data The byte of data to send                    
                </param>
                <exception>
                    IOException if there is an error
                      sending the data.                    
                </exception>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="sendUrgentData" type="void" line="1020">
                <params>
                    <param name="data" type="int"/>
                </params>
                <scope line="1021"/>
            </method>
            <javadoc line="1027">
                Enable/disable OOBINLINE (receipt of TCP urgent data)
                  By default, this option is disabled and TCP urgent data received on a
                  socket is silently discarded. If the user wishes to receive urgent data, then
                  this option must be enabled. When enabled, urgent data is received
                  inline with normal data.
                  &lt;p&gt;
                  Note, only limited support is provided for handling incoming urgent
                  data. In particular, no notification of incoming urgent data is provided
                  and there is no capability to distinguish between normal data and urgent
                  data unless provided by a higher level protocol.                
                <param>
                    on <code>true</code> to enable OOBINLINE,
                      <code>false</code> to disable.                    
                </param>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    1.4                    
                </since>
                <see>
                    #getOOBInline()                    
                </see>
            </javadoc>
            <method name="setOOBInline" type="void" line="1050">
                <params>
                    <param name="on" type="boolean"/>
                </params>
            </method>
            <javadoc line="1056">
                Tests if OOBINLINE is enabled.                
                <return>
                    a <code>boolean</code> indicating whether or not OOBINLINE is enabled.                    
                </return>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    1.4                    
                </since>
                <see>
                    #setOOBInline(boolean)                    
                </see>
            </javadoc>
            <method name="getOOBInline" type="boolean" line="1065"/>
            <javadoc line="1071">
                Enable/disable SO_TIMEOUT with the specified timeout, in
                  milliseconds.  With this option set to a non-zero timeout,
                  a read() call on the InputStream associated with this Socket
                  will block for only this amount of time.  If the timeout expires,
                  a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
                  Socket is still valid. The option &lt;B&gt;must&lt;/B&gt; be enabled
                  prior to entering the blocking operation to have effect. The
                  timeout must be &gt; 0.
                  A timeout of zero is interpreted as an infinite timeout.                
                <param>
                    timeout the specified timeout, in milliseconds.                    
                </param>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    JDK 1.1                    
                </since>
                <see>
                    #getSoTimeout()                    
                </see>
            </javadoc>
            <method name="setSoTimeout" type="void" line="1087">
                <params>
                    <param name="timeout" type="int"/>
                </params>
            </method>
            <javadoc line="1096">
                Returns setting for SO_TIMEOUT.  0 returns implies that the
                  option is disabled (i.e., timeout of infinity).                
                <return>
                    the setting for SO_TIMEOUT                    
                </return>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    JDK1.1                    
                </since>
                <see>
                    #setSoTimeout(int)                    
                </see>
            </javadoc>
            <method name="getSoTimeout" type="int" line="1105">
                <comment line="1110">
                                        
                </comment>
                <declaration name="o" type="Object" line="1108"/>
                <scope line="1110"/>
                <scope line="1112"/>
            </method>
            <javadoc line="1117">
                Sets the SO_SNDBUF option to the specified value for this
                  &lt;tt&gt;Socket&lt;/tt&gt;. The SO_SNDBUF option is used by the platform&apos;s
                  networking code as a hint for the size to set
                  the underlying network I/O buffers.
                  &lt;p&gt;Because SO_SNDBUF is a hint, applications that want to
                  verify what size the buffers were set to should call{@link #getSendBufferSize()}.                
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <param>
                    size the size to which to set the send buffer
                      size. This value must be greater than 0.                    
                </param>
                <exception>
                    IllegalArgumentException if the
                      value is 0 or is negative.                    
                </exception>
                <see>
                    #getSendBufferSize()                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setSendBufferSize" type="void" line="1140">
                <params>
                    <param name="size" type="int"/>
                </params>
                <scope line="1141"/>
            </method>
            <javadoc line="1149">
                Get value of the SO_SNDBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;,
                  that is the buffer size used by the platform
                  for output on this &lt;tt&gt;Socket&lt;/tt&gt;.                
                <return>
                    the value of the SO_SNDBUF option for this <tt>Socket</tt>.                    
                </return>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <see>
                    #setSendBufferSize(int)                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getSendBufferSize" type="int" line="1161">
                <declaration name="result" type="int" line="1164"/>
                <declaration name="o" type="Object" line="1165"/>
                <scope line="1166"/>
            </method>
            <javadoc line="1172">
                Sets the SO_RCVBUF option to the specified value for this
                  &lt;tt&gt;Socket&lt;/tt&gt;. The SO_RCVBUF option is used by the platform&apos;s
                  networking code as a hint for the size to set
                  the underlying network I/O buffers.
                  &lt;p&gt;Increasing the receive buffer size can increase the performance of
                  network I/O for high-volume connection, while decreasing it can
                  help reduce the backlog of incoming data.
                  &lt;p&gt;Because SO_RCVBUF is a hint, applications that want to
                  verify what size the buffers were set to should call{@link #getReceiveBufferSize()}.
                  &lt;p&gt;The value of SO_RCVBUF is also used to set the TCP receive window
                  that is advertized to the remote peer. Generally, the window size
                  can be modified at any time when a socket is connected. However, if
                  a receive window larger than 64K is required then this must be requested
                  &lt;B&gt;before&lt;/B&gt; the socket is connected to the remote peer. There are two
                  cases to be aware of:&lt;p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;For sockets accepted from a ServerSocket, this must be done by calling{@link ServerSocket#setReceiveBufferSize(int)} before the ServerSocket
                  is bound to a local address.&lt;p&gt;&lt;/li&gt;
                  &lt;li&gt;For client sockets, setReceiveBufferSize() must be called before
                  connecting the socket to its remote peer.&lt;p&gt;&lt;/li&gt;&lt;/ol&gt;                
                <param>
                    size the size to which to set the receive buffer
                      size. This value must be greater than 0.                    
                </param>
                <exception>
                    IllegalArgumentException if the value is 0 or is
                      negative.                    
                </exception>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <see>
                    #getReceiveBufferSize()                    
                </see>
                <see>
                    ServerSocket#setReceiveBufferSize(int)                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setReceiveBufferSize" type="void" line="1212">
                <params>
                    <param name="size" type="int"/>
                </params>
                <scope line="1213"/>
            </method>
            <javadoc line="1221">
                Gets the value of the SO_RCVBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;,
                  that is the buffer size used by the platform for
                  input on this &lt;tt&gt;Socket&lt;/tt&gt;.                
                <return>
                    the value of the SO_RCVBUF option for this <tt>Socket</tt>.                    
                </return>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <see>
                    #setReceiveBufferSize(int)                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getReceiveBufferSize" type="int" line="1233">
                <declaration name="result" type="int" line="1236"/>
                <declaration name="o" type="Object" line="1237"/>
                <scope line="1238"/>
            </method>
            <javadoc line="1244">
                Enable/disable SO_KEEPALIVE.                
                <param>
                    on     whether or not to have socket keep alive turned on.                    
                </param>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    1.3                    
                </since>
                <see>
                    #getKeepAlive()                    
                </see>
            </javadoc>
            <method name="setKeepAlive" type="void" line="1253">
                <params>
                    <param name="on" type="boolean"/>
                </params>
            </method>
            <javadoc line="1259">
                Tests if SO_KEEPALIVE is enabled.                
                <return>
                    a <code>boolean</code> indicating whether or not SO_KEEPALIVE is enabled.                    
                </return>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    1.3                    
                </since>
                <see>
                    #setKeepAlive(boolean)                    
                </see>
            </javadoc>
            <method name="getKeepAlive" type="boolean" line="1268"/>
            <javadoc line="1274">
                Sets traffic class or type-of-service octet in the IP
                  header for packets sent from this Socket.
                  As the underlying network implementation may ignore this
                  value applications should consider it a hint.
                  &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range &lt;code&gt; 0 &lt;= tc &lt;=
                  255&lt;/code&gt; or an IllegalArgumentException will be thrown.
                  &lt;p&gt;Notes:
                  &lt;p&gt;For Internet Protocol v4 the value consists of an
                  &lt;code&gt;integer&lt;/code&gt;, the least significant 8 bits of which
                  represent the value of the TOS octet in IP packets sent by
                  the socket.
                  RFC 1349 defines the TOS values as follows:
                  &lt;p&gt;
                  &lt;UL&gt;
                  &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWCOST (0x02)&lt;/CODE&gt;&lt;/LI&gt;
                  &lt;LI&gt;&lt;CODE&gt;IPTOS_RELIABILITY (0x04)&lt;/CODE&gt;&lt;/LI&gt;
                  &lt;LI&gt;&lt;CODE&gt;IPTOS_THROUGHPUT (0x08)&lt;/CODE&gt;&lt;/LI&gt;
                  &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWDELAY (0x10)&lt;/CODE&gt;&lt;/LI&gt;
                  &lt;/UL&gt;
                  The last low order bit is always ignored as this
                  corresponds to the MBZ (must be zero) bit.
                  &lt;p&gt;
                  Setting bits in the precedence field may result in a
                  SocketException indicating that the operation is not
                  permitted.
                  &lt;p&gt;
                  As RFC 1122 section 4.2.4.2 indicates, a compliant TCP
                  implementation should, but is not required to, let application
                  change the TOS field during the lifetime of a connection.
                  So whether the type-of-service field can be changed after the
                  TCP connection has been established depends on the implementation
                  in the underlying platform. Applications should not assume that
                  they can change the TOS field after the connection.
                  &lt;p&gt;
                  For Internet Protocol v6 &lt;code&gt;tc&lt;/code&gt; is the value that
                  would be placed into the sin6_flowinfo field of the IP header.                
                <param>
                    tc        an <code>int</code> value for the bitset.                    
                </param>
                <throws>
                    SocketException if there is an error setting the
                      traffic class or type-of-service                    
                </throws>
                <since>
                    1.4                    
                </since>
                <see>
                    #getTrafficClass                    
                </see>
            </javadoc>
            <method name="setTrafficClass" type="void" line="1319">
                <params>
                    <param name="tc" type="int"/>
                </params>
            </method>
            <javadoc line="1328">
                Gets traffic class or type-of-service in the IP header
                  for packets sent from this Socket
                  &lt;p&gt;
                  As the underlying network implementation may ignore the
                  traffic class or type-of-service set using {@link #setTrafficClass(int)}this method may return a different value than was previously
                  set using the {@link #setTrafficClass(int)} method on this Socket.                
                <return>
                    the traffic class or type-of-service already set                    
                </return>
                <throws>
                    SocketException if there is an error obtaining the
                      traffic class or type-of-service value.                    
                </throws>
                <since>
                    1.4                    
                </since>
                <see>
                    #setTrafficClass(int)                    
                </see>
            </javadoc>
            <method name="getTrafficClass" type="int" line="1343"/>
            <javadoc line="1347">
                Enable/disable the SO_REUSEADDR socket option.
                  &lt;p&gt;
                  When a TCP connection is closed the connection may remain
                  in a timeout state for a period of time after the connection
                  is closed (typically known as the &lt;tt&gt;TIME_WAIT&lt;/tt&gt; state
                  or &lt;tt&gt;2MSL&lt;/tt&gt; wait state).
                  For applications using a well known socket address or port
                  it may not be possible to bind a socket to the required
                  &lt;tt&gt;SocketAddress&lt;/tt&gt; if there is a connection in the
                  timeout state involving the socket address or port.
                  &lt;p&gt;
                  Enabling &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; prior to binding the socket
                  using {@link #bind(SocketAddress)} allows the socket to be
                  bound even though a previous connection is in a timeout
                  state.
                  &lt;p&gt;
                  When a &lt;tt&gt;Socket&lt;/tt&gt; is created the initial setting
                  of &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; is disabled.
                  &lt;p&gt;
                  The behaviour when &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; is enabled or
                  disabled after a socket is bound (See {@link #isBound()})
                  is not defined.                
                <param>
                    on  whether to enable or disable the socket option                    
                </param>
                <exception>
                    SocketException if an error occurs enabling or
                      disabling the <tt>SO_RESUEADDR</tt> socket option,
                      or the socket is closed.                    
                </exception>
                <since>
                    1.4                    
                </since>
                <see>
                    #getReuseAddress()                    
                </see>
                <see>
                    #bind(SocketAddress)                    
                </see>
                <see>
                    #isClosed()                    
                </see>
                <see>
                    #isBound()                    
                </see>
            </javadoc>
            <method name="setReuseAddress" type="void" line="1381">
                <params>
                    <param name="on" type="boolean"/>
                </params>
            </method>
            <javadoc line="1387">
                Tests if SO_REUSEADDR is enabled.                
                <return>
                    a <code>boolean</code> indicating whether or not SO_REUSEADDR is enabled.                    
                </return>
                <exception>
                    SocketException if there is an error
                      in the underlying protocol, such as a TCP error.                    
                </exception>
                <since>
                    1.4                    
                </since>
                <see>
                    #setReuseAddress(boolean)                    
                </see>
            </javadoc>
            <method name="getReuseAddress" type="boolean" line="1396"/>
            <javadoc line="1402">
                Closes this socket.
                  &lt;p&gt;
                  Any thread currently blocked in an I/O operation upon this socket
                  will throw a {@link SocketException}.
                  &lt;p&gt;
                  Once a socket has been closed, it is not available for further networking
                  use (i.e. can&apos;t be reconnected or rebound). A new socket needs to be
                  created.
                  &lt;p&gt; Closing this socket will also close the socket&apos;s{@link java.io.InputStream InputStream} and{@link java.io.OutputStream OutputStream}.
                  &lt;p&gt; If this socket has an associated channel then the channel is closed
                  as well.                
                <exception>
                    IOException  if an I/O error occurs when closing this socket.                    
                </exception>
                <revised>
                    1.4                    
                </revised>
                <spec>
                    JSR-51                    
                </spec>
                <see>
                    #isClosed                    
                </see>
            </javadoc>
            <method name="close" type="void" line="1424">
                <scope line="1425"/>
            </method>
            <javadoc line="1434">
                Places the input stream for this socket at &quot;end of stream&quot;.
                  Any data sent to the input stream side of the socket is acknowledged
                  and then silently discarded.
                  &lt;p&gt;
                  If you read from a socket input stream after invoking
                  shutdownInput() on the socket, the stream will return EOF.                
                <exception>
                    IOException if an I/O error occurs when shutting down this
                      socket.                    
                </exception>
                <since>
                    1.3                    
                </since>
                <see>
                    java.net.Socket#shutdownOutput()                    
                </see>
                <see>
                    java.net.Socket#close()                    
                </see>
                <see>
                    java.net.Socket#setSoLinger(boolean,int)                    
                </see>
                <see>
                    #isInputShutdown                    
                </see>
            </javadoc>
            <method name="shutdownInput" type="void" line="1452"/>
            <javadoc line="1463">
                Disables the output stream for this socket.
                  For a TCP socket, any previously written data will be sent
                  followed by TCP&apos;s normal connection termination sequence.
                  If you write to a socket output stream after invoking
                  shutdownOutput() on the socket, the stream will throw
                  an IOException.                
                <exception>
                    IOException if an I/O error occurs when shutting down this
                      socket.                    
                </exception>
                <since>
                    1.3                    
                </since>
                <see>
                    java.net.Socket#shutdownInput()                    
                </see>
                <see>
                    java.net.Socket#close()                    
                </see>
                <see>
                    java.net.Socket#setSoLinger(boolean,int)                    
                </see>
                <see>
                    #isOutputShutdown                    
                </see>
            </javadoc>
            <method name="shutdownOutput" type="void" line="1482"/>
            <javadoc line="1493">
                Converts this socket to a &lt;code&gt;String&lt;/code&gt;.                
                <return>
                    a string representation of this socket.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1498">
                <scope line="1499"/>
                <scope line="1504"/>
            </method>
            <javadoc line="1509">
                Returns the connection state of the socket.
                  &lt;p&gt;
                  Note: Closing a socket doesn&apos;t clear its connection state, which means
                  this method will return &lt;code&gt;true&lt;/code&gt; for a closed socket
                  (see {@link #isClosed()}) if it was successfuly connected prior
                  to being closed.                
                <return>
                    true if the socket was successfuly connected to a server                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="isConnected" type="boolean" line="1520">
                <comment line="1522">
                    Before 1.3 Sockets were always connected during creation                    
                </comment>
            </method>
            <javadoc line="1525">
                Returns the binding state of the socket.
                  &lt;p&gt;
                  Note: Closing a socket doesn&apos;t clear its binding state, which means
                  this method will return &lt;code&gt;true&lt;/code&gt; for a closed socket
                  (see {@link #isClosed()}) if it was successfuly bound prior
                  to being closed.                
                <return>
                    true if the socket was successfuly bound to an address                    
                </return>
                <since>
                    1.4                    
                </since>
                <see>
                    #bind                    
                </see>
            </javadoc>
            <method name="isBound" type="boolean" line="1537">
                <comment line="1539">
                    Before 1.3 Sockets were always bound during creation                    
                </comment>
            </method>
            <javadoc line="1542">
                Returns the closed state of the socket.                
                <return>
                    true if the socket has been closed                    
                </return>
                <since>
                    1.4                    
                </since>
                <see>
                    #close                    
                </see>
            </javadoc>
            <method name="isClosed" type="boolean" line="1549">
                <scope line="1550"/>
            </method>
            <javadoc line="1555">
                Returns whether the read-half of the socket connection is closed.                
                <return>
                    true if the input of the socket has been shutdown                    
                </return>
                <since>
                    1.4                    
                </since>
                <see>
                    #shutdownInput                    
                </see>
            </javadoc>
            <method name="isInputShutdown" type="boolean" line="1562"/>
            <javadoc line="1566">
                Returns whether the write-half of the socket connection is closed.                
                <return>
                    true if the output of the socket has been shutdown                    
                </return>
                <since>
                    1.4                    
                </since>
                <see>
                    #shutdownOutput                    
                </see>
            </javadoc>
            <method name="isOutputShutdown" type="boolean" line="1573"/>
            <declaration name="factory" type="SocketImplFactory" line="1577"/>
            <javadoc line="1577">
                The factory for all client sockets.                
            </javadoc>
            <javadoc line="1582">
                Sets the client socket implementation factory for the
                  application. The factory can be specified only once.
                  &lt;p&gt;
                  When an application creates a new client socket, the socket
                  implementation factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is
                  called to create the actual socket implementation.
                  &lt;p&gt;
                  Passing &lt;code&gt;null&lt;/code&gt; to the method is a no-op unless the factory
                  was already set.
                  &lt;p&gt;If there is a security manager, this method first calls
                  the security manager&apos;s &lt;code&gt;checkSetFactory&lt;/code&gt; method
                  to ensure the operation is allowed.
                  This could result in a SecurityException.                
                <param>
                    fac   the desired factory.                    
                </param>
                <exception>
                    IOException  if an I/O error occurs when setting the
                      socket factory.                    
                </exception>
                <exception>
                    SocketException  if the factory is already defined.                    
                </exception>
                <exception>
                    SecurityException  if a security manager exists and its
                      <code>checkSetFactory</code> method doesn't allow the operation.                    
                </exception>
                <see>
                    java.net.SocketImplFactory#createSocketImpl()                    
                </see>
                <see>
                    SecurityManager#checkSetFactory                    
                </see>
            </javadoc>
            <method name="setSocketImplFactory" type="void" line="1608">
                <params>
                    <param name="fac" type="SocketImplFactory"/>
                </params>
                <scope line="1609"/>
                <declaration name="security" type="SecurityManager" line="1612"/>
                <scope line="1613"/>
            </method>
            <javadoc line="1619">
                Sets performance preferences for this socket.
                  &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
                  may offer alternative protocols which have different performance
                  characteristics than TCP/IP.  This method allows the application to
                  express its own preferences as to how these tradeoffs should be made
                  when the implementation chooses from the available protocols.
                  &lt;p&gt; Performance preferences are described by three integers
                  whose values indicate the relative importance of short connection time,
                  low latency, and high bandwidth.  The absolute values of the integers
                  are irrelevant; in order to choose a protocol the values are simply
                  compared, with larger values indicating stronger preferences. Negative
                  values represent a lower priority than positive values. If the
                  application prefers short connection time over both low latency and high
                  bandwidth, for example, then it could invoke this method with the values
                  &lt;tt&gt;(1, 0, 0)&lt;/tt&gt;.  If the application prefers high bandwidth above low
                  latency, and low latency above short connection time, then it could
                  invoke this method with the values &lt;tt&gt;(0, 1, 2)&lt;/tt&gt;.
                  &lt;p&gt; Invoking this method after this socket has been connected
                  will have no effect.                
                <param>
                    connectionTimeAn <tt>int</tt> expressing the relative importance of a short
                      connection time                    
                </param>
                <param>
                    latencyAn <tt>int</tt> expressing the relative importance of low
                      latency                    
                </param>
                <param>
                    bandwidthAn <tt>int</tt> expressing the relative importance of high
                      bandwidth                    
                </param>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setPerformancePreferences" type="void" line="1660">
                <params>
                    <param name="connectionTime" type="int"/>
                    <param name="latency" type="int"/>
                    <param name="bandwidth" type="int"/>
                </params>
                <comment line="1662">
                                        
                </comment>
            </method>
        </class>
    </source>