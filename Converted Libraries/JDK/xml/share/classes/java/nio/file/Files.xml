<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.nio.file">
        <import package="java.nio.file.attribute"/>
        <import package="java.nio.file.spi.FileSystemProvider"/>
        <import package="java.nio.file.spi.FileTypeDetector"/>
        <import package="java.nio.channels.SeekableByteChannel"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.Reader"/>
        <import package="java.io.Writer"/>
        <import package="java.io.BufferedReader"/>
        <import package="java.io.BufferedWriter"/>
        <import package="java.io.InputStreamReader"/>
        <import package="java.io.OutputStreamWriter"/>
        <import package="java.io.IOException"/>
        <import package="java.util"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.nio.charset.Charset"/>
        <import package="java.nio.charset.CharsetDecoder"/>
        <import package="java.nio.charset.CharsetEncoder"/>
        <class name="Files" line="48">
            <comment line="69">
                -- File contents --                
            </comment>
            <comment line="365">
                -- Directories --                
            </comment>
            <comment line="541">
                -- Creation and deletion --                
            </comment>
            <comment line="1114">
                -- Copying and moving files --                
            </comment>
            <comment line="1348">
                -- Miscellenous --                
            </comment>
            <comment line="1479">
                lazy loading of default and installed file type detectors                
            </comment>
            <comment line="1563">
                -- File Attributes --                
            </comment>
            <comment line="2262">
                -- Accessibility --                
            </comment>
            <comment line="2486">
                -- Recursive operations --                
            </comment>
            <comment line="2626">
                -- Utility methods for simple usages --                
            </comment>
            <comment line="2628">
                buffer size used for reading and writing                
            </comment>
            <javadoc line="48">
                This class consists exclusively of static methods that operate on files,
                  directories, or other types of files.
                  &lt;p&gt; In most cases, the methods defined here will delegate to the associated
                  file system provider to perform the file operations.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="Files" type="constructor" line="59"/>
            <javadoc line="61">
                Returns the {@code FileSystemProvider} to delegate to.                
            </javadoc>
            <method name="provider" type="FileSystemProvider" line="64">
                <params>
                    <param name="path" type="Path"/>
                </params>
            </method>
            <javadoc line="70">
                Opens a file, returning an input stream to read from the file. The stream
                  will not be buffered, and is not required to support the {@link InputStream#mark mark} or {@link InputStream#reset reset} methods. The
                  stream will be safe for access by multiple concurrent threads. Reading
                  commences at the beginning of the file. Whether the returned stream is
                  &lt;i&gt;asynchronously closeable&lt;/i&gt; and/or &lt;i&gt;interruptible&lt;/i&gt; is highly
                  file system provider specific and therefore not specified.
                  &lt;p&gt; The {@code options} parameter determines how the file is opened.
                  If no options are present then it is equivalent to opening the file with
                  the {@link StandardOpenOption#READ READ} option. In addition to the {@codeREAD} option, an implementation may also support additional implementation
                  specific options.                
                <param>
                    paththe path to the file to open                    
                </param>
                <param>
                    optionsoptions specifying how the file is opened                    
                </param>
                <return>
                    a new input stream                    
                </return>
                <throws>
                    IllegalArgumentExceptionif an invalid combination of options is specified                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif an unsupported option is specified                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the file.                    
                </throws>
            </javadoc>
            <method name="newInputStream" type="InputStream" line="105">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="OpenOption"/>
                </params>
            </method>
            <javadoc line="109">
                Opens or creates a file, returning an output stream that may be used to
                  write bytes to the file. The resulting stream will not be buffered. The
                  stream will be safe for access by multiple concurrent threads. Whether
                  the returned stream is &lt;i&gt;asynchronously closeable&lt;/i&gt; and/or
                  &lt;i&gt;interruptible&lt;/i&gt; is highly file system provider specific and
                  therefore not specified.
                  &lt;p&gt; This method opens or creates a file in exactly the manner specified
                  by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}method with the exception that the {@link StandardOpenOption#READ READ}option may not be present in the array of options. If no options are
                  present then this method works as if the {@link StandardOpenOption#CREATECREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},
                  and {@link StandardOpenOption#WRITE WRITE} options are present. In other
                  words, it opens the file for writing, creating the file if it doesn&apos;t
                  exist, or initially truncating an existing {@link #isRegularFileregular-file} to a size of {@code 0} if it exists.
                  &lt;p&gt; &lt;b&gt;Usage Examples:&lt;/b&gt;
                  &lt;pre&gt;
                  Path path = ...
                  // truncate and overwrite an existing file, or create the file if
                  // it doesn&apos;t initially exist
                  OutputStream out = Files.newOutputStream(path);
                  // append to an existing file, fail if the file does not exist
                  out = Files.newOutputStream(path, APPEND);
                  // append to an existing file, create file if it doesn&apos;t initially exist
                  out = Files.newOutputStream(path, CREATE, APPEND);
                  // always create new file, failing if it already exists
                  out = Files.newOutputStream(path, CREATE_NEW);
                  &lt;/pre&gt;                
                <param>
                    paththe path to the file to open or create                    
                </param>
                <param>
                    optionsoptions specifying how the file is opened                    
                </param>
                <return>
                    a new output stream                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code options} contains an invalid combination of options                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif an unsupported option is specified                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to the file. The {@link SecurityManager#checkDelete(String) checkDelete} method is
                      invoked to check delete access if the file is opened with the{@code DELETE_ON_CLOSE} option.                    
                </throws>
            </javadoc>
            <method name="newOutputStream" type="OutputStream" line="169">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="OpenOption"/>
                </params>
            </method>
            <javadoc line="173">
                Opens or creates a file, returning a seekable byte channel to access the
                  file.
                  &lt;p&gt; The {@code options} parameter determines how the file is opened.
                  The {@link StandardOpenOption#READ READ} and {@link StandardOpenOption#WRITE WRITE} options determine if the file should be
                  opened for reading and/or writing. If neither option (or the {@link StandardOpenOption#APPEND APPEND} option) is present then the file is
                  opened for reading. By default reading or writing commence at the
                  beginning of the file.
                  &lt;p&gt; In the addition to {@code READ} and {@code WRITE}, the following
                  options may be present:
                  &lt;table border=1 cellpadding=5 summary=&quot;&quot;&gt;
                  &lt;tr&gt; &lt;th&gt;Option&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt; &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#APPEND APPEND} &lt;/td&gt;
                  &lt;td&gt; If this option is present then the file is opened for writing and
                  each invocation of the channel&apos;s {@code write} method first advances
                  the position to the end of the file and then writes the requested
                  data. Whether the advancement of the position and the writing of the
                  data are done in a single atomic operation is system-dependent and
                  therefore unspecified. This option may not be used in conjunction
                  with the {@code READ} or {@code TRUNCATE_EXISTING} options. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} &lt;/td&gt;
                  &lt;td&gt; If this option is present then the existing file is truncated to
                  a size of 0 bytes. This option is ignored when the file is opened only
                  for reading. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#CREATE_NEW CREATE_NEW} &lt;/td&gt;
                  &lt;td&gt; If this option is present then a new file is created, failing if
                  the file already exists or is a symbolic link. When creating a file the
                  check for the existence of the file and the creation of the file if it
                  does not exist is atomic with respect to other file system operations.
                  This option is ignored when the file is opened only for reading. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td &gt; {@link StandardOpenOption#CREATE CREATE} &lt;/td&gt;
                  &lt;td&gt; If this option is present then an existing file is opened if it
                  exists, otherwise a new file is created. This option is ignored if the{@code CREATE_NEW} option is also present or the file is opened only
                  for reading. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td &gt; {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} &lt;/td&gt;
                  &lt;td&gt; When this option is present then the implementation makes a
                  &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the{@link SeekableByteChannel#close close} method. If the {@code close}method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to
                  delete the file when the Java virtual machine terminates. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;{@link StandardOpenOption#SPARSE SPARSE} &lt;/td&gt;
                  &lt;td&gt; When creating a new file this option is a &lt;em&gt;hint&lt;/em&gt; that the
                  new file will be sparse. This option is ignored when not creating
                  a new file. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#SYNC SYNC} &lt;/td&gt;
                  &lt;td&gt; Requires that every update to the file&apos;s content or metadata be
                  written synchronously to the underlying storage device. (see &lt;a
                  href=&quot;package-summary.html#integrity&quot;&gt; Synchronized I/O file
                  integrity&lt;/a&gt;). &lt;/td&gt;
                  &lt;tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#DSYNC DSYNC} &lt;/td&gt;
                  &lt;td&gt; Requires that every update to the file&apos;s content be written
                  synchronously to the underlying storage device. (see &lt;a
                  href=&quot;package-summary.html#integrity&quot;&gt; Synchronized I/O file
                  integrity&lt;/a&gt;). &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;p&gt; An implementation may also support additional implementation specific
                  options.
                  &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttributefile-attributes} to set atomically when a new file is created.
                  &lt;p&gt; In the case of the default provider, the returned seekable byte channel
                  is a {@link java.nio.channels.FileChannel}.
                  &lt;p&gt; &lt;b&gt;Usage Examples:&lt;/b&gt;
                  &lt;pre&gt;
                  Path path = ...
                  // open file for reading
                  ReadableByteChannel rbc = Files.newByteChannel(path, EnumSet.of(READ)));
                  // open file for writing to the end of an existing file, creating
                  // the file if it doesn&apos;t already exist
                  WritableByteChannel wbc = Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));
                  // create file with initial permissions, opening it for both reading and writing{@code FileAttribute&lt;&lt;SetPosixFilePermission&gt;&gt; perms = ...}SeekableByteChannel sbc = Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);
                  &lt;/pre&gt;                
                <param>
                    paththe path to the file to open or create                    
                </param>
                <param>
                    optionsoptions specifying how the file is opened                    
                </param>
                <param>
                    attrsan optional list of file attributes to set atomically when
                      creating the file                    
                </param>
                <return>
                    a new seekable byte channel                    
                </return>
                <throws>
                    IllegalArgumentExceptionif the set contains an invalid combination of options                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif an unsupported open option is specified or the array contains
                      attributes that cannot be set atomically when creating the file                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif a file of that name already exists and the {@link StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified
                      <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the path if the file is
                      opened for reading. The {@link SecurityManager#checkWrite(String)checkWrite} method is invoked to check write access to the path
                      if the file is opened for writing. The {@link SecurityManager#checkDelete(String) checkDelete} method is
                      invoked to check delete access if the file is opened with the{@code DELETE_ON_CLOSE} option.                    
                </throws>
                <see>
                    java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])                    
                </see>
            </javadoc>
            <method name="newByteChannel" type="SeekableByteChannel" line="314">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="Set<? extends OpenOption>"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
            </method>
            <javadoc line="318">
                Opens or creates a file, returning a seekable byte channel to access the
                  file.
                  &lt;p&gt; This method opens or creates a file in exactly the manner specified
                  by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}method.                
                <param>
                    paththe path to the file to open or create                    
                </param>
                <param>
                    optionsoptions specifying how the file is opened                    
                </param>
                <return>
                    a new seekable byte channel                    
                </return>
                <throws>
                    IllegalArgumentExceptionif the set contains an invalid combination of options                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif an unsupported open option is specified                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif a file of that name already exists and the {@link StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified
                      <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the path if the file is
                      opened for reading. The {@link SecurityManager#checkWrite(String)checkWrite} method is invoked to check write access to the path
                      if the file is opened for writing. The {@link SecurityManager#checkDelete(String) checkDelete} method is
                      invoked to check delete access if the file is opened with the{@code DELETE_ON_CLOSE} option.                    
                </throws>
                <see>
                    java.nio.channels.FileChannel#open(Path,OpenOption[])                    
                </see>
            </javadoc>
            <method name="newByteChannel" type="SeekableByteChannel" line="358">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="OpenOption"/>
                </params>
                <declaration name="set" type="Set&lt;OpenOption&gt;" line="359"/>
            </method>
            <javadoc line="366">
                Opens a directory, returning a {@link DirectoryStream} to iterate over
                  all entries in the directory. The elements returned by the directory
                  stream&apos;s {@link DirectoryStream#iterator iterator} are of type {@codePath}, each one representing an entry in the directory. The {@code Path}objects are obtained as if by {@link Path#resolve(Path) resolving} the
                  name of the directory entry against {@code dir}.
                  &lt;p&gt; When not using the try-with-resources construct, then directory
                  stream&apos;s {@code close} method should be invoked after iteration is
                  completed so as to free any resources held for the open directory.
                  &lt;p&gt; When an implementation supports operations on entries in the
                  directory that execute in a race-free manner then the returned directory
                  stream is a {@link SecureDirectoryStream}.                
                <param>
                    dirthe path to the directory                    
                </param>
                <return>
                    a new and open {@code DirectoryStream} object                    
                </return>
                <throws>
                    NotDirectoryExceptionif the file could not otherwise be opened because it is not
                      a directory <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the directory.                    
                </throws>
            </javadoc>
            <method name="newDirectoryStream" type="DirectoryStream<Path>" line="399">
                <params>
                    <param name="dir" type="Path"/>
                </params>
                <anonymous_class line="400">
                    <method name="accept" type="boolean" line="402">
                        <params>
                            <param name="entry" type="Path"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="408">
                Opens a directory, returning a {@link DirectoryStream} to iterate over
                  the entries in the directory. The elements returned by the directory
                  stream&apos;s {@link DirectoryStream#iterator iterator} are of type {@codePath}, each one representing an entry in the directory. The {@code Path}objects are obtained as if by {@link Path#resolve(Path) resolving} the
                  name of the directory entry against {@code dir}. The entries returned by
                  the iterator are filtered by matching the {@code String} representation
                  of their file names against the given &lt;em&gt;globbing&lt;/em&gt; pattern.
                  &lt;p&gt; For example, suppose we want to iterate over the files ending with
                  &quot;.java&quot; in a directory:
                  &lt;pre&gt;
                  Path dir = ...
                  try (DirectoryStream&amp;lt;Path&amp;gt; stream = Files.newDirectoryStream(dir, &quot;.java&quot;)) {
                  :
                  }
                  &lt;/pre&gt;
                  &lt;p&gt; The globbing pattern is specified by the {@link FileSystem#getPathMatcher getPathMatcher} method.
                  &lt;p&gt; When not using the try-with-resources construct, then directory
                  stream&apos;s {@code close} method should be invoked after iteration is
                  completed so as to free any resources held for the open directory.
                  &lt;p&gt; When an implementation supports operations on entries in the
                  directory that execute in a race-free manner then the returned directory
                  stream is a {@link SecureDirectoryStream}.                
                <param>
                    dirthe path to the directory                    
                </param>
                <param>
                    globthe glob pattern                    
                </param>
                <return>
                    a new and open {@code DirectoryStream} object                    
                </return>
                <throws>
                    java.util.regex.PatternSyntaxExceptionif the pattern is invalid                    
                </throws>
                <throws>
                    NotDirectoryExceptionif the file could not otherwise be opened because it is not
                      a directory <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the directory.                    
                </throws>
            </javadoc>
            <method name="newDirectoryStream" type="DirectoryStream<Path>" line="459">
                <params>
                    <param name="dir" type="Path"/>
                    <param name="glob" type="String"/>
                </params>
                <comment line="461">
                    avoid creating a matcher if all entries are required.                    
                </comment>
                <comment line="465">
                    create a matcher and return a filter that uses it.                    
                </comment>
                <declaration name="fs" type="FileSystem" line="465"/>
                <declaration name="matcher" type="PathMatcher" line="466"/>
                <anonymous_class line="467">
                    <method name="accept" type="boolean" line="469">
                        <params>
                            <param name="entry" type="Path"/>
                        </params>
                    </method>
                </anonymous_class>
                <declaration name="filter" type="DirectoryStream.Filter&lt;Path&gt;" line="467"/>
            </method>
            <javadoc line="476">
                Opens a directory, returning a {@link DirectoryStream} to iterate over
                  the entries in the directory. The elements returned by the directory
                  stream&apos;s {@link DirectoryStream#iterator iterator} are of type {@codePath}, each one representing an entry in the directory. The {@code Path}objects are obtained as if by {@link Path#resolve(Path) resolving} the
                  name of the directory entry against {@code dir}. The entries returned by
                  the iterator are filtered by the given {@link DirectoryStream.Filterfilter}.
                  &lt;p&gt; When not using the try-with-resources construct, then directory
                  stream&apos;s {@code close} method should be invoked after iteration is
                  completed so as to free any resources held for the open directory.
                  &lt;p&gt; Where the filter terminates due to an uncaught error or runtime
                  exception then it is propagated to the {@link Iterator#hasNext()hasNext} or {@link Iterator#next() next} method. Where an {@codeIOException} is thrown, it results in the {@code hasNext} or {@codenext} method throwing a {@link DirectoryIteratorException} with the{@code IOException} as the cause.
                  &lt;p&gt; When an implementation supports operations on entries in the
                  directory that execute in a race-free manner then the returned directory
                  stream is a {@link SecureDirectoryStream}.
                  &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
                  Suppose we want to iterate over the files in a directory that are
                  larger than 8K.
                  &lt;pre&gt;
                  DirectoryStream.Filter&amp;lt;Path&amp;gt; filter = new DirectoryStream.Filter&amp;lt;Path&amp;gt;() {
                  public boolean accept(Path file) throws IOException {
                  return (Files.size(file) &gt; 8192L);
                  }
                  };
                  Path dir = ...
                  try (DirectoryStream&amp;lt;Path&amp;gt; stream = Files.newDirectoryStream(dir, filter)) {
                  :
                  }
                  &lt;/pre&gt;                
                <param>
                    dirthe path to the directory                    
                </param>
                <param>
                    filterthe directory stream filter                    
                </param>
                <return>
                    a new and open {@code DirectoryStream} object                    
                </return>
                <throws>
                    NotDirectoryExceptionif the file could not otherwise be opened because it is not
                      a directory <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the directory.                    
                </throws>
            </javadoc>
            <method name="newDirectoryStream" type="DirectoryStream<Path>" line="536">
                <params>
                    <param name="dir" type="Path"/>
                    <param name="filter" type="DirectoryStream.Filter<? super Path>"/>
                </params>
            </method>
            <javadoc line="542">
                Creates a new and empty file, failing if the file already exists. The
                  check for the existence of the file and the creation of the new file if
                  it does not exist are a single operation that is atomic with respect to
                  all other filesystem activities that might affect the directory.
                  &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttributefile-attributes} to set atomically when creating the file. Each attribute
                  is identified by its {@link FileAttribute#name name}. If more than one
                  attribute of the same name is included in the array then all but the last
                  occurrence is ignored.                
                <param>
                    paththe path to the file to create                    
                </param>
                <param>
                    attrsan optional list of file attributes to set atomically when
                      creating the file                    
                </param>
                <return>
                    the file                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the array contains an attribute that cannot be set atomically
                      when creating the file                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif a file of that name already exists
                      <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs or the parent directory does not exist                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to the new file.                    
                </throws>
            </javadoc>
            <method name="createFile" type="Path" line="577">
                <params>
                    <param name="path" type="Path"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
                <declaration name="options" type="EnumSet&lt;StandardOpenOption&gt;" line="578"/>
            </method>
            <javadoc line="584">
                Creates a new directory. The check for the existence of the file and the
                  creation of the directory if it does not exist are a single operation
                  that is atomic with respect to all other filesystem activities that might
                  affect the directory. The {@link #createDirectories createDirectories}method should be used where it is required to create all nonexistent
                  parent directories first.
                  &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttributefile-attributes} to set atomically when creating the directory. Each
                  attribute is identified by its {@link FileAttribute#name name}. If more
                  than one attribute of the same name is included in the array then all but
                  the last occurrence is ignored.                
                <param>
                    dirthe directory to create                    
                </param>
                <param>
                    attrsan optional list of file attributes to set atomically when
                      creating the directory                    
                </param>
                <return>
                    the directory                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the array contains an attribute that cannot be set atomically
                      when creating the directory                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif a directory could not otherwise be created because a file of
                      that name already exists <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs or the parent directory does not exist                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to the new directory.                    
                </throws>
            </javadoc>
            <method name="createDirectory" type="Path" line="621">
                <params>
                    <param name="dir" type="Path"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
            </method>
            <javadoc line="626">
                Creates a directory by creating all nonexistent parent directories first.
                  Unlike the {@link #createDirectory createDirectory} method, an exception
                  is not thrown if the directory could not be created because it already
                  exists.
                  &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttributefile-attributes} to set atomically when creating the nonexistent
                  directories. Each file attribute is identified by its {@link FileAttribute#name name}. If more than one attribute of the same name is
                  included in the array then all but the last occurrence is ignored.
                  &lt;p&gt; If this method fails, then it may do so after creating some, but not
                  all, of the parent directories.                
                <param>
                    dirthe directory to create                    
                </param>
                <param>
                    attrsan optional list of file attributes to set atomically when
                      creating the directory                    
                </param>
                <return>
                    the directory                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the array contains an attribute that cannot be set atomically
                      when creating the directory                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif {@code dir} exists but is not a directory <i>(optional specific
                      exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionin the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked prior to attempting to create a directory and
                      its {@link SecurityManager#checkRead(String) checkRead} is
                      invoked for each parent directory that is checked. If {@codedir} is not an absolute path then its {@link Path#toAbsolutePathtoAbsolutePath} may need to be invoked to get its absolute path.
                      This may invoke the security manager's {@link SecurityManager#checkPropertyAccess(String) checkPropertyAccess}method to check access to the system property {@code user.dir}                    
                </throws>
            </javadoc>
            <method name="createDirectories" type="Path" line="672">
                <params>
                    <param name="dir" type="Path"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
                <comment line="674">
                    attempt to create the directory                    
                </comment>
                <comment line="679">
                    file exists and is not a directory                    
                </comment>
                <comment line="682">
                    parent may not exist or other reason                    
                </comment>
                <comment line="688">
                    don&apos;t have permission to get absolute path                    
                </comment>
                <comment line="691">
                    find a decendent that exists                    
                </comment>
                <comment line="698">
                    does not exist                    
                </comment>
                <comment line="703">
                    unable to find existing parent                    
                </comment>
                <comment line="709">
                    create directories                    
                </comment>
                <scope line="674"/>
                <scope line="677"/>
                <scope line="680"/>
                <declaration name="se" type="SecurityException" line="683"/>
                <scope line="684"/>
                <scope line="686"/>
                <declaration name="parent" type="Path" line="691"/>
                <scope line="692">
                    <scope line="693"/>
                    <scope line="696"/>
                </scope>
                <scope line="701"/>
                <declaration name="child" type="Path" line="709"/>
                <scope line="710"/>
            </method>
            <javadoc line="717">
                Used by createDirectories to attempt to create a directory. A no-op
                  if the directory already exists.                
            </javadoc>
            <method name="createAndCheckIsDirectory" type="void" line="724">
                <params>
                    <param name="dir" type="Path"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
                <scope line="725"/>
                <scope line="727"/>
            </method>
            <javadoc line="733">
                Creates a new empty file in the specified directory, using the given
                  prefix and suffix strings to generate its name. The resulting{@code Path} is associated with the same {@code FileSystem} as the given
                  directory.
                  &lt;p&gt; The details as to how the name of the file is constructed is
                  implementation dependent and therefore not specified. Where possible
                  the {@code prefix} and {@code suffix} are used to construct candidate
                  names in the same manner as the {@link java.io.File#createTempFile(String,String,File)} method.
                  &lt;p&gt; As with the {@code File.createTempFile} methods, this method is only
                  part of a temporary-file facility. Where used as a &lt;em&gt;work files&lt;/em&gt;,
                  the resulting file may be opened using the {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the
                  file is deleted when the appropriate {@code close} method is invoked.
                  Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the{@link java.io.File#deleteOnExit} mechanism may be used to delete the
                  file automatically.
                  &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttributefile-attributes} to set atomically when creating the file. Each attribute
                  is identified by its {@link FileAttribute#name name}. If more than one
                  attribute of the same name is included in the array then all but the last
                  occurrence is ignored. When no file attributes are specified, then the
                  resulting file may have more restrictive access permissions to files
                  created by the {@link java.io.File#createTempFile(String,String,File)}method.                
                <param>
                    dirthe path to directory in which to create the file                    
                </param>
                <param>
                    prefixthe prefix string to be used in generating the file's name;
                      may be {@code null}                    
                </param>
                <param>
                    suffixthe suffix string to be used in generating the file's name;
                      may be {@code null}, in which case "{@code .tmp}" is used                    
                </param>
                <param>
                    attrsan optional list of file attributes to set atomically when
                      creating the file                    
                </param>
                <return>
                    the path to the newly created file that did not exist before
                      this method was invoked                    
                </return>
                <throws>
                    IllegalArgumentExceptionif the prefix or suffix parameters cannot be used to generate
                      a candidate file name                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif the array contains an attribute that cannot be set atomically
                      when creating the directory                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs or {@code dir} does not exist                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to the file.                    
                </throws>
            </javadoc>
            <method name="createTempFile" type="Path" line="796">
                <params>
                    <param name="dir" type="Path"/>
                    <param name="prefix" type="String"/>
                    <param name="suffix" type="String"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
            </method>
            <javadoc line="801">
                Creates an empty file in the default temporary-file directory, using
                  the given prefix and suffix to generate its name. The resulting {@codePath} is associated with the default {@code FileSystem}.
                  &lt;p&gt; This method works in exactly the manner specified by the{@link #createTempFile(Path,String,String,FileAttribute[])} method for
                  the case that the {@code dir} parameter is the temporary-file directory.                
                <param>
                    prefixthe prefix string to be used in generating the file's name;
                      may be {@code null}                    
                </param>
                <param>
                    suffixthe suffix string to be used in generating the file's name;
                      may be {@code null}, in which case "{@code .tmp}" is used                    
                </param>
                <param>
                    attrsan optional list of file attributes to set atomically when
                      creating the file                    
                </param>
                <return>
                    the path to the newly created file that did not exist before
                      this method was invoked                    
                </return>
                <throws>
                    IllegalArgumentExceptionif the prefix or suffix parameters cannot be used to generate
                      a candidate file name                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif the array contains an attribute that cannot be set atomically
                      when creating the directory                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs or the temporary-file directory does not
                      exist                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to the file.                    
                </throws>
            </javadoc>
            <method name="createTempFile" type="Path" line="841">
                <params>
                    <param name="prefix" type="String"/>
                    <param name="suffix" type="String"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
            </method>
            <javadoc line="845">
                Creates a new directory in the specified directory, using the given
                  prefix to generate its name.  The resulting {@code Path} is associated
                  with the same {@code FileSystem} as the given directory.
                  &lt;p&gt; The details as to how the name of the directory is constructed is
                  implementation dependent and therefore not specified. Where possible
                  the {@code prefix} is used to construct candidate names.
                  &lt;p&gt; As with the {@code createTempFile} methods, this method is only
                  part of a temporary-file facility. A {@link Runtime#addShutdownHookshutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be
                  used to delete the directory automatically.
                  &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttributefile-attributes} to set atomically when creating the directory. Each
                  attribute is identified by its {@link FileAttribute#name name}. If more
                  than one attribute of the same name is included in the array then all but
                  the last occurrence is ignored.                
                <param>
                    dirthe path to directory in which to create the directory                    
                </param>
                <param>
                    prefixthe prefix string to be used in generating the directory's name;
                      may be {@code null}                    
                </param>
                <param>
                    attrsan optional list of file attributes to set atomically when
                      creating the directory                    
                </param>
                <return>
                    the path to the newly created directory that did not exist before
                      this method was invoked                    
                </return>
                <throws>
                    IllegalArgumentExceptionif the prefix cannot be used to generate a candidate directory name                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif the array contains an attribute that cannot be set atomically
                      when creating the directory                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs or {@code dir} does not exist                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access when creating the
                      directory.                    
                </throws>
            </javadoc>
            <method name="createTempDirectory" type="Path" line="894">
                <params>
                    <param name="dir" type="Path"/>
                    <param name="prefix" type="String"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
            </method>
            <javadoc line="899">
                Creates a new directory in the default temporary-file directory, using
                  the given prefix to generate its name. The resulting {@code Path} is
                  associated with the default {@code FileSystem}.
                  &lt;p&gt; This method works in exactly the manner specified by {@link #createTempDirectory(Path,String,FileAttribute[])} method for the case
                  that the {@code dir} parameter is the temporary-file directory.                
                <param>
                    prefixthe prefix string to be used in generating the directory's name;
                      may be {@code null}                    
                </param>
                <param>
                    attrsan optional list of file attributes to set atomically when
                      creating the directory                    
                </param>
                <return>
                    the path to the newly created directory that did not exist before
                      this method was invoked                    
                </return>
                <throws>
                    IllegalArgumentExceptionif the prefix cannot be used to generate a candidate directory name                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif the array contains an attribute that cannot be set atomically
                      when creating the directory                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs or the temporary-file directory does not
                      exist                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access when creating the
                      directory.                    
                </throws>
            </javadoc>
            <method name="createTempDirectory" type="Path" line="935">
                <params>
                    <param name="prefix" type="String"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
            </method>
            <javadoc line="939">
                Creates a symbolic link to a target &lt;i&gt;(optional operation)&lt;/i&gt;.
                  &lt;p&gt; The {@code target} parameter is the target of the link. It may be an{@link Path#isAbsolute absolute} or relative path and may not exist. When
                  the target is a relative path then file system operations on the resulting
                  link are relative to the path of the link.
                  &lt;p&gt; The {@code attrs} parameter is optional {@link FileAttributeattributes} to set atomically when creating the link. Each attribute is
                  identified by its {@link FileAttribute#name name}. If more than one attribute
                  of the same name is included in the array then all but the last occurrence
                  is ignored.
                  &lt;p&gt; Where symbolic links are supported, but the underlying {@link FileStore}does not support symbolic links, then this may fail with an {@link IOException}. Additionally, some operating systems may require that the
                  Java virtual machine be started with implementation specific privileges to
                  create symbolic links, in which case this method may throw {@code IOException}.                
                <param>
                    linkthe path of the symbolic link to create                    
                </param>
                <param>
                    targetthe target of the symbolic link                    
                </param>
                <param>
                    attrsthe array of attributes to set atomically when creating the
                      symbolic link                    
                </param>
                <return>
                    the path to the symbolic link                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the implementation does not support symbolic links or the
                      array contains an attribute that cannot be set atomically when
                      creating the symbolic link                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif a file with the name already exists <i>(optional specific
                      exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager
                      is installed, it denies {@link LinkPermission}<tt>("symbolic")</tt>
                      or its {@link SecurityManager#checkWrite(String) checkWrite}method denies write access to the path of the symbolic link.                    
                </throws>
            </javadoc>
            <method name="createSymbolicLink" type="Path" line="987">
                <params>
                    <param name="link" type="Path"/>
                    <param name="target" type="Path"/>
                    <param name="attrs" type="FileAttribute<?>"/>
                </params>
            </method>
            <javadoc line="992">
                Creates a new link (directory entry) for an existing file &lt;i&gt;(optional
                  operation)&lt;/i&gt;.
                  &lt;p&gt; The {@code link} parameter locates the directory entry to create.
                  The {@code existing} parameter is the path to an existing file. This
                  method creates a new directory entry for the file so that it can be
                  accessed using {@code link} as the path. On some file systems this is
                  known as creating a &quot;hard link&quot;. Whether the file attributes are
                  maintained for the file or for each directory entry is file system
                  specific and therefore not specified. Typically, a file system requires
                  that all links (directory entries) for a file be on the same file system.
                  Furthermore, on some platforms, the Java virtual machine may require to
                  be started with implementation specific privileges to create hard links
                  or to create links to directories.                
                <param>
                    linkthe link (directory entry) to create                    
                </param>
                <param>
                    existinga path to an existing file                    
                </param>
                <return>
                    the path to the link (directory entry)                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the implementation does not support adding an existing file
                      to a directory                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif the entry could not otherwise be created because a file of
                      that name already exists <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager
                      is installed, it denies {@link LinkPermission}<tt>("hard")</tt>
                      or its {@link SecurityManager#checkWrite(String) checkWrite}method denies write access to either the link or the
                      existing file.                    
                </throws>
            </javadoc>
            <method name="createLink" type="Path" line="1030">
                <params>
                    <param name="link" type="Path"/>
                    <param name="existing" type="Path"/>
                </params>
            </method>
            <javadoc line="1035">
                Deletes a file.
                  &lt;p&gt; An implementation may require to examine the file to determine if the
                  file is a directory. Consequently this method may not be atomic with respect
                  to other file system operations.  If the file is a symbolic link then the
                  symbolic link itself, not the final target of the link, is deleted.
                  &lt;p&gt; If the file is a directory then the directory must be empty. In some
                  implementations a directory has entries for special files or links that
                  are created when the directory is created. In such implementations a
                  directory is considered empty when only the special entries exist.
                  This method can be used with the {@link #walkFileTree walkFileTree}method to delete a directory and all entries in the directory, or an
                  entire &lt;i&gt;file-tree&lt;/i&gt; where required.
                  &lt;p&gt; On some operating systems it may not be possible to remove a file when
                  it is open and in use by this Java virtual machine or other programs.                
                <param>
                    paththe path to the file to delete                    
                </param>
                <throws>
                    NoSuchFileExceptionif the file does not exist <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    DirectoryNotEmptyExceptionif the file is a directory and could not otherwise be deleted
                      because the directory is not empty <i>(optional specific
                      exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkDelete(String)} method
                      is invoked to check delete access to the file                    
                </throws>
            </javadoc>
            <method name="delete" type="void" line="1070">
                <params>
                    <param name="path" type="Path"/>
                </params>
            </method>
            <javadoc line="1074">
                Deletes a file if it exists.
                  &lt;p&gt; As with the {@link #delete(Path) delete(Path)} method, an
                  implementation may need to examine the file to determine if the file is a
                  directory. Consequently this method may not be atomic with respect to
                  other file system operations.  If the file is a symbolic link, then the
                  symbolic link itself, not the final target of the link, is deleted.
                  &lt;p&gt; If the file is a directory then the directory must be empty. In some
                  implementations a directory has entries for special files or links that
                  are created when the directory is created. In such implementations a
                  directory is considered empty when only the special entries exist.
                  &lt;p&gt; On some operating systems it may not be possible to remove a file when
                  it is open and in use by this Java virtual machine or other programs.                
                <param>
                    paththe path to the file to delete                    
                </param>
                <return>
                    {@code true} if the file was deleted by this method; {@codefalse} if the file could not be deleted because it did not
                      exist                    
                </return>
                <throws>
                    DirectoryNotEmptyExceptionif the file is a directory and could not otherwise be deleted
                      because the directory is not empty <i>(optional specific
                      exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkDelete(String)} method
                      is invoked to check delete access to the file.                    
                </throws>
            </javadoc>
            <method name="deleteIfExists" type="boolean" line="1109">
                <params>
                    <param name="path" type="Path"/>
                </params>
            </method>
            <javadoc line="1115">
                Copy a file to a target file.
                  &lt;p&gt; This method copies a file to the target file with the {@codeoptions} parameter specifying how the copy is performed. By default, the
                  copy fails if the target file already exists or is a symbolic link,
                  except if the source and target are the {@link #isSameFile same} file, in
                  which case the method completes without copying the file. File attributes
                  are not required to be copied to the target file. If symbolic links are
                  supported, and the file is a symbolic link, then the final target of the
                  link is copied. If the file is a directory then it creates an empty
                  directory in the target location (entries in the directory are not
                  copied). This method can be used with the {@link #walkFileTreewalkFileTree} method to copy a directory and all entries in the directory,
                  or an entire &lt;i&gt;file-tree&lt;/i&gt; where required.
                  &lt;p&gt; The {@code options} parameter may include any of the following:
                  &lt;table border=1 cellpadding=5 summary=&quot;&quot;&gt;
                  &lt;tr&gt; &lt;th&gt;Option&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt; &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} &lt;/td&gt;
                  &lt;td&gt; If the target file exists, then the target file is replaced if it
                  is not a non-empty directory. If the target file exists and is a
                  symbolic link, then the symbolic link itself, not the target of
                  the link, is replaced. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} &lt;/td&gt;
                  &lt;td&gt; Attempts to copy the file attributes associated with this file to
                  the target file. The exact file attributes that are copied is platform
                  and file system dependent and therefore unspecified. Minimally, the{@link BasicFileAttributes#lastModifiedTime last-modified-time} is
                  copied to the target file if supported by both the source and target
                  file store. Copying of file timestamps may result in precision
                  loss. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} &lt;/td&gt;
                  &lt;td&gt; Symbolic links are not followed. If the file is a symbolic link,
                  then the symbolic link itself, not the target of the link, is copied.
                  It is implementation specific if file attributes can be copied to the
                  new link. In other words, the {@code COPY_ATTRIBUTES} option may be
                  ignored when copying a symbolic link. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;p&gt; An implementation of this interface may support additional
                  implementation specific options.
                  &lt;p&gt; Copying a file is not an atomic operation. If an {@link IOException}is thrown then it possible that the target file is incomplete or some of
                  its file attributes have not been copied from the source file. When the{@code REPLACE_EXISTING} option is specified and the target file exists,
                  then the target file is replaced. The check for the existence of the file
                  and the creation of the new file may not be atomic with respect to other
                  file system activities.
                  &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
                  Suppose we want to copy a file into a directory, giving it the same file
                  name as the source file:
                  &lt;pre&gt;
                  Path source = ...
                  Path newdir = ...
                  Files.copy(source, newdir.resolve(source.getFileName());
                  &lt;/pre&gt;                
                <param>
                    sourcethe path to the file to copy                    
                </param>
                <param>
                    targetthe path to the target file (may be associated with a different
                      provider to the source path)                    
                </param>
                <param>
                    optionsoptions specifying how the copy should be done                    
                </param>
                <return>
                    the path to the target file                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the array contains a copy option that is not supported                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif the target file exists but cannot be replaced because the{@code REPLACE_EXISTING} option is not specified <i>(optional
                      specific exception)</i>                    
                </throws>
                <throws>
                    DirectoryNotEmptyExceptionthe {@code REPLACE_EXISTING} option is specified but the file
                      cannot be replaced because it is a non-empty directory
                      <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the source file, the{@link SecurityManager#checkWrite(String) checkWrite} is invoked
                      to check write access to the target file. If a symbolic link is
                      copied the security manager is invoked to check {@link LinkPermission}{@code ("symbolic")}.                    
                </throws>
            </javadoc>
            <method name="copy" type="Path" line="1215">
                <params>
                    <param name="source" type="Path"/>
                    <param name="target" type="Path"/>
                    <param name="options" type="CopyOption"/>
                </params>
                <comment line="1219">
                    same provider                    
                </comment>
                <comment line="1222">
                    different providers                    
                </comment>
                <declaration name="provider" type="FileSystemProvider" line="1216"/>
                <scope line="1217"/>
                <scope line="1220"/>
            </method>
            <javadoc line="1227">
                Move or rename a file to a target file.
                  &lt;p&gt; By default, this method attempts to move the file to the target
                  file, failing if the target file exists except if the source and
                  target are the {@link #isSameFile same} file, in which case this method
                  has no effect. If the file is a symbolic link then the symbolic link
                  itself, not the target of the link, is moved. This method may be
                  invoked to move an empty directory. In some implementations a directory
                  has entries for special files or links that are created when the
                  directory is created. In such implementations a directory is considered
                  empty when only the special entries exist. When invoked to move a
                  directory that is not empty then the directory is moved if it does not
                  require moving the entries in the directory.  For example, renaming a
                  directory on the same {@link FileStore} will usually not require moving
                  the entries in the directory. When moving a directory requires that its
                  entries be moved then this method fails (by throwing an {@codeIOException}). To move a &lt;i&gt;file tree&lt;/i&gt; may involve copying rather
                  than moving directories and this can be done using the {@link #copy copy} method in conjunction with the {@link #walkFileTree Files.walkFileTree} utility method.
                  &lt;p&gt; The {@code options} parameter may include any of the following:
                  &lt;table border=1 cellpadding=5 summary=&quot;&quot;&gt;
                  &lt;tr&gt; &lt;th&gt;Option&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt; &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} &lt;/td&gt;
                  &lt;td&gt; If the target file exists, then the target file is replaced if it
                  is not a non-empty directory. If the target file exists and is a
                  symbolic link, then the symbolic link itself, not the target of
                  the link, is replaced. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} &lt;/td&gt;
                  &lt;td&gt; The move is performed as an atomic file system operation and all
                  other options are ignored. If the target file exists then it is
                  implementation specific if the existing file is replaced or this method
                  fails by throwing an {@link IOException}. If the move cannot be
                  performed as an atomic file system operation then {@link AtomicMoveNotSupportedException} is thrown. This can arise, for
                  example, when the target location is on a different {@code FileStore}and would require that the file be copied, or target location is
                  associated with a different provider to this object. &lt;/td&gt;
                  &lt;/table&gt;
                  &lt;p&gt; An implementation of this interface may support additional
                  implementation specific options.
                  &lt;p&gt; Where the move requires that the file be copied then the {@link BasicFileAttributes#lastModifiedTime last-modified-time} is copied to the
                  new file. An implementation may also attempt to copy other file
                  attributes but is not required to fail if the file attributes cannot be
                  copied. When the move is performed as a non-atomic operation, and a {@codeIOException} is thrown, then the state of the files is not defined. The
                  original file and the target file may both exist, the target file may be
                  incomplete or some of its file attributes may not been copied from the
                  original file.
                  &lt;p&gt; &lt;b&gt;Usage Examples:&lt;/b&gt;
                  Suppose we want to rename a file to &quot;newname&quot;, keeping the file in the
                  same directory:
                  &lt;pre&gt;
                  Path source = ...
                  Files.move(source, source.resolveSibling(&quot;newname&quot;));
                  &lt;/pre&gt;
                  Alternatively, suppose we want to move a file to new directory, keeping
                  the same file name, and replacing any existing file of that name in the
                  directory:
                  &lt;pre&gt;
                  Path source = ...
                  Path newdir = ...
                  Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);
                  &lt;/pre&gt;                
                <param>
                    sourcethe path to the file to move                    
                </param>
                <param>
                    targetthe path to the target file (may be associated with a different
                      provider to the source path)                    
                </param>
                <param>
                    optionsoptions specifying how the move should be done                    
                </param>
                <return>
                    the path to the target file                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the array contains a copy option that is not supported                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif the target file exists but cannot be replaced because the{@code REPLACE_EXISTING} option is not specified <i>(optional
                      specific exception)</i>                    
                </throws>
                <throws>
                    DirectoryNotEmptyExceptionthe {@code REPLACE_EXISTING} option is specified but the file
                      cannot be replaced because it is a non-empty directory
                      <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    AtomicMoveNotSupportedExceptionif the options array contains the {@code ATOMIC_MOVE} option but
                      the file cannot be moved as an atomic file system operation.                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to both the source and
                      target file.                    
                </throws>
            </javadoc>
            <method name="move" type="Path" line="1335">
                <params>
                    <param name="source" type="Path"/>
                    <param name="target" type="Path"/>
                    <param name="options" type="CopyOption"/>
                </params>
                <comment line="1339">
                    same provider                    
                </comment>
                <comment line="1342">
                    different providers                    
                </comment>
                <declaration name="provider" type="FileSystemProvider" line="1336"/>
                <scope line="1337"/>
                <scope line="1340"/>
            </method>
            <javadoc line="1349">
                Reads the target of a symbolic link &lt;i&gt;(optional operation)&lt;/i&gt;.
                  &lt;p&gt; If the file system supports &lt;a href=&quot;package-summary.html#links&quot;&gt;symbolic
                  links&lt;/a&gt; then this method is used to read the target of the link, failing
                  if the file is not a symbolic link. The target of the link need not exist.
                  The returned {@code Path} object will be associated with the same file
                  system as {@code link}.                
                <param>
                    linkthe path to the symbolic link                    
                </param>
                <return>
                    a {@code Path} object representing the target of the link                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the implementation does not support symbolic links                    
                </throws>
                <throws>
                    NotLinkExceptionif the target could otherwise not be read because the file
                      is not a symbolic link <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager
                      is installed, it checks that {@code FilePermission} has been
                      granted with the "{@code readlink}" action to read the link.                    
                </throws>
            </javadoc>
            <method name="readSymbolicLink" type="Path" line="1375">
                <params>
                    <param name="link" type="Path"/>
                </params>
            </method>
            <javadoc line="1379">
                Returns the {@link FileStore} representing the file store where a file
                  is located.
                  &lt;p&gt; Once a reference to the {@code FileStore} is obtained it is
                  implementation specific if operations on the returned {@code FileStore},
                  or {@link FileStoreAttributeView} objects obtained from it, continue
                  to depend on the existence of the file. In particular the behavior is not
                  defined for the case that the file is deleted or moved to a different
                  file store.                
                <param>
                    paththe path to the file                    
                </param>
                <return>
                    the file store where the file is stored                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the file, and in
                      addition it checks {@link RuntimePermission}<tt>
                      ("getFileStoreAttributes")</tt>                    
                </throws>
            </javadoc>
            <method name="getFileStore" type="FileStore" line="1404">
                <params>
                    <param name="path" type="Path"/>
                </params>
            </method>
            <javadoc line="1408">
                Tests if two paths locate the same file.
                  &lt;p&gt; If both {@code Path} objects are {@link Path#equals(Object) equal}then this method returns {@code true} without checking if the file exists.
                  If the two {@code Path} objects are associated with different providers
                  then this method returns {@code false}. Otherwise, this method checks if
                  both {@code Path} objects locate the same file, and depending on the
                  implementation, may require to open or access both files.
                  &lt;p&gt; If the file system and files remain static, then this method implements
                  an equivalence relation for non-null {@code Paths}.
                  &lt;ul&gt;
                  &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for {@code Path} {@code f},{@code isSameFile(f,f)} should return {@code true}.
                  &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for two {@code Paths} {@code f} and {@code g},{@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.
                  &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for three {@code Paths}{@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns{@code true} and {@code isSameFile(g,h)} returns {@code true}, then{@code isSameFile(g,h)} will return return {@code true}.
                  &lt;/ul&gt;                
                <param>
                    pathone path to the file                    
                </param>
                <param>
                    path2the other path                    
                </param>
                <return>
                    {@code true} if, and only if, the two paths locate the same file                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to both files.                    
                </throws>
                <see>
                    java.nio.file.attribute.BasicFileAttributes#fileKey                    
                </see>
            </javadoc>
            <method name="isSameFile" type="boolean" line="1447">
                <params>
                    <param name="path" type="Path"/>
                    <param name="path2" type="Path"/>
                </params>
            </method>
            <javadoc line="1451">
                Tells whether or not a file is considered &lt;em&gt;hidden&lt;/em&gt;. The exact
                  definition of hidden is platform or provider dependent. On UNIX for
                  example a file is considered to be hidden if its name begins with a
                  period character (&apos;.&apos;). On Windows a file is considered hidden if it
                  isn&apos;t a directory and the DOS {@link DosFileAttributes#isHidden hidden}attribute is set.
                  &lt;p&gt; Depending on the implementation this method may require to access
                  the file system to determine if the file is considered hidden.                
                <param>
                    paththe path to the file to test                    
                </param>
                <return>
                    {@code true} if the file is considered hidden                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the file.                    
                </throws>
            </javadoc>
            <method name="isHidden" type="boolean" line="1474">
                <params>
                    <param name="path" type="Path"/>
                </params>
            </method>
            <class name="FileTypeDetectors" line="1479">
                <comment line="1486">
                    loads all installed file type detectors                    
                </comment>
                <declaration name="defaultFileTypeDetector" type="FileTypeDetector" line="1480"/>
                <declaration name="installeDetectors" type="List&lt;FileTypeDetector&gt;" line="1482"/>
                <method name="loadInstalledDetectors" type="List<FileTypeDetector>" line="1486">
                    <anonymous_class line="1488">
                        <method name="run" type="List<FileTypeDetector>" line="1489">
                            <declaration name="list" type="List&lt;FileTypeDetector&gt;" line="1490"/>
                            <declaration name="loader" type="ServiceLoader&lt;FileTypeDetector&gt;" line="1491"/>
                            <scope line="1493"/>
                        </method>
                    </anonymous_class>
                </method>
            </class>
            <javadoc line="1501">
                Probes the content type of a file.
                  &lt;p&gt; This method uses the installed {@link FileTypeDetector} implementations
                  to probe the given file to determine its content type. Each file type
                  detector&apos;s {@link FileTypeDetector#probeContentType probeContentType} is
                  invoked, in turn, to probe the file type. If the file is recognized then
                  the content type is returned. If the file is not recognized by any of the
                  installed file type detectors then a system-default file type detector is
                  invoked to guess the content type.
                  &lt;p&gt; A given invocation of the Java virtual machine maintains a system-wide
                  list of file type detectors. Installed file type detectors are loaded
                  using the service-provider loading facility defined by the {@link ServiceLoader}class. Installed file type detectors are loaded using the system class
                  loader. If the system class loader cannot be found then the extension class
                  loader is used; If the extension class loader cannot be found then the
                  bootstrap class loader is used. File type detectors are typically installed
                  by placing them in a JAR file on the application class path or in the
                  extension directory, the JAR file contains a provider-configuration file
                  named {@code java.nio.file.spi.FileTypeDetector} in the resource directory{@code META-INF/services}, and the file lists one or more fully-qualified
                  names of concrete subclass of {@code FileTypeDetector } that have a zero
                  argument constructor. If the process of locating or instantiating the
                  installed file type detectors fails then an unspecified error is thrown.
                  The ordering that installed providers are located is implementation
                  specific.
                  &lt;p&gt; The return value of this method is the string form of the value of a
                  Multipurpose Internet Mail Extension (MIME) content type as
                  defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2045:
                  Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet
                  Message Bodies&lt;/i&gt;&lt;/a&gt;. The string is guaranteed to be parsable according
                  to the grammar in the RFC.                
                <param>
                    paththe path to the file to probe                    
                </param>
                <return>
                    The content type of the file, or {@code null} if the content
                      type cannot be determined                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager is installed and it denies an unspecified
                      permission required by a file type detector implementation.                    
                </throws>
            </javadoc>
            <method name="probeContentType" type="String" line="1550">
                <params>
                    <param name="path" type="Path"/>
                </params>
                <comment line="1552">
                    try installed file type detectors                    
                </comment>
                <comment line="1559">
                    fallback to default                    
                </comment>
                <scope line="1552">
                    <declaration name="result" type="String" line="1553"/>
                </scope>
            </method>
            <javadoc line="1564">
                Returns a file attribute view of a given type.
                  &lt;p&gt; A file attribute view provides a read-only or updatable view of a
                  set of file attributes. This method is intended to be used where the file
                  attribute view defines type-safe methods to read or update the file
                  attributes. The {@code type} parameter is the type of the attribute view
                  required and the method returns an instance of that type if supported.
                  The {@link BasicFileAttributeView} type supports access to the basic
                  attributes of a file. Invoking this method to select a file attribute
                  view of that type will always return an instance of that class.
                  &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
                  are handled by the resulting file attribute view for the case that the
                  file is a symbolic link. By default, symbolic links are followed. If the
                  option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then
                  symbolic links are not followed. This option is ignored by implementations
                  that do not support symbolic links.
                  &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
                  Suppose we want read or set a file&apos;s ACL, if supported:
                  &lt;pre&gt;
                  Path path = ...
                  AclFileAttributeView view = Files.getFileAttributeView(path, AclFileAttributeView.class);
                  if (view != null) {
                  List&amp;lt;AclEntry&amp;gt acl = view.getAcl();
                  :
                  }
                  &lt;/pre&gt;                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    typethe {@code Class} object corresponding to the file attribute view                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    a file attribute view of the specified type, or {@code null} if
                      the attribute view type is not available                    
                </return>
            </javadoc>
            <method name="getFileAttributeView" type="V" line="1608">
                <params>
                    <param name="path" type="Path"/>
                    <param name="type" type="Class<V>"/>
                    <param name="options" type="LinkOption"/>
                </params>
            </method>
            <javadoc line="1612">
                Reads a file&apos;s attributes as a bulk operation.
                  &lt;p&gt; The {@code type} parameter is the type of the attributes required
                  and this method returns an instance of that type if supported. All
                  implementations support a basic set of file attributes and so invoking
                  this method with a  {@code type} parameter of {@codeBasicFileAttributes.class} will not throw {@codeUnsupportedOperationException}.
                  &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed and the file attribute of the final target
                  of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.
                  &lt;p&gt; It is implementation specific if all file attributes are read as an
                  atomic operation with respect to other file system operations.
                  &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
                  Suppose we want to read a file&apos;s attributes in bulk:
                  &lt;pre&gt;
                  Path path = ...
                  BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
                  &lt;/pre&gt;
                  Alternatively, suppose we want to read file&apos;s POSIX attributes without
                  following symbolic links:
                  &lt;pre&gt;
                  PosixFileAttributes attrs = Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);
                  &lt;/pre&gt;                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    typethe {@code Class} of the file attributes required
                      to read                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    the file attributes                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif an attributes of the given type are not supported                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, a security manager is
                      installed, its {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the file. If this
                      method is invoked to read security sensitive attributes then the
                      security manager may be invoke to check for additional permissions.                    
                </throws>
            </javadoc>
            <method name="readAttributes" type="A" line="1668">
                <params>
                    <param name="path" type="Path"/>
                    <param name="type" type="Class<A>"/>
                    <param name="options" type="LinkOption"/>
                </params>
            </method>
            <javadoc line="1672">
                Sets the value of a file attribute.
                  &lt;p&gt; The {@code attribute} parameter identifies the attribute to be set
                  and takes the form:
                  &lt;blockquote&gt;
                  [&lt;i&gt;view-name&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;]&lt;i&gt;attribute-name&lt;/i&gt;
                  &lt;/blockquote&gt;
                  where square brackets [...] delineate an optional component and the
                  character {@code &apos;:&apos;} stands for itself.
                  &lt;p&gt; &lt;i&gt;view-name&lt;/i&gt; is the {@link FileAttributeView#name name} of a {@link FileAttributeView} that identifies a set of file attributes. If not
                  specified then it defaults to {@code &quot;basic&quot;}, the name of the file
                  attribute view that identifies the basic set of file attributes common to
                  many file systems. &lt;i&gt;attribute-name&lt;/i&gt; is the name of the attribute
                  within the set.
                  &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed and the file attribute of the final target
                  of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.
                  &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
                  Suppose we want to set the DOS &quot;hidden&quot; attribute:
                  &lt;pre&gt;
                  Path path = ...
                  Files.setAttribute(path, &quot;dos:hidden&quot;, true);
                  &lt;/pre&gt;                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    attributethe attribute to set                    
                </param>
                <param>
                    valuethe attribute value                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    the {@code path} parameter                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the attribute view is not available                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif the attribute name is not specified, or is not recognized, or
                      the attribute value is of the correct type but has an
                      inappropriate value                    
                </throws>
                <throws>
                    ClassCastExceptionif the attribute value is not of the expected type or is a
                      collection containing elements that are not of the expected
                      type                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, its {@link SecurityManager#checkWrite(String) checkWrite}method denies write access to the file. If this method is invoked
                      to set security sensitive attributes then the security manager
                      may be invoked to check for additional permissions.                    
                </throws>
            </javadoc>
            <method name="setAttribute" type="Path" line="1736">
                <params>
                    <param name="path" type="Path"/>
                    <param name="attribute" type="String"/>
                    <param name="value" type="Object"/>
                    <param name="options" type="LinkOption"/>
                </params>
            </method>
            <javadoc line="1741">
                Reads the value of a file attribute.
                  &lt;p&gt; The {@code attribute} parameter identifies the attribute to be read
                  and takes the form:
                  &lt;blockquote&gt;
                  [&lt;i&gt;view-name&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;]&lt;i&gt;attribute-name&lt;/i&gt;
                  &lt;/blockquote&gt;
                  where square brackets [...] delineate an optional component and the
                  character {@code &apos;:&apos;} stands for itself.
                  &lt;p&gt; &lt;i&gt;view-name&lt;/i&gt; is the {@link FileAttributeView#name name} of a {@link FileAttributeView} that identifies a set of file attributes. If not
                  specified then it defaults to {@code &quot;basic&quot;}, the name of the file
                  attribute view that identifies the basic set of file attributes common to
                  many file systems. &lt;i&gt;attribute-name&lt;/i&gt; is the name of the attribute.
                  &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed and the file attribute of the final target
                  of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.
                  &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
                  Suppose we require the user ID of the file owner on a system that
                  supports a &quot;{@code unix}&quot; view:
                  &lt;pre&gt;
                  Path path = ...
                  int uid = (Integer)Files.getAttribute(path, &quot;unix:uid&quot;);
                  &lt;/pre&gt;                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    attributethe attribute to read                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    the attribute value                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the attribute view is not available                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif the attribute name is not specified or is not recognized                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, its {@link SecurityManager#checkRead(String) checkRead}method denies read access to the file. If this method is invoked
                      to read security sensitive attributes then the security manager
                      may be invoked to check for additional permissions.                    
                </throws>
            </javadoc>
            <method name="getAttribute" type="Object" line="1797">
                <params>
                    <param name="path" type="Path"/>
                    <param name="attribute" type="String"/>
                    <param name="options" type="LinkOption"/>
                </params>
                <comment line="1799">
                    only one attribute should be read                    
                </comment>
                <declaration name="map" type="Map&lt;String,Object&gt;" line="1801"/>
                <declaration name="name" type="String" line="1803"/>
                <declaration name="pos" type="int" line="1804"/>
                <scope line="1805"/>
                <scope line="1807"/>
            </method>
            <javadoc line="1813">
                Reads a set of file attributes as a bulk operation.
                  &lt;p&gt; The {@code attributes} parameter identifies the attributes to be read
                  and takes the form:
                  &lt;blockquote&gt;
                  [&lt;i&gt;view-name&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;]&lt;i&gt;attribute-list&lt;/i&gt;
                  &lt;/blockquote&gt;
                  where square brackets [...] delineate an optional component and the
                  character {@code &apos;:&apos;} stands for itself.
                  &lt;p&gt; &lt;i&gt;view-name&lt;/i&gt; is the {@link FileAttributeView#name name} of a {@link FileAttributeView} that identifies a set of file attributes. If not
                  specified then it defaults to {@code &quot;basic&quot;}, the name of the file
                  attribute view that identifies the basic set of file attributes common to
                  many file systems.
                  &lt;p&gt; The &lt;i&gt;attribute-list&lt;/i&gt; component is a comma separated list of
                  zero or more names of attributes to read. If the list contains the value{@code &quot;&quot;} then all attributes are read. Attributes that are not supported
                  are ignored and will not be present in the returned map. It is
                  implementation specific if all attributes are read as an atomic operation
                  with respect to other file system operations.
                  &lt;p&gt; The following examples demonstrate possible values for the {@codeattributes} parameter:
                  &lt;blockquote&gt;
                  &lt;table border=&quot;0&quot;&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@code &quot;&quot;} &lt;/td&gt;
                  &lt;td&gt; Read all {@link BasicFileAttributes basic-file-attributes}. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@code &quot;size,lastModifiedTime,lastAccessTime&quot;} &lt;/td&gt;
                  &lt;td&gt; Reads the file size, last modified time, and last access time
                  attributes. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@code &quot;posix:&quot;} &lt;/td&gt;
                  &lt;td&gt; Read all {@link PosixFileAttributes POSIX-file-attributes}. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@code &quot;posix:permissions,owner,size&quot;} &lt;/td&gt;
                  &lt;td&gt; Reads the POSX file permissions, owner, and file size. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed and the file attribute of the final target
                  of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    attributesthe attributes to read                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    a map of the attributes returned; The map's keys are the
                      attribute names, its values are the attribute values                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the attribute view is not available                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif no attributes are specified or an unrecognized attributes is
                      specified                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, its {@link SecurityManager#checkRead(String) checkRead}method denies read access to the file. If this method is invoked
                      to read security sensitive attributes then the security manager
                      may be invoke to check for additional permissions.                    
                </throws>
            </javadoc>
            <method name="readAttributes" type="Map<String,Object>" line="1895">
                <params>
                    <param name="path" type="Path"/>
                    <param name="attributes" type="String"/>
                    <param name="options" type="LinkOption"/>
                </params>
            </method>
            <javadoc line="1899">
                Returns a file&apos;s POSIX file permissions.
                  &lt;p&gt; The {@code path} parameter is associated with a {@code FileSystem}that supports the {@link PosixFileAttributeView}. This attribute view
                  provides access to file attributes commonly associated with files on file
                  systems used by operating systems that implement the Portable Operating
                  System Interface (POSIX) family of standards.
                  &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed and the file attribute of the final target
                  of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    the file permissions                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the associated file system does not support the {@codePosixFileAttributeView}                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, a security manager is
                      installed, and it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
                      or its {@link SecurityManager#checkRead(String) checkRead} method
                      denies read access to the file.                    
                </throws>
            </javadoc>
            <method name="getPosixFilePermissions" type="Set<PosixFilePermission>" line="1935">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="LinkOption"/>
                </params>
            </method>
            <javadoc line="1939">
                Sets a file&apos;s POSIX permissions.
                  &lt;p&gt; The {@code path} parameter is associated with a {@code FileSystem}that supports the {@link PosixFileAttributeView}. This attribute view
                  provides access to file attributes commonly associated with files on file
                  systems used by operating systems that implement the Portable Operating
                  System Interface (POSIX) family of standards.                
                <param>
                    pathA file reference that locates the file                    
                </param>
                <param>
                    permsThe new set of permissions                    
                </param>
                <throws>
                    UnsupportedOperationExceptionif the associated file system does not support the {@codePosixFileAttributeView}                    
                </throws>
                <throws>
                    ClassCastExceptionif the sets contains elements that are not of type {@codePosixFilePermission}                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
                      or its {@link SecurityManager#checkWrite(String) checkWrite}method denies write access to the file.                    
                </throws>
            </javadoc>
            <method name="setPosixFilePermissions" type="Path" line="1970">
                <params>
                    <param name="path" type="Path"/>
                    <param name="perms" type="Set<PosixFilePermission>"/>
                </params>
                <declaration name="view" type="PosixFileAttributeView" line="1971"/>
            </method>
            <javadoc line="1979">
                Returns the owner of a file.
                  &lt;p&gt; The {@code path} parameter is associated with a file system that
                  supports {@link FileOwnerAttributeView}. This file attribute view provides
                  access to a file attribute that is the owner of the file.                
                <param>
                    pathA file reference that locates the file                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    A user principal representing the owner of the file                    
                </return>
                <throws>
                    UnsupportedOperationExceptionif the associated file system does not support the {@codeFileOwnerAttributeView}                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
                      or its {@link SecurityManager#checkRead(String) checkRead} method
                      denies read access to the file.                    
                </throws>
            </javadoc>
            <method name="getOwner" type="UserPrincipal" line="2004">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="LinkOption"/>
                </params>
                <declaration name="view" type="FileOwnerAttributeView" line="2005"/>
            </method>
            <javadoc line="2012">
                Updates the file owner.
                  &lt;p&gt; The {@code path} parameter is associated with a file system that
                  supports {@link FileOwnerAttributeView}. This file attribute view provides
                  access to a file attribute that is the owner of the file.
                  &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
                  Suppose we want to make &quot;joe&quot; the owner of a file:
                  &lt;pre&gt;
                  Path path = ...
                  UserPrincipalLookupService lookupService =
                  provider(path).getUserPrincipalLookupService();
                  UserPrincipal joe = lookupService.lookupPrincipalByName(&quot;joe&quot;);
                  Files.setOwner(path, joe);
                  &lt;/pre&gt;                
                <param>
                    pathA file reference that locates the file                    
                </param>
                <param>
                    ownerThe new file owner                    
                </param>
                <throws>
                    UnsupportedOperationExceptionif the associated file system does not support the {@codeFileOwnerAttributeView}                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
                      or its {@link SecurityManager#checkWrite(String) checkWrite}method denies write access to the file.                    
                </throws>
                <see>
                    FileSystem#getUserPrincipalLookupService                    
                </see>
                <see>
                    java.nio.file.attribute.UserPrincipalLookupService                    
                </see>
            </javadoc>
            <method name="setOwner" type="Path" line="2050">
                <params>
                    <param name="path" type="Path"/>
                    <param name="owner" type="UserPrincipal"/>
                </params>
                <declaration name="view" type="FileOwnerAttributeView" line="2051"/>
            </method>
            <javadoc line="2059">
                Tests whether a file is a symbolic link.
                  &lt;p&gt; Where is it required to distinguish an I/O exception from the case
                  that the file is not a symbolic link then the file attributes can be
                  read with the {@link #readAttributes(Path,Class,LinkOption[])readAttributes} method and the file type tested with the {@link BasicFileAttributes#isSymbolicLink} method.                
                <return>
                    {@code true} if the file is a symbolic link; {@code false} if
                      the file does not exist, is not a symbolic link, or it cannot
                      be determined if the file is a symbolic link or not.                    
                </return>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, its {@link SecurityManager#checkRead(String) checkRead}method denies read access to the file.                    
                </throws>
            </javadoc>
            <method name="isSymbolicLink" type="boolean" line="2077">
                <params>
                    <param name="path" type="Path"/>
                </params>
                <scope line="2078"/>
                <scope line="2082"/>
            </method>
            <javadoc line="2087">
                Tests whether a file is a directory.
                  &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed and the file attribute of the final target
                  of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.
                  &lt;p&gt; Where is it required to distinguish an I/O exception from the case
                  that the file is not a directory then the file attributes can be
                  read with the {@link #readAttributes(Path,Class,LinkOption[])readAttributes} method and the file type tested with the {@link BasicFileAttributes#isDirectory} method.                
                <param>
                    paththe path to the file to test                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    {@code true} if the file is a directory; {@code false} if
                      the file does not exist, is not a directory, or it cannot
                      be determined if the file is a directory or not.                    
                </return>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, its {@link SecurityManager#checkRead(String) checkRead}method denies read access to the file.                    
                </throws>
            </javadoc>
            <method name="isDirectory" type="boolean" line="2116">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="LinkOption"/>
                </params>
                <scope line="2117"/>
                <scope line="2119"/>
            </method>
            <javadoc line="2124">
                Tests whether a file is a regular file with opaque content.
                  &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed and the file attribute of the final target
                  of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.
                  &lt;p&gt; Where is it required to distinguish an I/O exception from the case
                  that the file is not a regular file then the file attributes can be
                  read with the {@link #readAttributes(Path,Class,LinkOption[])readAttributes} method and the file type tested with the {@link BasicFileAttributes#isRegularFile} method.                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    {@code true} if the file is a regular file; {@code false} if
                      the file does not exist, is not a regular file, or it
                      cannot be determined if the file is a regular file or not.                    
                </return>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, its {@link SecurityManager#checkRead(String) checkRead}method denies read access to the file.                    
                </throws>
            </javadoc>
            <method name="isRegularFile" type="boolean" line="2153">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="LinkOption"/>
                </params>
                <scope line="2154"/>
                <scope line="2156"/>
            </method>
            <javadoc line="2161">
                Returns a file&apos;s last modified time.
                  &lt;p&gt; The {@code options} array may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed and the file attribute of the final target
                  of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    a {@code FileTime} representing the time the file was last
                      modified, or an implementation specific default when a time
                      stamp to indicate the time of last modification is not supported
                      by the file system                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, its {@link SecurityManager#checkRead(String) checkRead}method denies read access to the file.                    
                </throws>
                <see>
                    BasicFileAttributes#lastModifiedTime                    
                </see>
            </javadoc>
            <method name="getLastModifiedTime" type="FileTime" line="2191">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="LinkOption"/>
                </params>
            </method>
            <javadoc line="2195">
                Updates a file&apos;s last modified time attribute. The file time is converted
                  to the epoch and precision supported by the file system. Converting from
                  finer to coarser granularities result in precision loss. The behavior of
                  this method when attempting to set the last modified time when it is not
                  supported by the file system or is outside the range supported by the
                  underlying file store is not defined. It may or not fail by throwing an{@code IOException}.
                  &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
                  Suppose we want to set the last modified time to the current time:
                  &lt;pre&gt;
                  Path path = ...
                  FileTime now = FileTime.fromMillis(System.currentTimeMillis());
                  Files.setLastModifiedTime(path, now);
                  &lt;/pre&gt;                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    timethe new last modified time                    
                </param>
                <return>
                    the file                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, the security manager's {@link SecurityManager#checkWrite(String) checkWrite} method is invoked
                      to check write access to file                    
                </throws>
                <see>
                    BasicFileAttributeView#setTimes                    
                </see>
            </javadoc>
            <method name="setLastModifiedTime" type="Path" line="2230">
                <params>
                    <param name="path" type="Path"/>
                    <param name="time" type="FileTime"/>
                </params>
            </method>
            <javadoc line="2236">
                Returns the size of a file (in bytes). The size may differ from the
                  actual size on the file system due to compression, support for sparse
                  files, or other reasons. The size of files that are not {@link #isRegularFile regular} files is implementation specific and
                  therefore unspecified.                
                <param>
                    paththe path to the file                    
                </param>
                <return>
                    the file size, in bytes                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, its {@link SecurityManager#checkRead(String) checkRead}method denies read access to the file.                    
                </throws>
                <see>
                    BasicFileAttributes#size                    
                </see>
            </javadoc>
            <method name="size" type="long" line="2257">
                <params>
                    <param name="path" type="Path"/>
                </params>
            </method>
            <javadoc line="2263">
                Returns {@code false} if NOFOLLOW_LINKS is present.                
            </javadoc>
            <method name="followLinks" type="boolean" line="2266">
                <params>
                    <param name="options" type="LinkOption"/>
                </params>
                <declaration name="followLinks" type="boolean" line="2267"/>
                <scope line="2268">
                    <scope line="2269"/>
                </scope>
            </method>
            <javadoc line="2280">
                Tests whether a file exists.
                  &lt;p&gt; The {@code options} parameter may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.
                  &lt;p&gt; Note that the result of this method is immediately outdated. If this
                  method indicates the file exists then there is no guarantee that a
                  subsequence access will succeed. Care should be taken when using this
                  method in security sensitive applications.                
                <param>
                    paththe path to the file to test                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled
                      .                    
                </param>
                <return>
                    {@code true} if the file exists; {@code false} if the file does
                      not exist or its existence cannot be determined.                    
                </return>
                <throws>
                    SecurityExceptionIn the case of the default provider, the {@link SecurityManager#checkRead(String)} is invoked to check
                      read access to the file.                    
                </throws>
                <see>
                    #notExists                    
                </see>
            </javadoc>
            <method name="exists" type="boolean" line="2308">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="LinkOption"/>
                </params>
                <comment line="2314">
                    attempt to read attributes without following links                    
                </comment>
                <comment line="2318">
                    file exists                    
                </comment>
                <comment line="2321">
                    does not exist or unable to determine if file exists                    
                </comment>
                <scope line="2309">
                    <scope line="2310"/>
                    <scope line="2312"/>
                </scope>
                <scope line="2319"/>
            </method>
            <javadoc line="2326">
                Tests whether the file located by this path does not exist. This method
                  is intended for cases where it is required to take action when it can be
                  confirmed that a file does not exist.
                  &lt;p&gt; The {@code options} parameter may be used to indicate how symbolic links
                  are handled for the case that the file is a symbolic link. By default,
                  symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKSNOFOLLOW_LINKS} is present then symbolic links are not followed.
                  &lt;p&gt; Note that this method is not the complement of the {@link #existsexists} method. Where it is not possible to determine if a file exists
                  or not then both methods return {@code false}. As with the {@code exists}method, the result of this method is immediately outdated. If this
                  method indicates the file does exist then there is no guarantee that a
                  subsequence attempt to create the file will succeed. Care should be taken
                  when using this method in security sensitive applications.                
                <param>
                    paththe path to the file to test                    
                </param>
                <param>
                    optionsoptions indicating how symbolic links are handled                    
                </param>
                <return>
                    {@code true} if the file does not exist; {@code false} if the
                      file exists or its existence cannot be determined                    
                </return>
                <throws>
                    SecurityExceptionIn the case of the default provider, the {@link SecurityManager#checkRead(String)} is invoked to check
                      read access to the file.                    
                </throws>
            </javadoc>
            <method name="notExists" type="boolean" line="2357">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="LinkOption"/>
                </params>
                <comment line="2363">
                    attempt to read attributes without following links                    
                </comment>
                <comment line="2367">
                    file exists                    
                </comment>
                <comment line="2370">
                    file confirmed not to exist                    
                </comment>
                <scope line="2358">
                    <scope line="2359"/>
                    <scope line="2361"/>
                </scope>
                <scope line="2368"/>
                <scope line="2371"/>
            </method>
            <javadoc line="2376">
                Used by isReadbale, isWritable, isExecutable to test access to a file.                
            </javadoc>
            <method name="isAccessible" type="boolean" line="2379">
                <params>
                    <param name="path" type="Path"/>
                    <param name="modes" type="AccessMode"/>
                </params>
                <scope line="2380"/>
                <scope line="2383"/>
            </method>
            <javadoc line="2388">
                Tests whether a file is readable. This method checks that a file exists
                  and that this Java virtual machine has appropriate privileges that would
                  allow it open the file for reading. Depending on the implementation, this
                  method may require to read file permissions, access control lists, or
                  other file attributes in order to check the effective access to the file.
                  Consequently, this method may not be atomic with respect to other file
                  system operations.
                  &lt;p&gt; Note that the result of this method is immediately outdated, there is
                  no guarantee that a subsequent attempt to open the file for reading will
                  succeed (or even that it will access the same file). Care should be taken
                  when using this method in security sensitive applications.                
                <param>
                    paththe path to the file to check                    
                </param>
                <return>
                    {@code true} if the file exists and is readable; {@code false}if the file does not exist, read access would be denied because
                      the Java virtual machine has insufficient privileges, or access
                      cannot be determined                    
                </return>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}is invoked to check read access to the file.                    
                </throws>
            </javadoc>
            <method name="isReadable" type="boolean" line="2415">
                <params>
                    <param name="path" type="Path"/>
                </params>
            </method>
            <javadoc line="2419">
                Tests whether a file is writable. This method checks that a file exists
                  and that this Java virtual machine has appropriate privileges that would
                  allow it open the file for writing. Depending on the implementation, this
                  method may require to read file permissions, access control lists, or
                  other file attributes in order to check the effective access to the file.
                  Consequently, this method may not be atomic with respect to other file
                  system operations.
                  &lt;p&gt; Note that result of this method is immediately outdated, there is no
                  guarantee that a subsequent attempt to open the file for writing will
                  succeed (or even that it will access the same file). Care should be taken
                  when using this method in security sensitive applications.                
                <param>
                    paththe path to the file to check                    
                </param>
                <return>
                    {@code true} if the file exists and is writable; {@code false}if the file does not exist, write access would be denied because
                      the Java virtual machine has insufficient privileges, or access
                      cannot be determined                    
                </return>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}is invoked to check write access to the file.                    
                </throws>
            </javadoc>
            <method name="isWritable" type="boolean" line="2446">
                <params>
                    <param name="path" type="Path"/>
                </params>
            </method>
            <javadoc line="2450">
                Tests whether a file is executable. This method checks that a file exists
                  and that this Java virtual machine has appropriate privileges to {@link Runtime#exec execute} the file. The semantics may differ when checking
                  access to a directory. For example, on UNIX systems, checking for
                  execute access checks that the Java virtual machine has permission to
                  search the directory in order to access file or subdirectories.
                  &lt;p&gt; Depending on the implementation, this method may require to read file
                  permissions, access control lists, or other file attributes in order to
                  check the effective access to the file. Consequently, this method may not
                  be atomic with respect to other file system operations.
                  &lt;p&gt; Note that the result of this method is immediately outdated, there is
                  no guarantee that a subsequent attempt to execute the file will succeed
                  (or even that it will access the same file). Care should be taken when
                  using this method in security sensitive applications.                
                <param>
                    paththe path to the file to check                    
                </param>
                <return>
                    {@code true} if the file exists and is executable; {@code false}if the file does not exist, execute access would be denied because
                      the Java virtual machine has insufficient privileges, or access
                      cannot be determined                    
                </return>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkExec(String)checkExec} is invoked to check execute access to the file.                    
                </throws>
            </javadoc>
            <method name="isExecutable" type="boolean" line="2481">
                <params>
                    <param name="path" type="Path"/>
                </params>
            </method>
            <javadoc line="2487">
                Walks a file tree.
                  &lt;p&gt; This method walks a file tree rooted at a given starting file. The
                  file tree traversal is &lt;em&gt;depth-first&lt;/em&gt; with the given {@link FileVisitor} invoked for each file encountered. File tree traversal
                  completes when all accessible files in the tree have been visited, or a
                  visit method returns a result of {@link FileVisitResult#TERMINATETERMINATE}. Where a visit method terminates due an {@code IOException},
                  an uncaught error, or runtime exception, then the traversal is terminated
                  and the error or exception is propagated to the caller of this method.
                  &lt;p&gt; For each file encountered this method attempts to read its {@link java.nio.file.attribute.BasicFileAttributes}. If the file is not a
                  directory then the {@link FileVisitor#visitFile visitFile} method is
                  invoked with the file attributes. If the file attributes cannot be read,
                  due to an I/O exception, then the {@link FileVisitor#visitFileFailedvisitFileFailed} method is invoked with the I/O exception.
                  &lt;p&gt; Where the file is a directory, and the directory could not be opened,
                  then the {@code visitFileFailed} method is invoked with the I/O exception,
                  after which, the file tree walk continues, by default, at the next
                  &lt;em&gt;sibling&lt;/em&gt; of the directory.
                  &lt;p&gt; Where the directory is opened successfully, then the entries in the
                  directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries
                  have been visited, or an I/O error occurs during iteration of the
                  directory, then the directory is closed and the visitor&apos;s {@link FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.
                  The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt;
                  of the directory.
                  &lt;p&gt; By default, symbolic links are not automatically followed by this
                  method. If the {@code options} parameter contains the {@link FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are
                  followed. When following links, and the attributes of the target cannot
                  be read, then this method attempts to get the {@code BasicFileAttributes}of the link. If they can be read then the {@code visitFile} method is
                  invoked with the attributes of the link (otherwise the {@code visitFileFailed}method is invoked as specified above).
                  &lt;p&gt; If the {@code options} parameter contains the {@link FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps
                  track of directories visited so that cycles can be detected. A cycle
                  arises when there is an entry in a directory that is an ancestor of the
                  directory. Cycle detection is done by recording the {@link java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,
                  or if file keys are not available, by invoking the {@link #isSameFileisSameFile} method to test if a directory is the same file as an
                  ancestor. When a cycle is detected it is treated as an I/O error, and the{@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with
                  an instance of {@link FileSystemLoopException}.
                  &lt;p&gt; The {@code maxDepth} parameter is the maximum number of levels of
                  directories to visit. A value of {@code 0} means that only the starting
                  file is visited, unless denied by the security manager. A value of{@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all
                  levels should be visited. The {@code visitFile} method is invoked for all
                  files, including directories, encountered at {@code maxDepth}, unless the
                  basic file attributes cannot be read, in which case the {@codevisitFileFailed} method is invoked.
                  &lt;p&gt; If a visitor returns a result of {@code null} then {@codeNullPointerException} is thrown.
                  &lt;p&gt; When a security manager is installed and it denies access to a file
                  (or directory), then it is ignored and the visitor is not invoked for
                  that file (or directory).                
                <param>
                    startthe starting file                    
                </param>
                <param>
                    optionsoptions to configure the traversal                    
                </param>
                <param>
                    maxDepththe maximum number of directory levels to visit                    
                </param>
                <param>
                    visitorthe file visitor to invoke for each file                    
                </param>
                <return>
                    the starting file                    
                </return>
                <throws>
                    IllegalArgumentExceptionif the {@code maxDepth} parameter is negative                    
                </throws>
                <throws>
                    SecurityExceptionIf the security manager denies access to the starting file.
                      In the case of the default provider, the {@link SecurityManager#checkRead(String) checkRead} method is invoked
                      to check read access to the directory.                    
                </throws>
                <throws>
                    IOExceptionif an I/O error is thrown by a visitor method                    
                </throws>
            </javadoc>
            <method name="walkFileTree" type="Path" line="2582">
                <params>
                    <param name="start" type="Path"/>
                    <param name="options" type="Set<FileVisitOption>"/>
                    <param name="maxDepth" type="int"/>
                    <param name="visitor" type="FileVisitor<? super Path>"/>
                </params>
            </method>
            <javadoc line="2589">
                Walks a file tree.
                  &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
                  expression:
                  &lt;blockquote&gt;&lt;pre&gt;
                  walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  In other words, it does not follow symbolic links, and visits all levels
                  of the file tree.                
                <param>
                    startthe starting file                    
                </param>
                <param>
                    visitorthe file visitor to invoke for each file                    
                </param>
                <return>
                    the starting file                    
                </return>
                <throws>
                    SecurityExceptionIf the security manager denies access to the starting file.
                      In the case of the default provider, the {@link SecurityManager#checkRead(String) checkRead} method is invoked
                      to check read access to the directory.                    
                </throws>
                <throws>
                    IOExceptionif an I/O error is thrown by a visitor method                    
                </throws>
            </javadoc>
            <method name="walkFileTree" type="Path" line="2617">
                <params>
                    <param name="start" type="Path"/>
                    <param name="visitor" type="FileVisitor<? super Path>"/>
                </params>
            </method>
            <declaration name="BUFFER_SIZE" type="int" line="2628"/>
            <javadoc line="2630">
                Opens a file for reading, returning a {@code BufferedReader} that may be
                  used to read text from the file in an efficient manner. Bytes from the
                  file are decoded into characters using the specified charset. Reading
                  commences at the beginning of the file.
                  &lt;p&gt; The {@code Reader} methods that read from the file throw {@codeIOException} if a malformed or unmappable byte sequence is read.                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    csthe charset to use for decoding                    
                </param>
                <return>
                    a new buffered reader, with default buffer size, to read text
                      from the file                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs opening the file                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the file.                    
                </throws>
                <see>
                    #readAllLines                    
                </see>
            </javadoc>
            <method name="newBufferedReader" type="BufferedReader" line="2658">
                <params>
                    <param name="path" type="Path"/>
                    <param name="cs" type="Charset"/>
                </params>
                <declaration name="decoder" type="CharsetDecoder" line="2659"/>
                <declaration name="reader" type="Reader" line="2660"/>
            </method>
            <javadoc line="2664">
                Opens or creates a file for writing, returning a {@code BufferedWriter}that may be used to write text to the file in an efficient manner.
                  The {@code options} parameter specifies how the the file is created or
                  opened. If no options are present then this method works as if the {@link StandardOpenOption#CREATE CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link StandardOpenOption#WRITE WRITE} options are present. In other words, it
                  opens the file for writing, creating the file if it doesn&apos;t exist, or
                  initially truncating an existing {@link #isRegularFile regular-file} to
                  a size of {@code 0} if it exists.
                  &lt;p&gt; The {@code Writer} methods to write text throw {@code IOException}if the text cannot be encoded using the specified charset.                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    csthe charset to use for encoding                    
                </param>
                <param>
                    optionsoptions specifying how the file is opened                    
                </param>
                <return>
                    a new buffered writer, with default buffer size, to write text
                      to the file                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs opening or creating the file                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif an unsupported option is specified                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to the file.                    
                </throws>
                <see>
                    #write(Path,Iterable,Charset,OpenOption[])                    
                </see>
            </javadoc>
            <method name="newBufferedWriter" type="BufferedWriter" line="2703">
                <params>
                    <param name="path" type="Path"/>
                    <param name="cs" type="Charset"/>
                    <param name="options" type="OpenOption"/>
                </params>
                <declaration name="encoder" type="CharsetEncoder" line="2704"/>
                <declaration name="writer" type="Writer" line="2705"/>
            </method>
            <javadoc line="2709">
                Reads all bytes from an input stream and writes them to an output stream.                
            </javadoc>
            <method name="copy" type="long" line="2714">
                <params>
                    <param name="source" type="InputStream"/>
                    <param name="sink" type="OutputStream"/>
                </params>
                <declaration name="nread" type="long" line="2715"/>
                <declaration name="buf" type="byte[]" line="2716"/>
                <declaration name="n" type="int" line="2717"/>
                <scope line="2718"/>
            </method>
            <javadoc line="2725">
                Copies all bytes from an input stream to a file. On return, the input
                  stream will be at end of stream.
                  &lt;p&gt; By default, the copy fails if the target file already exists or is a
                  symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTINGREPLACE_EXISTING} option is specified, and the target file already exists,
                  then it is replaced if it is not a non-empty directory. If the target
                  file exists and is a symbolic link, then the symbolic link is replaced.
                  In this release, the {@code REPLACE_EXISTING} option is the only option
                  required to be supported by this method. Additional options may be
                  supported in future releases.
                  &lt;p&gt;  If an I/O error occurs reading from the input stream or writing to
                  the file, then it may do so after the target file has been created and
                  after some bytes have been read or written. Consequently the input
                  stream may not be at end of stream and may be in an inconsistent state.
                  It is strongly recommended that the input stream be promptly closed if an
                  I/O error occurs.
                  &lt;p&gt; This method may block indefinitely reading from the input stream (or
                  writing to the file). The behavior for the case that the input stream is
                  &lt;i&gt;asynchronously closed&lt;/i&gt; or the thread interrupted during the copy is
                  highly input stream and file system provider specific and therefore not
                  specified.
                  &lt;p&gt; &lt;b&gt;Usage example&lt;/b&gt;: Suppose we want to capture a web page and save
                  it to a file:
                  &lt;pre&gt;
                  Path path = ...
                  URI u = URI.create(&quot;http://java.sun.com/&quot;);
                  try (InputStream in = u.toURL().openStream()) {
                  Files.copy(in, path);
                  }
                  &lt;/pre&gt;                
                <param>
                    inthe input stream to read from                    
                </param>
                <param>
                    targetthe path to the file                    
                </param>
                <param>
                    optionsoptions specifying how the copy should be done                    
                </param>
                <return>
                    the number of bytes read or written                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs when reading or writing                    
                </throws>
                <throws>
                    FileAlreadyExistsExceptionif the target file exists but cannot be replaced because the{@code REPLACE_EXISTING} option is not specified <i>(optional
                      specific exception)</i>                    
                </throws>
                <throws>
                    DirectoryNotEmptyExceptionthe {@code REPLACE_EXISTING} option is specified but the file
                      cannot be replaced because it is a non-empty directory
                      <i>(optional specific exception)</i>                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif {@code options} contains a copy option that is not supported                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to the file. Where the{@code REPLACE_EXISTING} option is specified, the security
                      manager's {@link SecurityManager#checkDelete(String) checkDelete}method is invoked to check that an existing file can be deleted.                    
                </throws>
            </javadoc>
            <method name="copy" type="long" line="2792">
                <params>
                    <param name="in" type="InputStream"/>
                    <param name="target" type="Path"/>
                    <param name="options" type="CopyOption"/>
                </params>
                <comment line="2794">
                    ensure not null before opening file                    
                </comment>
                <comment line="2797">
                    check for REPLACE_EXISTING                    
                </comment>
                <comment line="2811">
                    attempt to delete an existing file                    
                </comment>
                <comment line="2821">
                    attempt to create target file. If it fails with
                     FileAlreadyExistsException then it may be because the security
                     manager prevented us from deleting the file, in which case we just
                     throw the SecurityException.                    
                </comment>
                <comment line="2832">
                    someone else won the race and created the file                    
                </comment>
                <comment line="2836">
                    do the copy                    
                </comment>
                <declaration name="replaceExisting" type="boolean" line="2797"/>
                <scope line="2798">
                    <scope line="2799"/>
                    <scope line="2801">
                        <scope line="2802"/>
                        <scope line="2804"/>
                    </scope>
                </scope>
                <declaration name="se" type="SecurityException" line="2811"/>
                <scope line="2812">
                    <scope line="2813"/>
                    <scope line="2815"/>
                </scope>
                <declaration name="ostream" type="OutputStream" line="2824"/>
                <scope line="2825"/>
                <scope line="2828"/>
                <scope line="2836"/>
            </method>
            <javadoc line="2841">
                Copies all bytes from a file to an output stream.
                  &lt;p&gt; If an I/O error occurs reading from the file or writing to the output
                  stream, then it may do so after some bytes have been read or written.
                  Consequently the output stream may be in an inconsistent state. It is
                  strongly recommended that the output stream be promptly closed if an I/O
                  error occurs.
                  &lt;p&gt; This method may block indefinitely writing to the output stream (or
                  reading from the file). The behavior for the case that the output stream
                  is &lt;i&gt;asynchronously closed&lt;/i&gt; or the thread interrupted during the copy
                  is highly output stream and file system provider specific and therefore
                  not specified.
                  &lt;p&gt; Note that if the given output stream is {@link java.io.Flushable}then its {@link java.io.Flushable#flush flush} method may need to invoked
                  after this method completes so as to flush any buffered output.                
                <param>
                    sourcethe  path to the file                    
                </param>
                <param>
                    outthe output stream to write to                    
                </param>
                <return>
                    the number of bytes read or written                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs when reading or writing                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the file.                    
                </throws>
            </javadoc>
            <method name="copy" type="long" line="2874">
                <params>
                    <param name="source" type="Path"/>
                    <param name="out" type="OutputStream"/>
                </params>
                <comment line="2876">
                    ensure not null before opening file                    
                </comment>
                <scope line="2878"/>
            </method>
            <javadoc line="2883">
                Read all the bytes from an input stream. The {@code initialSize}parameter indicates the initial size of the byte[] to allocate.                
            </javadoc>
            <method name="read" type="byte[]" line="2889">
                <params>
                    <param name="source" type="InputStream"/>
                    <param name="initialSize" type="int"/>
                </params>
                <comment line="2896">
                    read to EOF which may read more or less than initialSize (eg: file
                     is truncated while we are reading)                    
                </comment>
                <comment line="2903">
                    need larger buffer                    
                </comment>
                <declaration name="capacity" type="int" line="2890"/>
                <declaration name="buf" type="byte[]" line="2891"/>
                <declaration name="nread" type="int" line="2892"/>
                <declaration name="rem" type="int" line="2893"/>
                <declaration name="n" type="int" line="2894"/>
                <scope line="2897">
                    <scope line="2901">
                        <declaration name="newCapacity" type="int" line="2903"/>
                        <scope line="2904"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2917">
                Read all the bytes from a file. The method ensures that the file is
                  closed when all bytes have been read or an I/O error, or other runtime
                  exception, is thrown.
                  &lt;p&gt; Note that this method is intended for simple cases where it is
                  convenient to read all bytes into a byte array. It is not intended for
                  reading in large files.                
                <param>
                    paththe path to the file                    
                </param>
                <return>
                    a byte array containing the bytes read from the file                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs reading from the stream                    
                </throws>
                <throws>
                    OutOfMemoryErrorif an array of the required size cannot be allocated, for
                      example the file is larger that {@code 2GB}                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the file.                    
                </throws>
            </javadoc>
            <method name="readAllBytes" type="byte[]" line="2941">
                <params>
                    <param name="path" type="Path"/>
                </params>
                <declaration name="size" type="long" line="2942"/>
                <scope line="2946"/>
            </method>
            <javadoc line="2951">
                Read all lines from a file. This method ensures that the file is
                  closed when all bytes have been read or an I/O error, or other runtime
                  exception, is thrown. Bytes from the file are decoded into characters
                  using the specified charset.
                  &lt;p&gt; This method recognizes the following as line terminators:
                  &lt;ul&gt;
                  &lt;li&gt; &lt;code&gt;&amp;#92;u000D&lt;/code&gt; followed by &lt;code&gt;&amp;#92;u000A&lt;/code&gt;,
                  CARRIAGE RETURN followed by LINE FEED &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt;&amp;#92;u000A&lt;/code&gt;, LINE FEED &lt;/li&gt;
                  &lt;li&gt; &lt;code&gt;&amp;#92;u000D&lt;/code&gt;, CARRIAGE RETURN &lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt; Additional Unicode line terminators may be recognized in future
                  releases.
                  &lt;p&gt; Note that this method is intended for simple cases where it is
                  convenient to read all lines in a single operation. It is not intended
                  for reading in large files.                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    csthe charset to use for decoding                    
                </param>
                <return>
                    the lines from the file as a {@code List}; whether the {@codeList} is modifiable or not is implementation dependent and
                      therefore not specified                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs reading from the file or a malformed or
                      unmappable byte sequence is read                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkRead(String) checkRead}method is invoked to check read access to the file.                    
                </throws>
                <see>
                    #newBufferedReader                    
                </see>
            </javadoc>
            <method name="readAllLines" type="List<String>" line="2992">
                <params>
                    <param name="path" type="Path"/>
                    <param name="cs" type="Charset"/>
                </params>
                <scope line="2993">
                    <declaration name="result" type="List&lt;String&gt;" line="2994"/>
                    <scope line="2995">
                        <declaration name="line" type="String" line="2996"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3005">
                Writes bytes to a file. The {@code options} parameter specifies how the
                  the file is created or opened. If no options are present then this method
                  works as if the {@link StandardOpenOption#CREATE CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link StandardOpenOption#WRITE WRITE} options are present. In other words, it
                  opens the file for writing, creating the file if it doesn&apos;t exist, or
                  initially truncating an existing {@link #isRegularFile regular-file} to
                  a size of {@code 0}. All bytes in the byte array are written to the file.
                  The method ensures that the file is closed when all bytes have been
                  written (or an I/O error or other runtime exception is thrown). If an I/O
                  error occurs then it may do so after the file has created or truncated,
                  or after some bytes have been written to the file.
                  &lt;p&gt; &lt;b&gt;Usage example&lt;/b&gt;: By default the method creates a new file or
                  overwrites an existing file. Suppose you instead want to append bytes
                  to an existing file:
                  &lt;pre&gt;
                  Path path = ...
                  byte[] bytes = ...
                  Files.write(path, bytes, StandardOpenOption.APPEND);
                  &lt;/pre&gt;                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    bytesthe byte array with the bytes to write                    
                </param>
                <param>
                    optionsoptions specifying how the file is opened                    
                </param>
                <return>
                    the path                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs writing to or creating the file                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif an unsupported option is specified                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to the file.                    
                </throws>
            </javadoc>
            <method name="write" type="Path" line="3048">
                <params>
                    <param name="path" type="Path"/>
                    <param name="bytes" type="byte[]"/>
                    <param name="options" type="OpenOption"/>
                </params>
                <comment line="3050">
                    ensure bytes is not null before opening file                    
                </comment>
                <scope line="3052">
                    <declaration name="len" type="int" line="3053"/>
                    <declaration name="rem" type="int" line="3054"/>
                    <scope line="3055">
                        <declaration name="n" type="int" line="3056"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3064">
                Write lines of text to a file. Each line is a char sequence and is
                  written to the file in sequence with each line terminated by the
                  platform&apos;s line separator, as defined by the system property {@codeline.separator}. Characters are encoded into bytes using the specified
                  charset.
                  &lt;p&gt; The {@code options} parameter specifies how the the file is created
                  or opened. If no options are present then this method works as if the{@link StandardOpenOption#CREATE CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link StandardOpenOption#WRITE WRITE} options are present. In other words, it
                  opens the file for writing, creating the file if it doesn&apos;t exist, or
                  initially truncating an existing {@link #isRegularFile regular-file} to
                  a size of {@code 0}. The method ensures that the file is closed when all
                  lines have been written (or an I/O error or other runtime exception is
                  thrown). If an I/O error occurs then it may do so after the file has
                  created or truncated, or after some bytes have been written to the file.                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    linesan object to iterate over the char sequences                    
                </param>
                <param>
                    csthe charset to use for encoding                    
                </param>
                <param>
                    optionsoptions specifying how the file is opened                    
                </param>
                <return>
                    the path                    
                </return>
                <throws>
                    IOExceptionif an I/O error occurs writing to or creating the file, or the
                      text cannot be encoded using the specified charset                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionif an unsupported option is specified                    
                </throws>
                <throws>
                    SecurityExceptionIn the case of the default provider, and a security manager is
                      installed, the {@link SecurityManager#checkWrite(String) checkWrite}method is invoked to check write access to the file.                    
                </throws>
            </javadoc>
            <method name="write" type="Path" line="3107">
                <params>
                    <param name="path" type="Path"/>
                    <param name="lines" type="Iterable<? extends CharSequence>"/>
                    <param name="cs" type="Charset"/>
                    <param name="options" type="OpenOption"/>
                </params>
                <comment line="3109">
                    ensure lines is not null before opening file                    
                </comment>
                <declaration name="encoder" type="CharsetEncoder" line="3110"/>
                <declaration name="out" type="OutputStream" line="3111"/>
                <scope line="3112">
                    <scope line="3113"/>
                </scope>
            </method>
        </class>
    </source>