<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.nio.file">
        <import package="java.nio.file.spi.FileSystemProvider"/>
        <import package="java.net.URI"/>
        <import package="java.io.IOException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util"/>
        <import package="java.lang.reflect.Constructor"/>
        <class name="FileSystems" line="36">
            <comment line="89">
                lazy initialization of default file system                
            </comment>
            <javadoc line="36">
                Factory methods for file systems. This class defines the {@link #getDefaultgetDefault} method to get the default file system and factory methods to
                  construct other types of file systems.
                  &lt;p&gt; The first invocation of any of the methods defined by this class causes
                  the default {@link FileSystemProvider provider} to be loaded. The default
                  provider, identified by the URI scheme &quot;file&quot;, creates the {@link FileSystem}that provides access to the file systems accessible to the Java virtual
                  machine. If the process of loading or initializing the default provider fails
                  then an unspecified error is thrown.
                  &lt;p&gt; The first invocation of the {@link FileSystemProvider#installedProvidersinstalledProviders} method, by way of invoking any of the {@codenewFileSystem} methods defined by this class, locates and loads all
                  installed file system providers. Installed providers are loaded using the
                  service-provider loading facility defined by the {@link ServiceLoader} class.
                  Installed providers are loaded using the system class loader. If the
                  system class loader cannot be found then the extension class loader is used;
                  if there is no extension class loader then the bootstrap class loader is used.
                  Providers are typically installed by placing them in a JAR file on the
                  application class path or in the extension directory, the JAR file contains a
                  provider-configuration file named {@code java.nio.file.spi.FileSystemProvider}in the resource directory {@code META-INF/services}, and the file lists one or
                  more fully-qualified names of concrete subclass of {@link FileSystemProvider}that have a zero argument constructor.
                  The ordering that installed providers are located is implementation specific.
                  If a provider is instantiated and its {@link FileSystemProvider#getScheme()getScheme} returns the same URI scheme of a provider that was previously
                  instantiated then the most recently instantiated duplicate is discarded. URI
                  schemes are compared without regard to case. During construction a provider
                  may safely access files associated with the default provider but care needs
                  to be taken to avoid circular loading of other installed providers. If
                  circular loading of installed providers is detected then an unspecified error
                  is thrown.
                  &lt;p&gt; This class also defines factory methods that allow a {@link ClassLoader}to be specified when locating a provider. As with installed providers, the
                  provider classes are identified by placing the provider configuration file
                  in the resource directory {@code META-INF/services}.
                  &lt;p&gt; If a thread initiates the loading of the installed file system providers
                  and another thread invokes a method that also attempts to load the providers
                  then the method will block until the loading completes.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="FileSystems" type="constructor" line="85"/>
            <class name="DefaultFileSystemHolder" line="89">
                <comment line="93">
                    returns default file system                    
                </comment>
                <comment line="107">
                    returns default provider                    
                </comment>
                <declaration name="defaultFileSystem" type="FileSystem" line="90"/>
                <method name="defaultFileSystem" type="FileSystem" line="93">
                    <comment line="95">
                        load default provider                        
                    </comment>
                    <comment line="103">
                        return file system                        
                    </comment>
                    <anonymous_class line="96">
                        <method name="run" type="FileSystemProvider" line="97"/>
                    </anonymous_class>
                    <declaration name="provider" type="FileSystemProvider" line="95"/>
                </method>
                <method name="getDefaultProvider" type="FileSystemProvider" line="107">
                    <comment line="111">
                        if the property java.nio.file.spi.DefaultFileSystemProvider is
                         set then its value is the name of the default provider (or a list)                        
                    </comment>
                    <comment line="124">
                        must be &quot;file&quot;                        
                    </comment>
                    <declaration name="provider" type="FileSystemProvider" line="108"/>
                    <declaration name="propValue" type="String" line="112"/>
                    <scope line="114">
                        <scope line="115">
                            <scope line="116">
                                <declaration name="c" type="Class&lt;?&gt;" line="117"/>
                                <declaration name="ctor" type="Constructor&lt;?&gt;" line="119"/>
                            </scope>
                            <scope line="127"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <javadoc line="136">
                Returns the default {@code FileSystem}. The default file system creates
                  objects that provide access to the file systems accessible to the Java
                  virtual machine. The &lt;em&gt;working directory&lt;/em&gt; of the file system is
                  the current user directory, named by the system property {@code user.dir}.
                  This allows for interoperability with the {@link java.io.File java.io.File}class.
                  &lt;p&gt; The first invocation of any of the methods defined by this class
                  locates the default {@link FileSystemProvider provider} object. Where the
                  system property {@code java.nio.file.spi.DefaultFileSystemProvider} is
                  not defined then the default provider is a system-default provider that
                  is invoked to create the default file system.
                  &lt;p&gt; If the system property {@code java.nio.file.spi.DefaultFileSystemProvider}is defined then it is taken to be a list of one or more fully-qualified
                  names of concrete provider classes identified by the URI scheme{@code &quot;file&quot;}. Where the property is a list of more than one name then
                  the names are separated by a comma. Each class is loaded, using the system
                  class loader, and instantiated by invoking a one argument constructor
                  whose formal parameter type is {@code FileSystemProvider}. The providers
                  are loaded and instantiated in the order they are listed in the property.
                  If this process fails or a provider&apos;s scheme is not equal to {@code &quot;file&quot;}then an unspecified error is thrown. URI schemes are normally compared
                  without regard to case but for the default provider, the scheme is
                  required to be {@code &quot;file&quot;}. The first provider class is instantiated
                  by invoking it with a reference to the system-default provider.
                  The second provider class is instantiated by invoking it with a reference
                  to the first provider instance. The third provider class is instantiated
                  by invoking it with a reference to the second instance, and so on. The
                  last provider to be instantiated becomes the default provider; its {@codegetFileSystem} method is invoked with the URI {@code &quot;file:///&quot;} to
                  get a reference to the default file system.
                  &lt;p&gt; Subsequent invocations of this method return the file system that was
                  returned by the first invocation.                
                <return>
                    the default file system                    
                </return>
            </javadoc>
            <method name="getDefault" type="FileSystem" line="175"/>
            <javadoc line="179">
                Returns a reference to an existing {@code FileSystem}.
                  &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()installed} providers to locate the provider that is identified by the URI{@link URI#getScheme scheme} of the given URI. URI schemes are compared
                  without regard to case. The exact form of the URI is highly provider
                  dependent. If found, the provider&apos;s {@link FileSystemProvider#getFileSystemgetFileSystem} method is invoked to obtain a reference to the {@codeFileSystem}.
                  &lt;p&gt; Once a file system created by this provider is {@link FileSystem#closeclosed} it is provider-dependent if this method returns a reference to
                  the closed file system or throws {@link FileSystemNotFoundException}.
                  If the provider allows a new file system to be created with the same URI
                  as a file system it previously created then this method throws the
                  exception if invoked after the file system is closed (and before a new
                  instance is created by the {@link #newFileSystem newFileSystem} method).
                  &lt;p&gt; If a security manager is installed then a provider implementation
                  may require to check a permission before returning a reference to an
                  existing file system. In the case of the {@link FileSystems#getDefaultdefault} file system, no permission check is required.                
                <throws>
                    IllegalArgumentExceptionif the pre-conditions for the {@code uri} parameter are not met                    
                </throws>
                <throws>
                    FileSystemNotFoundExceptionif the file system, identified by the URI, does not exist                    
                </throws>
                <throws>
                    ProviderNotFoundExceptionif a provider supporting the URI scheme is not installed                    
                </throws>
                <throws>
                    SecurityExceptionif a security manager is installed and it denies an unspecified
                      permission                    
                </throws>
            </javadoc>
            <method name="getFileSystem" type="FileSystem" line="213">
                <params>
                    <param name="uri" type="URI"/>
                </params>
                <declaration name="scheme" type="String" line="214"/>
                <scope line="215">
                    <scope line="216"/>
                </scope>
            </method>
            <javadoc line="223">
                Constructs a new file system that is identified by a {@link URI}&lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()installed} providers to locate the provider that is identified by the URI{@link URI#getScheme scheme} of the given URI. URI schemes are compared
                  without regard to case. The exact form of the URI is highly provider
                  dependent. If found, the provider&apos;s {@link FileSystemProvider#newFileSystem(URI,Map)newFileSystem(URI,Map)} method is invoked to construct the new file system.
                  &lt;p&gt; Once a file system is {@link FileSystem#close closed} it is
                  provider-dependent if the provider allows a new file system to be created
                  with the same URI as a file system it previously created.
                  &lt;p&gt; &lt;b&gt;Usage Example:&lt;/b&gt;
                  Suppose there is a provider identified by the scheme {@code &quot;memory&quot;}installed:
                  &lt;pre&gt;
                  Map&amp;lt;String,String&amp;gt; env = new HashMap&amp;lt;&amp;gt;();
                  env.put(&quot;capacity&quot;, &quot;16G&quot;);
                  env.put(&quot;blockSize&quot;, &quot;4k&quot;);
                  FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;memory:///?name=logfs&quot;), env);
                  &lt;/pre&gt;                
                <param>
                    urithe URI identifying the file system                    
                </param>
                <param>
                    enva map of provider specific properties to configure the file system;
                      may be empty                    
                </param>
                <return>
                    a new file system                    
                </return>
                <throws>
                    IllegalArgumentExceptionif the pre-conditions for the {@code uri} parameter are not met,
                      or the {@code env} parameter does not contain properties required
                      by the provider, or a property value is invalid                    
                </throws>
                <throws>
                    FileSystemAlreadyExistsExceptionif the file system has already been created                    
                </throws>
                <throws>
                    ProviderNotFoundExceptionif a provider supporting the URI scheme is not installed                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs creating the file system                    
                </throws>
                <throws>
                    SecurityExceptionif a security manager is installed and it denies an unspecified
                      permission required by the file system provider implementation                    
                </throws>
            </javadoc>
            <method name="newFileSystem" type="FileSystem" line="271">
                <params>
                    <param name="uri" type="URI"/>
                    <param name="env" type="Map<String,?>"/>
                </params>
            </method>
            <javadoc line="275">
                Constructs a new file system that is identified by a {@link URI}&lt;p&gt; This method first attempts to locate an installed provider in exactly
                  the same manner as the {@link #newFileSystem(URI,Map) newFileSystem(URI,Map)}method. If none of the installed providers support the URI scheme then an
                  attempt is made to locate the provider using the given class loader. If a
                  provider supporting the URI scheme is located then its {@link FileSystemProvider#newFileSystem(URI,Map) newFileSystem(URI,Map)} is
                  invoked to construct the new file system.                
                <param>
                    urithe URI identifying the file system                    
                </param>
                <param>
                    enva map of provider specific properties to configure the file system;
                      may be empty                    
                </param>
                <param>
                    loaderthe class loader to locate the provider or {@code null} to only
                      attempt to locate an installed provider                    
                </param>
                <return>
                    a new file system                    
                </return>
                <throws>
                    IllegalArgumentExceptionif the pre-conditions for the {@code uri} parameter are not met,
                      or the {@code env} parameter does not contain properties required
                      by the provider, or a property value is invalid                    
                </throws>
                <throws>
                    FileSystemAlreadyExistsExceptionif the URI scheme identifies an installed provider and the file
                      system has already been created                    
                </throws>
                <throws>
                    ProviderNotFoundExceptionif a provider supporting the URI scheme is not found                    
                </throws>
                <throws>
                    ServiceConfigurationErrorwhen an error occurs while loading a service provider                    
                </throws>
                <throws>
                    IOExceptionan I/O error occurs creating the file system                    
                </throws>
                <throws>
                    SecurityExceptionif a security manager is installed and it denies an unspecified
                      permission required by the file system provider implementation                    
                </throws>
            </javadoc>
            <method name="newFileSystem" type="FileSystem" line="316">
                <params>
                    <param name="uri" type="URI"/>
                    <param name="env" type="Map<String,?>"/>
                    <param name="loader" type="ClassLoader"/>
                </params>
                <comment line="320">
                    check installed providers                    
                </comment>
                <comment line="327">
                    if not found, use service-provider loading facility                    
                </comment>
                <declaration name="scheme" type="String" line="317"/>
                <scope line="320">
                    <scope line="321"/>
                </scope>
                <scope line="327">
                    <declaration name="sl" type="ServiceLoader&lt;FileSystemProvider&gt;" line="328"/>
                    <scope line="330">
                        <scope line="331"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="340">
                Constructs a new {@code FileSystem} to access the contents of a file as a
                  file system.
                  &lt;p&gt; This method makes use of specialized providers that create pseudo file
                  systems where the contents of one or more files is treated as a file
                  system.
                  &lt;p&gt; This method iterates over the {@link FileSystemProvider#installedProviders()installed} providers. It invokes, in turn, each provider&apos;s {@link FileSystemProvider#newFileSystem(Path,Map) newFileSystem(Path,Map)} method
                  with an empty map. If a provider returns a file system then the iteration
                  terminates and the file system is returned. If none of the installed
                  providers return a {@code FileSystem} then an attempt is made to locate
                  the provider using the given class loader. If a provider returns a file
                  system then the lookup terminates and the file system is returned.                
                <param>
                    paththe path to the file                    
                </param>
                <param>
                    loaderthe class loader to locate the provider or {@code null} to only
                      attempt to locate an installed provider                    
                </param>
                <return>
                    a new file system                    
                </return>
                <throws>
                    ProviderNotFoundExceptionif a provider supporting this file type cannot be located                    
                </throws>
                <throws>
                    ServiceConfigurationErrorwhen an error occurs while loading a service provider                    
                </throws>
                <throws>
                    IOExceptionif an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionif a security manager is installed and it denies an unspecified
                      permission                    
                </throws>
            </javadoc>
            <method name="newFileSystem" type="FileSystem" line="378">
                <params>
                    <param name="path" type="Path"/>
                    <param name="loader" type="ClassLoader"/>
                </params>
                <comment line="384">
                    check installed providers                    
                </comment>
                <comment line="392">
                    if not found, use service-provider loading facility                    
                </comment>
                <declaration name="env" type="Map&lt;String,?&gt;" line="381"/>
                <scope line="384">
                    <scope line="385"/>
                    <scope line="387"/>
                </scope>
                <scope line="392">
                    <declaration name="sl" type="ServiceLoader&lt;FileSystemProvider&gt;" line="393"/>
                    <scope line="395">
                        <scope line="396"/>
                        <scope line="398"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>