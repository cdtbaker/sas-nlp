<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.nio.charset">
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.CharBuffer"/>
        <import package="java.nio.charset.spi.CharsetProvider"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.AccessControlException"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.Collections"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.Locale"/>
        <import package="java.util.Map"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="java.util.Set"/>
        <import package="java.util.ServiceLoader"/>
        <import package="java.util.ServiceConfigurationError"/>
        <import package="java.util.SortedMap"/>
        <import package="java.util.TreeMap"/>
        <import package="sun.misc.ASCIICaseInsensitiveComparator"/>
        <import package="sun.nio.cs.StandardCharsets"/>
        <import package="sun.nio.cs.ThreadLocalCoders"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="Charset" line="51">
            <comment line="281">
                                
            </comment>
            <comment line="325">
                                
            </comment>
            <comment line="328">
                Cache of the most-recently-returned charsets,
                 along with the names that were used to find them                
            </comment>
            <comment line="331">
                &quot;Level 1&quot; cache                
            </comment>
            <comment line="332">
                &quot;Level 2&quot; cache                
            </comment>
            <comment line="339">
                Creates an iterator that walks over the available providers, ignoring
                 those whose lookup or instantiation causes a security exception to be
                 thrown.  Should be invoked with full privileges.                
            </comment>
            <comment line="389">
                Thread-local gate to prevent recursive provider lookups                
            </comment>
            <comment line="429">
                                
            </comment>
            <comment line="547">
                Fold charsets from the given iterator into the given map, ignoring
                 charsets whose names already have entries in the map.                
            </comment>
            <comment line="630">
                                
            </comment>
            <comment line="632">
                tickles a bug in oldjavac                
            </comment>
            <comment line="633">
                tickles a bug in oldjavac                
            </comment>
            <implements interface="Comparable">
                <type_params>
                    <type_param name="Charset"/>
                </type_params>
            </implements>
            <javadoc line="51">
                A named mapping between sequences of sixteen-bit Unicode &lt;a
                  href=&quot;../../lang/Character.html#unicode&quot;&gt;code units&lt;/a&gt; and sequences of
                  bytes.  This class defines methods for creating decoders and encoders and
                  for retrieving the various names associated with a charset.  Instances of
                  this class are immutable.
                  &lt;p&gt; This class also defines static methods for testing whether a particular
                  charset is supported, for locating charset instances by name, and for
                  constructing a map that contains every charset for which support is
                  available in the current Java virtual machine.  Support for new charsets can
                  be added via the service-provider interface defined in the {@link java.nio.charset.spi.CharsetProvider} class.
                  &lt;p&gt; All of the methods defined in this class are safe for use by multiple
                  concurrent threads.
                  &lt;a name=&quot;names&quot;&gt;&lt;a name=&quot;charenc&quot;&gt;
                  &lt;h4&gt;Charset names&lt;/h4&gt;
                  &lt;p&gt; Charsets are named by strings composed of the following characters:
                  &lt;ul&gt;
                  &lt;li&gt; The uppercase letters &lt;tt&gt;&apos;A&apos;&lt;/tt&gt; through &lt;tt&gt;&apos;Z&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u0041&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;&amp;#92;u005a&apos;&lt;/tt&gt;),
                  &lt;li&gt; The lowercase letters &lt;tt&gt;&apos;a&apos;&lt;/tt&gt; through &lt;tt&gt;&apos;z&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u0061&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;&amp;#92;u007a&apos;&lt;/tt&gt;),
                  &lt;li&gt; The digits &lt;tt&gt;&apos;0&apos;&lt;/tt&gt; through &lt;tt&gt;&apos;9&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u0030&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;&amp;#92;u0039&apos;&lt;/tt&gt;),
                  &lt;li&gt; The dash character &lt;tt&gt;&apos;-&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u002d&apos;&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;HYPHEN-MINUS&lt;/small&gt;),
                  &lt;li&gt; The plus character &lt;tt&gt;&apos;+&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u002b&apos;&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;PLUS SIGN&lt;/small&gt;),
                  &lt;li&gt; The period character &lt;tt&gt;&apos;.&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u002e&apos;&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;FULL STOP&lt;/small&gt;),
                  &lt;li&gt; The colon character &lt;tt&gt;&apos;:&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u003a&apos;&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;COLON&lt;/small&gt;), and
                  &lt;li&gt; The underscore character &lt;tt&gt;&apos;_&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u005f&apos;&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;LOW&amp;nbsp;LINE&lt;/small&gt;).
                  &lt;/ul&gt;
                  A charset name must begin with either a letter or a digit.  The empty string
                  is not a legal charset name.  Charset names are not case-sensitive; that is,
                  case is always ignored when comparing charset names.  Charset names
                  generally follow the conventions documented in &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2278:&amp;nbsp;IANA Charset
                  Registration Procedures&lt;/i&gt;&lt;/a&gt;.
                  &lt;p&gt; Every charset has a &lt;i&gt;canonical name&lt;/i&gt; and may also have one or more
                  &lt;i&gt;aliases&lt;/i&gt;.  The canonical name is returned by the {@link #name() name} method
                  of this class.  Canonical names are, by convention, usually in upper case.
                  The aliases of a charset are returned by the {@link #aliases() aliases}method.
                  &lt;a name=&quot;hn&quot;&gt;
                  &lt;p&gt; Some charsets have an &lt;i&gt;historical name&lt;/i&gt; that is defined for
                  compatibility with previous versions of the Java platform.  A charset&apos;s
                  historical name is either its canonical name or one of its aliases.  The
                  historical name is returned by the &lt;tt&gt;getEncoding()&lt;/tt&gt; methods of the{@link java.io.InputStreamReader#getEncoding InputStreamReader} and {@link java.io.OutputStreamWriter#getEncoding OutputStreamWriter} classes.
                  &lt;a name=&quot;iana&quot;&gt;
                  &lt;p&gt; If a charset listed in the &lt;a
                  href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset
                  Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then
                  its canonical name must be the name listed in the registry.  Many charsets
                  are given more than one name in the registry, in which case the registry
                  identifies one of the names as &lt;i&gt;MIME-preferred&lt;/i&gt;.  If a charset has more
                  than one registry name then its canonical name must be the MIME-preferred
                  name and the other names in the registry must be valid aliases.  If a
                  supported charset is not listed in the IANA registry then its canonical name
                  must begin with one of the strings &lt;tt&gt;&quot;X-&quot;&lt;/tt&gt; or &lt;tt&gt;&quot;x-&quot;&lt;/tt&gt;.
                  &lt;p&gt; The IANA charset registry does change over time, and so the canonical
                  name and the aliases of a particular charset may also change over time.  To
                  ensure compatibility it is recommended that no alias ever be removed from a
                  charset, and that if the canonical name of a charset is changed then its
                  previous canonical name be made into an alias.
                  &lt;h4&gt;Standard charsets&lt;/h4&gt;
                  &lt;a name=&quot;standard&quot;&gt;
                  &lt;p&gt; Every implementation of the Java platform is required to support the
                  following standard charsets.  Consult the release documentation for your
                  implementation to see if any other charsets are supported.  The behavior
                  of such optional charsets may differ between implementations.
                  &lt;blockquote&gt;&lt;table width=&quot;80%&quot; summary=&quot;Description of standard charsets&quot;&gt;
                  &lt;tr&gt;&lt;th&gt;&lt;p align=&quot;left&quot;&gt;Charset&lt;/p&gt;&lt;/th&gt;&lt;th&gt;&lt;p align=&quot;left&quot;&gt;Description&lt;/p&gt;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;US-ASCII&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;Seven-bit ASCII, a.k.a. &lt;tt&gt;ISO646-US&lt;/tt&gt;,
                  a.k.a. the Basic Latin block of the Unicode character set&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;ISO-8859-1&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;ISO Latin Alphabet No. 1, a.k.a. &lt;tt&gt;ISO-LATIN-1&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;UTF-8&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;Eight-bit UCS Transformation Format&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;UTF-16BE&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;Sixteen-bit UCS Transformation Format,
                  big-endian byte&amp;nbsp;order&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;UTF-16LE&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;Sixteen-bit UCS Transformation Format,
                  little-endian byte&amp;nbsp;order&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;UTF-16&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;Sixteen-bit UCS Transformation Format,
                  byte&amp;nbsp;order identified by an optional byte-order mark&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;
                  &lt;p&gt; The &lt;tt&gt;UTF-8&lt;/tt&gt; charset is specified by &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2279.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2279&lt;/i&gt;&lt;/a&gt;; the
                  transformation format upon which it is based is specified in
                  Amendment&amp;nbsp;2 of ISO&amp;nbsp;10646-1 and is also described in the &lt;a
                  href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;Unicode
                  Standard&lt;/i&gt;&lt;/a&gt;.
                  &lt;p&gt; The &lt;tt&gt;UTF-16&lt;/tt&gt; charsets are specified by &lt;a
                  href=&quot;http://www.ietf.org/rfc/rfc2781.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2781&lt;/i&gt;&lt;/a&gt;; the
                  transformation formats upon which they are based are specified in
                  Amendment&amp;nbsp;1 of ISO&amp;nbsp;10646-1 and are also described in the &lt;a
                  href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;Unicode
                  Standard&lt;/i&gt;&lt;/a&gt;.
                  &lt;p&gt; The &lt;tt&gt;UTF-16&lt;/tt&gt; charsets use sixteen-bit quantities and are
                  therefore sensitive to byte order.  In these encodings the byte order of a
                  stream may be indicated by an initial &lt;i&gt;byte-order mark&lt;/i&gt; represented by
                  the Unicode character &lt;tt&gt;&apos;&amp;#92;uFEFF&apos;&lt;/tt&gt;.  Byte-order marks are handled
                  as follows:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt; When decoding, the &lt;tt&gt;UTF-16BE&lt;/tt&gt; and &lt;tt&gt;UTF-16LE&lt;/tt&gt;
                  charsets interpret the initial byte-order marks as a &lt;small&gt;ZERO-WIDTH
                  NON-BREAKING SPACE&lt;/small&gt;; when encoding, they do not write
                  byte-order marks. &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; When decoding, the &lt;tt&gt;UTF-16&lt;/tt&gt; charset interprets the
                  byte-order mark at the beginning of the input stream to indicate the
                  byte-order of the stream but defaults to big-endian if there is no
                  byte-order mark; when encoding, it uses big-endian byte order and writes
                  a big-endian byte-order mark. &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  In any case, byte order marks occuring after the first element of an
                  input sequence are not omitted since the same code is used to represent
                  &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt;.
                  &lt;p&gt; Every instance of the Java virtual machine has a default charset, which
                  may or may not be one of the standard charsets.  The default charset is
                  determined during virtual-machine startup and typically depends upon the
                  locale and charset being used by the underlying operating system. &lt;/p&gt;
                  &lt;p&gt;The {@link StandardCharsets} class defines constants for each of the
                  standard charsets.
                  &lt;h4&gt;Terminology&lt;/h4&gt;
                  &lt;p&gt; The name of this class is taken from the terms used in
                  &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2278&lt;/i&gt;&lt;/a&gt;.
                  In that document a &lt;i&gt;charset&lt;/i&gt; is defined as the combination of
                  one or more coded character sets and a character-encoding scheme.
                  (This definition is confusing; some other software systems define
                  &lt;i&gt;charset&lt;/i&gt; as a synonym for &lt;i&gt;coded character set&lt;/i&gt;.)
                  &lt;p&gt; A &lt;i&gt;coded character set&lt;/i&gt; is a mapping between a set of abstract
                  characters and a set of integers.  US-ASCII, ISO&amp;nbsp;8859-1,
                  JIS&amp;nbsp;X&amp;nbsp;0201, and Unicode are examples of coded character sets.
                  &lt;p&gt; Some standards have defined a &lt;i&gt;character set&lt;/i&gt; to be simply a
                  set of abstract characters without an associated assigned numbering.
                  An alphabet is an example of such a character set.  However, the subtle
                  distinction between &lt;i&gt;character set&lt;/i&gt; and &lt;i&gt;coded character set&lt;/i&gt;
                  is rarely used in practice; the former has become a short form for the
                  latter, including in the Java API specification.
                  &lt;p&gt; A &lt;i&gt;character-encoding scheme&lt;/i&gt; is a mapping between one or more
                  coded character sets and a set of octet (eight-bit byte) sequences.
                  UTF-8, UTF-16, ISO&amp;nbsp;2022, and EUC are examples of
                  character-encoding schemes.  Encoding schemes are often associated with
                  a particular coded character set; UTF-8, for example, is used only to
                  encode Unicode.  Some schemes, however, are associated with multiple
                  coded character sets; EUC, for example, can be used to encode
                  characters in a variety of Asian coded character sets.
                  &lt;p&gt; When a coded character set is used exclusively with a single
                  character-encoding scheme then the corresponding charset is usually
                  named for the coded character set; otherwise a charset is usually named
                  for the encoding scheme and, possibly, the locale of the coded
                  character sets that it supports.  Hence &lt;tt&gt;US-ASCII&lt;/tt&gt; is both the
                  name of a coded character set and of the charset that encodes it, while
                  &lt;tt&gt;EUC-JP&lt;/tt&gt; is the name of the charset that encodes the
                  JIS&amp;nbsp;X&amp;nbsp;0201, JIS&amp;nbsp;X&amp;nbsp;0208, and JIS&amp;nbsp;X&amp;nbsp;0212
                  coded character sets for the Japanese language.
                  &lt;p&gt; The native character encoding of the Java programming language is
                  UTF-16.  A charset in the Java platform therefore defines a mapping
                  between sequences of sixteen-bit UTF-16 code units (that is, sequences
                  of chars) and sequences of bytes. &lt;/p&gt;                
                <author>
                    Mark Reinhold                    
                </author>
                <author>
                    JSR-51 Expert Group                    
                </author>
                <since>
                    1.4                    
                </since>
                <see>
                    CharsetDecoder                    
                </see>
                <see>
                    CharsetEncoder                    
                </see>
                <see>
                    java.nio.charset.spi.CharsetProvider                    
                </see>
                <see>
                    java.lang.Character                    
                </see>
            </javadoc>
            <declaration name="bugLevel" type="String" line="282"/>
            <method name="atBugLevel" type="boolean" line="284">
                <params>
                    <param name="bl" type="String"/>
                </params>
                <declaration name="level" type="String" line="285"/>
                <scope line="286"/>
            </method>
            <javadoc line="295">
                Checks that the given string is a legal charset name. &lt;/p&gt;                
                <param>
                    sA purported charset name                    
                </param>
                <throws>
                    IllegalCharsetNameExceptionIf the given name is not a legal charset name                    
                </throws>
            </javadoc>
            <method name="checkName" type="void" line="304">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="n" type="int" line="305"/>
                <scope line="306"/>
                <scope line="310">
                    <declaration name="c" type="char" line="311"/>
                </scope>
            </method>
            <declaration name="standardProvider" type="CharsetProvider" line="325"/>
            <declaration name="cache1" type="Object[]" line="330"/>
            <declaration name="cache2" type="Object[]" line="331"/>
            <method name="cache" type="void" line="333">
                <params>
                    <param name="charsetName" type="String"/>
                    <param name="cs" type="Charset"/>
                </params>
            </method>
            <method name="providers" type="Iterator" line="342">
                <comment line="361">
                    Ignore security exceptions                    
                </comment>
                <anonymous_class line="343">
                    <declaration name="cl" type="ClassLoader" line="345"/>
                    <declaration name="sl" type="ServiceLoader&lt;CharsetProvider&gt;" line="346"/>
                    <declaration name="i" type="Iterator&lt;CharsetProvider&gt;" line="348"/>
                    <declaration name="next" type="Object" line="350"/>
                    <method name="getNext" type="boolean" line="352">
                        <comment line="361">
                            Ignore security exceptions                            
                        </comment>
                        <scope line="353">
                            <scope line="354"/>
                            <scope line="358">
                                <scope line="359"/>
                            </scope>
                        </scope>
                    </method>
                    <method name="hasNext" type="boolean" line="369"/>
                    <method name="next" type="Object" line="373">
                        <declaration name="n" type="Object" line="376"/>
                    </method>
                    <method name="remove" type="void" line="381"/>
                </anonymous_class>
            </method>
            <declaration name="gate" type="ThreadLocal&lt;ThreadLocal&gt;" line="389"/>
            <method name="lookupViaProviders" type="Charset" line="391">
                <params>
                    <param name="charsetName" type="String"/>
                </params>
                <comment line="394">
                    The runtime startup sequence looks up standard charsets as a
                     consequence of the VM&apos;s invocation of System.initializeSystemClass
                     in order to, e.g., set system properties and encode filenames.  At
                     that point the application class loader has not been initialized,
                     however, so we can&apos;t look for providers because doing so will cause
                     that loader to be prematurely initialized with incomplete
                     information.                    
                </comment>
                <comment line="406">
                    Avoid recursive provider lookups                    
                </comment>
                <scope line="407">
                    <anonymous_class line="411">
                        <method name="run" type="Charset" line="412">
                            <scope line="413">
                                <declaration name="cp" type="CharsetProvider" line="414"/>
                                <declaration name="cs" type="Charset" line="415"/>
                            </scope>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="423"/>
            </method>
            <declaration name="extendedProviderLock" type="Object" line="429"/>
            <declaration name="extendedProviderProbed" type="boolean" line="430"/>
            <declaration name="extendedProvider" type="CharsetProvider" line="431"/>
            <method name="probeExtendedProvider" type="void" line="433">
                <comment line="442">
                    Extended charsets not available
                     (charsets.jar not present)                    
                </comment>
                <anonymous_class line="434">
                    <method name="run" type="Object" line="435">
                        <comment line="442">
                            Extended charsets not available
                             (charsets.jar not present)                            
                        </comment>
                        <scope line="436">
                            <declaration name="epc" type="Class" line="437"/>
                        </scope>
                        <scope line="440"/>
                        <scope line="443"/>
                        <scope line="445"/>
                    </method>
                </anonymous_class>
            </method>
            <method name="lookupExtendedCharset" type="Charset" line="453">
                <params>
                    <param name="charsetName" type="String"/>
                </params>
                <declaration name="ecp" type="CharsetProvider" line="454"/>
                <scope line="455">
                    <scope line="456"/>
                </scope>
            </method>
            <method name="lookup" type="Charset" line="465">
                <params>
                    <param name="charsetName" type="String"/>
                </params>
                <comment line="473">
                    We expect most programs to use one Charset repeatedly.
                     We convey a hint to this effect to the VM by putting the
                     level 1 cache miss code in a separate method.                    
                </comment>
                <declaration name="a" type="Object[]" line="469"/>
            </method>
            <method name="lookup2" type="Charset" line="478">
                <params>
                    <param name="charsetName" type="String"/>
                </params>
                <comment line="496">
                                        
                </comment>
                <declaration name="a" type="Object[]" line="479"/>
                <scope line="480"/>
                <declaration name="cs" type="Charset" line="486"/>
                <scope line="490"/>
            </method>
            <javadoc line="500">
                Tells whether the named charset is supported. &lt;/p&gt;                
                <param>
                    charsetNameThe name of the requested charset; may be either
                      a canonical name or an alias                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if, and only if, support for the named charset
                      is available in the current Java virtual machine                    
                </return>
                <throws>
                    IllegalCharsetNameExceptionIf the given charset name is illegal                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf the given &lt;tt&gt;charsetName&lt;/tt&gt; is null                    
                </throws>
            </javadoc>
            <method name="isSupported" type="boolean" line="516">
                <params>
                    <param name="charsetName" type="String"/>
                </params>
            </method>
            <javadoc line="520">
                Returns a charset object for the named charset. &lt;/p&gt;                
                <param>
                    charsetNameThe name of the requested charset; may be either
                      a canonical name or an alias                    
                </param>
                <return>
                    A charset object for the named charset                    
                </return>
                <throws>
                    IllegalCharsetNameExceptionIf the given charset name is illegal                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf the given &lt;tt&gt;charsetName&lt;/tt&gt; is null                    
                </throws>
                <throws>
                    UnsupportedCharsetExceptionIf no support for the named charset is available
                      in this instance of the Java virtual machine                    
                </throws>
            </javadoc>
            <method name="forName" type="Charset" line="539">
                <params>
                    <param name="charsetName" type="String"/>
                </params>
                <declaration name="cs" type="Charset" line="540"/>
            </method>
            <method name="put" type="void" line="549">
                <params>
                    <param name="i" type="Iterator<Charset>"/>
                    <param name="m" type="Map<String,Charset>"/>
                </params>
                <scope line="550">
                    <declaration name="cs" type="Charset" line="551"/>
                </scope>
            </method>
            <javadoc line="557">
                Constructs a sorted map from canonical charset names to charset objects.
                  &lt;p&gt; The map returned by this method will have one entry for each charset
                  for which support is available in the current Java virtual machine.  If
                  two or more supported charsets have the same canonical name then the
                  resulting map will contain just one of them; which one it will contain
                  is not specified. &lt;/p&gt;
                  &lt;p&gt; The invocation of this method, and the subsequent use of the
                  resulting map, may cause time-consuming disk or network I/O operations
                  to occur.  This method is provided for applications that need to
                  enumerate all of the available charsets, for example to allow user
                  charset selection.  This method is not used by the {@link #forNameforName} method, which instead employs an efficient incremental lookup
                  algorithm.
                  &lt;p&gt; This method may return different results at different times if new
                  charset providers are dynamically made available to the current Java
                  virtual machine.  In the absence of such changes, the charsets returned
                  by this method are exactly those that can be retrieved via the {@link #forName forName} method.  &lt;/p&gt;                
                <return>
                    An immutable, case-insensitive map from canonical charset names
                      to charset objects                    
                </return>
            </javadoc>
            <method name="availableCharsets" type="SortedMap<String,Charset>" line="583">
                <anonymous_class line="585">
                    <method name="run" type="SortedMap<String,Charset>" line="586">
                        <declaration name="m" type="TreeMap&lt;String,Charset&gt;" line="587"/>
                        <scope line="591">
                            <declaration name="cp" type="CharsetProvider" line="592"/>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <declaration name="defaultCharset" type="Charset" line="600"/>
            <javadoc line="602">
                Returns the default charset of this Java virtual machine.
                  &lt;p&gt; The default charset is determined during virtual-machine startup and
                  typically depends upon the locale and charset of the underlying
                  operating system.                
                <return>
                    A charset object for the default charset                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="defaultCharset" type="Charset" line="613">
                <scope line="614">
                    <scope line="615">
                        <declaration name="csn" type="String" line="616"/>
                        <declaration name="cs" type="Charset" line="618"/>
                    </scope>
                </scope>
            </method>
            <declaration name="name" type="String" line="631"/>
            <declaration name="aliases" type="String[]" line="632"/>
            <declaration name="aliasSet" type="Set&lt;String&gt;" line="633"/>
            <javadoc line="635">
                Initializes a new charset with the given canonical name and alias
                  set. &lt;/p&gt;                
                <param>
                    canonicalNameThe canonical name of this charset                    
                </param>
                <param>
                    aliasesAn array of this charset&apos;s aliases, or null if it has no aliases                    
                </param>
                <throws>
                    IllegalCharsetNameExceptionIf the canonical name or any of the aliases are illegal                    
                </throws>
            </javadoc>
            <method name="Charset" type="constructor" line="648">
                <params>
                    <param name="canonicalName" type="String"/>
                    <param name="aliases" type="String[]"/>
                </params>
                <declaration name="as" type="String[]" line="650"/>
            </method>
            <javadoc line="657">
                Returns this charset&apos;s canonical name. &lt;/p&gt;                
                <return>
                    The canonical name of this charset                    
                </return>
            </javadoc>
            <method name="name" type="String" line="662"/>
            <javadoc line="666">
                Returns a set containing this charset&apos;s aliases. &lt;/p&gt;                
                <return>
                    An immutable set of this charset&apos;s aliases                    
                </return>
            </javadoc>
            <method name="aliases" type="Set<String>" line="671">
                <declaration name="n" type="int" line="674"/>
                <declaration name="hs" type="HashSet&lt;String&gt;" line="675"/>
            </method>
            <javadoc line="682">
                Returns this charset&apos;s human-readable name for the default locale.
                  &lt;p&gt; The default implementation of this method simply returns this
                  charset&apos;s canonical name.  Concrete subclasses of this class may
                  override this method in order to provide a localized display name. &lt;/p&gt;                
                <return>
                    The display name of this charset in the default locale                    
                </return>
            </javadoc>
            <method name="displayName" type="String" line="691"/>
            <javadoc line="695">
                Tells whether or not this charset is registered in the &lt;a
                  href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA Charset
                  Registry&lt;/a&gt;.  &lt;/p&gt;                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if, and only if, this charset is known by its
                      implementor to be registered with the IANA                    
                </return>
            </javadoc>
            <method name="isRegistered" type="boolean" line="703"/>
            <javadoc line="707">
                Returns this charset&apos;s human-readable name for the given locale.
                  &lt;p&gt; The default implementation of this method simply returns this
                  charset&apos;s canonical name.  Concrete subclasses of this class may
                  override this method in order to provide a localized display name. &lt;/p&gt;                
                <param>
                    localeThe locale for which the display name is to be retrieved                    
                </param>
                <return>
                    The display name of this charset in the given locale                    
                </return>
            </javadoc>
            <method name="displayName" type="String" line="719">
                <params>
                    <param name="locale" type="Locale"/>
                </params>
            </method>
            <method name="contains" type="boolean" line="723"/>
            <javadoc line="723">
                Tells whether or not this charset contains the given charset.
                  &lt;p&gt; A charset &lt;i&gt;C&lt;/i&gt; is said to &lt;i&gt;contain&lt;/i&gt; a charset &lt;i&gt;D&lt;/i&gt; if,
                  and only if, every character representable in &lt;i&gt;D&lt;/i&gt; is also
                  representable in &lt;i&gt;C&lt;/i&gt;.  If this relationship holds then it is
                  guaranteed that every string that can be encoded in &lt;i&gt;D&lt;/i&gt; can also be
                  encoded in &lt;i&gt;C&lt;/i&gt; without performing any replacements.
                  &lt;p&gt; That &lt;i&gt;C&lt;/i&gt; contains &lt;i&gt;D&lt;/i&gt; does not imply that each character
                  representable in &lt;i&gt;C&lt;/i&gt; by a particular byte sequence is represented
                  in &lt;i&gt;D&lt;/i&gt; by the same byte sequence, although sometimes this is the
                  case.
                  &lt;p&gt; Every charset contains itself.
                  &lt;p&gt; This method computes an approximation of the containment relation:
                  If it returns &lt;tt&gt;true&lt;/tt&gt; then the given charset is known to be
                  contained by this charset; if it returns &lt;tt&gt;false&lt;/tt&gt;, however, then
                  it is not necessarily the case that the given charset is not contained
                  in this charset.                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if the given charset is contained in this charset                    
                </return>
            </javadoc>
            <method name="newDecoder" type="CharsetDecoder" line="749"/>
            <javadoc line="749">
                Constructs a new decoder for this charset. &lt;/p&gt;                
                <return>
                    A new decoder for this charset                    
                </return>
            </javadoc>
            <method name="newEncoder" type="CharsetEncoder" line="756"/>
            <javadoc line="756">
                Constructs a new encoder for this charset. &lt;/p&gt;                
                <return>
                    A new encoder for this charset                    
                </return>
                <throws>
                    UnsupportedOperationExceptionIf this charset does not support encoding                    
                </throws>
            </javadoc>
            <javadoc line="766">
                Tells whether or not this charset supports encoding.
                  &lt;p&gt; Nearly all charsets support encoding.  The primary exceptions are
                  special-purpose &lt;i&gt;auto-detect&lt;/i&gt; charsets whose decoders can determine
                  which of several possible encoding schemes is in use by examining the
                  input byte sequence.  Such charsets do not support encoding because
                  there is no way to determine which encoding should be used on output.
                  Implementations of such charsets should override this method to return
                  &lt;tt&gt;false&lt;/tt&gt;. &lt;/p&gt;                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if, and only if, this charset supports encoding                    
                </return>
            </javadoc>
            <method name="canEncode" type="boolean" line="779"/>
            <javadoc line="783">
                Convenience method that decodes bytes in this charset into Unicode
                  characters.
                  &lt;p&gt; An invocation of this method upon a charset &lt;tt&gt;cs&lt;/tt&gt; returns the
                  same result as the expression
                  &lt;pre&gt;
                  cs.newDecoder()
                  .onMalformedInput(CodingErrorAction.REPLACE)
                  .onUnmappableCharacter(CodingErrorAction.REPLACE)
                  .decode(bb); &lt;/pre&gt;
                  except that it is potentially more efficient because it can cache
                  decoders between successive invocations.
                  &lt;p&gt; This method always replaces malformed-input and unmappable-character
                  sequences with this charset&apos;s default replacement byte array.  In order
                  to detect such sequences, use the {@link CharsetDecoder#decode(java.nio.ByteBuffer)} method directly.  &lt;/p&gt;                
                <param>
                    bb  The byte buffer to be decoded                    
                </param>
                <return>
                    A char buffer containing the decoded characters                    
                </return>
            </javadoc>
            <method name="decode" type="CharBuffer" line="808">
                <params>
                    <param name="bb" type="ByteBuffer"/>
                </params>
                <comment line="816">
                    Can&apos;t happen                    
                </comment>
                <scope line="809"/>
                <scope line="814"/>
            </method>
            <javadoc line="819">
                Convenience method that encodes Unicode characters into bytes in this
                  charset.
                  &lt;p&gt; An invocation of this method upon a charset &lt;tt&gt;cs&lt;/tt&gt; returns the
                  same result as the expression
                  &lt;pre&gt;
                  cs.newEncoder()
                  .onMalformedInput(CodingErrorAction.REPLACE)
                  .onUnmappableCharacter(CodingErrorAction.REPLACE)
                  .encode(bb); &lt;/pre&gt;
                  except that it is potentially more efficient because it can cache
                  encoders between successive invocations.
                  &lt;p&gt; This method always replaces malformed-input and unmappable-character
                  sequences with this charset&apos;s default replacement string.  In order to
                  detect such sequences, use the {@link CharsetEncoder#encode(java.nio.CharBuffer)} method directly.  &lt;/p&gt;                
                <param>
                    cb  The char buffer to be encoded                    
                </param>
                <return>
                    A byte buffer containing the encoded characters                    
                </return>
            </javadoc>
            <method name="encode" type="ByteBuffer" line="844">
                <params>
                    <param name="cb" type="CharBuffer"/>
                </params>
                <comment line="852">
                    Can&apos;t happen                    
                </comment>
                <scope line="845"/>
                <scope line="850"/>
            </method>
            <javadoc line="855">
                Convenience method that encodes a string into bytes in this charset.
                  &lt;p&gt; An invocation of this method upon a charset &lt;tt&gt;cs&lt;/tt&gt; returns the
                  same result as the expression
                  &lt;pre&gt;
                  cs.encode(CharBuffer.wrap(s)); &lt;/pre&gt;                
                <param>
                    str  The string to be encoded                    
                </param>
                <return>
                    A byte buffer containing the encoded characters                    
                </return>
            </javadoc>
            <method name="encode" type="ByteBuffer" line="868">
                <params>
                    <param name="str" type="String"/>
                </params>
            </method>
            <javadoc line="872">
                Compares this charset to another.
                  &lt;p&gt; Charsets are ordered by their canonical names, without regard to
                  case. &lt;/p&gt;                
                <param>
                    thatThe charset to which this charset is to be compared                    
                </param>
                <return>
                    A negative integer, zero, or a positive integer as this charset
                      is less than, equal to, or greater than the specified charset                    
                </return>
            </javadoc>
            <method name="compareTo" type="int" line="884">
                <params>
                    <param name="that" type="Charset"/>
                </params>
            </method>
            <javadoc line="888">
                Computes a hashcode for this charset. &lt;/p&gt;                
                <return>
                    An integer hashcode                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="893"/>
            <javadoc line="897">
                Tells whether or not this object is equal to another.
                  &lt;p&gt; Two charsets are equal if, and only if, they have the same canonical
                  names.  A charset is never equal to any other type of object.  &lt;/p&gt;                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if, and only if, this charset is equal to the
                      given object                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="906">
                <params>
                    <param name="ob" type="Object"/>
                </params>
            </method>
            <javadoc line="914">
                Returns a string describing this charset. &lt;/p&gt;                
                <return>
                    A string describing this charset                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="919"/>
        </class>
    </source>