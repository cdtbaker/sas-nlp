<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.nio.channels">
        <import package="java.io"/>
        <import package="java.nio.ByteBuffer"/>
        <import package="java.nio.MappedByteBuffer"/>
        <import package="java.nio.channels.spi.AbstractInterruptibleChannel"/>
        <import package="java.nio.file"/>
        <import package="java.nio.file.attribute.FileAttribute"/>
        <import package="java.nio.file.spi"/>
        <import package="java.util.Set"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Collections"/>
        <class name="FileChannel" line="12">
            <extends class="AbstractInterruptibleChannel"/>
            <implements interface="SeekableByteChannel"/>
            <implements interface="GatheringByteChannel"/>
            <implements interface="ScatteringByteChannel"/>
            <javadoc line="12">
                A channel for reading, writing, mapping, and manipulating a file.
                  &lt;p&gt; A file channel is a {@link SeekableByteChannel} that is connected to
                  a file. It has a current &lt;i&gt;position&lt;/i&gt; within its file which can
                  be both {@link #position() &lt;i&gt;queried&lt;/i&gt;} and {@link #position(long)&lt;i&gt;modified&lt;/i&gt;}.  The file itself contains a variable-length sequence
                  of bytes that can be read and written and whose current {@link #size&lt;i&gt;size&lt;/i&gt;} can be queried.  The size of the file increases
                  when bytes are written beyond its current size; the size of the file
                  decreases when it is {@link #truncate &lt;/code&gt;&lt;i&gt;truncated&lt;/i&gt;&lt;code&gt;}.  The
                  file may also have some associated &lt;i&gt;metadata&lt;/i&gt; such as access
                  permissions, content type, and last-modification time; this class does not
                  define methods for metadata access.
                  &lt;p&gt; In addition to the familiar read, write, and close operations of byte
                  channels, this class defines the following file-specific operations: &lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt; Bytes may be {@link #read(ByteBuffer,long) read} or{@link #write(ByteBuffer,long) &lt;i&gt;written&lt;/i&gt;} at an absolute
                  position in a file in a way that does not affect the channel&apos;s current
                  position.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; A region of a file may be {@link #map &lt;i&gt;mapped&lt;/i&gt;}directly into memory; for large files this is often much more efficient
                  than invoking the usual &lt;tt&gt;read&lt;/tt&gt; or &lt;tt&gt;write&lt;/tt&gt; methods.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Updates made to a file may be {@link #force &lt;i&gt;forced
                  out&lt;/i&gt;} to the underlying storage device, ensuring that data are not
                  lost in the event of a system crash.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Bytes can be transferred from a file {@link #transferTo &lt;i&gt;to
                  some other channel&lt;/i&gt;}, and {@link #transferFrom &lt;i&gt;vice
                  versa&lt;/i&gt;}, in a way that can be optimized by many operating systems
                  into a very fast transfer directly to or from the filesystem cache.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; A region of a file may be {@link FileLock &lt;i&gt;locked&lt;/i&gt;}against access by other programs.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt; File channels are safe for use by multiple concurrent threads.  The{@link Channel#close close} method may be invoked at any time, as specified
                  by the {@link Channel} interface.  Only one operation that involves the
                  channel&apos;s position or can change its file&apos;s size may be in progress at any
                  given time; attempts to initiate a second such operation while the first is
                  still in progress will block until the first operation completes.  Other
                  operations, in particular those that take an explicit position, may proceed
                  concurrently; whether they in fact do so is dependent upon the underlying
                  implementation and is therefore unspecified.
                  &lt;p&gt; The view of a file provided by an instance of this class is guaranteed
                  to be consistent with other views of the same file provided by other
                  instances in the same program.  The view provided by an instance of this
                  class may or may not, however, be consistent with the views seen by other
                  concurrently-running programs due to caching performed by the underlying
                  operating system and delays induced by network-filesystem protocols.  This
                  is true regardless of the language in which these other programs are
                  written, and whether they are running on the same machine or on some other
                  machine.  The exact nature of any such inconsistencies are system-dependent
                  and are therefore unspecified.
                  &lt;p&gt; A file channel is created by invoking one of the {@link #open open}methods defined by this class. A file channel can also be obtained from an
                  existing {@link java.io.FileInputStream#getChannel FileInputStream}, {@link java.io.FileOutputStream#getChannel FileOutputStream}, or {@link java.io.RandomAccessFile#getChannel RandomAccessFile} object by invoking
                  that object&apos;s &lt;tt&gt;getChannel&lt;/tt&gt; method, which returns a file channel that
                  is connected to the same underlying file. Where the file channel is obtained
                  from an existing stream or random access file then the state of the file
                  channel is intimately connected to that of the object whose &lt;tt&gt;getChannel&lt;/tt&gt;
                  method returned the channel.  Changing the channel&apos;s position, whether
                  explicitly or by reading or writing bytes, will change the file position of
                  the originating object, and vice versa. Changing the file&apos;s length via the
                  file channel will change the length seen via the originating object, and vice
                  versa.  Changing the file&apos;s content by writing bytes will change the content
                  seen by the originating object, and vice versa.
                  &lt;a name=&quot;open-mode&quot;&gt;&lt;/a&gt; &lt;p&gt; At various points this class specifies that an
                  instance that is &quot;open for reading,&quot; &quot;open for writing,&quot; or &quot;open for
                  reading and writing&quot; is required.  A channel obtained via the {@link java.io.FileInputStream#getChannel getChannel} method of a {@link java.io.FileInputStream} instance will be open for reading.  A channel
                  obtained via the {@link java.io.FileOutputStream#getChannel getChannel}method of a {@link java.io.FileOutputStream} instance will be open for
                  writing.  Finally, a channel obtained via the {@link java.io.RandomAccessFile#getChannel getChannel} method of a {@link java.io.RandomAccessFile} instance will be open for reading if the instance
                  was created with mode &lt;tt&gt;&quot;r&quot;&lt;/tt&gt; and will be open for reading and writing
                  if the instance was created with mode &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;.
                  &lt;a name=&quot;append-mode&quot;&gt;&lt;/a&gt;&lt;p&gt; A file channel that is open for writing may be in
                  &lt;i&gt;append mode&lt;/i&gt;, for example if it was obtained from a file-output stream
                  that was created by invoking the {@link java.io.FileOutputStream#FileOutputStream(java.io.File,boolean)FileOutputStream(File,boolean)} constructor and passing &lt;tt&gt;true&lt;/tt&gt; for
                  the second parameter.  In this mode each invocation of a relative write
                  operation first advances the position to the end of the file and then writes
                  the requested data.  Whether the advancement of the position and the writing
                  of the data are done in a single atomic operation is system-dependent and
                  therefore unspecified.                
                <see>
                    java.io.FileInputStream#getChannel()                    
                </see>
                <see>
                    java.io.FileOutputStream#getChannel()                    
                </see>
                <see>
                    java.io.RandomAccessFile#getChannel()                    
                </see>
                <author>
                    Mark Reinhold                    
                </author>
                <author>
                    Mike McCloskey                    
                </author>
                <author>
                    JSR-51 Expert Group                    
                </author>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <javadoc line="96">
                Initializes a new instance of this class.                
            </javadoc>
            <method name="FileChannel" type="constructor" line="99"/>
            <javadoc line="101">
                Opens or creates a file, returning a file channel to access the file.
                  &lt;p&gt; The {@code options} parameter determines how the file is opened.
                  The {@link StandardOpenOption#READ READ} and {@link StandardOpenOption#WRITEWRITE} options determine if the file should be opened for reading and/or
                  writing. If neither option (or the {@link StandardOpenOption#APPEND APPEND}option) is contained in the array then the file is opened for reading.
                  By default reading or writing commences at the beginning of the file.
                  &lt;p&gt; In the addition to {@code READ} and {@code WRITE}, the following
                  options may be present:
                  &lt;table border=1 cellpadding=5 summary=&quot;&quot;&gt;
                  &lt;tr&gt; &lt;th&gt;Option&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt; &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#APPEND APPEND} &lt;/td&gt;
                  &lt;td&gt; If this option is present then the file is opened for writing and
                  each invocation of the channel&apos;s {@code write} method first advances
                  the position to the end of the file and then writes the requested
                  data. Whether the advancement of the position and the writing of the
                  data are done in a single atomic operation is system-dependent and
                  therefore unspecified. This option may not be used in conjunction
                  with the {@code READ} or {@code TRUNCATE_EXISTING} options. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} &lt;/td&gt;
                  &lt;td&gt; If this option is present then the existing file is truncated to
                  a size of 0 bytes. This option is ignored when the file is opened only
                  for reading. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#CREATE_NEW CREATE_NEW} &lt;/td&gt;
                  &lt;td&gt; If this option is present then a new file is created, failing if
                  the file already exists. When creating a file the check for the
                  existence of the file and the creation of the file if it does not exist
                  is atomic with respect to other file system operations. This option is
                  ignored when the file is opened only for reading. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td &gt; {@link StandardOpenOption#CREATE CREATE} &lt;/td&gt;
                  &lt;td&gt; If this option is present then an existing file is opened if it
                  exists, otherwise a new file is created. When creating a file the check
                  for the existence of the file and the creation of the file if it does
                  not exist is atomic with respect to other file system operations. This
                  option is ignored if the {@code CREATE_NEW} option is also present or
                  the file is opened only for reading. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td &gt; {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} &lt;/td&gt;
                  &lt;td&gt; When this option is present then the implementation makes a
                  &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the
                  the {@link #close close} method. If the {@code close} method is not
                  invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file
                  when the Java virtual machine terminates. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt;{@link StandardOpenOption#SPARSE SPARSE} &lt;/td&gt;
                  &lt;td&gt; When creating a new file this option is a &lt;em&gt;hint&lt;/em&gt; that the
                  new file will be sparse. This option is ignored when not creating
                  a new file. &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#SYNC SYNC} &lt;/td&gt;
                  &lt;td&gt; Requires that every update to the file&apos;s content or metadata be
                  written synchronously to the underlying storage device. (see &lt;a
                  href=&quot;../file/package-summary.html#integrity&quot;&gt; Synchronized I/O file
                  integrity&lt;/a&gt;). &lt;/td&gt;
                  &lt;tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; {@link StandardOpenOption#DSYNC DSYNC} &lt;/td&gt;
                  &lt;td&gt; Requires that every update to the file&apos;s content be written
                  synchronously to the underlying storage device. (see &lt;a
                  href=&quot;../file/package-summary.html#integrity&quot;&gt; Synchronized I/O file
                  integrity&lt;/a&gt;). &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;p&gt; An implementation may also support additional options.
                  &lt;p&gt; The {@code attrs} parameter is an optional array of file {@link FileAttribute file-attributes} to set atomically when creating the file.
                  &lt;p&gt; The new channel is created by invoking the {@link FileSystemProvider#newFileChannel newFileChannel} method on the
                  provider that created the {@code Path}.                
                <param>
                    pathThe path of the file to open or create                    
                </param>
                <param>
                    optionsOptions specifying how the file is opened                    
                </param>
                <param>
                    attrsAn optional list of file attributes to set atomically when
                      creating the file                    
                </param>
                <return>
                    A new file channel                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the set contains an invalid combination of options                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionIf the {@code path} is associated with a provider that does not
                      support creating file channels, or an unsupported open option is
                      specified, or the array contains an attribute that cannot be set
                      atomically when creating the file                    
                </throws>
                <throws>
                    IOExceptionIf an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager is installed and it denies an
                      unspecified permission required by the implementation.
                      In the case of the default provider, the {@link SecurityManager#checkRead(String)} method is invoked to check
                      read access if the file is opened for reading. The {@link SecurityManager#checkWrite(String)} method is invoked to check
                      write access if the file is opened for writing                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="open" type="FileChannel" line="195">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="Set&lt;? extends OpenOption&gt;"/>
                    <param name="attrs" type="FileAttribute&lt;?&gt;"/>
                </params>
                <declaration name="provider" type="FileSystemProvider" line="196"/>
            </method>
            <declaration name="NO_ATTRIBUTES" type="FileAttribute&amp;lt;?&amp;gt;[]" line="199"/>
            <javadoc line="200">
                Opens or creates a file, returning a file channel to access the file.
                  &lt;p&gt; An invocation of this method behaves in exactly the same way as the
                  invocation
                  &lt;pre&gt;
                  fc.{@link #open(Path,Set,FileAttribute[]) open}(file, opts, new FileAttribute&amp;lt;?&amp;gt;[0]);
                  &lt;/pre&gt;
                  where {@code opts} is a set of the options specified in the {@codeoptions} array.                
                <param>
                    pathThe path of the file to open or create                    
                </param>
                <param>
                    optionsOptions specifying how the file is opened                    
                </param>
                <return>
                    A new file channel                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the set contains an invalid combination of options                    
                </throws>
                <throws>
                    UnsupportedOperationExceptionIf the {@code path} is associated with a provider that does not
                      support creating file channels, or an unsupported open option is
                      specified                    
                </throws>
                <throws>
                    IOExceptionIf an I/O error occurs                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager is installed and it denies an
                      unspecified permission required by the implementation.
                      In the case of the default provider, the {@link SecurityManager#checkRead(String)} method is invoked to check
                      read access if the file is opened for reading. The {@link SecurityManager#checkWrite(String)} method is invoked to check
                      write access if the file is opened for writing                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="open" type="FileChannel" line="223">
                <params>
                    <param name="path" type="Path"/>
                    <param name="options" type="OpenOption"/>
                </params>
                <declaration name="set" type="Set&amp;lt;OpenOption&amp;gt;" line="224"/>
            </method>
            <method name="read" type="int" line="228"/>
            <javadoc line="228">
                Reads a sequence of bytes from this channel into the given buffer.
                  &lt;p&gt; Bytes are read starting at this channel&apos;s current file position, and
                  then the file position is updated with the number of bytes actually
                  read.  Otherwise this method behaves exactly as specified in the {@link ReadableByteChannel} interface. &lt;/p&gt;                
            </javadoc>
            <method name="read" type="long" line="235"/>
            <javadoc line="235">
                Reads a sequence of bytes from this channel into a subsequence of the
                  given buffers.
                  &lt;p&gt; Bytes are read starting at this channel&apos;s current file position, and
                  then the file position is updated with the number of bytes actually
                  read.  Otherwise this method behaves exactly as specified in the {@link ScatteringByteChannel} interface.  &lt;/p&gt;                
            </javadoc>
            <javadoc line="243">
                Reads a sequence of bytes from this channel into the given buffers.
                  &lt;p&gt; Bytes are read starting at this channel&apos;s current file position, and
                  then the file position is updated with the number of bytes actually
                  read.  Otherwise this method behaves exactly as specified in the {@link ScatteringByteChannel} interface.  &lt;/p&gt;                
            </javadoc>
            <method name="read" type="long" line="249">
                <params>
                    <param name="dsts" type="ByteBuffer[]"/>
                </params>
            </method>
            <method name="write" type="int" line="252"/>
            <javadoc line="252">
                Writes a sequence of bytes to this channel from the given buffer.
                  &lt;p&gt; Bytes are written starting at this channel&apos;s current file position
                  unless the channel is in append mode, in which case the position is
                  first advanced to the end of the file.  The file is grown, if necessary,
                  to accommodate the written bytes, and then the file position is updated
                  with the number of bytes actually written.  Otherwise this method
                  behaves exactly as specified by the {@link WritableByteChannel}interface. &lt;/p&gt;                
            </javadoc>
            <method name="write" type="long" line="262"/>
            <javadoc line="262">
                Writes a sequence of bytes to this channel from a subsequence of the
                  given buffers.
                  &lt;p&gt; Bytes are written starting at this channel&apos;s current file position
                  unless the channel is in append mode, in which case the position is
                  first advanced to the end of the file.  The file is grown, if necessary,
                  to accommodate the written bytes, and then the file position is updated
                  with the number of bytes actually written.  Otherwise this method
                  behaves exactly as specified in the {@link GatheringByteChannel}interface.  &lt;/p&gt;                
            </javadoc>
            <javadoc line="273">
                Writes a sequence of bytes to this channel from the given buffers.
                  &lt;p&gt; Bytes are written starting at this channel&apos;s current file position
                  unless the channel is in append mode, in which case the position is
                  first advanced to the end of the file.  The file is grown, if necessary,
                  to accommodate the written bytes, and then the file position is updated
                  with the number of bytes actually written.  Otherwise this method
                  behaves exactly as specified in the {@link GatheringByteChannel}interface.  &lt;/p&gt;                
            </javadoc>
            <method name="write" type="long" line="282">
                <params>
                    <param name="srcs" type="ByteBuffer[]"/>
                </params>
            </method>
            <method name="position" type="long" line="285"/>
            <javadoc line="285">
                Returns this channel&apos;s file position.  &lt;/p&gt;                
                <return>
                    This channel&apos;s file position,
                      a non-negative integer counting the number of bytes
                      from the beginning of the file to the current position                    
                </return>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
            </javadoc>
            <method name="position" type="FileChannel" line="294"/>
            <javadoc line="294">
                Sets this channel&apos;s file position.
                  &lt;p&gt; Setting the position to a value that is greater than the file&apos;s
                  current size is legal but does not change the size of the file.  A later
                  attempt to read bytes at such a position will immediately return an
                  end-of-file indication.  A later attempt to write bytes at such a
                  position will cause the file to be grown to accommodate the new bytes;
                  the values of any bytes between the previous end-of-file and the
                  newly-written bytes are unspecified.  &lt;/p&gt;                
                <param>
                    newPositionThe new position, a non-negative integer counting
                      the number of bytes from the beginning of the file                    
                </param>
                <return>
                    This file channel                    
                </return>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf the new position is negative                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
            </javadoc>
            <method name="size" type="long" line="311"/>
            <javadoc line="311">
                Returns the current size of this channel&apos;s file.  &lt;/p&gt;                
                <return>
                    The current size of this channel&apos;s file,
                      measured in bytes                    
                </return>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
            </javadoc>
            <method name="truncate" type="FileChannel" line="319"/>
            <javadoc line="319">
                Truncates this channel&apos;s file to the given size.
                  &lt;p&gt; If the given size is less than the file&apos;s current size then the file
                  is truncated, discarding any bytes beyond the new end of the file.  If
                  the given size is greater than or equal to the file&apos;s current size then
                  the file is not modified.  In either case, if this channel&apos;s file
                  position is greater than the given size then it is set to that size.
                  &lt;/p&gt;                
                <param>
                    sizeThe new size, a non-negative byte count                    
                </param>
                <return>
                    This file channel                    
                </return>
                <throws>
                    NonWritableChannelExceptionIf this channel was not opened for writing                    
                </throws>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf the new size is negative                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
            </javadoc>
            <method name="force" type="void" line="335"/>
            <javadoc line="335">
                Forces any updates to this channel&apos;s file to be written to the storage
                  device that contains it.
                  &lt;p&gt; If this channel&apos;s file resides on a local storage device then when
                  this method returns it is guaranteed that all changes made to the file
                  since this channel was created, or since this method was last invoked,
                  will have been written to that device.  This is useful for ensuring that
                  critical information is not lost in the event of a system crash.
                  &lt;p&gt; If the file does not reside on a local device then no such guarantee
                  is made.
                  &lt;p&gt; The &lt;tt&gt;metaData&lt;/tt&gt; parameter can be used to limit the number of
                  I/O operations that this method is required to perform.  Passing
                  &lt;tt&gt;false&lt;/tt&gt; for this parameter indicates that only updates to the
                  file&apos;s content need be written to storage; passing &lt;tt&gt;true&lt;/tt&gt;
                  indicates that updates to both the file&apos;s content and metadata must be
                  written, which generally requires at least one more I/O operation.
                  Whether this parameter actually has any effect is dependent upon the
                  underlying operating system and is therefore unspecified.
                  &lt;p&gt; Invoking this method may cause an I/O operation to occur even if the
                  channel was only opened for reading.  Some operating systems, for
                  example, maintain a last-access time as part of a file&apos;s metadata, and
                  this time is updated whenever the file is read.  Whether or not this is
                  actually done is system-dependent and is therefore unspecified.
                  &lt;p&gt; This method is only guaranteed to force changes that were made to
                  this channel&apos;s file via the methods defined in this class.  It may or
                  may not force changes that were made by modifying the content of a{@link MappedByteBuffer &lt;i&gt;mapped byte buffer&lt;/i&gt;} obtained by
                  invoking the {@link #map map} method.  Invoking the {@link MappedByteBuffer#force force} method of the mapped byte buffer will
                  force changes made to the buffer&apos;s content to be written.  &lt;/p&gt;                
                <param>
                    metaDataIf &lt;tt&gt;true&lt;/tt&gt; then this method is required to force changes
                      to both the file&apos;s content and metadata to be written to
                      storage; otherwise, it need only force content changes to be
                      written                    
                </param>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
            </javadoc>
            <method name="transferTo" type="long" line="371"/>
            <javadoc line="371">
                Transfers bytes from this channel&apos;s file to the given writable byte
                  channel.
                  &lt;p&gt; An attempt is made to read up to &lt;tt&gt;count&lt;/tt&gt; bytes starting at
                  the given &lt;tt&gt;position&lt;/tt&gt; in this channel&apos;s file and write them to the
                  target channel.  An invocation of this method may or may not transfer
                  all of the requested bytes; whether or not it does so depends upon the
                  natures and states of the channels.  Fewer than the requested number of
                  bytes are transferred if this channel&apos;s file contains fewer than
                  &lt;tt&gt;count&lt;/tt&gt; bytes starting at the given &lt;tt&gt;position&lt;/tt&gt;, or if the
                  target channel is non-blocking and it has fewer than &lt;tt&gt;count&lt;/tt&gt;
                  bytes free in its output buffer.
                  &lt;p&gt; This method does not modify this channel&apos;s position.  If the given
                  position is greater than the file&apos;s current size then no bytes are
                  transferred.  If the target channel has a position then bytes are
                  written starting at that position and then the position is incremented
                  by the number of bytes written.
                  &lt;p&gt; This method is potentially much more efficient than a simple loop
                  that reads from this channel and writes to the target channel.  Many
                  operating systems can transfer bytes directly from the filesystem cache
                  to the target channel without actually copying them.  &lt;/p&gt;                
                <param>
                    positionThe position within the file at which the transfer is to begin;
                      must be non-negative                    
                </param>
                <param>
                    countThe maximum number of bytes to be transferred; must be
                      non-negative                    
                </param>
                <param>
                    targetThe target channel                    
                </param>
                <return>
                    The number of bytes, possibly zero,
                      that were actually transferred                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the preconditions on the parameters do not hold                    
                </throws>
                <throws>
                    NonReadableChannelExceptionIf this channel was not opened for reading                    
                </throws>
                <throws>
                    NonWritableChannelExceptionIf the target channel was not opened for writing                    
                </throws>
                <throws>
                    ClosedChannelExceptionIf either this channel or the target channel is closed                    
                </throws>
                <throws>
                    AsynchronousCloseExceptionIf another thread closes either channel
                      while the transfer is in progress                    
                </throws>
                <throws>
                    ClosedByInterruptExceptionIf another thread interrupts the current thread while the
                      transfer is in progress, thereby closing both channels and
                      setting the current thread&apos;s interrupt status                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
            </javadoc>
            <method name="transferFrom" type="long" line="411"/>
            <javadoc line="411">
                Transfers bytes into this channel&apos;s file from the given readable byte
                  channel.
                  &lt;p&gt; An attempt is made to read up to &lt;tt&gt;count&lt;/tt&gt; bytes from the
                  source channel and write them to this channel&apos;s file starting at the
                  given &lt;tt&gt;position&lt;/tt&gt;.  An invocation of this method may or may not
                  transfer all of the requested bytes; whether or not it does so depends
                  upon the natures and states of the channels.  Fewer than the requested
                  number of bytes will be transferred if the source channel has fewer than
                  &lt;tt&gt;count&lt;/tt&gt; bytes remaining, or if the source channel is non-blocking
                  and has fewer than &lt;tt&gt;count&lt;/tt&gt; bytes immediately available in its
                  input buffer.
                  &lt;p&gt; This method does not modify this channel&apos;s position.  If the given
                  position is greater than the file&apos;s current size then no bytes are
                  transferred.  If the source channel has a position then bytes are read
                  starting at that position and then the position is incremented by the
                  number of bytes read.
                  &lt;p&gt; This method is potentially much more efficient than a simple loop
                  that reads from the source channel and writes to this channel.  Many
                  operating systems can transfer bytes directly from the source channel
                  into the filesystem cache without actually copying them.  &lt;/p&gt;                
                <param>
                    srcThe source channel                    
                </param>
                <param>
                    positionThe position within the file at which the transfer is to begin;
                      must be non-negative                    
                </param>
                <param>
                    countThe maximum number of bytes to be transferred; must be
                      non-negative                    
                </param>
                <return>
                    The number of bytes, possibly zero,
                      that were actually transferred                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the preconditions on the parameters do not hold                    
                </throws>
                <throws>
                    NonReadableChannelExceptionIf the source channel was not opened for reading                    
                </throws>
                <throws>
                    NonWritableChannelExceptionIf this channel was not opened for writing                    
                </throws>
                <throws>
                    ClosedChannelExceptionIf either this channel or the source channel is closed                    
                </throws>
                <throws>
                    AsynchronousCloseExceptionIf another thread closes either channel
                      while the transfer is in progress                    
                </throws>
                <throws>
                    ClosedByInterruptExceptionIf another thread interrupts the current thread while the
                      transfer is in progress, thereby closing both channels and
                      setting the current thread&apos;s interrupt status                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
            </javadoc>
            <method name="read" type="int" line="451"/>
            <javadoc line="451">
                Reads a sequence of bytes from this channel into the given buffer,
                  starting at the given file position.
                  &lt;p&gt; This method works in the same manner as the {@link #read(ByteBuffer)} method, except that bytes are read starting at the
                  given file position rather than at the channel&apos;s current position.  This
                  method does not modify this channel&apos;s position.  If the given position
                  is greater than the file&apos;s current size then no bytes are read.  &lt;/p&gt;                
                <param>
                    dstThe buffer into which bytes are to be transferred                    
                </param>
                <param>
                    positionThe file position at which the transfer is to begin;
                      must be non-negative                    
                </param>
                <return>
                    The number of bytes read, possibly zero, or &lt;tt&gt;-1&lt;/tt&gt; if the
                      given position is greater than or equal to the file&apos;s current
                      size                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the position is negative                    
                </throws>
                <throws>
                    NonReadableChannelExceptionIf this channel was not opened for reading                    
                </throws>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    AsynchronousCloseExceptionIf another thread closes this channel
                      while the read operation is in progress                    
                </throws>
                <throws>
                    ClosedByInterruptExceptionIf another thread interrupts the current thread
                      while the read operation is in progress, thereby
                      closing the channel and setting the current thread&apos;s
                      interrupt status                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
            </javadoc>
            <method name="write" type="int" line="476"/>
            <javadoc line="476">
                Writes a sequence of bytes to this channel from the given buffer,
                  starting at the given file position.
                  &lt;p&gt; This method works in the same manner as the {@link #write(ByteBuffer)} method, except that bytes are written starting at
                  the given file position rather than at the channel&apos;s current position.
                  This method does not modify this channel&apos;s position.  If the given
                  position is greater than the file&apos;s current size then the file will be
                  grown to accommodate the new bytes; the values of any bytes between the
                  previous end-of-file and the newly-written bytes are unspecified.  &lt;/p&gt;                
                <param>
                    srcThe buffer from which bytes are to be transferred                    
                </param>
                <param>
                    positionThe file position at which the transfer is to begin;
                      must be non-negative                    
                </param>
                <return>
                    The number of bytes written, possibly zero                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the position is negative                    
                </throws>
                <throws>
                    NonWritableChannelExceptionIf this channel was not opened for writing                    
                </throws>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    AsynchronousCloseExceptionIf another thread closes this channel
                      while the write operation is in progress                    
                </throws>
                <throws>
                    ClosedByInterruptExceptionIf another thread interrupts the current thread
                      while the write operation is in progress, thereby
                      closing the channel and setting the current thread&apos;s
                      interrupt status                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
            </javadoc>
            <class name="MapMode" line="501">
                <javadoc line="501">
                    A typesafe enumeration for file-mapping modes.                    
                    <since>
                        1.4                        
                    </since>
                    <see>
                        java.nio.channels.FileChannel#map                        
                    </see>
                </javadoc>
                <declaration name="READ_ONLY" type="MapMode" line="507"/>
                <javadoc line="507">
                    Mode for a read-only mapping.                    
                </javadoc>
                <declaration name="READ_WRITE" type="MapMode" line="511"/>
                <javadoc line="511">
                    Mode for a read/write mapping.                    
                </javadoc>
                <declaration name="PRIVATE" type="MapMode" line="515"/>
                <javadoc line="515">
                    Mode for a private (copy-on-write) mapping.                    
                </javadoc>
                <declaration name="name" type="String" line="519"/>
                <method name="MapMode" type="constructor" line="520">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                </method>
                <javadoc line="523">
                    Returns a string describing this file-mapping mode.                    
                    <return>
                        A descriptive string                        
                    </return>
                </javadoc>
                <method name="toString" type="String" line="527"/>
            </class>
            <method name="map" type="MappedByteBuffer" line="531"/>
            <javadoc line="531">
                Maps a region of this channel&apos;s file directly into memory.
                  &lt;p&gt; A region of a file may be mapped into memory in one of three modes:
                  &lt;/p&gt;
                  &lt;ul type=disc&gt;
                  &lt;li&gt;&lt;p&gt; &lt;i&gt;Read-only:&lt;/i&gt; Any attempt to modify the resulting buffer
                  will cause a {@link java.nio.ReadOnlyBufferException} to be thrown.
                  ({@link MapMode#READ_ONLY MapMode.READ_ONLY}) &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; &lt;i&gt;Read/write:&lt;/i&gt; Changes made to the resulting buffer will
                  eventually be propagated to the file; they may or may not be made
                  visible to other programs that have mapped the same file.  ({@link MapMode#READ_WRITE MapMode.READ_WRITE}) &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; &lt;i&gt;Private:&lt;/i&gt; Changes made to the resulting buffer will not
                  be propagated to the file and will not be visible to other programs
                  that have mapped the same file; instead, they will cause private
                  copies of the modified portions of the buffer to be created.  ({@link MapMode#PRIVATE MapMode.PRIVATE}) &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt; For a read-only mapping, this channel must have been opened for
                  reading; for a read/write or private mapping, this channel must have
                  been opened for both reading and writing.
                  &lt;p&gt; The {@link MappedByteBuffer &lt;i&gt;mapped byte buffer&lt;/i&gt;}returned by this method will have a position of zero and a limit and
                  capacity of &lt;tt&gt;size&lt;/tt&gt;; its mark will be undefined.  The buffer and
                  the mapping that it represents will remain valid until the buffer itself
                  is garbage-collected.
                  &lt;p&gt; A mapping, once established, is not dependent upon the file channel
                  that was used to create it.  Closing the channel, in particular, has no
                  effect upon the validity of the mapping.
                  &lt;p&gt; Many of the details of memory-mapped files are inherently dependent
                  upon the underlying operating system and are therefore unspecified.  The
                  behavior of this method when the requested region is not completely
                  contained within this channel&apos;s file is unspecified.  Whether changes
                  made to the content or size of the underlying file, by this program or
                  another, are propagated to the buffer is unspecified.  The rate at which
                  changes to the buffer are propagated to the file is unspecified.
                  &lt;p&gt; For most operating systems, mapping a file into memory is more
                  expensive than reading or writing a few tens of kilobytes of data via
                  the usual {@link #read read} and {@link #write write} methods.  From the
                  standpoint of performance it is generally only worth mapping relatively
                  large files into memory.  &lt;/p&gt;                
                <param>
                    modeOne of the constants {@link MapMode#READ_ONLY READ_ONLY}, {@link MapMode#READ_WRITE READ_WRITE}, or {@link MapMode#PRIVATEPRIVATE} defined in the {@link MapMode} class, according to
                      whether the file is to be mapped read-only, read/write, or
                      privately (copy-on-write), respectively                    
                </param>
                <param>
                    positionThe position within the file at which the mapped region
                      is to start; must be non-negative                    
                </param>
                <param>
                    sizeThe size of the region to be mapped; must be non-negative and
                      no greater than {@link java.lang.Integer#MAX_VALUE}                    
                </param>
                <return>
                    The mapped byte buffer                    
                </return>
                <throws>
                    NonReadableChannelExceptionIf the &lt;tt&gt;mode&lt;/tt&gt; is {@link MapMode#READ_ONLY READ_ONLY} but
                      this channel was not opened for reading                    
                </throws>
                <throws>
                    NonWritableChannelExceptionIf the &lt;tt&gt;mode&lt;/tt&gt; is {@link MapMode#READ_WRITE READ_WRITE} or{@link MapMode#PRIVATE PRIVATE} but this channel was not opened
                      for both reading and writing                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf the preconditions on the parameters do not hold                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
                <see>
                    java.nio.channels.FileChannel.MapMode                    
                </see>
                <see>
                    java.nio.MappedByteBuffer                    
                </see>
            </javadoc>
            <method name="lock" type="FileLock" line="587"/>
            <javadoc line="587">
                Acquires a lock on the given region of this channel&apos;s file.
                  &lt;p&gt; An invocation of this method will block until the region can be
                  locked, this channel is closed, or the invoking thread is interrupted,
                  whichever comes first.
                  &lt;p&gt; If this channel is closed by another thread during an invocation of
                  this method then an {@link AsynchronousCloseException} will be thrown.
                  &lt;p&gt; If the invoking thread is interrupted while waiting to acquire the
                  lock then its interrupt status will be set and a {@link FileLockInterruptionException} will be thrown.  If the invoker&apos;s
                  interrupt status is set when this method is invoked then that exception
                  will be thrown immediately; the thread&apos;s interrupt status will not be
                  changed.
                  &lt;p&gt; The region specified by the &lt;tt&gt;position&lt;/tt&gt; and &lt;tt&gt;size&lt;/tt&gt;
                  parameters need not be contained within, or even overlap, the actual
                  underlying file.  Lock regions are fixed in size; if a locked region
                  initially contains the end of the file and the file grows beyond the
                  region then the new portion of the file will not be covered by the lock.
                  If a file is expected to grow in size and a lock on the entire file is
                  required then a region starting at zero, and no smaller than the
                  expected maximum size of the file, should be locked.  The zero-argument{@link #lock()} method simply locks a region of size {@link Long#MAX_VALUE}.
                  &lt;p&gt; Some operating systems do not support shared locks, in which case a
                  request for a shared lock is automatically converted into a request for
                  an exclusive lock.  Whether the newly-acquired lock is shared or
                  exclusive may be tested by invoking the resulting lock object&apos;s {@link FileLock#isShared() isShared} method.
                  &lt;p&gt; File locks are held on behalf of the entire Java virtual machine.
                  They are not suitable for controlling access to a file by multiple
                  threads within the same virtual machine.  &lt;/p&gt;                
                <param>
                    positionThe position at which the locked region is to start; must be
                      non-negative                    
                </param>
                <param>
                    sizeThe size of the locked region; must be non-negative, and the sum
                      &lt;tt&gt;position&lt;/tt&gt;&amp;nbsp;+&amp;nbsp;&lt;tt&gt;size&lt;/tt&gt; must be non-negative                    
                </param>
                <param>
                    shared&lt;tt&gt;true&lt;/tt&gt; to request a shared lock, in which case this
                      channel must be open for reading (and possibly writing);
                      &lt;tt&gt;false&lt;/tt&gt; to request an exclusive lock, in which case this
                      channel must be open for writing (and possibly reading)                    
                </param>
                <return>
                    A lock object representing the newly-acquired lock                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the preconditions on the parameters do not hold                    
                </throws>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    AsynchronousCloseExceptionIf another thread closes this channel while the invoking
                      thread is blocked in this method                    
                </throws>
                <throws>
                    FileLockInterruptionExceptionIf the invoking thread is interrupted while blocked in this
                      method                    
                </throws>
                <throws>
                    OverlappingFileLockExceptionIf a lock that overlaps the requested region is already held by
                      this Java virtual machine, or if another thread is already
                      blocked in this method and is attempting to lock an overlapping
                      region                    
                </throws>
                <throws>
                    NonReadableChannelExceptionIf &lt;tt&gt;shared&lt;/tt&gt; is &lt;tt&gt;true&lt;/tt&gt; this channel was not
                      opened for reading                    
                </throws>
                <throws>
                    NonWritableChannelExceptionIf &lt;tt&gt;shared&lt;/tt&gt; is &lt;tt&gt;false&lt;/tt&gt; but this channel was not
                      opened for writing                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
                <see>
                    #lock()                    
                </see>
                <see>
                    #tryLock()                    
                </see>
                <see>
                    #tryLock(long,long,boolean)                    
                </see>
            </javadoc>
            <javadoc line="643">
                Acquires an exclusive lock on this channel&apos;s file.
                  &lt;p&gt; An invocation of this method of the form &lt;tt&gt;fc.lock()&lt;/tt&gt; behaves
                  in exactly the same way as the invocation
                  &lt;pre&gt;
                  fc.{@link #lock(long,long,boolean) lock}(0L, Long.MAX_VALUE, false) &lt;/pre&gt;                
                <return>
                    A lock object representing the newly-acquired lock                    
                </return>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    AsynchronousCloseExceptionIf another thread closes this channel while the invoking
                      thread is blocked in this method                    
                </throws>
                <throws>
                    FileLockInterruptionExceptionIf the invoking thread is interrupted while blocked in this
                      method                    
                </throws>
                <throws>
                    OverlappingFileLockExceptionIf a lock that overlaps the requested region is already held by
                      this Java virtual machine, or if another thread is already
                      blocked in this method and is attempting to lock an overlapping
                      region of the same file                    
                </throws>
                <throws>
                    NonWritableChannelExceptionIf this channel was not opened for writing                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
                <see>
                    #lock(long,long,boolean)                    
                </see>
                <see>
                    #tryLock()                    
                </see>
                <see>
                    #tryLock(long,long,boolean)                    
                </see>
            </javadoc>
            <method name="lock" type="FileLock" line="665"/>
            <method name="tryLock" type="FileLock" line="668"/>
            <javadoc line="668">
                Attempts to acquire a lock on the given region of this channel&apos;s file.
                  &lt;p&gt; This method does not block.  An invocation always returns
                  immediately, either having acquired a lock on the requested region or
                  having failed to do so.  If it fails to acquire a lock because an
                  overlapping lock is held by another program then it returns
                  &lt;tt&gt;null&lt;/tt&gt;.  If it fails to acquire a lock for any other reason then
                  an appropriate exception is thrown.
                  &lt;p&gt; The region specified by the &lt;tt&gt;position&lt;/tt&gt; and &lt;tt&gt;size&lt;/tt&gt;
                  parameters need not be contained within, or even overlap, the actual
                  underlying file.  Lock regions are fixed in size; if a locked region
                  initially contains the end of the file and the file grows beyond the
                  region then the new portion of the file will not be covered by the lock.
                  If a file is expected to grow in size and a lock on the entire file is
                  required then a region starting at zero, and no smaller than the
                  expected maximum size of the file, should be locked.  The zero-argument{@link #tryLock()} method simply locks a region of size {@link Long#MAX_VALUE}.
                  &lt;p&gt; Some operating systems do not support shared locks, in which case a
                  request for a shared lock is automatically converted into a request for
                  an exclusive lock.  Whether the newly-acquired lock is shared or
                  exclusive may be tested by invoking the resulting lock object&apos;s {@link FileLock#isShared() isShared} method.
                  &lt;p&gt; File locks are held on behalf of the entire Java virtual machine.
                  They are not suitable for controlling access to a file by multiple
                  threads within the same virtual machine.  &lt;/p&gt;                
                <param>
                    positionThe position at which the locked region is to start; must be
                      non-negative                    
                </param>
                <param>
                    sizeThe size of the locked region; must be non-negative, and the sum
                      &lt;tt&gt;position&lt;/tt&gt;&amp;nbsp;+&amp;nbsp;&lt;tt&gt;size&lt;/tt&gt; must be non-negative                    
                </param>
                <param>
                    shared&lt;tt&gt;true&lt;/tt&gt; to request a shared lock,
                      &lt;tt&gt;false&lt;/tt&gt; to request an exclusive lock                    
                </param>
                <return>
                    A lock object representing the newly-acquired lock,
                      or &lt;tt&gt;null&lt;/tt&gt; if the lock could not be acquired
                      because another program holds an overlapping lock                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the preconditions on the parameters do not hold                    
                </throws>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    OverlappingFileLockExceptionIf a lock that overlaps the requested region is already held by
                      this Java virtual machine, or if another thread is already
                      blocked in this method and is attempting to lock an overlapping
                      region of the same file                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
                <see>
                    #lock()                    
                </see>
                <see>
                    #lock(long,long,boolean)                    
                </see>
                <see>
                    #tryLock()                    
                </see>
            </javadoc>
            <javadoc line="712">
                Attempts to acquire an exclusive lock on this channel&apos;s file.
                  &lt;p&gt; An invocation of this method of the form &lt;tt&gt;fc.tryLock()&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;pre&gt;
                  fc.{@link #tryLock(long,long,boolean) tryLock}(0L, Long.MAX_VALUE, false) &lt;/pre&gt;                
                <return>
                    A lock object representing the newly-acquired lock,
                      or &lt;tt&gt;null&lt;/tt&gt; if the lock could not be acquired
                      because another program holds an overlapping lock                    
                </return>
                <throws>
                    ClosedChannelExceptionIf this channel is closed                    
                </throws>
                <throws>
                    OverlappingFileLockExceptionIf a lock that overlaps the requested region is already held by
                      this Java virtual machine, or if another thread is already
                      blocked in this method and is attempting to lock an overlapping
                      region                    
                </throws>
                <throws>
                    IOExceptionIf some other I/O error occurs                    
                </throws>
                <see>
                    #lock()                    
                </see>
                <see>
                    #lock(long,long,boolean)                    
                </see>
                <see>
                    #tryLock(long,long,boolean)                    
                </see>
            </javadoc>
            <method name="tryLock" type="FileLock" line="731"/>
        </class>
    </source>