<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.security">
        <import package="java.io"/>
        <import package="java.lang.RuntimePermission"/>
        <import package="java.lang.reflect"/>
        <import package="java.net.MalformedURLException"/>
        <import package="java.net.URL"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.PropertyPermission"/>
        <import package="java.util.StringTokenizer"/>
        <import package="java.util.Vector"/>
        <import package="java.util.WeakHashMap"/>
        <import package="sun.security.jca.GetInstance"/>
        <import package="sun.security.util.Debug"/>
        <import package="sun.security.util.SecurityConstants"/>
        <class name="Policy" line="16">
            <javadoc line="16">
                A Policy object is responsible for determining whether code executing
                  in the Java runtime environment has permission to perform a
                  security-sensitive operation.
                  &lt;p&gt; There is only one Policy object installed in the runtime at any
                  given time.  A Policy object can be installed by calling the
                  &lt;code&gt;setPolicy&lt;/code&gt; method.  The installed Policy object can be
                  obtained by calling the &lt;code&gt;getPolicy&lt;/code&gt; method.
                  &lt;p&gt; If no Policy object has been installed in the runtime, a call to
                  &lt;code&gt;getPolicy&lt;/code&gt; installs an instance of the default Policy
                  implementation (a default subclass implementation of this abstract class).
                  The default Policy implementation can be changed by setting the value
                  of the &quot;policy.provider&quot; security property (in the Java security properties
                  file) to the fully qualified name of the desired Policy subclass
                  implementation.  The Java security properties file is located in the
                  file named &amp;lt;JAVA_HOME&amp;gt;/lib/security/java.security.
                  &amp;lt;JAVA_HOME&amp;gt; refers to the value of the java.home system property,
                  and specifies the directory where the JRE is installed.
                  &lt;p&gt; Application code can directly subclass Policy to provide a custom
                  implementation.  In addition, an instance of a Policy object can be
                  constructed by invoking one of the &lt;code&gt;getInstance&lt;/code&gt; factory methods
                  with a standard type.  The default policy type is &quot;JavaPolicy&quot;.
                  &lt;p&gt; Once a Policy instance has been installed (either by default, or by
                  calling &lt;code&gt;setPolicy&lt;/code&gt;),
                  the Java runtime invokes its &lt;code&gt;implies&lt;/code&gt; when it needs to
                  determine whether executing code (encapsulated in a ProtectionDomain)
                  can perform SecurityManager-protected operations.  How a Policy object
                  retrieves its policy data is up to the Policy implementation itself.
                  The policy data may be stored, for example, in a flat ASCII file,
                  in a serialized binary file of the Policy class, or in a database.
                  &lt;p&gt; The &lt;code&gt;refresh&lt;/code&gt; method causes the policy object to
                  refresh/reload its data.  This operation is implementation-dependent.
                  For example, if the policy object stores its data in configuration files,
                  calling &lt;code&gt;refresh&lt;/code&gt; will cause it to re-read the configuration
                  policy files.  If a refresh operation is not supported, this method does
                  nothing.  Note that refreshed policy may not have an effect on classes
                  in a particular ProtectionDomain. This is dependent on the Policy
                  provider&apos;s implementation of the &lt;code&gt;implies&lt;/code&gt;
                  method and its PermissionCollection caching strategy.                
                <author>
                    Roland Schemers                    
                </author>
                <author>
                    Gary Ellison                    
                </author>
                <see>
                    java.security.Provider                    
                </see>
                <see>
                    java.security.ProtectionDomain                    
                </see>
                <see>
                    java.security.Permission                    
                </see>
            </javadoc>
            <declaration name="UNSUPPORTED_EMPTY_COLLECTION" type="PermissionCollection" line="62"/>
            <javadoc line="62">
                A read-only empty PermissionCollection instance.                
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="policy" type="Policy" line="67"/>
            <javadoc line="67">
                the system-wide policy.                
            </javadoc>
            <declaration name="debug" type="Debug" line="71"/>
            <declaration name="pdMapping" type="WeakHashMap&amp;lt;ProtectionDomain.Key,PermissionCollection&amp;gt;" line="72"/>
            <javadoc line="73">
                package private for AccessControlContext                
            </javadoc>
            <method name="isSet" type="boolean" line="76"/>
            <method name="checkPermission" type="void" line="79">
                <params>
                    <param name="type" type="String"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="80"/>
                <scope line="81"/>
            </method>
            <javadoc line="85">
                Returns the installed Policy object. This value should not be cached,
                  as it may be changed by a call to &lt;code&gt;setPolicy&lt;/code&gt;.
                  This method first calls
                  &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; with a
                  &lt;code&gt;SecurityPermission(&quot;getPolicy&quot;)&lt;/code&gt; permission
                  to ensure it&apos;s ok to get the Policy object.                
                <return>
                    the installed Policy.                    
                </return>
                <throws>
                    SecurityExceptionif a security manager exists and its
                      &lt;code&gt;checkPermission&lt;/code&gt; method doesn&apos;t allow
                      getting the Policy object.                    
                </throws>
                <see>
                    SecurityManager#checkPermission(Permission)                    
                </see>
                <see>
                    #setPolicy(java.security.Policy)                    
                </see>
            </javadoc>
            <method name="getPolicy" type="Policy" line="99">
                <declaration name="sm" type="SecurityManager" line="100"/>
            </method>
            <javadoc line="104">
                Returns the installed Policy object, skipping the security check.
                  Used by SecureClassLoader and getPolicy.                
                <return>
                    the installed Policy.                    
                </return>
            </javadoc>
            <method name="getPolicyNoCheck" type="Policy" line="109">
                <scope line="110">
                    <declaration name="policy_class" type="String" line="111"/>
                    <anonymous_class line="112">
                        <method name="run" type="String" line="113"/>
                    </anonymous_class>
                    <scope line="118"/>
                    <scope line="121"/>
                    <scope line="124">
                        <declaration name="pc" type="String" line="126"/>
                        <anonymous_class line="127">
                            <method name="run" type="Policy" line="128">
                                <scope line="129">
                                    <declaration name="cl" type="ClassLoader" line="130"/>
                                    <declaration name="extcl" type="ClassLoader" line="131"/>
                                    <scope line="132"/>
                                </scope>
                                <scope line="138">
                                    <scope line="139"/>
                                </scope>
                            </method>
                        </anonymous_class>
                        <declaration name="p" type="Policy" line="127"/>
                        <scope line="148"/>
                        <scope line="151">
                            <scope line="152"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="160">
                Sets the system-wide Policy object. This method first calls
                  &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; with a
                  &lt;code&gt;SecurityPermission(&quot;setPolicy&quot;)&lt;/code&gt;
                  permission to ensure it&apos;s ok to set the Policy.                
                <param>
                    p the new system Policy object.                    
                </param>
                <throws>
                    SecurityExceptionif a security manager exists and its
                      &lt;code&gt;checkPermission&lt;/code&gt; method doesn&apos;t allow
                      setting the Policy.                    
                </throws>
                <see>
                    SecurityManager#checkPermission(Permission)                    
                </see>
                <see>
                    #getPolicy()                    
                </see>
            </javadoc>
            <method name="setPolicy" type="void" line="172">
                <params>
                    <param name="p" type="Policy"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="173"/>
                <scope line="175"/>
                <scope line="178"/>
            </method>
            <javadoc line="182">
                Initialize superclass state such that a legacy provider can
                  handle queries for itself.                
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="initPolicy" type="void" line="187">
                <params>
                    <param name="p" type="Policy"/>
                </params>
                <anonymous_class line="188">
                    <method name="run" type="ProtectionDomain" line="189"/>
                </anonymous_class>
                <declaration name="policyDomain" type="ProtectionDomain" line="188"/>
                <declaration name="policyPerms" type="PermissionCollection" line="194"/>
                <scope line="195">
                    <scope line="196"/>
                </scope>
                <scope line="200">
                    <scope line="201"/>
                    <scope line="204"/>
                    <scope line="208"/>
                </scope>
            </method>
            <javadoc line="214">
                Returns a Policy object of the specified type.
                  &lt;p&gt; This method traverses the list of registered security providers,
                  starting with the most preferred Provider.
                  A new Policy object encapsulating the
                  PolicySpi implementation from the first
                  Provider that supports the specified type is returned.
                  &lt;p&gt; Note that the list of registered providers may be retrieved via
                  the {@link Security#getProviders() Security.getProviders()} method.                
                <param>
                    type the specified Policy type.  See the Policy section in the
                      &lt;a href=
                      &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Policy&quot;&gt;
                      Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
                      for a list of standard Policy types.                    
                </param>
                <param>
                    params parameters for the Policy, which may be null.                    
                </param>
                <return>
                    the new Policy object.                    
                </return>
                <exception>
                    SecurityException if the caller does not have permission
                      to get a Policy instance for the specified type.                    
                </exception>
                <exception>
                    NullPointerException if the specified type is null.                    
                </exception>
                <exception>
                    IllegalArgumentException if the specified parameters
                      are not understood by the PolicySpi implementation
                      from the selected Provider.                    
                </exception>
                <exception>
                    NoSuchAlgorithmException if no Provider supports a PolicySpi
                      implementation for the specified type.                    
                </exception>
                <see>
                    Provider                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getInstance" type="Policy" line="241">
                <params>
                    <param name="type" type="String"/>
                    <param name="params" type="Policy.Parameters"/>
                </params>
                <scope line="243">
                    <declaration name="instance" type="GetInstance.Instance" line="244"/>
                </scope>
                <scope line="247"/>
            </method>
            <javadoc line="251">
                Returns a Policy object of the specified type.
                  &lt;p&gt; A new Policy object encapsulating the
                  PolicySpi implementation from the specified provider
                  is returned.   The specified provider must be registered
                  in the provider list.
                  &lt;p&gt; Note that the list of registered providers may be retrieved via
                  the {@link Security#getProviders() Security.getProviders()} method.                
                <param>
                    type the specified Policy type.  See the Policy section in the
                      &lt;a href=
                      &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Policy&quot;&gt;
                      Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
                      for a list of standard Policy types.                    
                </param>
                <param>
                    params parameters for the Policy, which may be null.                    
                </param>
                <param>
                    provider the provider.                    
                </param>
                <return>
                    the new Policy object.                    
                </return>
                <exception>
                    SecurityException if the caller does not have permission
                      to get a Policy instance for the specified type.                    
                </exception>
                <exception>
                    NullPointerException if the specified type is null.                    
                </exception>
                <exception>
                    IllegalArgumentException if the specified provider
                      is null or empty,
                      or if the specified parameters are not understood by
                      the PolicySpi implementation from the specified provider.                    
                </exception>
                <exception>
                    NoSuchProviderException if the specified provider is not
                      registered in the security provider list.                    
                </exception>
                <exception>
                    NoSuchAlgorithmException if the specified provider does not
                      support a PolicySpi implementation for the specified type.                    
                </exception>
                <see>
                    Provider                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getInstance" type="Policy" line="281">
                <params>
                    <param name="type" type="String"/>
                    <param name="params" type="Policy.Parameters"/>
                    <param name="provider" type="String"/>
                </params>
                <scope line="282"/>
                <scope line="286">
                    <declaration name="instance" type="GetInstance.Instance" line="287"/>
                </scope>
                <scope line="290"/>
            </method>
            <javadoc line="294">
                Returns a Policy object of the specified type.
                  &lt;p&gt; A new Policy object encapsulating the
                  PolicySpi implementation from the specified Provider
                  object is returned.  Note that the specified Provider object
                  does not have to be registered in the provider list.                
                <param>
                    type the specified Policy type.  See the Policy section in the
                      &lt;a href=
                      &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Policy&quot;&gt;
                      Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
                      for a list of standard Policy types.                    
                </param>
                <param>
                    params parameters for the Policy, which may be null.                    
                </param>
                <param>
                    provider the Provider.                    
                </param>
                <return>
                    the new Policy object.                    
                </return>
                <exception>
                    SecurityException if the caller does not have permission
                      to get a Policy instance for the specified type.                    
                </exception>
                <exception>
                    NullPointerException if the specified type is null.                    
                </exception>
                <exception>
                    IllegalArgumentException if the specified Provider is null,
                      or if the specified parameters are not understood by
                      the PolicySpi implementation from the specified Provider.                    
                </exception>
                <exception>
                    NoSuchAlgorithmException if the specified Provider does not
                      support a PolicySpi implementation for the specified type.                    
                </exception>
                <see>
                    Provider                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getInstance" type="Policy" line="319">
                <params>
                    <param name="type" type="String"/>
                    <param name="params" type="Policy.Parameters"/>
                    <param name="provider" type="Provider"/>
                </params>
                <scope line="320"/>
                <scope line="324">
                    <declaration name="instance" type="GetInstance.Instance" line="325"/>
                </scope>
                <scope line="328"/>
            </method>
            <method name="handleException" type="Policy" line="332">
                <params>
                    <param name="nsae" type="NoSuchAlgorithmException"/>
                </params>
                <declaration name="cause" type="Throwable" line="333"/>
                <scope line="334"/>
            </method>
            <javadoc line="339">
                Return the Provider of this Policy.
                  &lt;p&gt; This Policy instance will only have a Provider if it
                  was obtained via a call to &lt;code&gt;Policy.getInstance&lt;/code&gt;.
                  Otherwise this method returns null.                
                <return>
                    the Provider of this Policy, or null.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getProvider" type="Provider" line="347"/>
            <javadoc line="350">
                Return the type of this Policy.
                  &lt;p&gt; This Policy instance will only have a type if it
                  was obtained via a call to &lt;code&gt;Policy.getInstance&lt;/code&gt;.
                  Otherwise this method returns null.                
                <return>
                    the type of this Policy, or null.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getType" type="String" line="358"/>
            <javadoc line="361">
                Return Policy parameters.
                  &lt;p&gt; This Policy instance will only have parameters if it
                  was obtained via a call to &lt;code&gt;Policy.getInstance&lt;/code&gt;.
                  Otherwise this method returns null.                
                <return>
                    Policy parameters, or null.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getParameters" type="Policy.Parameters" line="369"/>
            <javadoc line="372">
                Return a PermissionCollection object containing the set of
                  permissions granted to the specified CodeSource.
                  &lt;p&gt; Applications are discouraged from calling this method
                  since this operation may not be supported by all policy implementations.
                  Applications should solely rely on the &lt;code&gt;implies&lt;/code&gt; method
                  to perform policy checks.  If an application absolutely must call
                  a getPermissions method, it should call
                  &lt;code&gt;getPermissions(ProtectionDomain)&lt;/code&gt;.
                  &lt;p&gt; The default implementation of this method returns
                  Policy.UNSUPPORTED_EMPTY_COLLECTION.  This method can be
                  overridden if the policy implementation can return a set of
                  permissions granted to a CodeSource.                
                <param>
                    codesource the CodeSource to which the returned
                      PermissionCollection has been granted.                    
                </param>
                <return>
                    a set of permissions granted to the specified CodeSource.
                      If this operation is supported, the returned
                      set of permissions must be a new mutable instance
                      and it must support heterogeneous Permission types.
                      If this operation is not supported,
                      Policy.UNSUPPORTED_EMPTY_COLLECTION is returned.                    
                </return>
            </javadoc>
            <method name="getPermissions" type="PermissionCollection" line="394">
                <params>
                    <param name="codesource" type="CodeSource"/>
                </params>
            </method>
            <javadoc line="397">
                Return a PermissionCollection object containing the set of
                  permissions granted to the specified ProtectionDomain.
                  &lt;p&gt; Applications are discouraged from calling this method
                  since this operation may not be supported by all policy implementations.
                  Applications should rely on the &lt;code&gt;implies&lt;/code&gt; method
                  to perform policy checks.
                  &lt;p&gt; The default implementation of this method first retrieves
                  the permissions returned via &lt;code&gt;getPermissions(CodeSource)&lt;/code&gt;
                  (the CodeSource is taken from the specified ProtectionDomain),
                  as well as the permissions located inside the specified ProtectionDomain.
                  All of these permissions are then combined and returned in a new
                  PermissionCollection object.  If &lt;code&gt;getPermissions(CodeSource)&lt;/code&gt;
                  returns Policy.UNSUPPORTED_EMPTY_COLLECTION, then this method
                  returns the permissions contained inside the specified ProtectionDomain
                  in a new PermissionCollection object.
                  &lt;p&gt; This method can be overridden if the policy implementation
                  supports returning a set of permissions granted to a ProtectionDomain.                
                <param>
                    domain the ProtectionDomain to which the returned
                      PermissionCollection has been granted.                    
                </param>
                <return>
                    a set of permissions granted to the specified ProtectionDomain.
                      If this operation is supported, the returned
                      set of permissions must be a new mutable instance
                      and it must support heterogeneous Permission types.
                      If this operation is not supported,
                      Policy.UNSUPPORTED_EMPTY_COLLECTION is returned.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getPermissions" type="PermissionCollection" line="425">
                <params>
                    <param name="domain" type="ProtectionDomain"/>
                </params>
                <declaration name="pc" type="PermissionCollection" line="426"/>
                <scope line="428"/>
                <scope line="431"/>
                <scope line="434">
                    <declaration name="perms" type="Permissions" line="435"/>
                    <scope line="436">
                        <scope line="437"/>
                    </scope>
                </scope>
                <scope line="444"/>
            </method>
            <javadoc line="450">
                add static permissions to provided permission collection                
            </javadoc>
            <method name="addStaticPerms" type="void" line="453">
                <params>
                    <param name="perms" type="PermissionCollection"/>
                    <param name="statics" type="PermissionCollection"/>
                </params>
                <scope line="454">
                    <scope line="455">
                        <declaration name="e" type="Enumeration&amp;lt;Permission&amp;gt;" line="456"/>
                        <scope line="457"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="463">
                Evaluates the global policy for the permissions granted to
                  the ProtectionDomain and tests whether the permission is
                  granted.                
                <param>
                    domain the ProtectionDomain to test                    
                </param>
                <param>
                    permission the Permission object to be tested for implication.                    
                </param>
                <return>
                    true if &quot;permission&quot; is a proper subset of a permission
                      granted to this ProtectionDomain.                    
                </return>
                <see>
                    java.security.ProtectionDomain                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="implies" type="boolean" line="474">
                <params>
                    <param name="domain" type="ProtectionDomain"/>
                    <param name="permission" type="Permission"/>
                </params>
                <declaration name="pc" type="PermissionCollection" line="475"/>
                <scope line="476"/>
                <scope line="479"/>
                <scope line="482"/>
                <scope line="486"/>
                <scope line="489"/>
            </method>
            <javadoc line="494">
                Refreshes/reloads the policy configuration. The behavior of this method
                  depends on the implementation. For example, calling &lt;code&gt;refresh&lt;/code&gt;
                  on a file-based policy will cause the file to be re-read.
                  &lt;p&gt; The default implementation of this method does nothing.
                  This method should be overridden if a refresh operation is supported
                  by the policy implementation.                
            </javadoc>
            <method name="refresh" type="void" line="502"/>
            <class name="PolicyDelegate" line="504">
                <extends class="Policy"/>
                <javadoc line="504">
                    This subclass is returned by the getInstance calls.  All Policy calls
                      are delegated to the underlying PolicySpi.                    
                </javadoc>
                <declaration name="spi" type="PolicySpi" line="509"/>
                <declaration name="p" type="Provider" line="510"/>
                <declaration name="type" type="String" line="511"/>
                <declaration name="params" type="Policy.Parameters" line="512"/>
                <method name="PolicyDelegate" type="constructor" line="513">
                    <params>
                        <param name="spi" type="PolicySpi"/>
                        <param name="p" type="Provider"/>
                        <param name="type" type="String"/>
                        <param name="params" type="Policy.Parameters"/>
                    </params>
                </method>
                <method name="getType" type="String" line="519"/>
                <method name="getParameters" type="Policy.Parameters" line="522"/>
                <method name="getProvider" type="Provider" line="525"/>
                <method name="getPermissions" type="PermissionCollection" line="528">
                    <params>
                        <param name="codesource" type="CodeSource"/>
                    </params>
                </method>
                <method name="getPermissions" type="PermissionCollection" line="531">
                    <params>
                        <param name="domain" type="ProtectionDomain"/>
                    </params>
                </method>
                <method name="implies" type="boolean" line="534">
                    <params>
                        <param name="domain" type="ProtectionDomain"/>
                        <param name="perm" type="Permission"/>
                    </params>
                </method>
                <method name="refresh" type="void" line="537"/>
            </class>
            <interface name="Parameters">
                <javadoc line="541">
                    This represents a marker interface for Policy parameters.                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
            </interface>
            <class name="UnsupportedEmptyCollection" line="547">
                <extends class="PermissionCollection"/>
                <javadoc line="547">
                    This class represents a read-only empty PermissionCollection object that
                      is returned from the &lt;code&gt;getPermissions(CodeSource)&lt;/code&gt; and
                      &lt;code&gt;getPermissions(ProtectionDomain)&lt;/code&gt;
                      methods in the Policy class when those operations are not
                      supported by the Policy implementation.                    
                </javadoc>
                <declaration name="perms" type="Permissions" line="555"/>
                <javadoc line="556">
                    Create a read-only empty PermissionCollection object.                    
                </javadoc>
                <method name="UnsupportedEmptyCollection" type="constructor" line="559"/>
                <javadoc line="563">
                    Adds a permission object to the current collection of permission
                      objects.                    
                    <param>
                        permission the Permission object to add.                        
                    </param>
                    <exception>
                        SecurityException - if this PermissionCollection object
                          has been marked readonly                        
                    </exception>
                </javadoc>
                <method name="add" type="void" line="570">
                    <params>
                        <param name="permission" type="Permission"/>
                    </params>
                </method>
                <javadoc line="573">
                    Checks to see if the specified permission is implied by the
                      collection of Permission objects held in this PermissionCollection.                    
                    <param>
                        permission the Permission object to compare.                        
                    </param>
                    <return>
                        true if &quot;permission&quot; is implied by the  permissions in
                          the collection, false if not.                        
                    </return>
                </javadoc>
                <method name="implies" type="boolean" line="580">
                    <params>
                        <param name="permission" type="Permission"/>
                    </params>
                </method>
                <javadoc line="583">
                    Returns an enumeration of all the Permission objects in the
                      collection.                    
                    <return>
                        an enumeration of all the Permissions.                        
                    </return>
                </javadoc>
                <method name="elements" type="Enumeration&lt;Permission&gt;" line="588"/>
            </class>
        </class>
    </source>