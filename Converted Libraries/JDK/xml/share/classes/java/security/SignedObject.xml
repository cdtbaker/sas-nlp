<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.security">
        <import package="java.io"/>
        <class name="SignedObject" line="30">
            <comment line="124">
                The original content is &quot;deep copied&quot; in its serialized format
                 and stored in a byte array.  The signature field is also in the
                 form of byte array.                
            </comment>
            <comment line="229">
                Signs the encapsulated object with the given signing key, using the
                 designated signature engine.
                
                 @param signingKey the private key for signing.
                 @param signingEngine the signature signing engine.
                
                 @exception InvalidKeyException if the key is invalid.
                 @exception SignatureException if signing fails.                
            </comment>
            <implements interface="Serializable"/>
            <javadoc line="30">
                &lt;p&gt; SignedObject is a class for the purpose of creating authentic
                  runtime objects whose integrity cannot be compromised without being
                  detected.
                  &lt;p&gt; More specifically, a SignedObject contains another Serializable
                  object, the (to-be-)signed object and its signature.
                  &lt;p&gt; The signed object is a &quot;deep copy&quot; (in serialized form) of an
                  original object.  Once the copy is made, further manipulation of
                  the original object has no side effect on the copy.
                  &lt;p&gt; The underlying signing algorithm is designated by the Signature
                  object passed to the constructor and the &lt;code&gt;verify&lt;/code&gt; method.
                  A typical usage for signing is the following:
                  &lt;p&gt; &lt;code&gt; &lt;pre&gt;
                  Signature signingEngine = Signature.getInstance(algorithm,
                  provider);
                  SignedObject so = new SignedObject(myobject, signingKey,
                  signingEngine);
                  &lt;/pre&gt; &lt;/code&gt;
                  &lt;p&gt; A typical usage for verification is the following (having
                  received SignedObject &lt;code&gt;so&lt;/code&gt;):
                  &lt;p&gt; &lt;code&gt; &lt;pre&gt;
                  Signature verificationEngine =
                  Signature.getInstance(algorithm, provider);
                  if (so.verify(publickey, verificationEngine))
                  try {
                  Object myobj = so.getObject();
                  } catch (java.lang.ClassNotFoundException e) {};
                  &lt;/pre&gt; &lt;/code&gt;
                  &lt;p&gt; Several points are worth noting.  First, there is no need to
                  initialize the signing or verification engine, as it will be
                  re-initialized inside the constructor and the &lt;code&gt;verify&lt;/code&gt;
                  method. Secondly, for verification to succeed, the specified
                  public key must be the public key corresponding to the private key
                  used to generate the SignedObject.
                  &lt;p&gt; More importantly, for flexibility reasons, the
                  constructor and &lt;code&gt;verify&lt;/code&gt; method allow for
                  customized signature engines, which can implement signature
                  algorithms that are not installed formally as part of a crypto
                  provider.  However, it is crucial that the programmer writing the
                  verifier code be aware what &lt;code&gt;Signature&lt;/code&gt; engine is being
                  used, as its own implementation of the &lt;code&gt;verify&lt;/code&gt; method
                  is invoked to verify a signature.  In other words, a malicious
                  &lt;code&gt;Signature&lt;/code&gt; may choose to always return true on
                  verification in an attempt to bypass a security check.
                  &lt;p&gt; The signature algorithm can be, among others, the NIST standard
                  DSA, using DSA and SHA-1.  The algorithm is specified using the
                  same convention as that for signatures. The DSA algorithm using the
                  SHA-1 message digest algorithm can be specified, for example, as
                  &quot;SHA/DSA&quot; or &quot;SHA-1/DSA&quot; (they are equivalent).  In the case of
                  RSA, there are multiple choices for the message digest algorithm,
                  so the signing algorithm could be specified as, for example,
                  &quot;MD2/RSA&quot;, &quot;MD5/RSA&quot; or &quot;SHA-1/RSA&quot;.  The algorithm name must be
                  specified, as there is no default.
                  &lt;p&gt; The name of the Cryptography Package Provider is designated
                  also by the Signature parameter to the constructor and the
                  &lt;code&gt;verify&lt;/code&gt; method.  If the provider is not
                  specified, the default provider is used.  Each installation can
                  be configured to use a particular provider as default.
                  &lt;p&gt; Potential applications of SignedObject include:
                  &lt;ul&gt;
                  &lt;li&gt; It can be used
                  internally to any Java runtime as an unforgeable authorization
                  token -- one that can be passed around without the fear that the
                  token can be maliciously modified without being detected.
                  &lt;li&gt; It
                  can be used to sign and serialize data/object for storage outside
                  the Java runtime (e.g., storing critical access control data on
                  disk).
                  &lt;li&gt; Nested SignedObjects can be used to construct a logical
                  sequence of signatures, resembling a chain of authorization and
                  delegation.
                  &lt;/ul&gt;                
                <see>
                    Signature                    
                </see>
                <author>
                    Li Gong                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="121"/>
            <declaration name="content" type="byte[]" line="129"/>
            <declaration name="signature" type="byte[]" line="130"/>
            <declaration name="thealgorithm" type="String" line="131"/>
            <javadoc line="133">
                Constructs a SignedObject from any Serializable object.
                  The given object is signed with the given signing key, using the
                  designated signature engine.                
                <param>
                    object the object to be signed.                    
                </param>
                <param>
                    signingKey the private key for signing.                    
                </param>
                <param>
                    signingEngine the signature signing engine.                    
                </param>
                <exception>
                    IOException if an error occurs during serialization                    
                </exception>
                <exception>
                    InvalidKeyException if the key is invalid.                    
                </exception>
                <exception>
                    SignatureException if signing fails.                    
                </exception>
            </javadoc>
            <method name="SignedObject" type="constructor" line="148">
                <params>
                    <param name="object" type="Serializable"/>
                    <param name="signingKey" type="PrivateKey"/>
                    <param name="signingEngine" type="Signature"/>
                </params>
                <comment line="150">
                    creating a stream pipe-line, from a to b                    
                </comment>
                <comment line="154">
                    write and flush the object content to byte array                    
                </comment>
                <comment line="161">
                    now sign the encapsulated object                    
                </comment>
                <declaration name="b" type="ByteArrayOutputStream" line="150"/>
                <declaration name="a" type="ObjectOutput" line="151"/>
            </method>
            <javadoc line="164">
                Retrieves the encapsulated object.
                  The encapsulated object is de-serialized before it is returned.                
                <return>
                    the encapsulated object.                    
                </return>
                <exception>
                    IOException if an error occurs during de-serialization                    
                </exception>
                <exception>
                    ClassNotFoundException if an error occurs during
                      de-serialization                    
                </exception>
            </javadoc>
            <method name="getObject" type="Object" line="176">
                <comment line="178">
                    creating a stream pipe-line, from b to a                    
                </comment>
                <declaration name="b" type="ByteArrayInputStream" line="178"/>
                <declaration name="a" type="ObjectInput" line="179"/>
                <declaration name="obj" type="Object" line="180"/>
            </method>
            <javadoc line="186">
                Retrieves the signature on the signed object, in the form of a
                  byte array.                
                <return>
                    the signature. Returns a new array each time this
                      method is called.                    
                </return>
            </javadoc>
            <method name="getSignature" type="byte[]" line="193"/>
            <javadoc line="197">
                Retrieves the name of the signature algorithm.                
                <return>
                    the signature algorithm name.                    
                </return>
            </javadoc>
            <method name="getAlgorithm" type="String" line="202"/>
            <javadoc line="206">
                Verifies that the signature in this SignedObject is the valid
                  signature for the object stored inside, with the given
                  verification key, using the designated verification engine.                
                <param>
                    verificationKey the public key for verification.                    
                </param>
                <param>
                    verificationEngine the signature verification engine.                    
                </param>
                <exception>
                    SignatureException if signature verification failed.                    
                </exception>
                <exception>
                    InvalidKeyException if the verification key is invalid.                    
                </exception>
                <return>
                    <tt>true</tt> if the signature
                      is valid, <tt>false</tt> otherwise                    
                </return>
            </javadoc>
            <method name="verify" type="boolean" line="222">
                <params>
                    <param name="verificationKey" type="PublicKey"/>
                    <param name="verificationEngine" type="Signature"/>
                </params>
            </method>
            <method name="sign" type="void" line="239">
                <params>
                    <param name="signingKey" type="PrivateKey"/>
                    <param name="signingEngine" type="Signature"/>
                </params>
                <comment line="241">
                    initialize the signing engine                    
                </comment>
            </method>
            <javadoc line="247">
                readObject is called to restore the state of the SignedObject from
                  a stream.                
            </javadoc>
            <method name="readObject" type="void" line="252">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <declaration name="fields" type="java.io.ObjectInputStream.GetField" line="253"/>
            </method>
        </class>
    </source>