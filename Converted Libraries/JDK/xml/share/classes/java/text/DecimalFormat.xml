<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.io.InvalidObjectException"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.math.BigDecimal"/>
        <import package="java.math.BigInteger"/>
        <import package="java.math.RoundingMode"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Currency"/>
        <import package="java.util.Locale"/>
        <import package="java.util.ResourceBundle"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.concurrent.ConcurrentMap"/>
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <import package="java.util.concurrent.atomic.AtomicLong"/>
        <import package="sun.util.resources.LocaleData"/>
        <class name="DecimalFormat" line="57">
            <extends class="NumberFormat"/>
            <comment line="468">
                Overrides                
            </comment>
            <comment line="2956">
                ----------------------------------------------------------------------                
            </comment>
            <comment line="2957">
                INSTANCE VARIABLES                
            </comment>
            <comment line="2958">
                ----------------------------------------------------------------------                
            </comment>
            <comment line="3063">
                invariant, &gt; 0 if useThousands                
            </comment>
            <comment line="3099">
                LIU new DecimalFormatSymbols();                
            </comment>
            <comment line="3108">
                Newly persistent in the Java 2 platform v.1.2                
            </comment>
            <comment line="3146">
                Newly persistent in the Java 2 platform v.1.2                
            </comment>
            <comment line="3204">
                ----------------------------------------------------------------------                
            </comment>
            <comment line="3233">
                ----------------------------------------------------------------------                
            </comment>
            <comment line="3234">
                CONSTANTS                
            </comment>
            <comment line="3235">
                ----------------------------------------------------------------------                
            </comment>
            <comment line="3237">
                Constants for characters used in programmatic (unlocalized) patterns.                
            </comment>
            <comment line="3263">
                Upper limit on integer and fraction digits for a Java double                
            </comment>
            <comment line="3267">
                Upper limit on integer and fraction digits for BigDecimal and BigInteger                
            </comment>
            <comment line="3271">
                Proclaim JDK 1.1 serial compatibility.                
            </comment>
            <javadoc line="57">
                &lt;code&gt;DecimalFormat&lt;/code&gt; is a concrete subclass of
                  &lt;code&gt;NumberFormat&lt;/code&gt; that formats decimal numbers. It has a variety of
                  features designed to make it possible to parse and format numbers in any
                  locale, including support for Western, Arabic, and Indic digits.  It also
                  supports different kinds of numbers, including integers (123), fixed-point
                  numbers (123.4), scientific notation (1.23E4), percentages (12%), and
                  currency amounts ($123).  All of these can be localized.
                  &lt;p&gt;To obtain a &lt;code&gt;NumberFormat&lt;/code&gt; for a specific locale, including the
                  default locale, call one of &lt;code&gt;NumberFormat&lt;/code&gt;&apos;s factory methods, such
                  as &lt;code&gt;getInstance()&lt;/code&gt;.  In general, do not call the
                  &lt;code&gt;DecimalFormat&lt;/code&gt; constructors directly, since the
                  &lt;code&gt;NumberFormat&lt;/code&gt; factory methods may return subclasses other than
                  &lt;code&gt;DecimalFormat&lt;/code&gt;. If you need to customize the format object, do
                  something like this:
                  &lt;blockquote&gt;&lt;pre&gt;
                  NumberFormat f = NumberFormat.getInstance(loc);
                  if (f instanceof DecimalFormat) {
                  ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; comprises a &lt;em&gt;pattern&lt;/em&gt; and a set of
                  &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
                  &lt;code&gt;applyPattern()&lt;/code&gt;, or indirectly using the API methods.  The
                  symbols are stored in a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  When using
                  the &lt;code&gt;NumberFormat&lt;/code&gt; factory methods, the pattern and symbols are
                  read from localized &lt;code&gt;ResourceBundle&lt;/code&gt;s.
                  &lt;h4&gt;Patterns&lt;/h4&gt;
                  &lt;code&gt;DecimalFormat&lt;/code&gt; patterns have the following syntax:
                  &lt;blockquote&gt;&lt;pre&gt;
                  &lt;i&gt;Pattern:&lt;/i&gt;
                  &lt;i&gt;PositivePattern&lt;/i&gt;
                  &lt;i&gt;PositivePattern&lt;/i&gt; ; &lt;i&gt;NegativePattern&lt;/i&gt;
                  &lt;i&gt;PositivePattern:&lt;/i&gt;
                  &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;NegativePattern:&lt;/i&gt;
                  &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;Prefix:&lt;/i&gt;
                  any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
                  &lt;i&gt;Suffix:&lt;/i&gt;
                  any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
                  &lt;i&gt;Number:&lt;/i&gt;
                  &lt;i&gt;Integer&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;Integer&lt;/i&gt; . &lt;i&gt;Fraction&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;Integer:&lt;/i&gt;
                  &lt;i&gt;MinimumInteger&lt;/i&gt;
                  #
                  # &lt;i&gt;Integer&lt;/i&gt;
                  # , &lt;i&gt;Integer&lt;/i&gt;
                  &lt;i&gt;MinimumInteger:&lt;/i&gt;
                  0
                  0 &lt;i&gt;MinimumInteger&lt;/i&gt;
                  0 , &lt;i&gt;MinimumInteger&lt;/i&gt;
                  &lt;i&gt;Fraction:&lt;/i&gt;
                  &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;MinimumFraction:&lt;/i&gt;
                  0 &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;OptionalFraction:&lt;/i&gt;
                  # &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;Exponent:&lt;/i&gt;
                  E &lt;i&gt;MinimumExponent&lt;/i&gt;
                  &lt;i&gt;MinimumExponent:&lt;/i&gt;
                  0 &lt;i&gt;MinimumExponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; pattern contains a positive and negative
                  subpattern, for example, &lt;code&gt;&quot;#,##0.00;(#,##0.00)&quot;&lt;/code&gt;.  Each
                  subpattern has a prefix, numeric part, and suffix. The negative subpattern
                  is optional; if absent, then the positive subpattern prefixed with the
                  localized minus sign (&lt;code&gt;&apos;-&apos;&lt;/code&gt; in most locales) is used as the
                  negative subpattern. That is, &lt;code&gt;&quot;0.00&quot;&lt;/code&gt; alone is equivalent to
                  &lt;code&gt;&quot;0.00;-0.00&quot;&lt;/code&gt;.  If there is an explicit negative subpattern, it
                  serves only to specify the negative prefix and suffix; the number of digits,
                  minimal digits, and other characteristics are all the same as the positive
                  pattern. That means that &lt;code&gt;&quot;#,##0.0#;(#)&quot;&lt;/code&gt; produces precisely
                  the same behavior as &lt;code&gt;&quot;#,##0.0#;(#,##0.0#)&quot;&lt;/code&gt;.
                  &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
                  thousands separators, decimal separators, etc. may be set to arbitrary
                  values, and they will appear properly during formatting.  However, care must
                  be taken that the symbols and strings do not conflict, or parsing will be
                  unreliable.  For example, either the positive and negative prefixes or the
                  suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able
                  to distinguish positive from negative values.  (If they are identical, then
                  &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was
                  specified.)  Another example is that the decimal separator and thousands
                  separator should be distinct characters, or parsing will be impossible.
                  &lt;p&gt;The grouping separator is commonly used for thousands, but in some
                  countries it separates ten-thousands. The grouping size is a constant number
                  of digits between the grouping characters, such as 3 for 100,000,000 or 4 for
                  1,0000,0000.  If you supply a pattern with multiple grouping characters, the
                  interval between the last one and the end of the integer is the one that is
                  used. So &lt;code&gt;&quot;#,##,###,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;######,####&quot;&lt;/code&gt; ==
                  &lt;code&gt;&quot;##,####,####&quot;&lt;/code&gt;.
                  &lt;h4&gt;Special Pattern Characters&lt;/h4&gt;
                  &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
                  parsing and output unchanged during formatting.  Special characters, on the
                  other hand, stand for other characters, strings, or classes of characters.
                  They must be quoted, unless noted otherwise, if they are to appear in the
                  prefix or suffix as literals.
                  &lt;p&gt;The characters listed here are used in non-localized patterns.  Localized
                  patterns use the corresponding characters taken from this formatter&apos;s
                  &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object instead, and these characters lose
                  their special status.  Two exceptions are the currency sign and quote, which
                  are not localized.
                  &lt;blockquote&gt;
                  &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Chart showing symbol,
                  location, localized, and meaning.&quot;&gt;
                  &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
                  &lt;th align=left&gt;Symbol
                  &lt;th align=left&gt;Location
                  &lt;th align=left&gt;Localized?
                  &lt;th align=left&gt;Meaning
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Digit
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;#&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Digit, zero shows as absent
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;.&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Decimal separator or monetary decimal separator
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;-&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Minus sign
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;,&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Grouping separator
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;E&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Separates mantissa and exponent in scientific notation.
                  &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;;&lt;/code&gt;
                  &lt;td&gt;Subpattern boundary
                  &lt;td&gt;Yes
                  &lt;td&gt;Separates positive and negative subpatterns
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;%&lt;/code&gt;
                  &lt;td&gt;Prefix or suffix
                  &lt;td&gt;Yes
                  &lt;td&gt;Multiply by 100 and show as percentage
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;&amp;#92;u2030&lt;/code&gt;
                  &lt;td&gt;Prefix or suffix
                  &lt;td&gt;Yes
                  &lt;td&gt;Multiply by 1000 and show as per mille value
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&amp;#164;&lt;/code&gt; (&lt;code&gt;&amp;#92;u00A4&lt;/code&gt;)
                  &lt;td&gt;Prefix or suffix
                  &lt;td&gt;No
                  &lt;td&gt;Currency sign, replaced by currency symbol.  If
                  doubled, replaced by international currency symbol.
                  If present in a pattern, the monetary decimal separator
                  is used instead of the decimal separator.
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;&apos;&lt;/code&gt;
                  &lt;td&gt;Prefix or suffix
                  &lt;td&gt;No
                  &lt;td&gt;Used to quote special characters in a prefix or suffix,
                  for example, &lt;code&gt;&quot;&apos;#&apos;#&quot;&lt;/code&gt; formats 123 to
                  &lt;code&gt;&quot;#123&quot;&lt;/code&gt;.  To create a single quote
                  itself, use two in a row: &lt;code&gt;&quot;# o&apos;&apos;clock&quot;&lt;/code&gt;.
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;h4&gt;Scientific Notation&lt;/h4&gt;
                  &lt;p&gt;Numbers in scientific notation are expressed as the product of a mantissa
                  and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The
                  mantissa is often in the range 1.0 &lt;= x &lt; 10.0, but it need not be.
                  &lt;code&gt;DecimalFormat&lt;/code&gt; can be instructed to format and parse scientific
                  notation &lt;em&gt;only via a pattern&lt;/em&gt;; there is currently no factory method
                  that creates a scientific notation format.  In a pattern, the exponent
                  character immediately followed by one or more digit characters indicates
                  scientific notation.  Example: &lt;code&gt;&quot;0.###E0&quot;&lt;/code&gt; formats the number
                  1234 as &lt;code&gt;&quot;1.234E3&quot;&lt;/code&gt;.
                  &lt;ul&gt;
                  &lt;li&gt;The number of digit characters after the exponent character gives the
                  minimum exponent digit count.  There is no maximum.  Negative exponents are
                  formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix
                  from the pattern.  This allows patterns such as &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt;.
                  &lt;li&gt;The minimum and maximum number of integer digits are interpreted
                  together:
                  &lt;ul&gt;
                  &lt;li&gt;If the maximum number of integer digits is greater than their minimum number
                  and greater than 1, it forces the exponent to be a multiple of the maximum
                  number of integer digits, and the minimum number of integer digits to be
                  interpreted as 1.  The most common use of this is to generate
                  &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three,
                  e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345
                  formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to
                  &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.
                  &lt;li&gt;Otherwise, the minimum number of integer digits is achieved by adjusting the
                  exponent.  Example: 0.00123 formatted with &lt;code&gt;&quot;00.###E0&quot;&lt;/code&gt; yields
                  &lt;code&gt;&quot;12.3E-4&quot;&lt;/code&gt;.
                  &lt;/ul&gt;
                  &lt;li&gt;The number of significant digits in the mantissa is the sum of the
                  &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is
                  unaffected by the maximum integer digits.  For example, 12345 formatted with
                  &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; is &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt;. To show all digits, set
                  the significant digits count to zero.  The number of significant digits
                  does not affect parsing.
                  &lt;li&gt;Exponential patterns may not contain grouping separators.
                  &lt;/ul&gt;
                  &lt;h4&gt;Rounding&lt;/h4&gt;
                  &lt;code&gt;DecimalFormat&lt;/code&gt; provides rounding modes defined in{@link java.math.RoundingMode} for formatting.  By default, it uses{@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
                  &lt;h4&gt;Digits&lt;/h4&gt;
                  For formatting, &lt;code&gt;DecimalFormat&lt;/code&gt; uses the ten consecutive
                  characters starting with the localized zero digit defined in the
                  &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object as digits. For parsing, these
                  digits as well as all Unicode decimal digits, as defined by{@link Character#digit Character.digit}, are recognized.
                  &lt;h4&gt;Special Values&lt;/h4&gt;
                  &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is formatted as a string, which typically has a single character
                  &lt;code&gt;&amp;#92;uFFFD&lt;/code&gt;.  This string is determined by the
                  &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  This is the only value for which
                  the prefixes and suffixes are not used.
                  &lt;p&gt;Infinity is formatted as a string, which typically has a single character
                  &lt;code&gt;&amp;#92;u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes
                  applied.  The infinity string is determined by the
                  &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.
                  &lt;p&gt;Negative zero (&lt;code&gt;&quot;-0&quot;&lt;/code&gt;) parses to
                  &lt;ul&gt;
                  &lt;li&gt;&lt;code&gt;BigDecimal(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is
                  true,
                  &lt;li&gt;&lt;code&gt;Long(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false
                  and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; is true,
                  &lt;li&gt;&lt;code&gt;Double(-0.0)&lt;/code&gt; if both &lt;code&gt;isParseBigDecimal()&lt;/code&gt;
                  and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; are false.
                  &lt;/ul&gt;
                  &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt;
                  Decimal formats are generally not synchronized.
                  It is recommended to create separate format instances for each thread.
                  If multiple threads access a format concurrently, it must be synchronized
                  externally.
                  &lt;h4&gt;Example&lt;/h4&gt;
                  &lt;blockquote&gt;&lt;pre&gt;
                  &lt;strong&gt;// Print out a number using the localized number, integer, currency,
                  // and percent format for each locale&lt;/strong&gt;
                  Locale[] locales = NumberFormat.getAvailableLocales();
                  double myNumber = -1234.56;
                  NumberFormat form;
                  for (int j=0; j&lt;4; ++j) {
                  System.out.println(&quot;FORMAT&quot;);
                  for (int i = 0; i &lt; locales.length; ++i) {
                  if (locales[i].getCountry().length() == 0) {
                  continue; // Skip language-only locales
                  }
                  System.out.print(locales[i].getDisplayName());
                  switch (j) {
                  case 0:
                  form = NumberFormat.getInstance(locales[i]); break;
                  case 1:
                  form = NumberFormat.getIntegerInstance(locales[i]); break;
                  case 2:
                  form = NumberFormat.getCurrencyInstance(locales[i]); break;
                  default:
                  form = NumberFormat.getPercentInstance(locales[i]); break;
                  }
                  if (form instanceof DecimalFormat) {
                  System.out.print(&quot;: &quot; + ((DecimalFormat) form).toPattern());
                  }
                  System.out.print(&quot; -&gt; &quot; + form.format(myNumber));
                  try {
                  System.out.println(&quot; -&gt; &quot; + form.parse(form.format(myNumber)));
                  } catch (ParseException e) {}
                  }
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <see>
                    <a href="http://java.sun.com/docs/books/tutorial/i18n/format/decimalFormat.html">Java Tutorial</a>                    
                </see>
                <see>
                    NumberFormat                    
                </see>
                <see>
                    DecimalFormatSymbols                    
                </see>
                <see>
                    ParsePosition                    
                </see>
                <author>
                    Mark Davis                    
                </author>
                <author>
                    Alan Liu                    
                </author>
            </javadoc>
            <javadoc line="380">
                Creates a DecimalFormat using the default pattern and symbols
                  for the default locale. This is a convenient way to obtain a
                  DecimalFormat when internationalization is not the main concern.
                  &lt;p&gt;
                  To obtain standard formats for a given locale, use the factory methods
                  on NumberFormat such as getNumberInstance. These factories will
                  return the most appropriate sub-class of NumberFormat for a given
                  locale.                
                <see>
                    java.text.NumberFormat#getInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getNumberInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getCurrencyInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getPercentInstance                    
                </see>
            </javadoc>
            <method name="DecimalFormat" type="constructor" line="395">
                <comment line="397">
                    try to get the pattern from the cache                    
                </comment>
                <comment line="399">
                                        
                </comment>
                <comment line="400">
                    Get the pattern for the default locale.                    
                </comment>
                <comment line="404">
                                        
                </comment>
                <comment line="408">
                    Always applyPattern after the symbols are set                    
                </comment>
                <declaration name="def" type="Locale" line="396"/>
                <declaration name="pattern" type="String" line="398"/>
                <scope line="399">
                    <declaration name="rb" type="ResourceBundle" line="401"/>
                    <declaration name="all" type="String[]" line="402"/>
                </scope>
            </method>
            <javadoc line="414">
                Creates a DecimalFormat using the given pattern and the symbols
                  for the default locale. This is a convenient way to obtain a
                  DecimalFormat when internationalization is not the main concern.
                  &lt;p&gt;
                  To obtain standard formats for a given locale, use the factory methods
                  on NumberFormat such as getNumberInstance. These factories will
                  return the most appropriate sub-class of NumberFormat for a given
                  locale.                
                <param>
                    pattern A non-localized pattern string.                    
                </param>
                <exception>
                    NullPointerException if <code>pattern</code> is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid.                    
                </exception>
                <see>
                    java.text.NumberFormat#getInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getNumberInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getCurrencyInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getPercentInstance                    
                </see>
            </javadoc>
            <method name="DecimalFormat" type="constructor" line="432">
                <params>
                    <param name="pattern" type="String"/>
                </params>
                <comment line="433">
                    Always applyPattern after the symbols are set                    
                </comment>
            </method>
            <javadoc line="439">
                Creates a DecimalFormat using the given pattern and symbols.
                  Use this constructor when you need to completely customize the
                  behavior of the format.
                  &lt;p&gt;
                  To obtain standard formats for a given
                  locale, use the factory methods on NumberFormat such as
                  getInstance or getCurrencyInstance. If you need only minor adjustments
                  to a standard format, you can modify the format returned by
                  a NumberFormat factory method.                
                <param>
                    pattern a non-localized pattern string                    
                </param>
                <param>
                    symbols the set of symbols to be used                    
                </param>
                <exception>
                    NullPointerException if any of the given arguments is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
                <see>
                    java.text.NumberFormat#getInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getNumberInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getCurrencyInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getPercentInstance                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols                    
                </see>
            </javadoc>
            <method name="DecimalFormat" type="constructor" line="460">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="symbols" type="DecimalFormatSymbols"/>
                </params>
                <comment line="461">
                    Always applyPattern after the symbols are set                    
                </comment>
            </method>
            <javadoc line="468">
                Formats a number and appends the resulting text to the given string
                  buffer.
                  The number can be of any subclass of {@link java.lang.Number}.
                  &lt;p&gt;
                  This implementation uses the maximum precision permitted.                
                <param>
                    number     the number to format                    
                </param>
                <param>
                    toAppendTo the <code>StringBuffer</code> to which the formatted
                      text is to be appended                    
                </param>
                <param>
                    pos        On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <return>
                    the value passed in as <code>toAppendTo</code>                    
                </return>
                <exception>
                    IllegalArgumentException if <code>number</code> is
                      null or not an instance of <code>Number</code>.                    
                </exception>
                <exception>
                    NullPointerException if <code>toAppendTo</code> or
                      <code>pos</code> is null                    
                </exception>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="490">
                <params>
                    <param name="number" type="Object"/>
                    <param name="toAppendTo" type="StringBuffer"/>
                    <param name="pos" type="FieldPosition"/>
                </params>
                <scope line="496"/>
                <scope line="498"/>
                <scope line="500"/>
                <scope line="502"/>
                <scope line="504"/>
            </method>
            <javadoc line="509">
                Formats a double to produce a string.                
                <param>
                    number    The double to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    fieldPosition    On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <return>
                    The formatted number string                    
                </return>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="521">
                <params>
                    <param name="number" type="double"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="fieldPosition" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="528">
                Formats a double to produce a string.                
                <param>
                    number    The double to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    delegate notified of locations of sub fields                    
                </param>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <return>
                    The formatted number string                    
                </return>
            </javadoc>
            <method name="format" type="StringBuffer" line="538">
                <params>
                    <param name="number" type="double"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                </params>
                <comment line="548">
                    Detecting whether a double is negative is easy with the exception of
                     the value -0.0.  This is a double which has a zero mantissa (and
                     exponent), but a negative sign bit.  It is semantically distinct from
                     a zero with a positive sign bit, and this distinction is important
                     to certain kinds of computations.  However, it&apos;s a little tricky to
                     detect, since (-0.0 == 0.0) and !(-0.0 &lt; 0.0).  How then, you may
                     ask, does it behave distinctly from +0.0?  Well, 1(-0.0) ==
                     -Infinity.  Proper detection of -0.0 is needed to deal with the
                     issues raised by bugs 4106658, 4106667, and 4147706.  Liu 7698.                    
                </comment>
                <comment line="593">
                    at this point we are guaranteed a nonnegative finite number.                    
                </comment>
                <scope line="540">
                    <declaration name="iFieldStart" type="int" line="541"/>
                </scope>
                <declaration name="isNegative" type="boolean" line="558"/>
                <scope line="560"/>
                <scope line="564">
                    <scope line="565"/>
                    <scope line="568"/>
                    <declaration name="iFieldStart" type="int" line="573"/>
                    <scope line="578"/>
                    <scope line="581"/>
                </scope>
                <scope line="589"/>
                <scope line="596">
                    <declaration name="maxIntDigits" type="int" line="597"/>
                    <declaration name="minIntDigits" type="int" line="598"/>
                    <declaration name="maxFraDigits" type="int" line="599"/>
                    <declaration name="minFraDigits" type="int" line="600"/>
                </scope>
            </method>
            <javadoc line="610">
                Format a long to produce a string.                
                <param>
                    number    The long to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    fieldPosition    On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <return>
                    The formatted number string                    
                </return>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="622">
                <params>
                    <param name="number" type="long"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="fieldPosition" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="629">
                Format a long to produce a string.                
                <param>
                    number    The long to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    delegate notified of locations of sub fields                    
                </param>
                <return>
                    The formatted number string                    
                </return>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="640">
                <params>
                    <param name="number" type="long"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                </params>
                <comment line="646">
                    In general, long values always represent real finite numbers, so                    
                </comment>
                <comment line="647">
                    we don&apos;t have to check for +/- Infinity or NaN.  However, there                    
                </comment>
                <comment line="648">
                    is one case we have to be careful of:  The multiplier can push                    
                </comment>
                <comment line="649">
                    a number near MIN_VALUE or MAX_VALUE outside the legal range.  We                    
                </comment>
                <comment line="650">
                    check for this before multiplying, and if it happens we use                    
                </comment>
                <comment line="651">
                    BigInteger instead.                    
                </comment>
                <comment line="653">
                    This can only happen if number == Long.MIN_VALUE.                    
                </comment>
                <declaration name="isNegative" type="boolean" line="641"/>
                <scope line="642"/>
                <declaration name="useBigInteger" type="boolean" line="652"/>
                <scope line="653">
                    <scope line="654"/>
                </scope>
                <scope line="657">
                    <declaration name="cutoff" type="long" line="658"/>
                    <scope line="659"/>
                </scope>
                <scope line="665">
                    <scope line="666"/>
                    <declaration name="bigIntegerValue" type="BigInteger" line="669"/>
                </scope>
                <scope line="674"/>
                <scope line="676">
                    <scope line="677"/>
                </scope>
                <scope line="683">
                    <declaration name="maxIntDigits" type="int" line="684"/>
                    <declaration name="minIntDigits" type="int" line="685"/>
                    <declaration name="maxFraDigits" type="int" line="686"/>
                    <declaration name="minFraDigits" type="int" line="687"/>
                </scope>
            </method>
            <javadoc line="697">
                Formats a BigDecimal to produce a string.                
                <param>
                    number    The BigDecimal to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    fieldPosition    On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <return>
                    The formatted number string                    
                </return>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="709">
                <params>
                    <param name="number" type="BigDecimal"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="fieldPosition" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="715">
                Formats a BigDecimal to produce a string.                
                <param>
                    number    The BigDecimal to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    delegate notified of locations of sub fields                    
                </param>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <return>
                    The formatted number string                    
                </return>
            </javadoc>
            <method name="format" type="StringBuffer" line="725">
                <params>
                    <param name="number" type="BigDecimal"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                </params>
                <scope line="726"/>
                <declaration name="isNegative" type="boolean" line="729"/>
                <scope line="730"/>
                <scope line="734">
                    <declaration name="maxIntDigits" type="int" line="735"/>
                    <declaration name="minIntDigits" type="int" line="736"/>
                    <declaration name="maxFraDigits" type="int" line="737"/>
                    <declaration name="minFraDigits" type="int" line="738"/>
                    <declaration name="maximumDigits" type="int" line="739"/>
                </scope>
            </method>
            <javadoc line="750">
                Format a BigInteger to produce a string.                
                <param>
                    number    The BigInteger to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    fieldPosition    On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <return>
                    The formatted number string                    
                </return>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="762">
                <params>
                    <param name="number" type="BigInteger"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="fieldPosition" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="769">
                Format a BigInteger to produce a string.                
                <param>
                    number    The BigInteger to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    delegate notified of locations of sub fields                    
                </param>
                <return>
                    The formatted number string                    
                </return>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="780">
                <params>
                    <param name="number" type="BigInteger"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                    <param name="formatLong" type="boolean"/>
                </params>
                <scope line="781"/>
                <declaration name="isNegative" type="boolean" line="784"/>
                <scope line="785"/>
                <scope line="789">
                    <declaration name="maxIntDigits" type="int" line="790"/>
                    <scope line="791"/>
                    <scope line="797">
                        <scope line="803"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="816">
                Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
                  You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
                  to build the resulting String, as well as to determine information
                  about the resulting String.
                  &lt;p&gt;
                  Each attribute key of the AttributedCharacterIterator will be of type
                  &lt;code&gt;NumberFormat.Field&lt;/code&gt;, with the attribute value being the
                  same as the attribute key.                
                <exception>
                    NullPointerException if obj is null.                    
                </exception>
                <exception>
                    IllegalArgumentException when the Format cannot format the
                      given object.                    
                </exception>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <param>
                    obj The object to format                    
                </param>
                <return>
                    AttributedCharacterIterator describing the formatted value.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="formatToCharacterIterator" type="AttributedCharacterIterator" line="835">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <declaration name="delegate" type="CharacterIteratorFieldDelegate" line="836"/>
                <declaration name="sb" type="StringBuffer" line="838"/>
                <scope line="840"/>
                <scope line="844"/>
                <scope line="846"/>
                <scope line="848"/>
                <scope line="850"/>
                <scope line="853"/>
            </method>
            <javadoc line="860">
                Complete the formatting of a finite number.  On entry, the digitList must
                  be filled in with the correct digits.                
            </javadoc>
            <method name="subformat" type="StringBuffer" line="867">
                <params>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                    <param name="isNegative" type="boolean"/>
                    <param name="isInteger" type="boolean"/>
                    <param name="maxIntDigits" type="int"/>
                    <param name="minIntDigits" type="int"/>
                    <param name="maxFraDigits" type="int"/>
                    <param name="minFraDigits" type="int"/>
                </params>
                <comment line="868">
                    NOTE: This isn&apos;t required anymore because DigitList takes care of this.                    
                </comment>
                <comment line="869">
                                        
                </comment>
                <comment line="870">
                    // The negative of the exponent represents the number of leading                    
                </comment>
                <comment line="871">
                    // zeros between the decimal and the first non-zero digit, for                    
                </comment>
                <comment line="872">
                    // a value &lt; 0.1 (e.g., for 0.00123, -fExponent == 2).  If this                    
                </comment>
                <comment line="873">
                    // is more than the maximum fraction digits, then we have an underflow                    
                </comment>
                <comment line="874">
                    // for the printed representation.  We recognize this here and set                    
                </comment>
                <comment line="875">
                    // the DigitList representation to zero in this situation.                    
                </comment>
                <comment line="876">
                                        
                </comment>
                <comment line="877">
                    if (-digitList.decimalAt &gt;= getMaximumFractionDigits())                    
                </comment>
                <comment line="878">
                    {                    
                </comment>
                <comment line="879">
                    digitList.count = 0;                    
                </comment>
                <comment line="880">
                    }                    
                </comment>
                <comment line="883">
                    &apos;0&apos; is the DigitList representation of zero                    
                </comment>
                <comment line="889">
                    Per bug 4147706, DecimalFormat must respect the sign of numbers which
                     format as zero.  This allows sensible computations and preserves
                     relations such as signum(1x) = signum(x), where x is +Infinity or
                     -Infinity.  Prior to this fix, we always formatted zero values as if
                     they were positive.  Liu 7698.                    
                </comment>
                <comment line="896">
                    Normalize                    
                </comment>
                <comment line="912">
                    Minimum integer digits are handled in exponential format by                    
                </comment>
                <comment line="913">
                    adjusting the exponent.  For example, 0.01234 with 3 minimum                    
                </comment>
                <comment line="914">
                    integer digits is &quot;123.4E-4&quot;.                    
                </comment>
                <comment line="916">
                    Maximum integer digits are interpreted as indicating the                    
                </comment>
                <comment line="917">
                    repeating range.  This is useful for engineering notation, in                    
                </comment>
                <comment line="918">
                    which the exponent is restricted to a multiple of 3.  For                    
                </comment>
                <comment line="919">
                    example, 0.01234 with 3 maximum integer digits is &quot;12.34e-3&quot;.                    
                </comment>
                <comment line="920">
                    If maximum integer digits are &gt; 1 and are larger than                    
                </comment>
                <comment line="921">
                    minimum integer digits, then minimum integer digits are                    
                </comment>
                <comment line="922">
                    ignored.                    
                </comment>
                <comment line="927">
                    A repeating range is defined; adjust to it as follows.                    
                </comment>
                <comment line="928">
                    If repeat == 3, we have 6,5,4=&gt;3; 3,2,1=&gt;0; 0,-1,-2=&gt;-3;                    
                </comment>
                <comment line="929">
                    -3,-4,-5=&gt;-6, etc. This takes into account that the                    
                </comment>
                <comment line="930">
                    exponent we have here is off by one from what we expect;                    
                </comment>
                <comment line="931">
                    it is for the format 0.MMMMMx10^n.                    
                </comment>
                <comment line="935">
                    integer division rounds towards 0                    
                </comment>
                <comment line="940">
                    No repeating range is defined; use minimum integer digits.                    
                </comment>
                <comment line="944">
                    We now output a minimum number of digits, and more if there                    
                </comment>
                <comment line="945">
                    are more digits, up to the maximum number of digits.  We                    
                </comment>
                <comment line="946">
                    place the decimal point after the &quot;integer&quot; digits, which                    
                </comment>
                <comment line="947">
                    are the first (decimalAt - exponent) digits.                    
                </comment>
                <comment line="949">
                    overflow?                    
                </comment>
                <comment line="953">
                    The number of integer digits is handled specially if the number                    
                </comment>
                <comment line="954">
                    is zero, since then there may be no digits.                    
                </comment>
                <comment line="968">
                    Record field information for caller.                    
                </comment>
                <comment line="974">
                    Record field information for caller.                    
                </comment>
                <comment line="983">
                    Record field information for caller.                    
                </comment>
                <comment line="989">
                    Record field information for caller.                    
                </comment>
                <comment line="993">
                    Record field information                    
                </comment>
                <comment line="1010">
                    The exponent is output using the pattern-specified minimum                    
                </comment>
                <comment line="1011">
                    exponent digits.  There is no maximum limit to the exponent                    
                </comment>
                <comment line="1012">
                    digits, since truncating the exponent would result in an                    
                </comment>
                <comment line="1013">
                    unacceptable inaccuracy.                    
                </comment>
                <comment line="1021">
                    For zero values, we force the exponent to zero.  We                    
                </comment>
                <comment line="1022">
                    must do this here, and not earlier, because the value                    
                </comment>
                <comment line="1023">
                    is used to determine integer digit count above.                    
                </comment>
                <comment line="1052">
                    Output the integer portion.  Here &apos;count&apos; is the total                    
                </comment>
                <comment line="1053">
                    number of integer digits we will display, including both                    
                </comment>
                <comment line="1054">
                    leading zeros required to satisfy getMinimumIntegerDigits,                    
                </comment>
                <comment line="1055">
                    and actual digits present in the number.                    
                </comment>
                <comment line="1057">
                    Index into digitList.fDigits[]                    
                </comment>
                <comment line="1062">
                    Handle the case where getMaximumIntegerDigits() is smaller                    
                </comment>
                <comment line="1063">
                    than the real number of integer digits.  If this is so, we                    
                </comment>
                <comment line="1064">
                    output the least significant max integer digits.  For example,                    
                </comment>
                <comment line="1065">
                    the value 1997 printed with 2 max integer digits is just &quot;97&quot;.                    
                </comment>
                <comment line="1074">
                    Output a real digit                    
                </comment>
                <comment line="1077">
                    Output a leading zero                    
                </comment>
                <comment line="1081">
                    Output grouping separator if necessary.  Don&apos;t output a                    
                </comment>
                <comment line="1082">
                    grouping separator if i==0 though; that&apos;s at the end of                    
                </comment>
                <comment line="1083">
                    the integer part.                    
                </comment>
                <comment line="1094">
                    Determine whether or not there are any printable fractional                    
                </comment>
                <comment line="1095">
                    digits.  If we&apos;ve used up the digits we know there aren&apos;t.                    
                </comment>
                <comment line="1099">
                    If there is no fraction present, and we haven&apos;t printed any                    
                </comment>
                <comment line="1100">
                    integer digits, then print a zero.  Otherwise we won&apos;t print                    
                </comment>
                <comment line="1101">
                    _any_ digits, and we won&apos;t be able to parse this string.                    
                </comment>
                <comment line="1109">
                    Output the decimal separator if we always do so.                    
                </comment>
                <comment line="1123">
                    Here is where we escape from the loop.  We escape if we&apos;ve                    
                </comment>
                <comment line="1124">
                    output the maximum fraction digits (specified in the for                    
                </comment>
                <comment line="1125">
                    expression above).                    
                </comment>
                <comment line="1126">
                    We also stop when we&apos;ve output the minimum digits and either:                    
                </comment>
                <comment line="1127">
                    we have an integer, so there is no fractional stuff to                    
                </comment>
                <comment line="1128">
                    display, or we&apos;re out of significant digits.                    
                </comment>
                <comment line="1134">
                    Output leading fractional zeros. These are zeros that come                    
                </comment>
                <comment line="1135">
                    after the decimal but before any significant digits. These                    
                </comment>
                <comment line="1136">
                    are only output if abs(number being formatted) &lt; 1.0.                    
                </comment>
                <comment line="1142">
                    Output a digit, if we have any precision left, or a                    
                </comment>
                <comment line="1143">
                    zero if we don&apos;t.  We don&apos;t want to output noise digits.                    
                </comment>
                <comment line="1151">
                    Record field information for caller.                    
                </comment>
                <declaration name="zero" type="char" line="882"/>
                <declaration name="zeroDelta" type="int" line="883"/>
                <declaration name="grouping" type="char" line="884"/>
                <declaration name="decimal" type="char" line="885"/>
                <scope line="895"/>
                <scope line="899"/>
                <scope line="902"/>
                <scope line="907">
                    <declaration name="iFieldStart" type="int" line="908"/>
                    <declaration name="iFieldEnd" type="int" line="909"/>
                    <declaration name="fFieldStart" type="int" line="910"/>
                    <declaration name="exponent" type="int" line="923"/>
                    <declaration name="repeat" type="int" line="924"/>
                    <declaration name="minimumIntegerDigits" type="int" line="925"/>
                    <scope line="926">
                        <scope line="932"/>
                        <scope line="934"/>
                    </scope>
                    <scope line="939"/>
                    <declaration name="minimumDigits" type="int" line="948"/>
                    <scope line="949"/>
                    <declaration name="integerDigits" type="int" line="955"/>
                    <scope line="957"/>
                    <declaration name="totalDigits" type="int" line="960"/>
                    <scope line="961"/>
                    <declaration name="addedDecimalSeparator" type="boolean" line="964"/>
                    <scope line="966">
                        <scope line="967"/>
                    </scope>
                    <scope line="982"/>
                    <scope line="994"/>
                    <scope line="999"/>
                    <scope line="1004"/>
                    <declaration name="fieldStart" type="int" line="1014"/>
                    <scope line="1024"/>
                    <declaration name="negativeExponent" type="boolean" line="1028"/>
                    <scope line="1029"/>
                    <declaration name="eFieldStart" type="int" line="1038"/>
                    <scope line="1040"/>
                    <scope line="1043"/>
                </scope>
                <scope line="1049">
                    <declaration name="iFieldStart" type="int" line="1050"/>
                    <declaration name="count" type="int" line="1056"/>
                    <declaration name="digitIndex" type="int" line="1057"/>
                    <scope line="1058"/>
                    <scope line="1066"/>
                    <declaration name="sizeBeforeIntegerPart" type="int" line="1071"/>
                    <scope line="1072">
                        <scope line="1073"/>
                        <scope line="1076"/>
                        <scope line="1085">
                            <declaration name="gStart" type="int" line="1086"/>
                        </scope>
                    </scope>
                    <declaration name="fractionPresent" type="boolean" line="1096"/>
                    <scope line="1102"/>
                    <declaration name="sStart" type="int" line="1110"/>
                    <scope line="1111"/>
                    <scope line="1115"/>
                    <declaration name="fFieldStart" type="int" line="1120"/>
                    <scope line="1122">
                        <scope line="1130"/>
                        <scope line="1137"/>
                        <scope line="1144"/>
                        <scope line="1146"/>
                    </scope>
                </scope>
                <scope line="1156"/>
                <scope line="1160"/>
            </method>
            <javadoc line="1168">
                Appends the String &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;result&lt;/code&gt;.
                  &lt;code&gt;delegate&lt;/code&gt; is notified of all  the
                  &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;.
                  &lt;p&gt;
                  If one of the &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;
                  identifies a &lt;code&gt;SIGN&lt;/code&gt; attribute, it is mapped to
                  &lt;code&gt;signAttribute&lt;/code&gt;. This is used
                  to map the &lt;code&gt;SIGN&lt;/code&gt; attribute to the &lt;code&gt;EXPONENT&lt;/code&gt;
                  attribute as necessary.
                  &lt;p&gt;
                  This is used by &lt;code&gt;subformat&lt;/code&gt; to add the prefix/suffix.                
            </javadoc>
            <method name="append" type="void" line="1184">
                <params>
                    <param name="result" type="StringBuffer"/>
                    <param name="string" type="String"/>
                    <param name="delegate" type="FieldDelegate"/>
                    <param name="positions" type="FieldPosition[]"/>
                    <param name="signAttribute" type="Format.Field"/>
                </params>
                <declaration name="start" type="int" line="1185"/>
                <scope line="1187">
                    <scope line="1190">
                        <declaration name="fp" type="FieldPosition" line="1191"/>
                        <declaration name="attribute" type="Format.Field" line="1192"/>
                        <scope line="1194"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1204">
                Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.
                  &lt;p&gt;
                  The method attempts to parse text starting at the index given by
                  &lt;code&gt;pos&lt;/code&gt;.
                  If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
                  to the index after the last character used (parsing does not necessarily
                  use all characters up to the end of the string), and the parsed
                  number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
                  indicate the starting point for the next call to this method.
                  If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
                  changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
                  the character where the error occurred, and null is returned.
                  &lt;p&gt;
                  The subclass returned depends on the value of {@link #isParseBigDecimal}as well as on the string being parsed.
                  &lt;ul&gt;
                  &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false (the default),
                  most integer values are returned as &lt;code&gt;Long&lt;/code&gt;
                  objects, no matter how they are written: &lt;code&gt;&quot;17&quot;&lt;/code&gt; and
                  &lt;code&gt;&quot;17.000&quot;&lt;/code&gt; both parse to &lt;code&gt;Long(17)&lt;/code&gt;.
                  Values that cannot fit into a &lt;code&gt;Long&lt;/code&gt; are returned as
                  &lt;code&gt;Double&lt;/code&gt;s. This includes values with a fractional part,
                  infinite values, &lt;code&gt;NaN&lt;/code&gt;, and the value -0.0.
                  &lt;code&gt;DecimalFormat&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; decide whether to
                  return a &lt;code&gt;Double&lt;/code&gt; or a &lt;code&gt;Long&lt;/code&gt; based on the
                  presence of a decimal separator in the source string. Doing so
                  would prevent integers that overflow the mantissa of a double,
                  such as &lt;code&gt;&quot;-9,223,372,036,854,775,808.00&quot;&lt;/code&gt;, from being
                  parsed accurately.
                  &lt;p&gt;
                  Callers may use the &lt;code&gt;Number&lt;/code&gt; methods
                  &lt;code&gt;doubleValue&lt;/code&gt;, &lt;code&gt;longValue&lt;/code&gt;, etc., to obtain
                  the type they want.
                  &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is true, values are returned
                  as &lt;code&gt;BigDecimal&lt;/code&gt; objects. The values are the ones
                  constructed by {@link java.math.BigDecimal#BigDecimal(String)}for corresponding strings in locale-independent format. The
                  special cases negative and positive infinity and NaN are returned
                  as &lt;code&gt;Double&lt;/code&gt; instances holding the values of the
                  corresponding &lt;code&gt;Double&lt;/code&gt; constants.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  &lt;code&gt;DecimalFormat&lt;/code&gt; parses all Unicode characters that represent
                  decimal digits, as defined by &lt;code&gt;Character.digit()&lt;/code&gt;. In
                  addition, &lt;code&gt;DecimalFormat&lt;/code&gt; also recognizes as digits the ten
                  consecutive characters starting with the localized zero digit defined in
                  the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.                
                <param>
                    text the string to be parsed                    
                </param>
                <param>
                    pos  A <code>ParsePosition</code> object with index and error
                      index information as described above.                    
                </param>
                <return>
                    the parsed value, or <code>null</code> if the parse fails                    
                </return>
                <exception>
                    NullPointerException if <code>text</code> or
                      <code>pos</code> is null.                    
                </exception>
            </javadoc>
            <method name="parse" type="Number" line="1260">
                <params>
                    <param name="text" type="String"/>
                    <param name="pos" type="ParsePosition"/>
                </params>
                <comment line="1261">
                    special case NaN                    
                </comment>
                <comment line="1272">
                    special case INFINITY                    
                </comment>
                <comment line="1298">
                    non-terminating decimal expansion                    
                </comment>
                <comment line="1313">
                    Finally, have DigitList parse the digits into a value.                    
                </comment>
                <comment line="1317">
                    got Long.MIN_VALUE                    
                </comment>
                <comment line="1324">
                    Divide by multiplier. We have to be careful here not to do                    
                </comment>
                <comment line="1325">
                    unneeded conversions between double and long.                    
                </comment>
                <comment line="1330">
                    Avoid converting to double if we can                    
                </comment>
                <comment line="1345">
                    At this point, if we divided the result by the multiplier, the                    
                </comment>
                <comment line="1346">
                    result may fit into a long.  We check for this case and return                    
                </comment>
                <comment line="1347">
                    a long if possible.                    
                </comment>
                <comment line="1348">
                    We must do this AFTER applying the negative (if appropriate)                    
                </comment>
                <comment line="1349">
                    in order to handle the case of LONG_MIN; otherwise, if we do                    
                </comment>
                <comment line="1350">
                    this with a positive value -LONG_MIN, the double is &gt; 0, but                    
                </comment>
                <comment line="1351">
                    the long is &lt; 0. We also must retain a double in the case of                    
                </comment>
                <comment line="1352">
                    -0.0, which will compare as == to a long 0 cast to a double                    
                </comment>
                <comment line="1353">
                    (bug 4162852).                    
                </comment>
                <scope line="1262"/>
                <declaration name="status" type="boolean[]" line="1267"/>
                <scope line="1268"/>
                <scope line="1273">
                    <scope line="1274"/>
                    <scope line="1276"/>
                </scope>
                <scope line="1281">
                    <scope line="1282"/>
                    <scope line="1284"/>
                    <scope line="1286"/>
                </scope>
                <scope line="1291">
                    <declaration name="bigDecimalResult" type="BigDecimal" line="1292"/>
                    <scope line="1294">
                        <scope line="1295"/>
                        <scope line="1298"/>
                    </scope>
                    <scope line="1303"/>
                </scope>
                <scope line="1307">
                    <declaration name="gotDouble" type="boolean" line="1308"/>
                    <declaration name="gotLongMinimum" type="boolean" line="1309"/>
                    <declaration name="doubleResult" type="double" line="1310"/>
                    <declaration name="longResult" type="long" line="1311"/>
                    <scope line="1314">
                        <scope line="1317"/>
                    </scope>
                    <scope line="1320"/>
                    <scope line="1326">
                        <scope line="1327"/>
                        <scope line="1329">
                            <scope line="1331"/>
                            <scope line="1333"/>
                        </scope>
                    </scope>
                    <scope line="1340"/>
                    <scope line="1354"/>
                </scope>
            </method>
            <javadoc line="1366">
                Return a BigInteger multiplier.                
            </javadoc>
            <method name="getBigIntegerMultiplier" type="BigInteger" line="1369">
                <scope line="1370"/>
            </method>
            <declaration name="bigIntegerMultiplier" type="BigInteger" line="1375"/>
            <javadoc line="1377">
                Return a BigDecimal multiplier.                
            </javadoc>
            <method name="getBigDecimalMultiplier" type="BigDecimal" line="1380">
                <scope line="1381"/>
            </method>
            <declaration name="bigDecimalMultiplier" type="BigDecimal" line="1386"/>
            <declaration name="STATUS_INFINITE" type="int" line="1388"/>
            <declaration name="STATUS_POSITIVE" type="int" line="1389"/>
            <declaration name="STATUS_LENGTH" type="int" line="1390"/>
            <javadoc line="1392">
                Parse the given text into a number.  The text is parsed beginning at
                  parsePosition, until an unparseable character is seen.                
                <param>
                    text The string to parse.                    
                </param>
                <param>
                    parsePosition The position at which to being parsing.  Upon
                      return, the first unparseable character.                    
                </param>
                <param>
                    digits The DigitList to set to the parsed value.                    
                </param>
                <param>
                    isExponent If true, parse an exponent.  This means no
                      infinite values and integer only.                    
                </param>
                <param>
                    status Upon return contains boolean status flags indicating
                      whether the value was infinite and whether it was positive.                    
                </param>
            </javadoc>
            <method name="subparse" type="boolean" line="1407">
                <params>
                    <param name="text" type="String"/>
                    <param name="parsePosition" type="ParsePosition"/>
                    <param name="positivePrefix" type="String"/>
                    <param name="negativePrefix" type="String"/>
                    <param name="digits" type="DigitList"/>
                    <param name="isExponent" type="boolean"/>
                    <param name="status" type="boolean"/>
                </params>
                <comment line="1413">
                    check for positivePrefix; take longest                    
                </comment>
                <comment line="1436">
                    process digits or Inf, find decimal position                    
                </comment>
                <comment line="1443">
                    We now have a string of digits, possibly with grouping symbols,                    
                </comment>
                <comment line="1444">
                    and decimal points.  We want to process these into a DigitList.                    
                </comment>
                <comment line="1445">
                    We don&apos;t want to put a bunch of leading zeros into the DigitList                    
                </comment>
                <comment line="1446">
                    though, so we keep track of the location of the decimal point,                    
                </comment>
                <comment line="1447">
                    put only significant digits into the DigitList, and adjust the                    
                </comment>
                <comment line="1448">
                    exponent as needed.                    
                </comment>
                <comment line="1460">
                    Set to the exponent value, if any                    
                </comment>
                <comment line="1462">
                    We have to track digitCount ourselves, because digits.count will                    
                </comment>
                <comment line="1463">
                    pin when the maximum allowable digits is reached.                    
                </comment>
                <comment line="1470">
                    We recognize all digit ranges, not only the Latin digit range
                     &apos;0&apos;..&apos;9&apos;.  We do so by using the Character.digit() method,
                     which converts a valid Unicode digit to the range 0..9.
                    
                     The character &apos;ch&apos; may be a digit.  If so, place its value
                     from 0 to 9 in &apos;digit&apos;.  First try using the locale digit,
                     which may or MAY NOT be a standard Unicode digit range.  If
                     this fails, try using the standard Unicode digit ranges by
                     calling Character.digit().  If this also fails, digit will
                     have a value outside the range 0..9.                    
                </comment>
                <comment line="1487">
                    Cancel out backup setting (see grouping handler below)                    
                </comment>
                <comment line="1488">
                    Do this BEFORE continue statement below!!!                    
                </comment>
                <comment line="1491">
                    Handle leading zeros                    
                </comment>
                <comment line="1493">
                    Ignore leading zeros in integer part of number.                    
                </comment>
                <comment line="1498">
                    If we have seen the decimal, but no significant                    
                </comment>
                <comment line="1499">
                    digits yet, then we account for leading zeros by                    
                </comment>
                <comment line="1500">
                    decrementing the digits.decimalAt into negative                    
                </comment>
                <comment line="1501">
                    values.                    
                </comment>
                <comment line="1507">
                    [sic] digit==0 handled above                    
                </comment>
                <comment line="1512">
                    Cancel out backup setting (see grouping handler below)                    
                </comment>
                <comment line="1515">
                    If we&apos;re only parsing integers, or if we ALREADY saw the                    
                </comment>
                <comment line="1516">
                    decimal, then don&apos;t parse this one.                    
                </comment>
                <comment line="1520">
                    Not digits.count!                    
                </comment>
                <comment line="1526">
                    Ignore grouping characters, if we are using them, but                    
                </comment>
                <comment line="1527">
                    require that they be followed by a digit.  Otherwise                    
                </comment>
                <comment line="1528">
                    we backup and reprocess them.                    
                </comment>
                <comment line="1532">
                    Process the exponent by recursively calling this method.                    
                </comment>
                <comment line="1539">
                    Advance past the exponent                    
                </comment>
                <comment line="1546">
                    Whether we fail or succeed, we exit this loop                    
                </comment>
                <comment line="1557">
                    If there was no decimal point we have an integer                    
                </comment>
                <comment line="1559">
                    Not digits.count!                    
                </comment>
                <comment line="1562">
                    Adjust for exponent, if any                    
                </comment>
                <comment line="1565">
                    If none of the text string was recognized.  For example, parse                    
                </comment>
                <comment line="1566">
                    &quot;x&quot; with pattern &quot;#0.00&quot; (return index and error index both 0)                    
                </comment>
                <comment line="1567">
                    parse &quot;$&quot; with pattern &quot;$#0.00&quot;. (return index 0 and error                    
                </comment>
                <comment line="1568">
                    index 1).                    
                </comment>
                <comment line="1576">
                    check for suffix                    
                </comment>
                <comment line="1587">
                    if both match, take longest                    
                </comment>
                <comment line="1596">
                    fail if neither or both                    
                </comment>
                <comment line="1603">
                    mark success!                    
                </comment>
                <declaration name="position" type="int" line="1408"/>
                <declaration name="oldStart" type="int" line="1409"/>
                <declaration name="backup" type="int" line="1410"/>
                <declaration name="gotPositive" type="boolean" line="1411"/>
                <scope line="1419">
                    <scope line="1420"/>
                    <scope line="1422"/>
                </scope>
                <scope line="1427"/>
                <scope line="1429"/>
                <scope line="1431"/>
                <scope line="1439"/>
                <scope line="1442">
                    <declaration name="zero" type="char" line="1451"/>
                    <declaration name="decimal" type="char" line="1452"/>
                    <declaration name="grouping" type="char" line="1455"/>
                    <declaration name="exponentString" type="String" line="1456"/>
                    <declaration name="sawDecimal" type="boolean" line="1457"/>
                    <declaration name="sawExponent" type="boolean" line="1458"/>
                    <declaration name="sawDigit" type="boolean" line="1459"/>
                    <declaration name="exponent" type="int" line="1460"/>
                    <declaration name="digitCount" type="int" line="1464"/>
                    <scope line="1467">
                        <declaration name="ch" type="char" line="1468"/>
                        <declaration name="digit" type="int" line="1481"/>
                        <scope line="1482"/>
                        <scope line="1486">
                            <scope line="1492">
                                <scope line="1494"/>
                            </scope>
                            <scope line="1503"/>
                        </scope>
                        <scope line="1507"/>
                        <scope line="1514">
                            <scope line="1517"/>
                        </scope>
                        <scope line="1522">
                            <scope line="1523"/>
                        </scope>
                        <scope line="1531">
                            <declaration name="pos" type="ParsePosition" line="1533"/>
                            <declaration name="stat" type="boolean[]" line="1534"/>
                            <declaration name="exponentDigits" type="DigitList" line="1535"/>
                            <scope line="1538">
                                <scope line="1541"/>
                            </scope>
                        </scope>
                        <scope line="1548"/>
                    </scope>
                    <scope line="1553"/>
                    <scope line="1558"/>
                    <scope line="1569"/>
                </scope>
                <scope line="1577">
                    <scope line="1578"/>
                    <scope line="1582"/>
                    <scope line="1588">
                        <scope line="1589"/>
                        <scope line="1591"/>
                    </scope>
                    <scope line="1597"/>
                </scope>
                <scope line="1604"/>
                <scope line="1609"/>
            </method>
            <javadoc line="1616">
                Returns a copy of the decimal format symbols, which is generally not
                  changed by the programmer or user.                
                <return>
                    a copy of the desired DecimalFormatSymbols                    
                </return>
                <see>
                    java.text.DecimalFormatSymbols                    
                </see>
            </javadoc>
            <method name="getDecimalFormatSymbols" type="DecimalFormatSymbols" line="1622">
                <comment line="1624">
                    don&apos;t allow multiple references                    
                </comment>
                <comment line="1627">
                    should never happen                    
                </comment>
                <scope line="1623"/>
                <scope line="1626"/>
            </method>
            <javadoc line="1632">
                Sets the decimal format symbols, which is generally not changed
                  by the programmer or user.                
                <param>
                    newSymbols desired DecimalFormatSymbols                    
                </param>
                <see>
                    java.text.DecimalFormatSymbols                    
                </see>
            </javadoc>
            <method name="setDecimalFormatSymbols" type="void" line="1638">
                <params>
                    <param name="newSymbols" type="DecimalFormatSymbols"/>
                </params>
                <comment line="1640">
                    don&apos;t allow multiple references                    
                </comment>
                <comment line="1644">
                    should never happen                    
                </comment>
                <scope line="1639"/>
                <scope line="1643"/>
            </method>
            <javadoc line="1648">
                Get the positive prefix.
                  &lt;P&gt;Examples: +123, $123, sFr123                
            </javadoc>
            <method name="getPositivePrefix" type="String" line="1652"/>
            <javadoc line="1656">
                Set the positive prefix.
                  &lt;P&gt;Examples: +123, $123, sFr123                
            </javadoc>
            <method name="setPositivePrefix" type="void" line="1660">
                <params>
                    <param name="newValue" type="String"/>
                </params>
            </method>
            <javadoc line="1666">
                Returns the FieldPositions of the fields in the prefix used for
                  positive numbers. This is not used if the user has explicitly set
                  a positive prefix via &lt;code&gt;setPositivePrefix&lt;/code&gt;. This is
                  lazily created.                
                <return>
                    FieldPositions in positive prefix                    
                </return>
            </javadoc>
            <method name="getPositivePrefixFieldPositions" type="FieldPosition[]" line="1674">
                <scope line="1675">
                    <scope line="1676"/>
                    <scope line="1679"/>
                </scope>
            </method>
            <javadoc line="1686">
                Get the negative prefix.
                  &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123                
            </javadoc>
            <method name="getNegativePrefix" type="String" line="1690"/>
            <javadoc line="1694">
                Set the negative prefix.
                  &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123                
            </javadoc>
            <method name="setNegativePrefix" type="void" line="1698">
                <params>
                    <param name="newValue" type="String"/>
                </params>
            </method>
            <javadoc line="1703">
                Returns the FieldPositions of the fields in the prefix used for
                  negative numbers. This is not used if the user has explicitly set
                  a negative prefix via &lt;code&gt;setNegativePrefix&lt;/code&gt;. This is
                  lazily created.                
                <return>
                    FieldPositions in positive prefix                    
                </return>
            </javadoc>
            <method name="getNegativePrefixFieldPositions" type="FieldPosition[]" line="1711">
                <scope line="1712">
                    <scope line="1713"/>
                    <scope line="1716"/>
                </scope>
            </method>
            <javadoc line="1723">
                Get the positive suffix.
                  &lt;P&gt;Example: 123%                
            </javadoc>
            <method name="getPositiveSuffix" type="String" line="1727"/>
            <javadoc line="1731">
                Set the positive suffix.
                  &lt;P&gt;Example: 123%                
            </javadoc>
            <method name="setPositiveSuffix" type="void" line="1735">
                <params>
                    <param name="newValue" type="String"/>
                </params>
            </method>
            <javadoc line="1740">
                Returns the FieldPositions of the fields in the suffix used for
                  positive numbers. This is not used if the user has explicitly set
                  a positive suffix via &lt;code&gt;setPositiveSuffix&lt;/code&gt;. This is
                  lazily created.                
                <return>
                    FieldPositions in positive prefix                    
                </return>
            </javadoc>
            <method name="getPositiveSuffixFieldPositions" type="FieldPosition[]" line="1748">
                <scope line="1749">
                    <scope line="1750"/>
                    <scope line="1753"/>
                </scope>
            </method>
            <javadoc line="1760">
                Get the negative suffix.
                  &lt;P&gt;Examples: -123%, ($123) (with positive suffixes)                
            </javadoc>
            <method name="getNegativeSuffix" type="String" line="1764"/>
            <javadoc line="1768">
                Set the negative suffix.
                  &lt;P&gt;Examples: 123%                
            </javadoc>
            <method name="setNegativeSuffix" type="void" line="1772">
                <params>
                    <param name="newValue" type="String"/>
                </params>
            </method>
            <javadoc line="1777">
                Returns the FieldPositions of the fields in the suffix used for
                  negative numbers. This is not used if the user has explicitly set
                  a negative suffix via &lt;code&gt;setNegativeSuffix&lt;/code&gt;. This is
                  lazily created.                
                <return>
                    FieldPositions in positive prefix                    
                </return>
            </javadoc>
            <method name="getNegativeSuffixFieldPositions" type="FieldPosition[]" line="1785">
                <scope line="1786">
                    <scope line="1787"/>
                    <scope line="1790"/>
                </scope>
            </method>
            <javadoc line="1797">
                Gets the multiplier for use in percent, per mille, and similar
                  formats.                
                <see>
                    #setMultiplier(int)                    
                </see>
            </javadoc>
            <method name="getMultiplier" type="int" line="1803"/>
            <javadoc line="1807">
                Sets the multiplier for use in percent, per mille, and similar
                  formats.
                  For a percent format, set the multiplier to 100 and the suffixes to
                  have &apos;%&apos; (for Arabic, use the Arabic percent sign).
                  For a per mille format, set the multiplier to 1000 and the suffixes to
                  have &apos;&amp;#92;u2030&apos;.
                  &lt;P&gt;Example: with multiplier 100, 1.23 is formatted as &quot;123&quot;, and
                  &quot;123&quot; is parsed into 1.23.                
                <see>
                    #getMultiplier                    
                </see>
            </javadoc>
            <method name="setMultiplier" type="void" line="1820">
                <params>
                    <param name="newValue" type="int"/>
                </params>
            </method>
            <javadoc line="1826">
                Return the grouping size. Grouping size is the number of digits between
                  grouping separators in the integer portion of a number.  For example,
                  in the number &quot;123,456.78&quot;, the grouping size is 3.                
                <see>
                    #setGroupingSize                    
                </see>
                <see>
                    java.text.NumberFormat#isGroupingUsed                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols#getGroupingSeparator                    
                </see>
            </javadoc>
            <method name="getGroupingSize" type="int" line="1834"/>
            <javadoc line="1838">
                Set the grouping size. Grouping size is the number of digits between
                  grouping separators in the integer portion of a number.  For example,
                  in the number &quot;123,456.78&quot;, the grouping size is 3.
                  &lt;br&gt;
                  The value passed in is converted to a byte, which may lose information.                
                <see>
                    #getGroupingSize                    
                </see>
                <see>
                    java.text.NumberFormat#setGroupingUsed                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols#setGroupingSeparator                    
                </see>
            </javadoc>
            <method name="setGroupingSize" type="void" line="1848">
                <params>
                    <param name="newValue" type="int"/>
                </params>
            </method>
            <javadoc line="1852">
                Allows you to get the behavior of the decimal separator with integers.
                  (The decimal separator will always appear with decimals.)
                  &lt;P&gt;Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345                
            </javadoc>
            <method name="isDecimalSeparatorAlwaysShown" type="boolean" line="1857"/>
            <javadoc line="1861">
                Allows you to set the behavior of the decimal separator with integers.
                  (The decimal separator will always appear with decimals.)
                  &lt;P&gt;Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345                
            </javadoc>
            <method name="setDecimalSeparatorAlwaysShown" type="void" line="1866">
                <params>
                    <param name="newValue" type="boolean"/>
                </params>
            </method>
            <javadoc line="1870">
                Returns whether the {@link #parse(java.lang.String,java.text.ParsePosition)}method returns &lt;code&gt;BigDecimal&lt;/code&gt;. The default value is false.                
                <see>
                    #setParseBigDecimal                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isParseBigDecimal" type="boolean" line="1876"/>
            <javadoc line="1880">
                Sets whether the {@link #parse(java.lang.String,java.text.ParsePosition)}method returns &lt;code&gt;BigDecimal&lt;/code&gt;.                
                <see>
                    #isParseBigDecimal                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setParseBigDecimal" type="void" line="1886">
                <params>
                    <param name="newValue" type="boolean"/>
                </params>
            </method>
            <javadoc line="1890">
                Standard override; no change in semantics.                
            </javadoc>
            <method name="clone" type="Object" line="1893">
                <scope line="1894">
                    <declaration name="other" type="DecimalFormat" line="1895"/>
                </scope>
                <scope line="1899"/>
            </method>
            <javadoc line="1904">
                Overrides equals                
            </javadoc>
            <method name="equals" type="boolean" line="1908">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="1910">
                    super does class check                    
                </comment>
                <declaration name="other" type="DecimalFormat" line="1911"/>
            </method>
            <javadoc line="1943">
                Overrides hashCode                
            </javadoc>
            <method name="hashCode" type="int" line="1946">
                <comment line="1948">
                    just enough fields for a reasonable distribution                    
                </comment>
            </method>
            <javadoc line="1951">
                Synthesizes a pattern string that represents the current state
                  of this Format object.                
                <see>
                    #applyPattern                    
                </see>
            </javadoc>
            <method name="toPattern" type="String" line="1956"/>
            <javadoc line="1960">
                Synthesizes a localized pattern string that represents the current
                  state of this Format object.                
                <see>
                    #applyPattern                    
                </see>
            </javadoc>
            <method name="toLocalizedPattern" type="String" line="1965"/>
            <javadoc line="1969">
                Expand the affix pattern strings into the expanded affix strings.  If any
                  affix pattern string is null, do not expand it.  This method should be
                  called any time the symbols or the affix patterns change in order to keep
                  the expanded affix strings up to date.                
            </javadoc>
            <method name="expandAffixes" type="void" line="1975">
                <comment line="1976">
                    Reuse one StringBuffer for better performance                    
                </comment>
                <declaration name="buffer" type="StringBuffer" line="1977"/>
                <scope line="1978"/>
                <scope line="1982"/>
                <scope line="1986"/>
                <scope line="1990"/>
            </method>
            <javadoc line="1996">
                Expand an affix pattern into an affix string.  All characters in the
                  pattern are literal unless prefixed by QUOTE.  The following characters
                  after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
                  PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
                  CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
                  currency code.  Any other character after a QUOTE represents itself.
                  QUOTE must be followed by another character; QUOTE may not occur by
                  itself at the end of the pattern.                
                <param>
                    pattern the non-null, possibly empty pattern                    
                </param>
                <param>
                    buffer a scratch StringBuffer; its contents will be lost                    
                </param>
                <return>
                    the expanded equivalent of pattern                    
                </return>
            </javadoc>
            <method name="expandAffix" type="String" line="2010">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="buffer" type="StringBuffer"/>
                </params>
                <scope line="2012">
                    <declaration name="c" type="char" line="2013"/>
                    <scope line="2014">
                        <scope line="2019"/>
                        <scope line="2022"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2042">
                Expand an affix pattern into an array of FieldPositions describing
                  how the pattern would be expanded.
                  All characters in the
                  pattern are literal unless prefixed by QUOTE.  The following characters
                  after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
                  PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
                  CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
                  currency code.  Any other character after a QUOTE represents itself.
                  QUOTE must be followed by another character; QUOTE may not occur by
                  itself at the end of the pattern.                
                <param>
                    pattern the non-null, possibly empty pattern                    
                </param>
                <return>
                    FieldPosition array of the resulting fields.                    
                </return>
            </javadoc>
            <method name="expandAffix" type="FieldPosition[]" line="2057">
                <params>
                    <param name="pattern" type="String"/>
                </params>
                <declaration name="positions" type="ArrayList" line="2058"/>
                <declaration name="stringIndex" type="int" line="2059"/>
                <scope line="2060">
                    <declaration name="c" type="char" line="2061"/>
                    <scope line="2062">
                        <declaration name="field" type="int" line="2063"/>
                        <declaration name="fieldID" type="Format.Field" line="2064"/>
                        <declaration name="string" type="String" line="2068"/>
                        <scope line="2070"/>
                        <scope line="2073"/>
                        <scope line="2076">
                            <scope line="2077"/>
                            <declaration name="fp" type="FieldPosition" line="2080"/>
                        </scope>
                        <scope line="2103">
                            <scope line="2104"/>
                            <declaration name="fp" type="FieldPosition" line="2107"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2115"/>
            </method>
            <javadoc line="2121">
                Appends an affix pattern to the given StringBuffer, quoting special
                  characters as needed.  Uses the internal affix pattern, if that exists,
                  or the literal affix, if the internal affix pattern is null.  The
                  appended string will generate the same affix pattern (or literal affix)
                  when passed to toPattern().                
                <param>
                    buffer the affix string is appended to this                    
                </param>
                <param>
                    affixPattern a pattern such as posPrefixPattern; may be null                    
                </param>
                <param>
                    expAffix a corresponding expanded affix, such as positivePrefix.
                      Ignored unless affixPattern is null.  If affixPattern is null, then
                      expAffix is appended as a literal affix.                    
                </param>
                <param>
                    localized true if the appended pattern should contain localized
                      pattern characters; otherwise, non-localized pattern chars are appended                    
                </param>
            </javadoc>
            <method name="appendAffix" type="void" line="2137">
                <params>
                    <param name="buffer" type="StringBuffer"/>
                    <param name="affixPattern" type="String"/>
                    <param name="expAffix" type="String"/>
                    <param name="localized" type="boolean"/>
                </params>
                <comment line="2155">
                    Fall through and append another QUOTE below                    
                </comment>
                <comment line="2161">
                    Fall through and append another CURRENCY_SIGN below                    
                </comment>
                <scope line="2138"/>
                <scope line="2140">
                    <declaration name="i" type="int" line="2141"/>
                    <scope line="2142">
                        <scope line="2144"/>
                        <scope line="2148"/>
                        <declaration name="c" type="char" line="2151"/>
                        <scope line="2153"/>
                        <scope line="2158"/>
                        <scope line="2162"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2180">
                Append an affix to the given StringBuffer, using quotes if
                  there are special characters.  Single quotes themselves must be
                  escaped in either case.                
            </javadoc>
            <method name="appendAffix" type="void" line="2185">
                <params>
                    <param name="buffer" type="StringBuffer"/>
                    <param name="affix" type="String"/>
                    <param name="localized" type="boolean"/>
                </params>
                <declaration name="needQuote" type="boolean" line="2186"/>
                <scope line="2187"/>
                <scope line="2198"/>
                <scope line="2211">
                    <scope line="2212">
                        <declaration name="c" type="char" line="2213"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2221">
                Does the real work of generating a pattern.                
            </javadoc>
            <method name="toPattern" type="String" line="2223">
                <params>
                    <param name="localized" type="boolean"/>
                </params>
                <comment line="2265">
                    n == p == null                    
                </comment>
                <comment line="2271">
                    n == p == null                    
                </comment>
                <declaration name="result" type="StringBuffer" line="2224"/>
                <scope line="2225">
                    <declaration name="i" type="int" line="2229"/>
                    <declaration name="digitCount" type="int" line="2230"/>
                    <scope line="2233">
                        <scope line="2235"/>
                    </scope>
                    <scope line="2246">
                        <scope line="2247"/>
                        <scope line="2250"/>
                    </scope>
                    <scope line="2256"/>
                    <scope line="2263">
                        <scope line="2268"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2282">
                Apply the given pattern to this Format object.  A pattern is a
                  short-hand specification for the various formatting properties.
                  These properties can also be changed individually through the
                  various setter methods.
                  &lt;p&gt;
                  There is no limit to integer digits set
                  by this routine, since that is the typical end-user desire;
                  use setMaximumInteger if you want to set a real value.
                  For negative numbers, use a second pattern, separated by a semicolon
                  &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; -&gt; 1,234.56
                  &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
                  a maximum of 2 fraction digits.
                  &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in
                  parentheses.
                  &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
                  these are presumed to be set in the positive pattern.                
                <exception>
                    NullPointerException if <code>pattern</code> is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid.                    
                </exception>
            </javadoc>
            <method name="applyPattern" type="void" line="2303">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="2307">
                Apply the given pattern to this Format object.  The pattern
                  is assumed to be in a localized notation. A pattern is a
                  short-hand specification for the various formatting properties.
                  These properties can also be changed individually through the
                  various setter methods.
                  &lt;p&gt;
                  There is no limit to integer digits set
                  by this routine, since that is the typical end-user desire;
                  use setMaximumInteger if you want to set a real value.
                  For negative numbers, use a second pattern, separated by a semicolon
                  &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; -&gt; 1,234.56
                  &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
                  a maximum of 2 fraction digits.
                  &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in
                  parentheses.
                  &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
                  these are presumed to be set in the positive pattern.                
                <exception>
                    NullPointerException if <code>pattern</code> is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid.                    
                </exception>
            </javadoc>
            <method name="applyLocalizedPattern" type="void" line="2329">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="2333">
                Does the real work of applying a pattern.                
            </javadoc>
            <method name="applyPattern" type="void" line="2336">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="localized" type="boolean"/>
                </params>
                <comment line="2362">
                    Two variables are used to record the subrange of the pattern                    
                </comment>
                <comment line="2363">
                    occupied by phase 1.  This is used during the processing of the                    
                </comment>
                <comment line="2364">
                    second pattern (the one representing negative numbers) to ensure                    
                </comment>
                <comment line="2365">
                    that no deviation exists in phase 1 between the two patterns.                    
                </comment>
                <comment line="2379">
                    The phase ranges from 0 to 2.  Phase 0 is the prefix.  Phase 1 is                    
                </comment>
                <comment line="2380">
                    the section of the pattern with digits, decimal separator,                    
                </comment>
                <comment line="2381">
                    grouping characters.  Phase 2 is the suffix.  In phases 0 and 2,                    
                </comment>
                <comment line="2382">
                    percent, per mille, and currency symbols are recognized and                    
                </comment>
                <comment line="2383">
                    translated.  The separation of the characters into phases is                    
                </comment>
                <comment line="2384">
                    strictly enforced; if phase 1 characters are to appear in the                    
                </comment>
                <comment line="2385">
                    suffix, for example, they must be quoted.                    
                </comment>
                <comment line="2388">
                    The affix is either the prefix or the suffix.                    
                </comment>
                <comment line="2396">
                    Process the prefix / suffix characters                    
                </comment>
                <comment line="2398">
                    A quote within quotes indicates either the closing                    
                </comment>
                <comment line="2399">
                    quote or two quotes, which is a quote literal. That                    
                </comment>
                <comment line="2400">
                    is, we have the second quote in &apos;do&apos; or &apos;don&apos;&apos;t&apos;.                    
                </comment>
                <comment line="2405">
                    &apos;don&apos;&apos;t&apos;                    
                </comment>
                <comment line="2407">
                    &apos;do&apos;                    
                </comment>
                <comment line="2412">
                    Process unquoted characters seen in prefix or suffix                    
                </comment>
                <comment line="2413">
                    phase.                    
                </comment>
                <comment line="2422">
                    Reprocess this character                    
                </comment>
                <comment line="2425">
                    Use lookahead to determine if the currency sign                    
                </comment>
                <comment line="2426">
                    is doubled or not.                    
                </comment>
                <comment line="2429">
                    Skip over the doubled character                    
                </comment>
                <comment line="2436">
                    A quote outside quotes indicates either the                    
                </comment>
                <comment line="2437">
                    opening quote or two quotes, which is a quote                    
                </comment>
                <comment line="2438">
                    literal. That is, we have the first quote in &apos;do&apos;                    
                </comment>
                <comment line="2439">
                    or o&apos;&apos;clock.                    
                </comment>
                <comment line="2444">
                    o&apos;&apos;clock                    
                </comment>
                <comment line="2446">
                    &apos;do&apos;                    
                </comment>
                <comment line="2451">
                    Don&apos;t allow separators before we see digit                    
                </comment>
                <comment line="2452">
                    characters of phase 1, and don&apos;t allow separators                    
                </comment>
                <comment line="2453">
                    in the second pattern (j == 0).                    
                </comment>
                <comment line="2463">
                    Next handle characters which are appended directly.                    
                </comment>
                <comment line="2485">
                    Note that if we are within quotes, or if this is an                    
                </comment>
                <comment line="2486">
                    unquoted, non-special character, then we usually fall                    
                </comment>
                <comment line="2487">
                    through to here.                    
                </comment>
                <comment line="2492">
                    Phase one must be identical in the two sub-patterns. We                    
                </comment>
                <comment line="2493">
                    enforce this by doing a direct comparison. While                    
                </comment>
                <comment line="2494">
                    processing the first sub-pattern, we just record its                    
                </comment>
                <comment line="2495">
                    length. While processing the second, we compare                    
                </comment>
                <comment line="2496">
                    characters.                    
                </comment>
                <comment line="2507">
                    Process the digits, decimal, and grouping characters. We                    
                </comment>
                <comment line="2508">
                    record five pieces of information. We expect the digits                    
                </comment>
                <comment line="2509">
                    to occur in the pattern ####0000.####, and we record the                    
                </comment>
                <comment line="2510">
                    number of left digits, zero (central) digits, and right                    
                </comment>
                <comment line="2511">
                    digits. The position of the last grouping character is                    
                </comment>
                <comment line="2512">
                    recorded (should be somewhere within the first two blocks                    
                </comment>
                <comment line="2513">
                    of characters), as is the position of the decimal point,                    
                </comment>
                <comment line="2514">
                    if any (should be in the zero digits). If there is no                    
                </comment>
                <comment line="2515">
                    decimal point, then there should be no right digits.                    
                </comment>
                <comment line="2550">
                    Use lookahead to parse out the exponential part                    
                </comment>
                <comment line="2551">
                    of the pattern, then jump into phase 2.                    
                </comment>
                <comment line="2566">
                    Transition to phase 2                    
                </comment>
                <comment line="2582">
                    Handle patterns with no &apos;0&apos; pattern character. These patterns                    
                </comment>
                <comment line="2583">
                    are legal, but must be interpreted.  &quot;##.###&quot; -&gt; &quot;#0.###&quot;.                    
                </comment>
                <comment line="2584">
                    &quot;.###&quot; -&gt; &quot;.0##&quot;.                    
                </comment>
                <comment line="2585">
                    We allow patterns of the form &quot;####&quot; to produce a zeroDigitCount
                     of zero (got that?); although this seems like it might make it
                     possible for format() to produce empty strings, format() checks
                     for this condition and outputs a zero digit in this situation.
                     Having a zeroDigitCount of zero yields a minimum integer digits
                     of zero, which allows proper round-trip patterns.  That is, we
                     don&apos;t want &quot;#&quot; to become &quot;#0&quot; when toPattern() is called (even
                     though that&apos;s what it really is, semantically).                    
                </comment>
                <comment line="2595">
                    Handle &quot;###.###&quot; and &quot;###.&quot; and &quot;.###&quot;                    
                </comment>
                <comment line="2597">
                    Handle &quot;.###&quot;                    
                </comment>
                <comment line="2605">
                    Do syntax checking on the digits.                    
                </comment>
                <comment line="2617">
                    assume these for now                    
                </comment>
                <comment line="2620">
                    The effectiveDecimalPos is the position the decimal is at or
                     would be at if there is no decimal. Note that if decimalPos&lt;0,
                     then digitTotalCount == digitLeftCount + zeroDigitCount.                    
                </comment>
                <comment line="2654">
                    If there was no negative pattern, or if the negative pattern is                    
                </comment>
                <comment line="2655">
                    identical to the positive pattern, then prepend the minus sign to                    
                </comment>
                <comment line="2656">
                    the positive pattern to form the negative pattern.                    
                </comment>
                <declaration name="zeroDigit" type="char" line="2337"/>
                <declaration name="groupingSeparator" type="char" line="2338"/>
                <declaration name="decimalSeparator" type="char" line="2339"/>
                <declaration name="percent" type="char" line="2340"/>
                <declaration name="perMill" type="char" line="2341"/>
                <declaration name="digit" type="char" line="2342"/>
                <declaration name="separator" type="char" line="2343"/>
                <declaration name="exponent" type="String" line="2344"/>
                <declaration name="minus" type="char" line="2345"/>
                <scope line="2346"/>
                <declaration name="gotNegative" type="boolean" line="2357"/>
                <declaration name="phaseOneStart" type="int" line="2366"/>
                <declaration name="phaseOneLength" type="int" line="2367"/>
                <declaration name="start" type="int" line="2369"/>
                <scope line="2370">
                    <declaration name="inQuote" type="boolean" line="2371"/>
                    <declaration name="prefix" type="StringBuffer" line="2372"/>
                    <declaration name="suffix" type="StringBuffer" line="2373"/>
                    <declaration name="decimalPos" type="int" line="2374"/>
                    <declaration name="multiplier" type="int" line="2375"/>
                    <declaration name="digitLeftCount" type="int" line="2376"/>
                    <declaration name="groupingCount" type="byte" line="2377"/>
                    <declaration name="phase" type="int" line="2386"/>
                    <declaration name="affix" type="StringBuffer" line="2389"/>
                    <scope line="2391">
                        <declaration name="ch" type="char" line="2392"/>
                        <scope line="2397">
                            <scope line="2401">
                                <scope line="2403"/>
                                <scope line="2406"/>
                            </scope>
                        </scope>
                        <scope line="2411">
                            <scope line="2417">
                                <scope line="2419"/>
                            </scope>
                            <scope line="2424">
                                <declaration name="doubled" type="boolean" line="2427"/>
                                <scope line="2429"/>
                            </scope>
                            <scope line="2435">
                                <scope line="2440">
                                    <scope line="2442"/>
                                    <scope line="2445"/>
                                </scope>
                            </scope>
                            <scope line="2450">
                                <scope line="2454"/>
                            </scope>
                            <scope line="2464">
                                <scope line="2465"/>
                            </scope>
                            <scope line="2472">
                                <scope line="2473"/>
                            </scope>
                            <scope line="2480"/>
                        </scope>
                        <scope line="2497"/>
                        <scope line="2499">
                            <scope line="2500"/>
                        </scope>
                        <scope line="2516">
                            <scope line="2517"/>
                            <scope line="2519"/>
                            <scope line="2522"/>
                        </scope>
                        <scope line="2525">
                            <scope line="2526"/>
                            <scope line="2531"/>
                        </scope>
                        <scope line="2534"/>
                        <scope line="2536">
                            <scope line="2537"/>
                        </scope>
                        <scope line="2542">
                            <scope line="2543"/>
                            <scope line="2554"/>
                            <scope line="2561"/>
                        </scope>
                        <scope line="2571"/>
                    </scope>
                    <scope line="2594">
                        <declaration name="n" type="int" line="2596"/>
                        <scope line="2597"/>
                    </scope>
                    <scope line="2609"/>
                    <scope line="2614">
                        <declaration name="digitTotalCount" type="int" line="2619"/>
                        <declaration name="effectiveDecimalPos" type="int" line="2624"/>
                    </scope>
                    <scope line="2639"/>
                </scope>
                <scope line="2646"/>
                <scope line="2659"/>
            </method>
            <javadoc line="2667">
                Sets the maximum number of digits allowed in the integer portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
                  309 is used. Negative input values are replaced with 0.                
                <see>
                    NumberFormat#setMaximumIntegerDigits                    
                </see>
            </javadoc>
            <method name="setMaximumIntegerDigits" type="void" line="2675">
                <params>
                    <param name="newValue" type="int"/>
                </params>
                <scope line="2679"/>
            </method>
            <javadoc line="2686">
                Sets the minimum number of digits allowed in the integer portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
                  309 is used. Negative input values are replaced with 0.                
                <see>
                    NumberFormat#setMinimumIntegerDigits                    
                </see>
            </javadoc>
            <method name="setMinimumIntegerDigits" type="void" line="2694">
                <params>
                    <param name="newValue" type="int"/>
                </params>
                <scope line="2698"/>
            </method>
            <javadoc line="2705">
                Sets the maximum number of digits allowed in the fraction portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
                  340 is used. Negative input values are replaced with 0.                
                <see>
                    NumberFormat#setMaximumFractionDigits                    
                </see>
            </javadoc>
            <method name="setMaximumFractionDigits" type="void" line="2713">
                <params>
                    <param name="newValue" type="int"/>
                </params>
                <scope line="2717"/>
            </method>
            <javadoc line="2724">
                Sets the minimum number of digits allowed in the fraction portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
                  340 is used. Negative input values are replaced with 0.                
                <see>
                    NumberFormat#setMinimumFractionDigits                    
                </see>
            </javadoc>
            <method name="setMinimumFractionDigits" type="void" line="2732">
                <params>
                    <param name="newValue" type="int"/>
                </params>
                <scope line="2736"/>
            </method>
            <javadoc line="2743">
                Gets the maximum number of digits allowed in the integer portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
                  309 is used.                
                <see>
                    #setMaximumIntegerDigits                    
                </see>
            </javadoc>
            <method name="getMaximumIntegerDigits" type="int" line="2751"/>
            <javadoc line="2755">
                Gets the minimum number of digits allowed in the integer portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
                  309 is used.                
                <see>
                    #setMinimumIntegerDigits                    
                </see>
            </javadoc>
            <method name="getMinimumIntegerDigits" type="int" line="2763"/>
            <javadoc line="2767">
                Gets the maximum number of digits allowed in the fraction portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
                  340 is used.                
                <see>
                    #setMaximumFractionDigits                    
                </see>
            </javadoc>
            <method name="getMaximumFractionDigits" type="int" line="2775"/>
            <javadoc line="2779">
                Gets the minimum number of digits allowed in the fraction portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
                  340 is used.                
                <see>
                    #setMinimumFractionDigits                    
                </see>
            </javadoc>
            <method name="getMinimumFractionDigits" type="int" line="2787"/>
            <javadoc line="2791">
                Gets the currency used by this decimal format when formatting
                  currency values.
                  The currency is obtained by calling{@link DecimalFormatSymbols#getCurrency DecimalFormatSymbols.getCurrency}on this number format&apos;s symbols.                
                <return>
                    the currency used by this decimal format, or <code>null</code>                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getCurrency" type="Currency" line="2801"/>
            <javadoc line="2805">
                Sets the currency used by this number format when formatting
                  currency values. This does not update the minimum or maximum
                  number of fraction digits used by the number format.
                  The currency is set by calling{@link DecimalFormatSymbols#setCurrency DecimalFormatSymbols.setCurrency}on this number format&apos;s symbols.                
                <param>
                    currency the new currency to be used by this decimal format                    
                </param>
                <exception>
                    NullPointerException if <code>currency</code> is null                    
                </exception>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setCurrency" type="void" line="2817">
                <params>
                    <param name="currency" type="Currency"/>
                </params>
                <scope line="2818">
                    <scope line="2820"/>
                </scope>
            </method>
            <javadoc line="2826">
                Gets the {@link java.math.RoundingMode} used in this DecimalFormat.                
                <return>
                    The <code>RoundingMode</code> used for this DecimalFormat.                    
                </return>
                <see>
                    #setRoundingMode(RoundingMode)                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getRoundingMode" type="RoundingMode" line="2833"/>
            <javadoc line="2837">
                Sets the {@link java.math.RoundingMode} used in this DecimalFormat.                
                <param>
                    roundingMode The <code>RoundingMode</code> to be used                    
                </param>
                <see>
                    #getRoundingMode()                    
                </see>
                <exception>
                    NullPointerException if <code>roundingMode</code> is null.                    
                </exception>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setRoundingMode" type="void" line="2845">
                <params>
                    <param name="roundingMode" type="RoundingMode"/>
                </params>
                <scope line="2846"/>
            </method>
            <javadoc line="2854">
                Adjusts the minimum and maximum fraction digits to values that
                  are reasonable for the currency&apos;s default fraction digits.                
            </javadoc>
            <method name="adjustForCurrencyDefaultFractionDigits" type="void" line="2858">
                <comment line="2870">
                    Common patterns are &quot;#.##&quot;, &quot;#.00&quot;, &quot;#&quot;.                    
                </comment>
                <comment line="2871">
                    Try to adjust all of them in a reasonable way.                    
                </comment>
                <declaration name="currency" type="Currency" line="2859"/>
                <scope line="2860">
                    <scope line="2861"/>
                    <scope line="2863"/>
                </scope>
                <scope line="2866">
                    <declaration name="digits" type="int" line="2867"/>
                    <scope line="2868">
                        <declaration name="oldMinDigits" type="int" line="2869"/>
                        <scope line="2872"/>
                        <scope line="2875"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2883">
                Reads the default serializable fields from the stream and performs
                  validations and adjustments for older serialized versions. The
                  validations and adjustments are:
                  &lt;ol&gt;
                  &lt;li&gt;
                  Verify that the superclass&apos;s digit count fields correctly reflect
                  the limits imposed on formatting numbers other than
                  &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; objects. These
                  limits are stored in the superclass for serialization compatibility
                  with older versions, while the limits for &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects are kept in this class.
                  If, in the superclass, the minimum or maximum integer digit count is
                  larger than &lt;code&gt;DOUBLE_INTEGER_DIGITS&lt;/code&gt; or if the minimum or
                  maximum fraction digit count is larger than
                  &lt;code&gt;DOUBLE_FRACTION_DIGITS&lt;/code&gt;, then the stream data is invalid
                  and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.
                  &lt;li&gt;
                  If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 4, initialize
                  &lt;code&gt;roundingMode&lt;/code&gt; to {@link java.math.RoundingMode#HALF_EVENRoundingMode.HALF_EVEN}.  This field is new with version 4.
                  &lt;li&gt;
                  If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 3, then call
                  the setters for the minimum and maximum integer and fraction digits with
                  the values of the corresponding superclass getters to initialize the
                  fields in this class. The fields in this class are new with version 3.
                  &lt;li&gt;
                  If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that
                  the stream was written by JDK 1.1, initialize
                  &lt;code&gt;useExponentialNotation&lt;/code&gt;
                  to false, since it was not present in JDK 1.1.
                  &lt;li&gt;
                  Set &lt;code&gt;serialVersionOnStream&lt;/code&gt; to the maximum allowed value so
                  that default serialization will work properly if this object is streamed
                  out again.
                  &lt;/ol&gt;
                  &lt;p&gt;Stream versions older than 2 will not have the affix pattern variables
                  &lt;code&gt;posPrefixPattern&lt;/code&gt; etc.  As a result, they will be initialized
                  to &lt;code&gt;null&lt;/code&gt;, which means the affix strings will be taken as
                  literal values.  This is exactly what we want, since that corresponds to
                  the pre-version-2 behavior.                
            </javadoc>
            <method name="readObject" type="void" line="2928">
                <params>
                    <param name="stream" type="ObjectInputStream"/>
                </params>
                <comment line="2935">
                    We only need to check the maximum counts because NumberFormat                    
                </comment>
                <comment line="2936">
                    .readObject has already ensured that the maximum is greater than the                    
                </comment>
                <comment line="2937">
                    minimum count.                    
                </comment>
                <comment line="2949">
                    Didn&apos;t have exponential fields                    
                </comment>
                <scope line="2932"/>
                <scope line="2939"/>
                <scope line="2942"/>
                <scope line="2948"/>
            </method>
            <declaration name="digitList" type="DigitList" line="2959"/>
            <declaration name="positivePrefix" type="String" line="2961"/>
            <javadoc line="2961">
                The symbol used as a prefix when formatting positive numbers, e.g. &quot;+&quot;.                
                <serial>
                                        
                </serial>
                <see>
                    #getPositivePrefix                    
                </see>
            </javadoc>
            <declaration name="positiveSuffix" type="String" line="2969"/>
            <javadoc line="2969">
                The symbol used as a suffix when formatting positive numbers.
                  This is often an empty string.                
                <serial>
                                        
                </serial>
                <see>
                    #getPositiveSuffix                    
                </see>
            </javadoc>
            <declaration name="negativePrefix" type="String" line="2978"/>
            <javadoc line="2978">
                The symbol used as a prefix when formatting negative numbers, e.g. &quot;-&quot;.                
                <serial>
                                        
                </serial>
                <see>
                    #getNegativePrefix                    
                </see>
            </javadoc>
            <declaration name="negativeSuffix" type="String" line="2986"/>
            <javadoc line="2986">
                The symbol used as a suffix when formatting negative numbers.
                  This is often an empty string.                
                <serial>
                                        
                </serial>
                <see>
                    #getNegativeSuffix                    
                </see>
            </javadoc>
            <declaration name="posPrefixPattern" type="String" line="2995"/>
            <javadoc line="2995">
                The prefix pattern for non-negative numbers.  This variable corresponds
                  to &lt;code&gt;positivePrefix&lt;/code&gt;.
                  &lt;p&gt;This pattern is expanded by the method &lt;code&gt;expandAffix()&lt;/code&gt; to
                  &lt;code&gt;positivePrefix&lt;/code&gt; to update the latter to reflect changes in
                  &lt;code&gt;symbols&lt;/code&gt;.  If this variable is &lt;code&gt;null&lt;/code&gt; then
                  &lt;code&gt;positivePrefix&lt;/code&gt; is taken as a literal value that does not
                  change when &lt;code&gt;symbols&lt;/code&gt; changes.  This variable is always
                  &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;DecimalFormat&lt;/code&gt; objects older than
                  stream version 2 restored from stream.                
                <serial>
                                        
                </serial>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="posSuffixPattern" type="String" line="3012"/>
            <javadoc line="3012">
                The suffix pattern for non-negative numbers.  This variable corresponds
                  to &lt;code&gt;positiveSuffix&lt;/code&gt;.  This variable is analogous to
                  &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
                  documentation.                
                <serial>
                                        
                </serial>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="negPrefixPattern" type="String" line="3023"/>
            <javadoc line="3023">
                The prefix pattern for negative numbers.  This variable corresponds
                  to &lt;code&gt;negativePrefix&lt;/code&gt;.  This variable is analogous to
                  &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
                  documentation.                
                <serial>
                                        
                </serial>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="negSuffixPattern" type="String" line="3034"/>
            <javadoc line="3034">
                The suffix pattern for negative numbers.  This variable corresponds
                  to &lt;code&gt;negativeSuffix&lt;/code&gt;.  This variable is analogous to
                  &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
                  documentation.                
                <serial>
                                        
                </serial>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="multiplier" type="int" line="3045"/>
            <javadoc line="3045">
                The multiplier for use in percent, per mille, etc.                
                <serial>
                                        
                </serial>
                <see>
                    #getMultiplier                    
                </see>
            </javadoc>
            <declaration name="groupingSize" type="byte" line="3053"/>
            <javadoc line="3053">
                The number of digits between grouping separators in the integer
                  portion of a number.  Must be greater than 0 if
                  &lt;code&gt;NumberFormat.groupingUsed&lt;/code&gt; is true.                
                <serial>
                                        
                </serial>
                <see>
                    #getGroupingSize                    
                </see>
                <see>
                    java.text.NumberFormat#isGroupingUsed                    
                </see>
            </javadoc>
            <declaration name="decimalSeparatorAlwaysShown" type="boolean" line="3064"/>
            <javadoc line="3064">
                If true, forces the decimal separator to always appear in a formatted
                  number, even if the fractional part of the number is zero.                
                <serial>
                                        
                </serial>
                <see>
                    #isDecimalSeparatorAlwaysShown                    
                </see>
            </javadoc>
            <declaration name="parseBigDecimal" type="boolean" line="3073"/>
            <javadoc line="3073">
                If true, parse returns BigDecimal wherever possible.                
                <serial>
                                        
                </serial>
                <see>
                    #isParseBigDecimal                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="isCurrencyFormat" type="boolean" line="3083"/>
            <javadoc line="3083">
                True if this object represents a currency format.  This determines
                  whether the monetary decimal separator is used instead of the normal one.                
            </javadoc>
            <declaration name="symbols" type="DecimalFormatSymbols" line="3089"/>
            <javadoc line="3089">
                The &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object used by this format.
                  It contains the symbols used to format numbers, e.g. the grouping separator,
                  decimal separator, and so on.                
                <serial>
                                        
                </serial>
                <see>
                    #setDecimalFormatSymbols                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols                    
                </see>
            </javadoc>
            <declaration name="useExponentialNotation" type="boolean" line="3100"/>
            <javadoc line="3100">
                True to force the use of exponential (i.e. scientific) notation when formatting
                  numbers.                
                <serial>
                                        
                </serial>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="positivePrefixFieldPositions" type="FieldPosition[]" line="3109"/>
            <javadoc line="3109">
                FieldPositions describing the positive prefix String. This is
                  lazily created. Use &lt;code&gt;getPositivePrefixFieldPositions&lt;/code&gt;
                  when needed.                
            </javadoc>
            <declaration name="positiveSuffixFieldPositions" type="FieldPosition[]" line="3116"/>
            <javadoc line="3116">
                FieldPositions describing the positive suffix String. This is
                  lazily created. Use &lt;code&gt;getPositiveSuffixFieldPositions&lt;/code&gt;
                  when needed.                
            </javadoc>
            <declaration name="negativePrefixFieldPositions" type="FieldPosition[]" line="3123"/>
            <javadoc line="3123">
                FieldPositions describing the negative prefix String. This is
                  lazily created. Use &lt;code&gt;getNegativePrefixFieldPositions&lt;/code&gt;
                  when needed.                
            </javadoc>
            <declaration name="negativeSuffixFieldPositions" type="FieldPosition[]" line="3130"/>
            <javadoc line="3130">
                FieldPositions describing the negative suffix String. This is
                  lazily created. Use &lt;code&gt;getNegativeSuffixFieldPositions&lt;/code&gt;
                  when needed.                
            </javadoc>
            <declaration name="minExponentDigits" type="byte" line="3137"/>
            <javadoc line="3137">
                The minimum number of digits used to display the exponent when a number is
                  formatted in exponential notation.  This field is ignored if
                  &lt;code&gt;useExponentialNotation&lt;/code&gt; is not true.                
                <serial>
                                        
                </serial>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="maximumIntegerDigits" type="int" line="3147"/>
            <javadoc line="3147">
                The maximum number of digits allowed in the integer portion of a
                  &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
                  &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to
                  &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.                
                <serial>
                                        
                </serial>
                <see>
                    #getMaximumIntegerDigits                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="minimumIntegerDigits" type="int" line="3159"/>
            <javadoc line="3159">
                The minimum number of digits allowed in the integer portion of a
                  &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
                  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to
                  &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.                
                <serial>
                                        
                </serial>
                <see>
                    #getMinimumIntegerDigits                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="maximumFractionDigits" type="int" line="3171"/>
            <javadoc line="3171">
                The maximum number of digits allowed in the fractional portion of a
                  &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
                  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to
                  &lt;code&gt;minimumFractionDigits&lt;/code&gt;.                
                <serial>
                                        
                </serial>
                <see>
                    #getMaximumFractionDigits                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="minimumFractionDigits" type="int" line="3183"/>
            <javadoc line="3183">
                The minimum number of digits allowed in the fractional portion of a
                  &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
                  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to
                  &lt;code&gt;maximumFractionDigits&lt;/code&gt;.                
                <serial>
                                        
                </serial>
                <see>
                    #getMinimumFractionDigits                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="roundingMode" type="RoundingMode" line="3195"/>
            <javadoc line="3195">
                The {@link java.math.RoundingMode} used in this DecimalFormat.                
                <serial>
                                        
                </serial>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="currentSerialVersion" type="int" line="3205"/>
            <declaration name="serialVersionOnStream" type="int" line="3207"/>
            <javadoc line="3207">
                The internal serial version which says which version was written.
                  Possible values are:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (default): versions before the Java 2 platform v1.2
                  &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: version for 1.2, which includes the two new fields
                  &lt;code&gt;useExponentialNotation&lt;/code&gt; and
                  &lt;code&gt;minExponentDigits&lt;/code&gt;.
                  &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: version for 1.3 and later, which adds four new fields:
                  &lt;code&gt;posPrefixPattern&lt;/code&gt;, &lt;code&gt;posSuffixPattern&lt;/code&gt;,
                  &lt;code&gt;negPrefixPattern&lt;/code&gt;, and &lt;code&gt;negSuffixPattern&lt;/code&gt;.
                  &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: version for 1.5 and later, which adds five new fields:
                  &lt;code&gt;maximumIntegerDigits&lt;/code&gt;,
                  &lt;code&gt;minimumIntegerDigits&lt;/code&gt;,
                  &lt;code&gt;maximumFractionDigits&lt;/code&gt;,
                  &lt;code&gt;minimumFractionDigits&lt;/code&gt;, and
                  &lt;code&gt;parseBigDecimal&lt;/code&gt;.
                  &lt;li&gt;&lt;b&gt;4&lt;/b&gt;: version for 1.6 and later, which adds one new field:
                  &lt;code&gt;roundingMode&lt;/code&gt;.
                  &lt;/ul&gt;                
                <since>
                    1.2                    
                </since>
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="PATTERN_ZERO_DIGIT" type="char" line="3237"/>
            <declaration name="PATTERN_GROUPING_SEPARATOR" type="char" line="3238"/>
            <declaration name="PATTERN_DECIMAL_SEPARATOR" type="char" line="3239"/>
            <declaration name="PATTERN_PER_MILLE" type="char" line="3240"/>
            <declaration name="PATTERN_PERCENT" type="char" line="3241"/>
            <declaration name="PATTERN_DIGIT" type="char" line="3242"/>
            <declaration name="PATTERN_SEPARATOR" type="char" line="3243"/>
            <declaration name="PATTERN_EXPONENT" type="String" line="3244"/>
            <declaration name="PATTERN_MINUS" type="char" line="3245"/>
            <declaration name="CURRENCY_SIGN" type="char" line="3247"/>
            <javadoc line="3247">
                The CURRENCY_SIGN is the standard Unicode symbol for currency.  It
                  is used in patterns and substituted with either the currency symbol,
                  or if it is doubled, with the international currency symbol.  If the
                  CURRENCY_SIGN is seen in a pattern, then the decimal separator is
                  replaced with the monetary decimal separator.
                  The CURRENCY_SIGN is not localized.                
            </javadoc>
            <declaration name="QUOTE" type="char" line="3258"/>
            <declaration name="EmptyFieldPositionArray" type="FieldPosition[]" line="3260"/>
            <declaration name="DOUBLE_INTEGER_DIGITS" type="int" line="3263"/>
            <declaration name="DOUBLE_FRACTION_DIGITS" type="int" line="3264"/>
            <declaration name="MAXIMUM_INTEGER_DIGITS" type="int" line="3267"/>
            <declaration name="MAXIMUM_FRACTION_DIGITS" type="int" line="3268"/>
            <declaration name="serialVersionUID" type="long" line="3271"/>
            <declaration name="cachedLocaleData" type="ConcurrentMap&lt;Locale,String&gt;" line="3273"/>
            <javadoc line="3273">
                Cache to hold the NumberPattern of a Locale.                
            </javadoc>
        </class>
    </source>