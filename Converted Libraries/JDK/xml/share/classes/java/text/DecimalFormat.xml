<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.io.InvalidObjectException"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.math.BigDecimal"/>
        <import package="java.math.BigInteger"/>
        <import package="java.math.RoundingMode"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Currency"/>
        <import package="java.util.Locale"/>
        <import package="java.util.ResourceBundle"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.concurrent.ConcurrentMap"/>
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <import package="java.util.concurrent.atomic.AtomicLong"/>
        <import package="sun.util.resources.LocaleData"/>
        <class name="DecimalFormat" line="17">
            <extends class="NumberFormat"/>
            <javadoc line="17">
                &lt;code&gt;DecimalFormat&lt;/code&gt; is a concrete subclass of
                  &lt;code&gt;NumberFormat&lt;/code&gt; that formats decimal numbers. It has a variety of
                  features designed to make it possible to parse and format numbers in any
                  locale, including support for Western, Arabic, and Indic digits.  It also
                  supports different kinds of numbers, including integers (123), fixed-point
                  numbers (123.4), scientific notation (1.23E4), percentages (12%), and
                  currency amounts ($123).  All of these can be localized.
                  &lt;p&gt;To obtain a &lt;code&gt;NumberFormat&lt;/code&gt; for a specific locale, including the
                  default locale, call one of &lt;code&gt;NumberFormat&lt;/code&gt;&apos;s factory methods, such
                  as &lt;code&gt;getInstance()&lt;/code&gt;.  In general, do not call the
                  &lt;code&gt;DecimalFormat&lt;/code&gt; constructors directly, since the
                  &lt;code&gt;NumberFormat&lt;/code&gt; factory methods may return subclasses other than
                  &lt;code&gt;DecimalFormat&lt;/code&gt;. If you need to customize the format object, do
                  something like this:
                  &lt;blockquote&gt;&lt;pre&gt;
                  NumberFormat f = NumberFormat.getInstance(loc);
                  if (f instanceof DecimalFormat) {
                  ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; comprises a &lt;em&gt;pattern&lt;/em&gt; and a set of
                  &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
                  &lt;code&gt;applyPattern()&lt;/code&gt;, or indirectly using the API methods.  The
                  symbols are stored in a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  When using
                  the &lt;code&gt;NumberFormat&lt;/code&gt; factory methods, the pattern and symbols are
                  read from localized &lt;code&gt;ResourceBundle&lt;/code&gt;s.
                  &lt;h4&gt;Patterns&lt;/h4&gt;
                  &lt;code&gt;DecimalFormat&lt;/code&gt; patterns have the following syntax:
                  &lt;blockquote&gt;&lt;pre&gt;
                  &lt;i&gt;Pattern:&lt;/i&gt;
                  &lt;i&gt;PositivePattern&lt;/i&gt;
                  &lt;i&gt;PositivePattern&lt;/i&gt; ; &lt;i&gt;NegativePattern&lt;/i&gt;
                  &lt;i&gt;PositivePattern:&lt;/i&gt;
                  &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;NegativePattern:&lt;/i&gt;
                  &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;Prefix:&lt;/i&gt;
                  any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
                  &lt;i&gt;Suffix:&lt;/i&gt;
                  any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
                  &lt;i&gt;Number:&lt;/i&gt;
                  &lt;i&gt;Integer&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;Integer&lt;/i&gt; . &lt;i&gt;Fraction&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;Integer:&lt;/i&gt;
                  &lt;i&gt;MinimumInteger&lt;/i&gt;
                  #
                  # &lt;i&gt;Integer&lt;/i&gt;
                  # , &lt;i&gt;Integer&lt;/i&gt;
                  &lt;i&gt;MinimumInteger:&lt;/i&gt;
                  0
                  0 &lt;i&gt;MinimumInteger&lt;/i&gt;
                  0 , &lt;i&gt;MinimumInteger&lt;/i&gt;
                  &lt;i&gt;Fraction:&lt;/i&gt;
                  &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;MinimumFraction:&lt;/i&gt;
                  0 &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;OptionalFraction:&lt;/i&gt;
                  # &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;i&gt;Exponent:&lt;/i&gt;
                  E &lt;i&gt;MinimumExponent&lt;/i&gt;
                  &lt;i&gt;MinimumExponent:&lt;/i&gt;
                  0 &lt;i&gt;MinimumExponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; pattern contains a positive and negative
                  subpattern, for example, &lt;code&gt;&quot;#,##0.00;(#,##0.00)&quot;&lt;/code&gt;.  Each
                  subpattern has a prefix, numeric part, and suffix. The negative subpattern
                  is optional; if absent, then the positive subpattern prefixed with the
                  localized minus sign (&lt;code&gt;&apos;-&apos;&lt;/code&gt; in most locales) is used as the
                  negative subpattern. That is, &lt;code&gt;&quot;0.00&quot;&lt;/code&gt; alone is equivalent to
                  &lt;code&gt;&quot;0.00;-0.00&quot;&lt;/code&gt;.  If there is an explicit negative subpattern, it
                  serves only to specify the negative prefix and suffix; the number of digits,
                  minimal digits, and other characteristics are all the same as the positive
                  pattern. That means that &lt;code&gt;&quot;#,##0.0#;(#)&quot;&lt;/code&gt; produces precisely
                  the same behavior as &lt;code&gt;&quot;#,##0.0#;(#,##0.0#)&quot;&lt;/code&gt;.
                  &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
                  thousands separators, decimal separators, etc. may be set to arbitrary
                  values, and they will appear properly during formatting.  However, care must
                  be taken that the symbols and strings do not conflict, or parsing will be
                  unreliable.  For example, either the positive and negative prefixes or the
                  suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able
                  to distinguish positive from negative values.  (If they are identical, then
                  &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was
                  specified.)  Another example is that the decimal separator and thousands
                  separator should be distinct characters, or parsing will be impossible.
                  &lt;p&gt;The grouping separator is commonly used for thousands, but in some
                  countries it separates ten-thousands. The grouping size is a constant number
                  of digits between the grouping characters, such as 3 for 100,000,000 or 4 for
                  1,0000,0000.  If you supply a pattern with multiple grouping characters, the
                  interval between the last one and the end of the integer is the one that is
                  used. So &lt;code&gt;&quot;#,##,###,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;######,####&quot;&lt;/code&gt; ==
                  &lt;code&gt;&quot;##,####,####&quot;&lt;/code&gt;.
                  &lt;h4&gt;Special Pattern Characters&lt;/h4&gt;
                  &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
                  parsing and output unchanged during formatting.  Special characters, on the
                  other hand, stand for other characters, strings, or classes of characters.
                  They must be quoted, unless noted otherwise, if they are to appear in the
                  prefix or suffix as literals.
                  &lt;p&gt;The characters listed here are used in non-localized patterns.  Localized
                  patterns use the corresponding characters taken from this formatter&apos;s
                  &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object instead, and these characters lose
                  their special status.  Two exceptions are the currency sign and quote, which
                  are not localized.
                  &lt;blockquote&gt;
                  &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Chart showing symbol,
                  location, localized, and meaning.&quot;&gt;
                  &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
                  &lt;th align=left&gt;Symbol
                  &lt;th align=left&gt;Location
                  &lt;th align=left&gt;Localized?
                  &lt;th align=left&gt;Meaning
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Digit
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;#&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Digit, zero shows as absent
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;.&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Decimal separator or monetary decimal separator
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;-&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Minus sign
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;,&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Grouping separator
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;E&lt;/code&gt;
                  &lt;td&gt;Number
                  &lt;td&gt;Yes
                  &lt;td&gt;Separates mantissa and exponent in scientific notation.
                  &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;;&lt;/code&gt;
                  &lt;td&gt;Subpattern boundary
                  &lt;td&gt;Yes
                  &lt;td&gt;Separates positive and negative subpatterns
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;%&lt;/code&gt;
                  &lt;td&gt;Prefix or suffix
                  &lt;td&gt;Yes
                  &lt;td&gt;Multiply by 100 and show as percentage
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;&amp;#92;u2030&lt;/code&gt;
                  &lt;td&gt;Prefix or suffix
                  &lt;td&gt;Yes
                  &lt;td&gt;Multiply by 1000 and show as per mille value
                  &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&amp;#164;&lt;/code&gt; (&lt;code&gt;&amp;#92;u00A4&lt;/code&gt;)
                  &lt;td&gt;Prefix or suffix
                  &lt;td&gt;No
                  &lt;td&gt;Currency sign, replaced by currency symbol.  If
                  doubled, replaced by international currency symbol.
                  If present in a pattern, the monetary decimal separator
                  is used instead of the decimal separator.
                  &lt;tr valign=top&gt;
                  &lt;td&gt;&lt;code&gt;&apos;&lt;/code&gt;
                  &lt;td&gt;Prefix or suffix
                  &lt;td&gt;No
                  &lt;td&gt;Used to quote special characters in a prefix or suffix,
                  for example, &lt;code&gt;&quot;&apos;#&apos;#&quot;&lt;/code&gt; formats 123 to
                  &lt;code&gt;&quot;#123&quot;&lt;/code&gt;.  To create a single quote
                  itself, use two in a row: &lt;code&gt;&quot;# o&apos;&apos;clock&quot;&lt;/code&gt;.
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;h4&gt;Scientific Notation&lt;/h4&gt;
                  &lt;p&gt;Numbers in scientific notation are expressed as the product of a mantissa
                  and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The
                  mantissa is often in the range 1.0 &lt;= x &lt; 10.0, but it need not be.
                  &lt;code&gt;DecimalFormat&lt;/code&gt; can be instructed to format and parse scientific
                  notation &lt;em&gt;only via a pattern&lt;/em&gt;; there is currently no factory method
                  that creates a scientific notation format.  In a pattern, the exponent
                  character immediately followed by one or more digit characters indicates
                  scientific notation.  Example: &lt;code&gt;&quot;0.###E0&quot;&lt;/code&gt; formats the number
                  1234 as &lt;code&gt;&quot;1.234E3&quot;&lt;/code&gt;.
                  &lt;ul&gt;
                  &lt;li&gt;The number of digit characters after the exponent character gives the
                  minimum exponent digit count.  There is no maximum.  Negative exponents are
                  formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix
                  from the pattern.  This allows patterns such as &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt;.
                  &lt;li&gt;The minimum and maximum number of integer digits are interpreted
                  together:
                  &lt;ul&gt;
                  &lt;li&gt;If the maximum number of integer digits is greater than their minimum number
                  and greater than 1, it forces the exponent to be a multiple of the maximum
                  number of integer digits, and the minimum number of integer digits to be
                  interpreted as 1.  The most common use of this is to generate
                  &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three,
                  e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345
                  formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to
                  &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.
                  &lt;li&gt;Otherwise, the minimum number of integer digits is achieved by adjusting the
                  exponent.  Example: 0.00123 formatted with &lt;code&gt;&quot;00.###E0&quot;&lt;/code&gt; yields
                  &lt;code&gt;&quot;12.3E-4&quot;&lt;/code&gt;.
                  &lt;/ul&gt;
                  &lt;li&gt;The number of significant digits in the mantissa is the sum of the
                  &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is
                  unaffected by the maximum integer digits.  For example, 12345 formatted with
                  &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; is &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt;. To show all digits, set
                  the significant digits count to zero.  The number of significant digits
                  does not affect parsing.
                  &lt;li&gt;Exponential patterns may not contain grouping separators.
                  &lt;/ul&gt;
                  &lt;h4&gt;Rounding&lt;/h4&gt;
                  &lt;code&gt;DecimalFormat&lt;/code&gt; provides rounding modes defined in{@link java.math.RoundingMode} for formatting.  By default, it uses{@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
                  &lt;h4&gt;Digits&lt;/h4&gt;
                  For formatting, &lt;code&gt;DecimalFormat&lt;/code&gt; uses the ten consecutive
                  characters starting with the localized zero digit defined in the
                  &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object as digits. For parsing, these
                  digits as well as all Unicode decimal digits, as defined by{@link Character#digit Character.digit}, are recognized.
                  &lt;h4&gt;Special Values&lt;/h4&gt;
                  &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is formatted as a string, which typically has a single character
                  &lt;code&gt;&amp;#92;uFFFD&lt;/code&gt;.  This string is determined by the
                  &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  This is the only value for which
                  the prefixes and suffixes are not used.
                  &lt;p&gt;Infinity is formatted as a string, which typically has a single character
                  &lt;code&gt;&amp;#92;u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes
                  applied.  The infinity string is determined by the
                  &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.
                  &lt;p&gt;Negative zero (&lt;code&gt;&quot;-0&quot;&lt;/code&gt;) parses to
                  &lt;ul&gt;
                  &lt;li&gt;&lt;code&gt;BigDecimal(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is
                  true,
                  &lt;li&gt;&lt;code&gt;Long(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false
                  and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; is true,
                  &lt;li&gt;&lt;code&gt;Double(-0.0)&lt;/code&gt; if both &lt;code&gt;isParseBigDecimal()&lt;/code&gt;
                  and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; are false.
                  &lt;/ul&gt;
                  &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt;
                  Decimal formats are generally not synchronized.
                  It is recommended to create separate format instances for each thread.
                  If multiple threads access a format concurrently, it must be synchronized
                  externally.
                  &lt;h4&gt;Example&lt;/h4&gt;
                  &lt;blockquote&gt;&lt;pre&gt;
                  &lt;strong&gt;// Print out a number using the localized number, integer, currency,
                  // and percent format for each locale&lt;/strong&gt;
                  Locale[] locales = NumberFormat.getAvailableLocales();
                  double myNumber = -1234.56;
                  NumberFormat form;
                  for (int j=0; j&lt;4; ++j) {
                  System.out.println(&quot;FORMAT&quot;);
                  for (int i = 0; i &lt; locales.length; ++i) {
                  if (locales[i].getCountry().length() == 0) {
                  continue; // Skip language-only locales
                  }
                  System.out.print(locales[i].getDisplayName());
                  switch (j) {
                  case 0:
                  form = NumberFormat.getInstance(locales[i]); break;
                  case 1:
                  form = NumberFormat.getIntegerInstance(locales[i]); break;
                  case 2:
                  form = NumberFormat.getCurrencyInstance(locales[i]); break;
                  default:
                  form = NumberFormat.getPercentInstance(locales[i]); break;
                  }
                  if (form instanceof DecimalFormat) {
                  System.out.print(&quot;: &quot; + ((DecimalFormat) form).toPattern());
                  }
                  System.out.print(&quot; -&gt; &quot; + form.format(myNumber));
                  try {
                  System.out.println(&quot; -&gt; &quot; + form.parse(form.format(myNumber)));
                  } catch (ParseException e) {}
                  }
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <see>
                    <a href="http://java.sun.com/docs/books/tutorial/i18n/format/decimalFormat.html">Java Tutorial</a>                    
                </see>
                <see>
                    NumberFormat                    
                </see>
                <see>
                    DecimalFormatSymbols                    
                </see>
                <see>
                    ParsePosition                    
                </see>
                <author>
                    Mark Davis                    
                </author>
                <author>
                    Alan Liu                    
                </author>
            </javadoc>
            <javadoc line="303">
                Creates a DecimalFormat using the default pattern and symbols
                  for the default locale. This is a convenient way to obtain a
                  DecimalFormat when internationalization is not the main concern.
                  &lt;p&gt;
                  To obtain standard formats for a given locale, use the factory methods
                  on NumberFormat such as getNumberInstance. These factories will
                  return the most appropriate sub-class of NumberFormat for a given
                  locale.                
                <see>
                    java.text.NumberFormat#getInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getNumberInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getCurrencyInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getPercentInstance                    
                </see>
            </javadoc>
            <method name="DecimalFormat" type="constructor" line="317">
                <declaration name="def" type="Locale" line="318"/>
                <declaration name="pattern" type="String" line="319"/>
                <scope line="320">
                    <declaration name="rb" type="ResourceBundle" line="321"/>
                    <declaration name="all" type="String[]" line="322"/>
                </scope>
            </method>
            <javadoc line="329">
                Creates a DecimalFormat using the given pattern and the symbols
                  for the default locale. This is a convenient way to obtain a
                  DecimalFormat when internationalization is not the main concern.
                  &lt;p&gt;
                  To obtain standard formats for a given locale, use the factory methods
                  on NumberFormat such as getNumberInstance. These factories will
                  return the most appropriate sub-class of NumberFormat for a given
                  locale.                
                <param>
                    pattern A non-localized pattern string.                    
                </param>
                <exception>
                    NullPointerException if <code>pattern</code> is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid.                    
                </exception>
                <see>
                    java.text.NumberFormat#getInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getNumberInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getCurrencyInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getPercentInstance                    
                </see>
            </javadoc>
            <method name="DecimalFormat" type="constructor" line="346">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="350">
                Creates a DecimalFormat using the given pattern and symbols.
                  Use this constructor when you need to completely customize the
                  behavior of the format.
                  &lt;p&gt;
                  To obtain standard formats for a given
                  locale, use the factory methods on NumberFormat such as
                  getInstance or getCurrencyInstance. If you need only minor adjustments
                  to a standard format, you can modify the format returned by
                  a NumberFormat factory method.                
                <param>
                    pattern a non-localized pattern string                    
                </param>
                <param>
                    symbols the set of symbols to be used                    
                </param>
                <exception>
                    NullPointerException if any of the given arguments is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
                <see>
                    java.text.NumberFormat#getInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getNumberInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getCurrencyInstance                    
                </see>
                <see>
                    java.text.NumberFormat#getPercentInstance                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols                    
                </see>
            </javadoc>
            <method name="DecimalFormat" type="constructor" line="370">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="symbols" type="DecimalFormatSymbols"/>
                </params>
            </method>
            <javadoc line="374">
                Formats a number and appends the resulting text to the given string
                  buffer.
                  The number can be of any subclass of {@link java.lang.Number}.
                  &lt;p&gt;
                  This implementation uses the maximum precision permitted.                
                <param>
                    number     the number to format                    
                </param>
                <param>
                    toAppendTo the <code>StringBuffer</code> to which the formatted
                      text is to be appended                    
                </param>
                <param>
                    pos        On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <return>
                    the value passed in as <code>toAppendTo</code>                    
                </return>
                <exception>
                    IllegalArgumentException if <code>number</code> is
                      null or not an instance of <code>Number</code>.                    
                </exception>
                <exception>
                    NullPointerException if <code>toAppendTo</code> or
                      <code>pos</code> is null                    
                </exception>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="394">
                <params>
                    <param name="number" type="Object"/>
                    <param name="toAppendTo" type="StringBuffer"/>
                    <param name="pos" type="FieldPosition"/>
                </params>
                <scope line="395"/>
                <scope line="398"/>
                <scope line="401"/>
                <scope line="404"/>
                <scope line="407"/>
            </method>
            <javadoc line="411">
                Formats a double to produce a string.                
                <param>
                    number    The double to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    fieldPosition    On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <return>
                    The formatted number string                    
                </return>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="422">
                <params>
                    <param name="number" type="double"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="fieldPosition" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="427">
                Formats a double to produce a string.                
                <param>
                    number    The double to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    delegate notified of locations of sub fields                    
                </param>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <return>
                    The formatted number string                    
                </return>
            </javadoc>
            <method name="format" type="StringBuffer" line="436">
                <params>
                    <param name="number" type="double"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                </params>
                <scope line="437">
                    <declaration name="iFieldStart" type="int" line="438"/>
                </scope>
                <declaration name="isNegative" type="boolean" line="443"/>
                <scope line="444"/>
                <scope line="447">
                    <scope line="448"/>
                    <scope line="451"/>
                    <declaration name="iFieldStart" type="int" line="454"/>
                    <scope line="457"/>
                    <scope line="460"/>
                </scope>
                <scope line="465"/>
                <scope line="469">
                    <declaration name="maxIntDigits" type="int" line="470"/>
                    <declaration name="minIntDigits" type="int" line="471"/>
                    <declaration name="maxFraDigits" type="int" line="472"/>
                    <declaration name="minFraDigits" type="int" line="473"/>
                </scope>
            </method>
            <javadoc line="478">
                Format a long to produce a string.                
                <param>
                    number    The long to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    fieldPosition    On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <return>
                    The formatted number string                    
                </return>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="489">
                <params>
                    <param name="number" type="long"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="fieldPosition" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="494">
                Format a long to produce a string.                
                <param>
                    number    The long to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    delegate notified of locations of sub fields                    
                </param>
                <return>
                    The formatted number string                    
                </return>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="504">
                <params>
                    <param name="number" type="long"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                </params>
                <declaration name="isNegative" type="boolean" line="505"/>
                <scope line="506"/>
                <declaration name="useBigInteger" type="boolean" line="509"/>
                <scope line="510">
                    <scope line="511"/>
                </scope>
                <scope line="515">
                    <declaration name="cutoff" type="long" line="516"/>
                    <scope line="517"/>
                </scope>
                <scope line="522">
                    <scope line="523"/>
                    <declaration name="bigIntegerValue" type="BigInteger" line="526"/>
                </scope>
                <scope line="530"/>
                <scope line="533">
                    <scope line="534"/>
                </scope>
                <scope line="539">
                    <declaration name="maxIntDigits" type="int" line="540"/>
                    <declaration name="minIntDigits" type="int" line="541"/>
                    <declaration name="maxFraDigits" type="int" line="542"/>
                    <declaration name="minFraDigits" type="int" line="543"/>
                </scope>
            </method>
            <javadoc line="548">
                Formats a BigDecimal to produce a string.                
                <param>
                    number    The BigDecimal to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    fieldPosition    On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <return>
                    The formatted number string                    
                </return>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="559">
                <params>
                    <param name="number" type="BigDecimal"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="fieldPosition" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="564">
                Formats a BigDecimal to produce a string.                
                <param>
                    number    The BigDecimal to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    delegate notified of locations of sub fields                    
                </param>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <return>
                    The formatted number string                    
                </return>
            </javadoc>
            <method name="format" type="StringBuffer" line="573">
                <params>
                    <param name="number" type="BigDecimal"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                </params>
                <scope line="574"/>
                <declaration name="isNegative" type="boolean" line="577"/>
                <scope line="578"/>
                <scope line="581">
                    <declaration name="maxIntDigits" type="int" line="582"/>
                    <declaration name="minIntDigits" type="int" line="583"/>
                    <declaration name="maxFraDigits" type="int" line="584"/>
                    <declaration name="minFraDigits" type="int" line="585"/>
                    <declaration name="maximumDigits" type="int" line="586"/>
                </scope>
            </method>
            <javadoc line="591">
                Format a BigInteger to produce a string.                
                <param>
                    number    The BigInteger to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    fieldPosition    On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <return>
                    The formatted number string                    
                </return>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="602">
                <params>
                    <param name="number" type="BigInteger"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="fieldPosition" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="607">
                Format a BigInteger to produce a string.                
                <param>
                    number    The BigInteger to format                    
                </param>
                <param>
                    result    where the text is to be appended                    
                </param>
                <param>
                    delegate notified of locations of sub fields                    
                </param>
                <return>
                    The formatted number string                    
                </return>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <see>
                    java.text.FieldPosition                    
                </see>
            </javadoc>
            <method name="format" type="StringBuffer" line="617">
                <params>
                    <param name="number" type="BigInteger"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                    <param name="formatLong" type="boolean"/>
                </params>
                <scope line="618"/>
                <declaration name="isNegative" type="boolean" line="621"/>
                <scope line="622"/>
                <scope line="625">
                    <declaration name="maxIntDigits" type="int" line="626"/>
                    <scope line="627"/>
                    <scope line="634">
                        <scope line="640"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="648">
                Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
                  You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
                  to build the resulting String, as well as to determine information
                  about the resulting String.
                  &lt;p&gt;
                  Each attribute key of the AttributedCharacterIterator will be of type
                  &lt;code&gt;NumberFormat.Field&lt;/code&gt;, with the attribute value being the
                  same as the attribute key.                
                <exception>
                    NullPointerException if obj is null.                    
                </exception>
                <exception>
                    IllegalArgumentException when the Format cannot format the
                      given object.                    
                </exception>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <param>
                    obj The object to format                    
                </param>
                <return>
                    AttributedCharacterIterator describing the formatted value.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="formatToCharacterIterator" type="AttributedCharacterIterator" line="666">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <declaration name="delegate" type="CharacterIteratorFieldDelegate" line="667"/>
                <declaration name="sb" type="StringBuffer" line="668"/>
                <scope line="669"/>
                <scope line="672"/>
                <scope line="675"/>
                <scope line="678"/>
                <scope line="681"/>
                <scope line="684"/>
            </method>
            <javadoc line="689">
                Complete the formatting of a finite number.  On entry, the digitList must
                  be filled in with the correct digits.                
            </javadoc>
            <method name="subformat" type="StringBuffer" line="693">
                <params>
                    <param name="result" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                    <param name="isNegative" type="boolean"/>
                    <param name="isInteger" type="boolean"/>
                    <param name="maxIntDigits" type="int"/>
                    <param name="minIntDigits" type="int"/>
                    <param name="maxFraDigits" type="int"/>
                    <param name="minFraDigits" type="int"/>
                </params>
                <declaration name="zero" type="char" line="694"/>
                <declaration name="zeroDelta" type="int" line="695"/>
                <declaration name="grouping" type="char" line="696"/>
                <declaration name="decimal" type="char" line="697"/>
                <scope line="698"/>
                <scope line="701"/>
                <scope line="704"/>
                <scope line="707">
                    <declaration name="iFieldStart" type="int" line="708"/>
                    <declaration name="iFieldEnd" type="int" line="709"/>
                    <declaration name="fFieldStart" type="int" line="710"/>
                    <declaration name="exponent" type="int" line="711"/>
                    <declaration name="repeat" type="int" line="712"/>
                    <declaration name="minimumIntegerDigits" type="int" line="713"/>
                    <scope line="714">
                        <scope line="715"/>
                        <scope line="718"/>
                    </scope>
                    <scope line="723"/>
                    <declaration name="minimumDigits" type="int" line="726"/>
                    <scope line="727"/>
                    <declaration name="integerDigits" type="int" line="730"/>
                    <scope line="731"/>
                    <declaration name="totalDigits" type="int" line="734"/>
                    <scope line="735"/>
                    <declaration name="addedDecimalSeparator" type="boolean" line="738"/>
                    <scope line="739">
                        <scope line="740"/>
                    </scope>
                    <scope line="748"/>
                    <scope line="754"/>
                    <scope line="758"/>
                    <scope line="761"/>
                    <declaration name="fieldStart" type="int" line="765"/>
                    <scope line="768"/>
                    <declaration name="negativeExponent" type="boolean" line="771"/>
                    <scope line="772"/>
                    <declaration name="eFieldStart" type="int" line="779"/>
                    <scope line="780"/>
                    <scope line="783"/>
                </scope>
                <scope line="788">
                    <declaration name="iFieldStart" type="int" line="789"/>
                    <declaration name="count" type="int" line="790"/>
                    <declaration name="digitIndex" type="int" line="791"/>
                    <scope line="792"/>
                    <scope line="795"/>
                    <declaration name="sizeBeforeIntegerPart" type="int" line="799"/>
                    <scope line="800">
                        <scope line="801"/>
                        <scope line="804"/>
                        <scope line="807">
                            <declaration name="gStart" type="int" line="808"/>
                        </scope>
                    </scope>
                    <declaration name="fractionPresent" type="boolean" line="813"/>
                    <scope line="814"/>
                    <declaration name="sStart" type="int" line="818"/>
                    <scope line="819"/>
                    <scope line="822"/>
                    <declaration name="fFieldStart" type="int" line="825"/>
                    <scope line="826">
                        <scope line="827"/>
                        <scope line="830"/>
                        <scope line="834"/>
                        <scope line="837"/>
                    </scope>
                </scope>
                <scope line="843"/>
                <scope line="846"/>
            </method>
            <javadoc line="851">
                Appends the String &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;result&lt;/code&gt;.
                  &lt;code&gt;delegate&lt;/code&gt; is notified of all  the
                  &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;.
                  &lt;p&gt;
                  If one of the &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;
                  identifies a &lt;code&gt;SIGN&lt;/code&gt; attribute, it is mapped to
                  &lt;code&gt;signAttribute&lt;/code&gt;. This is used
                  to map the &lt;code&gt;SIGN&lt;/code&gt; attribute to the &lt;code&gt;EXPONENT&lt;/code&gt;
                  attribute as necessary.
                  &lt;p&gt;
                  This is used by &lt;code&gt;subformat&lt;/code&gt; to add the prefix/suffix.                
            </javadoc>
            <method name="append" type="void" line="864">
                <params>
                    <param name="result" type="StringBuffer"/>
                    <param name="string" type="String"/>
                    <param name="delegate" type="FieldDelegate"/>
                    <param name="positions" type="FieldPosition[]"/>
                    <param name="signAttribute" type="Format.Field"/>
                </params>
                <declaration name="start" type="int" line="865"/>
                <scope line="866">
                    <scope line="868">
                        <declaration name="fp" type="FieldPosition" line="869"/>
                        <declaration name="attribute" type="Format.Field" line="870"/>
                        <scope line="871"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="878">
                Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.
                  &lt;p&gt;
                  The method attempts to parse text starting at the index given by
                  &lt;code&gt;pos&lt;/code&gt;.
                  If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
                  to the index after the last character used (parsing does not necessarily
                  use all characters up to the end of the string), and the parsed
                  number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
                  indicate the starting point for the next call to this method.
                  If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
                  changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
                  the character where the error occurred, and null is returned.
                  &lt;p&gt;
                  The subclass returned depends on the value of {@link #isParseBigDecimal}as well as on the string being parsed.
                  &lt;ul&gt;
                  &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false (the default),
                  most integer values are returned as &lt;code&gt;Long&lt;/code&gt;
                  objects, no matter how they are written: &lt;code&gt;&quot;17&quot;&lt;/code&gt; and
                  &lt;code&gt;&quot;17.000&quot;&lt;/code&gt; both parse to &lt;code&gt;Long(17)&lt;/code&gt;.
                  Values that cannot fit into a &lt;code&gt;Long&lt;/code&gt; are returned as
                  &lt;code&gt;Double&lt;/code&gt;s. This includes values with a fractional part,
                  infinite values, &lt;code&gt;NaN&lt;/code&gt;, and the value -0.0.
                  &lt;code&gt;DecimalFormat&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; decide whether to
                  return a &lt;code&gt;Double&lt;/code&gt; or a &lt;code&gt;Long&lt;/code&gt; based on the
                  presence of a decimal separator in the source string. Doing so
                  would prevent integers that overflow the mantissa of a double,
                  such as &lt;code&gt;&quot;-9,223,372,036,854,775,808.00&quot;&lt;/code&gt;, from being
                  parsed accurately.
                  &lt;p&gt;
                  Callers may use the &lt;code&gt;Number&lt;/code&gt; methods
                  &lt;code&gt;doubleValue&lt;/code&gt;, &lt;code&gt;longValue&lt;/code&gt;, etc., to obtain
                  the type they want.
                  &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is true, values are returned
                  as &lt;code&gt;BigDecimal&lt;/code&gt; objects. The values are the ones
                  constructed by {@link java.math.BigDecimal#BigDecimal(String)}for corresponding strings in locale-independent format. The
                  special cases negative and positive infinity and NaN are returned
                  as &lt;code&gt;Double&lt;/code&gt; instances holding the values of the
                  corresponding &lt;code&gt;Double&lt;/code&gt; constants.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  &lt;code&gt;DecimalFormat&lt;/code&gt; parses all Unicode characters that represent
                  decimal digits, as defined by &lt;code&gt;Character.digit()&lt;/code&gt;. In
                  addition, &lt;code&gt;DecimalFormat&lt;/code&gt; also recognizes as digits the ten
                  consecutive characters starting with the localized zero digit defined in
                  the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.                
                <param>
                    text the string to be parsed                    
                </param>
                <param>
                    pos  A <code>ParsePosition</code> object with index and error
                      index information as described above.                    
                </param>
                <return>
                    the parsed value, or <code>null</code> if the parse fails                    
                </return>
                <exception>
                    NullPointerException if <code>text</code> or
                      <code>pos</code> is null.                    
                </exception>
            </javadoc>
            <method name="parse" type="Number" line="931">
                <params>
                    <param name="text" type="String"/>
                    <param name="pos" type="ParsePosition"/>
                </params>
                <scope line="932"/>
                <declaration name="status" type="boolean[]" line="936"/>
                <scope line="937"/>
                <scope line="940">
                    <scope line="941"/>
                    <scope line="944"/>
                </scope>
                <scope line="948">
                    <scope line="949"/>
                    <scope line="952"/>
                    <scope line="955"/>
                </scope>
                <scope line="959">
                    <declaration name="bigDecimalResult" type="BigDecimal" line="960"/>
                    <scope line="961">
                        <scope line="962"/>
                        <scope line="965"/>
                    </scope>
                    <scope line="969"/>
                </scope>
                <scope line="974">
                    <declaration name="gotDouble" type="boolean" line="975"/>
                    <declaration name="gotLongMinimum" type="boolean" line="976"/>
                    <declaration name="doubleResult" type="double" line="977"/>
                    <declaration name="longResult" type="long" line="978"/>
                    <scope line="979">
                        <scope line="982"/>
                    </scope>
                    <scope line="986"/>
                    <scope line="989">
                        <scope line="990"/>
                        <scope line="993">
                            <scope line="994"/>
                            <scope line="997"/>
                        </scope>
                    </scope>
                    <scope line="1003"/>
                    <scope line="1007"/>
                </scope>
            </method>
            <javadoc line="1014">
                Return a BigInteger multiplier.                
            </javadoc>
            <method name="getBigIntegerMultiplier" type="BigInteger" line="1017">
                <scope line="1018"/>
            </method>
            <declaration name="bigIntegerMultiplier" type="BigInteger" line="1023"/>
            <javadoc line="1024">
                Return a BigDecimal multiplier.                
            </javadoc>
            <method name="getBigDecimalMultiplier" type="BigDecimal" line="1027">
                <scope line="1028"/>
            </method>
            <declaration name="bigDecimalMultiplier" type="BigDecimal" line="1033"/>
            <declaration name="STATUS_INFINITE" type="int" line="1034"/>
            <declaration name="STATUS_POSITIVE" type="int" line="1035"/>
            <declaration name="STATUS_LENGTH" type="int" line="1036"/>
            <javadoc line="1037">
                Parse the given text into a number.  The text is parsed beginning at
                  parsePosition, until an unparseable character is seen.                
                <param>
                    text The string to parse.                    
                </param>
                <param>
                    parsePosition The position at which to being parsing.  Upon
                      return, the first unparseable character.                    
                </param>
                <param>
                    digits The DigitList to set to the parsed value.                    
                </param>
                <param>
                    isExponent If true, parse an exponent.  This means no
                      infinite values and integer only.                    
                </param>
                <param>
                    status Upon return contains boolean status flags indicating
                      whether the value was infinite and whether it was positive.                    
                </param>
            </javadoc>
            <method name="subparse" type="boolean" line="1049">
                <params>
                    <param name="text" type="String"/>
                    <param name="parsePosition" type="ParsePosition"/>
                    <param name="positivePrefix" type="String"/>
                    <param name="negativePrefix" type="String"/>
                    <param name="digits" type="DigitList"/>
                    <param name="isExponent" type="boolean"/>
                    <param name="status" type="boolean"/>
                </params>
                <declaration name="position" type="int" line="1050"/>
                <declaration name="oldStart" type="int" line="1051"/>
                <declaration name="backup" type="int" line="1052"/>
                <declaration name="gotPositive" type="boolean" line="1053"/>
                <scope line="1056">
                    <scope line="1057"/>
                    <scope line="1060"/>
                </scope>
                <scope line="1064"/>
                <scope line="1067"/>
                <scope line="1070"/>
                <scope line="1075"/>
                <scope line="1079">
                    <declaration name="zero" type="char" line="1081"/>
                    <declaration name="decimal" type="char" line="1082"/>
                    <declaration name="grouping" type="char" line="1083"/>
                    <declaration name="exponentString" type="String" line="1084"/>
                    <declaration name="sawDecimal" type="boolean" line="1085"/>
                    <declaration name="sawExponent" type="boolean" line="1086"/>
                    <declaration name="sawDigit" type="boolean" line="1087"/>
                    <declaration name="exponent" type="int" line="1088"/>
                    <declaration name="digitCount" type="int" line="1089"/>
                    <scope line="1091">
                        <declaration name="ch" type="char" line="1092"/>
                        <declaration name="digit" type="int" line="1093"/>
                        <scope line="1094"/>
                        <scope line="1097">
                            <scope line="1100">
                                <scope line="1101"/>
                            </scope>
                            <scope line="1106"/>
                        </scope>
                        <scope line="1111"/>
                        <scope line="1117">
                            <scope line="1118"/>
                        </scope>
                        <scope line="1124">
                            <scope line="1125"/>
                        </scope>
                        <scope line="1130">
                            <declaration name="pos" type="ParsePosition" line="1131"/>
                            <declaration name="stat" type="boolean[]" line="1132"/>
                            <declaration name="exponentDigits" type="DigitList" line="1133"/>
                            <scope line="1134">
                                <scope line="1137"/>
                            </scope>
                        </scope>
                        <scope line="1144"/>
                    </scope>
                    <scope line="1148"/>
                    <scope line="1151"/>
                    <scope line="1155"/>
                </scope>
                <scope line="1161">
                    <scope line="1162"/>
                    <scope line="1165"/>
                    <scope line="1168">
                        <scope line="1169"/>
                        <scope line="1172"/>
                    </scope>
                    <scope line="1176"/>
                </scope>
                <scope line="1182"/>
                <scope line="1186"/>
            </method>
            <javadoc line="1192">
                Returns a copy of the decimal format symbols, which is generally not
                  changed by the programmer or user.                
                <return>
                    a copy of the desired DecimalFormatSymbols                    
                </return>
                <see>
                    java.text.DecimalFormatSymbols                    
                </see>
            </javadoc>
            <method name="getDecimalFormatSymbols" type="DecimalFormatSymbols" line="1198">
                <scope line="1199"/>
                <scope line="1202"/>
            </method>
            <javadoc line="1206">
                Sets the decimal format symbols, which is generally not changed
                  by the programmer or user.                
                <param>
                    newSymbols desired DecimalFormatSymbols                    
                </param>
                <see>
                    java.text.DecimalFormatSymbols                    
                </see>
            </javadoc>
            <method name="setDecimalFormatSymbols" type="void" line="1212">
                <params>
                    <param name="newSymbols" type="DecimalFormatSymbols"/>
                </params>
                <scope line="1213"/>
                <scope line="1217"/>
            </method>
            <javadoc line="1220">
                Get the positive prefix.
                  &lt;P&gt;Examples: +123, $123, sFr123                
            </javadoc>
            <method name="getPositivePrefix" type="String" line="1224"/>
            <javadoc line="1227">
                Set the positive prefix.
                  &lt;P&gt;Examples: +123, $123, sFr123                
            </javadoc>
            <method name="setPositivePrefix" type="void" line="1231">
                <params>
                    <param name="newValue" type="String"/>
                </params>
            </method>
            <javadoc line="1236">
                Returns the FieldPositions of the fields in the prefix used for
                  positive numbers. This is not used if the user has explicitly set
                  a positive prefix via &lt;code&gt;setPositivePrefix&lt;/code&gt;. This is
                  lazily created.                
                <return>
                    FieldPositions in positive prefix                    
                </return>
            </javadoc>
            <method name="getPositivePrefixFieldPositions" type="FieldPosition[]" line="1243">
                <scope line="1244">
                    <scope line="1245"/>
                    <scope line="1248"/>
                </scope>
            </method>
            <javadoc line="1254">
                Get the negative prefix.
                  &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123                
            </javadoc>
            <method name="getNegativePrefix" type="String" line="1258"/>
            <javadoc line="1261">
                Set the negative prefix.
                  &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123                
            </javadoc>
            <method name="setNegativePrefix" type="void" line="1265">
                <params>
                    <param name="newValue" type="String"/>
                </params>
            </method>
            <javadoc line="1269">
                Returns the FieldPositions of the fields in the prefix used for
                  negative numbers. This is not used if the user has explicitly set
                  a negative prefix via &lt;code&gt;setNegativePrefix&lt;/code&gt;. This is
                  lazily created.                
                <return>
                    FieldPositions in positive prefix                    
                </return>
            </javadoc>
            <method name="getNegativePrefixFieldPositions" type="FieldPosition[]" line="1276">
                <scope line="1277">
                    <scope line="1278"/>
                    <scope line="1281"/>
                </scope>
            </method>
            <javadoc line="1287">
                Get the positive suffix.
                  &lt;P&gt;Example: 123%                
            </javadoc>
            <method name="getPositiveSuffix" type="String" line="1291"/>
            <javadoc line="1294">
                Set the positive suffix.
                  &lt;P&gt;Example: 123%                
            </javadoc>
            <method name="setPositiveSuffix" type="void" line="1298">
                <params>
                    <param name="newValue" type="String"/>
                </params>
            </method>
            <javadoc line="1302">
                Returns the FieldPositions of the fields in the suffix used for
                  positive numbers. This is not used if the user has explicitly set
                  a positive suffix via &lt;code&gt;setPositiveSuffix&lt;/code&gt;. This is
                  lazily created.                
                <return>
                    FieldPositions in positive prefix                    
                </return>
            </javadoc>
            <method name="getPositiveSuffixFieldPositions" type="FieldPosition[]" line="1309">
                <scope line="1310">
                    <scope line="1311"/>
                    <scope line="1314"/>
                </scope>
            </method>
            <javadoc line="1320">
                Get the negative suffix.
                  &lt;P&gt;Examples: -123%, ($123) (with positive suffixes)                
            </javadoc>
            <method name="getNegativeSuffix" type="String" line="1324"/>
            <javadoc line="1327">
                Set the negative suffix.
                  &lt;P&gt;Examples: 123%                
            </javadoc>
            <method name="setNegativeSuffix" type="void" line="1331">
                <params>
                    <param name="newValue" type="String"/>
                </params>
            </method>
            <javadoc line="1335">
                Returns the FieldPositions of the fields in the suffix used for
                  negative numbers. This is not used if the user has explicitly set
                  a negative suffix via &lt;code&gt;setNegativeSuffix&lt;/code&gt;. This is
                  lazily created.                
                <return>
                    FieldPositions in positive prefix                    
                </return>
            </javadoc>
            <method name="getNegativeSuffixFieldPositions" type="FieldPosition[]" line="1342">
                <scope line="1343">
                    <scope line="1344"/>
                    <scope line="1347"/>
                </scope>
            </method>
            <javadoc line="1353">
                Gets the multiplier for use in percent, per mille, and similar
                  formats.                
                <see>
                    #setMultiplier(int)                    
                </see>
            </javadoc>
            <method name="getMultiplier" type="int" line="1358"/>
            <javadoc line="1361">
                Sets the multiplier for use in percent, per mille, and similar
                  formats.
                  For a percent format, set the multiplier to 100 and the suffixes to
                  have &apos;%&apos; (for Arabic, use the Arabic percent sign).
                  For a per mille format, set the multiplier to 1000 and the suffixes to
                  have &apos;&amp;#92;u2030&apos;.
                  &lt;P&gt;Example: with multiplier 100, 1.23 is formatted as &quot;123&quot;, and
                  &quot;123&quot; is parsed into 1.23.                
                <see>
                    #getMultiplier                    
                </see>
            </javadoc>
            <method name="setMultiplier" type="void" line="1372">
                <params>
                    <param name="newValue" type="int"/>
                </params>
            </method>
            <javadoc line="1377">
                Return the grouping size. Grouping size is the number of digits between
                  grouping separators in the integer portion of a number.  For example,
                  in the number &quot;123,456.78&quot;, the grouping size is 3.                
                <see>
                    #setGroupingSize                    
                </see>
                <see>
                    java.text.NumberFormat#isGroupingUsed                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols#getGroupingSeparator                    
                </see>
            </javadoc>
            <method name="getGroupingSize" type="int" line="1385"/>
            <javadoc line="1388">
                Set the grouping size. Grouping size is the number of digits between
                  grouping separators in the integer portion of a number.  For example,
                  in the number &quot;123,456.78&quot;, the grouping size is 3.
                  &lt;br&gt;
                  The value passed in is converted to a byte, which may lose information.                
                <see>
                    #getGroupingSize                    
                </see>
                <see>
                    java.text.NumberFormat#setGroupingUsed                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols#setGroupingSeparator                    
                </see>
            </javadoc>
            <method name="setGroupingSize" type="void" line="1398">
                <params>
                    <param name="newValue" type="int"/>
                </params>
            </method>
            <javadoc line="1401">
                Allows you to get the behavior of the decimal separator with integers.
                  (The decimal separator will always appear with decimals.)
                  &lt;P&gt;Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345                
            </javadoc>
            <method name="isDecimalSeparatorAlwaysShown" type="boolean" line="1406"/>
            <javadoc line="1409">
                Allows you to set the behavior of the decimal separator with integers.
                  (The decimal separator will always appear with decimals.)
                  &lt;P&gt;Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345                
            </javadoc>
            <method name="setDecimalSeparatorAlwaysShown" type="void" line="1414">
                <params>
                    <param name="newValue" type="boolean"/>
                </params>
            </method>
            <javadoc line="1417">
                Returns whether the {@link #parse(java.lang.String,java.text.ParsePosition)}method returns &lt;code&gt;BigDecimal&lt;/code&gt;. The default value is false.                
                <see>
                    #setParseBigDecimal                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="isParseBigDecimal" type="boolean" line="1422"/>
            <javadoc line="1425">
                Sets whether the {@link #parse(java.lang.String,java.text.ParsePosition)}method returns &lt;code&gt;BigDecimal&lt;/code&gt;.                
                <see>
                    #isParseBigDecimal                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setParseBigDecimal" type="void" line="1430">
                <params>
                    <param name="newValue" type="boolean"/>
                </params>
            </method>
            <javadoc line="1433">
                Standard override; no change in semantics.                
            </javadoc>
            <method name="clone" type="Object" line="1436">
                <scope line="1437">
                    <declaration name="other" type="DecimalFormat" line="1438"/>
                </scope>
                <scope line="1443"/>
            </method>
            <javadoc line="1447">
                Overrides equals                
            </javadoc>
            <method name="equals" type="boolean" line="1450">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <declaration name="other" type="DecimalFormat" line="1453"/>
            </method>
            <javadoc line="1456">
                Overrides hashCode                
            </javadoc>
            <method name="hashCode" type="int" line="1459"/>
            <javadoc line="1462">
                Synthesizes a pattern string that represents the current state
                  of this Format object.                
                <see>
                    #applyPattern                    
                </see>
            </javadoc>
            <method name="toPattern" type="String" line="1467"/>
            <javadoc line="1470">
                Synthesizes a localized pattern string that represents the current
                  state of this Format object.                
                <see>
                    #applyPattern                    
                </see>
            </javadoc>
            <method name="toLocalizedPattern" type="String" line="1475"/>
            <javadoc line="1478">
                Expand the affix pattern strings into the expanded affix strings.  If any
                  affix pattern string is null, do not expand it.  This method should be
                  called any time the symbols or the affix patterns change in order to keep
                  the expanded affix strings up to date.                
            </javadoc>
            <method name="expandAffixes" type="void" line="1484">
                <declaration name="buffer" type="StringBuffer" line="1485"/>
                <scope line="1486"/>
                <scope line="1490"/>
                <scope line="1494"/>
                <scope line="1498"/>
            </method>
            <javadoc line="1503">
                Expand an affix pattern into an affix string.  All characters in the
                  pattern are literal unless prefixed by QUOTE.  The following characters
                  after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
                  PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
                  CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
                  currency code.  Any other character after a QUOTE represents itself.
                  QUOTE must be followed by another character; QUOTE may not occur by
                  itself at the end of the pattern.                
                <param>
                    pattern the non-null, possibly empty pattern                    
                </param>
                <param>
                    buffer a scratch StringBuffer; its contents will be lost                    
                </param>
                <return>
                    the expanded equivalent of pattern                    
                </return>
            </javadoc>
            <method name="expandAffix" type="String" line="1516">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="buffer" type="StringBuffer"/>
                </params>
                <scope line="1518">
                    <declaration name="c" type="char" line="1519"/>
                    <scope line="1520">
                        <scope line="1524"/>
                        <scope line="1528"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1547">
                Expand an affix pattern into an array of FieldPositions describing
                  how the pattern would be expanded.
                  All characters in the
                  pattern are literal unless prefixed by QUOTE.  The following characters
                  after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
                  PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
                  CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
                  currency code.  Any other character after a QUOTE represents itself.
                  QUOTE must be followed by another character; QUOTE may not occur by
                  itself at the end of the pattern.                
                <param>
                    pattern the non-null, possibly empty pattern                    
                </param>
                <return>
                    FieldPosition array of the resulting fields.                    
                </return>
            </javadoc>
            <method name="expandAffix" type="FieldPosition[]" line="1561">
                <params>
                    <param name="pattern" type="String"/>
                </params>
                <declaration name="positions" type="ArrayList" line="1562"/>
                <declaration name="stringIndex" type="int" line="1563"/>
                <scope line="1564">
                    <declaration name="c" type="char" line="1565"/>
                    <scope line="1566">
                        <declaration name="field" type="int" line="1567"/>
                        <declaration name="fieldID" type="Format.Field" line="1568"/>
                        <declaration name="string" type="String" line="1572"/>
                        <scope line="1573"/>
                        <scope line="1577"/>
                        <scope line="1580">
                            <scope line="1581"/>
                            <declaration name="fp" type="FieldPosition" line="1584"/>
                        </scope>
                        <scope line="1607">
                            <scope line="1608"/>
                            <declaration name="fp" type="FieldPosition" line="1611"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1619"/>
            </method>
            <javadoc line="1624">
                Appends an affix pattern to the given StringBuffer, quoting special
                  characters as needed.  Uses the internal affix pattern, if that exists,
                  or the literal affix, if the internal affix pattern is null.  The
                  appended string will generate the same affix pattern (or literal affix)
                  when passed to toPattern().                
                <param>
                    buffer the affix string is appended to this                    
                </param>
                <param>
                    affixPattern a pattern such as posPrefixPattern; may be null                    
                </param>
                <param>
                    expAffix a corresponding expanded affix, such as positivePrefix.
                      Ignored unless affixPattern is null.  If affixPattern is null, then
                      expAffix is appended as a literal affix.                    
                </param>
                <param>
                    localized true if the appended pattern should contain localized
                      pattern characters; otherwise, non-localized pattern chars are appended                    
                </param>
            </javadoc>
            <method name="appendAffix" type="void" line="1638">
                <params>
                    <param name="buffer" type="StringBuffer"/>
                    <param name="affixPattern" type="String"/>
                    <param name="expAffix" type="String"/>
                    <param name="localized" type="boolean"/>
                </params>
                <scope line="1639"/>
                <scope line="1642">
                    <declaration name="i" type="int" line="1643"/>
                    <scope line="1644">
                        <scope line="1646"/>
                        <scope line="1650"/>
                        <declaration name="c" type="char" line="1653"/>
                        <scope line="1655"/>
                        <scope line="1658"/>
                        <scope line="1662"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1679">
                Append an affix to the given StringBuffer, using quotes if
                  there are special characters.  Single quotes themselves must be
                  escaped in either case.                
            </javadoc>
            <method name="appendAffix" type="void" line="1684">
                <params>
                    <param name="buffer" type="StringBuffer"/>
                    <param name="affix" type="String"/>
                    <param name="localized" type="boolean"/>
                </params>
                <declaration name="needQuote" type="boolean" line="1685"/>
                <scope line="1686"/>
                <scope line="1689"/>
                <scope line="1694">
                    <scope line="1695">
                        <declaration name="c" type="char" line="1696"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1703">
                Does the real work of generating a pattern.                
            </javadoc>
            <method name="toPattern" type="String" line="1706">
                <params>
                    <param name="localized" type="boolean"/>
                </params>
                <declaration name="result" type="StringBuffer" line="1707"/>
                <scope line="1708">
                    <declaration name="i" type="int" line="1711"/>
                    <declaration name="digitCount" type="int" line="1712"/>
                    <scope line="1713">
                        <scope line="1714"/>
                    </scope>
                    <scope line="1720">
                        <scope line="1721"/>
                        <scope line="1724"/>
                    </scope>
                    <scope line="1728"/>
                    <scope line="1732">
                        <scope line="1734"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1743">
                Apply the given pattern to this Format object.  A pattern is a
                  short-hand specification for the various formatting properties.
                  These properties can also be changed individually through the
                  various setter methods.
                  &lt;p&gt;
                  There is no limit to integer digits set
                  by this routine, since that is the typical end-user desire;
                  use setMaximumInteger if you want to set a real value.
                  For negative numbers, use a second pattern, separated by a semicolon
                  &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; -&gt; 1,234.56
                  &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
                  a maximum of 2 fraction digits.
                  &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in
                  parentheses.
                  &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
                  these are presumed to be set in the positive pattern.                
                <exception>
                    NullPointerException if <code>pattern</code> is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid.                    
                </exception>
            </javadoc>
            <method name="applyPattern" type="void" line="1763">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1766">
                Apply the given pattern to this Format object.  The pattern
                  is assumed to be in a localized notation. A pattern is a
                  short-hand specification for the various formatting properties.
                  These properties can also be changed individually through the
                  various setter methods.
                  &lt;p&gt;
                  There is no limit to integer digits set
                  by this routine, since that is the typical end-user desire;
                  use setMaximumInteger if you want to set a real value.
                  For negative numbers, use a second pattern, separated by a semicolon
                  &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; -&gt; 1,234.56
                  &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
                  a maximum of 2 fraction digits.
                  &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in
                  parentheses.
                  &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
                  these are presumed to be set in the positive pattern.                
                <exception>
                    NullPointerException if <code>pattern</code> is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid.                    
                </exception>
            </javadoc>
            <method name="applyLocalizedPattern" type="void" line="1787">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1790">
                Does the real work of applying a pattern.                
            </javadoc>
            <method name="applyPattern" type="void" line="1793">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="localized" type="boolean"/>
                </params>
                <declaration name="zeroDigit" type="char" line="1794"/>
                <declaration name="groupingSeparator" type="char" line="1795"/>
                <declaration name="decimalSeparator" type="char" line="1796"/>
                <declaration name="percent" type="char" line="1797"/>
                <declaration name="perMill" type="char" line="1798"/>
                <declaration name="digit" type="char" line="1799"/>
                <declaration name="separator" type="char" line="1800"/>
                <declaration name="exponent" type="String" line="1801"/>
                <declaration name="minus" type="char" line="1802"/>
                <scope line="1803"/>
                <declaration name="gotNegative" type="boolean" line="1814"/>
                <declaration name="phaseOneStart" type="int" line="1818"/>
                <declaration name="phaseOneLength" type="int" line="1819"/>
                <declaration name="start" type="int" line="1820"/>
                <scope line="1821">
                    <declaration name="inQuote" type="boolean" line="1822"/>
                    <declaration name="prefix" type="StringBuffer" line="1823"/>
                    <declaration name="suffix" type="StringBuffer" line="1824"/>
                    <declaration name="decimalPos" type="int" line="1825"/>
                    <declaration name="multiplier" type="int" line="1826"/>
                    <declaration name="digitLeftCount" type="int" line="1827"/>
                    <declaration name="groupingCount" type="byte" line="1828"/>
                    <declaration name="phase" type="int" line="1829"/>
                    <declaration name="affix" type="StringBuffer" line="1830"/>
                    <scope line="1831">
                        <declaration name="ch" type="char" line="1832"/>
                        <scope line="1836">
                            <scope line="1837">
                                <scope line="1838"/>
                                <scope line="1842"/>
                            </scope>
                        </scope>
                        <scope line="1848">
                            <scope line="1849">
                                <scope line="1851"/>
                            </scope>
                            <scope line="1857">
                                <declaration name="doubled" type="boolean" line="1858"/>
                                <scope line="1859"/>
                            </scope>
                            <scope line="1866">
                                <scope line="1867">
                                    <scope line="1868"/>
                                    <scope line="1872"/>
                                </scope>
                            </scope>
                            <scope line="1878">
                                <scope line="1879"/>
                            </scope>
                            <scope line="1886">
                                <scope line="1887"/>
                            </scope>
                            <scope line="1894">
                                <scope line="1895"/>
                            </scope>
                            <scope line="1902"/>
                        </scope>
                        <scope line="1910"/>
                        <scope line="1913">
                            <scope line="1914"/>
                        </scope>
                        <scope line="1920">
                            <scope line="1921"/>
                            <scope line="1924"/>
                            <scope line="1927"/>
                        </scope>
                        <scope line="1931">
                            <scope line="1932"/>
                            <scope line="1936"/>
                        </scope>
                        <scope line="1940"/>
                        <scope line="1943">
                            <scope line="1944"/>
                        </scope>
                        <scope line="1949">
                            <scope line="1950"/>
                            <scope line="1956"/>
                            <scope line="1961"/>
                        </scope>
                        <scope line="1969"/>
                    </scope>
                    <scope line="1979">
                        <declaration name="n" type="int" line="1980"/>
                        <scope line="1981"/>
                    </scope>
                    <scope line="1988"/>
                    <scope line="1991">
                        <declaration name="digitTotalCount" type="int" line="1996"/>
                        <declaration name="effectiveDecimalPos" type="int" line="1997"/>
                    </scope>
                    <scope line="2007"/>
                </scope>
                <scope line="2013"/>
                <scope line="2020"/>
            </method>
            <javadoc line="2026">
                Sets the maximum number of digits allowed in the integer portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
                  309 is used. Negative input values are replaced with 0.                
                <see>
                    NumberFormat#setMaximumIntegerDigits                    
                </see>
            </javadoc>
            <method name="setMaximumIntegerDigits" type="void" line="2034">
                <params>
                    <param name="newValue" type="int"/>
                </params>
                <scope line="2037"/>
            </method>
            <javadoc line="2042">
                Sets the minimum number of digits allowed in the integer portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
                  309 is used. Negative input values are replaced with 0.                
                <see>
                    NumberFormat#setMinimumIntegerDigits                    
                </see>
            </javadoc>
            <method name="setMinimumIntegerDigits" type="void" line="2050">
                <params>
                    <param name="newValue" type="int"/>
                </params>
                <scope line="2053"/>
            </method>
            <javadoc line="2058">
                Sets the maximum number of digits allowed in the fraction portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
                  340 is used. Negative input values are replaced with 0.                
                <see>
                    NumberFormat#setMaximumFractionDigits                    
                </see>
            </javadoc>
            <method name="setMaximumFractionDigits" type="void" line="2066">
                <params>
                    <param name="newValue" type="int"/>
                </params>
                <scope line="2069"/>
            </method>
            <javadoc line="2074">
                Sets the minimum number of digits allowed in the fraction portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
                  340 is used. Negative input values are replaced with 0.                
                <see>
                    NumberFormat#setMinimumFractionDigits                    
                </see>
            </javadoc>
            <method name="setMinimumFractionDigits" type="void" line="2082">
                <params>
                    <param name="newValue" type="int"/>
                </params>
                <scope line="2085"/>
            </method>
            <javadoc line="2090">
                Gets the maximum number of digits allowed in the integer portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
                  309 is used.                
                <see>
                    #setMaximumIntegerDigits                    
                </see>
            </javadoc>
            <method name="getMaximumIntegerDigits" type="int" line="2098"/>
            <javadoc line="2101">
                Gets the minimum number of digits allowed in the integer portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
                  309 is used.                
                <see>
                    #setMinimumIntegerDigits                    
                </see>
            </javadoc>
            <method name="getMinimumIntegerDigits" type="int" line="2109"/>
            <javadoc line="2112">
                Gets the maximum number of digits allowed in the fraction portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
                  340 is used.                
                <see>
                    #setMaximumFractionDigits                    
                </see>
            </javadoc>
            <method name="getMaximumFractionDigits" type="int" line="2120"/>
            <javadoc line="2123">
                Gets the minimum number of digits allowed in the fraction portion of a
                  number.
                  For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
                  340 is used.                
                <see>
                    #setMinimumFractionDigits                    
                </see>
            </javadoc>
            <method name="getMinimumFractionDigits" type="int" line="2131"/>
            <javadoc line="2134">
                Gets the currency used by this decimal format when formatting
                  currency values.
                  The currency is obtained by calling{@link DecimalFormatSymbols#getCurrency DecimalFormatSymbols.getCurrency}on this number format&apos;s symbols.                
                <return>
                    the currency used by this decimal format, or <code>null</code>                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getCurrency" type="Currency" line="2141"/>
            <javadoc line="2144">
                Sets the currency used by this number format when formatting
                  currency values. This does not update the minimum or maximum
                  number of fraction digits used by the number format.
                  The currency is set by calling{@link DecimalFormatSymbols#setCurrency DecimalFormatSymbols.setCurrency}on this number format&apos;s symbols.                
                <param>
                    currency the new currency to be used by this decimal format                    
                </param>
                <exception>
                    NullPointerException if <code>currency</code> is null                    
                </exception>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setCurrency" type="void" line="2153">
                <params>
                    <param name="currency" type="Currency"/>
                </params>
                <scope line="2154">
                    <scope line="2156"/>
                </scope>
            </method>
            <javadoc line="2161">
                Gets the {@link java.math.RoundingMode} used in this DecimalFormat.                
                <return>
                    The <code>RoundingMode</code> used for this DecimalFormat.                    
                </return>
                <see>
                    #setRoundingMode(RoundingMode)                    
                </see>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getRoundingMode" type="RoundingMode" line="2167"/>
            <javadoc line="2170">
                Sets the {@link java.math.RoundingMode} used in this DecimalFormat.                
                <param>
                    roundingMode The <code>RoundingMode</code> to be used                    
                </param>
                <see>
                    #getRoundingMode()                    
                </see>
                <exception>
                    NullPointerException if <code>roundingMode</code> is null.                    
                </exception>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setRoundingMode" type="void" line="2177">
                <params>
                    <param name="roundingMode" type="RoundingMode"/>
                </params>
                <scope line="2178"/>
            </method>
            <javadoc line="2184">
                Adjusts the minimum and maximum fraction digits to values that
                  are reasonable for the currency&apos;s default fraction digits.                
            </javadoc>
            <method name="adjustForCurrencyDefaultFractionDigits" type="void" line="2188">
                <declaration name="currency" type="Currency" line="2189"/>
                <scope line="2190">
                    <scope line="2191"/>
                    <scope line="2194"/>
                </scope>
                <scope line="2197">
                    <declaration name="digits" type="int" line="2198"/>
                    <scope line="2199">
                        <declaration name="oldMinDigits" type="int" line="2200"/>
                        <scope line="2201"/>
                        <scope line="2205"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2212">
                Reads the default serializable fields from the stream and performs
                  validations and adjustments for older serialized versions. The
                  validations and adjustments are:
                  &lt;ol&gt;
                  &lt;li&gt;
                  Verify that the superclass&apos;s digit count fields correctly reflect
                  the limits imposed on formatting numbers other than
                  &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; objects. These
                  limits are stored in the superclass for serialization compatibility
                  with older versions, while the limits for &lt;code&gt;BigInteger&lt;/code&gt; and
                  &lt;code&gt;BigDecimal&lt;/code&gt; objects are kept in this class.
                  If, in the superclass, the minimum or maximum integer digit count is
                  larger than &lt;code&gt;DOUBLE_INTEGER_DIGITS&lt;/code&gt; or if the minimum or
                  maximum fraction digit count is larger than
                  &lt;code&gt;DOUBLE_FRACTION_DIGITS&lt;/code&gt;, then the stream data is invalid
                  and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.
                  &lt;li&gt;
                  If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 4, initialize
                  &lt;code&gt;roundingMode&lt;/code&gt; to {@link java.math.RoundingMode#HALF_EVENRoundingMode}.  This field is new with version 4.
                  &lt;li&gt;
                  If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 3, then call
                  the setters for the minimum and maximum integer and fraction digits with
                  the values of the corresponding superclass getters to initialize the
                  fields in this class. The fields in this class are new with version 3.
                  &lt;li&gt;
                  If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that
                  the stream was written by JDK 1.1, initialize
                  &lt;code&gt;useExponentialNotation&lt;/code&gt;
                  to false, since it was not present in JDK 1.1.
                  &lt;li&gt;
                  Set &lt;code&gt;serialVersionOnStream&lt;/code&gt; to the maximum allowed value so
                  that default serialization will work properly if this object is streamed
                  out again.
                  &lt;/ol&gt;
                  &lt;p&gt;Stream versions older than 2 will not have the affix pattern variables
                  &lt;code&gt;posPrefixPattern&lt;/code&gt; etc.  As a result, they will be initialized
                  to &lt;code&gt;null&lt;/code&gt;, which means the affix strings will be taken as
                  literal values.  This is exactly what we want, since that corresponds to
                  the pre-version-2 behavior.                
            </javadoc>
            <method name="readObject" type="void" line="2253">
                <params>
                    <param name="stream" type="ObjectInputStream"/>
                </params>
                <scope line="2256"/>
                <scope line="2259"/>
                <scope line="2262"/>
                <scope line="2268"/>
            </method>
            <declaration name="digitList" type="DigitList" line="2273"/>
            <declaration name="positivePrefix" type="String" line="2274"/>
            <javadoc line="2274">
                The symbol used as a prefix when formatting positive numbers, e.g. &quot;+&quot;.                
                <serial>
                                        
                </serial>
                <see>
                    #getPositivePrefix                    
                </see>
            </javadoc>
            <declaration name="positiveSuffix" type="String" line="2280"/>
            <javadoc line="2280">
                The symbol used as a suffix when formatting positive numbers.
                  This is often an empty string.                
                <serial>
                                        
                </serial>
                <see>
                    #getPositiveSuffix                    
                </see>
            </javadoc>
            <declaration name="negativePrefix" type="String" line="2287"/>
            <javadoc line="2287">
                The symbol used as a prefix when formatting negative numbers, e.g. &quot;-&quot;.                
                <serial>
                                        
                </serial>
                <see>
                    #getNegativePrefix                    
                </see>
            </javadoc>
            <declaration name="negativeSuffix" type="String" line="2293"/>
            <javadoc line="2293">
                The symbol used as a suffix when formatting negative numbers.
                  This is often an empty string.                
                <serial>
                                        
                </serial>
                <see>
                    #getNegativeSuffix                    
                </see>
            </javadoc>
            <declaration name="posPrefixPattern" type="String" line="2300"/>
            <javadoc line="2300">
                The prefix pattern for non-negative numbers.  This variable corresponds
                  to &lt;code&gt;positivePrefix&lt;/code&gt;.
                  &lt;p&gt;This pattern is expanded by the method &lt;code&gt;expandAffix()&lt;/code&gt; to
                  &lt;code&gt;positivePrefix&lt;/code&gt; to update the latter to reflect changes in
                  &lt;code&gt;symbols&lt;/code&gt;.  If this variable is &lt;code&gt;null&lt;/code&gt; then
                  &lt;code&gt;positivePrefix&lt;/code&gt; is taken as a literal value that does not
                  change when &lt;code&gt;symbols&lt;/code&gt; changes.  This variable is always
                  &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;DecimalFormat&lt;/code&gt; objects older than
                  stream version 2 restored from stream.                
                <serial>
                                        
                </serial>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="posSuffixPattern" type="String" line="2314"/>
            <javadoc line="2314">
                The suffix pattern for non-negative numbers.  This variable corresponds
                  to &lt;code&gt;positiveSuffix&lt;/code&gt;.  This variable is analogous to
                  &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
                  documentation.                
                <serial>
                                        
                </serial>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="negPrefixPattern" type="String" line="2323"/>
            <javadoc line="2323">
                The prefix pattern for negative numbers.  This variable corresponds
                  to &lt;code&gt;negativePrefix&lt;/code&gt;.  This variable is analogous to
                  &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
                  documentation.                
                <serial>
                                        
                </serial>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="negSuffixPattern" type="String" line="2332"/>
            <javadoc line="2332">
                The suffix pattern for negative numbers.  This variable corresponds
                  to &lt;code&gt;negativeSuffix&lt;/code&gt;.  This variable is analogous to
                  &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
                  documentation.                
                <serial>
                                        
                </serial>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <declaration name="multiplier" type="int" line="2341"/>
            <javadoc line="2341">
                The multiplier for use in percent, per mille, etc.                
                <serial>
                                        
                </serial>
                <see>
                    #getMultiplier                    
                </see>
            </javadoc>
            <declaration name="groupingSize" type="byte" line="2347"/>
            <javadoc line="2347">
                The number of digits between grouping separators in the integer
                  portion of a number.  Must be greater than 0 if
                  &lt;code&gt;NumberFormat.groupingUsed&lt;/code&gt; is true.                
                <serial>
                                        
                </serial>
                <see>
                    #getGroupingSize                    
                </see>
                <see>
                    java.text.NumberFormat#isGroupingUsed                    
                </see>
            </javadoc>
            <declaration name="decimalSeparatorAlwaysShown" type="boolean" line="2356"/>
            <javadoc line="2356">
                If true, forces the decimal separator to always appear in a formatted
                  number, even if the fractional part of the number is zero.                
                <serial>
                                        
                </serial>
                <see>
                    #isDecimalSeparatorAlwaysShown                    
                </see>
            </javadoc>
            <declaration name="parseBigDecimal" type="boolean" line="2363"/>
            <javadoc line="2363">
                If true, parse returns BigDecimal wherever possible.                
                <serial>
                                        
                </serial>
                <see>
                    #isParseBigDecimal                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="isCurrencyFormat" type="boolean" line="2370"/>
            <javadoc line="2370">
                True if this object represents a currency format.  This determines
                  whether the monetary decimal separator is used instead of the normal one.                
            </javadoc>
            <declaration name="symbols" type="DecimalFormatSymbols" line="2375"/>
            <javadoc line="2375">
                The &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object used by this format.
                  It contains the symbols used to format numbers, e.g. the grouping separator,
                  decimal separator, and so on.                
                <serial>
                                        
                </serial>
                <see>
                    #setDecimalFormatSymbols                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols                    
                </see>
            </javadoc>
            <declaration name="useExponentialNotation" type="boolean" line="2384"/>
            <javadoc line="2384">
                True to force the use of exponential (i.e. scientific) notation when formatting
                  numbers.                
                <serial>
                                        
                </serial>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="positivePrefixFieldPositions" type="FieldPosition[]" line="2391"/>
            <javadoc line="2391">
                FieldPositions describing the positive prefix String. This is
                  lazily created. Use &lt;code&gt;getPositivePrefixFieldPositions&lt;/code&gt;
                  when needed.                
            </javadoc>
            <declaration name="positiveSuffixFieldPositions" type="FieldPosition[]" line="2397"/>
            <javadoc line="2397">
                FieldPositions describing the positive suffix String. This is
                  lazily created. Use &lt;code&gt;getPositiveSuffixFieldPositions&lt;/code&gt;
                  when needed.                
            </javadoc>
            <declaration name="negativePrefixFieldPositions" type="FieldPosition[]" line="2403"/>
            <javadoc line="2403">
                FieldPositions describing the negative prefix String. This is
                  lazily created. Use &lt;code&gt;getNegativePrefixFieldPositions&lt;/code&gt;
                  when needed.                
            </javadoc>
            <declaration name="negativeSuffixFieldPositions" type="FieldPosition[]" line="2409"/>
            <javadoc line="2409">
                FieldPositions describing the negative suffix String. This is
                  lazily created. Use &lt;code&gt;getNegativeSuffixFieldPositions&lt;/code&gt;
                  when needed.                
            </javadoc>
            <declaration name="minExponentDigits" type="byte" line="2415"/>
            <javadoc line="2415">
                The minimum number of digits used to display the exponent when a number is
                  formatted in exponential notation.  This field is ignored if
                  &lt;code&gt;useExponentialNotation&lt;/code&gt; is not true.                
                <serial>
                                        
                </serial>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="maximumIntegerDigits" type="int" line="2423"/>
            <javadoc line="2423">
                The maximum number of digits allowed in the integer portion of a
                  &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
                  &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to
                  &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.                
                <serial>
                                        
                </serial>
                <see>
                    #getMaximumIntegerDigits                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="minimumIntegerDigits" type="int" line="2433"/>
            <javadoc line="2433">
                The minimum number of digits allowed in the integer portion of a
                  &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
                  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to
                  &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.                
                <serial>
                                        
                </serial>
                <see>
                    #getMinimumIntegerDigits                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="maximumFractionDigits" type="int" line="2443"/>
            <javadoc line="2443">
                The maximum number of digits allowed in the fractional portion of a
                  &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
                  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to
                  &lt;code&gt;minimumFractionDigits&lt;/code&gt;.                
                <serial>
                                        
                </serial>
                <see>
                    #getMaximumFractionDigits                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="minimumFractionDigits" type="int" line="2453"/>
            <javadoc line="2453">
                The minimum number of digits allowed in the fractional portion of a
                  &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
                  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to
                  &lt;code&gt;maximumFractionDigits&lt;/code&gt;.                
                <serial>
                                        
                </serial>
                <see>
                    #getMinimumFractionDigits                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="roundingMode" type="RoundingMode" line="2463"/>
            <javadoc line="2463">
                The {@link java.math.RoundingMode} used in this DecimalFormat.                
                <serial>
                                        
                </serial>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="currentSerialVersion" type="int" line="2469"/>
            <declaration name="serialVersionOnStream" type="int" line="2470"/>
            <javadoc line="2470">
                The internal serial version which says which version was written.
                  Possible values are:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (default): versions before the Java 2 platform v1.2
                  &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: version for 1.2, which includes the two new fields
                  &lt;code&gt;useExponentialNotation&lt;/code&gt; and
                  &lt;code&gt;minExponentDigits&lt;/code&gt;.
                  &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: version for 1.3 and later, which adds four new fields:
                  &lt;code&gt;posPrefixPattern&lt;/code&gt;, &lt;code&gt;posSuffixPattern&lt;/code&gt;,
                  &lt;code&gt;negPrefixPattern&lt;/code&gt;, and &lt;code&gt;negSuffixPattern&lt;/code&gt;.
                  &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: version for 1.5 and later, which adds five new fields:
                  &lt;code&gt;maximumIntegerDigits&lt;/code&gt;,
                  &lt;code&gt;minimumIntegerDigits&lt;/code&gt;,
                  &lt;code&gt;maximumFractionDigits&lt;/code&gt;,
                  &lt;code&gt;minimumFractionDigits&lt;/code&gt;, and
                  &lt;code&gt;parseBigDecimal&lt;/code&gt;.
                  &lt;li&gt;&lt;b&gt;4&lt;/b&gt;: version for 1.6 and later, which adds one new field:
                  &lt;code&gt;roundingMode&lt;/code&gt;.
                  &lt;/ul&gt;                
                <since>
                    1.2                    
                </since>
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="PATTERN_ZERO_DIGIT" type="char" line="2494"/>
            <declaration name="PATTERN_GROUPING_SEPARATOR" type="char" line="2495"/>
            <declaration name="PATTERN_DECIMAL_SEPARATOR" type="char" line="2496"/>
            <declaration name="PATTERN_PER_MILLE" type="char" line="2497"/>
            <declaration name="PATTERN_PERCENT" type="char" line="2498"/>
            <declaration name="PATTERN_DIGIT" type="char" line="2499"/>
            <declaration name="PATTERN_SEPARATOR" type="char" line="2500"/>
            <declaration name="PATTERN_EXPONENT" type="String" line="2501"/>
            <declaration name="PATTERN_MINUS" type="char" line="2502"/>
            <declaration name="CURRENCY_SIGN" type="char" line="2503"/>
            <javadoc line="2503">
                The CURRENCY_SIGN is the standard Unicode symbol for currency.  It
                  is used in patterns and substituted with either the currency symbol,
                  or if it is doubled, with the international currency symbol.  If the
                  CURRENCY_SIGN is seen in a pattern, then the decimal separator is
                  replaced with the monetary decimal separator.
                  The CURRENCY_SIGN is not localized.                
            </javadoc>
            <declaration name="QUOTE" type="char" line="2512"/>
            <declaration name="EmptyFieldPositionArray" type="FieldPosition[]" line="2513"/>
            <declaration name="DOUBLE_INTEGER_DIGITS" type="int" line="2514"/>
            <declaration name="DOUBLE_FRACTION_DIGITS" type="int" line="2515"/>
            <declaration name="MAXIMUM_INTEGER_DIGITS" type="int" line="2516"/>
            <declaration name="MAXIMUM_FRACTION_DIGITS" type="int" line="2517"/>
            <declaration name="serialVersionUID" type="long" line="2518"/>
            <declaration name="cachedLocaleData" type="ConcurrentMap&lt;Locale,String&gt;" line="2519"/>
            <javadoc line="2519">
                Cache to hold the NumberPattern of a Locale.                
            </javadoc>
        </class>
    </source>