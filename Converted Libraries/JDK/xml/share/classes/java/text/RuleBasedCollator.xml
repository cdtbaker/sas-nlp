<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.text.Normalizer"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Locale"/>
        <class name="RuleBasedCollator" line="45">
            <extends class="Collator"/>
            <comment line="248">
                IMPLEMENTATION NOTES:  The implementation of the collation algorithm is
                 divided across three classes: RuleBasedCollator, RBCollationTables, and
                 CollationElementIterator.  RuleBasedCollator contains the collator&apos;s
                 transient state and includes the code that uses the other classes to
                 implement comparison and sort-key building.  RuleBasedCollator also
                 contains the logic to handle French secondary accent sorting.
                 A RuleBasedCollator has two CollationElementIterators.  State doesn&apos;t
                 need to be preserved in these objects between calls to compare() or
                 getCollationKey(), but the objects persist anyway to avoid wasting extra
                 creation time.  compare() and getCollationKey() are synchronized to ensure
                 thread safety with this scheme.  The CollationElementIterator is responsible
                 for generating collation elements from strings and returning one element at
                 a time (sometimes there&apos;s a one-to-many or many-to-one mapping between
                 characters and collation elements-- this class handles that).
                 CollationElementIterator depends on RBCollationTables, which contains the
                 collator&apos;s static state.  RBCollationTables contains the actual data
                 tables specifying the collation order of characters for a particular locale
                 or use.  It also contains the base logic that CollationElementIterator
                 uses to map from characters to collation elements.  A single RBCollationTables
                 object is shared among all RuleBasedCollators for the same locale, and
                 thus by all the CollationElementIterators they create.                
            </comment>
            <comment line="744">
                ==============================================================
                 private
                 ==============================================================                
            </comment>
            <comment line="748">
                need look up in .commit()                
            </comment>
            <comment line="749">
                Expand index follows                
            </comment>
            <comment line="750">
                contract indexes follow                
            </comment>
            <comment line="757">
                Internal objects that are cached across calls so that they don&apos;t have to
                 be created/destroyed on every call to compare() and getCollationKey()                
            </comment>
            <javadoc line="45">
                The &lt;code&gt;RuleBasedCollator&lt;/code&gt; class is a concrete subclass of
                  &lt;code&gt;Collator&lt;/code&gt; that provides a simple, data-driven, table
                  collator.  With this class you can create a customized table-based
                  &lt;code&gt;Collator&lt;/code&gt;.  &lt;code&gt;RuleBasedCollator&lt;/code&gt; maps
                  characters to sort keys.
                  &lt;p&gt;
                  &lt;code&gt;RuleBasedCollator&lt;/code&gt; has the following restrictions
                  for efficiency (other subclasses may be used for more complex languages) :
                  &lt;ol&gt;
                  &lt;li&gt;If a special collation rule controlled by a &amp;lt;modifier&amp;gt; is
                  specified it applies to the whole collator object.
                  &lt;li&gt;All non-mentioned characters are at the end of the
                  collation order.
                  &lt;/ol&gt;
                  &lt;p&gt;
                  The collation table is composed of a list of collation rules, where each
                  rule is of one of three forms:
                  &lt;pre&gt;
                  &amp;lt;modifier&amp;gt;
                  &amp;lt;relation&amp;gt; &amp;lt;text-argument&amp;gt;
                  &amp;lt;reset&amp;gt; &amp;lt;text-argument&amp;gt;
                  &lt;/pre&gt;
                  The definitions of the rule elements is as follows:
                  &lt;UL Type=disc&gt;
                  &lt;LI&gt;&lt;strong&gt;Text-Argument&lt;/strong&gt;: A text-argument is any sequence of
                  characters, excluding special characters (that is, common
                  whitespace characters [0009-000D, 0020] and rule syntax characters
                  [0021-002F, 003A-0040, 005B-0060, 007B-007E]). If those
                  characters are desired, you can put them in single quotes
                  (e.g. ampersand =&gt; &apos;&amp;&apos;). Note that unquoted white space characters
                  are ignored; e.g. &lt;code&gt;b c&lt;/code&gt; is treated as &lt;code&gt;bc&lt;/code&gt;.
                  &lt;LI&gt;&lt;strong&gt;Modifier&lt;/strong&gt;: There are currently two modifiers that
                  turn on special collation rules.
                  &lt;UL Type=square&gt;
                  &lt;LI&gt;&apos;@&apos; : Turns on backwards sorting of accents (secondary
                  differences), as in French.
                  &lt;LI&gt;&apos;!&apos; : Turns on Thai/Lao vowel-consonant swapping.  If this
                  rule is in force when a Thai vowel of the range
                  &amp;#92;U0E40-&amp;#92;U0E44 precedes a Thai consonant of the range
                  &amp;#92;U0E01-&amp;#92;U0E2E OR a Lao vowel of the range &amp;#92;U0EC0-&amp;#92;U0EC4
                  precedes a Lao consonant of the range &amp;#92;U0E81-&amp;#92;U0EAE then
                  the vowel is placed after the consonant for collation
                  purposes.
                  &lt;/UL&gt;
                  &lt;p&gt;&apos;@&apos; : Indicates that accents are sorted backwards, as in French.
                  &lt;LI&gt;&lt;strong&gt;Relation&lt;/strong&gt;: The relations are the following:
                  &lt;UL Type=square&gt;
                  &lt;LI&gt;&apos;&amp;lt;&apos; : Greater, as a letter difference (primary)
                  &lt;LI&gt;&apos;;&apos; : Greater, as an accent difference (secondary)
                  &lt;LI&gt;&apos;,&apos; : Greater, as a case difference (tertiary)
                  &lt;LI&gt;&apos;=&apos; : Equal
                  &lt;/UL&gt;
                  &lt;LI&gt;&lt;strong&gt;Reset&lt;/strong&gt;: There is a single reset
                  which is used primarily for contractions and expansions, but which
                  can also be used to add a modification at the end of a set of rules.
                  &lt;p&gt;&apos;&amp;&apos; : Indicates that the next rule follows the position to where
                  the reset text-argument would be sorted.
                  &lt;/UL&gt;
                  &lt;p&gt;
                  This sounds more complicated than it is in practice. For example, the
                  following are equivalent ways of expressing the same thing:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  a &amp;lt; b &amp;lt; c
                  a &amp;lt; b &amp;amp; b &amp;lt; c
                  a &amp;lt; c &amp;amp; a &amp;lt; b
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  Notice that the order is important, as the subsequent item goes immediately
                  after the text-argument. The following are not equivalent:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  a &amp;lt; b &amp;amp; a &amp;lt; c
                  a &amp;lt; c &amp;amp; a &amp;lt; b
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  Either the text-argument must already be present in the sequence, or some
                  initial substring of the text-argument must be present. (e.g. &quot;a &amp;lt; b &amp;amp; ae &amp;lt;
                  e&quot; is valid since &quot;a&quot; is present in the sequence before &quot;ae&quot; is reset). In
                  this latter case, &quot;ae&quot; is not entered and treated as a single character;
                  instead, &quot;e&quot; is sorted as if it were expanded to two characters: &quot;a&quot;
                  followed by an &quot;e&quot;. This difference appears in natural languages: in
                  traditional Spanish &quot;ch&quot; is treated as though it contracts to a single
                  character (expressed as &quot;c &amp;lt; ch &amp;lt; d&quot;), while in traditional German
                  a-umlaut is treated as though it expanded to two characters
                  (expressed as &quot;a,A &amp;lt; b,B ... &amp;amp;ae;&amp;#92;u00e3&amp;amp;AE;&amp;#92;u00c3&quot;).
                  [&amp;#92;u00e3 and &amp;#92;u00c3 are, of course, the escape sequences for a-umlaut.]
                  &lt;p&gt;
                  &lt;strong&gt;Ignorable Characters&lt;/strong&gt;
                  &lt;p&gt;
                  For ignorable characters, the first rule must start with a relation (the
                  examples we have used above are really fragments; &quot;a &amp;lt; b&quot; really should be
                  &quot;&amp;lt; a &amp;lt; b&quot;). If, however, the first relation is not &quot;&amp;lt;&quot;, then all the all
                  text-arguments up to the first &quot;&amp;lt;&quot; are ignorable. For example, &quot;, - &amp;lt; a &amp;lt; b&quot;
                  makes &quot;-&quot; an ignorable character, as we saw earlier in the word
                  &quot;black-birds&quot;. In the samples for different languages, you see that most
                  accents are ignorable.
                  &lt;p&gt;&lt;strong&gt;Normalization and Accents&lt;/strong&gt;
                  &lt;p&gt;
                  &lt;code&gt;RuleBasedCollator&lt;/code&gt; automatically processes its rule table to
                  include both pre-composed and combining-character versions of
                  accented characters.  Even if the provided rule string contains only
                  base characters and separate combining accent characters, the pre-composed
                  accented characters matching all canonical combinations of characters from
                  the rule string will be entered in the table.
                  &lt;p&gt;
                  This allows you to use a RuleBasedCollator to compare accented strings
                  even when the collator is set to NO_DECOMPOSITION.  There are two caveats,
                  however.  First, if the strings to be collated contain combining
                  sequences that may not be in canonical order, you should set the collator to
                  CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of
                  combining sequences.  Second, if the strings contain characters with
                  compatibility decompositions (such as full-width and half-width forms),
                  you must use FULL_DECOMPOSITION, since the rule tables only include
                  canonical mappings.
                  &lt;p&gt;&lt;strong&gt;Errors&lt;/strong&gt;
                  &lt;p&gt;
                  The following are errors:
                  &lt;UL Type=disc&gt;
                  &lt;LI&gt;A text-argument contains unquoted punctuation symbols
                  (e.g. &quot;a &amp;lt; b-c &amp;lt; d&quot;).
                  &lt;LI&gt;A relation or reset character not followed by a text-argument
                  (e.g. &quot;a &amp;lt; ,b&quot;).
                  &lt;LI&gt;A reset where the text-argument (or an initial substring of the
                  text-argument) is not already in the sequence.
                  (e.g. &quot;a &amp;lt; b &amp;amp; e &amp;lt; f&quot;)
                  &lt;/UL&gt;
                  If you produce one of these errors, a &lt;code&gt;RuleBasedCollator&lt;/code&gt; throws
                  a &lt;code&gt;ParseException&lt;/code&gt;.
                  &lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;
                  &lt;p&gt;Simple:     &quot;&amp;lt; a &amp;lt; b &amp;lt; c &amp;lt; d&quot;
                  &lt;p&gt;Norwegian:  &quot;&amp;lt; a, A &amp;lt; b, B &amp;lt; c, C &amp;lt; d, D &amp;lt; e, E &amp;lt; f, F
                  &amp;lt; g, G &amp;lt; h, H &amp;lt; i, I &amp;lt; j, J &amp;lt; k, K &amp;lt; l, L
                  &amp;lt; m, M &amp;lt; n, N &amp;lt; o, O &amp;lt; p, P &amp;lt; q, Q &amp;lt; r, R
                  &amp;lt; s, S &amp;lt; t, T &amp;lt; u, U &amp;lt; v, V &amp;lt; w, W &amp;lt; x, X
                  &amp;lt; y, Y &amp;lt; z, Z
                  &amp;lt; &amp;#92;u00E6, &amp;#92;u00C6
                  &amp;lt; &amp;#92;u00F8, &amp;#92;u00D8
                  &amp;lt; &amp;#92;u00E5 = a&amp;#92;u030A, &amp;#92;u00C5 = A&amp;#92;u030A;
                  aa, AA&quot;
                  &lt;p&gt;
                  To create a &lt;code&gt;RuleBasedCollator&lt;/code&gt; object with specialized
                  rules tailored to your needs, you construct the &lt;code&gt;RuleBasedCollator&lt;/code&gt;
                  with the rules contained in a &lt;code&gt;String&lt;/code&gt; object. For example:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  String simple = &quot;&amp;lt; a&amp;lt; b&amp;lt; c&amp;lt; d&quot;;
                  RuleBasedCollator mySimple = new RuleBasedCollator(simple);
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  Or:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  String Norwegian = &quot;&amp;lt; a, A &amp;lt; b, B &amp;lt; c, C &amp;lt; d, D &amp;lt; e, E &amp;lt; f, F &amp;lt; g, G &amp;lt; h, H &amp;lt; i, I&quot; +
                  &quot;&amp;lt; j, J &amp;lt; k, K &amp;lt; l, L &amp;lt; m, M &amp;lt; n, N &amp;lt; o, O &amp;lt; p, P &amp;lt; q, Q &amp;lt; r, R&quot; +
                  &quot;&amp;lt; s, S &amp;lt; t, T &amp;lt; u, U &amp;lt; v, V &amp;lt; w, W &amp;lt; x, X &amp;lt; y, Y &amp;lt; z, Z&quot; +
                  &quot;&amp;lt; &amp;#92;u00E6, &amp;#92;u00C6&quot; +     // Latin letter ae &amp; AE
                  &quot;&amp;lt; &amp;#92;u00F8, &amp;#92;u00D8&quot; +     // Latin letter o &amp; O with stroke
                  &quot;&amp;lt; &amp;#92;u00E5 = a&amp;#92;u030A,&quot; +  // Latin letter a with ring above
                  &quot;  &amp;#92;u00C5 = A&amp;#92;u030A;&quot; +  // Latin letter A with ring above
                  &quot;  aa, AA&quot;;
                  RuleBasedCollator myNorwegian = new RuleBasedCollator(Norwegian);
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  A new collation rules string can be created by concatenating rules
                  strings. For example, the rules returned by {@link #getRules()} could
                  be concatenated to combine multiple &lt;code&gt;RuleBasedCollator&lt;/code&gt;s.
                  &lt;p&gt;
                  The following example demonstrates how to change the order of
                  non-spacing accents,
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  // old rule
                  String oldRules = &quot;=&amp;#92;u0301;&amp;#92;u0300;&amp;#92;u0302;&amp;#92;u0308&quot;    // main accents
                  + &quot;;&amp;#92;u0327;&amp;#92;u0303;&amp;#92;u0304;&amp;#92;u0305&quot;    // main accents
                  + &quot;;&amp;#92;u0306;&amp;#92;u0307;&amp;#92;u0309;&amp;#92;u030A&quot;    // main accents
                  + &quot;;&amp;#92;u030B;&amp;#92;u030C;&amp;#92;u030D;&amp;#92;u030E&quot;    // main accents
                  + &quot;;&amp;#92;u030F;&amp;#92;u0310;&amp;#92;u0311;&amp;#92;u0312&quot;    // main accents
                  + &quot;&amp;lt; a , A ; ae, AE ; &amp;#92;u00e6 , &amp;#92;u00c6&quot;
                  + &quot;&amp;lt; b , B &amp;lt; c, C &amp;lt; e, E &amp; C &amp;lt; d, D&quot;;
                  // change the order of accent characters
                  String addOn = &quot;&amp; &amp;#92;u0300 ; &amp;#92;u0308 ; &amp;#92;u0302&quot;;
                  RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;                
                <see>
                    Collator                    
                </see>
                <see>
                    CollationElementIterator                    
                </see>
                <author>
                    Helena Shih, Laura Werner, Richard Gillam                    
                </author>
            </javadoc>
            <javadoc line="269">
                RuleBasedCollator constructor.  This takes the table rules and builds
                  a collation table out of them.  Please see RuleBasedCollator class
                  description for more details on the collation rule syntax.                
                <see>
                    java.util.Locale                    
                </see>
                <param>
                    rules the collation rules to build the collation table from.                    
                </param>
                <exception>
                    ParseException A format exception
                      will be thrown if the build process of the rules fails. For
                      example, build rule &quot;a &lt; ? &lt; d&quot; will cause the constructor to
                      throw the ParseException because the &apos;?&apos; is not quoted.                    
                </exception>
            </javadoc>
            <method name="RuleBasedCollator" type="constructor" line="280">
                <params>
                    <param name="rules" type="String"/>
                </params>
            </method>
            <javadoc line="284">
                RuleBasedCollator constructor.  This takes the table rules and builds
                  a collation table out of them.  Please see RuleBasedCollator class
                  description for more details on the collation rule syntax.                
                <see>
                    java.util.Locale                    
                </see>
                <param>
                    rules the collation rules to build the collation table from.                    
                </param>
                <param>
                    decomp the decomposition strength used to build the
                      collation table and to perform comparisons.                    
                </param>
                <exception>
                    ParseException A format exception
                      will be thrown if the build process of the rules fails. For
                      example, build rule &quot;a &lt; ? &lt; d&quot; will cause the constructor to
                      throw the ParseException because the &apos;?&apos; is not quoted.                    
                </exception>
            </javadoc>
            <method name="RuleBasedCollator" type="constructor" line="297">
                <params>
                    <param name="rules" type="String"/>
                    <param name="decomp" type="int"/>
                </params>
            </method>
            <javadoc line="303">
                &quot;Copy constructor.&quot;  Used in clone() for performance.                
            </javadoc>
            <method name="RuleBasedCollator" type="constructor" line="306">
                <params>
                    <param name="that" type="RuleBasedCollator"/>
                </params>
            </method>
            <javadoc line="312">
                Gets the table-based rules for the collation object.                
                <return>
                    returns the collation rules that the table collation object
                      was created from.                    
                </return>
            </javadoc>
            <method name="getRules" type="String" line="318"/>
            <javadoc line="322">
                Return a CollationElementIterator for the given String.                
                <see>
                    java.text.CollationElementIterator                    
                </see>
            </javadoc>
            <method name="getCollationElementIterator" type="CollationElementIterator" line="326">
                <params>
                    <param name="source" type="String"/>
                </params>
            </method>
            <javadoc line="330">
                Return a CollationElementIterator for the given String.                
                <see>
                    java.text.CollationElementIterator                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getCollationElementIterator" type="CollationElementIterator" line="336">
                <params>
                    <param name="source" type="CharacterIterator"/>
                </params>
            </method>
            <javadoc line="340">
                Compares the character data stored in two different strings based on the
                  collation rules.  Returns information about whether a string is less
                  than, greater than or equal to another string in a language.
                  This can be overriden in a subclass.                
                <exception>
                    NullPointerException if &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;target&lt;/code&gt; is null.                    
                </exception>
            </javadoc>
            <method name="compare" type="int" line="349">
                <params>
                    <param name="source" type="String"/>
                    <param name="target" type="String"/>
                </params>
                <comment line="355">
                    The basic algorithm here is that we use CollationElementIterators
                     to step through both the source and target strings.  We compare each
                     collation element in the source string against the corresponding one
                     in the target, checking for differences.
                    
                     If a difference is found, we set &lt;result&gt; to LESS or GREATER to
                     indicate whether the source string is less or greater than the target.
                    
                     However, it&apos;s not that simple.  If we find a tertiary difference
                     (e.g. &apos;A&apos; vs. &apos;a&apos;) near the beginning of a string, it can be
                     overridden by a primary difference (e.g. &quot;A&quot; vs. &quot;B&quot;) later in
                     the string.  For example, &quot;AA&quot; &lt; &quot;aB&quot;, even though &apos;A&apos; &gt; &apos;a&apos;.
                    
                     To keep track of this, we use strengthResult to keep track of the
                     strength of the most significant difference that has been found
                     so far.  When we find a difference whose strength is greater than
                     strengthResult, it overrides the last difference (if any) that
                     was found.                    
                </comment>
                <comment line="396">
                    Get the next collation element in each of the strings, unless
                     we&apos;ve been requested to skip it.                    
                </comment>
                <comment line="401">
                    If we&apos;ve hit the end of one of the strings, jump out of the loop                    
                </comment>
                <comment line="409">
                    If there&apos;s no difference at this position, we can skip it                    
                </comment>
                <comment line="413">
                    in french, a secondary difference more to the right is stronger,
                     so accents have to be checked with each base element                    
                </comment>
                <comment line="416">
                    but tertiary differences are less important than the first
                     secondary difference, so checking tertiary remains disabled                    
                </comment>
                <comment line="424">
                    Compare primary differences first.                    
                </comment>
                <comment line="428">
                    The entire source element is ignorable.
                     Skip to the next source element, but don&apos;t fetch another target element.                    
                </comment>
                <comment line="438">
                    The source and target elements aren&apos;t ignorable, but it&apos;s still possible
                     for the primary component of one of the elements to be ignorable....                    
                </comment>
                <comment line="441">
                    primary order in source is ignorable                    
                </comment>
                <comment line="443">
                    The source&apos;s primary is ignorable, but the target&apos;s isn&apos;t.  We treat ignorables
                     as a secondary difference, so remember that we found one.                    
                </comment>
                <comment line="446">
                    (strength is SECONDARY)                    
                </comment>
                <comment line="449">
                    Skip to the next source element, but don&apos;t fetch another target element.                    
                </comment>
                <comment line="454">
                    record differences - see the comment above.                    
                </comment>
                <comment line="456">
                    (strength is SECONDARY)                    
                </comment>
                <comment line="459">
                    Skip to the next source element, but don&apos;t fetch another target element.                    
                </comment>
                <comment line="462">
                    Neither of the orders is ignorable, and we already know that the primary
                     orders are different because of the (pSOrder != pTOrder) test above.
                     Record the difference and stop the comparison.                    
                </comment>
                <comment line="466">
                    (strength is PRIMARY)                    
                </comment>
                <comment line="468">
                    (strength is PRIMARY)                    
                </comment>
                <comment line="471">
                    else of if ( pSOrder != pTOrder )                    
                </comment>
                <comment line="472">
                    primary order is the same, but complete order is different. So there
                     are no base elements at this point, only ignorables (Since the strings are
                     normalized)                    
                </comment>
                <comment line="477">
                    a secondary or tertiary difference may still matter                    
                </comment>
                <comment line="481">
                    there is a secondary difference                    
                </comment>
                <comment line="483">
                    (strength is SECONDARY)                    
                </comment>
                <comment line="485">
                    (even in french, only the first secondary difference within
                      a base character matters)                    
                </comment>
                <comment line="489">
                    a tertiary difference may still matter                    
                </comment>
                <comment line="493">
                    there is a tertiary difference                    
                </comment>
                <comment line="495">
                    (strength is TERTIARY)                    
                </comment>
                <comment line="500">
                    if (checkSecTer)                    
                </comment>
                <comment line="502">
                    if ( pSOrder != pTOrder )                    
                </comment>
                <comment line="503">
                    while()                    
                </comment>
                <comment line="506">
                    (tOrder must be CollationElementIterator::NULLORDER,
                      since this point is only reached when sOrder or tOrder is NULLORDER.)
                     The source string has more elements, but the target string hasn&apos;t.                    
                </comment>
                <comment line="511">
                    We found an additional non-ignorable base character in the source string.
                     This is a primary difference, so the source is greater                    
                </comment>
                <comment line="513">
                    (strength is PRIMARY)                    
                </comment>
                <comment line="516">
                    Additional secondary elements mean the source string is greater                    
                </comment>
                <comment line="518">
                    (strength is SECONDARY)                    
                </comment>
                <comment line="525">
                    The target string has more elements, but the source string hasn&apos;t.                    
                </comment>
                <comment line="528">
                    We found an additional non-ignorable base character in the target string.
                     This is a primary difference, so the source is less                    
                </comment>
                <comment line="530">
                    (strength is PRIMARY)                    
                </comment>
                <comment line="532">
                    Additional secondary elements in the target mean the source string is less                    
                </comment>
                <comment line="534">
                    (strength is SECONDARY)                    
                </comment>
                <comment line="541">
                    For IDENTICAL comparisons, we use a bitwise character comparison
                     as a tiebreaker if all else is equal                    
                </comment>
                <scope line="350"/>
                <declaration name="result" type="int" line="373"/>
                <scope line="375"/>
                <scope line="377"/>
                <scope line="380"/>
                <scope line="382"/>
                <declaration name="sOrder" type="int" line="386"/>
                <declaration name="initialCheckSecTer" type="boolean" line="388"/>
                <declaration name="checkSecTer" type="boolean" line="389"/>
                <declaration name="checkTertiary" type="boolean" line="390"/>
                <declaration name="gets" type="boolean" line="392"/>
                <scope line="394">
                    <declaration name="pSOrder" type="int" line="405"/>
                    <declaration name="pTOrder" type="int" line="406"/>
                    <scope line="409">
                        <scope line="410">
                            <scope line="411"/>
                        </scope>
                    </scope>
                    <scope line="425">
                        <scope line="426"/>
                        <scope line="432"/>
                        <scope line="441">
                            <scope line="444"/>
                        </scope>
                        <scope line="452">
                            <scope line="454"/>
                        </scope>
                        <scope line="460">
                            <scope line="464"/>
                            <scope line="466"/>
                        </scope>
                    </scope>
                    <scope line="470">
                        <scope line="475">
                            <declaration name="secSOrder" type="short" line="477"/>
                            <declaration name="secTOrder" type="short" line="478"/>
                            <scope line="479"/>
                            <scope line="486">
                                <scope line="487">
                                    <declaration name="terSOrder" type="short" line="489"/>
                                    <declaration name="terTOrder" type="short" line="490"/>
                                    <scope line="491"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="504">
                    <scope line="508">
                        <scope line="509"/>
                        <scope line="514">
                            <scope line="516"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="523">
                    <scope line="525">
                        <scope line="530">
                            <scope line="532"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="542">
                    <declaration name="mode" type="int" line="543"/>
                    <declaration name="form" type="Normalizer.Form" line="544"/>
                    <scope line="545"/>
                    <scope line="547"/>
                    <scope line="549"/>
                    <declaration name="sourceDecomposition" type="String" line="553"/>
                    <declaration name="targetDecomposition" type="String" line="554"/>
                </scope>
            </method>
            <javadoc line="560">
                Transforms the string into a series of characters that can be compared
                  with CollationKey.compareTo. This overrides java.text.Collator.getCollationKey.
                  It can be overriden in a subclass.                
            </javadoc>
            <method name="getCollationKey" type="CollationKey" line="566">
                <params>
                    <param name="source" type="String"/>
                </params>
                <comment line="568">
                    The basic algorithm here is to find all of the collation elements for each
                     character in the source string, convert them to a char representation,
                     and put them into the collation key.  But it&apos;s trickier than that.
                     Each collation element in a string has three components: primary (A vs B),
                     secondary (A vs A-acute), and tertiary (A&apos; vs a); and a primary difference
                     at the end of a string takes precedence over a secondary or tertiary
                     difference earlier in the string.
                    
                     To account for this, we put all of the primary orders at the beginning of the
                     string, followed by the secondary and tertiary orders, separated by nulls.
                    
                     Here&apos;s a hypothetical example, with the collation element represented as
                     a three-digit number, one digit for primary, one for secondary, etc.
                    
                     String:              A     a     B   \u00e9 &lt;--(e-acute)
                     Collation Elements: 101   100   201  510
                    
                     Collation Key:      1125&lt;null&gt;0001&lt;null&gt;1010
                    
                     To make things even trickier, secondary differences (accent marks) are compared
                     starting at the *end* of the string in languages with French secondary ordering.
                     But when comparing the accent marks on a single base character, they are compared
                     from the beginning.  To handle this, we reverse all of the accents that belong
                     to each base character, then we reverse the entire string of secondary orderings
                     at the end.  Taking the same example above, a French collator might return
                     this instead:
                    
                     Collation Key:      1125&lt;null&gt;1000&lt;null&gt;1010                    
                </comment>
                <comment line="623">
                    walk through each character                    
                </comment>
                <comment line="635">
                    accumulate all of the ignorable/secondary characters attached
                     to a given base character                    
                </comment>
                <comment line="640">
                    We&apos;re doing reversed secondary ordering and we&apos;ve hit a base
                     (non-ignorable) character.  Reverse any secondary orderings
                     that applied to the last base character.  (see block comment above.)                    
                </comment>
                <comment line="647">
                    Remember where we are in the secondary orderings - this is how far
                     back to go if we need to reverse them later.                    
                </comment>
                <comment line="669">
                    If we&apos;ve accumlated any secondary characters after the last base character,
                     reverse them.                    
                </comment>
                <comment line="673">
                    And now reverse the entire secResult to get French secondary ordering.                    
                </comment>
                <scope line="600"/>
                <scope line="604"/>
                <declaration name="order" type="int" line="609"/>
                <declaration name="compareSec" type="boolean" line="610"/>
                <declaration name="compareTer" type="boolean" line="611"/>
                <declaration name="secOrder" type="int" line="612"/>
                <declaration name="terOrder" type="int" line="613"/>
                <declaration name="preSecIgnore" type="int" line="614"/>
                <scope line="616"/>
                <scope line="618"/>
                <scope line="625">
                    <scope line="629">
                        <scope line="633">
                            <scope line="638"/>
                        </scope>
                        <scope line="651"/>
                    </scope>
                    <scope line="656"/>
                </scope>
                <scope line="666">
                    <scope line="667"/>
                </scope>
                <scope line="680">
                    <declaration name="mode" type="int" line="682"/>
                    <scope line="683"/>
                    <scope line="685"/>
                    <scope line="687"/>
                </scope>
            </method>
            <javadoc line="694">
                Standard override; no change in semantics.                
            </javadoc>
            <method name="clone" type="Object" line="697">
                <comment line="699">
                    if we know we&apos;re not actually a subclass of RuleBasedCollator
                     (this class really should have been made final), bypass
                     Object.clone() and use our &quot;copy constructor&quot;.  This is faster.                    
                </comment>
                <scope line="701"/>
                <scope line="704">
                    <declaration name="result" type="RuleBasedCollator" line="705"/>
                </scope>
            </method>
            <javadoc line="715">
                Compares the equality of two collation objects.                
                <param>
                    obj the table-based collation object to be compared with this.                    
                </param>
                <return>
                    true if the current table-based collation object is the same
                      as the table-based collation object obj; false otherwise.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="721">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="724">
                    super does class check                    
                </comment>
                <comment line="726">
                    all other non-transient information is also contained in rules.                    
                </comment>
                <declaration name="other" type="RuleBasedCollator" line="724"/>
            </method>
            <javadoc line="729">
                Generates the hash code for the table-based collation object                
            </javadoc>
            <method name="hashCode" type="int" line="732"/>
            <javadoc line="736">
                Allows CollationElementIterator access to the tables object                
            </javadoc>
            <method name="getTables" type="RBCollationTables" line="739"/>
            <declaration name="CHARINDEX" type="int" line="747"/>
            <declaration name="EXPANDCHARINDEX" type="int" line="748"/>
            <declaration name="CONTRACTCHARINDEX" type="int" line="749"/>
            <declaration name="UNMAPPED" type="int" line="750"/>
            <declaration name="COLLATIONKEYOFFSET" type="int" line="752"/>
            <declaration name="tables" type="RBCollationTables" line="754"/>
            <declaration name="primResult" type="StringBuffer" line="758"/>
            <declaration name="secResult" type="StringBuffer" line="759"/>
            <declaration name="terResult" type="StringBuffer" line="760"/>
            <declaration name="sourceCursor" type="CollationElementIterator" line="761"/>
            <declaration name="targetCursor" type="CollationElementIterator" line="762"/>
        </class>
    </source>