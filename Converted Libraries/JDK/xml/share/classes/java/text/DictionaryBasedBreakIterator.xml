<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.util.Vector"/>
        <import package="java.util.Stack"/>
        <import package="java.util.Hashtable"/>
        <import package="java.text.CharacterIterator"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <class name="DictionaryBasedBreakIterator" line="50">
            <extends class="RuleBasedBreakIterator"/>
            <javadoc line="50">
                A subclass of RuleBasedBreakIterator that adds the ability to use a dictionary
                  to further subdivide ranges of text beyond what is possible using just the
                  state-table-based algorithm.  This is necessary, for example, to handle
                  word and line breaking in Thai, which doesn&apos;t use spaces between words.  The
                  state-table-based algorithm used by RuleBasedBreakIterator is used to divide
                  up text as far as possible, and then contiguous ranges of letters are
                  repeatedly compared against a list of known words (i.e., the dictionary)
                  to divide them up into words.
                  DictionaryBasedBreakIterator uses the same rule language as RuleBasedBreakIterator,
                  but adds one more special substitution name: &amp;lt;dictionary&amp;gt;.  This substitution
                  name is used to identify characters in words in the dictionary.  The idea is that
                  if the iterator passes over a chunk of text that includes two or more characters
                  in a row that are included in &amp;lt;dictionary&amp;gt;, it goes back through that range and
                  derives additional break positions (if possible) using the dictionary.
                  DictionaryBasedBreakIterator is also constructed with the filename of a dictionary
                  file.  It follows a prescribed search path to locate the dictionary (right now,
                  it looks for it in /com/ibm/text/resources in each directory in the classpath,
                  and won&apos;t find it in JAR files, but this location is likely to change).  The
                  dictionary file is in a serialized binary format.  We have a very primitive (and
                  slow) BuildDictionaryFile utility for creating dictionary files, but aren&apos;t
                  currently making it public.  Contact us for help.                
            </javadoc>
            <declaration name="dictionary" type="BreakDictionary" line="77"/>
            <javadoc line="77">
                a list of known words that is used to divide up contiguous ranges of letters,
                  stored in a compressed, indexed, format that offers fast access                
            </javadoc>
            <declaration name="categoryFlags" type="boolean[]" line="83"/>
            <javadoc line="83">
                a list of flags indicating which character categories are contained in
                  the dictionary file (this is used to determine which ranges of characters
                  to apply the dictionary to)                
            </javadoc>
            <declaration name="dictionaryCharCount" type="int" line="90"/>
            <javadoc line="90">
                a temporary hiding place for the number of dictionary characters in the
                  last range passed over by next()                
            </javadoc>
            <declaration name="cachedBreakPositions" type="int[]" line="96"/>
            <javadoc line="96">
                when a range of characters is divided up using the dictionary, the break
                  positions that are discovered are stored here, preventing us from having
                  to use either the dictionary or the state table again until the iterator
                  leaves this range of text                
            </javadoc>
            <declaration name="positionInCache" type="int" line="104"/>
            <javadoc line="104">
                if cachedBreakPositions is not null, this indicates which item in the
                  cache the current iteration position refers to                
            </javadoc>
            <javadoc line="110">
                Constructs a DictionaryBasedBreakIterator.                
                <param>
                    description Same as the description parameter on RuleBasedBreakIterator,
                      except for the special meaning of "<dictionary>".  This parameter is just
                      passed through to RuleBasedBreakIterator's constructor.                    
                </param>
                <param>
                    dictionaryFilename The filename of the dictionary file to use                    
                </param>
            </javadoc>
            <method name="DictionaryBasedBreakIterator" type="constructor" line="118">
                <params>
                    <param name="dataFile" type="String"/>
                    <param name="dictionaryFile" type="String"/>
                </params>
                <declaration name="tmp" type="byte[]" line="120"/>
                <scope line="121"/>
            </method>
            <method name="prepareCategoryFlags" type="void" line="128">
                <params>
                    <param name="data" type="byte[]"/>
                </params>
                <scope line="130"/>
            </method>
            <method name="setText" type="void" line="135">
                <params>
                    <param name="newText" type="CharacterIterator"/>
                </params>
            </method>
            <javadoc line="142">
                Sets the current iteration position to the beginning of the text.
                  (i.e., the CharacterIterator&apos;s starting offset).                
                <return>
                    The offset of the beginning of the text.                    
                </return>
            </javadoc>
            <method name="first" type="int" line="147"/>
            <javadoc line="154">
                Sets the current iteration position to the end of the text.
                  (i.e., the CharacterIterator&apos;s ending offset).                
                <return>
                    The text's past-the-end offset.                    
                </return>
            </javadoc>
            <method name="last" type="int" line="159"/>
            <javadoc line="166">
                Advances the iterator one step backwards.                
                <return>
                    The position of the last boundary position before the
                      current iteration position                    
                </return>
            </javadoc>
            <method name="previous" type="int" line="171">
                <comment line="174">
                    if we have cached break positions and we&apos;re still in the range                    
                </comment>
                <comment line="175">
                    covered by them, just move one step backward in the cache                    
                </comment>
                <comment line="182">
                    otherwise, dump the cache and use the inherited previous() method to move                    
                </comment>
                <comment line="183">
                    backward.  This may fill up the cache with new break positions, in which                    
                </comment>
                <comment line="184">
                    case we have to mark our position in the cache                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="172"/>
                <scope line="176"/>
                <scope line="185">
                    <declaration name="result" type="int" line="187"/>
                    <scope line="188"/>
                </scope>
            </method>
            <javadoc line="195">
                Sets the current iteration position to the last boundary position
                  before the specified position.                
                <param>
                    offset The position to begin searching from                    
                </param>
                <return>
                    The position of the last boundary before "offset"                    
                </return>
            </javadoc>
            <method name="preceding" type="int" line="201">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <comment line="205">
                    if we have no cached break positions, or &quot;offset&quot; is outside the                    
                </comment>
                <comment line="206">
                    range covered by the cache, we can just call the inherited routine                    
                </comment>
                <comment line="207">
                    (which will eventually call other routines in this class that may                    
                </comment>
                <comment line="208">
                    refresh the cache)                    
                </comment>
                <comment line="215">
                    on the other hand, if &quot;offset&quot; is within the range covered by the cache,                    
                </comment>
                <comment line="216">
                    then all we have to do is search the cache for the last break position                    
                </comment>
                <comment line="217">
                    before &quot;offset&quot;                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="202"/>
                <scope line="210"/>
                <scope line="218">
                    <scope line="221"/>
                </scope>
            </method>
            <javadoc line="230">
                Sets the current iteration position to the first boundary position after
                  the specified position.                
                <param>
                    offset The position to begin searching forward from                    
                </param>
                <return>
                    The position of the first boundary after "offset"                    
                </return>
            </javadoc>
            <method name="following" type="int" line="236">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <comment line="240">
                    if we have no cached break positions, or if &quot;offset&quot; is outside the                    
                </comment>
                <comment line="241">
                    range covered by the cache, then dump the cache and call our                    
                </comment>
                <comment line="242">
                    inherited following() method.  This will call other methods in this                    
                </comment>
                <comment line="243">
                    class that may refresh the cache.                    
                </comment>
                <comment line="250">
                    on the other hand, if &quot;offset&quot; is within the range covered by the                    
                </comment>
                <comment line="251">
                    cache, then just search the cache for the first break position                    
                </comment>
                <comment line="252">
                    after &quot;offset&quot;                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="237"/>
                <scope line="245"/>
                <scope line="253">
                    <scope line="256"/>
                </scope>
            </method>
            <javadoc line="264">
                This is the implementation function for next().                
            </javadoc>
            <method name="handleNext" type="int" line="267">
                <comment line="270">
                    if there are no cached break positions, or if we&apos;ve just moved                    
                </comment>
                <comment line="271">
                    off the end of the range covered by the cache, we have to dump                    
                </comment>
                <comment line="272">
                    and possibly regenerate the cache                    
                </comment>
                <comment line="276">
                    start by using the inherited handleNext() to find a tentative return                    
                </comment>
                <comment line="277">
                    value.   dictionaryCharCount tells us how many dictionary characters                    
                </comment>
                <comment line="278">
                    we passed over on our way to the tentative return value                    
                </comment>
                <comment line="283">
                    if we passed over more than one dictionary character, then we use                    
                </comment>
                <comment line="284">
                    divideUpDictionaryRange() to regenerate the cached break positions                    
                </comment>
                <comment line="285">
                    for the new range                    
                </comment>
                <comment line="290">
                    otherwise, the value we got back from the inherited fuction                    
                </comment>
                <comment line="291">
                    is our return value, and we can dump the cache                    
                </comment>
                <comment line="298">
                    if the cache of break positions has been regenerated (or existed all                    
                </comment>
                <comment line="299">
                    along), then just advance to the next break position in the cache                    
                </comment>
                <comment line="300">
                    and return it                    
                </comment>
                <comment line="306">
                    SHOULD NEVER GET HERE!                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="268"/>
                <scope line="274">
                    <declaration name="startPos" type="int" line="279"/>
                    <declaration name="result" type="int" line="281"/>
                    <scope line="286"/>
                    <scope line="292"/>
                </scope>
                <scope line="301"/>
            </method>
            <javadoc line="309">
                Looks up a character category for a character.                
            </javadoc>
            <method name="lookupCategory" type="int" line="312">
                <params>
                    <param name="c" type="int"/>
                </params>
                <comment line="313">
                    this override of lookupCategory() exists only to keep track of whether we&apos;ve                    
                </comment>
                <comment line="314">
                    passed over any dictionary characters.  It calls the inherited lookupCategory()                    
                </comment>
                <comment line="315">
                    to do the real work, and then checks whether its return value is one of the                    
                </comment>
                <comment line="316">
                    categories represented in the dictionary.  If it is, bump the dictionary-                    
                </comment>
                <comment line="317">
                    character count.                    
                </comment>
                <declaration name="result" type="int" line="318"/>
                <scope line="319"/>
            </method>
            <javadoc line="325">
                This is the function that actually implements the dictionary-based
                  algorithm.  Given the endpoints of a range of text, it uses the
                  dictionary to determine the positions of any boundaries in this
                  range.  It stores all the boundary positions it discovers in
                  cachedBreakPositions so that we only have to do this work once
                  for each time we enter the range.                
            </javadoc>
            <method name="divideUpDictionaryRange" type="void" line="333">
                <params>
                    <param name="startPos" type="int"/>
                    <param name="endPos" type="int"/>
                </params>
                <comment line="336">
                    the range we&apos;re dividing may begin or end with non-dictionary characters                    
                </comment>
                <comment line="337">
                    (i.e., for line breaking, we may have leading or trailing punctuation                    
                </comment>
                <comment line="338">
                    that needs to be kept with the word).  Seek from the beginning of the                    
                </comment>
                <comment line="339">
                    range to the first dictionary character                    
                </comment>
                <comment line="348">
                    initialize.  We maintain two stacks: currentBreakPositions contains                    
                </comment>
                <comment line="349">
                    the list of break positions that will be returned if we successfully                    
                </comment>
                <comment line="350">
                    finish traversing the whole range now.  possibleBreakPositions lists                    
                </comment>
                <comment line="351">
                    all other possible word ends we&apos;ve passed along the way.  (Whenever                    
                </comment>
                <comment line="352">
                    we reach an error [a sequence of characters that can&apos;t begin any word                    
                </comment>
                <comment line="353">
                    in the dictionary], we back up, possibly delete some breaks from                    
                </comment>
                <comment line="354">
                    currentBreakPositions, move a break from possibleBreakPositions                    
                </comment>
                <comment line="355">
                    to currentBreakPositions, and start over from there.  This process                    
                </comment>
                <comment line="356">
                    continues in this way until we either successfully make it all the way                    
                </comment>
                <comment line="357">
                    across the range, or exhaust all of our combinations of break                    
                </comment>
                <comment line="358">
                    positions.)                    
                </comment>
                <comment line="363">
                    the dictionary is implemented as a trie, which is treated as a state                    
                </comment>
                <comment line="364">
                    machine.  -1 represents the end of a legal word.  Every word in the                    
                </comment>
                <comment line="365">
                    dictionary is represented by a path from the root node to -1.  A path                    
                </comment>
                <comment line="366">
                    that ends in state 0 is an illegal combination of characters.                    
                </comment>
                <comment line="369">
                    these two variables are used for error handling.  We keep track of the                    
                </comment>
                <comment line="370">
                    farthest we&apos;ve gotten through the range being divided, and the combination                    
                </comment>
                <comment line="371">
                    of breaks that got us that far.  If we use up all possible break                    
                </comment>
                <comment line="372">
                    combinations, the text contains an error or a word that&apos;s not in the                    
                </comment>
                <comment line="373">
                    dictionary.  In this case, we &quot;bless&quot; the break positions that got us the                    
                </comment>
                <comment line="374">
                    farthest as real break positions, and then start over from scratch with                    
                </comment>
                <comment line="375">
                    the character where the error occurred.                    
                </comment>
                <comment line="379">
                    initialize (we always exit the loop with a break statement)                    
                </comment>
                <comment line="383">
                    if we can transition to state &quot;-1&quot; from our current state, we&apos;re                    
                </comment>
                <comment line="384">
                    on the last character of a legal word.  Push that position onto                    
                </comment>
                <comment line="385">
                    the possible-break-positions stack                    
                </comment>
                <comment line="390">
                    look up the new state to transition to in the dictionary                    
                </comment>
                <comment line="393">
                    if the character we&apos;re sitting on causes us to transition to                    
                </comment>
                <comment line="394">
                    the &quot;end of word&quot; state, then it was a non-dictionary character                    
                </comment>
                <comment line="395">
                    and we&apos;ve successfully traversed the whole range.  Drop out                    
                </comment>
                <comment line="396">
                    of the loop.                    
                </comment>
                <comment line="402">
                    if the character we&apos;re sitting on causes us to transition to                    
                </comment>
                <comment line="403">
                    the error state, or if we&apos;ve gone off the end of the range                    
                </comment>
                <comment line="404">
                    without transitioning to the &quot;end of word&quot; state, we&apos;ve hit                    
                </comment>
                <comment line="405">
                    an error...                    
                </comment>
                <comment line="408">
                    if this is the farthest we&apos;ve gotten, take note of it in                    
                </comment>
                <comment line="409">
                    case there&apos;s an error in the text                    
                </comment>
                <comment line="415">
                    wrongBreakPositions is a list of all break positions                    
                </comment>
                <comment line="416">
                    we&apos;ve tried starting that didn&apos;t allow us to traverse                    
                </comment>
                <comment line="417">
                    all the way through the text.  Every time we pop a                    
                </comment>
                <comment line="418">
                    break position off of currentBreakPositions, we put it                    
                </comment>
                <comment line="419">
                    into wrongBreakPositions to avoid trying it again later.                    
                </comment>
                <comment line="420">
                    If we make it to this spot, we&apos;re either going to back                    
                </comment>
                <comment line="421">
                    up to a break in possibleBreakPositions and try starting                    
                </comment>
                <comment line="422">
                    over from there, or we&apos;ve exhausted all possible break                    
                </comment>
                <comment line="423">
                    positions and are going to do the fallback procedure.                    
                </comment>
                <comment line="424">
                    This loop prevents us from messing with anything in                    
                </comment>
                <comment line="425">
                    possibleBreakPositions that didn&apos;t work as a starting                    
                </comment>
                <comment line="426">
                    point the last time we tried it (this is to prevent a bunch of                    
                </comment>
                <comment line="427">
                    repetitive checks from slowing down some extreme cases)                    
                </comment>
                <comment line="434">
                    if we&apos;ve used up all possible break-position combinations, there&apos;s                    
                </comment>
                <comment line="435">
                    an error or an unknown word in the text.  In this case, we start                    
                </comment>
                <comment line="436">
                    over, treating the farthest character we&apos;ve reached as the beginning                    
                </comment>
                <comment line="437">
                    of the range, and &quot;blessing&quot; the break positions that got us that                    
                </comment>
                <comment line="438">
                    far as real break positions                    
                </comment>
                <comment line="460">
                    if we still have more break positions we can try, then promote the                    
                </comment>
                <comment line="461">
                    last break in possibleBreakPositions into currentBreakPositions,                    
                </comment>
                <comment line="462">
                    and get rid of all entries in currentBreakPositions that come after                    
                </comment>
                <comment line="463">
                    it.  Then back up to that position and start over from there (i.e.,                    
                </comment>
                <comment line="464">
                    treat that position as the beginning of a new word)                    
                </comment>
                <comment line="477">
                    re-sync &quot;c&quot; for the next go-round, and drop out of the loop if                    
                </comment>
                <comment line="478">
                    we&apos;ve made it off the end of the range                    
                </comment>
                <comment line="485">
                    if we didn&apos;t hit any exceptional conditions on this last iteration,                    
                </comment>
                <comment line="486">
                    just advance to the next character and loop                    
                </comment>
                <comment line="492">
                    dump the last break position in the list, and replace it with the actual                    
                </comment>
                <comment line="493">
                    end of the range (which may be the same character, or may be further on                    
                </comment>
                <comment line="494">
                    because the range actually ended with non-dictionary characters we want to                    
                </comment>
                <comment line="495">
                    keep with the word)                    
                </comment>
                <comment line="501">
                    create a regular array to hold the break positions and copy                    
                </comment>
                <comment line="502">
                    the break positions from the stack to the array (in addition,                    
                </comment>
                <comment line="503">
                    our starting position goes into this array as a break position).                    
                </comment>
                <comment line="504">
                    This array becomes the cache of break positions used by next()                    
                </comment>
                <comment line="505">
                    and previous(), so this is where we actually refresh the cache.                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="334"/>
                <declaration name="c" type="int" line="341"/>
                <declaration name="category" type="int" line="342"/>
                <scope line="343"/>
                <declaration name="currentBreakPositions" type="Stack" line="359"/>
                <declaration name="possibleBreakPositions" type="Stack" line="360"/>
                <declaration name="wrongBreakPositions" type="Vector" line="361"/>
                <declaration name="state" type="int" line="367"/>
                <declaration name="farthestEndPoint" type="int" line="376"/>
                <declaration name="bestBreakPositions" type="Stack" line="377"/>
                <scope line="381">
                    <scope line="386"/>
                    <scope line="397"/>
                    <scope line="406">
                        <scope line="410"/>
                        <declaration name="newStartingSpot" type="Integer" line="428"/>
                        <scope line="430"/>
                        <scope line="439">
                            <scope line="440">
                                <scope line="442"/>
                                <scope line="445"/>
                            </scope>
                            <scope line="449">
                                <scope line="452"/>
                            </scope>
                        </scope>
                        <scope line="465">
                            <declaration name="temp" type="Integer" line="466"/>
                            <declaration name="temp2" type="Object" line="467"/>
                            <scope line="469"/>
                        </scope>
                        <scope line="480"/>
                    </scope>
                    <scope line="487"/>
                </scope>
                <scope line="496"/>
                <scope line="509"/>
            </method>
        </class>
    </source>