<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.util.Vector"/>
        <import package="java.util.Stack"/>
        <import package="java.util.Hashtable"/>
        <import package="java.text.CharacterIterator"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <class name="DictionaryBasedBreakIterator" line="8">
            <extends class="RuleBasedBreakIterator"/>
            <javadoc line="8">
                A subclass of RuleBasedBreakIterator that adds the ability to use a dictionary
                  to further subdivide ranges of text beyond what is possible using just the
                  state-table-based algorithm.  This is necessary, for example, to handle
                  word and line breaking in Thai, which doesn&apos;t use spaces between words.  The
                  state-table-based algorithm used by RuleBasedBreakIterator is used to divide
                  up text as far as possible, and then contiguous ranges of letters are
                  repeatedly compared against a list of known words (i.e., the dictionary)
                  to divide them up into words.
                  DictionaryBasedBreakIterator uses the same rule language as RuleBasedBreakIterator,
                  but adds one more special substitution name: &amp;lt;dictionary&amp;gt;.  This substitution
                  name is used to identify characters in words in the dictionary.  The idea is that
                  if the iterator passes over a chunk of text that includes two or more characters
                  in a row that are included in &amp;lt;dictionary&amp;gt;, it goes back through that range and
                  derives additional break positions (if possible) using the dictionary.
                  DictionaryBasedBreakIterator is also constructed with the filename of a dictionary
                  file.  It follows a prescribed search path to locate the dictionary (right now,
                  it looks for it in /com/ibm/text/resources in each directory in the classpath,
                  and won&apos;t find it in JAR files, but this location is likely to change).  The
                  dictionary file is in a serialized binary format.  We have a very primitive (and
                  slow) BuildDictionaryFile utility for creating dictionary files, but aren&apos;t
                  currently making it public.  Contact us for help.                
            </javadoc>
            <declaration name="dictionary" type="BreakDictionary" line="32"/>
            <javadoc line="32">
                a list of known words that is used to divide up contiguous ranges of letters,
                  stored in a compressed, indexed, format that offers fast access                
            </javadoc>
            <declaration name="categoryFlags" type="boolean[]" line="37"/>
            <javadoc line="37">
                a list of flags indicating which character categories are contained in
                  the dictionary file (this is used to determine which ranges of characters
                  to apply the dictionary to)                
            </javadoc>
            <declaration name="dictionaryCharCount" type="int" line="43"/>
            <javadoc line="43">
                a temporary hiding place for the number of dictionary characters in the
                  last range passed over by next()                
            </javadoc>
            <declaration name="cachedBreakPositions" type="int[]" line="48"/>
            <javadoc line="48">
                when a range of characters is divided up using the dictionary, the break
                  positions that are discovered are stored here, preventing us from having
                  to use either the dictionary or the state table again until the iterator
                  leaves this range of text                
            </javadoc>
            <declaration name="positionInCache" type="int" line="55"/>
            <javadoc line="55">
                if cachedBreakPositions is not null, this indicates which item in the
                  cache the current iteration position refers to                
            </javadoc>
            <javadoc line="60">
                Constructs a DictionaryBasedBreakIterator.                
                <param>
                    description Same as the description parameter on RuleBasedBreakIterator,
                      except for the special meaning of "<dictionary>".  This parameter is just
                      passed through to RuleBasedBreakIterator's constructor.                    
                </param>
                <param>
                    dictionaryFilename The filename of the dictionary file to use                    
                </param>
            </javadoc>
            <method name="DictionaryBasedBreakIterator" type="constructor" line="67">
                <params>
                    <param name="dataFile" type="String"/>
                    <param name="dictionaryFile" type="String"/>
                </params>
                <declaration name="tmp" type="byte[]" line="69"/>
                <scope line="70"/>
            </method>
            <method name="prepareCategoryFlags" type="void" line="76">
                <params>
                    <param name="data" type="byte[]"/>
                </params>
                <scope line="78"/>
            </method>
            <method name="setText" type="void" line="82">
                <params>
                    <param name="newText" type="CharacterIterator"/>
                </params>
            </method>
            <javadoc line="88">
                Sets the current iteration position to the beginning of the text.
                  (i.e., the CharacterIterator&apos;s starting offset).                
                <return>
                    The offset of the beginning of the text.                    
                </return>
            </javadoc>
            <method name="first" type="int" line="93"/>
            <javadoc line="99">
                Sets the current iteration position to the end of the text.
                  (i.e., the CharacterIterator&apos;s ending offset).                
                <return>
                    The text's past-the-end offset.                    
                </return>
            </javadoc>
            <method name="last" type="int" line="104"/>
            <javadoc line="110">
                Advances the iterator one step backwards.                
                <return>
                    The position of the last boundary position before the
                      current iteration position                    
                </return>
            </javadoc>
            <method name="previous" type="int" line="115">
                <declaration name="text" type="CharacterIterator" line="116"/>
                <scope line="117"/>
                <scope line="122">
                    <declaration name="result" type="int" line="124"/>
                    <scope line="125"/>
                </scope>
            </method>
            <javadoc line="131">
                Sets the current iteration position to the last boundary position
                  before the specified position.                
                <param>
                    offset The position to begin searching from                    
                </param>
                <return>
                    The position of the last boundary before "offset"                    
                </return>
            </javadoc>
            <method name="preceding" type="int" line="137">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <declaration name="text" type="CharacterIterator" line="138"/>
                <scope line="140"/>
                <scope line="144">
                    <scope line="146"/>
                </scope>
            </method>
            <javadoc line="154">
                Sets the current iteration position to the first boundary position after
                  the specified position.                
                <param>
                    offset The position to begin searching forward from                    
                </param>
                <return>
                    The position of the first boundary after "offset"                    
                </return>
            </javadoc>
            <method name="following" type="int" line="160">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <declaration name="text" type="CharacterIterator" line="161"/>
                <scope line="163"/>
                <scope line="167">
                    <scope line="169"/>
                </scope>
            </method>
            <javadoc line="176">
                This is the implementation function for next().                
            </javadoc>
            <method name="handleNext" type="int" line="179">
                <declaration name="text" type="CharacterIterator" line="180"/>
                <scope line="181">
                    <declaration name="startPos" type="int" line="182"/>
                    <declaration name="result" type="int" line="184"/>
                    <scope line="185"/>
                    <scope line="188"/>
                </scope>
                <scope line="193"/>
            </method>
            <javadoc line="200">
                Looks up a character category for a character.                
            </javadoc>
            <method name="lookupCategory" type="int" line="203">
                <params>
                    <param name="c" type="int"/>
                </params>
                <declaration name="result" type="int" line="204"/>
                <scope line="205"/>
            </method>
            <javadoc line="210">
                This is the function that actually implements the dictionary-based
                  algorithm.  Given the endpoints of a range of text, it uses the
                  dictionary to determine the positions of any boundaries in this
                  range.  It stores all the boundary positions it discovers in
                  cachedBreakPositions so that we only have to do this work once
                  for each time we enter the range.                
            </javadoc>
            <method name="divideUpDictionaryRange" type="void" line="218">
                <params>
                    <param name="startPos" type="int"/>
                    <param name="endPos" type="int"/>
                </params>
                <declaration name="text" type="CharacterIterator" line="219"/>
                <declaration name="c" type="int" line="221"/>
                <declaration name="category" type="int" line="222"/>
                <scope line="223"/>
                <declaration name="currentBreakPositions" type="Stack" line="227"/>
                <declaration name="possibleBreakPositions" type="Stack" line="228"/>
                <declaration name="wrongBreakPositions" type="Vector" line="229"/>
                <declaration name="state" type="int" line="230"/>
                <declaration name="farthestEndPoint" type="int" line="231"/>
                <declaration name="bestBreakPositions" type="Stack" line="232"/>
                <scope line="234">
                    <scope line="235"/>
                    <scope line="239"/>
                    <scope line="243">
                        <scope line="244"/>
                        <declaration name="newStartingSpot" type="Integer" line="248"/>
                        <scope line="249"/>
                        <scope line="252">
                            <scope line="253">
                                <scope line="255"/>
                                <scope line="258"/>
                            </scope>
                            <scope line="262">
                                <scope line="263"/>
                            </scope>
                        </scope>
                        <scope line="270">
                            <declaration name="temp" type="Integer" line="271"/>
                            <declaration name="temp2" type="Object" line="272"/>
                            <scope line="273"/>
                        </scope>
                        <scope line="281"/>
                    </scope>
                    <scope line="285"/>
                </scope>
                <scope line="289"/>
                <scope line="295"/>
            </method>
        </class>
    </source>