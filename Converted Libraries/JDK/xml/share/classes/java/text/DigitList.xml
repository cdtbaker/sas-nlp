<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.math.BigDecimal"/>
        <import package="java.math.BigInteger"/>
        <import package="java.math.RoundingMode"/>
        <class name="DigitList" line="45">
            <comment line="80">
                == Long.toString(Long.MAX_VALUE).length()                
            </comment>
            <comment line="678">
                The digit part of -9223372036854775808L                
            </comment>
            <implements interface="Cloneable"/>
            <javadoc line="45">
                Digit List. Private to DecimalFormat.
                  Handles the transcoding
                  between numeric values and strings of characters.  Only handles
                  non-negative numbers.  The division of labor between DigitList and
                  DecimalFormat is that DigitList handles the radix 10 representation
                  issues; DecimalFormat handles the locale-specific issues such as
                  positive/negative, grouping, decimal point, currency, and so on.
                  A DigitList is really a representation of a floating point value.
                  It may be an integer value; we assume that a double has sufficient
                  precision to represent all digits of a long.
                  The DigitList representation consists of a string of characters,
                  which are the digits radix 10, from &apos;0&apos; to &apos;9&apos;.  It also has a radix
                  10 exponent associated with it.  The value represented by a DigitList
                  object can be computed by mulitplying the fraction f, where 0 &lt;= f &lt; 1,
                  derived by placing all the digits of the list to the right of the
                  decimal point, by 10^exponent.                
                <see>
                    Locale                    
                </see>
                <see>
                    Format                    
                </see>
                <see>
                    NumberFormat                    
                </see>
                <see>
                    DecimalFormat                    
                </see>
                <see>
                    ChoiceFormat                    
                </see>
                <see>
                    MessageFormat                    
                </see>
                <author>
                    Mark Davis, Alan Liu                    
                </author>
            </javadoc>
            <declaration name="MAX_COUNT" type="int" line="74"/>
            <javadoc line="74">
                The maximum number of significant digits in an IEEE 754 double, that
                  is, in a Java double.  This must not be increased, or garbage digits
                  will be generated, and should not be decreased, or accuracy will be lost.                
            </javadoc>
            <declaration name="decimalAt" type="int" line="81"/>
            <javadoc line="81">
                These data members are intentionally public and can be set directly.
                  The value represented is given by placing the decimal point before
                  digits[decimalAt].  If decimalAt is &lt; 0, then leading zeros between
                  the decimal point and the first nonzero digit are implied.  If decimalAt
                  is &gt; count, then trailing zeros between the digits[count-1] and the
                  decimal point are implied.
                  Equivalently, the represented value is given by f  10^decimalAt.  Here
                  f is a value 0.1 &lt;= f &lt; 1 arrived at by placing the digits in Digits to
                  the right of the decimal.
                  DigitList is normalized, so if it is non-zero, figits[0] is non-zero.  We
                  don&apos;t allow denormalized numbers because our exponent is effectively of
                  unlimited magnitude.  The count value contains the number of significant
                  digits present in digits[].
                  Zero is represented by any DigitList with count == 0 or with each digits[i]
                  for all i &lt;= count == &apos;0&apos;.                
            </javadoc>
            <declaration name="count" type="int" line="103"/>
            <declaration name="digits" type="char[]" line="104"/>
            <declaration name="data" type="char[]" line="106"/>
            <declaration name="roundingMode" type="RoundingMode" line="107"/>
            <declaration name="isNegative" type="boolean" line="108"/>
            <javadoc line="110">
                Return true if the represented number is zero.                
            </javadoc>
            <method name="isZero" type="boolean" line="113">
                <scope line="114">
                    <scope line="115"/>
                </scope>
            </method>
            <javadoc line="122">
                Set the rounding mode                
            </javadoc>
            <method name="setRoundingMode" type="void" line="125">
                <params>
                    <param name="r" type="RoundingMode"/>
                </params>
            </method>
            <javadoc line="129">
                Clears out the digits.
                  Use before appending them.
                  Typically, you set a series of digits with append, then at the point
                  you hit the decimal point, you set myDigitList.decimalAt = myDigitList.count;
                  then go on appending digits.                
            </javadoc>
            <method name="clear" type="void" line="136"/>
            <javadoc line="141">
                Appends a digit to the list, extending the list when necessary.                
            </javadoc>
            <method name="append" type="void" line="144">
                <params>
                    <param name="digit" type="char"/>
                </params>
                <scope line="145">
                    <declaration name="data" type="char[]" line="146"/>
                </scope>
            </method>
            <javadoc line="153">
                Utility routine to get the value of the digit list
                  If (count == 0) this throws a NumberFormatException, which
                  mimics Long.parseLong().                
            </javadoc>
            <method name="getDouble" type="double" line="158">
                <scope line="159"/>
                <declaration name="temp" type="StringBuffer" line="163"/>
            </method>
            <javadoc line="171">
                Utility routine to get the value of the digit list.
                  If (count == 0) this returns 0, unlike Long.parseLong().                
            </javadoc>
            <method name="getLong" type="long" line="175">
                <comment line="177">
                    for now, simple implementation; later, do proper IEEE native stuff                    
                </comment>
                <comment line="183">
                    We have to check for this, because this is the one NEGATIVE value
                     we represent.  If we tried to just pass the digits off to parseLong,
                     we&apos;d get a parse failure.                    
                </comment>
                <scope line="178"/>
                <scope line="185"/>
                <declaration name="temp" type="StringBuffer" line="189"/>
                <scope line="191"/>
            </method>
            <method name="getBigDecimal" type="BigDecimal" line="197">
                <scope line="198">
                    <scope line="199"/>
                    <scope line="201"/>
                </scope>
                <scope line="206"/>
                <scope line="208"/>
            </method>
            <javadoc line="213">
                Return true if the number represented by this object can fit into
                  a long.                
                <param>
                    isPositive true if this number should be regarded as positive                    
                </param>
                <param>
                    ignoreNegativeZero true if -0 should be regarded as identical to
                      +0; otherwise they are considered distinct                    
                </param>
                <return>
                    true if this number fits into a Java long                    
                </return>
            </javadoc>
            <method name="fitsIntoLong" type="boolean" line="221">
                <params>
                    <param name="isPositive" type="boolean"/>
                    <param name="ignoreNegativeZero" type="boolean"/>
                </params>
                <comment line="223">
                    Figure out if the result will fit in a long.  We have to
                     first look for nonzero digits after the decimal point;
                     then check the size.  If the digit count is 18 or less, then
                     the value can definitely be represented as a long.  If it is 19
                     then it may be too large.                    
                </comment>
                <comment line="229">
                    Trim trailing zeros.  This does not change the represented value.                    
                </comment>
                <comment line="235">
                    Positive zero fits into a long, but negative zero can only
                     be represented as a double. - bug 4162852                    
                </comment>
                <comment line="246">
                    At this point we have decimalAt == count, and count == MAX_COUNT.
                     The number will overflow if it is larger than 9223372036854775807
                     or smaller than -9223372036854775808.                    
                </comment>
                <comment line="255">
                    At this point the first count digits match.  If decimalAt is less
                     than count, then the remaining digits are zero, and we return true.                    
                </comment>
                <comment line="259">
                    Now we have a representation of Long.MIN_VALUE, without the leading
                     negative sign.  If this represents a positive value, then it does
                     not fit; otherwise it fits.                    
                </comment>
                <scope line="229"/>
                <scope line="233"/>
                <scope line="239"/>
                <scope line="248">
                    <declaration name="dig" type="char" line="249"/>
                </scope>
            </method>
            <javadoc line="264">
                Set the digit list to a representation of the given double value.
                  This method supports fixed-point notation.                
                <param>
                    isNegative Boolean value indicating whether the number is negative.                    
                </param>
                <param>
                    source Value to be converted; must not be Inf, -Inf, Nan,
                      or a value <= 0.                    
                </param>
                <param>
                    maximumFractionDigits The most fractional digits which should
                      be converted.                    
                </param>
            </javadoc>
            <method name="set" type="void" line="273">
                <params>
                    <param name="isNegative" type="boolean"/>
                    <param name="source" type="double"/>
                    <param name="maximumFractionDigits" type="int"/>
                </params>
            </method>
            <javadoc line="277">
                Set the digit list to a representation of the given double value.
                  This method supports both fixed-point and exponential notation.                
                <param>
                    isNegative Boolean value indicating whether the number is negative.                    
                </param>
                <param>
                    source Value to be converted; must not be Inf, -Inf, Nan,
                      or a value <= 0.                    
                </param>
                <param>
                    maximumDigits The most fractional or total digits which should
                      be converted.                    
                </param>
                <param>
                    fixedPoint If true, then maximumDigits is the maximum
                      fractional digits to be converted.  If false, total digits.                    
                </param>
            </javadoc>
            <method name="set" type="void" line="288">
                <params>
                    <param name="isNegative" type="boolean"/>
                    <param name="source" type="double"/>
                    <param name="maximumDigits" type="int"/>
                    <param name="fixedPoint" type="boolean"/>
                </params>
            </method>
            <javadoc line="292">
                Generate a representation of the form DDDDD, DDDDD.DDDDD, or
                  DDDDDE+/-DDDDD.                
            </javadoc>
            <method name="set" type="void" line="296">
                <params>
                    <param name="isNegative" type="boolean"/>
                    <param name="s" type="String"/>
                    <param name="maximumDigits" type="int"/>
                    <param name="fixedPoint" type="boolean"/>
                </params>
                <comment line="306">
                    Number of zeros between decimal point and first non-zero digit after
                     decimal point, for numbers &lt; 1.                    
                </comment>
                <comment line="337">
                    The negative of the exponent represents the number of leading
                     zeros between the decimal and the first non-zero digit, for
                     a value &lt; 0.1 (e.g., for 0.00123, -decimalAt == 2).  If this
                     is more than the maximum fraction digits, then we have an underflow
                     for the printed representation.                    
                </comment>
                <comment line="343">
                    Handle an underflow to zero when we round something like
                     0.0009 to 2 fractional digits.                    
                </comment>
                <comment line="348">
                    If we round 0.0009 to 3 fractional digits, then we have to
                     create a new one digit in the least significant location.                    
                </comment>
                <comment line="359">
                    else fall through                    
                </comment>
                <comment line="362">
                    Eliminate trailing zeros.                    
                </comment>
                <comment line="367">
                    Eliminate digits beyond maximum digits to be displayed.
                     Round up if appropriate.                    
                </comment>
                <declaration name="len" type="int" line="298"/>
                <declaration name="source" type="char[]" line="299"/>
                <declaration name="exponent" type="int" line="304"/>
                <declaration name="leadingZerosAfterDecimal" type="int" line="307"/>
                <declaration name="nonZeroDigitSeen" type="boolean" line="308"/>
                <scope line="310">
                    <declaration name="c" type="char" line="311"/>
                    <scope line="312"/>
                    <scope line="314"/>
                    <scope line="317">
                        <scope line="318"/>
                        <scope line="323"/>
                    </scope>
                </scope>
                <scope line="328"/>
                <scope line="331"/>
                <scope line="335">
                    <scope line="341"/>
                    <scope line="346">
                        <scope line="349"/>
                        <scope line="353"/>
                    </scope>
                </scope>
                <scope line="362"/>
            </method>
            <javadoc line="371">
                Round the representation to the given number of digits.                
                <param>
                    maximumDigits The maximum number of digits to be shown.
                      Upon return, count will be less than or equal to maximumDigits.                    
                </param>
            </javadoc>
            <method name="round" type="void" line="376">
                <params>
                    <param name="maximumDigits" type="int"/>
                </params>
                <comment line="378">
                    Eliminate digits beyond maximum digits to be displayed.
                     Round up if appropriate.                    
                </comment>
                <comment line="382">
                    Rounding up involved incrementing digits from LSD to MSD.
                     In most cases this is simple, but in a worst case situation
                     (9999..99) we have to adjust the decimalAt value.                    
                </comment>
                <comment line="388">
                    We have all 9&apos;s, so we increment to a single digit
                     of one and adjust the exponent.                    
                </comment>
                <comment line="392">
                    Adjust the count                    
                </comment>
                <comment line="398">
                    digits[maximumDigits] = &apos;0&apos;; // Unnecessary since we&apos;ll truncate this                    
                </comment>
                <comment line="400">
                    Increment for use as count                    
                </comment>
                <comment line="404">
                    Eliminate trailing zeros.                    
                </comment>
                <scope line="379">
                    <scope line="380">
                        <scope line="384">
                            <scope line="386"/>
                        </scope>
                    </scope>
                    <scope line="404"/>
                </scope>
            </method>
            <javadoc line="411">
                Return true if truncating the representation to the given number
                  of digits will result in an increment to the last digit.  This
                  method implements the rounding modes defined in the
                  java.math.RoundingMode class.
                  [bnf]                
                <param>
                    maximumDigits the number of digits to keep, from 0 to
                      <code>count-1</code>.  If 0, then all digits are rounded away, and
                      this method returns true if a one should be generated (e.g., formatting
                      0.09 with "#.#").                    
                </param>
                <exception>
                    ArithmeticException if rounding is needed with rounding
                      mode being set to RoundingMode.UNNECESSARY                    
                </exception>
                <return>
                    true if digit <code>maximumDigits-1</code> should be
                      incremented                    
                </return>
            </javadoc>
            <method name="shouldRoundUp" type="boolean" line="426">
                <params>
                    <param name="maximumDigits" type="int"/>
                </params>
                <comment line="470">
                    Implement IEEE half-even rounding                    
                </comment>
                <scope line="427">
                    <scope line="430">
                        <scope line="431"/>
                    </scope>
                    <scope line="439">
                        <scope line="440"/>
                    </scope>
                    <scope line="446">
                        <scope line="447"/>
                    </scope>
                    <scope line="453"/>
                    <scope line="458"/>
                    <scope line="460">
                        <scope line="461">
                            <scope line="462"/>
                        </scope>
                    </scope>
                    <scope line="470"/>
                    <scope line="472">
                        <scope line="473">
                            <scope line="474"/>
                        </scope>
                    </scope>
                    <scope line="482">
                        <scope line="483"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="496">
                Utility routine to set the value of the digit list from a long                
            </javadoc>
            <method name="set" type="void" line="499">
                <params>
                    <param name="isNegative" type="boolean"/>
                    <param name="source" type="long"/>
                </params>
            </method>
            <javadoc line="503">
                Set the digit list to a representation of the given long value.                
                <param>
                    isNegative Boolean value indicating whether the number is negative.                    
                </param>
                <param>
                    source Value to be converted; must be >= 0 or ==
                      Long.MIN_VALUE.                    
                </param>
                <param>
                    maximumDigits The most digits which should be converted.
                      If maximumDigits is lower than the number of significant digits
                      in source, the representation will be rounded.  Ignored if <= 0.                    
                </param>
            </javadoc>
            <method name="set" type="void" line="512">
                <params>
                    <param name="isNegative" type="boolean"/>
                    <param name="source" type="long"/>
                    <param name="maximumDigits" type="int"/>
                </params>
                <comment line="516">
                    This method does not expect a negative number. However,
                     &quot;source&quot; can be a Long.MIN_VALUE (-9223372036854775808),
                     if the number being formatted is a Long.MIN_VALUE.  In that
                     case, it will be formatted as -Long.MIN_VALUE, a number
                     which is outside the legal range of a long, but which can
                     be represented by DigitList.                    
                </comment>
                <comment line="527">
                    Values &lt;= 0 format as zero                    
                </comment>
                <comment line="530">
                    Rewritten to improve performance.  I used to call
                     Long.toString(), which was about 4x slower than this code.                    
                </comment>
                <comment line="539">
                    Don&apos;t copy trailing zeros.  We are guaranteed that there is at
                     least one non-zero digit, so we don&apos;t have to check lower bounds.                    
                </comment>
                <scope line="521">
                    <scope line="522"/>
                    <scope line="525"/>
                </scope>
                <scope line="528">
                    <declaration name="left" type="int" line="531"/>
                    <declaration name="right" type="int" line="532"/>
                    <scope line="533"/>
                </scope>
            </method>
            <javadoc line="548">
                Set the digit list to a representation of the given BigDecimal value.
                  This method supports both fixed-point and exponential notation.                
                <param>
                    isNegative Boolean value indicating whether the number is negative.                    
                </param>
                <param>
                    source Value to be converted; must not be a value <= 0.                    
                </param>
                <param>
                    maximumDigits The most fractional or total digits which should
                      be converted.                    
                </param>
                <param>
                    fixedPoint If true, then maximumDigits is the maximum
                      fractional digits to be converted.  If false, total digits.                    
                </param>
            </javadoc>
            <method name="set" type="void" line="558">
                <params>
                    <param name="isNegative" type="boolean"/>
                    <param name="source" type="BigDecimal"/>
                    <param name="maximumDigits" type="int"/>
                    <param name="fixedPoint" type="boolean"/>
                </params>
                <declaration name="s" type="String" line="559"/>
            </method>
            <javadoc line="565">
                Set the digit list to a representation of the given BigInteger value.                
                <param>
                    isNegative Boolean value indicating whether the number is negative.                    
                </param>
                <param>
                    source Value to be converted; must be >= 0.                    
                </param>
                <param>
                    maximumDigits The most digits which should be converted.
                      If maximumDigits is lower than the number of significant digits
                      in source, the representation will be rounded.  Ignored if <= 0.                    
                </param>
            </javadoc>
            <method name="set" type="void" line="573">
                <params>
                    <param name="isNegative" type="boolean"/>
                    <param name="source" type="BigInteger"/>
                    <param name="maximumDigits" type="int"/>
                </params>
                <declaration name="s" type="String" line="575"/>
                <declaration name="len" type="int" line="576"/>
                <declaration name="right" type="int" line="581"/>
                <scope line="586"/>
            </method>
            <javadoc line="591">
                equality test between two digit lists.                
            </javadoc>
            <method name="equals" type="boolean" line="594">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="596">
                    quick check                    
                </comment>
                <comment line="598">
                    (1) same object?                    
                </comment>
                <declaration name="other" type="DigitList" line="599"/>
            </method>
            <javadoc line="609">
                Generates the hash code for the digit list.                
            </javadoc>
            <method name="hashCode" type="int" line="612">
                <declaration name="hashcode" type="int" line="613"/>
                <scope line="615"/>
            </method>
            <javadoc line="622">
                Creates a copy of this object.                
                <return>
                    a clone of this instance.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="626">
                <scope line="627">
                    <declaration name="other" type="DigitList" line="628"/>
                    <declaration name="newDigits" type="char[]" line="629"/>
                </scope>
                <scope line="634"/>
            </method>
            <javadoc line="639">
                Returns true if this DigitList represents Long.MIN_VALUE;
                  false, otherwise.  This is required so that getLong() works.                
            </javadoc>
            <method name="isLongMIN_VALUE" type="boolean" line="643">
                <scope line="644"/>
                <scope line="648"/>
            </method>
            <method name="parseInt" type="int" line="655">
                <params>
                    <param name="str" type="char[]"/>
                    <param name="offset" type="int"/>
                    <param name="strLen" type="int"/>
                </params>
                <declaration name="c" type="char" line="656"/>
                <declaration name="positive" type="boolean" line="657"/>
                <scope line="658"/>
                <scope line="661"/>
                <declaration name="value" type="int" line="665"/>
                <scope line="666">
                    <scope line="668"/>
                    <scope line="670"/>
                </scope>
            </method>
            <declaration name="LONG_MIN_REP" type="char[]" line="678"/>
            <method name="toString" type="String" line="680">
                <scope line="681"/>
                <declaration name="buf" type="StringBuffer" line="684"/>
            </method>
            <declaration name="tempBuffer" type="StringBuffer" line="692"/>
            <method name="getStringBuffer" type="StringBuffer" line="694">
                <scope line="695"/>
                <scope line="697"/>
            </method>
            <method name="extendDigits" type="void" line="703">
                <params>
                    <param name="len" type="int"/>
                </params>
                <scope line="704"/>
            </method>
            <method name="getDataChars" type="char[]" line="709">
                <params>
                    <param name="length" type="int"/>
                </params>
                <scope line="710"/>
            </method>
        </class>
    </source>