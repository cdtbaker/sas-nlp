<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.io"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.util.MissingResourceException"/>
        <import package="sun.text.CompactByteArray"/>
        <import package="sun.text.SupplementaryCharacterData"/>
        <class name="BreakDictionary" line="50">
            <comment line="64">
                =========================================================================
                 data members
                =========================================================================                
            </comment>
            <comment line="134">
                =========================================================================
                 deserialization
                =========================================================================                
            </comment>
            <comment line="258">
                =========================================================================
                 access to the words
                =========================================================================                
            </comment>
            <javadoc line="50">
                This is the class that represents the list of known words used by
                  DictionaryBasedBreakIterator.  The conceptual data structure used
                  here is a trie: there is a node hanging off the root node for every
                  letter that can start a word.  Each of these nodes has a node hanging
                  off of it for every letter that can be the second letter of a word
                  if this node is the first letter, and so on.  The trie is represented
                  as a two-dimensional array that can be treated as a table of state
                  transitions.  Indexes are used to compress this array, taking
                  advantage of the fact that this array will always be very sparse.                
            </javadoc>
            <declaration name="supportedVersion" type="int" line="67"/>
            <javadoc line="67">
                The version of the dictionary that was read in.                
            </javadoc>
            <declaration name="columnMap" type="CompactByteArray" line="72"/>
            <javadoc line="72">
                Maps from characters to column numbers.  The main use of this is to
                  avoid making room in the array for empty columns.                
            </javadoc>
            <declaration name="supplementaryCharColumnMap" type="SupplementaryCharacterData" line="77"/>
            <declaration name="numCols" type="int" line="79"/>
            <javadoc line="79">
                The number of actual columns in the table                
            </javadoc>
            <declaration name="numColGroups" type="int" line="84"/>
            <javadoc line="84">
                Columns are organized into groups of 32.  This says how many
                  column groups.  (We could calculate this, but we store the
                  value to avoid having to repeatedly calculate it.)                
            </javadoc>
            <declaration name="table" type="short[]" line="91"/>
            <javadoc line="91">
                The actual compressed state table.  Each conceptual row represents
                  a state, and the cells in it contain the row numbers of the states
                  to transition to for each possible letter.  0 is used to indicate
                  an illegal combination of letters (i.e., the error state).  The
                  table is compressed by eliminating all the unpopulated (i.e., zero)
                  cells.  Multiple conceptual rows can then be doubled up in a single
                  physical row by sliding them up and possibly shifting them to one
                  side or the other so the populated cells don&apos;t collide.  Indexes
                  are used to identify unpopulated cells and to locate populated cells.                
            </javadoc>
            <declaration name="rowIndex" type="short[]" line="104"/>
            <javadoc line="104">
                This index maps logical row numbers to physical row numbers                
            </javadoc>
            <declaration name="rowIndexFlags" type="int[]" line="109"/>
            <javadoc line="109">
                A bitmap is used to tell which cells in the comceptual table are
                  populated.  This array contains all the unique bit combinations
                  in that bitmap.  If the table is more than 32 columns wide,
                  successive entries in this array are used for a single row.                
            </javadoc>
            <declaration name="rowIndexFlagsIndex" type="short[]" line="117"/>
            <javadoc line="117">
                This index maps from a logical row number into the bitmap table above.
                  (This keeps us from storing duplicate bitmap combinations.)  Since there
                  are a lot of rows with only one populated cell, instead of wasting space
                  in the bitmap table, we just store a negative number in this index for
                  rows with one populated cell.  The absolute value of that number is
                  the column number of the populated cell.                
            </javadoc>
            <declaration name="rowIndexShifts" type="byte[]" line="127"/>
            <javadoc line="127">
                For each logical row, this index contains a constant that is added to
                  the logical column number to get the physical column number                
            </javadoc>
            <method name="BreakDictionary" type="constructor" line="138">
                <params>
                    <param name="dictionaryName" type="String"/>
                </params>
            </method>
            <method name="readDictionaryFile" type="void" line="144">
                <params>
                    <param name="dictionaryName" type="String"/>
                </params>
                <comment line="167">
                    check vesion                    
                </comment>
                <comment line="174">
                    get data size                    
                </comment>
                <comment line="182">
                    close the stream                    
                </comment>
                <comment line="188">
                    read in the column map for BMP characteres (this is serialized in
                     its internal form: an index array followed by a data array)                    
                </comment>
                <comment line="204">
                    read in numCols and numColGroups                    
                </comment>
                <comment line="210">
                    read in the row-number index                    
                </comment>
                <comment line="218">
                    load in the populated-cells bitmap: index first, then bitmap list                    
                </comment>
                <comment line="232">
                    load in the row-shift index                    
                </comment>
                <comment line="240">
                    load in the actual state table                    
                </comment>
                <comment line="248">
                    finally, prepare the column map for supplementary characters                    
                </comment>
                <declaration name="in" type="BufferedInputStream" line="146"/>
                <scope line="147">
                    <anonymous_class line="149">
                        <method name="run" type="Object" line="150"/>
                    </anonymous_class>
                </scope>
                <scope line="156"/>
                <declaration name="buf" type="byte[]" line="160"/>
                <scope line="161"/>
                <declaration name="version" type="int" line="167"/>
                <scope line="168"/>
                <declaration name="len" type="int" line="174"/>
                <scope line="176"/>
                <declaration name="l" type="int" line="184"/>
                <declaration name="offset" type="int" line="185"/>
                <declaration name="temp" type="short[]" line="191"/>
                <scope line="192"/>
                <declaration name="temp2" type="byte[]" line="197"/>
                <scope line="198"/>
                <scope line="213"/>
                <scope line="221"/>
                <scope line="227"/>
                <scope line="235"/>
                <scope line="243"/>
                <declaration name="temp3" type="int[]" line="250"/>
                <scope line="251"/>
            </method>
            <javadoc line="261">
                Uses the column map to map the character to a column number, then
                  passes the row and column number to getNextState()                
                <param>
                    row The current state                    
                </param>
                <param>
                    ch The character whose column we're interested in                    
                </param>
                <return>
                    The new state to transition to                    
                </return>
            </javadoc>
            <method name="getNextStateFromCharacter" type="short" line="268">
                <params>
                    <param name="row" type="int"/>
                    <param name="ch" type="int"/>
                </params>
                <declaration name="col" type="int" line="269"/>
                <scope line="270"/>
                <scope line="272"/>
            </method>
            <javadoc line="278">
                Returns the value in the cell with the specified (logical) row and
                  column numbers.  In DictionaryBasedBreakIterator, the row number is
                  a state number, the column number is an input, and the return value
                  is the row number of the new state to transition to.  (0 is the
                  &quot;error&quot; state, and -1 is the &quot;end of word&quot; state in a dictionary)                
                <param>
                    row The row number of the current state                    
                </param>
                <param>
                    col The column number of the input character (0 means "not a
                      dictionary character")                    
                </param>
                <return>
                    The row number of the new state to transition to                    
                </return>
            </javadoc>
            <method name="getNextState" type="short" line="289">
                <params>
                    <param name="row" type="int"/>
                    <param name="col" type="int"/>
                </params>
                <comment line="292">
                    we map from logical to physical row number by looking up the
                     mapping in rowIndex; we map from logical column number to
                     physical column number by looking up a shift value for this
                     logical row and offsetting the logical column number by
                     the shift amount.  Then we can use internalAt() to actually
                     get the value out of the table.                    
                </comment>
                <scope line="290"/>
                <scope line="299"/>
            </method>
            <javadoc line="304">
                Given (logical) row and column numbers, returns true if the
                  cell in that position is populated                
            </javadoc>
            <method name="cellIsPopulated" type="boolean" line="308">
                <params>
                    <param name="row" type="int"/>
                    <param name="col" type="int"/>
                </params>
                <comment line="310">
                    look up the entry in the bitmap index for the specified row.
                     If it&apos;s a negative number, it&apos;s the column number of the only
                     populated cell in the row                    
                </comment>
                <comment line="317">
                    if it&apos;s a positive number, it&apos;s the offset of an entry in the bitmap
                     list.  If the table is more than 32 columns wide, the bitmap is stored
                     successive entries in the bitmap list, so we have to divide the column
                     number by 32 and offset the number we got out of the index by the result.
                     Once we have the appropriate piece of the bitmap, test the appropriate
                     bit and return the result.                    
                </comment>
                <scope line="312"/>
                <scope line="322">
                    <declaration name="flags" type="int" line="323"/>
                </scope>
            </method>
            <javadoc line="328">
                Implementation of getNextState() when we know the specified cell is
                  populated.                
                <param>
                    row The PHYSICAL row number of the cell                    
                </param>
                <param>
                    col The PHYSICAL column number of the cell                    
                </param>
                <return>
                    The value stored in the cell                    
                </return>
            </javadoc>
            <method name="internalAt" type="short" line="335">
                <params>
                    <param name="row" type="int"/>
                    <param name="col" type="int"/>
                </params>
                <comment line="337">
                    the table is a one-dimensional array, so this just does the math necessary
                     to treat it as a two-dimensional array (we don&apos;t just use a two-dimensional
                     array because two-dimensional arrays are inefficient in Java)                    
                </comment>
            </method>
        </class>
    </source>