<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.io.InvalidObjectException"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.util.Arrays"/>
        <class name="ChoiceFormat" line="46">
            <extends class="NumberFormat"/>
            <comment line="170">
                Proclaim serial compatibility with 1.1 FCS                
            </comment>
            <comment line="362">
                Overrides                
            </comment>
            <comment line="505">
                ===============privates===========================                
            </comment>
            <comment line="523">
                static final long SIGN          = 0x8000000000000000L;
                static final long EXPONENT      = 0x7FF0000000000000L;
                static final long SIGNIFICAND   = 0x000FFFFFFFFFFFFFL;
                
                private static double nextDouble (double d, boolean positive) {
                if (Double.isNaN(d) || Double.isInfinite(d)) {
                return d;
                }
                long bits = Double.doubleToLongBits(d);
                long significand = bits &amp; SIGNIFICAND;
                if (bits &lt; 0) {
                significand |= (SIGN | EXPONENT);
                }
                long exponent = bits &amp; EXPONENT;
                if (positive) {
                significand += 1;
                 FIXME fix overflow &amp; underflow
                } else {
                significand -= 1;
                 FIXME fix overflow &amp; underflow
                }
                bits = exponent | (significand &amp; ~EXPONENT);
                return Double.longBitsToDouble(bits);
                }                
            </comment>
            <javadoc line="46">
                A &lt;code&gt;ChoiceFormat&lt;/code&gt; allows you to attach a format to a range of numbers.
                  It is generally used in a &lt;code&gt;MessageFormat&lt;/code&gt; for handling plurals.
                  The choice is specified with an ascending list of doubles, where each item
                  specifies a half-open interval up to the next item:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  X matches j if and only if limit[j] &amp;lt;= X &amp;lt; limit[j+1]
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  If there is no match, then either the first or last index is used, depending
                  on whether the number (X) is too low or too high.  If the limit array is not
                  in ascending order, the results of formatting will be incorrect.  ChoiceFormat
                  also accepts &lt;code&gt;&amp;#92;u221E&lt;/code&gt; as equivalent to infinity(INF).
                  &lt;p&gt;
                  &lt;strong&gt;Note:&lt;/strong&gt;
                  &lt;code&gt;ChoiceFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
                  classes in that you create a &lt;code&gt;ChoiceFormat&lt;/code&gt; object with a
                  constructor (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory
                  method). The factory methods aren&apos;t necessary because &lt;code&gt;ChoiceFormat&lt;/code&gt;
                  doesn&apos;t require any complex setup for a given locale. In fact,
                  &lt;code&gt;ChoiceFormat&lt;/code&gt; doesn&apos;t implement any locale specific behavior.
                  &lt;p&gt;
                  When creating a &lt;code&gt;ChoiceFormat&lt;/code&gt;, you must specify an array of formats
                  and an array of limits. The length of these arrays must be the same.
                  For example,
                  &lt;ul&gt;
                  &lt;li&gt;
                  &lt;em&gt;limits&lt;/em&gt; = {1,2,3,4,5,6,7}&lt;br&gt;
                  &lt;em&gt;formats&lt;/em&gt; = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;}
                  &lt;li&gt;
                  &lt;em&gt;limits&lt;/em&gt; = {0, 1, ChoiceFormat.nextDouble(1)}&lt;br&gt;
                  &lt;em&gt;formats&lt;/em&gt; = {&quot;no files&quot;, &quot;one file&quot;, &quot;many files&quot;}&lt;br&gt;
                  (&lt;code&gt;nextDouble&lt;/code&gt; can be used to get the next higher double, to
                  make the half-open interval.)
                  &lt;/ul&gt;
                  &lt;p&gt;
                  Here is a simple example that shows formatting and parsing:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  double[] limits = {1,2,3,4,5,6,7};
                  String[] dayOfWeekNames = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;};
                  ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);
                  ParsePosition status = new ParsePosition(0);
                  for (double i = 0.0; i &amp;lt;= 8.0; ++i) {
                  status.setIndex(0);
                  System.out.println(i + &quot; -&amp;gt; &quot; + form.format(i) + &quot; -&amp;gt; &quot;
                  + form.parse(form.format(i),status));
                  }
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  Here is a more complex example, with a pattern format:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  double[] filelimits = {0,1,2};
                  String[] filepart = {&quot;are no files&quot;,&quot;is one file&quot;,&quot;are {2} files&quot;};
                  ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
                  Format[] testFormats = {fileform, null, NumberFormat.getInstance()};
                  MessageFormat pattform = new MessageFormat(&quot;There {0} on {1}&quot;);
                  pattform.setFormats(testFormats);
                  Object[] testArgs = {null, &quot;ADisk&quot;, null};
                  for (int i = 0; i &amp;lt; 4; ++i) {
                  testArgs[0] = new Integer(i);
                  testArgs[2] = testArgs[0];
                  System.out.println(pattform.format(testArgs));
                  }
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  Specifying a pattern for ChoiceFormat objects is fairly straightforward.
                  For example:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  ChoiceFormat fmt = new ChoiceFormat(
                  &quot;-1#is negative| 0#is zero or fraction | 1#is one |1.0&amp;lt;is 1+ |2#is two |2&amp;lt;is more than 2.&quot;);
                  System.out.println(&quot;Formatter Pattern : &quot; + fmt.toPattern());
                  System.out.println(&quot;Format with -INF : &quot; + fmt.format(Double.NEGATIVE_INFINITY));
                  System.out.println(&quot;Format with -1.0 : &quot; + fmt.format(-1.0));
                  System.out.println(&quot;Format with 0 : &quot; + fmt.format(0));
                  System.out.println(&quot;Format with 0.9 : &quot; + fmt.format(0.9));
                  System.out.println(&quot;Format with 1.0 : &quot; + fmt.format(1));
                  System.out.println(&quot;Format with 1.5 : &quot; + fmt.format(1.5));
                  System.out.println(&quot;Format with 2 : &quot; + fmt.format(2));
                  System.out.println(&quot;Format with 2.1 : &quot; + fmt.format(2.1));
                  System.out.println(&quot;Format with NaN : &quot; + fmt.format(Double.NaN));
                  System.out.println(&quot;Format with +INF : &quot; + fmt.format(Double.POSITIVE_INFINITY));
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  And the output result would be like the following:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  Format with -INF : is negative
                  Format with -1.0 : is negative
                  Format with 0 : is zero or fraction
                  Format with 0.9 : is zero or fraction
                  Format with 1.0 : is one
                  Format with 1.5 : is 1+
                  Format with 2 : is two
                  Format with 2.1 : is more than 2.
                  Format with NaN : is negative
                  Format with +INF : is more than 2.
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt;
                  Choice formats are not synchronized.
                  It is recommended to create separate format instances for each thread.
                  If multiple threads access a format concurrently, it must be synchronized
                  externally.                
                <see>
                    DecimalFormat                    
                </see>
                <see>
                    MessageFormat                    
                </see>
                <author>
                    Mark Davis                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="170"/>
            <javadoc line="172">
                Sets the pattern.                
                <param>
                    newPattern See the class description.                    
                </param>
            </javadoc>
            <method name="applyPattern" type="void" line="176">
                <params>
                    <param name="newPattern" type="String"/>
                </params>
                <comment line="192">
                    Check for &quot;&apos;&apos;&quot; indicating a literal quote                    
                </comment>
                <comment line="241">
                    clean up last one                    
                </comment>
                <declaration name="segments" type="StringBuffer[]" line="177"/>
                <scope line="178"/>
                <declaration name="newChoiceLimits" type="double[]" line="181"/>
                <declaration name="newChoiceFormats" type="String[]" line="182"/>
                <declaration name="count" type="int" line="183"/>
                <declaration name="part" type="int" line="184"/>
                <declaration name="startValue" type="double" line="185"/>
                <declaration name="oldStartValue" type="double" line="186"/>
                <declaration name="inQuote" type="boolean" line="187"/>
                <scope line="188">
                    <declaration name="ch" type="char" line="189"/>
                    <scope line="190">
                        <scope line="192"/>
                        <scope line="195"/>
                    </scope>
                    <scope line="198"/>
                    <scope line="200">
                        <scope line="201"/>
                        <scope line="204">
                            <declaration name="tempBuffer" type="String" line="205"/>
                            <scope line="206"/>
                            <scope line="208"/>
                            <scope line="210"/>
                        </scope>
                        <scope line="213"/>
                        <scope line="217"/>
                        <scope line="220"/>
                    </scope>
                    <scope line="225">
                        <scope line="226"/>
                    </scope>
                    <scope line="236"/>
                </scope>
                <scope line="241">
                    <scope line="242"/>
                </scope>
            </method>
            <javadoc line="256">
                Gets the pattern.                
            </javadoc>
            <method name="toPattern" type="String" line="259">
                <comment line="266">
                    choose based upon which has less precision
                     approximate that by choosing the closest one to an integer.
                     could do better, but it&apos;s not worth it.                    
                </comment>
                <comment line="286">
                    Append choiceFormats[i], using quotes if there are special characters.
                     Single quotes themselves must be escaped in either case.                    
                </comment>
                <declaration name="result" type="StringBuffer" line="260"/>
                <scope line="261">
                    <scope line="262"/>
                    <declaration name="less" type="double" line="268"/>
                    <declaration name="tryLessOrEqual" type="double" line="269"/>
                    <declaration name="tryLess" type="double" line="270"/>
                    <scope line="272"/>
                    <scope line="275">
                        <scope line="276"/>
                        <scope line="278"/>
                        <scope line="280"/>
                    </scope>
                    <declaration name="text" type="String" line="287"/>
                    <declaration name="needQuote" type="boolean" line="288"/>
                    <scope line="294">
                        <scope line="295">
                            <declaration name="c" type="char" line="296"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="306">
                Constructs with limits and corresponding formats based on the pattern.                
                <see>
                    #applyPattern                    
                </see>
            </javadoc>
            <method name="ChoiceFormat" type="constructor" line="310">
                <params>
                    <param name="newPattern" type="String"/>
                </params>
            </method>
            <javadoc line="314">
                Constructs with the limits and the corresponding formats.                
                <see>
                    #setChoices                    
                </see>
            </javadoc>
            <method name="ChoiceFormat" type="constructor" line="318">
                <params>
                    <param name="limits" type="double[]"/>
                    <param name="formats" type="String[]"/>
                </params>
            </method>
            <javadoc line="322">
                Set the choices to be used in formatting.                
                <param>
                    limits contains the top value that you want
                      parsed with that format,and should be in ascending sorted order. When
                      formatting X, the choice will be the i, where
                      limit[i] &amp;lt;= X &amp;lt; limit[i+1].
                      If the limit array is not in ascending order, the results of formatting
                      will be incorrect.                    
                </param>
                <param>
                    formats are the formats you want to use for each limit.
                      They can be either Format objects or Strings.
                      When formatting with object Y,
                      if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
                      is called. Otherwise Y.toString() is called.                    
                </param>
            </javadoc>
            <method name="setChoices" type="void" line="336">
                <params>
                    <param name="limits" type="double[]"/>
                    <param name="formats" type="String"/>
                </params>
                <scope line="337"/>
            </method>
            <javadoc line="345">
                Get the limits passed in the constructor.                
                <return>
                    the limits.                    
                </return>
            </javadoc>
            <method name="getLimits" type="double[]" line="349"/>
            <javadoc line="353">
                Get the formats passed in the constructor.                
                <return>
                    the formats.                    
                </return>
            </javadoc>
            <method name="getFormats" type="Object[]" line="357"/>
            <javadoc line="363">
                Specialization of format. This method really calls
                  &lt;code&gt;format(double, StringBuffer, FieldPosition)&lt;/code&gt;
                  thus the range of longs that are supported is only equal to
                  the range that can be stored by double. This will never be
                  a practical limitation.                
            </javadoc>
            <method name="format" type="StringBuffer" line="371">
                <params>
                    <param name="number" type="long"/>
                    <param name="toAppendTo" type="StringBuffer"/>
                    <param name="status" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="375">
                Returns pattern with formatted double.                
                <param>
                    number number to be formatted &amp; substituted.                    
                </param>
                <param>
                    toAppendTo where text is appended.                    
                </param>
                <param>
                    status ignore no useful status is returned.                    
                </param>
            </javadoc>
            <method name="format" type="StringBuffer" line="382">
                <params>
                    <param name="number" type="double"/>
                    <param name="toAppendTo" type="StringBuffer"/>
                    <param name="status" type="FieldPosition"/>
                </params>
                <comment line="384">
                    find the number                    
                </comment>
                <comment line="388">
                    same as number &lt; choiceLimits, except catchs NaN                    
                </comment>
                <comment line="394">
                    return either a formatted number, or a string                    
                </comment>
                <declaration name="i" type="int" line="384"/>
                <scope line="385">
                    <scope line="386"/>
                </scope>
            </method>
            <javadoc line="397">
                Parses a Number from the input text.                
                <param>
                    text the source text.                    
                </param>
                <param>
                    status an input-output parameter.  On input, the
                      status.index field indicates the first character of the
                      source text that should be parsed.  On exit, if no error
                      occured, status.index is set to the first unparsed character
                      in the source text.  On exit, if an error did occur,
                      status.index is unchanged and status.errorIndex is set to the
                      first index of the character that caused the parse to fail.                    
                </param>
                <return>
                    A Number representing the value of the number parsed.                    
                </return>
            </javadoc>
            <method name="parse" type="Number" line="409">
                <params>
                    <param name="text" type="String"/>
                    <param name="status" type="ParsePosition"/>
                </params>
                <comment line="411">
                    find the best number (defined as the one with the longest parse)                    
                </comment>
                <declaration name="start" type="int" line="411"/>
                <declaration name="furthest" type="int" line="412"/>
                <declaration name="bestNumber" type="double" line="413"/>
                <declaration name="tempNumber" type="double" line="414"/>
                <scope line="415">
                    <declaration name="tempString" type="String" line="416"/>
                    <scope line="417">
                        <scope line="420"/>
                    </scope>
                </scope>
                <scope line="428"/>
            </method>
            <javadoc line="434">
                Finds the least double greater than d.
                  If NaN, returns same value.
                  &lt;p&gt;Used to make half-open intervals.                
                <see>
                    #previousDouble                    
                </see>
            </javadoc>
            <method name="nextDouble" type="double" line="440">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="444">
                Finds the greatest double less than d.
                  If NaN, returns same value.                
                <see>
                    #nextDouble                    
                </see>
            </javadoc>
            <method name="previousDouble" type="double" line="449">
                <params>
                    <param name="d" type="double"/>
                </params>
            </method>
            <javadoc line="453">
                Overrides Cloneable                
            </javadoc>
            <method name="clone" type="Object" line="457">
                <comment line="460">
                    for primitives or immutables, shallow clone is enough                    
                </comment>
                <declaration name="other" type="ChoiceFormat" line="458"/>
            </method>
            <javadoc line="465">
                Generates a hash code for the message format object.                
            </javadoc>
            <method name="hashCode" type="int" line="468">
                <comment line="472">
                    enough for reasonable distribution                    
                </comment>
                <declaration name="result" type="int" line="469"/>
                <scope line="470"/>
            </method>
            <javadoc line="477">
                Equality comparision between two                
            </javadoc>
            <method name="equals" type="boolean" line="480">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="483">
                    quick check                    
                </comment>
                <declaration name="other" type="ChoiceFormat" line="486"/>
            </method>
            <javadoc line="491">
                After reading an object from the input stream, do a simple verification
                  to maintain class invariants.                
                <throws>
                    InvalidObjectException if the objects read from the stream is invalid.                    
                </throws>
            </javadoc>
            <method name="readObject" type="void" line="496">
                <params>
                    <param name="in" type="ObjectInputStream"/>
                </params>
                <scope line="498"/>
            </method>
            <declaration name="choiceLimits" type="double[]" line="506"/>
            <javadoc line="506">
                A list of lower bounds for the choices.  The formatter will return
                  &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to
                  &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="choiceFormats" type="String[]" line="514"/>
            <javadoc line="514">
                A list of choice strings.  The formatter will return
                  &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to
                  &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="SIGN" type="long" line="549"/>
            <declaration name="EXPONENT" type="long" line="550"/>
            <declaration name="POSITIVEINFINITY" type="long" line="551"/>
            <javadoc line="553">
                Finds the least double greater than d (if positive == true),
                  or the greatest double less than d (if positive == false).
                  If NaN, returns same value.
                  Does not affect floating-point flags,
                  provided these member functions do not:
                  Double.longBitsToDouble(long)
                  Double.doubleToLongBits(double)
                  Double.isNaN(double)                
            </javadoc>
            <method name="nextDouble" type="double" line="564">
                <params>
                    <param name="d" type="double"/>
                    <param name="positive" type="boolean"/>
                </params>
                <comment line="567">
                                        
                </comment>
                <comment line="572">
                                        
                </comment>
                <comment line="582">
                                        
                </comment>
                <comment line="584">
                                        
                </comment>
                <comment line="587">
                                        
                </comment>
                <comment line="590">
                                        
                </comment>
                <comment line="596">
                                        
                </comment>
                <comment line="601">
                                        
                </comment>
                <scope line="567"/>
                <scope line="572">
                    <declaration name="smallestPositiveDouble" type="double" line="573"/>
                    <scope line="574"/>
                    <scope line="576"/>
                </scope>
                <declaration name="bits" type="long" line="584"/>
                <declaration name="magnitude" type="long" line="587"/>
                <scope line="590">
                    <scope line="591"/>
                </scope>
                <scope line="596"/>
                <declaration name="signbit" type="long" line="601"/>
            </method>
            <method name="doubleArraySize" type="double[]" line="605">
                <params>
                    <param name="array" type="double[]"/>
                </params>
                <declaration name="oldSize" type="int" line="606"/>
                <declaration name="newArray" type="double[]" line="607"/>
            </method>
            <method name="doubleArraySize" type="String[]" line="612">
                <params>
                    <param name="array" type="String[]"/>
                </params>
                <declaration name="oldSize" type="int" line="613"/>
                <declaration name="newArray" type="String[]" line="614"/>
            </method>
        </class>
    </source>