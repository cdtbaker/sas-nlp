<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.io.IOException"/>
        <import package="java.io.InvalidObjectException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.util.Calendar"/>
        <import package="java.util.Date"/>
        <import package="java.util.GregorianCalendar"/>
        <import package="java.util.Locale"/>
        <import package="java.util.Map"/>
        <import package="java.util.MissingResourceException"/>
        <import package="java.util.ResourceBundle"/>
        <import package="java.util.SimpleTimeZone"/>
        <import package="java.util.TimeZone"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.concurrent.ConcurrentMap"/>
        <import package="sun.util.calendar.CalendarUtils"/>
        <import package="sun.util.calendar.ZoneInfoFile"/>
        <import package="sun.util.resources.LocaleData"/>
        <import package="java.text.DateFormatSymbols"/>
        <class name="SimpleDateFormat" line="61">
            <extends class="DateFormat"/>
            <comment line="412">
                the official serial version ID which says cryptically
                 which version we&apos;re compatible with                
            </comment>
            <comment line="416">
                the internal serial version which says which version was written
                 - 0 (default) for version up to JDK 1.1.3
                 - 1 for version from JDK 1.1.4, which includes a new field                
            </comment>
            <comment line="501">
                For time zones that have no names, use strings GMT+minutes and
                 GMT-minutes. For instance, in France the time zone is GMT+60.                
            </comment>
            <comment line="612">
                                
            </comment>
            <comment line="657">
                                
            </comment>
            <comment line="890">
                Initialize the fields we use to disambiguate ambiguous years. Separate
                 so we can call it from readObject().                
            </comment>
            <comment line="899">
                Define one-century window into which to disambiguate dates using
                 two-digit years.                
            </comment>
            <comment line="952">
                Called from Format after creating a FieldDelegate                
            </comment>
            <comment line="1025">
                Map index into pattern character string to Calendar field number                
            </comment>
            <comment line="1041">
                Map index into pattern character string to DateFormat field number                
            </comment>
            <comment line="1056">
                Maps from DecimalFormatSymbols index to Field constant                
            </comment>
            <javadoc line="61">
                &lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and
                  parsing dates in a locale-sensitive manner. It allows for formatting
                  (date -&gt; text), parsing (text -&gt; date), and normalization.
                  &lt;p&gt;
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; allows you to start by choosing
                  any user-defined patterns for date-time formatting. However, you
                  are encouraged to create a date-time formatter with either
                  &lt;code&gt;getTimeInstance&lt;/code&gt;, &lt;code&gt;getDateInstance&lt;/code&gt;, or
                  &lt;code&gt;getDateTimeInstance&lt;/code&gt; in &lt;code&gt;DateFormat&lt;/code&gt;. Each
                  of these class methods can return a date/time formatter initialized
                  with a default format pattern. You may modify the format pattern
                  using the &lt;code&gt;applyPattern&lt;/code&gt; methods as desired.
                  For more information on using these methods, see{@link DateFormat}.
                  &lt;h4&gt;Date and Time Patterns&lt;/h4&gt;
                  &lt;p&gt;
                  Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt;
                  strings.
                  Within date and time pattern strings, unquoted letters from
                  &lt;code&gt;&apos;A&apos;&lt;/code&gt; to &lt;code&gt;&apos;Z&apos;&lt;/code&gt; and from &lt;code&gt;&apos;a&apos;&lt;/code&gt; to
                  &lt;code&gt;&apos;z&apos;&lt;/code&gt; are interpreted as pattern letters representing the
                  components of a date or time string.
                  Text can be quoted using single quotes (&lt;code&gt;&apos;&lt;/code&gt;) to avoid
                  interpretation.
                  &lt;code&gt;&quot;&apos;&apos;&quot;&lt;/code&gt; represents a single quote.
                  All other characters are not interpreted; they&apos;re simply copied into the
                  output string during formatting or matched against the input string
                  during parsing.
                  &lt;p&gt;
                  The following pattern letters are defined (all other characters from
                  &lt;code&gt;&apos;A&apos;&lt;/code&gt; to &lt;code&gt;&apos;Z&apos;&lt;/code&gt; and from &lt;code&gt;&apos;a&apos;&lt;/code&gt; to
                  &lt;code&gt;&apos;z&apos;&lt;/code&gt; are reserved):
                  &lt;blockquote&gt;
                  &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Chart shows pattern letters, date/time component, presentation, and examples.&quot;&gt;
                  &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
                  &lt;th align=left&gt;Letter
                  &lt;th align=left&gt;Date or Time Component
                  &lt;th align=left&gt;Presentation
                  &lt;th align=left&gt;Examples
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;G&lt;/code&gt;
                  &lt;td&gt;Era designator
                  &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;AD&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;y&lt;/code&gt;
                  &lt;td&gt;Year
                  &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;1996&lt;/code&gt;; &lt;code&gt;96&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;Y&lt;/code&gt;
                  &lt;td&gt;Week year
                  &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;2009&lt;/code&gt;; &lt;code&gt;09&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;M&lt;/code&gt;
                  &lt;td&gt;Month in year
                  &lt;td&gt;&lt;a href=&quot;#month&quot;&gt;Month&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;July&lt;/code&gt;; &lt;code&gt;Jul&lt;/code&gt;; &lt;code&gt;07&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;w&lt;/code&gt;
                  &lt;td&gt;Week in year
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;27&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;W&lt;/code&gt;
                  &lt;td&gt;Week in month
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;D&lt;/code&gt;
                  &lt;td&gt;Day in year
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;189&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;d&lt;/code&gt;
                  &lt;td&gt;Day in month
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;10&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;F&lt;/code&gt;
                  &lt;td&gt;Day of week in month
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;E&lt;/code&gt;
                  &lt;td&gt;Day name in week
                  &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;Tuesday&lt;/code&gt;; &lt;code&gt;Tue&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;u&lt;/code&gt;
                  &lt;td&gt;Day number of week (1 = Monday, ..., 7 = Sunday)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;1&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;a&lt;/code&gt;
                  &lt;td&gt;Am/pm marker
                  &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;PM&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;H&lt;/code&gt;
                  &lt;td&gt;Hour in day (0-23)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;k&lt;/code&gt;
                  &lt;td&gt;Hour in day (1-24)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;24&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;K&lt;/code&gt;
                  &lt;td&gt;Hour in am/pm (0-11)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;h&lt;/code&gt;
                  &lt;td&gt;Hour in am/pm (1-12)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;12&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;m&lt;/code&gt;
                  &lt;td&gt;Minute in hour
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;30&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;s&lt;/code&gt;
                  &lt;td&gt;Second in minute
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;55&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;S&lt;/code&gt;
                  &lt;td&gt;Millisecond
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;978&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;z&lt;/code&gt;
                  &lt;td&gt;Time zone
                  &lt;td&gt;&lt;a href=&quot;#timezone&quot;&gt;General time zone&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;Pacific Standard Time&lt;/code&gt;; &lt;code&gt;PST&lt;/code&gt;; &lt;code&gt;GMT-08:00&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;Z&lt;/code&gt;
                  &lt;td&gt;Time zone
                  &lt;td&gt;&lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zone&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;-0800&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;X&lt;/code&gt;
                  &lt;td&gt;Time zone
                  &lt;td&gt;&lt;a href=&quot;#iso8601timezone&quot;&gt;ISO 8601 time zone&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;-08&lt;/code&gt;; &lt;code&gt;-0800&lt;/code&gt;;  &lt;code&gt;-08:00&lt;/code&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  Pattern letters are usually repeated, as their number determines the
                  exact presentation:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;text&quot;&gt;Text:&lt;/a&gt;&lt;/strong&gt;
                  For formatting, if the number of pattern letters is 4 or more,
                  the full form is used; otherwise a short or abbreviated form
                  is used if available.
                  For parsing, both forms are accepted, independent of the number
                  of pattern letters.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;number&quot;&gt;Number:&lt;/a&gt;&lt;/strong&gt;
                  For formatting, the number of pattern letters is the minimum
                  number of digits, and shorter numbers are zero-padded to this amount.
                  For parsing, the number of pattern letters is ignored unless
                  it&apos;s needed to separate two adjacent fields.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;year&quot;&gt;Year:&lt;/a&gt;&lt;/strong&gt;
                  If the formatter&apos;s {@link #getCalendar() Calendar} is the Gregorian
                  calendar, the following rules are applied.&lt;br&gt;
                  &lt;ul&gt;
                  &lt;li&gt;For formatting, if the number of pattern letters is 2, the year
                  is truncated to 2 digits; otherwise it is interpreted as a
                  &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.
                  &lt;li&gt;For parsing, if the number of pattern letters is more than 2,
                  the year is interpreted literally, regardless of the number of
                  digits. So using the pattern &quot;MM/dd/yyyy&quot;, &quot;01/11/12&quot; parses to
                  Jan 11, 12 A.D.
                  &lt;li&gt;For parsing with the abbreviated year pattern (&quot;y&quot; or &quot;yy&quot;),
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; must interpret the abbreviated year
                  relative to some century.  It does this by adjusting dates to be
                  within 80 years before and 20 years after the time the &lt;code&gt;SimpleDateFormat&lt;/code&gt;
                  instance is created. For example, using a pattern of &quot;MM/dd/yy&quot; and a
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; instance created on Jan 1, 1997,  the string
                  &quot;01/11/12&quot; would be interpreted as Jan 11, 2012 while the string &quot;05/04/64&quot;
                  would be interpreted as May 4, 1964.
                  During parsing, only strings consisting of exactly two digits, as defined by{@link Character#isDigit(char)}, will be parsed into the default century.
                  Any other numeric string, such as a one digit string, a three or more digit
                  string, or a two digit string that isn&apos;t all digits (for example, &quot;-1&quot;), is
                  interpreted literally.  So &quot;01/02/3&quot; or &quot;01/02/003&quot; are parsed, using the
                  same pattern, as Jan 2, 3 AD.  Likewise, &quot;01/02/-3&quot; is parsed as Jan 2, 4 BC.
                  &lt;/ul&gt;
                  Otherwise, calendar system specific forms are applied.
                  For both formatting and parsing, if the number of pattern
                  letters is 4 or more, a calendar specific {@linkplain Calendar#LONG long form} is used. Otherwise, a calendar
                  specific {@linkplain Calendar#SHORT short or abbreviated form}is used.&lt;br&gt;
                  &lt;br&gt;
                  If week year {@code &apos;Y&apos;} is specified and the {@linkplain #getCalendar() calendar} doesn&apos;t support any &lt;a
                  href=&quot;../util/GregorianCalendar.html#week_year&quot;&gt; week
                  years&lt;/a&gt;, the calendar year ({@code &apos;y&apos;}) is used instead. The
                  support of week years can be tested with a call to {@link DateFormat#getCalendar() getCalendar()}.{@link java.util.Calendar#isWeekDateSupported()isWeekDateSupported()}.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;month&quot;&gt;Month:&lt;/a&gt;&lt;/strong&gt;
                  If the number of pattern letters is 3 or more, the month is
                  interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;; otherwise,
                  it is interpreted as a &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;timezone&quot;&gt;General time zone:&lt;/a&gt;&lt;/strong&gt;
                  Time zones are interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; if they have
                  names. For time zones representing a GMT offset value, the
                  following syntax is used:
                  &lt;pre&gt;
                  &lt;a name=&quot;GMTOffsetTimeZone&quot;&gt;&lt;i&gt;GMTOffsetTimeZone:&lt;/i&gt;&lt;/a&gt;
                  &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;
                  &lt;i&gt;Sign:&lt;/i&gt; one of
                  &lt;code&gt;+ -&lt;/code&gt;
                  &lt;i&gt;Hours:&lt;/i&gt;
                  &lt;i&gt;Digit&lt;/i&gt;
                  &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                  &lt;i&gt;Minutes:&lt;/i&gt;
                  &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                  &lt;i&gt;Digit:&lt;/i&gt; one of
                  &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;
                  &lt;i&gt;Hours&lt;/i&gt; must be between 0 and 23, and &lt;i&gt;Minutes&lt;/i&gt; must be between
                  00 and 59. The format is locale independent and digits must be taken
                  from the Basic Latin block of the Unicode standard.
                  &lt;p&gt;For parsing, &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt; are also
                  accepted.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;rfc822timezone&quot;&gt;RFC 822 time zone:&lt;/a&gt;&lt;/strong&gt;
                  For formatting, the RFC 822 4-digit time zone format is used:
                  &lt;pre&gt;
                  &lt;i&gt;RFC822TimeZone:&lt;/i&gt;
                  &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
                  &lt;i&gt;TwoDigitHours:&lt;/i&gt;
                  &lt;i&gt;Digit Digit&lt;/i&gt;&lt;/pre&gt;
                  &lt;i&gt;TwoDigitHours&lt;/i&gt; must be between 00 and 23. Other definitions
                  are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt;.
                  &lt;p&gt;For parsing, &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; are also
                  accepted.
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;iso8601timezone&quot;&gt;ISO 8601 Time zone:&lt;/a&gt;&lt;/strong&gt;
                  The number of pattern letters designates the format for both formatting
                  and parsing as follows:
                  &lt;pre&gt;
                  &lt;i&gt;ISO8601TimeZone:&lt;/i&gt;
                  &lt;i&gt;OneLetterISO8601TimeZone&lt;/i&gt;
                  &lt;i&gt;TwoLetterISO8601TimeZone&lt;/i&gt;
                  &lt;i&gt;ThreeLetterISO8601TimeZone&lt;/i&gt;
                  &lt;i&gt;OneLetterISO8601TimeZone:&lt;/i&gt;
                  &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt;{@code Z}&lt;i&gt;TwoLetterISO8601TimeZone:&lt;/i&gt;
                  &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;{@code Z}&lt;i&gt;ThreeLetterISO8601TimeZone:&lt;/i&gt;
                  &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; {@code :} &lt;i&gt;Minutes&lt;/i&gt;{@code Z}&lt;/pre&gt;
                  Other definitions are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; or
                  &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt;.
                  &lt;p&gt;For formatting, if the offset value from GMT is 0, {@code &quot;Z&quot;} is
                  produced. If the number of pattern letters is 1, any fraction of an hour
                  is ignored. For example, if the pattern is {@code &quot;X&quot;} and the time zone is{@code &quot;GMT+05:30&quot;}, {@code &quot;+05&quot;} is produced.
                  &lt;p&gt;For parsing, {@code &quot;Z&quot;} is parsed as the UTC time zone designator.
                  &lt;a href=&quot;#timezone&quot;&gt;General time zones&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; accepted.
                  &lt;p&gt;If the number of pattern letters is 4 or more, {@link IllegalArgumentException} is thrown when constructing a {@codeSimpleDateFormat} or {@linkplain #applyPattern(String) applying a
                  pattern}.
                  &lt;/ul&gt;
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; also supports &lt;em&gt;localized date and time
                  pattern&lt;/em&gt; strings. In these strings, the pattern letters described above
                  may be replaced with other, locale dependent, pattern letters.
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; does not deal with the localization of text
                  other than the pattern letters; that&apos;s up to the client of the class.
                  &lt;p&gt;
                  &lt;h4&gt;Examples&lt;/h4&gt;
                  The following examples show how date and time patterns are interpreted in
                  the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time
                  in the U.S. Pacific Time time zone.
                  &lt;blockquote&gt;
                  &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Examples of date and time patterns interpreted in the U.S. locale&quot;&gt;
                  &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
                  &lt;th align=left&gt;Date and Time Pattern
                  &lt;th align=left&gt;Result
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyyy.MM.dd G &apos;at&apos; HH:mm:ss z&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;2001.07.04 AD at 12:08:56 PDT&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;EEE, MMM d, &apos;&apos;yy&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;Wed, Jul 4, &apos;01&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;h:mm a&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;12:08 PM&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;hh &apos;o&apos;&apos;clock&apos; a, zzzz&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;12 o&apos;clock PM, Pacific Daylight Time&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;K:mm a, z&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;0:08 PM, PDT&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;02001.July.04 AD 12:08 PM&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;EEE, d MMM yyyy HH:mm:ss Z&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;Wed, 4 Jul 2001 12:08:56 -0700&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyMMddHHmmssZ&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;010704120856-0700&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSZ&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-0700&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSXXX&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-07:00&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;YYYY-&apos;W&apos;ww-u&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;2001-W27-3&lt;/code&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt;
                  Date formats are not synchronized.
                  It is recommended to create separate format instances for each thread.
                  If multiple threads access a format concurrently, it must be synchronized
                  externally.                
                <see>
                    <a href="http://java.sun.com/docs/books/tutorial/i18n/format/simpleDateFormat.html">Java Tutorial</a>                    
                </see>
                <see>
                    java.util.Calendar                    
                </see>
                <see>
                    java.util.TimeZone                    
                </see>
                <see>
                    DateFormat                    
                </see>
                <see>
                    DateFormatSymbols                    
                </see>
                <author>
                    Mark Davis, Chen-Lieh Huang, Alan Liu                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="413"/>
            <declaration name="currentSerialVersion" type="int" line="418"/>
            <declaration name="serialVersionOnStream" type="int" line="420"/>
            <javadoc line="420">
                The version of the serialized data on the stream.  Possible values:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream: JDK 1.1.3.  This version
                  has no &lt;code&gt;defaultCenturyStart&lt;/code&gt; on stream.
                  &lt;li&gt;&lt;b&gt;1&lt;/b&gt; JDK 1.1.4 or later.  This version adds
                  &lt;code&gt;defaultCenturyStart&lt;/code&gt;.
                  &lt;/ul&gt;
                  When streaming out this class, the most recent format
                  and the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;
                  is written.                
                <serial>
                                        
                </serial>
                <since>
                    JDK1.1.4                    
                </since>
            </javadoc>
            <declaration name="pattern" type="String" line="436"/>
            <javadoc line="436">
                The pattern string of this formatter.  This is always a non-localized
                  pattern.  May not be null.  See class documentation for details.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="originalNumberFormat" type="NumberFormat" line="443"/>
            <javadoc line="443">
                Saved numberFormat and pattern.                
                <see>
                    SimpleDateFormat#checkNegativeNumberExpression                    
                </see>
            </javadoc>
            <declaration name="originalNumberPattern" type="String" line="448"/>
            <declaration name="minusSign" type="char" line="450"/>
            <javadoc line="450">
                The minus sign to be used with format and parse.                
            </javadoc>
            <declaration name="hasFollowingMinusSign" type="boolean" line="455"/>
            <javadoc line="455">
                True when a negative sign follows a number.
                  (True as default in Arabic.)                
            </javadoc>
            <declaration name="compiledPattern" type="char[]" line="461"/>
            <javadoc line="461">
                The compiled pattern.                
            </javadoc>
            <declaration name="TAG_QUOTE_ASCII_CHAR" type="int" line="466"/>
            <javadoc line="466">
                Tags for the compiled pattern.                
            </javadoc>
            <declaration name="TAG_QUOTE_CHARS" type="int" line="470"/>
            <declaration name="zeroDigit" type="char" line="472"/>
            <javadoc line="472">
                Locale dependent digit zero.                
                <see>
                    #zeroPaddingNumber                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols#getZeroDigit                    
                </see>
            </javadoc>
            <declaration name="formatData" type="DateFormatSymbols" line="479"/>
            <javadoc line="479">
                The symbols used by this formatter for week names, month names,
                  etc.  May not be null.                
                <serial>
                                        
                </serial>
                <see>
                    java.text.DateFormatSymbols                    
                </see>
            </javadoc>
            <declaration name="defaultCenturyStart" type="Date" line="487"/>
            <javadoc line="487">
                We map dates with two-digit years into the century starting at
                  &lt;code&gt;defaultCenturyStart&lt;/code&gt;, which may be any date.  May
                  not be null.                
                <serial>
                                        
                </serial>
                <since>
                    JDK1.1.4                    
                </since>
            </javadoc>
            <declaration name="defaultCenturyStartYear" type="int" line="496"/>
            <declaration name="MILLIS_PER_MINUTE" type="int" line="498"/>
            <declaration name="GMT" type="String" line="502"/>
            <declaration name="cachedLocaleData" type="ConcurrentMap&lt;Locale,String[]&gt;" line="504"/>
            <javadoc line="504">
                Cache to hold the DateTimePatterns of a Locale.                
            </javadoc>
            <declaration name="cachedNumberFormatData" type="ConcurrentMap&lt;Locale,NumberFormat&gt;" line="510"/>
            <javadoc line="510">
                Cache NumberFormat instances with Locale key.                
            </javadoc>
            <declaration name="locale" type="Locale" line="516"/>
            <javadoc line="516">
                The Locale used to instantiate this
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt;. The value may be null if this object
                  has been created by an older &lt;code&gt;SimpleDateFormat&lt;/code&gt; and
                  deserialized.                
                <serial>
                                        
                </serial>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="useDateFormatSymbols" type="boolean" line="527"/>
            <javadoc line="527">
                Indicates whether this &lt;code&gt;SimpleDateFormat&lt;/code&gt; should use
                  the DateFormatSymbols. If true, the format and parse methods
                  use the DateFormatSymbols values. If false, the format and
                  parse methods call Calendar.getDisplayName or
                  Calendar.getDisplayNames.                
            </javadoc>
            <javadoc line="536">
                Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the default pattern and
                  date format symbols for the default locale.
                  &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
                  For full coverage, use the factory methods in the {@link DateFormat}class.                
            </javadoc>
            <method name="SimpleDateFormat" type="constructor" line="543"/>
            <javadoc line="547">
                Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
                  the default date format symbols for the default locale.
                  &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
                  For full coverage, use the factory methods in the {@link DateFormat}class.                
                <param>
                    pattern the pattern describing the date and time format                    
                </param>
                <exception>
                    NullPointerException if the given pattern is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="SimpleDateFormat" type="constructor" line="559">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="563">
                Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
                  the default date format symbols for the given locale.
                  &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
                  For full coverage, use the factory methods in the {@link DateFormat}class.                
                <param>
                    pattern the pattern describing the date and time format                    
                </param>
                <param>
                    locale the locale whose date format symbols should be used                    
                </param>
                <exception>
                    NullPointerException if the given pattern or locale is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="SimpleDateFormat" type="constructor" line="576">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="locale" type="Locale"/>
                </params>
                <scope line="577"/>
            </method>
            <javadoc line="588">
                Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
                  date format symbols.                
                <param>
                    pattern the pattern describing the date and time format                    
                </param>
                <param>
                    formatSymbols the date format symbols to be used for formatting                    
                </param>
                <exception>
                    NullPointerException if the given pattern or formatSymbols is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="SimpleDateFormat" type="constructor" line="598">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="formatSymbols" type="DateFormatSymbols"/>
                </params>
                <scope line="599"/>
            </method>
            <method name="SimpleDateFormat" type="constructor" line="612">
                <params>
                    <param name="timeStyle" type="int"/>
                    <param name="dateStyle" type="int"/>
                    <param name="loc" type="Locale"/>
                </params>
                <comment line="619">
                    initialize calendar and related fields                    
                </comment>
                <comment line="622">
                                        
                </comment>
                <comment line="624">
                                        
                </comment>
                <comment line="635">
                                        
                </comment>
                <scope line="613"/>
                <declaration name="dateTimePatterns" type="String[]" line="622"/>
                <scope line="623">
                    <declaration name="r" type="ResourceBundle" line="624"/>
                    <scope line="625">
                        <scope line="626"/>
                        <scope line="628"/>
                    </scope>
                    <scope line="631"/>
                </scope>
                <scope line="638">
                    <declaration name="dateTimeArgs" type="Object[]" line="639"/>
                </scope>
                <scope line="643"/>
                <scope line="646"/>
                <scope line="649"/>
            </method>
            <method name="initialize" type="void" line="657">
                <params>
                    <param name="loc" type="Locale"/>
                </params>
                <comment line="659">
                    Verify and compile the given pattern.                    
                </comment>
                <comment line="662">
                                        
                </comment>
                <comment line="664">
                                        
                </comment>
                <comment line="668">
                                        
                </comment>
                <scope line="663"/>
            </method>
            <method name="initializeCalendar" type="void" line="675">
                <params>
                    <param name="loc" type="Locale"/>
                </params>
                <comment line="679">
                    The format object must be constructed using the symbols for this zone.
                     However, the calendar should use the current default TimeZone.
                     If this is not contained in the locale zone strings, then the zone
                     will be formatted using generic GMT+/-H:MM nomenclature.                    
                </comment>
                <scope line="676"/>
            </method>
            <javadoc line="686">
                Returns the compiled form of the given pattern. The syntax of
                  the compiled pattern is:
                  &lt;blockquote&gt;
                  CompiledPattern:
                  EntryList
                  EntryList:
                  Entry
                  EntryList Entry
                  Entry:
                  TagField
                  TagField data
                  TagField:
                  Tag Length
                  TaggedData
                  Tag:
                  pattern_char_index
                  TAG_QUOTE_CHARS
                  Length:
                  short_length
                  long_length
                  TaggedData:
                  TAG_QUOTE_ASCII_CHAR ascii_char
                  &lt;/blockquote&gt;
                  where `short_length&apos; is an 8-bit unsigned integer between 0 and
                  254.  `long_length&apos; is a sequence of an 8-bit integer 255 and a
                  32-bit signed integer value which is split into upper and lower
                  16-bit fields in two char&apos;s. `pattern_char_index&apos; is an 8-bit
                  integer between 0 and 18. `ascii_char&apos; is an 7-bit ASCII
                  character value. `data&apos; depends on its Tag value.
                  &lt;p&gt;
                  If Length is short_length, Tag and short_length are packed in a
                  single char, as illustrated below.
                  &lt;blockquote&gt;
                  char[0] = (Tag &lt;&lt; 8) | short_length;
                  &lt;/blockquote&gt;
                  If Length is long_length, Tag and 255 are packed in the first
                  char and a 32-bit integer, as illustrated below.
                  &lt;blockquote&gt;
                  char[0] = (Tag &lt;&lt; 8) | 255;
                  char[1] = (char) (long_length &gt;&gt;&gt; 16);
                  char[2] = (char) (long_length &amp; 0xffff);
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  If Tag is a pattern_char_index, its Length is the number of
                  pattern characters. For example, if the given pattern is
                  &quot;yyyy&quot;, Tag is 1 and Length is 4, followed by no data.
                  &lt;p&gt;
                  If Tag is TAG_QUOTE_CHARS, its Length is the number of char&apos;s
                  following the TagField. For example, if the given pattern is
                  &quot;&apos;o&apos;&apos;clock&apos;&quot;, Length is 7 followed by a char sequence of
                  &lt;code&gt;o&amp;nbs;&apos;&amp;nbs;c&amp;nbs;l&amp;nbs;o&amp;nbs;c&amp;nbs;k&lt;/code&gt;.
                  &lt;p&gt;
                  TAG_QUOTE_ASCII_CHAR is a special tag and has an ASCII
                  character in place of Length. For example, if the given pattern
                  is &quot;&apos;o&apos;&quot;, the TaggedData entry is
                  &lt;code&gt;((TAG_QUOTE_ASCII_CHAR&amp;nbs;&lt;&lt;&amp;nbs;8)&amp;nbs;|&amp;nbs;&apos;o&apos;)&lt;/code&gt;.                
                <exception>
                    NullPointerException if the given pattern is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="compile" type="char[]" line="750">
                <params>
                    <param name="pattern" type="String"/>
                </params>
                <comment line="763">
                    &apos;&apos; is treated as a single quote regardless of being
                     in a quoted section.                    
                </comment>
                <comment line="823">
                    In most cases, c would be a delimiter, such as &apos;:&apos;.                    
                </comment>
                <comment line="826">
                    Take any contiguous non-ASCII alphabet characters and
                     put them in a single TAG_QUOTE_CHARS.                    
                </comment>
                <comment line="867">
                    Copy the compiled pattern to a char array                    
                </comment>
                <declaration name="length" type="int" line="751"/>
                <declaration name="inQuote" type="boolean" line="752"/>
                <declaration name="compiledPattern" type="StringBuilder" line="753"/>
                <declaration name="tmpBuffer" type="StringBuilder" line="754"/>
                <declaration name="count" type="int" line="755"/>
                <declaration name="lastTag" type="int" line="756"/>
                <scope line="758">
                    <declaration name="c" type="char" line="759"/>
                    <scope line="761">
                        <scope line="764">
                            <scope line="766">
                                <scope line="768"/>
                                <scope line="773"/>
                                <scope line="775"/>
                            </scope>
                        </scope>
                        <scope line="781">
                            <scope line="782"/>
                            <scope line="787"/>
                            <scope line="789"/>
                        </scope>
                        <scope line="793">
                            <declaration name="len" type="int" line="794"/>
                            <scope line="795">
                                <declaration name="ch" type="char" line="796"/>
                                <scope line="797"/>
                                <scope line="799"/>
                            </scope>
                            <scope line="803"/>
                        </scope>
                    </scope>
                    <scope line="811"/>
                    <scope line="815">
                        <scope line="816"/>
                        <scope line="821"/>
                        <scope line="824">
                            <declaration name="j" type="int" line="827"/>
                            <scope line="828">
                                <declaration name="d" type="char" line="829"/>
                                <scope line="830"/>
                            </scope>
                            <scope line="835"/>
                        </scope>
                    </scope>
                    <declaration name="tag" type="int" line="843"/>
                    <scope line="844"/>
                    <scope line="848"/>
                </scope>
                <scope line="858"/>
                <scope line="862"/>
                <declaration name="len" type="int" line="867"/>
                <declaration name="r" type="char[]" line="868"/>
            </method>
            <javadoc line="873">
                Encodes the given tag and length and puts encoded char(s) into buffer.                
            </javadoc>
            <method name="encode" type="void" line="876">
                <params>
                    <param name="tag" type="int"/>
                    <param name="length" type="int"/>
                    <param name="buffer" type="StringBuilder"/>
                </params>
                <scope line="877"/>
                <scope line="880"/>
                <scope line="882"/>
            </method>
            <method name="initializeDefaultCentury" type="void" line="892"/>
            <method name="parseAmbiguousDatesAsAfter" type="void" line="901">
                <params>
                    <param name="startDate" type="Date"/>
                </params>
            </method>
            <javadoc line="907">
                Sets the 100-year period 2-digit years will be interpreted as being in
                  to begin on the date the user specifies.                
                <param>
                    startDate During parsing, two digit years will be placed in the range
                      <code>startDate</code> to <code>startDate + 100 years</code>.                    
                </param>
                <see>
                    #get2DigitYearStart                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="set2DigitYearStart" type="void" line="916">
                <params>
                    <param name="startDate" type="Date"/>
                </params>
            </method>
            <javadoc line="920">
                Returns the beginning date of the 100-year period 2-digit years are interpreted
                  as being within.                
                <return>
                    the start of the 100-year period into which two digit years are
                      parsed                    
                </return>
                <see>
                    #set2DigitYearStart                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="get2DigitYearStart" type="Date" line="929"/>
            <javadoc line="933">
                Formats the given &lt;code&gt;Date&lt;/code&gt; into a date/time string and appends
                  the result to the given &lt;code&gt;StringBuffer&lt;/code&gt;.                
                <param>
                    date the date-time value to be formatted into a date-time string.                    
                </param>
                <param>
                    toAppendTo where the new date-time text is to be appended.                    
                </param>
                <param>
                    pos the formatting position. On input: an alignment field,
                      if desired. On output: the offsets of the alignment field.                    
                </param>
                <return>
                    the formatted date-time string.                    
                </return>
                <exception>
                    NullPointerException if the given {@code date} is {@code null}.                    
                </exception>
            </javadoc>
            <method name="format" type="StringBuffer" line="946">
                <params>
                    <param name="date" type="Date"/>
                    <param name="toAppendTo" type="StringBuffer"/>
                    <param name="pos" type="FieldPosition"/>
                </params>
            </method>
            <method name="format" type="StringBuffer" line="953">
                <params>
                    <param name="date" type="Date"/>
                    <param name="toAppendTo" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                </params>
                <comment line="955">
                    Convert input date to time field list                    
                </comment>
                <declaration name="useDateFormatSymbols" type="boolean" line="957"/>
                <scope line="959">
                    <declaration name="tag" type="int" line="960"/>
                    <declaration name="count" type="int" line="961"/>
                    <scope line="962"/>
                </scope>
            </method>
            <javadoc line="985">
                Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
                  You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
                  to build the resulting String, as well as to determine information
                  about the resulting String.
                  &lt;p&gt;
                  Each attribute key of the AttributedCharacterIterator will be of type
                  &lt;code&gt;DateFormat.Field&lt;/code&gt;, with the corresponding attribute value
                  being the same as the attribute key.                
                <exception>
                    NullPointerException if obj is null.                    
                </exception>
                <exception>
                    IllegalArgumentException if the Format cannot format the
                      given object, or if the Format's pattern string is invalid.                    
                </exception>
                <param>
                    obj The object to format                    
                </param>
                <return>
                    AttributedCharacterIterator describing the formatted value.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="formatToCharacterIterator" type="AttributedCharacterIterator" line="1002">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <declaration name="sb" type="StringBuffer" line="1003"/>
                <declaration name="delegate" type="CharacterIteratorFieldDelegate" line="1004"/>
                <scope line="1007"/>
                <scope line="1010"/>
                <scope line="1013"/>
                <scope line="1017"/>
            </method>
            <declaration name="PATTERN_INDEX_TO_CALENDAR_FIELD" type="int[]" line="1025"/>
            <declaration name="PATTERN_INDEX_TO_DATE_FORMAT_FIELD" type="int[]" line="1041"/>
            <declaration name="PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID" type="Field[]" line="1056"/>
            <javadoc line="1068">
                Private member function that does the real date/time formatting.                
            </javadoc>
            <method name="subFormat" type="void" line="1074">
                <params>
                    <param name="patternCharIndex" type="int"/>
                    <param name="count" type="int"/>
                    <param name="delegate" type="FieldDelegate"/>
                    <param name="buffer" type="StringBuffer"/>
                    <param name="useDateFormatSymbols" type="boolean"/>
                </params>
                <comment line="1086">
                    use calendar year &apos;y&apos; instead                    
                </comment>
                <comment line="1102">
                    Note: zeroPaddingNumber() assumes that maxDigits is either
                     2 or maxIntCount. If we make any changes to this,
                     zeroPaddingNumber() must be fixed.                    
                </comment>
                <comment line="1107">
                    &apos;G&apos;                    
                </comment>
                <comment line="1117">
                    &apos;Y&apos;                    
                </comment>
                <comment line="1118">
                    &apos;y&apos;                    
                </comment>
                <comment line="1122">
                    count == 2                    
                </comment>
                <comment line="1123">
                    clip 1996 to 96                    
                </comment>
                <comment line="1132">
                    &apos;M&apos;                    
                </comment>
                <comment line="1152">
                    &apos;k&apos; 1-based.  eg, 23:59 + 1 hour =&gt;&gt; 24:59                    
                </comment>
                <comment line="1162">
                    &apos;E&apos;                    
                </comment>
                <comment line="1168">
                    count &lt; 4, use abbreviated form if exists                    
                </comment>
                <comment line="1175">
                    &apos;a&apos;                    
                </comment>
                <comment line="1182">
                    &apos;h&apos; 1-based.  eg, 11PM + 1 hour =&gt;&gt; 12 AM                    
                </comment>
                <comment line="1192">
                    &apos;z&apos;                    
                </comment>
                <comment line="1204">
                    Use the short name                    
                </comment>
                <comment line="1219">
                    &apos;Z&apos; (&quot;-/+hhmm&quot; form)                    
                </comment>
                <comment line="1234">
                    &apos;X&apos;                    
                </comment>
                <comment line="1263">
                    case PATTERN_DAY_OF_MONTH:         // &apos;d&apos;
                     case PATTERN_HOUR_OF_DAY0:          &apos;H&apos; 0-based.  eg, 23:59 + 1 hour =&gt;&gt; 00:59
                     case PATTERN_MINUTE:                &apos;m&apos;
                     case PATTERN_SECOND:                &apos;s&apos;
                     case PATTERN_MILLISECOND:           &apos;S&apos;
                     case PATTERN_DAY_OF_YEAR:           &apos;D&apos;
                     case PATTERN_DAY_OF_WEEK_IN_MONTH:  &apos;F&apos;
                     case PATTERN_WEEK_OF_YEAR:          &apos;w&apos;
                     case PATTERN_WEEK_OF_MONTH:         &apos;W&apos;
                     case PATTERN_HOUR0:                 &apos;K&apos; eg, 11PM + 1 hour =&gt;&gt; 0 AM
                     case PATTERN_ISO_DAY_OF_WEEK:       &apos;u&apos; pseudo field, Monday = 1, ..., Sunday = 7                    
                </comment>
                <comment line="1278">
                    switch (patternCharIndex)                    
                </comment>
                <declaration name="maxIntCount" type="int" line="1075"/>
                <declaration name="current" type="String" line="1076"/>
                <declaration name="beginOffset" type="int" line="1077"/>
                <declaration name="field" type="int" line="1079"/>
                <declaration name="value" type="int" line="1080"/>
                <scope line="1081">
                    <scope line="1082"/>
                    <scope line="1084"/>
                </scope>
                <scope line="1090"/>
                <scope line="1092"/>
                <declaration name="style" type="int" line="1096"/>
                <scope line="1097"/>
                <scope line="1107">
                    <declaration name="eras" type="String[]" line="1108"/>
                </scope>
                <scope line="1118"/>
                <scope line="1123">
                    <scope line="1124"/>
                </scope>
                <scope line="1132">
                    <declaration name="months" type="String[]" line="1133"/>
                    <scope line="1134"/>
                    <scope line="1137"/>
                </scope>
                <scope line="1141">
                    <scope line="1142"/>
                </scope>
                <scope line="1146"/>
                <scope line="1152"/>
                <scope line="1162">
                    <declaration name="weekdays" type="String[]" line="1163"/>
                    <scope line="1164"/>
                    <scope line="1167"/>
                </scope>
                <scope line="1175">
                    <declaration name="ampm" type="String[]" line="1176"/>
                </scope>
                <scope line="1182"/>
                <scope line="1192">
                    <scope line="1193">
                        <declaration name="zoneIndex" type="int" line="1194"/>
                        <scope line="1196"/>
                        <scope line="1200">
                            <declaration name="index" type="int" line="1201"/>
                            <scope line="1202"/>
                            <declaration name="zoneStrings" type="String[][]" line="1206"/>
                        </scope>
                    </scope>
                    <scope line="1209">
                        <declaration name="tz" type="TimeZone" line="1210"/>
                        <declaration name="daylight" type="boolean" line="1211"/>
                        <declaration name="tzstyle" type="int" line="1212"/>
                    </scope>
                </scope>
                <declaration name="width" type="int" line="1222"/>
                <scope line="1223"/>
                <scope line="1225"/>
                <declaration name="num" type="int" line="1229"/>
                <scope line="1237"/>
                <scope line="1243"/>
                <scope line="1245"/>
                <scope line="1251"/>
                <scope line="1255"/>
                <scope line="1273"/>
                <scope line="1279"/>
                <declaration name="fieldID" type="int" line="1283"/>
                <declaration name="f" type="Field" line="1284"/>
            </method>
            <javadoc line="1289">
                Formats a number with the specified minimum and maximum number of digits.                
            </javadoc>
            <method name="zeroPaddingNumber" type="void" line="1293">
                <params>
                    <param name="value" type="int"/>
                    <param name="minDigits" type="int"/>
                    <param name="maxDigits" type="int"/>
                    <param name="buffer" type="StringBuffer"/>
                </params>
                <comment line="1295">
                    Optimization for 1, 2 and 4 digit numbers. This should
                     cover most cases of formatting date/time related items.
                     Note: This optimization code assumes that maxDigits is
                     either 2 or Integer.MAX_VALUE (maxIntCount in format()).                    
                </comment>
                <scope line="1298">
                    <scope line="1299"/>
                    <scope line="1302">
                        <scope line="1303">
                            <scope line="1304">
                                <scope line="1305"/>
                            </scope>
                            <scope line="1309"/>
                        </scope>
                        <scope line="1314">
                            <scope line="1315"/>
                            <scope line="1324"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1330"/>
            </method>
            <javadoc line="1339">
                Parses text from a string to produce a &lt;code&gt;Date&lt;/code&gt;.
                  &lt;p&gt;
                  The method attempts to parse text starting at the index given by
                  &lt;code&gt;pos&lt;/code&gt;.
                  If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
                  to the index after the last character used (parsing does not necessarily
                  use all characters up to the end of the string), and the parsed
                  date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
                  indicate the starting point for the next call to this method.
                  If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
                  changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
                  the character where the error occurred, and null is returned.
                  &lt;p&gt;This parsing operation uses the {@link DateFormat#calendarcalendar} to produce a {@code Date}. All of the {@codecalendar}&apos;s date-time fields are {@linkplain Calendar#clear()cleared} before parsing, and the {@code calendar}&apos;s default
                  values of the date-time fields are used for any missing
                  date-time information. For example, the year value of the
                  parsed {@code Date} is 1970 with {@link GregorianCalendar} if
                  no year value is given from the parsing operation.  The {@codeTimeZone} value may be overwritten, depending on the given
                  pattern and the time zone value in {@code text}. Any {@codeTimeZone} value that has previously been set by a call to{@link #setTimeZone(java.util.TimeZone) setTimeZone} may need
                  to be restored for further operations.                
                <param>
                    text  A <code>String</code>, part of which should be parsed.                    
                </param>
                <param>
                    pos   A <code>ParsePosition</code> object with index and error
                      index information as described above.                    
                </param>
                <return>
                    A <code>Date</code> parsed from the string. In case of
                      error, returns null.                    
                </return>
                <exception>
                    NullPointerException if <code>text</code> or <code>pos</code> is null.                    
                </exception>
            </javadoc>
            <method name="parse" type="Date" line="1375">
                <params>
                    <param name="text" type="String"/>
                    <param name="pos" type="ParsePosition"/>
                </params>
                <comment line="1417">
                    Peek the next pattern to determine if we need to
                     obey the number of pattern letters for
                     parsing. It&apos;s required when parsing contiguous
                     digit text (e.g., &quot;20010704&quot;) with a pattern which
                     has no delimiters between fields, like &quot;yyyyMMdd&quot;.                    
                </comment>
                <comment line="1424">
                    In Arabic, a minus sign for a negative number is put after
                     the number. Even in another locale, a minus sign can be
                     put after a number using DateFormat.setNumberFormat().
                     If both the minus sign and the field-delimiter are &apos;-&apos;,
                     subParse() needs to determine whether a &apos;-&apos; after a number
                     in the given text is a delimiter or is a minus sign for the
                     preceding number. We give subParse() a clue based on the
                     information in compiledPattern.                    
                </comment>
                <comment line="1466">
                    At this point the fields of Calendar have been set.  Calendar
                     will fill in default values for missing fields when the time
                     is computed.                    
                </comment>
                <comment line="1475">
                    If the year value is ambiguous,
                     then the two-digit year == the default start year                    
                </comment>
                <comment line="1483">
                    An IllegalArgumentException will be thrown by Calendar.getTime()
                     if any fields are out of range, e.g., MONTH == 17.                    
                </comment>
                <declaration name="start" type="int" line="1378"/>
                <declaration name="oldStart" type="int" line="1379"/>
                <declaration name="textLength" type="int" line="1380"/>
                <declaration name="ambiguousYear" type="boolean[]" line="1382"/>
                <declaration name="calb" type="CalendarBuilder" line="1384"/>
                <scope line="1386">
                    <declaration name="tag" type="int" line="1387"/>
                    <declaration name="count" type="int" line="1388"/>
                    <scope line="1389"/>
                    <scope line="1396"/>
                    <scope line="1405">
                        <scope line="1406"/>
                    </scope>
                    <declaration name="obeyCount" type="boolean" line="1421"/>
                    <declaration name="useFollowingMinusSignAsDelimiter" type="boolean" line="1431"/>
                    <scope line="1433">
                        <declaration name="nextTag" type="int" line="1434"/>
                        <scope line="1436"/>
                        <scope line="1442">
                            <declaration name="c" type="int" line="1443"/>
                            <scope line="1444"/>
                            <scope line="1446"/>
                            <scope line="1450"/>
                        </scope>
                    </scope>
                    <scope line="1458"/>
                </scope>
                <declaration name="parsedDate" type="Date" line="1471"/>
                <scope line="1472">
                    <scope line="1476">
                        <scope line="1477"/>
                    </scope>
                </scope>
                <scope line="1484"/>
            </method>
            <javadoc line="1493">
                Private code-size reduction function used by subParse.                
                <param>
                    text the time text being parsed.                    
                </param>
                <param>
                    start where to start parsing.                    
                </param>
                <param>
                    field the date field being parsed.                    
                </param>
                <param>
                    data the string array to parsed.                    
                </param>
                <return>
                    the new start position if matching succeeded; a negative number
                      indicating matching failure, otherwise.                    
                </return>
            </javadoc>
            <method name="matchString" type="int" line="1503">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="field" type="int"/>
                    <param name="data" type="String[]"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <comment line="1510">
                    There may be multiple strings in the data[] array which begin with
                     the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).
                     We keep track of the longest match, and return that.  Note that this
                     unfortunately requires us to test all array elements.                    
                </comment>
                <comment line="1518">
                    Always compare if we have no match yet; otherwise only compare
                     against potentially better matches (longer strings).                    
                </comment>
                <declaration name="i" type="int" line="1504"/>
                <declaration name="count" type="int" line="1505"/>
                <declaration name="bestMatchLength" type="int" line="1513"/>
                <scope line="1515">
                    <declaration name="length" type="int" line="1516"/>
                    <scope line="1521"/>
                </scope>
                <scope line="1527"/>
            </method>
            <javadoc line="1534">
                Performs the same thing as matchString(String, int, int,
                  String[]). This method takes a Map&lt;String, Integer&gt; instead of
                  String[].                
            </javadoc>
            <method name="matchString" type="int" line="1540">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="field" type="int"/>
                    <param name="data" type="Map<String,Integer>"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <scope line="1541">
                    <declaration name="bestMatch" type="String" line="1542"/>
                    <scope line="1544">
                        <declaration name="length" type="int" line="1545"/>
                        <scope line="1546">
                            <scope line="1547"/>
                        </scope>
                    </scope>
                    <scope line="1553"/>
                </scope>
            </method>
            <method name="matchZoneString" type="int" line="1561">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="zoneNames" type="String[]"/>
                </params>
                <comment line="1564">
                    Checking long and short zones [1 &amp; 2],
                     and long and short daylight [3 &amp; 4].                    
                </comment>
                <scope line="1562">
                    <declaration name="zoneName" type="String" line="1565"/>
                    <scope line="1567"/>
                </scope>
            </method>
            <method name="matchDSTString" type="boolean" line="1575">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="zoneIndex" type="int"/>
                    <param name="standardIndex" type="int"/>
                    <param name="zoneStrings" type="String[][]"/>
                </params>
                <declaration name="index" type="int" line="1576"/>
                <declaration name="zoneName" type="String" line="1577"/>
                <scope line="1579"/>
            </method>
            <javadoc line="1585">
                find time zone &apos;text&apos; matched zoneStrings and set to internal
                  calendar.                
            </javadoc>
            <method name="subParseZoneString" type="int" line="1589">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <comment line="1591">
                    true if standard and daylight time use the same abbreviation.                    
                </comment>
                <comment line="1594">
                    At this point, check for named time zones by looking through
                     the locale data from the TimeZoneNames strings.
                     Want to be able to parse both short and long forms.                    
                </comment>
                <comment line="1606">
                    Check if the standard name (abbr) and the daylight name are the same.                    
                </comment>
                <comment line="1638">
                    Matched any ?                    
                </comment>
                <comment line="1642">
                    If the time zone matched uses the same name
                     (abbreviation) for both standard and daylight time,
                     let the time zone in the Calendar decide which one.
                    
                     Also if tz.getDSTSaving() returns 0 for DST, use tz to
                     determine the local time. (6645292)                    
                </comment>
                <declaration name="useSameName" type="boolean" line="1590"/>
                <declaration name="currentTimeZone" type="TimeZone" line="1591"/>
                <declaration name="zoneIndex" type="int" line="1596"/>
                <declaration name="tz" type="TimeZone" line="1597"/>
                <declaration name="zoneStrings" type="String[][]" line="1598"/>
                <declaration name="zoneNames" type="String[]" line="1599"/>
                <declaration name="nameIndex" type="int" line="1600"/>
                <scope line="1601">
                    <scope line="1603">
                        <scope line="1604"/>
                    </scope>
                </scope>
                <scope line="1611">
                    <scope line="1613">
                        <scope line="1615">
                            <scope line="1616"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1624">
                    <declaration name="len" type="int" line="1625"/>
                    <scope line="1626">
                        <scope line="1628">
                            <scope line="1629"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1637">
                    <scope line="1638"/>
                    <declaration name="dstAmount" type="int" line="1647"/>
                    <scope line="1648"/>
                </scope>
            </method>
            <javadoc line="1657">
                Parses numeric forms of time zone offset, such as &quot;hh:mm&quot;, and
                  sets calb to the parsed value.                
                <param>
                    text  the text to be parsed                    
                </param>
                <param>
                    start the character position to start parsing                    
                </param>
                <param>
                    sign  1: positive; -1: negative                    
                </param>
                <param>
                    count 0: 'Z' or "GMT+hh:mm" parsing; 1 - 3: the number of 'X's                    
                </param>
                <param>
                    colon true - colon required between hh and mm; false - no colon required                    
                </param>
                <param>
                    calb  a CalendarBuilder in which the parsed value is stored                    
                </param>
                <return>
                    updated parsed position, or its negative value to indicate a parsing error                    
                </return>
            </javadoc>
            <method name="subParseNumericZone" type="int" line="1670">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="sign" type="int"/>
                    <param name="count" type="int"/>
                    <param name="colon" type="boolean"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <comment line="1677">
                    Parse hh                    
                </comment>
                <comment line="1687">
                    If no colon in RFC 822 or &apos;X&apos; (ISO), two digits are
                     required.                    
                </comment>
                <comment line="1699">
                    Proceed with parsing mm                    
                </comment>
                <comment line="1726">
                    -(index - 1)                    
                </comment>
                <declaration name="index" type="int" line="1671"/>
                <scope line="1674">
                    <declaration name="c" type="char" line="1675"/>
                    <declaration name="hours" type="int" line="1677"/>
                    <scope line="1678"/>
                    <scope line="1683"/>
                    <scope line="1685">
                        <scope line="1688"/>
                    </scope>
                    <scope line="1693"/>
                    <declaration name="minutes" type="int" line="1696"/>
                    <scope line="1697">
                        <scope line="1700">
                            <scope line="1701"/>
                        </scope>
                        <scope line="1706"/>
                        <scope line="1711"/>
                        <scope line="1715"/>
                    </scope>
                </scope>
                <scope line="1723"/>
            </method>
            <method name="isDigit" type="boolean" line="1728">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <javadoc line="1732">
                Private member function that converts the parsed date strings into
                  timeFields. Returns -start (for ParsePosition) if failed.                
                <param>
                    text the time text to be parsed.                    
                </param>
                <param>
                    start where to start parsing.                    
                </param>
                <param>
                    ch the pattern character for the date field text to be parsed.                    
                </param>
                <param>
                    count the count of a pattern character.                    
                </param>
                <param>
                    obeyCount if true, then the next field directly abuts this one,
                      and we should use the count to know when to stop parsing.                    
                </param>
                <param>
                    ambiguousYear return parameter; upon return, if ambiguousYear[0]
                      is true, then a two-digit year was parsed and may need to be readjusted.                    
                </param>
                <param>
                    origPos origPos.errorIndex is used to return an error index
                      at which a parse error occurred, if matching failure occurs.                    
                </param>
                <return>
                    the new start position if matching succeeded; -1 indicating
                      matching failure, otherwise. In case matching failure occurred,
                      an error index is set to origPos.errorIndex.                    
                </return>
            </javadoc>
            <method name="subParse" type="int" line="1752">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="patternCharIndex" type="int"/>
                    <param name="count" type="int"/>
                    <param name="obeyCount" type="boolean"/>
                    <param name="ambiguousYear" type="boolean[]"/>
                    <param name="origPos" type="ParsePosition"/>
                    <param name="useFollowingMinusSignAsDelimiter" type="boolean"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <comment line="1759">
                    use calendar year &apos;y&apos; instead                    
                </comment>
                <comment line="1764">
                    If there are any spaces here, skip over them.  If we hit the end
                     of the string, then fail.                    
                </comment>
                <comment line="1778">
                    We handle a few special cases here where we need to parse
                     a number value.  We handle further, more generic cases below.  We need
                     to handle some of them here because some fields require extra processing on
                     the parsed value.                    
                </comment>
                <comment line="1787">
                    It would be good to unify this with the obeyCount logic below,
                     but that&apos;s going to be difficult.                    
                </comment>
                <comment line="1819">
                    &apos;G&apos;                    
                </comment>
                <comment line="1834">
                    &apos;Y&apos;                    
                </comment>
                <comment line="1835">
                    &apos;y&apos;                    
                </comment>
                <comment line="1837">
                    calendar might have text representations for year values,
                     such as &quot;\u5143&quot; in JapaneseImperialCalendar.                    
                </comment>
                <comment line="1850">
                    If there are 3 or more YEAR pattern characters, this indicates
                     that the year value is to be treated literally, without any
                     two-digit year adjustments (e.g., from &quot;01&quot; to 2001).  Otherwise
                     we made adjustments to place the 2-digit year in the proper
                     century, for parsed strings from &quot;00&quot; to &quot;99&quot;.  Any other string
                     is treated literally:  &quot;2250&quot;, &quot;-1&quot;, &quot;1&quot;, &quot;002&quot;.                    
                </comment>
                <comment line="1859">
                    Assume for example that the defaultCenturyStart is 6/18/1903.
                     This means that two-digit years will be forced into the range
                     6/18/1903 to 6/17/2003.  As a result, years 00, 01, and 02
                     correspond to 2000, 2001, and 2002.  Years 04, 05, etc. correspond
                     to 1904, 1905, etc.  If the year is 03, then it is 2003 if the
                     other fields specify a date before 6/18, or 1903 if they specify a
                     date afterwards.  As a result, 03 is an ambiguous year.  All other
                     two-digit years are unambiguous.                    
                </comment>
                <comment line="1875">
                    &apos;M&apos;                    
                </comment>
                <comment line="1876">
                    i.e., M or MM.                    
                </comment>
                <comment line="1878">
                    Don&apos;t want to parse the month if it is a string
                     while pattern uses numeric style: M or MM.
                     [We computed &apos;value&apos; above.]                    
                </comment>
                <comment line="1886">
                    count &gt;= 3 // i.e., MMM or MMMM
                     Want to be able to parse both short and long forms.
                     Try count == 4 first:                    
                </comment>
                <comment line="1894">
                    count == 4 failed, now try count == 3                    
                </comment>
                <comment line="1909">
                    &apos;k&apos; 1-based.  eg, 23:59 + 1 hour =&gt;&gt; 24:59                    
                </comment>
                <comment line="1911">
                    Validate the hour value in non-lenient                    
                </comment>
                <comment line="1916">
                    [We computed &apos;value&apos; above.]                    
                </comment>
                <comment line="1922">
                    &apos;E&apos;                    
                </comment>
                <comment line="1925">
                    Want to be able to parse both short and long forms.
                     Try count == 4 (DDDD) first:                    
                </comment>
                <comment line="1932">
                    DDDD failed, now try DDD                    
                </comment>
                <comment line="1949">
                    &apos;a&apos;                    
                </comment>
                <comment line="1963">
                    &apos;h&apos; 1-based.  eg, 11PM + 1 hour =&gt;&gt; 12 AM                    
                </comment>
                <comment line="1965">
                    Validate the hour value in non-lenient                    
                </comment>
                <comment line="1970">
                    [We computed &apos;value&apos; above.]                    
                </comment>
                <comment line="1976">
                    &apos;z&apos;                    
                </comment>
                <comment line="1977">
                    &apos;Z&apos;                    
                </comment>
                <comment line="1988">
                    Try parsing a custom time zone &quot;GMT+hh:mm&quot; or &quot;GMT&quot;.                    
                </comment>
                <comment line="2003">
                                        
                </comment>
                <comment line="2009">
                    Parse the rest as &quot;hh:mm&quot;                    
                </comment>
                <comment line="2017">
                    Try parsing the text as a time zone
                     name or abbreviation.                    
                </comment>
                <comment line="2026">
                    Parse the rest as &quot;hhmm&quot; (RFC 822)                    
                </comment>
                <comment line="2039">
                    &apos;X&apos;                    
                </comment>
                <comment line="2052">
                    parse text as &quot;+/-hh[[:]mm]&quot; based on count                    
                </comment>
                <comment line="2071">
                    case PATTERN_DAY_OF_MONTH:         // &apos;d&apos;
                     case PATTERN_HOUR_OF_DAY0:          &apos;H&apos; 0-based.  eg, 23:59 + 1 hour =&gt;&gt; 00:59
                     case PATTERN_MINUTE:                &apos;m&apos;
                     case PATTERN_SECOND:                &apos;s&apos;
                     case PATTERN_MILLISECOND:           &apos;S&apos;
                     case PATTERN_DAY_OF_YEAR:           &apos;D&apos;
                     case PATTERN_DAY_OF_WEEK_IN_MONTH:  &apos;F&apos;
                     case PATTERN_WEEK_OF_YEAR:          &apos;w&apos;
                     case PATTERN_WEEK_OF_MONTH:         &apos;W&apos;
                     case PATTERN_HOUR0:                 &apos;K&apos; 0-based.  eg, 11PM + 1 hour =&gt;&gt; 0 AM
                     case PATTERN_ISO_DAY_OF_WEEK:       &apos;u&apos; (pseudo field);                    
                </comment>
                <comment line="2083">
                    Handle &quot;generic&quot; fields                    
                </comment>
                <comment line="2111">
                    Parsing failed.                    
                </comment>
                <declaration name="number" type="Number" line="1753"/>
                <declaration name="value" type="int" line="1754"/>
                <declaration name="pos" type="ParsePosition" line="1755"/>
                <scope line="1757"/>
                <declaration name="field" type="int" line="1761"/>
                <scope line="1765">
                    <scope line="1766"/>
                    <declaration name="c" type="char" line="1770"/>
                </scope>
                <scope line="1776">
                    <scope line="1785">
                        <scope line="1788">
                            <scope line="1789"/>
                        </scope>
                        <scope line="1793"/>
                        <scope line="1796">
                            <scope line="1797"/>
                        </scope>
                        <scope line="1800">
                            <scope line="1807"/>
                        </scope>
                    </scope>
                    <declaration name="useDateFormatSymbols" type="boolean" line="1814"/>
                    <declaration name="index" type="int" line="1816"/>
                    <scope line="1819">
                        <scope line="1820"/>
                    </scope>
                    <scope line="1823">
                        <declaration name="map" type="Map&lt;String,Integer&gt;" line="1824"/>
                        <scope line="1827"/>
                    </scope>
                    <scope line="1835">
                        <declaration name="style" type="int" line="1838"/>
                        <declaration name="map" type="Map&lt;String,Integer&gt;" line="1839"/>
                        <scope line="1840">
                            <scope line="1841"/>
                        </scope>
                    </scope>
                    <scope line="1857">
                        <declaration name="ambiguousTwoDigitYear" type="int" line="1866"/>
                    </scope>
                    <scope line="1876"/>
                    <scope line="1884">
                        <declaration name="newStart" type="int" line="1888"/>
                        <scope line="1890"/>
                        <scope line="1895"/>
                    </scope>
                    <scope line="1898">
                        <declaration name="map" type="Map&lt;String,Integer&gt;" line="1899"/>
                        <scope line="1902"/>
                    </scope>
                    <scope line="1909">
                        <scope line="1911"/>
                    </scope>
                    <scope line="1922">
                        <scope line="1923">
                            <declaration name="newStart" type="int" line="1926"/>
                            <scope line="1928"/>
                            <scope line="1933"/>
                        </scope>
                        <scope line="1936">
                            <declaration name="styles" type="int[]" line="1937"/>
                            <scope line="1938">
                                <declaration name="map" type="Map&lt;String,Integer&gt;" line="1939"/>
                                <scope line="1940"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1949">
                        <scope line="1951"/>
                    </scope>
                    <scope line="1954">
                        <declaration name="map" type="Map&lt;String,Integer&gt;" line="1955"/>
                        <scope line="1956"/>
                    </scope>
                    <scope line="1963">
                        <scope line="1965"/>
                    </scope>
                    <scope line="1977">
                        <declaration name="sign" type="int" line="1978"/>
                        <scope line="1979">
                            <declaration name="c" type="char" line="1980"/>
                            <scope line="1981"/>
                            <scope line="1983"/>
                            <scope line="1986">
                                <scope line="1990">
                                    <scope line="1993">
                                        <scope line="1995"/>
                                        <scope line="1997"/>
                                    </scope>
                                    <scope line="2002"/>
                                    <declaration name="i" type="int" line="2009"/>
                                    <scope line="2011"/>
                                </scope>
                                <scope line="2015">
                                    <declaration name="i" type="int" line="2018"/>
                                    <scope line="2019"/>
                                </scope>
                            </scope>
                            <scope line="2024">
                                <declaration name="i" type="int" line="2026"/>
                                <scope line="2028"/>
                            </scope>
                        </scope>
                        <scope line="2033"/>
                    </scope>
                    <scope line="2039">
                        <scope line="2040"/>
                        <declaration name="sign" type="int" line="2044"/>
                        <declaration name="c" type="char" line="2045"/>
                        <scope line="2046"/>
                        <scope line="2052"/>
                        <scope line="2054"/>
                        <scope line="2056"/>
                        <declaration name="i" type="int" line="2060"/>
                        <scope line="2062"/>
                    </scope>
                    <scope line="2083">
                        <scope line="2084"/>
                    </scope>
                    <scope line="2088"/>
                    <scope line="2091">
                        <scope line="2098"/>
                    </scope>
                </scope>
            </method>
            <method name="getCalendarName" type="String" line="2115"/>
            <method name="useDateFormatSymbols" type="boolean" line="2119">
                <scope line="2120"/>
            </method>
            <method name="isGregorianCalendar" type="boolean" line="2126"/>
            <javadoc line="2130">
                Translates a pattern, mapping each character in the from string to the
                  corresponding character in the to string.                
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="translatePattern" type="String" line="2136">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="from" type="String"/>
                    <param name="to" type="String"/>
                </params>
                <comment line="2152">
                    patternChars is longer than localPatternChars due
                     to serialization compatibility. The pattern letters
                     unsupported by localPatternChars pass through.                    
                </comment>
                <declaration name="result" type="StringBuilder" line="2137"/>
                <declaration name="inQuote" type="boolean" line="2138"/>
                <scope line="2139">
                    <declaration name="c" type="char" line="2140"/>
                    <scope line="2141"/>
                    <scope line="2145">
                        <scope line="2148">
                            <declaration name="ci" type="int" line="2149"/>
                            <scope line="2150">
                                <scope line="2154"/>
                            </scope>
                            <scope line="2157"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="2171">
                Returns a pattern string describing this date format.                
                <return>
                    a pattern string describing this date format.                    
                </return>
            </javadoc>
            <method name="toPattern" type="String" line="2176"/>
            <javadoc line="2180">
                Returns a localized pattern string describing this date format.                
                <return>
                    a localized pattern string describing this date format.                    
                </return>
            </javadoc>
            <method name="toLocalizedPattern" type="String" line="2185"/>
            <javadoc line="2191">
                Applies the given pattern string to this date format.                
                <param>
                    pattern the new date and time pattern for this date format                    
                </param>
                <exception>
                    NullPointerException if the given pattern is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="applyPattern" type="void" line="2199">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="2204">
                Applies the given localized pattern string to this date format.                
                <param>
                    pattern a String to be mapped to the new date and time format
                      pattern for this format                    
                </param>
                <exception>
                    NullPointerException if the given pattern is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="applyLocalizedPattern" type="void" line="2212">
                <params>
                    <param name="pattern" type="String"/>
                </params>
                <declaration name="p" type="String" line="2213"/>
            </method>
            <javadoc line="2220">
                Gets a copy of the date and time format symbols of this date format.                
                <return>
                    the date and time format symbols of this date format                    
                </return>
                <see>
                    #setDateFormatSymbols                    
                </see>
            </javadoc>
            <method name="getDateFormatSymbols" type="DateFormatSymbols" line="2227"/>
            <javadoc line="2231">
                Sets the date and time format symbols of this date format.                
                <param>
                    newFormatSymbols the new date and time format symbols                    
                </param>
                <exception>
                    NullPointerException if the given newFormatSymbols is null                    
                </exception>
                <see>
                    #getDateFormatSymbols                    
                </see>
            </javadoc>
            <method name="setDateFormatSymbols" type="void" line="2239">
                <params>
                    <param name="newFormatSymbols" type="DateFormatSymbols"/>
                </params>
            </method>
            <javadoc line="2244">
                Creates a copy of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;. This also
                  clones the format&apos;s date format symbols.                
                <return>
                    a clone of this <code>SimpleDateFormat</code>                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="2250">
                <declaration name="other" type="SimpleDateFormat" line="2251"/>
            </method>
            <javadoc line="2256">
                Returns the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object.                
                <return>
                    the hash code value for this <code>SimpleDateFormat</code> object.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="2262">
                <comment line="2265">
                    just enough fields for a reasonable distribution                    
                </comment>
            </method>
            <javadoc line="2267">
                Compares the given object with this &lt;code&gt;SimpleDateFormat&lt;/code&gt; for
                  equality.                
                <return>
                    true if the given object is equal to this
                      <code>SimpleDateFormat</code>                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="2275">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="2277">
                    super does class check                    
                </comment>
                <declaration name="that" type="SimpleDateFormat" line="2277"/>
            </method>
            <javadoc line="2282">
                After reading an object from the input stream, the format
                  pattern in the object is verified.
                  &lt;p&gt;                
                <exception>
                    InvalidObjectException if the pattern is invalid                    
                </exception>
            </javadoc>
            <method name="readObject" type="void" line="2289">
                <params>
                    <param name="stream" type="ObjectInputStream"/>
                </params>
                <comment line="2300">
                    didn&apos;t have defaultCenturyStart field                    
                </comment>
                <comment line="2304">
                    fill in dependent transient field                    
                </comment>
                <comment line="2309">
                    If the deserialized object has a SimpleTimeZone, try
                     to replace it with a ZoneInfo equivalent in order to
                     be compatible with the SimpleTimeZone-based
                     implementation as much as possible.                    
                </comment>
                <scope line="2292"/>
                <scope line="2294"/>
                <scope line="2298"/>
                <scope line="2302"/>
                <declaration name="tz" type="TimeZone" line="2312"/>
                <scope line="2313">
                    <declaration name="id" type="String" line="2314"/>
                    <declaration name="zi" type="TimeZone" line="2315"/>
                    <scope line="2316"/>
                </scope>
            </method>
            <javadoc line="2322">
                Analyze the negative subpattern of DecimalFormat and set/update values
                  as necessary.                
            </javadoc>
            <method name="checkNegativeNumberExpression" type="void" line="2326">
                <comment line="2335">
                    If the negative subpattern is not absent, we have to analayze
                     it in order to check if it has a following minus sign.                    
                </comment>
                <scope line="2328">
                    <declaration name="numberPattern" type="String" line="2329"/>
                    <scope line="2330">
                        <declaration name="separatorIndex" type="int" line="2333"/>
                        <scope line="2336">
                            <declaration name="minusIndex" type="int" line="2337"/>
                            <scope line="2339"/>
                        </scope>
                    </scope>
                </scope>
            </method>
        </class>
    </source>