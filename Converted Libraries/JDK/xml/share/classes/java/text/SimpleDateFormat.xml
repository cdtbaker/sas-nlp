<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.io.IOException"/>
        <import package="java.io.InvalidObjectException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.util.Calendar"/>
        <import package="java.util.Date"/>
        <import package="java.util.GregorianCalendar"/>
        <import package="java.util.Locale"/>
        <import package="java.util.Map"/>
        <import package="java.util.MissingResourceException"/>
        <import package="java.util.ResourceBundle"/>
        <import package="java.util.SimpleTimeZone"/>
        <import package="java.util.TimeZone"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.concurrent.ConcurrentMap"/>
        <import package="sun.util.calendar.CalendarUtils"/>
        <import package="sun.util.calendar.ZoneInfoFile"/>
        <import package="sun.util.resources.LocaleData"/>
        <import package="java.text.DateFormatSymbols"/>
        <class name="SimpleDateFormat" line="20">
            <extends class="DateFormat"/>
            <javadoc line="20">
                &lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and
                  parsing dates in a locale-sensitive manner. It allows for formatting
                  (date -&gt; text), parsing (text -&gt; date), and normalization.
                  &lt;p&gt;
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; allows you to start by choosing
                  any user-defined patterns for date-time formatting. However, you
                  are encouraged to create a date-time formatter with either
                  &lt;code&gt;getTimeInstance&lt;/code&gt;, &lt;code&gt;getDateInstance&lt;/code&gt;, or
                  &lt;code&gt;getDateTimeInstance&lt;/code&gt; in &lt;code&gt;DateFormat&lt;/code&gt;. Each
                  of these class methods can return a date/time formatter initialized
                  with a default format pattern. You may modify the format pattern
                  using the &lt;code&gt;applyPattern&lt;/code&gt; methods as desired.
                  For more information on using these methods, see{@link DateFormat}.
                  &lt;h4&gt;Date and Time Patterns&lt;/h4&gt;
                  &lt;p&gt;
                  Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt;
                  strings.
                  Within date and time pattern strings, unquoted letters from
                  &lt;code&gt;&apos;A&apos;&lt;/code&gt; to &lt;code&gt;&apos;Z&apos;&lt;/code&gt; and from &lt;code&gt;&apos;a&apos;&lt;/code&gt; to
                  &lt;code&gt;&apos;z&apos;&lt;/code&gt; are interpreted as pattern letters representing the
                  components of a date or time string.
                  Text can be quoted using single quotes (&lt;code&gt;&apos;&lt;/code&gt;) to avoid
                  interpretation.
                  &lt;code&gt;&quot;&apos;&apos;&quot;&lt;/code&gt; represents a single quote.
                  All other characters are not interpreted; they&apos;re simply copied into the
                  output string during formatting or matched against the input string
                  during parsing.
                  &lt;p&gt;
                  The following pattern letters are defined (all other characters from
                  &lt;code&gt;&apos;A&apos;&lt;/code&gt; to &lt;code&gt;&apos;Z&apos;&lt;/code&gt; and from &lt;code&gt;&apos;a&apos;&lt;/code&gt; to
                  &lt;code&gt;&apos;z&apos;&lt;/code&gt; are reserved):
                  &lt;blockquote&gt;
                  &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Chart shows pattern letters, date/time component, presentation, and examples.&quot;&gt;
                  &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
                  &lt;th align=left&gt;Letter
                  &lt;th align=left&gt;Date or Time Component
                  &lt;th align=left&gt;Presentation
                  &lt;th align=left&gt;Examples
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;G&lt;/code&gt;
                  &lt;td&gt;Era designator
                  &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;AD&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;y&lt;/code&gt;
                  &lt;td&gt;Year
                  &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;1996&lt;/code&gt;; &lt;code&gt;96&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;Y&lt;/code&gt;
                  &lt;td&gt;Week year
                  &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;2009&lt;/code&gt;; &lt;code&gt;09&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;M&lt;/code&gt;
                  &lt;td&gt;Month in year
                  &lt;td&gt;&lt;a href=&quot;#month&quot;&gt;Month&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;July&lt;/code&gt;; &lt;code&gt;Jul&lt;/code&gt;; &lt;code&gt;07&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;w&lt;/code&gt;
                  &lt;td&gt;Week in year
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;27&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;W&lt;/code&gt;
                  &lt;td&gt;Week in month
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;D&lt;/code&gt;
                  &lt;td&gt;Day in year
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;189&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;d&lt;/code&gt;
                  &lt;td&gt;Day in month
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;10&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;F&lt;/code&gt;
                  &lt;td&gt;Day of week in month
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;E&lt;/code&gt;
                  &lt;td&gt;Day name in week
                  &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;Tuesday&lt;/code&gt;; &lt;code&gt;Tue&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;u&lt;/code&gt;
                  &lt;td&gt;Day number of week (1 = Monday, ..., 7 = Sunday)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;1&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;a&lt;/code&gt;
                  &lt;td&gt;Am/pm marker
                  &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;PM&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;H&lt;/code&gt;
                  &lt;td&gt;Hour in day (0-23)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;k&lt;/code&gt;
                  &lt;td&gt;Hour in day (1-24)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;24&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;K&lt;/code&gt;
                  &lt;td&gt;Hour in am/pm (0-11)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;h&lt;/code&gt;
                  &lt;td&gt;Hour in am/pm (1-12)
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;12&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;m&lt;/code&gt;
                  &lt;td&gt;Minute in hour
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;30&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;s&lt;/code&gt;
                  &lt;td&gt;Second in minute
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;55&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;S&lt;/code&gt;
                  &lt;td&gt;Millisecond
                  &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;978&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;z&lt;/code&gt;
                  &lt;td&gt;Time zone
                  &lt;td&gt;&lt;a href=&quot;#timezone&quot;&gt;General time zone&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;Pacific Standard Time&lt;/code&gt;; &lt;code&gt;PST&lt;/code&gt;; &lt;code&gt;GMT-08:00&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;Z&lt;/code&gt;
                  &lt;td&gt;Time zone
                  &lt;td&gt;&lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zone&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;-0800&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;X&lt;/code&gt;
                  &lt;td&gt;Time zone
                  &lt;td&gt;&lt;a href=&quot;#iso8601timezone&quot;&gt;ISO 8601 time zone&lt;/a&gt;
                  &lt;td&gt;&lt;code&gt;-08&lt;/code&gt;; &lt;code&gt;-0800&lt;/code&gt;;  &lt;code&gt;-08:00&lt;/code&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  Pattern letters are usually repeated, as their number determines the
                  exact presentation:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;text&quot;&gt;Text:&lt;/a&gt;&lt;/strong&gt;
                  For formatting, if the number of pattern letters is 4 or more,
                  the full form is used; otherwise a short or abbreviated form
                  is used if available.
                  For parsing, both forms are accepted, independent of the number
                  of pattern letters.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;number&quot;&gt;Number:&lt;/a&gt;&lt;/strong&gt;
                  For formatting, the number of pattern letters is the minimum
                  number of digits, and shorter numbers are zero-padded to this amount.
                  For parsing, the number of pattern letters is ignored unless
                  it&apos;s needed to separate two adjacent fields.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;year&quot;&gt;Year:&lt;/a&gt;&lt;/strong&gt;
                  If the formatter&apos;s {@link #getCalendar() Calendar} is the Gregorian
                  calendar, the following rules are applied.&lt;br&gt;
                  &lt;ul&gt;
                  &lt;li&gt;For formatting, if the number of pattern letters is 2, the year
                  is truncated to 2 digits; otherwise it is interpreted as a
                  &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.
                  &lt;li&gt;For parsing, if the number of pattern letters is more than 2,
                  the year is interpreted literally, regardless of the number of
                  digits. So using the pattern &quot;MM/dd/yyyy&quot;, &quot;01/11/12&quot; parses to
                  Jan 11, 12 A.D.
                  &lt;li&gt;For parsing with the abbreviated year pattern (&quot;y&quot; or &quot;yy&quot;),
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; must interpret the abbreviated year
                  relative to some century.  It does this by adjusting dates to be
                  within 80 years before and 20 years after the time the &lt;code&gt;SimpleDateFormat&lt;/code&gt;
                  instance is created. For example, using a pattern of &quot;MM/dd/yy&quot; and a
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; instance created on Jan 1, 1997,  the string
                  &quot;01/11/12&quot; would be interpreted as Jan 11, 2012 while the string &quot;05/04/64&quot;
                  would be interpreted as May 4, 1964.
                  During parsing, only strings consisting of exactly two digits, as defined by{@link Character#isDigit(char)}, will be parsed into the default century.
                  Any other numeric string, such as a one digit string, a three or more digit
                  string, or a two digit string that isn&apos;t all digits (for example, &quot;-1&quot;), is
                  interpreted literally.  So &quot;01/02/3&quot; or &quot;01/02/003&quot; are parsed, using the
                  same pattern, as Jan 2, 3 AD.  Likewise, &quot;01/02/-3&quot; is parsed as Jan 2, 4 BC.
                  &lt;/ul&gt;
                  Otherwise, calendar system specific forms are applied.
                  For both formatting and parsing, if the number of pattern
                  letters is 4 or more, a calendar specific {@linkplain Calendar#LONG long form} is used. Otherwise, a calendar
                  specific {@linkplain Calendar#SHORT short or abbreviated form}is used.&lt;br&gt;
                  &lt;br&gt;
                  If week year {@code &apos;Y&apos;} is specified and the {@linkplain #getCalendar() calendar} doesn&apos;t support any &lt;a
                  href=&quot;../util/GregorianCalendar.html#week_year&quot;&gt; week
                  years&lt;/a&gt;, the calendar year ({@code &apos;y&apos;}) is used instead. The
                  support of week years can be tested with a call to {@link DateFormat#getCalendar() getCalendar()}.{@link java.util.Calendar#isWeekDateSupported()isWeekDateSupported()}.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;month&quot;&gt;Month:&lt;/a&gt;&lt;/strong&gt;
                  If the number of pattern letters is 3 or more, the month is
                  interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;; otherwise,
                  it is interpreted as a &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;timezone&quot;&gt;General time zone:&lt;/a&gt;&lt;/strong&gt;
                  Time zones are interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; if they have
                  names. For time zones representing a GMT offset value, the
                  following syntax is used:
                  &lt;pre&gt;
                  &lt;a name=&quot;GMTOffsetTimeZone&quot;&gt;&lt;i&gt;GMTOffsetTimeZone:&lt;/i&gt;&lt;/a&gt;
                  &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;
                  &lt;i&gt;Sign:&lt;/i&gt; one of
                  &lt;code&gt;+ -&lt;/code&gt;
                  &lt;i&gt;Hours:&lt;/i&gt;
                  &lt;i&gt;Digit&lt;/i&gt;
                  &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                  &lt;i&gt;Minutes:&lt;/i&gt;
                  &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
                  &lt;i&gt;Digit:&lt;/i&gt; one of
                  &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;
                  &lt;i&gt;Hours&lt;/i&gt; must be between 0 and 23, and &lt;i&gt;Minutes&lt;/i&gt; must be between
                  00 and 59. The format is locale independent and digits must be taken
                  from the Basic Latin block of the Unicode standard.
                  &lt;p&gt;For parsing, &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt; are also
                  accepted.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;rfc822timezone&quot;&gt;RFC 822 time zone:&lt;/a&gt;&lt;/strong&gt;
                  For formatting, the RFC 822 4-digit time zone format is used:
                  &lt;pre&gt;
                  &lt;i&gt;RFC822TimeZone:&lt;/i&gt;
                  &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
                  &lt;i&gt;TwoDigitHours:&lt;/i&gt;
                  &lt;i&gt;Digit Digit&lt;/i&gt;&lt;/pre&gt;
                  &lt;i&gt;TwoDigitHours&lt;/i&gt; must be between 00 and 23. Other definitions
                  are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt;.
                  &lt;p&gt;For parsing, &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; are also
                  accepted.
                  &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;iso8601timezone&quot;&gt;ISO 8601 Time zone:&lt;/a&gt;&lt;/strong&gt;
                  The number of pattern letters designates the format for both formatting
                  and parsing as follows:
                  &lt;pre&gt;
                  &lt;i&gt;ISO8601TimeZone:&lt;/i&gt;
                  &lt;i&gt;OneLetterISO8601TimeZone&lt;/i&gt;
                  &lt;i&gt;TwoLetterISO8601TimeZone&lt;/i&gt;
                  &lt;i&gt;ThreeLetterISO8601TimeZone&lt;/i&gt;
                  &lt;i&gt;OneLetterISO8601TimeZone:&lt;/i&gt;
                  &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt;{@code Z}&lt;i&gt;TwoLetterISO8601TimeZone:&lt;/i&gt;
                  &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;{@code Z}&lt;i&gt;ThreeLetterISO8601TimeZone:&lt;/i&gt;
                  &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; {@code :} &lt;i&gt;Minutes&lt;/i&gt;{@code Z}&lt;/pre&gt;
                  Other definitions are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; or
                  &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt;.
                  &lt;p&gt;For formatting, if the offset value from GMT is 0, {@code &quot;Z&quot;} is
                  produced. If the number of pattern letters is 1, any fraction of an hour
                  is ignored. For example, if the pattern is {@code &quot;X&quot;} and the time zone is{@code &quot;GMT+05:30&quot;}, {@code &quot;+05&quot;} is produced.
                  &lt;p&gt;For parsing, {@code &quot;Z&quot;} is parsed as the UTC time zone designator.
                  &lt;a href=&quot;#timezone&quot;&gt;General time zones&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; accepted.
                  &lt;p&gt;If the number of pattern letters is 4 or more, {@link IllegalArgumentException} is thrown when constructing a {@codeSimpleDateFormat} or {@linkplain #applyPattern(String) applying a
                  pattern}.
                  &lt;/ul&gt;
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; also supports &lt;em&gt;localized date and time
                  pattern&lt;/em&gt; strings. In these strings, the pattern letters described above
                  may be replaced with other, locale dependent, pattern letters.
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt; does not deal with the localization of text
                  other than the pattern letters; that&apos;s up to the client of the class.
                  &lt;p&gt;
                  &lt;h4&gt;Examples&lt;/h4&gt;
                  The following examples show how date and time patterns are interpreted in
                  the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time
                  in the U.S. Pacific Time time zone.
                  &lt;blockquote&gt;
                  &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Examples of date and time patterns interpreted in the U.S. locale&quot;&gt;
                  &lt;tr bgcolor=&quot;#ccccff&quot;&gt;
                  &lt;th align=left&gt;Date and Time Pattern
                  &lt;th align=left&gt;Result
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyyy.MM.dd G &apos;at&apos; HH:mm:ss z&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;2001.07.04 AD at 12:08:56 PDT&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;EEE, MMM d, &apos;&apos;yy&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;Wed, Jul 4, &apos;01&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;h:mm a&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;12:08 PM&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;hh &apos;o&apos;&apos;clock&apos; a, zzzz&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;12 o&apos;clock PM, Pacific Daylight Time&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;K:mm a, z&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;0:08 PM, PDT&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;02001.July.04 AD 12:08 PM&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;EEE, d MMM yyyy HH:mm:ss Z&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;Wed, 4 Jul 2001 12:08:56 -0700&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyMMddHHmmssZ&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;010704120856-0700&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSZ&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-0700&lt;/code&gt;
                  &lt;tr bgcolor=&quot;#eeeeff&quot;&gt;
                  &lt;td&gt;&lt;code&gt;&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSXXX&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-07:00&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;&quot;YYYY-&apos;W&apos;ww-u&quot;&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;2001-W27-3&lt;/code&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt;
                  Date formats are not synchronized.
                  It is recommended to create separate format instances for each thread.
                  If multiple threads access a format concurrently, it must be synchronized
                  externally.                
                <see>
                    &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/i18n/format/simpleDateFormat.html&quot;&gt;Java Tutorial&lt;/a&gt;                    
                </see>
                <see>
                    java.util.Calendar                    
                </see>
                <see>
                    java.util.TimeZone                    
                </see>
                <see>
                    DateFormat                    
                </see>
                <see>
                    DateFormatSymbols                    
                </see>
                <author>
                    Mark Davis, Chen-Lieh Huang, Alan Liu                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="341"/>
            <declaration name="currentSerialVersion" type="int" line="342"/>
            <declaration name="serialVersionOnStream" type="int" line="343"/>
            <javadoc line="343">
                The version of the serialized data on the stream.  Possible values:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream: JDK 1.1.3.  This version
                  has no &lt;code&gt;defaultCenturyStart&lt;/code&gt; on stream.
                  &lt;li&gt;&lt;b&gt;1&lt;/b&gt; JDK 1.1.4 or later.  This version adds
                  &lt;code&gt;defaultCenturyStart&lt;/code&gt;.
                  &lt;/ul&gt;
                  When streaming out this class, the most recent format
                  and the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;
                  is written.                
                <serial>
                                        
                </serial>
                <since>
                    JDK1.1.4                    
                </since>
            </javadoc>
            <declaration name="pattern" type="String" line="358"/>
            <javadoc line="358">
                The pattern string of this formatter.  This is always a non-localized
                  pattern.  May not be null.  See class documentation for details.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="originalNumberFormat" type="NumberFormat" line="364"/>
            <javadoc line="364">
                Saved numberFormat and pattern.                
                <see>
                    SimpleDateFormat#checkNegativeNumberExpression                    
                </see>
            </javadoc>
            <declaration name="originalNumberPattern" type="String" line="369"/>
            <declaration name="minusSign" type="char" line="370"/>
            <javadoc line="370">
                The minus sign to be used with format and parse.                
            </javadoc>
            <declaration name="hasFollowingMinusSign" type="boolean" line="374"/>
            <javadoc line="374">
                True when a negative sign follows a number.
                  (True as default in Arabic.)                
            </javadoc>
            <declaration name="compiledPattern" type="char[]" line="379"/>
            <javadoc line="379">
                The compiled pattern.                
            </javadoc>
            <declaration name="TAG_QUOTE_ASCII_CHAR" type="int" line="383"/>
            <javadoc line="383">
                Tags for the compiled pattern.                
            </javadoc>
            <declaration name="TAG_QUOTE_CHARS" type="int" line="387"/>
            <declaration name="zeroDigit" type="char" line="388"/>
            <javadoc line="388">
                Locale dependent digit zero.                
                <see>
                    #zeroPaddingNumber                    
                </see>
                <see>
                    java.text.DecimalFormatSymbols#getZeroDigit                    
                </see>
            </javadoc>
            <declaration name="formatData" type="DateFormatSymbols" line="394"/>
            <javadoc line="394">
                The symbols used by this formatter for week names, month names,
                  etc.  May not be null.                
                <serial>
                                        
                </serial>
                <see>
                    java.text.DateFormatSymbols                    
                </see>
            </javadoc>
            <declaration name="defaultCenturyStart" type="Date" line="401"/>
            <javadoc line="401">
                We map dates with two-digit years into the century starting at
                  &lt;code&gt;defaultCenturyStart&lt;/code&gt;, which may be any date.  May
                  not be null.                
                <serial>
                                        
                </serial>
                <since>
                    JDK1.1.4                    
                </since>
            </javadoc>
            <declaration name="defaultCenturyStartYear" type="int" line="409"/>
            <declaration name="MILLIS_PER_MINUTE" type="int" line="410"/>
            <declaration name="GMT" type="String" line="411"/>
            <declaration name="cachedLocaleData" type="ConcurrentMap&amp;lt;Locale,String[]&amp;gt;" line="412"/>
            <javadoc line="412">
                Cache to hold the DateTimePatterns of a Locale.                
            </javadoc>
            <declaration name="cachedNumberFormatData" type="ConcurrentMap&amp;lt;Locale,NumberFormat&amp;gt;" line="416"/>
            <javadoc line="416">
                Cache NumberFormat instances with Locale key.                
            </javadoc>
            <declaration name="locale" type="Locale" line="420"/>
            <javadoc line="420">
                The Locale used to instantiate this
                  &lt;code&gt;SimpleDateFormat&lt;/code&gt;. The value may be null if this object
                  has been created by an older &lt;code&gt;SimpleDateFormat&lt;/code&gt; and
                  deserialized.                
                <serial>
                                        
                </serial>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="useDateFormatSymbols" type="boolean" line="429"/>
            <javadoc line="429">
                Indicates whether this &lt;code&gt;SimpleDateFormat&lt;/code&gt; should use
                  the DateFormatSymbols. If true, the format and parse methods
                  use the DateFormatSymbols values. If false, the format and
                  parse methods call Calendar.getDisplayName or
                  Calendar.getDisplayNames.                
            </javadoc>
            <javadoc line="437">
                Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the default pattern and
                  date format symbols for the default locale.
                  &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
                  For full coverage, use the factory methods in the {@link DateFormat}class.                
            </javadoc>
            <method name="SimpleDateFormat" type="constructor" line="443"/>
            <javadoc line="446">
                Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
                  the default date format symbols for the default locale.
                  &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
                  For full coverage, use the factory methods in the {@link DateFormat}class.                
                <param>
                    pattern the pattern describing the date and time format                    
                </param>
                <exception>
                    NullPointerException if the given pattern is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="SimpleDateFormat" type="constructor" line="455">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="458">
                Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
                  the default date format symbols for the given locale.
                  &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
                  For full coverage, use the factory methods in the {@link DateFormat}class.                
                <param>
                    pattern the pattern describing the date and time format                    
                </param>
                <param>
                    locale the locale whose date format symbols should be used                    
                </param>
                <exception>
                    NullPointerException if the given pattern or locale is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="SimpleDateFormat" type="constructor" line="468">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="locale" type="Locale"/>
                </params>
                <scope line="469"/>
            </method>
            <javadoc line="478">
                Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
                  date format symbols.                
                <param>
                    pattern the pattern describing the date and time format                    
                </param>
                <param>
                    formatSymbols the date format symbols to be used for formatting                    
                </param>
                <exception>
                    NullPointerException if the given pattern or formatSymbols is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="SimpleDateFormat" type="constructor" line="486">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="formatSymbols" type="DateFormatSymbols"/>
                </params>
                <scope line="487"/>
            </method>
            <method name="SimpleDateFormat" type="constructor" line="497">
                <params>
                    <param name="timeStyle" type="int"/>
                    <param name="dateStyle" type="int"/>
                    <param name="loc" type="Locale"/>
                </params>
                <scope line="498"/>
                <declaration name="dateTimePatterns" type="String[]" line="503"/>
                <scope line="504">
                    <declaration name="r" type="ResourceBundle" line="505"/>
                    <scope line="506">
                        <scope line="507"/>
                        <scope line="510"/>
                    </scope>
                    <scope line="513"/>
                </scope>
                <scope line="519">
                    <declaration name="dateTimeArgs" type="Object[]" line="520"/>
                </scope>
                <scope line="523"/>
                <scope line="526"/>
                <scope line="529"/>
            </method>
            <method name="initialize" type="void" line="534">
                <params>
                    <param name="loc" type="Locale"/>
                </params>
                <scope line="537"/>
            </method>
            <method name="initializeCalendar" type="void" line="545">
                <params>
                    <param name="loc" type="Locale"/>
                </params>
            </method>
            <javadoc line="551">
                Returns the compiled form of the given pattern. The syntax of
                  the compiled pattern is:
                  &lt;blockquote&gt;
                  CompiledPattern:
                  EntryList
                  EntryList:
                  Entry
                  EntryList Entry
                  Entry:
                  TagField
                  TagField data
                  TagField:
                  Tag Length
                  TaggedData
                  Tag:
                  pattern_char_index
                  TAG_QUOTE_CHARS
                  Length:
                  short_length
                  long_length
                  TaggedData:
                  TAG_QUOTE_ASCII_CHAR ascii_char
                  &lt;/blockquote&gt;
                  where `short_length&apos; is an 8-bit unsigned integer between 0 and
                  254.  `long_length&apos; is a sequence of an 8-bit integer 255 and a
                  32-bit signed integer value which is split into upper and lower
                  16-bit fields in two char&apos;s. `pattern_char_index&apos; is an 8-bit
                  integer between 0 and 18. `ascii_char&apos; is an 7-bit ASCII
                  character value. `data&apos; depends on its Tag value.
                  &lt;p&gt;
                  If Length is short_length, Tag and short_length are packed in a
                  single char, as illustrated below.
                  &lt;blockquote&gt;
                  char[0] = (Tag &lt;&lt; 8) | short_length;
                  &lt;/blockquote&gt;
                  If Length is long_length, Tag and 255 are packed in the first
                  char and a 32-bit integer, as illustrated below.
                  &lt;blockquote&gt;
                  char[0] = (Tag &lt;&lt; 8) | 255;
                  char[1] = (char) (long_length &gt;&gt;&gt; 16);
                  char[2] = (char) (long_length &amp; 0xffff);
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  If Tag is a pattern_char_index, its Length is the number of
                  pattern characters. For example, if the given pattern is
                  &quot;yyyy&quot;, Tag is 1 and Length is 4, followed by no data.
                  &lt;p&gt;
                  If Tag is TAG_QUOTE_CHARS, its Length is the number of char&apos;s
                  following the TagField. For example, if the given pattern is
                  &quot;&apos;o&apos;&apos;clock&apos;&quot;, Length is 7 followed by a char sequence of
                  &lt;code&gt;o&amp;nbs;&apos;&amp;nbs;c&amp;nbs;l&amp;nbs;o&amp;nbs;c&amp;nbs;k&lt;/code&gt;.
                  &lt;p&gt;
                  TAG_QUOTE_ASCII_CHAR is a special tag and has an ASCII
                  character in place of Length. For example, if the given pattern
                  is &quot;&apos;o&apos;&quot;, the TaggedData entry is
                  &lt;code&gt;((TAG_QUOTE_ASCII_CHAR&amp;nbs;&lt;&lt;&amp;nbs;8)&amp;nbs;|&amp;nbs;&apos;o&apos;)&lt;/code&gt;.                
                <exception>
                    NullPointerException if the given pattern is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="compile" type="char[]" line="611">
                <params>
                    <param name="pattern" type="String"/>
                </params>
                <declaration name="length" type="int" line="612"/>
                <declaration name="inQuote" type="boolean" line="613"/>
                <declaration name="compiledPattern" type="StringBuilder" line="614"/>
                <declaration name="tmpBuffer" type="StringBuilder" line="615"/>
                <declaration name="count" type="int" line="616"/>
                <declaration name="lastTag" type="int" line="617"/>
                <scope line="618">
                    <declaration name="c" type="char" line="619"/>
                    <scope line="620">
                        <scope line="621">
                            <scope line="623">
                                <scope line="625"/>
                                <scope line="630"/>
                                <scope line="633"/>
                            </scope>
                        </scope>
                        <scope line="639">
                            <scope line="640"/>
                            <scope line="645"/>
                            <scope line="648"/>
                        </scope>
                        <scope line="653">
                            <declaration name="len" type="int" line="654"/>
                            <scope line="655">
                                <declaration name="ch" type="char" line="656"/>
                                <scope line="657"/>
                                <scope line="660"/>
                            </scope>
                            <scope line="665"/>
                        </scope>
                    </scope>
                    <scope line="673"/>
                    <scope line="677">
                        <scope line="678"/>
                        <scope line="683"/>
                        <scope line="686">
                            <declaration name="j" type="int" line="687"/>
                            <scope line="688">
                                <declaration name="d" type="char" line="689"/>
                                <scope line="690"/>
                            </scope>
                            <scope line="695"/>
                        </scope>
                    </scope>
                    <declaration name="tag" type="int" line="702"/>
                    <scope line="703"/>
                    <scope line="706"/>
                </scope>
                <scope line="715"/>
                <scope line="718"/>
                <declaration name="len" type="int" line="721"/>
                <declaration name="r" type="char[]" line="722"/>
            </method>
            <javadoc line="726">
                Encodes the given tag and length and puts encoded char(s) into buffer.                
            </javadoc>
            <method name="encode" type="void" line="729">
                <params>
                    <param name="tag" type="int"/>
                    <param name="length" type="int"/>
                    <param name="buffer" type="StringBuilder"/>
                </params>
                <scope line="730"/>
                <scope line="733"/>
                <scope line="736"/>
            </method>
            <method name="initializeDefaultCentury" type="void" line="742"/>
            <method name="parseAmbiguousDatesAsAfter" type="void" line="747">
                <params>
                    <param name="startDate" type="Date"/>
                </params>
            </method>
            <javadoc line="752">
                Sets the 100-year period 2-digit years will be interpreted as being in
                  to begin on the date the user specifies.                
                <param>
                    startDate During parsing, two digit years will be placed in the range
                      &lt;code&gt;startDate&lt;/code&gt; to &lt;code&gt;startDate + 100 years&lt;/code&gt;.                    
                </param>
                <see>
                    #get2DigitYearStart                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="set2DigitYearStart" type="void" line="760">
                <params>
                    <param name="startDate" type="Date"/>
                </params>
            </method>
            <javadoc line="763">
                Returns the beginning date of the 100-year period 2-digit years are interpreted
                  as being within.                
                <return>
                    the start of the 100-year period into which two digit years are
                      parsed                    
                </return>
                <see>
                    #set2DigitYearStart                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="get2DigitYearStart" type="Date" line="771"/>
            <javadoc line="774">
                Formats the given &lt;code&gt;Date&lt;/code&gt; into a date/time string and appends
                  the result to the given &lt;code&gt;StringBuffer&lt;/code&gt;.                
                <param>
                    date the date-time value to be formatted into a date-time string.                    
                </param>
                <param>
                    toAppendTo where the new date-time text is to be appended.                    
                </param>
                <param>
                    pos the formatting position. On input: an alignment field,
                      if desired. On output: the offsets of the alignment field.                    
                </param>
                <return>
                    the formatted date-time string.                    
                </return>
                <exception>
                    NullPointerException if the given {@code date} is {@code null}.                    
                </exception>
            </javadoc>
            <method name="format" type="StringBuffer" line="784">
                <params>
                    <param name="date" type="Date"/>
                    <param name="toAppendTo" type="StringBuffer"/>
                    <param name="pos" type="FieldPosition"/>
                </params>
            </method>
            <method name="format" type="StringBuffer" line="788">
                <params>
                    <param name="date" type="Date"/>
                    <param name="toAppendTo" type="StringBuffer"/>
                    <param name="delegate" type="FieldDelegate"/>
                </params>
                <declaration name="useDateFormatSymbols" type="boolean" line="790"/>
                <scope line="791">
                    <declaration name="tag" type="int" line="792"/>
                    <declaration name="count" type="int" line="793"/>
                    <scope line="794"/>
                </scope>
            </method>
            <javadoc line="813">
                Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
                  You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
                  to build the resulting String, as well as to determine information
                  about the resulting String.
                  &lt;p&gt;
                  Each attribute key of the AttributedCharacterIterator will be of type
                  &lt;code&gt;DateFormat.Field&lt;/code&gt;, with the corresponding attribute value
                  being the same as the attribute key.                
                <exception>
                    NullPointerException if obj is null.                    
                </exception>
                <exception>
                    IllegalArgumentException if the Format cannot format the
                      given object, or if the Format&apos;s pattern string is invalid.                    
                </exception>
                <param>
                    obj The object to format                    
                </param>
                <return>
                    AttributedCharacterIterator describing the formatted value.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="formatToCharacterIterator" type="AttributedCharacterIterator" line="829">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <declaration name="sb" type="StringBuffer" line="830"/>
                <declaration name="delegate" type="CharacterIteratorFieldDelegate" line="831"/>
                <scope line="832"/>
                <scope line="835"/>
                <scope line="838"/>
                <scope line="841"/>
            </method>
            <declaration name="PATTERN_INDEX_TO_CALENDAR_FIELD" type="int[]" line="846"/>
            <declaration name="PATTERN_INDEX_TO_DATE_FORMAT_FIELD" type="int[]" line="847"/>
            <declaration name="PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID" type="Field[]" line="848"/>
            <javadoc line="849">
                Private member function that does the real date/time formatting.                
            </javadoc>
            <method name="subFormat" type="void" line="852">
                <params>
                    <param name="patternCharIndex" type="int"/>
                    <param name="count" type="int"/>
                    <param name="delegate" type="FieldDelegate"/>
                    <param name="buffer" type="StringBuffer"/>
                    <param name="useDateFormatSymbols" type="boolean"/>
                </params>
                <declaration name="maxIntCount" type="int" line="853"/>
                <declaration name="current" type="String" line="854"/>
                <declaration name="beginOffset" type="int" line="855"/>
                <declaration name="field" type="int" line="856"/>
                <declaration name="value" type="int" line="857"/>
                <scope line="858">
                    <scope line="859"/>
                    <scope line="862"/>
                </scope>
                <scope line="868"/>
                <scope line="871"/>
                <declaration name="style" type="int" line="874"/>
                <scope line="875"/>
                <scope line="880">
                    <declaration name="eras" type="String[]" line="881"/>
                </scope>
                <scope line="888"/>
                <scope line="892">
                    <scope line="893"/>
                </scope>
                <scope line="899">
                    <declaration name="months" type="String[]" line="900"/>
                    <scope line="901"/>
                    <scope line="905"/>
                </scope>
                <scope line="910">
                    <scope line="911"/>
                </scope>
                <scope line="915"/>
                <scope line="920"/>
                <scope line="926">
                    <declaration name="weekdays" type="String[]" line="927"/>
                    <scope line="928"/>
                    <scope line="932"/>
                </scope>
                <scope line="939">
                    <declaration name="ampm" type="String[]" line="940"/>
                </scope>
                <scope line="945"/>
                <scope line="951">
                    <scope line="952">
                        <declaration name="zoneIndex" type="int" line="953"/>
                        <scope line="954"/>
                        <scope line="958">
                            <declaration name="index" type="int" line="959"/>
                            <scope line="960"/>
                            <declaration name="zoneStrings" type="String[][]" line="963"/>
                        </scope>
                    </scope>
                    <scope line="967">
                        <declaration name="tz" type="TimeZone" line="968"/>
                        <declaration name="daylight" type="boolean" line="969"/>
                        <declaration name="tzstyle" type="int" line="970"/>
                    </scope>
                </scope>
                <declaration name="width" type="int" line="977"/>
                <scope line="978"/>
                <scope line="981"/>
                <declaration name="num" type="int" line="984"/>
                <scope line="989"/>
                <scope line="994"/>
                <scope line="997"/>
                <scope line="1002"/>
                <scope line="1005"/>
                <scope line="1011"/>
                <scope line="1016"/>
                <declaration name="fieldID" type="int" line="1019"/>
                <declaration name="f" type="Field" line="1020"/>
            </method>
            <javadoc line="1023">
                Formats a number with the specified minimum and maximum number of digits.                
            </javadoc>
            <method name="zeroPaddingNumber" type="void" line="1026">
                <params>
                    <param name="value" type="int"/>
                    <param name="minDigits" type="int"/>
                    <param name="maxDigits" type="int"/>
                    <param name="buffer" type="StringBuffer"/>
                </params>
                <scope line="1027">
                    <scope line="1028"/>
                    <scope line="1031">
                        <scope line="1032">
                            <scope line="1033">
                                <scope line="1034"/>
                            </scope>
                            <scope line="1039"/>
                        </scope>
                        <scope line="1045">
                            <scope line="1046"/>
                            <scope line="1055"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1062"/>
            </method>
            <javadoc line="1068">
                Parses text from a string to produce a &lt;code&gt;Date&lt;/code&gt;.
                  &lt;p&gt;
                  The method attempts to parse text starting at the index given by
                  &lt;code&gt;pos&lt;/code&gt;.
                  If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
                  to the index after the last character used (parsing does not necessarily
                  use all characters up to the end of the string), and the parsed
                  date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
                  indicate the starting point for the next call to this method.
                  If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
                  changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
                  the character where the error occurred, and null is returned.
                  &lt;p&gt;This parsing operation uses the {@link DateFormat#calendarcalendar} to produce a {@code Date}. All of the {@codecalendar}&apos;s date-time fields are {@linkplain Calendar#clear()cleared} before parsing, and the {@code calendar}&apos;s default
                  values of the date-time fields are used for any missing
                  date-time information. For example, the year value of the
                  parsed {@code Date} is 1970 with {@link GregorianCalendar} if
                  no year value is given from the parsing operation.  The {@codeTimeZone} value may be overwritten, depending on the given
                  pattern and the time zone value in {@code text}. Any {@codeTimeZone} value that has previously been set by a call to{@link #setTimeZone(java.util.TimeZone) setTimeZone} may need
                  to be restored for further operations.                
                <param>
                    text  A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.                    
                </param>
                <param>
                    pos   A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
                      index information as described above.                    
                </param>
                <return>
                    A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of
                      error, returns null.                    
                </return>
                <exception>
                    NullPointerException if &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;pos&lt;/code&gt; is null.                    
                </exception>
            </javadoc>
            <method name="parse" type="Date" line="1095">
                <params>
                    <param name="text" type="String"/>
                    <param name="pos" type="ParsePosition"/>
                </params>
                <declaration name="start" type="int" line="1097"/>
                <declaration name="oldStart" type="int" line="1098"/>
                <declaration name="textLength" type="int" line="1099"/>
                <declaration name="ambiguousYear" type="boolean[]" line="1100"/>
                <declaration name="calb" type="CalendarBuilder" line="1101"/>
                <scope line="1102">
                    <declaration name="tag" type="int" line="1103"/>
                    <declaration name="count" type="int" line="1104"/>
                    <scope line="1105"/>
                    <scope line="1111"/>
                    <scope line="1119">
                        <scope line="1120"/>
                    </scope>
                    <declaration name="obeyCount" type="boolean" line="1129"/>
                    <declaration name="useFollowingMinusSignAsDelimiter" type="boolean" line="1130"/>
                    <scope line="1131">
                        <declaration name="nextTag" type="int" line="1132"/>
                        <scope line="1133"/>
                        <scope line="1136">
                            <declaration name="c" type="int" line="1137"/>
                            <scope line="1138"/>
                            <scope line="1141"/>
                            <scope line="1144"/>
                        </scope>
                    </scope>
                    <scope line="1150"/>
                </scope>
                <declaration name="parsedDate" type="Date" line="1157"/>
                <scope line="1158">
                    <scope line="1160">
                        <scope line="1161"/>
                    </scope>
                </scope>
                <scope line="1166"/>
            </method>
            <javadoc line="1173">
                Private code-size reduction function used by subParse.                
                <param>
                    text the time text being parsed.                    
                </param>
                <param>
                    start where to start parsing.                    
                </param>
                <param>
                    field the date field being parsed.                    
                </param>
                <param>
                    data the string array to parsed.                    
                </param>
                <return>
                    the new start position if matching succeeded; a negative number
                      indicating matching failure, otherwise.                    
                </return>
            </javadoc>
            <method name="matchString" type="int" line="1182">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="field" type="int"/>
                    <param name="data" type="String[]"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <declaration name="i" type="int" line="1183"/>
                <declaration name="count" type="int" line="1184"/>
                <declaration name="bestMatchLength" type="int" line="1186"/>
                <scope line="1187">
                    <declaration name="length" type="int" line="1188"/>
                    <scope line="1189"/>
                </scope>
                <scope line="1194"/>
            </method>
            <javadoc line="1200">
                Performs the same thing as matchString(String, int, int,
                  String[]). This method takes a Map&lt;String, Integer&gt; instead of
                  String[].                
            </javadoc>
            <method name="matchString" type="int" line="1205">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="field" type="int"/>
                    <param name="data" type="Map&lt;String,Integer&gt;"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <scope line="1206">
                    <declaration name="bestMatch" type="String" line="1207"/>
                    <scope line="1208">
                        <declaration name="length" type="int" line="1209"/>
                        <scope line="1210">
                            <scope line="1211"/>
                        </scope>
                    </scope>
                    <scope line="1216"/>
                </scope>
            </method>
            <method name="matchZoneString" type="int" line="1223">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="zoneNames" type="String[]"/>
                </params>
                <scope line="1224">
                    <declaration name="zoneName" type="String" line="1225"/>
                    <scope line="1226"/>
                </scope>
            </method>
            <method name="matchDSTString" type="boolean" line="1232">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="zoneIndex" type="int"/>
                    <param name="standardIndex" type="int"/>
                    <param name="zoneStrings" type="String[][]"/>
                </params>
                <declaration name="index" type="int" line="1233"/>
                <declaration name="zoneName" type="String" line="1234"/>
                <scope line="1235"/>
            </method>
            <javadoc line="1240">
                find time zone &apos;text&apos; matched zoneStrings and set to internal
                  calendar.                
            </javadoc>
            <method name="subParseZoneString" type="int" line="1244">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <declaration name="useSameName" type="boolean" line="1245"/>
                <declaration name="currentTimeZone" type="TimeZone" line="1246"/>
                <declaration name="zoneIndex" type="int" line="1247"/>
                <declaration name="tz" type="TimeZone" line="1248"/>
                <declaration name="zoneStrings" type="String[][]" line="1249"/>
                <declaration name="zoneNames" type="String[]" line="1250"/>
                <declaration name="nameIndex" type="int" line="1251"/>
                <scope line="1252">
                    <scope line="1254">
                        <scope line="1255"/>
                    </scope>
                </scope>
                <scope line="1261">
                    <scope line="1263">
                        <scope line="1265">
                            <scope line="1266"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1273">
                    <declaration name="len" type="int" line="1274"/>
                    <scope line="1275">
                        <scope line="1277">
                            <scope line="1278"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1286">
                    <scope line="1287"/>
                    <declaration name="dstAmount" type="int" line="1290"/>
                    <scope line="1291"/>
                </scope>
            </method>
            <javadoc line="1298">
                Parses numeric forms of time zone offset, such as &quot;hh:mm&quot;, and
                  sets calb to the parsed value.                
                <param>
                    text  the text to be parsed                    
                </param>
                <param>
                    start the character position to start parsing                    
                </param>
                <param>
                    sign  1: positive; -1: negative                    
                </param>
                <param>
                    count 0: &apos;Z&apos; or &quot;GMT+hh:mm&quot; parsing; 1 - 3: the number of &apos;X&apos;s                    
                </param>
                <param>
                    colon true - colon required between hh and mm; false - no colon required                    
                </param>
                <param>
                    calb  a CalendarBuilder in which the parsed value is stored                    
                </param>
                <return>
                    updated parsed position, or its negative value to indicate a parsing error                    
                </return>
            </javadoc>
            <method name="subParseNumericZone" type="int" line="1309">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="sign" type="int"/>
                    <param name="count" type="int"/>
                    <param name="colon" type="boolean"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <declaration name="index" type="int" line="1310"/>
                <scope line="1311">
                    <declaration name="c" type="char" line="1312"/>
                    <declaration name="hours" type="int" line="1313"/>
                    <scope line="1314"/>
                    <scope line="1319"/>
                    <scope line="1322">
                        <scope line="1323"/>
                    </scope>
                    <scope line="1328"/>
                    <declaration name="minutes" type="int" line="1331"/>
                    <scope line="1332">
                        <scope line="1334">
                            <scope line="1335"/>
                        </scope>
                        <scope line="1340"/>
                        <scope line="1345"/>
                        <scope line="1349"/>
                    </scope>
                </scope>
                <scope line="1357"/>
            </method>
            <method name="isDigit" type="boolean" line="1361">
                <params>
                    <param name="c" type="char"/>
                </params>
            </method>
            <javadoc line="1364">
                Private member function that converts the parsed date strings into
                  timeFields. Returns -start (for ParsePosition) if failed.                
                <param>
                    text the time text to be parsed.                    
                </param>
                <param>
                    start where to start parsing.                    
                </param>
                <param>
                    ch the pattern character for the date field text to be parsed.                    
                </param>
                <param>
                    count the count of a pattern character.                    
                </param>
                <param>
                    obeyCount if true, then the next field directly abuts this one,
                      and we should use the count to know when to stop parsing.                    
                </param>
                <param>
                    ambiguousYear return parameter; upon return, if ambiguousYear[0]
                      is true, then a two-digit year was parsed and may need to be readjusted.                    
                </param>
                <param>
                    origPos origPos.errorIndex is used to return an error index
                      at which a parse error occurred, if matching failure occurs.                    
                </param>
                <return>
                    the new start position if matching succeeded; -1 indicating
                      matching failure, otherwise. In case matching failure occurred,
                      an error index is set to origPos.errorIndex.                    
                </return>
            </javadoc>
            <method name="subParse" type="int" line="1381">
                <params>
                    <param name="text" type="String"/>
                    <param name="start" type="int"/>
                    <param name="patternCharIndex" type="int"/>
                    <param name="count" type="int"/>
                    <param name="obeyCount" type="boolean"/>
                    <param name="ambiguousYear" type="boolean[]"/>
                    <param name="origPos" type="ParsePosition"/>
                    <param name="useFollowingMinusSignAsDelimiter" type="boolean"/>
                    <param name="calb" type="CalendarBuilder"/>
                </params>
                <declaration name="number" type="Number" line="1382"/>
                <declaration name="value" type="int" line="1383"/>
                <declaration name="pos" type="ParsePosition" line="1384"/>
                <scope line="1386"/>
                <declaration name="field" type="int" line="1389"/>
                <scope line="1390">
                    <scope line="1391"/>
                    <declaration name="c" type="char" line="1395"/>
                </scope>
                <scope line="1399">
                    <scope line="1400">
                        <scope line="1401">
                            <scope line="1402"/>
                        </scope>
                        <scope line="1407"/>
                        <scope line="1410">
                            <scope line="1411"/>
                        </scope>
                        <scope line="1415">
                            <scope line="1417"/>
                        </scope>
                    </scope>
                    <declaration name="useDateFormatSymbols" type="boolean" line="1423"/>
                    <declaration name="index" type="int" line="1424"/>
                    <scope line="1427">
                        <scope line="1428"/>
                    </scope>
                    <scope line="1432">
                        <declaration name="map" type="Map&amp;lt;String,Integer&amp;gt;" line="1433"/>
                        <scope line="1434"/>
                    </scope>
                    <scope line="1441">
                        <declaration name="style" type="int" line="1442"/>
                        <declaration name="map" type="Map&amp;lt;String,Integer&amp;gt;" line="1443"/>
                        <scope line="1444">
                            <scope line="1445"/>
                        </scope>
                    </scope>
                    <scope line="1452">
                        <declaration name="ambiguousTwoDigitYear" type="int" line="1453"/>
                    </scope>
                    <scope line="1460"/>
                    <scope line="1464">
                        <declaration name="newStart" type="int" line="1465"/>
                        <scope line="1466"/>
                        <scope line="1469"/>
                    </scope>
                    <scope line="1473">
                        <declaration name="map" type="Map&amp;lt;String,Integer&amp;gt;" line="1474"/>
                        <scope line="1475"/>
                    </scope>
                    <scope line="1481">
                        <scope line="1482"/>
                    </scope>
                    <scope line="1490">
                        <scope line="1491">
                            <declaration name="newStart" type="int" line="1492"/>
                            <scope line="1493"/>
                            <scope line="1496"/>
                        </scope>
                        <scope line="1500">
                            <declaration name="styles" type="int[]" line="1501"/>
                            <scope line="1502">
                                <declaration name="map" type="Map&amp;lt;String,Integer&amp;gt;" line="1503"/>
                                <scope line="1504"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1512">
                        <scope line="1513"/>
                    </scope>
                    <scope line="1517">
                        <declaration name="map" type="Map&amp;lt;String,Integer&amp;gt;" line="1518"/>
                        <scope line="1519"/>
                    </scope>
                    <scope line="1525">
                        <scope line="1526"/>
                    </scope>
                    <scope line="1535">
                        <declaration name="sign" type="int" line="1536"/>
                        <scope line="1537">
                            <declaration name="c" type="char" line="1538"/>
                            <scope line="1539"/>
                            <scope line="1542"/>
                            <scope line="1545">
                                <scope line="1546">
                                    <scope line="1548">
                                        <scope line="1550"/>
                                        <scope line="1553"/>
                                    </scope>
                                    <scope line="1557"/>
                                    <declaration name="i" type="int" line="1561"/>
                                    <scope line="1562"/>
                                </scope>
                                <scope line="1567">
                                    <declaration name="i" type="int" line="1568"/>
                                    <scope line="1569"/>
                                </scope>
                            </scope>
                            <scope line="1575">
                                <declaration name="i" type="int" line="1576"/>
                                <scope line="1577"/>
                            </scope>
                        </scope>
                        <scope line="1583"/>
                    </scope>
                    <scope line="1588">
                        <scope line="1589"/>
                        <declaration name="sign" type="int" line="1592"/>
                        <declaration name="c" type="char" line="1593"/>
                        <scope line="1594"/>
                        <scope line="1598"/>
                        <scope line="1601"/>
                        <scope line="1604"/>
                        <declaration name="i" type="int" line="1608"/>
                        <scope line="1609"/>
                    </scope>
                    <scope line="1616">
                        <scope line="1617"/>
                    </scope>
                    <scope line="1622"/>
                    <scope line="1625">
                        <scope line="1627"/>
                    </scope>
                </scope>
            </method>
            <method name="getCalendarName" type="String" line="1640"/>
            <method name="useDateFormatSymbols" type="boolean" line="1643">
                <scope line="1644"/>
            </method>
            <method name="isGregorianCalendar" type="boolean" line="1649"/>
            <javadoc line="1652">
                Translates a pattern, mapping each character in the from string to the
                  corresponding character in the to string.                
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="translatePattern" type="String" line="1657">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="from" type="String"/>
                    <param name="to" type="String"/>
                </params>
                <declaration name="result" type="StringBuilder" line="1658"/>
                <declaration name="inQuote" type="boolean" line="1659"/>
                <scope line="1660">
                    <declaration name="c" type="char" line="1661"/>
                    <scope line="1662"/>
                    <scope line="1665">
                        <scope line="1667">
                            <declaration name="ci" type="int" line="1668"/>
                            <scope line="1669">
                                <scope line="1670"/>
                            </scope>
                            <scope line="1674"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1684">
                Returns a pattern string describing this date format.                
                <return>
                    a pattern string describing this date format.                    
                </return>
            </javadoc>
            <method name="toPattern" type="String" line="1688"/>
            <javadoc line="1691">
                Returns a localized pattern string describing this date format.                
                <return>
                    a localized pattern string describing this date format.                    
                </return>
            </javadoc>
            <method name="toLocalizedPattern" type="String" line="1695"/>
            <javadoc line="1698">
                Applies the given pattern string to this date format.                
                <param>
                    pattern the new date and time pattern for this date format                    
                </param>
                <exception>
                    NullPointerException if the given pattern is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="applyPattern" type="void" line="1704">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1708">
                Applies the given localized pattern string to this date format.                
                <param>
                    pattern a String to be mapped to the new date and time format
                      pattern for this format                    
                </param>
                <exception>
                    NullPointerException if the given pattern is null                    
                </exception>
                <exception>
                    IllegalArgumentException if the given pattern is invalid                    
                </exception>
            </javadoc>
            <method name="applyLocalizedPattern" type="void" line="1715">
                <params>
                    <param name="pattern" type="String"/>
                </params>
                <declaration name="p" type="String" line="1716"/>
            </method>
            <javadoc line="1720">
                Gets a copy of the date and time format symbols of this date format.                
                <return>
                    the date and time format symbols of this date format                    
                </return>
                <see>
                    #setDateFormatSymbols                    
                </see>
            </javadoc>
            <method name="getDateFormatSymbols" type="DateFormatSymbols" line="1725"/>
            <javadoc line="1728">
                Sets the date and time format symbols of this date format.                
                <param>
                    newFormatSymbols the new date and time format symbols                    
                </param>
                <exception>
                    NullPointerException if the given newFormatSymbols is null                    
                </exception>
                <see>
                    #getDateFormatSymbols                    
                </see>
            </javadoc>
            <method name="setDateFormatSymbols" type="void" line="1734">
                <params>
                    <param name="newFormatSymbols" type="DateFormatSymbols"/>
                </params>
            </method>
            <javadoc line="1738">
                Creates a copy of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;. This also
                  clones the format&apos;s date format symbols.                
                <return>
                    a clone of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="1743">
                <declaration name="other" type="SimpleDateFormat" line="1744"/>
            </method>
            <javadoc line="1748">
                Returns the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object.                
                <return>
                    the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="1752"/>
            <javadoc line="1755">
                Compares the given object with this &lt;code&gt;SimpleDateFormat&lt;/code&gt; for
                  equality.                
                <return>
                    true if the given object is equal to this
                      &lt;code&gt;SimpleDateFormat&lt;/code&gt;                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1761">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <declaration name="that" type="SimpleDateFormat" line="1763"/>
            </method>
            <javadoc line="1766">
                After reading an object from the input stream, the format
                  pattern in the object is verified.
                  &lt;p&gt;                
                <exception>
                    InvalidObjectException if the pattern is invalid                    
                </exception>
            </javadoc>
            <method name="readObject" type="void" line="1772">
                <params>
                    <param name="stream" type="ObjectInputStream"/>
                </params>
                <scope line="1774"/>
                <scope line="1777"/>
                <scope line="1780"/>
                <scope line="1783"/>
                <declaration name="tz" type="TimeZone" line="1787"/>
                <scope line="1788">
                    <declaration name="id" type="String" line="1789"/>
                    <declaration name="zi" type="TimeZone" line="1790"/>
                    <scope line="1791"/>
                </scope>
            </method>
            <javadoc line="1796">
                Analyze the negative subpattern of DecimalFormat and set/update values
                  as necessary.                
            </javadoc>
            <method name="checkNegativeNumberExpression" type="void" line="1800">
                <scope line="1801">
                    <declaration name="numberPattern" type="String" line="1802"/>
                    <scope line="1803">
                        <declaration name="separatorIndex" type="int" line="1805"/>
                        <scope line="1806">
                            <declaration name="minusIndex" type="int" line="1807"/>
                            <scope line="1808"/>
                        </scope>
                    </scope>
                </scope>
            </method>
        </class>
    </source>