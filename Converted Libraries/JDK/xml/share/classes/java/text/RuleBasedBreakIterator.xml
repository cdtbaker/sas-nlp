<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.io.BufferedInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Stack"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.MissingResourceException"/>
        <import package="java.text.CharacterIterator"/>
        <import package="java.text.StringCharacterIterator"/>
        <import package="sun.text.CompactByteArray"/>
        <import package="sun.text.SupplementaryCharacterData"/>
        <class name="RuleBasedBreakIterator" line="58">
            <extends class="BreakIterator"/>
            <comment line="315">
                =======================================================================                
            </comment>
            <comment line="316">
                constructors                
            </comment>
            <comment line="317">
                =======================================================================                
            </comment>
            <comment line="505">
                =======================================================================                
            </comment>
            <comment line="506">
                boilerplate                
            </comment>
            <comment line="507">
                =======================================================================                
            </comment>
            <comment line="565">
                =======================================================================                
            </comment>
            <comment line="566">
                BreakIterator overrides                
            </comment>
            <comment line="567">
                =======================================================================                
            </comment>
            <comment line="895">
                =======================================================================                
            </comment>
            <comment line="896">
                implementation                
            </comment>
            <comment line="897">
                =======================================================================                
            </comment>
            <comment line="1048">
                This class exists to work around a bug in incorrect implementations
                 of CharacterIterator, which incorrectly handle setIndex(endIndex).
                 This iterator relies only on base.setIndex(n) where n is less than
                 endIndex.
                
                 One caveat:  if the base iterator&apos;s begin and end indices change
                 the change will not be reflected by this wrapper.  Does that matter?                
            </comment>
            <javadoc line="58">
                &lt;p&gt;A subclass of BreakIterator whose behavior is specified using a list of rules.&lt;/p&gt;
                  &lt;p&gt;There are two kinds of rules, which are separated by semicolons: &lt;i&gt;substitutions&lt;/i&gt;
                  and &lt;i&gt;regular expressions.&lt;/i&gt;&lt;/p&gt;
                  &lt;p&gt;A substitution rule defines a name that can be used in place of an expression. It
                  consists of a name, which is a string of characters contained in angle brackets, an equals
                  sign, and an expression. (There can be no whitespace on either side of the equals sign.)
                  To keep its syntactic meaning intact, the expression must be enclosed in parentheses or
                  square brackets. A substitution is visible after its definition, and is filled in using
                  simple textual substitution. Substitution definitions can contain other substitutions, as
                  long as those substitutions have been defined first. Substitutions are generally used to
                  make the regular expressions (which can get quite complex) shorted and easier to read.
                  They typically define either character categories or commonly-used subexpressions.&lt;/p&gt;
                  &lt;p&gt;There is one special substitution.&amp;nbsp; If the description defines a substitution
                  called &amp;quot;&amp;lt;ignore&amp;gt;&amp;quot;, the expression must be a [] expression, and the
                  expression defines a set of characters (the &amp;quot;&lt;em&gt;ignore characters&lt;/em&gt;&amp;quot;) that
                  will be transparent to the BreakIterator.&amp;nbsp; A sequence of characters will break the
                  same way it would if any ignore characters it contains are taken out.&amp;nbsp; Break
                  positions never occur befoer ignore characters.&lt;/p&gt;
                  &lt;p&gt;A regular expression uses a subset of the normal Unix regular-expression syntax, and
                  defines a sequence of characters to be kept together. With one significant exception, the
                  iterator uses a longest-possible-match algorithm when matching text to regular
                  expressions. The iterator also treats descriptions containing multiple regular expressions
                  as if they were ORed together (i.e., as if they were separated by |).&lt;/p&gt;
                  &lt;p&gt;The special characters recognized by the regular-expression parser are as follows:&lt;/p&gt;
                  &lt;blockquote&gt;
                  &lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies that the expression preceding the asterisk may occur any number
                  of times (including not at all).&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;{}&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Encloses a sequence of characters that is optional.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;()&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Encloses a sequence of characters.&amp;nbsp; If followed by , the sequence
                  repeats.&amp;nbsp; Otherwise, the parentheses are just a grouping device and a way to delimit
                  the ends of expressions containing |.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;|&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Separates two alternative sequences of characters.&amp;nbsp; Either one
                  sequence or the other, but not both, matches this expression.&amp;nbsp; The | character can
                  only occur inside ().&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;.&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Matches any character.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;?&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies a non-greedy asterisk.&amp;nbsp; ? works the same way as , except
                  when there is overlap between the last group of characters in the expression preceding the
                   and the first group of characters following the .&amp;nbsp; When there is this kind of
                  overlap,  will match the longest sequence of characters that match the expression before
                  the , and ? will match the shortest sequence of characters matching the expression
                  before the ?.&amp;nbsp; For example, if you have &amp;quot;xxyxyyyxyxyxxyxyxyy&amp;quot; in the text,
                  &amp;quot;x[xy]x&amp;quot; will match through to the last x (i.e., &amp;quot;&lt;strong&gt;xxyxyyyxyxyxxyxyx&lt;/strong&gt;yy&amp;quot;,
                  but &amp;quot;x[xy]?x&amp;quot; will only match the first two xes (&amp;quot;&lt;strong&gt;xx&lt;/strong&gt;yxyyyxyxyxxyxyxyy&amp;quot;).&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;[]&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies a group of alternative characters.&amp;nbsp; A [] expression will
                  match any single character that is specified in the [] expression.&amp;nbsp; For more on the
                  syntax of [] expressions, see below.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;/&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies where the break position should go if text matches this
                  expression.&amp;nbsp; (e.g., &amp;quot;[a-z]&amp;#42;/[:Zs:][1-0]&amp;quot; will match if the iterator sees a run
                  of letters, followed by a run of whitespace, followed by a digit, but the break position
                  will actually go before the whitespace).&amp;nbsp; Expressions that don&apos;t contain / put the
                  break position at the end of the matching text.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;\&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Escape character.&amp;nbsp; The \ itself is ignored, but causes the next
                  character to be treated as literal character.&amp;nbsp; This has no effect for many
                  characters, but for the characters listed above, this deprives them of their special
                  meaning.&amp;nbsp; (There are no special escape sequences for Unicode characters, or tabs and
                  newlines; these are all handled by a higher-level protocol.&amp;nbsp; In a Java string,
                  &amp;quot;\n&amp;quot; will be converted to a literal newline character by the time the
                  regular-expression parser sees it.&amp;nbsp; Of course, this means that \ sequences that are
                  visible to the regexp parser must be written as \\ when inside a Java string.)&amp;nbsp; All
                  characters in the ASCII range except for letters, digits, and control characters are
                  reserved characters to the parser and must be preceded by \ even if they currently don&apos;t
                  mean anything.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;!&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;If ! appears at the beginning of a regular expression, it tells the regexp
                  parser that this expression specifies the backwards-iteration behavior of the iterator,
                  and not its normal iteration behavior.&amp;nbsp; This is generally only used in situations
                  where the automatically-generated backwards-iteration brhavior doesn&apos;t produce
                  satisfactory results and must be supplemented with extra client-specified rules.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;&lt;em&gt;(all others)&lt;/em&gt;&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;All other characters are treated as literal characters, which must match
                  the corresponding character(s) in the text exactly.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;Within a [] expression, a number of other special characters can be used to specify
                  groups of characters:&lt;/p&gt;
                  &lt;blockquote&gt;
                  &lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;-&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies a range of matching characters.&amp;nbsp; For example
                  &amp;quot;[a-p]&amp;quot; matches all lowercase Latin letters from a to p (inclusive).&amp;nbsp; The -
                  sign specifies ranges of continuous Unicode numeric values, not ranges of characters in a
                  language&apos;s alphabetical order: &amp;quot;[a-z]&amp;quot; doesn&apos;t include capital letters, nor does
                  it include accented letters such as a-umlaut.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;::&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;A pair of colons containing a one- or two-letter code matches all
                  characters in the corresponding Unicode category.&amp;nbsp; The two-letter codes are the same
                  as the two-letter codes in the Unicode database (for example, &amp;quot;[:Sc::Sm:]&amp;quot;
                  matches all currency symbols and all math symbols).&amp;nbsp; Specifying a one-letter code is
                  the same as specifying all two-letter codes that begin with that letter (for example,
                  &amp;quot;[:L:]&amp;quot; matches all letters, and is equivalent to
                  &amp;quot;[:Lu::Ll::Lo::Lm::Lt:]&amp;quot;).&amp;nbsp; Anything other than a valid two-letter Unicode
                  category code or a single letter that begins a Unicode category code is illegal within
                  colons.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;[]&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;[] expressions can nest.&amp;nbsp; This has no effect, except when used in
                  conjunction with the ^ token.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;^&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Excludes the character (or the characters in the [] expression) following
                  it from the group of characters.&amp;nbsp; For example, &amp;quot;[a-z^p]&amp;quot; matches all Latin
                  lowercase letters except p.&amp;nbsp; &amp;quot;[:L:^[&amp;#92;u4e00-&amp;#92;u9fff]]&amp;quot; matches all letters
                  except the Han ideographs.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;&lt;em&gt;(all others)&lt;/em&gt;&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;All other characters are treated as literal characters.&amp;nbsp; (For
                  example, &amp;quot;[aeiou]&amp;quot; specifies just the letters a, e, i, o, and u.)&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;For a more complete explanation, see &lt;a
                  href=&quot;http://www.ibm.com/java/education/boundaries/boundaries.html&quot;&gt;http://www.ibm.com/java/education/boundaries/boundaries.html&lt;/a&gt;.
                  &amp;nbsp; For examples, see the resource data (which is annotated).&lt;/p&gt;                
                <author>
                    Richard Gillam                    
                </author>
            </javadoc>
            <declaration name="IGNORE" type="byte" line="224"/>
            <javadoc line="224">
                A token used as a character-category value to identify ignore characters                
            </javadoc>
            <declaration name="START_STATE" type="short" line="229"/>
            <javadoc line="229">
                The state number of the starting state                
            </javadoc>
            <declaration name="STOP_STATE" type="short" line="234"/>
            <javadoc line="234">
                The state-transition value indicating &quot;stop&quot;                
            </javadoc>
            <declaration name="LABEL" type="byte[]" line="239"/>
            <javadoc line="239">
                Magic number for the BreakIterator data file format.                
            </javadoc>
            <declaration name="LABEL_LENGTH" type="int" line="246"/>
            <declaration name="supportedVersion" type="byte" line="248"/>
            <javadoc line="248">
                Version number of the dictionary that was read in.                
            </javadoc>
            <declaration name="HEADER_LENGTH" type="int" line="253"/>
            <javadoc line="253">
                Header size in byte count                
            </javadoc>
            <declaration name="BMP_INDICES_LENGTH" type="int" line="258"/>
            <javadoc line="258">
                An array length of indices for BMP characters                
            </javadoc>
            <declaration name="charCategoryTable" type="CompactByteArray" line="263"/>
            <javadoc line="263">
                Tables that indexes from character values to character category numbers                
            </javadoc>
            <declaration name="supplementaryCharCategoryTable" type="SupplementaryCharacterData" line="267"/>
            <declaration name="stateTable" type="short[]" line="269"/>
            <javadoc line="269">
                The table of state transitions used for forward iteration                
            </javadoc>
            <declaration name="backwardsStateTable" type="short[]" line="274"/>
            <javadoc line="274">
                The table of state transitions used to sync up the iterator with the
                  text in backwards and random-access iteration                
            </javadoc>
            <declaration name="endStates" type="boolean[]" line="280"/>
            <javadoc line="280">
                A list of flags indicating which states in the state table are accepting
                  (&quot;end&quot;) states                
            </javadoc>
            <declaration name="lookaheadStates" type="boolean[]" line="286"/>
            <javadoc line="286">
                A list of flags indicating which states in the state table are
                  lookahead states (states which turn lookahead on and off)                
            </javadoc>
            <declaration name="additionalData" type="byte[]" line="292"/>
            <javadoc line="292">
                A table for additional data. May be used by a subclass of
                  RuleBasedBreakIterator.                
            </javadoc>
            <declaration name="numCategories" type="int" line="298"/>
            <javadoc line="298">
                The number of character categories (and, thus, the number of columns in
                  the state tables)                
            </javadoc>
            <declaration name="text" type="CharacterIterator" line="304"/>
            <javadoc line="304">
                The character iterator through which this BreakIterator accesses the text                
            </javadoc>
            <declaration name="checksum" type="long" line="309"/>
            <javadoc line="309">
                A CRC32 value of all data in datafile                
            </javadoc>
            <javadoc line="318">
                Constructs a RuleBasedBreakIterator according to the datafile
                  provided.                
            </javadoc>
            <method name="RuleBasedBreakIterator" type="constructor" line="323">
                <params>
                    <param name="datafile" type="String"/>
                </params>
            </method>
            <javadoc line="327">
                Read datafile. The datafile&apos;s format is as follows:
                  &lt;pre&gt;
                  BreakIteratorData {
                  u1           magic[7];
                  u1           version;
                  u4           totalDataSize;
                  header_info  header;
                  body         value;
                  }
                  &lt;/pre&gt;
                  &lt;code&gt;totalDataSize&lt;/code&gt; is the summation of the size of
                  &lt;code&gt;header_info&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; in byte count.
                  &lt;p&gt;
                  In &lt;code&gt;header&lt;/code&gt;, each field except for checksum implies the
                  length of each field. Since &lt;code&gt;BMPdataLength&lt;/code&gt; is a fixed-length
                  data(512 entries), its length isn&apos;t included in &lt;code&gt;header&lt;/code&gt;.
                  &lt;code&gt;checksum&lt;/code&gt; is a CRC32 value of all in &lt;code&gt;body&lt;/code&gt;.
                  &lt;pre&gt;
                  header_info {
                  u4           stateTableLength;
                  u4           backwardsStateTableLength;
                  u4           endStatesLength;
                  u4           lookaheadStatesLength;
                  u4           BMPdataLength;
                  u4           nonBMPdataLength;
                  u4           additionalDataLength;
                  u8           checksum;
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;
                  Finally, &lt;code&gt;BMPindices&lt;/code&gt; and &lt;code&gt;BMPdata&lt;/code&gt; are set to
                  &lt;code&gt;charCategoryTable&lt;/code&gt;. &lt;code&gt;nonBMPdata&lt;/code&gt; is set to
                  &lt;code&gt;supplementaryCharCategoryTable&lt;/code&gt;.
                  &lt;pre&gt;
                  body {
                  u2           stateTable[stateTableLength];
                  u2           backwardsStateTable[backwardsStateTableLength];
                  u1           endStates[endStatesLength];
                  u1           lookaheadStates[lookaheadStatesLength];
                  u2           BMPindices[512];
                  u1           BMPdata[BMPdataLength];
                  u4           nonBMPdata[numNonBMPdataLength];
                  u1           additionalData[additionalDataLength];
                  }
                  &lt;/pre&gt;                
            </javadoc>
            <method name="readTables" type="void" line="376">
                <params>
                    <param name="datafile" type="String"/>
                </params>
                <comment line="380">
                                        
                </comment>
                <comment line="390">
                                        
                </comment>
                <comment line="397">
                                        
                </comment>
                <comment line="403">
                                        
                </comment>
                <comment line="409">
                                        
                </comment>
                <comment line="415">
                                        
                </comment>
                <comment line="416">
                    BMPindices                    
                </comment>
                <comment line="420">
                    BMPdata                    
                </comment>
                <comment line="425">
                                        
                </comment>
                <comment line="432">
                                        
                </comment>
                <comment line="438">
                                        
                </comment>
                <declaration name="buffer" type="byte[]" line="378"/>
                <declaration name="stateTableLength" type="int" line="381"/>
                <declaration name="backwardsStateTableLength" type="int" line="382"/>
                <declaration name="endStatesLength" type="int" line="383"/>
                <declaration name="lookaheadStatesLength" type="int" line="384"/>
                <declaration name="BMPdataLength" type="int" line="385"/>
                <declaration name="nonBMPdataLength" type="int" line="386"/>
                <declaration name="additionalDataLength" type="int" line="387"/>
                <declaration name="offset" type="int" line="392"/>
                <scope line="393"/>
                <scope line="399"/>
                <scope line="405"/>
                <scope line="411"/>
                <declaration name="temp1" type="short[]" line="416"/>
                <scope line="417"/>
                <declaration name="temp2" type="byte[]" line="420"/>
                <declaration name="temp3" type="int[]" line="426"/>
                <scope line="427"/>
                <scope line="433"/>
            </method>
            <method name="readFile" type="byte[]" line="443">
                <params>
                    <param name="datafile" type="String"/>
                </params>
                <comment line="461">
                                        
                </comment>
                <comment line="469">
                                        
                </comment>
                <comment line="477">
                                        
                </comment>
                <comment line="483">
                                        
                </comment>
                <declaration name="is" type="BufferedInputStream" line="445"/>
                <scope line="446">
                    <anonymous_class line="448">
                        <method name="run" type="Object" line="449"/>
                    </anonymous_class>
                </scope>
                <scope line="455"/>
                <declaration name="offset" type="int" line="459"/>
                <declaration name="len" type="int" line="462"/>
                <declaration name="buf" type="byte[]" line="463"/>
                <scope line="464"/>
                <scope line="470">
                    <scope line="471"/>
                </scope>
                <scope line="478"/>
                <scope line="486"/>
            </method>
            <method name="getAdditionalData" type="byte[]" line="496"/>
            <method name="setAdditionalData" type="void" line="500">
                <params>
                    <param name="b" type="byte[]"/>
                </params>
            </method>
            <javadoc line="507">
                Clones this iterator.                
                <return>
                    A newly-constructed RuleBasedBreakIterator with the same
                      behavior as this one.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="512">
                <declaration name="result" type="RuleBasedBreakIterator" line="513"/>
                <scope line="514"/>
            </method>
            <javadoc line="520">
                Returns true if both BreakIterators are of the same class, have the same
                  rules, and iterate over the same text.                
            </javadoc>
            <method name="equals" type="boolean" line="524">
                <params>
                    <param name="that" type="Object"/>
                </params>
                <scope line="525">
                    <scope line="526"/>
                    <declaration name="other" type="RuleBasedBreakIterator" line="530"/>
                    <scope line="531"/>
                    <scope line="534"/>
                    <scope line="536"/>
                </scope>
                <scope line="540"/>
            </method>
            <javadoc line="545">
                Returns text                
            </javadoc>
            <method name="toString" type="String" line="548">
                <declaration name="sb" type="StringBuffer" line="549"/>
            </method>
            <javadoc line="556">
                Compute a hashcode for this BreakIterator                
                <return>
                    A hash code                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="560"/>
            <javadoc line="568">
                Sets the current iteration position to the beginning of the text.
                  (i.e., the CharacterIterator&apos;s starting offset).                
                <return>
                    The offset of the beginning of the text.                    
                </return>
            </javadoc>
            <method name="first" type="int" line="573">
                <declaration name="t" type="CharacterIterator" line="574"/>
            </method>
            <javadoc line="580">
                Sets the current iteration position to the end of the text.
                  (i.e., the CharacterIterator&apos;s ending offset).                
                <return>
                    The text's past-the-end offset.                    
                </return>
            </javadoc>
            <method name="last" type="int" line="585">
                <comment line="588">
                    I&apos;m not sure why, but t.last() returns the offset of the last character,                    
                </comment>
                <comment line="589">
                    rather than the past-the-end offset                    
                </comment>
                <declaration name="t" type="CharacterIterator" line="586"/>
            </method>
            <javadoc line="594">
                Advances the iterator either forward or backward the specified number of steps.
                  Negative values move backward, and positive values move forward.  This is
                  equivalent to repeatedly calling next() or previous().                
                <param>
                    n The number of steps to move.  The sign indicates the direction
                      (negative is backwards, and positive is forwards).                    
                </param>
                <return>
                    The character offset of the boundary position n boundaries away from
                      the current one.                    
                </return>
            </javadoc>
            <method name="next" type="int" line="603">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="result" type="int" line="604"/>
                <scope line="605"/>
                <scope line="609"/>
            </method>
            <javadoc line="616">
                Advances the iterator to the next boundary position.                
                <return>
                    The position of the first boundary after this one.                    
                </return>
            </javadoc>
            <method name="next" type="int" line="620"/>
            <declaration name="cachedLastKnownBreak" type="int" line="624"/>
            <javadoc line="626">
                Advances the iterator backwards, to the last boundary preceding this one.                
                <return>
                    The position of the last boundary position preceding this one.                    
                </return>
            </javadoc>
            <method name="previous" type="int" line="630">
                <comment line="631">
                    if we&apos;re already sitting at the beginning of the text, return DONE                    
                </comment>
                <comment line="637">
                    set things up.  handlePrevious() will back us up to some valid                    
                </comment>
                <comment line="638">
                    break position before the current position (we back our internal                    
                </comment>
                <comment line="639">
                    iterator up one step to prevent handlePrevious() from returning                    
                </comment>
                <comment line="640">
                    the current position), but not necessarily the last one before                    
                </comment>
                <comment line="641">
                    where we started                    
                </comment>
                <comment line="648">
                    it might be better to check if handlePrevious() give us closer                    
                </comment>
                <comment line="649">
                    safe value but handlePrevious() is slow too                    
                </comment>
                <comment line="650">
                    So, this has to be done carefully                    
                </comment>
                <comment line="655">
                    iterate forward from the known break position until we pass our                    
                </comment>
                <comment line="656">
                    starting point.  The last break position before the starting                    
                </comment>
                <comment line="657">
                    point is our return value                    
                </comment>
                <comment line="663">
                    set the current iteration position to be the last break position                    
                </comment>
                <comment line="664">
                    before where we started, and then return that value                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="632"/>
                <scope line="633"/>
                <declaration name="start" type="int" line="642"/>
                <declaration name="lastResult" type="int" line="643"/>
                <scope line="644"/>
                <scope line="647"/>
                <declaration name="result" type="int" line="653"/>
                <scope line="658"/>
            </method>
            <javadoc line="670">
                Returns previous character                
            </javadoc>
            <method name="getPrevious" type="int" line="673">
                <declaration name="c2" type="char" line="674"/>
                <scope line="676">
                    <declaration name="c1" type="char" line="677"/>
                    <scope line="678"/>
                    <scope line="680"/>
                </scope>
            </method>
            <javadoc line="687">
                Returns current character                
            </javadoc>
            <method name="getCurrent" type="int" line="690">
                <declaration name="c1" type="char" line="691"/>
                <scope line="693">
                    <declaration name="c2" type="char" line="694"/>
                    <scope line="696"/>
                </scope>
            </method>
            <javadoc line="703">
                Returns the count of next character.                
            </javadoc>
            <method name="getCurrentCodePointCount" type="int" line="706">
                <declaration name="c1" type="char" line="707"/>
                <scope line="709">
                    <declaration name="c2" type="char" line="710"/>
                    <scope line="712"/>
                </scope>
            </method>
            <javadoc line="719">
                Returns next character                
            </javadoc>
            <method name="getNext" type="int" line="722">
                <declaration name="index" type="int" line="723"/>
                <declaration name="endIndex" type="int" line="724"/>
                <scope line="726"/>
            </method>
            <javadoc line="733">
                Returns the position of next character.                
            </javadoc>
            <method name="getNextIndex" type="int" line="736">
                <declaration name="index" type="int" line="737"/>
                <declaration name="endIndex" type="int" line="738"/>
                <scope line="739"/>
                <scope line="741"/>
            </method>
            <javadoc line="746">
                Throw IllegalArgumentException unless begin &lt;= offset &lt; end.                
            </javadoc>
            <method name="checkOffset" type="void" line="749">
                <params>
                    <param name="offset" type="int"/>
                    <param name="text" type="CharacterIterator"/>
                </params>
                <scope line="750"/>
            </method>
            <javadoc line="755">
                Sets the iterator to refer to the first boundary position following
                  the specified position.                
                <offset>
                    The position from which to begin searching for a break position.                    
                </offset>
                <return>
                    The position of the first break after the current position.                    
                </return>
            </javadoc>
            <method name="following" type="int" line="761">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <comment line="766">
                    Set our internal iteration position (temporarily)                    
                </comment>
                <comment line="767">
                    to the position passed in.  If this is the _beginning_ position,                    
                </comment>
                <comment line="768">
                    then we can just use next() to get our return value                    
                </comment>
                <comment line="775">
                    otherwise, we have to sync up first.  Use handlePrevious() to back                    
                </comment>
                <comment line="776">
                    us up to a known break position before the specified position (if                    
                </comment>
                <comment line="777">
                    we can determine that the specified position is a break position,                    
                </comment>
                <comment line="778">
                    we don&apos;t back up at all).  This may or may not be the last break                    
                </comment>
                <comment line="779">
                    position at or before our starting position.  Advance forward                    
                </comment>
                <comment line="780">
                    from here until we&apos;ve passed the starting position.  The position                    
                </comment>
                <comment line="781">
                    we stop on will be the first break position after the specified one.                    
                </comment>
                <comment line="786">
                    it might be better to check if handlePrevious() give us closer                    
                </comment>
                <comment line="787">
                    safe value but handlePrevious() is slow too                    
                </comment>
                <comment line="788">
                    So, this has to be done carefully                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="763"/>
                <scope line="770"/>
                <declaration name="result" type="int" line="782"/>
                <scope line="783"/>
                <scope line="785"/>
                <scope line="791"/>
            </method>
            <javadoc line="798">
                Sets the iterator to refer to the last boundary position before the
                  specified position.                
                <offset>
                    The position to begin searching for a break from.                    
                </offset>
                <return>
                    The position of the last boundary before the starting position.                    
                </return>
            </javadoc>
            <method name="preceding" type="int" line="804">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <comment line="805">
                    if we start by updating the current iteration position to the                    
                </comment>
                <comment line="806">
                    position specified by the caller, we can just use previous()                    
                </comment>
                <comment line="807">
                    to carry out this operation                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="808"/>
            </method>
            <javadoc line="814">
                Returns true if the specfied position is a boundary position.  As a side
                  effect, leaves the iterator pointing to the first boundary position at
                  or after &quot;offset&quot;.                
                <param>
                    offset the offset to check.                    
                </param>
                <return>
                    True if "offset" is a boundary position.                    
                </return>
            </javadoc>
            <method name="isBoundary" type="boolean" line="821">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <comment line="828">
                    to check whether this is a boundary, we can use following() on the                    
                </comment>
                <comment line="829">
                    position before the specified one and return true if the position we                    
                </comment>
                <comment line="830">
                    get back is the one the user specified                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="822"/>
                <scope line="824"/>
                <scope line="831"/>
            </method>
            <javadoc line="836">
                Returns the current iteration position.                
                <return>
                    The current iteration position.                    
                </return>
            </javadoc>
            <method name="current" type="int" line="840"/>
            <javadoc line="844">
                Return a CharacterIterator over the text being analyzed.  This version
                  of this method returns the actual CharacterIterator we&apos;re using internally.
                  Changing the state of this iterator can have undefined consequences.  If
                  you need to change it, clone it first.                
                <return>
                    An iterator over the text being analyzed.                    
                </return>
            </javadoc>
            <method name="getText" type="CharacterIterator" line="851">
                <comment line="852">
                    The iterator is initialized pointing to no text at all, so if this                    
                </comment>
                <comment line="853">
                    function is called while we&apos;re in that state, we have to fudge an                    
                </comment>
                <comment line="854">
                    iterator to return.                    
                </comment>
                <scope line="855"/>
            </method>
            <javadoc line="861">
                Set the iterator to analyze a new piece of text.  This function resets
                  the current iteration position to the beginning of the text.                
                <param>
                    newText An iterator over the text to analyze.                    
                </param>
            </javadoc>
            <method name="setText" type="void" line="866">
                <params>
                    <param name="newText" type="CharacterIterator"/>
                </params>
                <comment line="867">
                    Test iterator to see if we need to wrap it in a SafeCharIterator.                    
                </comment>
                <comment line="868">
                    The correct behavior for CharacterIterators is to allow the                    
                </comment>
                <comment line="869">
                    position to be set to the endpoint of the iterator.  Many                    
                </comment>
                <comment line="870">
                    CharacterIterators do not uphold this, so this is a workaround                    
                </comment>
                <comment line="871">
                    to permit them to use this class.                    
                </comment>
                <comment line="875">
                    some buggy iterators throw an exception here                    
                </comment>
                <declaration name="end" type="int" line="872"/>
                <declaration name="goodIterator" type="boolean" line="873"/>
                <scope line="874"/>
                <scope line="878"/>
                <scope line="882"/>
                <scope line="885"/>
            </method>
            <javadoc line="898">
                This method is the actual implementation of the next() method.  All iteration
                  vectors through here.  This method initializes the state machine to state 1
                  and advances through the text character by character until we reach the end
                  of the text or the state machine transitions to state 0.  We update our return
                  value every time the state machine passes through a possible end state.                
            </javadoc>
            <method name="handleNext" type="int" line="905">
                <comment line="906">
                    if we&apos;re already at the end of the text, return DONE.                    
                </comment>
                <comment line="912">
                    no matter what, we always advance at least one character forward                    
                </comment>
                <comment line="916">
                    begin in state 1                    
                </comment>
                <comment line="921">
                    loop until we reach the end of the text or transition to state 0                    
                </comment>
                <comment line="924">
                    look up the current character&apos;s character category (which tells us                    
                </comment>
                <comment line="925">
                    which column in the state table to look at)                    
                </comment>
                <comment line="928">
                    if the character isn&apos;t an ignore character, look up a state                    
                </comment>
                <comment line="929">
                    transition in the state table                    
                </comment>
                <comment line="934">
                    if the state we&apos;ve just transitioned to is a lookahead state,                    
                </comment>
                <comment line="935">
                    (but not also an end state), save its position.  If it&apos;s                    
                </comment>
                <comment line="936">
                    both a lookahead state and an end state, update the break position                    
                </comment>
                <comment line="937">
                    to the last saved lookup-state position                    
                </comment>
                <comment line="947">
                    otherwise, if the state we&apos;ve just transitioned to is an accepting                    
                </comment>
                <comment line="948">
                    state, update the break position to be the current iteration position                    
                </comment>
                <comment line="958">
                    if we&apos;ve run off the end of the text, and the very last character took us into                    
                </comment>
                <comment line="959">
                    a lookahead state, advance the break position to the lookahead position                    
                </comment>
                <comment line="960">
                    (the theory here is that if there are no characters at all after the lookahead                    
                </comment>
                <comment line="961">
                    position, that always matches the lookahead criteria)                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="907"/>
                <scope line="908"/>
                <declaration name="result" type="int" line="913"/>
                <declaration name="lookaheadResult" type="int" line="914"/>
                <declaration name="state" type="int" line="917"/>
                <declaration name="category" type="int" line="918"/>
                <declaration name="c" type="int" line="919"/>
                <scope line="922">
                    <scope line="930"/>
                    <scope line="938">
                        <scope line="939"/>
                        <scope line="942"/>
                    </scope>
                    <scope line="949">
                        <scope line="950"/>
                    </scope>
                </scope>
                <scope line="962"/>
            </method>
            <javadoc line="970">
                This method backs the iterator back up to a &quot;safe position&quot; in the text.
                  This is a position that we know, without any context, must be a break position.
                  The various calling methods then iterate forward from this safe position to
                  the appropriate position to return.  (For more information, see the description
                  of buildBackwardsStateTable() in RuleBasedBreakIterator.Builder.)                
            </javadoc>
            <method name="handlePrevious" type="int" line="977">
                <comment line="984">
                    loop until we reach the beginning of the text or transition to state 0                    
                </comment>
                <comment line="987">
                    save the last character&apos;s category and look up the current                    
                </comment>
                <comment line="988">
                    character&apos;s category                    
                </comment>
                <comment line="992">
                    if the current character isn&apos;t an ignore character, look up a                    
                </comment>
                <comment line="993">
                    state transition in the backwards state table                    
                </comment>
                <comment line="998">
                    then advance one character backwards                    
                </comment>
                <comment line="1002">
                    if we didn&apos;t march off the beginning of the text, we&apos;re either one or two                    
                </comment>
                <comment line="1003">
                    positions away from the real break position.  (One because of the call to                    
                </comment>
                <comment line="1004">
                    previous() at the end of the loop above, and another because the character                    
                </comment>
                <comment line="1005">
                    that takes us into the stop state will always be the character BEFORE                    
                </comment>
                <comment line="1006">
                    the break position.)                    
                </comment>
                <declaration name="text" type="CharacterIterator" line="978"/>
                <declaration name="state" type="int" line="979"/>
                <declaration name="category" type="int" line="980"/>
                <declaration name="lastCategory" type="int" line="981"/>
                <declaration name="c" type="int" line="982"/>
                <scope line="985">
                    <scope line="994"/>
                </scope>
                <scope line="1007">
                    <scope line="1008"/>
                    <scope line="1012"/>
                </scope>
            </method>
            <javadoc line="1019">
                Looks up a character&apos;s category (i.e., its category for breaking purposes,
                  not its Unicode category)                
            </javadoc>
            <method name="lookupCategory" type="int" line="1023">
                <params>
                    <param name="c" type="int"/>
                </params>
                <scope line="1024"/>
                <scope line="1026"/>
            </method>
            <javadoc line="1031">
                Given a current state and a character category, looks up the
                  next state to transition to in the state table.                
            </javadoc>
            <method name="lookupState" type="int" line="1035">
                <params>
                    <param name="state" type="int"/>
                    <param name="category" type="int"/>
                </params>
            </method>
            <javadoc line="1039">
                Given a current state and a character category, looks up the
                  next state to transition to in the backwards state table.                
            </javadoc>
            <method name="lookupBackwardState" type="int" line="1043">
                <params>
                    <param name="state" type="int"/>
                    <param name="category" type="int"/>
                </params>
            </method>
            <class name="SafeCharIterator" line="1056">
                <implements interface="CharacterIterator"/>
                <implements interface="Cloneable"/>
                <declaration name="base" type="CharacterIterator" line="1059"/>
                <declaration name="rangeStart" type="int" line="1060"/>
                <declaration name="rangeLimit" type="int" line="1061"/>
                <declaration name="currentIndex" type="int" line="1062"/>
                <method name="SafeCharIterator" type="constructor" line="1064">
                    <params>
                        <param name="base" type="CharacterIterator"/>
                    </params>
                </method>
                <method name="first" type="char" line="1071"/>
                <method name="last" type="char" line="1075"/>
                <method name="current" type="char" line="1079">
                    <scope line="1080"/>
                    <scope line="1083"/>
                </method>
                <method name="next" type="char" line="1088">
                    <scope line="1091"/>
                    <scope line="1095"/>
                </method>
                <method name="previous" type="char" line="1100">
                    <scope line="1103"/>
                    <scope line="1107"/>
                </method>
                <method name="setIndex" type="char" line="1112">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                    <scope line="1114"/>
                </method>
                <method name="getBeginIndex" type="int" line="1121"/>
                <method name="getEndIndex" type="int" line="1125"/>
                <method name="getIndex" type="int" line="1129"/>
                <method name="clone" type="Object" line="1133">
                    <declaration name="copy" type="SafeCharIterator" line="1135"/>
                    <scope line="1136"/>
                    <scope line="1139"/>
                    <declaration name="copyOfBase" type="CharacterIterator" line="1143"/>
                </method>
            </class>
        </class>
    </source>