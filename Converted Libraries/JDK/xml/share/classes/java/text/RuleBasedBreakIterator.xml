<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.io.BufferedInputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.util.Vector"/>
        <import package="java.util.Stack"/>
        <import package="java.util.Hashtable"/>
        <import package="java.util.Enumeration"/>
        <import package="java.util.MissingResourceException"/>
        <import package="java.text.CharacterIterator"/>
        <import package="java.text.StringCharacterIterator"/>
        <import package="sun.text.CompactByteArray"/>
        <import package="sun.text.SupplementaryCharacterData"/>
        <class name="RuleBasedBreakIterator" line="16">
            <extends class="BreakIterator"/>
            <javadoc line="16">
                &lt;p&gt;A subclass of BreakIterator whose behavior is specified using a list of rules.&lt;/p&gt;
                  &lt;p&gt;There are two kinds of rules, which are separated by semicolons: &lt;i&gt;substitutions&lt;/i&gt;
                  and &lt;i&gt;regular expressions.&lt;/i&gt;&lt;/p&gt;
                  &lt;p&gt;A substitution rule defines a name that can be used in place of an expression. It
                  consists of a name, which is a string of characters contained in angle brackets, an equals
                  sign, and an expression. (There can be no whitespace on either side of the equals sign.)
                  To keep its syntactic meaning intact, the expression must be enclosed in parentheses or
                  square brackets. A substitution is visible after its definition, and is filled in using
                  simple textual substitution. Substitution definitions can contain other substitutions, as
                  long as those substitutions have been defined first. Substitutions are generally used to
                  make the regular expressions (which can get quite complex) shorted and easier to read.
                  They typically define either character categories or commonly-used subexpressions.&lt;/p&gt;
                  &lt;p&gt;There is one special substitution.&amp;nbsp; If the description defines a substitution
                  called &amp;quot;&amp;lt;ignore&amp;gt;&amp;quot;, the expression must be a [] expression, and the
                  expression defines a set of characters (the &amp;quot;&lt;em&gt;ignore characters&lt;/em&gt;&amp;quot;) that
                  will be transparent to the BreakIterator.&amp;nbsp; A sequence of characters will break the
                  same way it would if any ignore characters it contains are taken out.&amp;nbsp; Break
                  positions never occur befoer ignore characters.&lt;/p&gt;
                  &lt;p&gt;A regular expression uses a subset of the normal Unix regular-expression syntax, and
                  defines a sequence of characters to be kept together. With one significant exception, the
                  iterator uses a longest-possible-match algorithm when matching text to regular
                  expressions. The iterator also treats descriptions containing multiple regular expressions
                  as if they were ORed together (i.e., as if they were separated by |).&lt;/p&gt;
                  &lt;p&gt;The special characters recognized by the regular-expression parser are as follows:&lt;/p&gt;
                  &lt;blockquote&gt;
                  &lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies that the expression preceding the asterisk may occur any number
                  of times (including not at all).&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;{}&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Encloses a sequence of characters that is optional.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;()&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Encloses a sequence of characters.&amp;nbsp; If followed by , the sequence
                  repeats.&amp;nbsp; Otherwise, the parentheses are just a grouping device and a way to delimit
                  the ends of expressions containing |.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;|&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Separates two alternative sequences of characters.&amp;nbsp; Either one
                  sequence or the other, but not both, matches this expression.&amp;nbsp; The | character can
                  only occur inside ().&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;.&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Matches any character.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;?&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies a non-greedy asterisk.&amp;nbsp; ? works the same way as , except
                  when there is overlap between the last group of characters in the expression preceding the
                   and the first group of characters following the .&amp;nbsp; When there is this kind of
                  overlap,  will match the longest sequence of characters that match the expression before
                  the , and ? will match the shortest sequence of characters matching the expression
                  before the ?.&amp;nbsp; For example, if you have &amp;quot;xxyxyyyxyxyxxyxyxyy&amp;quot; in the text,
                  &amp;quot;x[xy]x&amp;quot; will match through to the last x (i.e., &amp;quot;&lt;strong&gt;xxyxyyyxyxyxxyxyx&lt;/strong&gt;yy&amp;quot;,
                  but &amp;quot;x[xy]?x&amp;quot; will only match the first two xes (&amp;quot;&lt;strong&gt;xx&lt;/strong&gt;yxyyyxyxyxxyxyxyy&amp;quot;).&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;[]&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies a group of alternative characters.&amp;nbsp; A [] expression will
                  match any single character that is specified in the [] expression.&amp;nbsp; For more on the
                  syntax of [] expressions, see below.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;/&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies where the break position should go if text matches this
                  expression.&amp;nbsp; (e.g., &amp;quot;[a-z]&amp;#42;/[:Zs:][1-0]&amp;quot; will match if the iterator sees a run
                  of letters, followed by a run of whitespace, followed by a digit, but the break position
                  will actually go before the whitespace).&amp;nbsp; Expressions that don&apos;t contain / put the
                  break position at the end of the matching text.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;\&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Escape character.&amp;nbsp; The \ itself is ignored, but causes the next
                  character to be treated as literal character.&amp;nbsp; This has no effect for many
                  characters, but for the characters listed above, this deprives them of their special
                  meaning.&amp;nbsp; (There are no special escape sequences for Unicode characters, or tabs and
                  newlines; these are all handled by a higher-level protocol.&amp;nbsp; In a Java string,
                  &amp;quot;\n&amp;quot; will be converted to a literal newline character by the time the
                  regular-expression parser sees it.&amp;nbsp; Of course, this means that \ sequences that are
                  visible to the regexp parser must be written as \\ when inside a Java string.)&amp;nbsp; All
                  characters in the ASCII range except for letters, digits, and control characters are
                  reserved characters to the parser and must be preceded by \ even if they currently don&apos;t
                  mean anything.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;!&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;If ! appears at the beginning of a regular expression, it tells the regexp
                  parser that this expression specifies the backwards-iteration behavior of the iterator,
                  and not its normal iteration behavior.&amp;nbsp; This is generally only used in situations
                  where the automatically-generated backwards-iteration brhavior doesn&apos;t produce
                  satisfactory results and must be supplemented with extra client-specified rules.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;&lt;em&gt;(all others)&lt;/em&gt;&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;All other characters are treated as literal characters, which must match
                  the corresponding character(s) in the text exactly.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;Within a [] expression, a number of other special characters can be used to specify
                  groups of characters:&lt;/p&gt;
                  &lt;blockquote&gt;
                  &lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;-&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Specifies a range of matching characters.&amp;nbsp; For example
                  &amp;quot;[a-p]&amp;quot; matches all lowercase Latin letters from a to p (inclusive).&amp;nbsp; The -
                  sign specifies ranges of continuous Unicode numeric values, not ranges of characters in a
                  language&apos;s alphabetical order: &amp;quot;[a-z]&amp;quot; doesn&apos;t include capital letters, nor does
                  it include accented letters such as a-umlaut.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;::&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;A pair of colons containing a one- or two-letter code matches all
                  characters in the corresponding Unicode category.&amp;nbsp; The two-letter codes are the same
                  as the two-letter codes in the Unicode database (for example, &amp;quot;[:Sc::Sm:]&amp;quot;
                  matches all currency symbols and all math symbols).&amp;nbsp; Specifying a one-letter code is
                  the same as specifying all two-letter codes that begin with that letter (for example,
                  &amp;quot;[:L:]&amp;quot; matches all letters, and is equivalent to
                  &amp;quot;[:Lu::Ll::Lo::Lm::Lt:]&amp;quot;).&amp;nbsp; Anything other than a valid two-letter Unicode
                  category code or a single letter that begins a Unicode category code is illegal within
                  colons.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;[]&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;[] expressions can nest.&amp;nbsp; This has no effect, except when used in
                  conjunction with the ^ token.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;^&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;Excludes the character (or the characters in the [] expression) following
                  it from the group of characters.&amp;nbsp; For example, &amp;quot;[a-z^p]&amp;quot; matches all Latin
                  lowercase letters except p.&amp;nbsp; &amp;quot;[:L:^[&amp;#92;u4e00-&amp;#92;u9fff]]&amp;quot; matches all letters
                  except the Han ideographs.&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td width=&quot;6%&quot;&gt;&lt;em&gt;(all others)&lt;/em&gt;&lt;/td&gt;
                  &lt;td width=&quot;94%&quot;&gt;All other characters are treated as literal characters.&amp;nbsp; (For
                  example, &amp;quot;[aeiou]&amp;quot; specifies just the letters a, e, i, o, and u.)&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;For a more complete explanation, see &lt;a
                  href=&quot;http://www.ibm.com/java/education/boundaries/boundaries.html&quot;&gt;http://www.ibm.com/java/education/boundaries/boundaries.html&lt;/a&gt;.
                  &amp;nbsp; For examples, see the resource data (which is annotated).&lt;/p&gt;                
                <author>
                    Richard Gillam                    
                </author>
            </javadoc>
            <declaration name="IGNORE" type="byte" line="171"/>
            <javadoc line="171">
                A token used as a character-category value to identify ignore characters                
            </javadoc>
            <declaration name="START_STATE" type="short" line="175"/>
            <javadoc line="175">
                The state number of the starting state                
            </javadoc>
            <declaration name="STOP_STATE" type="short" line="179"/>
            <javadoc line="179">
                The state-transition value indicating &quot;stop&quot;                
            </javadoc>
            <declaration name="LABEL" type="byte[]" line="183"/>
            <javadoc line="183">
                Magic number for the BreakIterator data file format.                
            </javadoc>
            <declaration name="LABEL_LENGTH" type="int" line="187"/>
            <declaration name="supportedVersion" type="byte" line="188"/>
            <javadoc line="188">
                Version number of the dictionary that was read in.                
            </javadoc>
            <declaration name="HEADER_LENGTH" type="int" line="192"/>
            <javadoc line="192">
                Header size in byte count                
            </javadoc>
            <declaration name="BMP_INDICES_LENGTH" type="int" line="196"/>
            <javadoc line="196">
                An array length of indices for BMP characters                
            </javadoc>
            <declaration name="charCategoryTable" type="CompactByteArray" line="200"/>
            <javadoc line="200">
                Tables that indexes from character values to character category numbers                
            </javadoc>
            <declaration name="supplementaryCharCategoryTable" type="SupplementaryCharacterData" line="204"/>
            <declaration name="stateTable" type="short[]" line="205"/>
            <javadoc line="205">
                The table of state transitions used for forward iteration                
            </javadoc>
            <declaration name="backwardsStateTable" type="short[]" line="209"/>
            <javadoc line="209">
                The table of state transitions used to sync up the iterator with the
                  text in backwards and random-access iteration                
            </javadoc>
            <declaration name="endStates" type="boolean[]" line="214"/>
            <javadoc line="214">
                A list of flags indicating which states in the state table are accepting
                  (&quot;end&quot;) states                
            </javadoc>
            <declaration name="lookaheadStates" type="boolean[]" line="219"/>
            <javadoc line="219">
                A list of flags indicating which states in the state table are
                  lookahead states (states which turn lookahead on and off)                
            </javadoc>
            <declaration name="additionalData" type="byte[]" line="224"/>
            <javadoc line="224">
                A table for additional data. May be used by a subclass of
                  RuleBasedBreakIterator.                
            </javadoc>
            <declaration name="numCategories" type="int" line="229"/>
            <javadoc line="229">
                The number of character categories (and, thus, the number of columns in
                  the state tables)                
            </javadoc>
            <declaration name="text" type="CharacterIterator" line="234"/>
            <javadoc line="234">
                The character iterator through which this BreakIterator accesses the text                
            </javadoc>
            <declaration name="checksum" type="long" line="238"/>
            <javadoc line="238">
                A CRC32 value of all data in datafile                
            </javadoc>
            <javadoc line="242">
                Constructs a RuleBasedBreakIterator according to the datafile
                  provided.                
            </javadoc>
            <method name="RuleBasedBreakIterator" type="constructor" line="246">
                <params>
                    <param name="datafile" type="String"/>
                </params>
            </method>
            <javadoc line="249">
                Read datafile. The datafile&apos;s format is as follows:
                  &lt;pre&gt;
                  BreakIteratorData {
                  u1           magic[7];
                  u1           version;
                  u4           totalDataSize;
                  header_info  header;
                  body         value;
                  }
                  &lt;/pre&gt;
                  &lt;code&gt;totalDataSize&lt;/code&gt; is the summation of the size of
                  &lt;code&gt;header_info&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; in byte count.
                  &lt;p&gt;
                  In &lt;code&gt;header&lt;/code&gt;, each field except for checksum implies the
                  length of each field. Since &lt;code&gt;BMPdataLength&lt;/code&gt; is a fixed-length
                  data(512 entries), its length isn&apos;t included in &lt;code&gt;header&lt;/code&gt;.
                  &lt;code&gt;checksum&lt;/code&gt; is a CRC32 value of all in &lt;code&gt;body&lt;/code&gt;.
                  &lt;pre&gt;
                  header_info {
                  u4           stateTableLength;
                  u4           backwardsStateTableLength;
                  u4           endStatesLength;
                  u4           lookaheadStatesLength;
                  u4           BMPdataLength;
                  u4           nonBMPdataLength;
                  u4           additionalDataLength;
                  u8           checksum;
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;
                  Finally, &lt;code&gt;BMPindices&lt;/code&gt; and &lt;code&gt;BMPdata&lt;/code&gt; are set to
                  &lt;code&gt;charCategoryTable&lt;/code&gt;. &lt;code&gt;nonBMPdata&lt;/code&gt; is set to
                  &lt;code&gt;supplementaryCharCategoryTable&lt;/code&gt;.
                  &lt;pre&gt;
                  body {
                  u2           stateTable[stateTableLength];
                  u2           backwardsStateTable[backwardsStateTableLength];
                  u1           endStates[endStatesLength];
                  u1           lookaheadStates[lookaheadStatesLength];
                  u2           BMPindices[512];
                  u1           BMPdata[BMPdataLength];
                  u4           nonBMPdata[numNonBMPdataLength];
                  u1           additionalData[additionalDataLength];
                  }
                  &lt;/pre&gt;                
            </javadoc>
            <method name="readTables" type="void" line="296">
                <params>
                    <param name="datafile" type="String"/>
                </params>
                <declaration name="buffer" type="byte[]" line="297"/>
                <declaration name="stateTableLength" type="int" line="298"/>
                <declaration name="backwardsStateTableLength" type="int" line="299"/>
                <declaration name="endStatesLength" type="int" line="300"/>
                <declaration name="lookaheadStatesLength" type="int" line="301"/>
                <declaration name="BMPdataLength" type="int" line="302"/>
                <declaration name="nonBMPdataLength" type="int" line="303"/>
                <declaration name="additionalDataLength" type="int" line="304"/>
                <declaration name="offset" type="int" line="307"/>
                <scope line="308"/>
                <scope line="312"/>
                <scope line="316"/>
                <scope line="320"/>
                <declaration name="temp1" type="short[]" line="323"/>
                <scope line="324"/>
                <declaration name="temp2" type="byte[]" line="327"/>
                <declaration name="temp3" type="int[]" line="331"/>
                <scope line="332"/>
                <scope line="336"/>
            </method>
            <method name="readFile" type="byte[]" line="342">
                <params>
                    <param name="datafile" type="String"/>
                </params>
                <declaration name="is" type="BufferedInputStream" line="343"/>
                <scope line="344">
                    <anonymous_class line="345">
                        <method name="run" type="Object" line="346"/>
                    </anonymous_class>
                </scope>
                <scope line="352"/>
                <declaration name="offset" type="int" line="355"/>
                <declaration name="len" type="int" line="356"/>
                <declaration name="buf" type="byte[]" line="357"/>
                <scope line="358"/>
                <scope line="361">
                    <scope line="362"/>
                </scope>
                <scope line="366"/>
                <scope line="371"/>
            </method>
            <method name="getAdditionalData" type="byte[]" line="377"/>
            <method name="setAdditionalData" type="void" line="380">
                <params>
                    <param name="b" type="byte[]"/>
                </params>
            </method>
            <javadoc line="383">
                Clones this iterator.                
                <return>
                    A newly-constructed RuleBasedBreakIterator with the same
                      behavior as this one.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="388">
                <declaration name="result" type="RuleBasedBreakIterator" line="389"/>
                <scope line="390"/>
            </method>
            <javadoc line="395">
                Returns true if both BreakIterators are of the same class, have the same
                  rules, and iterate over the same text.                
            </javadoc>
            <method name="equals" type="boolean" line="399">
                <params>
                    <param name="that" type="Object"/>
                </params>
                <scope line="400">
                    <scope line="401"/>
                    <declaration name="other" type="RuleBasedBreakIterator" line="404"/>
                    <scope line="405"/>
                    <scope line="408"/>
                    <scope line="411"/>
                </scope>
                <scope line="415"/>
            </method>
            <javadoc line="419">
                Returns text                
            </javadoc>
            <method name="toString" type="String" line="422">
                <declaration name="sb" type="StringBuffer" line="423"/>
            </method>
            <javadoc line="429">
                Compute a hashcode for this BreakIterator                
                <return>
                    A hash code                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="433"/>
            <javadoc line="436">
                Sets the current iteration position to the beginning of the text.
                  (i.e., the CharacterIterator&apos;s starting offset).                
                <return>
                    The offset of the beginning of the text.                    
                </return>
            </javadoc>
            <method name="first" type="int" line="441">
                <declaration name="t" type="CharacterIterator" line="442"/>
            </method>
            <javadoc line="446">
                Sets the current iteration position to the end of the text.
                  (i.e., the CharacterIterator&apos;s ending offset).                
                <return>
                    The text&apos;s past-the-end offset.                    
                </return>
            </javadoc>
            <method name="last" type="int" line="451">
                <declaration name="t" type="CharacterIterator" line="452"/>
            </method>
            <javadoc line="456">
                Advances the iterator either forward or backward the specified number of steps.
                  Negative values move backward, and positive values move forward.  This is
                  equivalent to repeatedly calling next() or previous().                
                <param>
                    n The number of steps to move.  The sign indicates the direction
                      (negative is backwards, and positive is forwards).                    
                </param>
                <return>
                    The character offset of the boundary position n boundaries away from
                      the current one.                    
                </return>
            </javadoc>
            <method name="next" type="int" line="465">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="result" type="int" line="466"/>
                <scope line="467"/>
                <scope line="471"/>
            </method>
            <javadoc line="477">
                Advances the iterator to the next boundary position.                
                <return>
                    The position of the first boundary after this one.                    
                </return>
            </javadoc>
            <method name="next" type="int" line="481"/>
            <declaration name="cachedLastKnownBreak" type="int" line="484"/>
            <javadoc line="485">
                Advances the iterator backwards, to the last boundary preceding this one.                
                <return>
                    The position of the last boundary position preceding this one.                    
                </return>
            </javadoc>
            <method name="previous" type="int" line="489">
                <declaration name="text" type="CharacterIterator" line="490"/>
                <scope line="491"/>
                <declaration name="start" type="int" line="494"/>
                <declaration name="lastResult" type="int" line="495"/>
                <scope line="496"/>
                <scope line="500"/>
                <declaration name="result" type="int" line="503"/>
                <scope line="504"/>
            </method>
            <javadoc line="512">
                Returns previous character                
            </javadoc>
            <method name="getPrevious" type="int" line="515">
                <declaration name="c2" type="char" line="516"/>
                <scope line="517">
                    <declaration name="c1" type="char" line="518"/>
                    <scope line="519"/>
                    <scope line="522"/>
                </scope>
            </method>
            <javadoc line="528">
                Returns current character                
            </javadoc>
            <method name="getCurrent" type="int" line="531">
                <declaration name="c1" type="char" line="532"/>
                <scope line="533">
                    <declaration name="c2" type="char" line="534"/>
                    <scope line="536"/>
                </scope>
            </method>
            <javadoc line="542">
                Returns the count of next character.                
            </javadoc>
            <method name="getCurrentCodePointCount" type="int" line="545">
                <declaration name="c1" type="char" line="546"/>
                <scope line="547">
                    <declaration name="c2" type="char" line="548"/>
                    <scope line="550"/>
                </scope>
            </method>
            <javadoc line="556">
                Returns next character                
            </javadoc>
            <method name="getNext" type="int" line="559">
                <declaration name="index" type="int" line="560"/>
                <declaration name="endIndex" type="int" line="561"/>
                <scope line="562"/>
            </method>
            <javadoc line="568">
                Returns the position of next character.                
            </javadoc>
            <method name="getNextIndex" type="int" line="571">
                <declaration name="index" type="int" line="572"/>
                <declaration name="endIndex" type="int" line="573"/>
                <scope line="574"/>
                <scope line="577"/>
            </method>
            <javadoc line="581">
                Throw IllegalArgumentException unless begin &lt;= offset &lt; end.                
            </javadoc>
            <method name="checkOffset" type="void" line="584">
                <params>
                    <param name="offset" type="int"/>
                    <param name="text" type="CharacterIterator"/>
                </params>
                <scope line="585"/>
            </method>
            <javadoc line="589">
                Sets the iterator to refer to the first boundary position following
                  the specified position.                
                <offset>
                    The position from which to begin searching for a break position.                    
                </offset>
                <return>
                    The position of the first break after the current position.                    
                </return>
            </javadoc>
            <method name="following" type="int" line="595">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <declaration name="text" type="CharacterIterator" line="596"/>
                <scope line="599"/>
                <declaration name="result" type="int" line="603"/>
                <scope line="604"/>
                <scope line="607"/>
                <scope line="610"/>
            </method>
            <javadoc line="616">
                Sets the iterator to refer to the last boundary position before the
                  specified position.                
                <offset>
                    The position to begin searching for a break from.                    
                </offset>
                <return>
                    The position of the last boundary before the starting position.                    
                </return>
            </javadoc>
            <method name="preceding" type="int" line="622">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <declaration name="text" type="CharacterIterator" line="623"/>
            </method>
            <javadoc line="628">
                Returns true if the specfied position is a boundary position.  As a side
                  effect, leaves the iterator pointing to the first boundary position at
                  or after &quot;offset&quot;.                
                <param>
                    offset the offset to check.                    
                </param>
                <return>
                    True if &quot;offset&quot; is a boundary position.                    
                </return>
            </javadoc>
            <method name="isBoundary" type="boolean" line="635">
                <params>
                    <param name="offset" type="int"/>
                </params>
                <declaration name="text" type="CharacterIterator" line="636"/>
                <scope line="638"/>
                <scope line="641"/>
            </method>
            <javadoc line="645">
                Returns the current iteration position.                
                <return>
                    The current iteration position.                    
                </return>
            </javadoc>
            <method name="current" type="int" line="649"/>
            <javadoc line="652">
                Return a CharacterIterator over the text being analyzed.  This version
                  of this method returns the actual CharacterIterator we&apos;re using internally.
                  Changing the state of this iterator can have undefined consequences.  If
                  you need to change it, clone it first.                
                <return>
                    An iterator over the text being analyzed.                    
                </return>
            </javadoc>
            <method name="getText" type="CharacterIterator" line="659">
                <scope line="660"/>
            </method>
            <javadoc line="665">
                Set the iterator to analyze a new piece of text.  This function resets
                  the current iteration position to the beginning of the text.                
                <param>
                    newText An iterator over the text to analyze.                    
                </param>
            </javadoc>
            <method name="setText" type="void" line="670">
                <params>
                    <param name="newText" type="CharacterIterator"/>
                </params>
                <declaration name="end" type="int" line="671"/>
                <declaration name="goodIterator" type="boolean" line="672"/>
                <scope line="673"/>
                <scope line="677"/>
                <scope line="680"/>
                <scope line="683"/>
            </method>
            <javadoc line="689">
                This method is the actual implementation of the next() method.  All iteration
                  vectors through here.  This method initializes the state machine to state 1
                  and advances through the text character by character until we reach the end
                  of the text or the state machine transitions to state 0.  We update our return
                  value every time the state machine passes through a possible end state.                
            </javadoc>
            <method name="handleNext" type="int" line="696">
                <declaration name="text" type="CharacterIterator" line="697"/>
                <scope line="698"/>
                <declaration name="result" type="int" line="701"/>
                <declaration name="lookaheadResult" type="int" line="702"/>
                <declaration name="state" type="int" line="703"/>
                <declaration name="category" type="int" line="704"/>
                <declaration name="c" type="int" line="705"/>
                <scope line="706">
                    <scope line="708"/>
                    <scope line="711">
                        <scope line="712"/>
                        <scope line="715"/>
                    </scope>
                    <scope line="719">
                        <scope line="720"/>
                    </scope>
                </scope>
                <scope line="726"/>
            </method>
            <javadoc line="732">
                This method backs the iterator back up to a &quot;safe position&quot; in the text.
                  This is a position that we know, without any context, must be a break position.
                  The various calling methods then iterate forward from this safe position to
                  the appropriate position to return.  (For more information, see the description
                  of buildBackwardsStateTable() in RuleBasedBreakIterator.Builder.)                
            </javadoc>
            <method name="handlePrevious" type="int" line="739">
                <declaration name="text" type="CharacterIterator" line="740"/>
                <declaration name="state" type="int" line="741"/>
                <declaration name="category" type="int" line="742"/>
                <declaration name="lastCategory" type="int" line="743"/>
                <declaration name="c" type="int" line="744"/>
                <scope line="745">
                    <scope line="748"/>
                </scope>
                <scope line="753">
                    <scope line="754"/>
                    <scope line="758"/>
                </scope>
            </method>
            <javadoc line="764">
                Looks up a character&apos;s category (i.e., its category for breaking purposes,
                  not its Unicode category)                
            </javadoc>
            <method name="lookupCategory" type="int" line="768">
                <params>
                    <param name="c" type="int"/>
                </params>
                <scope line="769"/>
                <scope line="772"/>
            </method>
            <javadoc line="776">
                Given a current state and a character category, looks up the
                  next state to transition to in the state table.                
            </javadoc>
            <method name="lookupState" type="int" line="780">
                <params>
                    <param name="state" type="int"/>
                    <param name="category" type="int"/>
                </params>
            </method>
            <javadoc line="783">
                Given a current state and a character category, looks up the
                  next state to transition to in the backwards state table.                
            </javadoc>
            <method name="lookupBackwardState" type="int" line="787">
                <params>
                    <param name="state" type="int"/>
                    <param name="category" type="int"/>
                </params>
            </method>
            <class name="SafeCharIterator" line="790">
                <implements interface="CharacterIterator"/>
                <implements interface="Cloneable"/>
                <declaration name="base" type="CharacterIterator" line="791"/>
                <declaration name="rangeStart" type="int" line="792"/>
                <declaration name="rangeLimit" type="int" line="793"/>
                <declaration name="currentIndex" type="int" line="794"/>
                <method name="SafeCharIterator" type="constructor" line="795">
                    <params>
                        <param name="base" type="CharacterIterator"/>
                    </params>
                </method>
                <method name="first" type="char" line="801"/>
                <method name="last" type="char" line="804"/>
                <method name="current" type="char" line="807">
                    <scope line="808"/>
                    <scope line="811"/>
                </method>
                <method name="next" type="char" line="815">
                    <scope line="817"/>
                    <scope line="821"/>
                </method>
                <method name="previous" type="char" line="825">
                    <scope line="827"/>
                    <scope line="831"/>
                </method>
                <method name="setIndex" type="char" line="835">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                    <scope line="836"/>
                </method>
                <method name="getBeginIndex" type="int" line="842"/>
                <method name="getEndIndex" type="int" line="845"/>
                <method name="getIndex" type="int" line="848"/>
                <method name="clone" type="Object" line="851">
                    <declaration name="copy" type="SafeCharIterator" line="852"/>
                    <scope line="853"/>
                    <scope line="856"/>
                    <declaration name="copyOfBase" type="CharacterIterator" line="859"/>
                </method>
            </class>
        </class>
    </source>