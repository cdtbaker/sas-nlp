<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.io.InvalidObjectException"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.text.DecimalFormat"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Date"/>
        <import package="java.util.List"/>
        <import package="java.util.Locale"/>
        <class name="MessageFormat" line="52">
            <extends class="Format"/>
            <comment line="840">
                Overrides                
            </comment>
            <comment line="1167">
                ===========================privates============================                
            </comment>
            <comment line="1350">
                Indices for segments                
            </comment>
            <comment line="1354">
                modifier or subformat                
            </comment>
            <comment line="1356">
                Indices for type keywords                
            </comment>
            <comment line="1371">
                Indices for number modifiers                
            </comment>
            <comment line="1372">
                common in number and date-time                
            </comment>
            <comment line="1384">
                Indices for date-time modifiers                
            </comment>
            <comment line="1398">
                Date-time style values corresponding to the date-time modifiers.                
            </comment>
            <javadoc line="52">
                &lt;code&gt;MessageFormat&lt;/code&gt; provides a means to produce concatenated
                  messages in a language-neutral way. Use this to construct messages
                  displayed for end users.
                  &lt;p&gt;
                  &lt;code&gt;MessageFormat&lt;/code&gt; takes a set of objects, formats them, then
                  inserts the formatted strings into the pattern at the appropriate places.
                  &lt;p&gt;
                  &lt;strong&gt;Note:&lt;/strong&gt;
                  &lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
                  classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one
                  of its constructors (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory
                  method). The factory methods aren&apos;t necessary because &lt;code&gt;MessageFormat&lt;/code&gt;
                  itself doesn&apos;t implement locale specific behavior. Any locale specific
                  behavior is defined by the pattern that you provide as well as the
                  subformats used for inserted arguments.
                  &lt;h4&gt;&lt;a name=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h4&gt;
                  &lt;code&gt;MessageFormat&lt;/code&gt; uses patterns of the following form:
                  &lt;blockquote&gt;&lt;pre&gt;
                  &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
                  &lt;i&gt;String&lt;/i&gt;
                  &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
                  &lt;i&gt;FormatElement:&lt;/i&gt;
                  { &lt;i&gt;ArgumentIndex&lt;/i&gt; }
                  { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; }
                  { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; , &lt;i&gt;FormatStyle&lt;/i&gt; }
                  &lt;i&gt;FormatType: one of &lt;/i&gt;
                  number date time choice
                  &lt;i&gt;FormatStyle:&lt;/i&gt;
                  short
                  medium
                  long
                  full
                  integer
                  currency
                  percent
                  &lt;i&gt;SubformatPattern&lt;/i&gt;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;Within a &lt;i&gt;String&lt;/i&gt;, a pair of single quotes can be used to
                  quote any arbitrary characters except single quotes. For example,
                  pattern string &lt;code&gt;&quot;&apos;{0}&apos;&quot;&lt;/code&gt; represents string
                  &lt;code&gt;&quot;{0}&quot;&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A single quote itself
                  must be represented by doubled single quotes {@code &apos;&apos;} throughout a
                  &lt;i&gt;String&lt;/i&gt;.  For example, pattern string &lt;code&gt;&quot;&apos;{&apos;&apos;}&apos;&quot;&lt;/code&gt; is
                  interpreted as a sequence of &lt;code&gt;&apos;{&lt;/code&gt; (start of quoting and a
                  left curly brace), &lt;code&gt;&apos;&apos;&lt;/code&gt; (a single quote), and
                  &lt;code&gt;}&apos;&lt;/code&gt; (a right curly brace and end of quoting),
                  &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&apos;{&apos;&lt;/code&gt; and &lt;code&gt;&apos;}&apos;&lt;/code&gt; (quoted left and
                  right curly braces): representing string &lt;code&gt;&quot;{&apos;}&quot;&lt;/code&gt;,
                  &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&quot;{}&quot;&lt;/code&gt;.
                  &lt;p&gt;A &lt;i&gt;SubformatPattern&lt;/i&gt; is interpreted by its corresponding
                  subformat, and subformat-dependent pattern rules apply. For example,
                  pattern string &lt;code&gt;&quot;{1,number,&lt;u&gt;$&apos;#&apos;,##&lt;/u&gt;}&quot;&lt;/code&gt;
                  (&lt;i&gt;SubformatPattern&lt;/i&gt; with underline) will produce a number format
                  with the pound-sign quoted, with a result such as: {@code&quot;$#31,45&quot;}. Refer to each {@code Format} subclass documentation for
                  details.
                  &lt;p&gt;Any unmatched quote is treated as closed at the end of the given
                  pattern. For example, pattern string {@code} &quot;&apos;
                  0}&quot;} is treated as
                  pattern {@code} &quot;&apos;
                  0}&apos;&quot;}.
                  &lt;p&gt;Any curly braces within an unquoted pattern must be balanced. For
                  example, &lt;code&gt;&quot;ab {0} de&quot;&lt;/code&gt; and &lt;code&gt;&quot;ab &apos;}&apos; de&quot;&lt;/code&gt; are
                  valid patterns, but &lt;code&gt;&quot;ab {0&apos;}&apos; de&quot;&lt;/code&gt;, &lt;code&gt;&quot;ab } de&quot;&lt;/code&gt;
                  and &lt;code&gt;&quot;&apos;&apos;{&apos;&apos;&quot;&lt;/code&gt; are not.
                  &lt;p&gt;
                  &lt;dl&gt;&lt;dt&gt;&lt;b&gt;Warning:&lt;/b&gt;&lt;dd&gt;The rules for using quotes within message
                  format patterns unfortunately have shown to be somewhat confusing.
                  In particular, it isn&apos;t always obvious to localizers whether single
                  quotes need to be doubled or not. Make sure to inform localizers about
                  the rules, and tell them (for example, by using comments in resource
                  bundle source files) which strings will be processed by {@code MessageFormat}.
                  Note that localizers may need to use single quotes in translated
                  strings where the original version doesn&apos;t have them.
                  &lt;/dl&gt;
                  &lt;p&gt;
                  The &lt;i&gt;ArgumentIndex&lt;/i&gt; value is a non-negative integer written
                  using the digits {@code &apos;0&apos;} through {@code &apos;9&apos;}, and represents an index into the{@code arguments} array passed to the {@code format} methods
                  or the result array returned by the {@code parse} methods.
                  &lt;p&gt;
                  The &lt;i&gt;FormatType&lt;/i&gt; and &lt;i&gt;FormatStyle&lt;/i&gt; values are used to create
                  a {@code Format} instance for the format element. The following
                  table shows how the values map to {@code Format} instances. Combinations not
                  shown in the table are illegal. A &lt;i&gt;SubformatPattern&lt;/i&gt; must
                  be a valid pattern string for the {@code Format} subclass used.
                  &lt;p&gt;
                  &lt;table border=1 summary=&quot;Shows how FormatType and FormatStyle values map to Format instances&quot;&gt;
                  &lt;tr&gt;
                  &lt;th id=&quot;ft&quot; class=&quot;TableHeadingColor&quot;&gt;FormatType
                  &lt;th id=&quot;fs&quot; class=&quot;TableHeadingColor&quot;&gt;FormatStyle
                  &lt;th id=&quot;sc&quot; class=&quot;TableHeadingColor&quot;&gt;Subformat Created
                  &lt;tr&gt;
                  &lt;td headers=&quot;ft&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
                  &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;null&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td headers=&quot;ft&quot; rowspan=5&gt;&lt;code&gt;number&lt;/code&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getInstance(Locale) NumberFormat.getInstance}{@code (getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;integer&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getIntegerInstance(Locale) NumberFormat.getIntegerInstance}{@code (getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;currency&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getCurrencyInstance(Locale) NumberFormat.getCurrencyInstance}{@code (getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;percent&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getPercentInstance(Locale) NumberFormat.getPercentInstance}{@code (getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@code new} {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}&lt;tr&gt;
                  &lt;td headers=&quot;ft&quot; rowspan=6&gt;&lt;code&gt;date&lt;/code&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;short&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;medium&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;long&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;full&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;ft&quot; rowspan=6&gt;&lt;code&gt;time&lt;/code&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;short&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;medium&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;long&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;full&lt;/code&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}&lt;tr&gt;
                  &lt;td headers=&quot;ft&quot;&gt;&lt;code&gt;choice&lt;/code&gt;
                  &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
                  &lt;td headers=&quot;sc&quot;&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}&lt;/table&gt;
                  &lt;p&gt;
                  &lt;h4&gt;Usage Information&lt;/h4&gt;
                  &lt;p&gt;
                  Here are some examples of usage.
                  In real internationalized programs, the message format pattern and other
                  static strings will, of course, be obtained from resource bundles.
                  Other parameters will be dynamically determined at runtime.
                  &lt;p&gt;
                  The first example uses the static method &lt;code&gt;MessageFormat.format&lt;/code&gt;,
                  which internally creates a &lt;code&gt;MessageFormat&lt;/code&gt; for one-time use:
                  &lt;blockquote&gt;&lt;pre&gt;
                  int planet = 7;
                  String event = &quot;a disturbance in the Force&quot;;
                  String result = MessageFormat.format(
                  &quot;At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.&quot;,
                  planet, new Date(), event);
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  The output is:
                  &lt;blockquote&gt;&lt;pre&gt;
                  At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  The following example creates a &lt;code&gt;MessageFormat&lt;/code&gt; instance that
                  can be used repeatedly:
                  &lt;blockquote&gt;&lt;pre&gt;
                  int fileCount = 1273;
                  String diskName = &quot;MyDisk&quot;;
                  Object[] testArgs = {new Long(fileCount), diskName};
                  MessageFormat form = new MessageFormat(
                  &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
                  System.out.println(form.format(testArgs));
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
                  &lt;blockquote&gt;&lt;pre&gt;
                  The disk &quot;MyDisk&quot; contains 0 file(s).
                  The disk &quot;MyDisk&quot; contains 1 file(s).
                  The disk &quot;MyDisk&quot; contains 1,273 file(s).
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  For more sophisticated patterns, you can use a &lt;code&gt;ChoiceFormat&lt;/code&gt;
                  to produce correct forms for singular and plural:
                  &lt;blockquote&gt;&lt;pre&gt;
                  MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
                  double[] filelimits = {0,1,2};
                  String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
                  ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
                  form.setFormatByArgumentIndex(0, fileform);
                  int fileCount = 1273;
                  String diskName = &quot;MyDisk&quot;;
                  Object[] testArgs = {new Long(fileCount), diskName};
                  System.out.println(form.format(testArgs));
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
                  &lt;blockquote&gt;&lt;pre&gt;
                  The disk &quot;MyDisk&quot; contains no files.
                  The disk &quot;MyDisk&quot; contains one file.
                  The disk &quot;MyDisk&quot; contains 1,273 files.
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  You can create the &lt;code&gt;ChoiceFormat&lt;/code&gt; programmatically, as in the
                  above example, or by using a pattern. See {@link ChoiceFormat}for more information.
                  &lt;blockquote&gt;&lt;pre&gt;
                  form.applyPattern(
                  &quot;There {0,choice,0#are no files|1#is one file|1&amp;lt;are {0,number,integer} files}.&quot;);
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
                  by a &lt;code&gt;ChoiceFormat&lt;/code&gt; in &lt;code&gt;MessageFormat&lt;/code&gt; is treated as special;
                  occurrences of &apos;{&apos; are used to indicate subformats, and cause recursion.
                  If you create both a &lt;code&gt;MessageFormat&lt;/code&gt; and &lt;code&gt;ChoiceFormat&lt;/code&gt;
                  programmatically (instead of using the string patterns), then be careful not to
                  produce a format that recurses on itself, which will cause an infinite loop.
                  &lt;p&gt;
                  When a single argument is parsed more than once in the string, the last match
                  will be the final result of the parsing.  For example,
                  &lt;blockquote&gt;&lt;pre&gt;
                  MessageFormat mf = new MessageFormat(&quot;{0,number,#.##}, {0,number,#.#}&quot;);
                  Object[] objs = {new Double(3.1415)};
                  String result = mf.format( objs );
                  // result now equals &quot;3.14, 3.1&quot;
                  objs = null;
                  objs = mf.parse(result, new ParsePosition(0));
                  // objs now equals {new Double(3.1)}
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  Likewise, parsing with a {@code MessageFormat} object using patterns containing
                  multiple occurrences of the same argument would return the last match.  For
                  example,
                  &lt;blockquote&gt;&lt;pre&gt;
                  MessageFormat mf = new MessageFormat(&quot;{0}, {0}, {0}&quot;);
                  String forParsing = &quot;x, y, z&quot;;
                  Object[] objs = mf.parse(forParsing, new ParsePosition(0));
                  // result now equals {new String(&quot;z&quot;)}
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt;
                  Message formats are not synchronized.
                  It is recommended to create separate format instances for each thread.
                  If multiple threads access a format concurrently, it must be synchronized
                  externally.                
                <see>
                    java.util.Locale                    
                </see>
                <see>
                    Format                    
                </see>
                <see>
                    NumberFormat                    
                </see>
                <see>
                    DecimalFormat                    
                </see>
                <see>
                    DecimalFormatSymbols                    
                </see>
                <see>
                    ChoiceFormat                    
                </see>
                <see>
                    DateFormat                    
                </see>
                <see>
                    SimpleDateFormat                    
                </see>
                <author>
                    Mark Davis                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="348"/>
            <javadoc line="350">
                Constructs a MessageFormat for the default locale and the
                  specified pattern.
                  The constructor first sets the locale, then parses the pattern and
                  creates a list of subformats for the format elements contained in it.
                  Patterns and their interpretation are specified in the
                  &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.                
                <param>
                    pattern the pattern for this message format                    
                </param>
                <exception>
                    IllegalArgumentException if the pattern is invalid                    
                </exception>
            </javadoc>
            <method name="MessageFormat" type="constructor" line="361">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="366">
                Constructs a MessageFormat for the specified locale and
                  pattern.
                  The constructor first sets the locale, then parses the pattern and
                  creates a list of subformats for the format elements contained in it.
                  Patterns and their interpretation are specified in the
                  &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.                
                <param>
                    pattern the pattern for this message format                    
                </param>
                <param>
                    locale the locale for this message format                    
                </param>
                <exception>
                    IllegalArgumentException if the pattern is invalid                    
                </exception>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="MessageFormat" type="constructor" line="379">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="locale" type="Locale"/>
                </params>
            </method>
            <javadoc line="384">
                Sets the locale to be used when creating or comparing subformats.
                  This affects subsequent calls
                  &lt;ul&gt;
                  &lt;li&gt;to the {@link #applyPattern applyPattern}and {@link #toPattern toPattern} methods if format elements specify
                  a format type and therefore have the subformats created in the
                  &lt;code&gt;applyPattern&lt;/code&gt; method, as well as
                  &lt;li&gt;to the &lt;code&gt;format&lt;/code&gt; and{@link #formatToCharacterIterator formatToCharacterIterator} methods
                  if format elements do not specify a format type and therefore have
                  the subformats created in the formatting methods.
                  &lt;/ul&gt;
                  Subformats that have already been created are not affected.                
                <param>
                    locale the locale to be used when creating or comparing subformats                    
                </param>
            </javadoc>
            <method name="setLocale" type="void" line="401">
                <params>
                    <param name="locale" type="Locale"/>
                </params>
            </method>
            <javadoc line="405">
                Gets the locale that&apos;s used when creating or comparing subformats.                
                <return>
                    the locale used when creating or comparing subformats                    
                </return>
            </javadoc>
            <method name="getLocale" type="Locale" line="410"/>
            <javadoc line="415">
                Sets the pattern used by this message format.
                  The method parses the pattern and creates a list of subformats
                  for the format elements contained in it.
                  Patterns and their interpretation are specified in the
                  &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.                
                <param>
                    pattern the pattern for this message format                    
                </param>
                <exception>
                    IllegalArgumentException if the pattern is invalid                    
                </exception>
            </javadoc>
            <method name="applyPattern" type="void" line="425">
                <params>
                    <param name="pattern" type="String"/>
                </params>
                <comment line="427">
                    Allocate only segments[SEG_RAW] here. The rest are                    
                </comment>
                <comment line="428">
                    allocated on demand.                    
                </comment>
                <comment line="442">
                    handle doubles                    
                </comment>
                <comment line="456">
                    just copy quotes in parts                    
                </comment>
                <comment line="481">
                    throw away other segments                    
                </comment>
                <comment line="491">
                    Skip any leading space chars for SEG_TYPE.                    
                </comment>
                <comment line="498">
                    fall through, so we keep quotes in other parts                    
                </comment>
                <declaration name="segments" type="StringBuilder[]" line="426"/>
                <declaration name="part" type="int" line="431"/>
                <declaration name="formatNumber" type="int" line="432"/>
                <declaration name="inQuote" type="boolean" line="433"/>
                <declaration name="braceStack" type="int" line="434"/>
                <scope line="436">
                    <declaration name="ch" type="char" line="437"/>
                    <scope line="438">
                        <scope line="439">
                            <scope line="441"/>
                            <scope line="444"/>
                        </scope>
                        <scope line="447">
                            <scope line="449"/>
                        </scope>
                        <scope line="452"/>
                    </scope>
                    <scope line="455">
                        <scope line="456">
                            <scope line="458"/>
                        </scope>
                        <scope line="461">
                            <scope line="464">
                                <scope line="465"/>
                            </scope>
                            <scope line="468"/>
                            <scope line="477"/>
                            <scope line="485"/>
                            <scope line="492"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="506"/>
            </method>
            <javadoc line="514">
                Returns a pattern representing the current state of the message format.
                  The string is constructed from internal information and therefore
                  does not necessarily equal the previously applied pattern.                
                <return>
                    a pattern representing the current state of the message format                    
                </return>
            </javadoc>
            <method name="toPattern" type="String" line="521">
                <comment line="522">
                    later, make this more extensible                    
                </comment>
                <comment line="531">
                    do nothing, string format                    
                </comment>
                <comment line="547">
                    UNKNOWN                    
                </comment>
                <comment line="570">
                    UNKNOWN                    
                </comment>
                <comment line="576">
                    result.append(&quot;, unknown&quot;);                    
                </comment>
                <declaration name="lastOffset" type="int" line="523"/>
                <declaration name="result" type="StringBuilder" line="524"/>
                <scope line="525">
                    <declaration name="fmt" type="Format" line="529"/>
                    <scope line="530"/>
                    <scope line="532">
                        <scope line="533"/>
                        <scope line="535"/>
                        <scope line="537"/>
                        <scope line="539"/>
                        <scope line="541">
                            <scope line="542"/>
                            <scope line="544"/>
                            <scope line="546"/>
                        </scope>
                    </scope>
                    <scope line="550">
                        <declaration name="index" type="int" line="551"/>
                        <scope line="552">
                            <declaration name="df" type="DateFormat" line="553"/>
                            <scope line="555"/>
                            <scope line="561"/>
                        </scope>
                        <scope line="566">
                            <scope line="567"/>
                            <scope line="569"/>
                        </scope>
                        <scope line="572"/>
                    </scope>
                    <scope line="575"/>
                </scope>
            </method>
            <javadoc line="584">
                Sets the formats to use for the values passed into
                  &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;
                  methods. The indices of elements in &lt;code&gt;newFormats&lt;/code&gt;
                  correspond to the argument indices used in the previously set
                  pattern string.
                  The order of formats in &lt;code&gt;newFormats&lt;/code&gt; thus corresponds to
                  the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed
                  to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
                  by the &lt;code&gt;parse&lt;/code&gt; methods.
                  &lt;p&gt;
                  If an argument index is used for more than one format element
                  in the pattern string, then the corresponding new format is used
                  for all such format elements. If an argument index is not used
                  for any format element in the pattern string, then the
                  corresponding new format is ignored. If fewer formats are provided
                  than needed, then only the formats for argument indices less
                  than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.                
                <param>
                    newFormats the new formats to use                    
                </param>
                <exception>
                    NullPointerException if <code>newFormats</code> is null                    
                </exception>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setFormatsByArgumentIndex" type="void" line="607">
                <params>
                    <param name="newFormats" type="Format[]"/>
                </params>
                <scope line="608">
                    <declaration name="j" type="int" line="609"/>
                    <scope line="610"/>
                </scope>
            </method>
            <javadoc line="616">
                Sets the formats to use for the format elements in the
                  previously set pattern string.
                  The order of formats in &lt;code&gt;newFormats&lt;/code&gt; corresponds to
                  the order of format elements in the pattern string.
                  &lt;p&gt;
                  If more formats are provided than needed by the pattern string,
                  the remaining ones are ignored. If fewer formats are provided
                  than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt;
                  formats are replaced.
                  &lt;p&gt;
                  Since the order of format elements in a pattern string often
                  changes during localization, it is generally better to use the{@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}method, which assumes an order of formats corresponding to the
                  order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to
                  the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by
                  the &lt;code&gt;parse&lt;/code&gt; methods.                
                <param>
                    newFormats the new formats to use                    
                </param>
                <exception>
                    NullPointerException if <code>newFormats</code> is null                    
                </exception>
            </javadoc>
            <method name="setFormats" type="void" line="638">
                <params>
                    <param name="newFormats" type="Format[]"/>
                </params>
                <declaration name="runsToCopy" type="int" line="639"/>
                <scope line="640"/>
                <scope line="643"/>
            </method>
            <javadoc line="648">
                Sets the format to use for the format elements within the
                  previously set pattern string that use the given argument
                  index.
                  The argument index is part of the format element definition and
                  represents an index into the &lt;code&gt;arguments&lt;/code&gt; array passed
                  to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
                  by the &lt;code&gt;parse&lt;/code&gt; methods.
                  &lt;p&gt;
                  If the argument index is used for more than one format element
                  in the pattern string, then the new format is used for all such
                  format elements. If the argument index is not used for any format
                  element in the pattern string, then the new format is ignored.                
                <param>
                    argumentIndex the argument index for which to use the new format                    
                </param>
                <param>
                    newFormat the new format to use                    
                </param>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="setFormatByArgumentIndex" type="void" line="666">
                <params>
                    <param name="argumentIndex" type="int"/>
                    <param name="newFormat" type="Format"/>
                </params>
                <scope line="667">
                    <scope line="668"/>
                </scope>
            </method>
            <javadoc line="674">
                Sets the format to use for the format element with the given
                  format element index within the previously set pattern string.
                  The format element index is the zero-based number of the format
                  element counting from the start of the pattern string.
                  &lt;p&gt;
                  Since the order of format elements in a pattern string often
                  changes during localization, it is generally better to use the{@link #setFormatByArgumentIndex setFormatByArgumentIndex}method, which accesses format elements based on the argument
                  index they specify.                
                <param>
                    formatElementIndex the index of a format element within the pattern                    
                </param>
                <param>
                    newFormat the format to use for the specified format element                    
                </param>
                <exception>
                    ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or
                      larger than the number of format elements in the pattern string                    
                </exception>
            </javadoc>
            <method name="setFormat" type="void" line="691">
                <params>
                    <param name="formatElementIndex" type="int"/>
                    <param name="newFormat" type="Format"/>
                </params>
            </method>
            <javadoc line="695">
                Gets the formats used for the values passed into
                  &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;
                  methods. The indices of elements in the returned array
                  correspond to the argument indices used in the previously set
                  pattern string.
                  The order of formats in the returned array thus corresponds to
                  the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed
                  to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
                  by the &lt;code&gt;parse&lt;/code&gt; methods.
                  &lt;p&gt;
                  If an argument index is used for more than one format element
                  in the pattern string, then the format used for the last such
                  format element is returned in the array. If an argument index
                  is not used for any format element in the pattern string, then
                  null is returned in the array.                
                <return>
                    the formats used for the arguments within the pattern                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="getFormatsByArgumentIndex" type="Format[]" line="715">
                <declaration name="maximumArgumentNumber" type="int" line="716"/>
                <scope line="717">
                    <scope line="718"/>
                </scope>
                <declaration name="resultArray" type="Format[]" line="722"/>
                <scope line="723"/>
            </method>
            <javadoc line="729">
                Gets the formats used for the format elements in the
                  previously set pattern string.
                  The order of formats in the returned array corresponds to
                  the order of format elements in the pattern string.
                  &lt;p&gt;
                  Since the order of format elements in a pattern string often
                  changes during localization, it&apos;s generally better to use the{@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}method, which assumes an order of formats corresponding to the
                  order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to
                  the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by
                  the &lt;code&gt;parse&lt;/code&gt; methods.                
                <return>
                    the formats used for the format elements in the pattern                    
                </return>
            </javadoc>
            <method name="getFormats" type="Format[]" line="745">
                <declaration name="resultArray" type="Format[]" line="746"/>
            </method>
            <javadoc line="751">
                Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&apos;s
                  pattern, with format elements replaced by the formatted objects, to the
                  provided &lt;code&gt;StringBuffer&lt;/code&gt;.
                  &lt;p&gt;
                  The text substituted for the individual format elements is derived from
                  the current subformat of the format element and the
                  &lt;code&gt;arguments&lt;/code&gt; element at the format element&apos;s argument index
                  as indicated by the first matching line of the following table. An
                  argument is &lt;i&gt;unavailable&lt;/i&gt; if &lt;code&gt;arguments&lt;/code&gt; is
                  &lt;code&gt;null&lt;/code&gt; or has fewer than argumentIndex+1 elements.
                  &lt;p&gt;
                  &lt;table border=1 summary=&quot;Examples of subformat,argument,and formatted text&quot;&gt;
                  &lt;tr&gt;
                  &lt;th&gt;Subformat
                  &lt;th&gt;Argument
                  &lt;th&gt;Formatted Text
                  &lt;tr&gt;
                  &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
                  &lt;td&gt;&lt;i&gt;unavailable&lt;/i&gt;
                  &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
                  &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;&quot;null&quot;&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;instanceof ChoiceFormat&lt;/code&gt;
                  &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
                  &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf(&apos;{&apos;) &gt;= 0 ?&lt;br&gt;
                  (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
                  subformat.format(argument)&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;!= null&lt;/code&gt;
                  &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
                  &lt;td&gt;&lt;code&gt;subformat.format(argument)&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;instanceof Number&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;NumberFormat.getInstance(getLocale()).format(argument)&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;instanceof Date&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;instanceof String&lt;/code&gt;
                  &lt;td&gt;&lt;code&gt;argument&lt;/code&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
                  &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
                  &lt;td&gt;&lt;code&gt;argument.toString()&lt;/code&gt;
                  &lt;/table&gt;
                  &lt;p&gt;
                  If &lt;code&gt;pos&lt;/code&gt; is non-null, and refers to
                  &lt;code&gt;Field.ARGUMENT&lt;/code&gt;, the location of the first formatted
                  string will be returned.                
                <param>
                    arguments an array of objects to be formatted and substituted.                    
                </param>
                <param>
                    result where text is appended.                    
                </param>
                <param>
                    pos On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <exception>
                    IllegalArgumentException if an argument in the
                      <code>arguments</code> array is not of the type
                      expected by the format element(s) that use it.                    
                </exception>
            </javadoc>
            <method name="format" type="StringBuffer" line="818">
                <params>
                    <param name="arguments" type="Object[]"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="pos" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="822">
                Creates a MessageFormat with the given pattern and uses it
                  to format the given arguments. This is equivalent to
                  &lt;blockquote&gt;
                  &lt;code&gt;(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
                  &lt;/blockquote&gt;                
                <exception>
                    IllegalArgumentException if the pattern is invalid,
                      or if an argument in the <code>arguments</code> array
                      is not of the type expected by the format element(s)
                      that use it.                    
                </exception>
            </javadoc>
            <method name="format" type="String" line="834">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="arguments" type="Object"/>
                </params>
                <declaration name="temp" type="MessageFormat" line="835"/>
            </method>
            <javadoc line="840">
                Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&apos;s
                  pattern, with format elements replaced by the formatted objects, to the
                  provided &lt;code&gt;StringBuffer&lt;/code&gt;.
                  This is equivalent to
                  &lt;blockquote&gt;
                  &lt;code&gt;{@link #format(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition) format}((Object[]) arguments, result, pos)&lt;/code&gt;
                  &lt;/blockquote&gt;                
                <param>
                    arguments an array of objects to be formatted and substituted.                    
                </param>
                <param>
                    result where text is appended.                    
                </param>
                <param>
                    pos On input: an alignment field, if desired.
                      On output: the offsets of the alignment field.                    
                </param>
                <exception>
                    IllegalArgumentException if an argument in the
                      <code>arguments</code> array is not of the type
                      expected by the format element(s) that use it.                    
                </exception>
            </javadoc>
            <method name="format" type="StringBuffer" line="859">
                <params>
                    <param name="arguments" type="Object"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="pos" type="FieldPosition"/>
                </params>
            </method>
            <javadoc line="863">
                Formats an array of objects and inserts them into the
                  &lt;code&gt;MessageFormat&lt;/code&gt;&apos;s pattern, producing an
                  &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
                  You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
                  to build the resulting String, as well as to determine information
                  about the resulting String.
                  &lt;p&gt;
                  The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is
                  the same that would be returned by
                  &lt;blockquote&gt;
                  &lt;code&gt;{@link #format(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;
                  In addition, the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; contains at
                  least attributes indicating where text was generated from an
                  argument in the &lt;code&gt;arguments&lt;/code&gt; array. The keys of these attributes are of
                  type &lt;code&gt;MessageFormat.Field&lt;/code&gt;, their values are
                  &lt;code&gt;Integer&lt;/code&gt; objects indicating the index in the &lt;code&gt;arguments&lt;/code&gt;
                  array of the argument from which the text was generated.
                  &lt;p&gt;
                  The attributes/value from the underlying &lt;code&gt;Format&lt;/code&gt;
                  instances that &lt;code&gt;MessageFormat&lt;/code&gt; uses will also be
                  placed in the resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
                  This allows you to not only find where an argument is placed in the
                  resulting String, but also which fields it contains in turn.                
                <param>
                    arguments an array of objects to be formatted and substituted.                    
                </param>
                <return>
                    AttributedCharacterIterator describing the formatted value.                    
                </return>
                <exception>
                    NullPointerException if <code>arguments</code> is null.                    
                </exception>
                <exception>
                    IllegalArgumentException if an argument in the
                      <code>arguments</code> array is not of the type
                      expected by the format element(s) that use it.                    
                </exception>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="formatToCharacterIterator" type="AttributedCharacterIterator" line="898">
                <params>
                    <param name="arguments" type="Object"/>
                </params>
                <declaration name="result" type="StringBuffer" line="899"/>
                <declaration name="iterators" type="ArrayList" line="900"/>
                <scope line="902"/>
                <scope line="907"/>
            </method>
            <javadoc line="915">
                Parses the string.
                  &lt;p&gt;Caveats: The parse may fail in a number of circumstances.
                  For example:
                  &lt;ul&gt;
                  &lt;li&gt;If one of the arguments does not occur in the pattern.
                  &lt;li&gt;If the format of an argument loses information, such as
                  with a choice format where a large number formats to &quot;many&quot;.
                  &lt;li&gt;Does not yet handle recursion (where
                  the substituted strings contain {n} references.)
                  &lt;li&gt;Will not always find a match (or the correct match)
                  if some part of the parse is ambiguous.
                  For example, if the pattern &quot;{1},{2}&quot; is used with the
                  string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;.
                  When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.
                  &lt;li&gt;If a single argument is parsed more than once in the string,
                  then the later parse wins.
                  &lt;/ul&gt;
                  When the parse fails, use ParsePosition.getErrorIndex() to find out
                  where in the string the parsing failed.  The returned error
                  index is the starting offset of the sub-patterns that the string
                  is comparing with.  For example, if the parsing string &quot;AAA {0} BBB&quot;
                  is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is
                  0. When an error occurs, the call to this method will return null.
                  If the source is null, return an empty array.                
            </javadoc>
            <method name="parse" type="Object[]" line="942">
                <params>
                    <param name="source" type="String"/>
                    <param name="pos" type="ParsePosition"/>
                </params>
                <comment line="960">
                    match up to format                    
                </comment>
                <comment line="968">
                    leave index as is to signal error                    
                </comment>
                <comment line="971">
                    now use format                    
                </comment>
                <comment line="972">
                    string format                    
                </comment>
                <comment line="973">
                    if at end, use longest possible match                    
                </comment>
                <comment line="974">
                    otherwise uses first match to intervening string                    
                </comment>
                <comment line="975">
                    does NOT recursively try all possibilities                    
                </comment>
                <comment line="988">
                    leave index as is to signal error                    
                </comment>
                <comment line="1002">
                    leave index as is to signal error                    
                </comment>
                <comment line="1004">
                    update                    
                </comment>
                <comment line="1013">
                    leave index as is to signal error                    
                </comment>
                <scope line="943">
                    <declaration name="empty" type="Object[]" line="944"/>
                </scope>
                <declaration name="maximumArgumentNumber" type="int" line="948"/>
                <scope line="949">
                    <scope line="950"/>
                </scope>
                <declaration name="resultArray" type="Object[]" line="954"/>
                <declaration name="patternOffset" type="int" line="956"/>
                <declaration name="sourceOffset" type="int" line="957"/>
                <declaration name="tempStatus" type="ParsePosition" line="958"/>
                <scope line="959">
                    <declaration name="len" type="int" line="961"/>
                    <scope line="963"/>
                    <scope line="966"/>
                    <scope line="972">
                        <declaration name="tempLength" type="int" line="976"/>
                        <declaration name="next" type="int" line="978"/>
                        <scope line="979"/>
                        <scope line="981"/>
                        <scope line="986"/>
                        <scope line="989">
                            <declaration name="strValue" type="String" line="990"/>
                        </scope>
                    </scope>
                    <scope line="996">
                        <scope line="1000"/>
                    </scope>
                </scope>
                <declaration name="len" type="int" line="1007"/>
                <scope line="1009"/>
                <scope line="1011"/>
            </method>
            <javadoc line="1018">
                Parses text from the beginning of the given string to produce an object
                  array.
                  The method may not use the entire text of the given string.
                  &lt;p&gt;
                  See the {@link #parse(String,ParsePosition)} method for more information
                  on message parsing.                
                <param>
                    source A <code>String</code> whose beginning should be parsed.                    
                </param>
                <return>
                    An <code>Object</code> array parsed from the string.                    
                </return>
                <exception>
                    ParseException if the beginning of the specified string
                      cannot be parsed.                    
                </exception>
            </javadoc>
            <method name="parse" type="Object[]" line="1031">
                <params>
                    <param name="source" type="String"/>
                </params>
                <comment line="1034">
                    unchanged, returned object is null                    
                </comment>
                <declaration name="pos" type="ParsePosition" line="1032"/>
                <declaration name="result" type="Object[]" line="1033"/>
            </method>
            <javadoc line="1040">
                Parses text from a string to produce an object array.
                  &lt;p&gt;
                  The method attempts to parse text starting at the index given by
                  &lt;code&gt;pos&lt;/code&gt;.
                  If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
                  to the index after the last character used (parsing does not necessarily
                  use all characters up to the end of the string), and the parsed
                  object array is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
                  indicate the starting point for the next call to this method.
                  If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
                  changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
                  the character where the error occurred, and null is returned.
                  &lt;p&gt;
                  See the {@link #parse(String,ParsePosition)} method for more information
                  on message parsing.                
                <param>
                    source A <code>String</code>, part of which should be parsed.                    
                </param>
                <param>
                    pos A <code>ParsePosition</code> object with index and error
                      index information as described above.                    
                </param>
                <return>
                    An <code>Object</code> array parsed from the string. In case of
                      error, returns null.                    
                </return>
                <exception>
                    NullPointerException if <code>pos</code> is null.                    
                </exception>
            </javadoc>
            <method name="parseObject" type="Object" line="1064">
                <params>
                    <param name="source" type="String"/>
                    <param name="pos" type="ParsePosition"/>
                </params>
            </method>
            <javadoc line="1068">
                Creates and returns a copy of this object.                
                <return>
                    a clone of this instance.                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="1073">
                <comment line="1076">
                    clone arrays. Can&apos;t do with utility because of bug in Cloneable                    
                </comment>
                <comment line="1077">
                    shallow clone                    
                </comment>
                <comment line="1082">
                    for primitives or immutables, shallow clone is enough                    
                </comment>
                <declaration name="other" type="MessageFormat" line="1074"/>
                <scope line="1078"/>
            </method>
            <javadoc line="1089">
                Equality comparison between two message format objects                
            </javadoc>
            <method name="equals" type="boolean" line="1092">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="1093">
                    quick check                    
                </comment>
                <declaration name="other" type="MessageFormat" line="1097"/>
            </method>
            <javadoc line="1107">
                Generates a hash code for the message format object.                
            </javadoc>
            <method name="hashCode" type="int" line="1110">
                <comment line="1111">
                    enough for reasonable distribution                    
                </comment>
            </method>
            <class name="Field" line="1115">
                <extends class="Format.Field"/>
                <comment line="1125">
                    Proclaim serial compatibility with 1.4 FCS                    
                </comment>
                <comment line="1152">
                                        
                </comment>
                <comment line="1153">
                    The constants                    
                </comment>
                <comment line="1154">
                                        
                </comment>
                <javadoc line="1115">
                    Defines constants that are used as attribute keys in the
                      &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
                      from &lt;code&gt;MessageFormat.formatToCharacterIterator&lt;/code&gt;.                    
                    <since>
                        1.4                        
                    </since>
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1125"/>
                <javadoc line="1127">
                    Creates a Field with the specified name.                    
                    <param>
                        name Name of the attribute                        
                    </param>
                </javadoc>
                <method name="Field" type="constructor" line="1132">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                </method>
                <javadoc line="1136">
                    Resolves instances being deserialized to the predefined constants.                    
                    <throws>
                        InvalidObjectException if the constant could not be
                          resolved.                        
                    </throws>
                    <return>
                        resolved MessageFormat.Field constant                        
                    </return>
                </javadoc>
                <method name="readResolve" type="Object" line="1143">
                    <scope line="1144"/>
                </method>
                <declaration name="ARGUMENT" type="Field" line="1155"/>
                <javadoc line="1155">
                    Constant identifying a portion of a message that was generated
                      from an argument passed into &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.
                      The value associated with the key will be an &lt;code&gt;Integer&lt;/code&gt;
                      indicating the index in the &lt;code&gt;arguments&lt;/code&gt; array of the
                      argument from which the text was generated.                    
                </javadoc>
            </class>
            <declaration name="locale" type="Locale" line="1168"/>
            <javadoc line="1168">
                The locale to use for formatting numbers and dates.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="pattern" type="String" line="1174"/>
            <javadoc line="1174">
                The string that the formatted values are to be plugged into.  In other words, this
                  is the pattern supplied on construction with all of the {} expressions taken out.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="INITIAL_FORMATS" type="int" line="1181"/>
            <javadoc line="1181">
                The initially expected number of subformats in the format                
            </javadoc>
            <declaration name="formats" type="Format[]" line="1184"/>
            <javadoc line="1184">
                An array of formatters, which are used to format the arguments.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="offsets" type="int[]" line="1190"/>
            <javadoc line="1190">
                The positions where the results of formatting each argument are to be inserted
                  into the pattern.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="argumentNumbers" type="int[]" line="1197"/>
            <javadoc line="1197">
                The argument numbers corresponding to each formatter.  (The formatters are stored
                  in the order they occur in the pattern, not in the order in which the arguments
                  are specified.)                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="maxOffset" type="int" line="1205"/>
            <javadoc line="1205">
                One less than the number of entries in &lt;code&gt;offsets&lt;/code&gt;.  Can also be thought of
                  as the index of the highest-numbered element in &lt;code&gt;offsets&lt;/code&gt; that is being used.
                  All of these arrays should have the same number of elements being used as &lt;code&gt;offsets&lt;/code&gt;
                  does, and so this variable suffices to tell us how many entries are in all of them.                
                <serial>
                                        
                </serial>
            </javadoc>
            <javadoc line="1214">
                Internal routine used by format. If &lt;code&gt;characterIterators&lt;/code&gt; is
                  non-null, AttributedCharacterIterator will be created from the
                  subformats as necessary. If &lt;code&gt;characterIterators&lt;/code&gt; is null
                  and &lt;code&gt;fp&lt;/code&gt; is non-null and identifies
                  &lt;code&gt;Field.MESSAGE_ARGUMENT&lt;/code&gt;, the location of
                  the first replaced argument will be set in it.                
                <exception>
                    IllegalArgumentException if an argument in the
                      <code>arguments</code> array is not of the type
                      expected by the format element(s) that use it.                    
                </exception>
            </javadoc>
            <method name="subformat" type="StringBuffer" line="1227">
                <params>
                    <param name="arguments" type="Object[]"/>
                    <param name="result" type="StringBuffer"/>
                    <param name="fp" type="FieldPosition"/>
                    <param name="characterIterators" type="List"/>
                </params>
                <comment line="1228">
                    note: this implementation assumes a fast substring &amp; index.                    
                </comment>
                <comment line="1229">
                    if this is not true, would be better to append chars one by one.                    
                </comment>
                <comment line="1240">
                    int argRecursion = ((recursionProtection &gt;&gt; (argumentNumber*2)) &amp; 0x3);                    
                </comment>
                <comment line="1241">
                    if (argRecursion == 3){                    
                </comment>
                <comment line="1242">
                    prevent loop!!!                    
                </comment>
                <comment line="1261">
                    format number if can                    
                </comment>
                <comment line="1264">
                    format a Date if can                    
                </comment>
                <comment line="1266">
                    fix                    
                </comment>
                <comment line="1275">
                    At this point we are in two states, either subFormatter                    
                </comment>
                <comment line="1276">
                    is non-null indicating we should format obj using it,                    
                </comment>
                <comment line="1277">
                    or arg is non-null and we should use it as the value.                    
                </comment>
                <comment line="1280">
                    If characterIterators is non-null, it indicates we need                    
                </comment>
                <comment line="1281">
                    to get the CharacterIterator from the child formatter.                    
                </comment>
                <declaration name="lastOffset" type="int" line="1230"/>
                <declaration name="last" type="int" line="1231"/>
                <scope line="1232">
                    <declaration name="argumentNumber" type="int" line="1235"/>
                    <scope line="1236"/>
                    <scope line="1241"/>
                    <scope line="1244">
                        <declaration name="obj" type="Object" line="1245"/>
                        <declaration name="arg" type="String" line="1246"/>
                        <declaration name="subFormatter" type="Format" line="1247"/>
                        <scope line="1248"/>
                        <scope line="1250">
                            <scope line="1252">
                                <scope line="1254"/>
                            </scope>
                        </scope>
                        <scope line="1260"/>
                        <scope line="1263"/>
                        <scope line="1267"/>
                        <scope line="1270"/>
                        <scope line="1279">
                            <scope line="1282"/>
                            <scope line="1288">
                                <declaration name="subIterator" type="AttributedCharacterIterator" line="1289"/>
                                <scope line="1293"/>
                            </scope>
                            <scope line="1302"/>
                        </scope>
                        <scope line="1311">
                            <scope line="1312"/>
                            <scope line="1318"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1327"/>
            </method>
            <javadoc line="1334">
                Convenience method to append all the characters in
                  &lt;code&gt;iterator&lt;/code&gt; to the StringBuffer &lt;code&gt;result&lt;/code&gt;.                
            </javadoc>
            <method name="append" type="void" line="1338">
                <params>
                    <param name="result" type="StringBuffer"/>
                    <param name="iterator" type="CharacterIterator"/>
                </params>
                <scope line="1339">
                    <declaration name="aChar" type="char" line="1340"/>
                    <scope line="1343"/>
                </scope>
            </method>
            <declaration name="SEG_RAW" type="int" line="1350"/>
            <declaration name="SEG_INDEX" type="int" line="1351"/>
            <declaration name="SEG_TYPE" type="int" line="1352"/>
            <declaration name="SEG_MODIFIER" type="int" line="1353"/>
            <declaration name="TYPE_NULL" type="int" line="1356"/>
            <declaration name="TYPE_NUMBER" type="int" line="1357"/>
            <declaration name="TYPE_DATE" type="int" line="1358"/>
            <declaration name="TYPE_TIME" type="int" line="1359"/>
            <declaration name="TYPE_CHOICE" type="int" line="1360"/>
            <declaration name="TYPE_KEYWORDS" type="String[]" line="1362"/>
            <declaration name="MODIFIER_DEFAULT" type="int" line="1371"/>
            <declaration name="MODIFIER_CURRENCY" type="int" line="1372"/>
            <declaration name="MODIFIER_PERCENT" type="int" line="1373"/>
            <declaration name="MODIFIER_INTEGER" type="int" line="1374"/>
            <declaration name="NUMBER_MODIFIER_KEYWORDS" type="String[]" line="1376"/>
            <declaration name="MODIFIER_SHORT" type="int" line="1384"/>
            <declaration name="MODIFIER_MEDIUM" type="int" line="1385"/>
            <declaration name="MODIFIER_LONG" type="int" line="1386"/>
            <declaration name="MODIFIER_FULL" type="int" line="1387"/>
            <declaration name="DATE_TIME_MODIFIER_KEYWORDS" type="String[]" line="1389"/>
            <declaration name="DATE_TIME_MODIFIERS" type="int[]" line="1398"/>
            <method name="makeFormat" type="void" line="1408">
                <params>
                    <param name="position" type="int"/>
                    <param name="offsetNumber" type="int"/>
                    <param name="textSegments" type="StringBuilder[]"/>
                </params>
                <comment line="1415">
                    get the argument number                    
                </comment>
                <comment line="1418">
                    always unlocalized!                    
                </comment>
                <comment line="1428">
                    resize format information arrays if necessary                    
                </comment>
                <comment line="1446">
                    now get the format                    
                </comment>
                <comment line="1452">
                    Type &quot;&quot; is allowed. e.g., &quot;{0,}&quot;, &quot;{0,,}&quot;, and &quot;{0,,#}&quot;                    
                </comment>
                <comment line="1453">
                    are treated as &quot;{0}&quot;.                    
                </comment>
                <comment line="1470">
                    DecimalFormat pattern                    
                </comment>
                <comment line="1494">
                    SimpleDateFormat pattern                    
                </comment>
                <comment line="1506">
                    ChoiceFormat pattern                    
                </comment>
                <declaration name="segments" type="String[]" line="1409"/>
                <scope line="1410">
                    <declaration name="oneseg" type="StringBuilder" line="1411"/>
                </scope>
                <declaration name="argumentNumber" type="int" line="1416"/>
                <scope line="1417"/>
                <scope line="1419"/>
                <scope line="1423"/>
                <scope line="1429">
                    <declaration name="newLength" type="int" line="1430"/>
                    <declaration name="newFormats" type="Format[]" line="1431"/>
                    <declaration name="newOffsets" type="int[]" line="1432"/>
                    <declaration name="newArgumentNumbers" type="int[]" line="1433"/>
                </scope>
                <declaration name="oldMaxOffset" type="int" line="1441"/>
                <declaration name="newFormat" type="Format" line="1447"/>
                <scope line="1448">
                    <declaration name="type" type="int" line="1449"/>
                    <scope line="1471"/>
                    <scope line="1474"/>
                    <declaration name="mod" type="int" line="1484"/>
                    <scope line="1485">
                        <scope line="1486"/>
                        <scope line="1489"/>
                    </scope>
                    <scope line="1493">
                        <scope line="1495"/>
                        <scope line="1497"/>
                    </scope>
                    <scope line="1505"/>
                    <scope line="1508"/>
                </scope>
            </method>
            <method name="findKeyword" type="int" line="1524">
                <params>
                    <param name="s" type="String"/>
                    <param name="list" type="String[]"/>
                </params>
                <comment line="1530">
                    Try trimmed lowercase.                    
                </comment>
                <scope line="1525"/>
                <declaration name="ls" type="String" line="1531"/>
                <scope line="1532">
                    <scope line="1533"/>
                </scope>
            </method>
            <method name="copyAndFixQuotes" type="void" line="1542">
                <params>
                    <param name="source" type="String"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                    <param name="target" type="StringBuilder"/>
                </params>
                <declaration name="quoted" type="boolean" line="1543"/>
                <scope line="1545">
                    <declaration name="ch" type="char" line="1546"/>
                    <scope line="1547">
                        <scope line="1548"/>
                    </scope>
                    <scope line="1553"/>
                    <scope line="1555">
                        <scope line="1556"/>
                    </scope>
                </scope>
                <scope line="1563"/>
            </method>
            <javadoc line="1568">
                After reading an object from the input stream, do a simple verification
                  to maintain class invariants.                
                <throws>
                    InvalidObjectException if the objects read from the stream is invalid.                    
                </throws>
            </javadoc>
            <method name="readObject" type="void" line="1573">
                <params>
                    <param name="in" type="ObjectInputStream"/>
                </params>
                <declaration name="isValid" type="boolean" line="1575"/>
                <scope line="1579">
                    <declaration name="lastOffset" type="int" line="1580"/>
                    <scope line="1581">
                        <scope line="1582"/>
                        <scope line="1585"/>
                    </scope>
                </scope>
                <scope line="1590"/>
            </method>
        </class>
    </source>