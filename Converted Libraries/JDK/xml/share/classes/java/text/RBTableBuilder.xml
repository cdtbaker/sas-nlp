<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.util.Vector"/>
        <import package="sun.text.UCompactIntArray"/>
        <import package="sun.text.IntHashtable"/>
        <import package="sun.text.ComposedCharIter"/>
        <import package="sun.text.CollatorUtilities"/>
        <import package="sun.text.normalizer.NormalizerImpl"/>
        <class name="RBTableBuilder" line="48">
            <comment line="584">
                ==============================================================
                 constants
                 ==============================================================                
            </comment>
            <comment line="587">
                need look up in .commit()                
            </comment>
            <comment line="596">
                ==============================================================
                 instance variables
                 ==============================================================                
            </comment>
            <comment line="600">
                variables used by the build process                
            </comment>
            <comment line="607">
                &quot;shadow&quot; copies of the instance variables in RBCollationTables
                 (the values in these variables are copied back into RBCollationTables
                 at the end of the build process)                
            </comment>
            <javadoc line="48">
                This class contains all the code to parse a RuleBasedCollator pattern
                  and build a RBCollationTables object from it.  A particular instance
                  of tis class exists only during the actual build process-- once an
                  RBCollationTables object has been built, the RBTableBuilder object
                  goes away.  This object carries all of the state which is only needed
                  during the build process, plus a &quot;shadow&quot; copy of all of the state
                  that will go into the tables object itself.  This object communicates
                  with RBCollationTables through a separate class, RBCollationTables.BuildAPI,
                  this is an inner class of RBCollationTables and provides a separate
                  private API for communication with RBTableBuilder.
                  This class isn&apos;t just an inner class of RBCollationTables itself because
                  of its large size.  For source-code readability, it seemed better for the
                  builder to have its own source file.                
            </javadoc>
            <method name="RBTableBuilder" type="constructor" line="65">
                <params>
                    <param name="tables" type="RBCollationTables.BuildAPI"/>
                </params>
            </method>
            <javadoc line="69">
                Create a table-based collation object with the given rules.
                  This is the main function that actually builds the tables and
                  stores them back in the RBCollationTables object.  It is called
                  ONLY by the RBCollationTables constructor.                
                <see>
                    java.util.RuleBasedCollator#RuleBasedCollator                    
                </see>
                <exception>
                    ParseException If the rules format is incorrect.                    
                </exception>
            </javadoc>
            <method name="build" type="void" line="79">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="decmp" type="int"/>
                </params>
                <comment line="88">
                    This array maps Unicode characters to their collation ordering                    
                </comment>
                <comment line="90">
                    Normalize the build rules.  Find occurances of all decomposed characters
                     and normalize the rules before feeding into the builder.  By &quot;normalize&quot;,
                     we mean that all precomposed Unicode characters must be converted into
                     a base character and one or more combining characters (such as accents).
                     When there are multiple combining characters attached to a base character,
                     the combining characters must be in their canonical order
                    
                     sherman/Note:
                    (1)decmp will be NO_DECOMPOSITION only in ko locale to prevent decompose
                    hangual syllables to jamos, so we can actually just call decompose with
                    normalizer&apos;s IGNORE_HANGUL option turned on
                    
                    (2)just call the &quot;special version&quot; in NormalizerImpl directly
                    pattern = Normalizer.decompose(pattern, false, Normalizer.IGNORE_HANGUL, true);
                    
                    Normalizer.Mode mode = CollatorUtilities.toNormalizerMode(decmp);
                    pattern = Normalizer.normalize(pattern, mode, 0, true);                    
                </comment>
                <comment line="110">
                    Build the merged collation entries
                     Since rules can be specified in any order in the string
                     (e.g. &quot;c , C &lt; d , D &lt; e , E .... C &lt; CH&quot;)
                     this splits all of the rules in the string out into separate
                     objects and then sorts them.  In the above example, it merges the
                     &quot;C &lt; CH&quot; rule in just before the &quot;C &lt; D&quot; rule.                    
                </comment>
                <comment line="122">
                    Now walk though each entry and add it to my own tables                    
                </comment>
                <comment line="163">
                    System.out.println(&quot;mappingSize=&quot; + mapping.getKSize());
                    for (int j = 0; j &lt; 0xffff; j++) {
                    int value = mapping.elementAt(j);
                    if (value != RBCollationTables.UNMAPPED)
                    System.out.println(&quot;index=&quot; + Integer.toString(j, 16)
                    + &quot;, value=&quot; + Integer.toString(value, 16));
                    }                    
                </comment>
                <declaration name="isSource" type="boolean" line="80"/>
                <declaration name="i" type="int" line="81"/>
                <declaration name="expChars" type="String" line="82"/>
                <declaration name="groupChars" type="String" line="83"/>
                <declaration name="order" type="int" line="119"/>
                <scope line="123">
                    <declaration name="entry" type="PatternEntry" line="124"/>
                    <scope line="125">
                        <scope line="127"/>
                        <scope line="143"/>
                        <scope line="145">
                            <declaration name="ch" type="char" line="146"/>
                            <scope line="147"/>
                            <scope line="149"/>
                        </scope>
                        <scope line="152">
                            <declaration name="ch" type="char" line="153"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="175">
                Add expanding entries for pre-composed unicode characters so that this
                  collator can be used reasonably well with decomposition turned off.                
            </javadoc>
            <method name="addComposedChars" type="void" line="178">
                <comment line="180">
                    Iterate through all of the pre-composed characters in Unicode                    
                </comment>
                <comment line="185">
                    We don&apos;t already have an ordering for this pre-composed character.
                    
                     First, see if the decomposed string is already in our
                     tables as a single contracting-string ordering.
                     If so, just map the precomposed character to that order.
                    
                     TODO: What we should really be doing here is trying to find the
                     longest initial substring of the decomposition that is present
                     in the tables as a contracting character sequence, and find its
                     ordering.  Then do this recursively with the remaining chars
                     so that we build a list of orderings, and add that list to
                     the expansion table.
                     That would be more correct but also significantly slower, so
                     I&apos;m not totally sure it&apos;s worth doing.                    
                </comment>
                <comment line="203">
                    sherman/Note: if this is 1 character decomposed string, the
                    only thing need to do is to check if this decomposed character
                    has an entry in our order table, this order is not necessary
                    to be a contraction order, if it does have one, add an entry
                    for the precomposed character by using the same order, the
                    previous impl unnecessarily adds a single character expansion
                    entry.                    
                </comment>
                <comment line="230">
                    We don&apos;t have a contracting ordering for the entire string
                     that results from the decomposition, but if we have orders
                     for each individual character, we can add an expanding
                     table entry for the pre-composed character                    
                </comment>
                <declaration name="iter" type="ComposedCharIter" line="180"/>
                <declaration name="c" type="int" line="181"/>
                <scope line="182">
                    <scope line="183">
                        <declaration name="s" type="String" line="200"/>
                        <scope line="209">
                            <declaration name="order" type="int" line="210"/>
                            <scope line="211"/>
                        </scope>
                        <scope line="215">
                            <declaration name="ch0" type="char" line="216"/>
                            <scope line="217">
                                <declaration name="order" type="int" line="218"/>
                                <scope line="219"/>
                            </scope>
                        </scope>
                        <declaration name="contractOrder" type="int" line="225"/>
                        <scope line="226"/>
                        <scope line="228">
                            <declaration name="allThere" type="boolean" line="235"/>
                            <scope line="236">
                                <scope line="237"/>
                            </scope>
                            <scope line="242"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="250">
                Look up for unmapped values in the expanded character table.
                  When the expanding character tables are built by addExpandOrder,
                  it doesn&apos;t know what the final ordering of each character
                  in the expansion will be.  Instead, it just puts the raw character
                  code into the table, adding CHARINDEX as a flag.  Now that we&apos;ve
                  finished building the mapping table, we can go back and look up
                  that character to see what its real collation order is and
                  stick that into the expansion table.  That lets us avoid doing
                  a two-stage lookup later.                
            </javadoc>
            <method name="commit" type="void" line="263">
                <comment line="271">
                    found a expanding character that isn&apos;t filled in yet                    
                </comment>
                <comment line="274">
                    Get the real values for the non-filled entry                    
                </comment>
                <comment line="278">
                    The real value is still unmapped, maybe it&apos;s ignorable                    
                </comment>
                <comment line="281">
                    just fill in the value                    
                </comment>
                <scope line="264">
                    <scope line="265">
                        <declaration name="valueList" type="int[]" line="266"/>
                        <scope line="267">
                            <declaration name="order" type="int" line="268"/>
                            <scope line="269">
                                <declaration name="ch" type="int" line="271"/>
                                <declaration name="realValue" type="int" line="274"/>
                                <scope line="276"/>
                                <scope line="279"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="288">
                Increment of the last order based on the comparison level.                
            </javadoc>
            <method name="increment" type="int" line="292">
                <params>
                    <param name="aStrength" type="int"/>
                    <param name="lastValue" type="int"/>
                </params>
                <comment line="297">
                    increment priamry order  and mask off secondary and tertiary difference                    
                </comment>
                <comment line="303">
                    increment secondary order and mask off tertiary difference                    
                </comment>
                <comment line="306">
                    record max # of ignorable chars with secondary difference                    
                </comment>
                <comment line="311">
                    increment tertiary order                    
                </comment>
                <comment line="313">
                    record max # of ignorable chars with tertiary difference                    
                </comment>
            </method>
            <javadoc line="320">
                Adds a character and its designated order into the collation table.                
            </javadoc>
            <method name="addOrder" type="void" line="324">
                <params>
                    <param name="ch" type="int"/>
                    <param name="anOrder" type="int"/>
                </params>
                <comment line="326">
                    See if the char already has an order in the mapping table                    
                </comment>
                <comment line="330">
                    There&apos;s already an entry for this character that points to a contracting
                     character table.  Instead of adding the character directly to the mapping
                     table, we must add it to the contract table instead.                    
                </comment>
                <comment line="341">
                    add the entry to the mapping table,
                     the same later entry replaces the previous one                    
                </comment>
                <declaration name="order" type="int" line="326"/>
                <scope line="328">
                    <declaration name="length" type="int" line="332"/>
                    <scope line="333"/>
                    <scope line="335"/>
                </scope>
                <scope line="339"/>
            </method>
            <method name="addContractOrder" type="void" line="346">
                <params>
                    <param name="groupChars" type="String"/>
                    <param name="anOrder" type="int"/>
                </params>
            </method>
            <javadoc line="350">
                Adds the contracting string into the collation table.                
            </javadoc>
            <method name="addContractOrder" type="void" line="355">
                <params>
                    <param name="groupChars" type="String"/>
                    <param name="anOrder" type="int"/>
                    <param name="fwd" type="boolean"/>
                </params>
                <comment line="361">
                    initial character                    
                </comment>
                <comment line="363">
                    char ch0 = groupChars.charAt(0);
                    int ch = Character.isHighSurrogate(ch0)?
                    Character.toCodePoint(ch0, groupChars.charAt(1)):ch0;                    
                </comment>
                <comment line="368">
                    See if the initial character of the string already has a contract table.                    
                </comment>
                <comment line="373">
                    We need to create a new table of contract entries for this base char                    
                </comment>
                <comment line="378">
                    Add the initial character&apos;s current ordering first. then
                     update its mapping to point to this contract table                    
                </comment>
                <comment line="384">
                    Now add (or replace) this string in the table                    
                </comment>
                <comment line="392">
                    NOTE:  This little bit of logic is here to speed CollationElementIterator
                     .nextContractChar().  This code ensures that the longest sequence in
                     this list is always the _last_ one in the list.  This keeps
                     nextContractChar() from having to search the entire list for the longest
                     sequence.                    
                </comment>
                <comment line="405">
                    If this was a forward mapping for a contracting string, also add a
                     reverse mapping for it, so that CollationElementIterator.previous
                     can work right                    
                </comment>
                <scope line="356"/>
                <declaration name="ch" type="int" line="361"/>
                <declaration name="entry" type="int" line="368"/>
                <declaration name="entryTable" type="Vector" line="369"/>
                <scope line="371">
                    <declaration name="tableIndex" type="int" line="373"/>
                </scope>
                <declaration name="index" type="int" line="384"/>
                <scope line="385">
                    <declaration name="pair" type="EntryPair" line="386"/>
                </scope>
                <scope line="388">
                    <declaration name="pair" type="EntryPair" line="389"/>
                    <scope line="396"/>
                    <scope line="398"/>
                </scope>
                <scope line="407"/>
            </method>
            <javadoc line="414">
                If the given string has been specified as a contracting string
                  in this collation table, return its ordering.
                  Otherwise return UNMAPPED.                
            </javadoc>
            <method name="getContractOrder" type="int" line="420">
                <params>
                    <param name="groupChars" type="String"/>
                </params>
                <comment line="425">
                    char ch0 = groupChars.charAt(0);
                    int ch = Character.isHighSurrogate(ch0)?
                    Character.toCodePoint(ch0, groupChars.charAt(1)):ch0;                    
                </comment>
                <declaration name="result" type="int" line="421"/>
                <scope line="422">
                    <declaration name="ch" type="int" line="423"/>
                    <declaration name="entryTable" type="Vector" line="429"/>
                    <scope line="430">
                        <declaration name="index" type="int" line="431"/>
                        <scope line="432">
                            <declaration name="pair" type="EntryPair" line="433"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getCharOrder" type="int" line="441">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <declaration name="order" type="int" line="442"/>
                <scope line="444">
                    <declaration name="groupList" type="Vector" line="445"/>
                    <declaration name="pair" type="EntryPair" line="446"/>
                </scope>
            </method>
            <javadoc line="452">
                Get the entry of hash table of the contracting string in the collation
                  table.                
                <param>
                    ch the starting character of the contracting string                    
                </param>
            </javadoc>
            <method name="getContractValues" type="Vector" line="458">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <declaration name="index" type="int" line="459"/>
            </method>
            <method name="getContractValuesImpl" type="Vector" line="464">
                <params>
                    <param name="index" type="int"/>
                </params>
                <comment line="470">
                    not found                    
                </comment>
                <scope line="466"/>
                <scope line="470"/>
            </method>
            <javadoc line="475">
                Adds the expanding string into the collation table.                
            </javadoc>
            <method name="addExpandOrder" type="void" line="481">
                <params>
                    <param name="contractChars" type="String"/>
                    <param name="expandChars" type="String"/>
                    <param name="anOrder" type="int"/>
                </params>
                <comment line="483">
                    Create an expansion table entry                    
                </comment>
                <comment line="486">
                    And add its index into the main mapping table                    
                </comment>
                <comment line="492">
                    only add into table when it is a legal surrogate                    
                </comment>
                <declaration name="tableIndex" type="int" line="483"/>
                <scope line="486">
                    <declaration name="ch" type="char" line="487"/>
                    <scope line="488">
                        <declaration name="ch2" type="char" line="489"/>
                        <scope line="490"/>
                    </scope>
                    <scope line="494"/>
                </scope>
                <scope line="497"/>
            </method>
            <method name="addExpandOrder" type="void" line="504">
                <params>
                    <param name="ch" type="int"/>
                    <param name="expandChars" type="String"/>
                    <param name="anOrder" type="int"/>
                </params>
                <declaration name="tableIndex" type="int" line="505"/>
            </method>
            <javadoc line="509">
                Create a new entry in the expansion table that contains the orderings
                  for the given characers.  If anOrder is valid, it is added to the
                  beginning of the expanded list of orders.                
            </javadoc>
            <method name="addExpansion" type="int" line="514">
                <params>
                    <param name="anOrder" type="int"/>
                    <param name="expandChars" type="String"/>
                </params>
                <comment line="520">
                    If anOrder is valid, we want to add it at the beginning of the list                    
                </comment>
                <comment line="536">
                    ether we are missing the low surrogate or the next char
                    is not a legal low surrogate, so stop loop                    
                </comment>
                <comment line="551">
                    can&apos;t find it in the table, will be filled in by commit().                    
                </comment>
                <comment line="556">
                    we had at least one supplementary character, the size of valueList
                    is bigger than it really needs...                    
                </comment>
                <comment line="564">
                    Add the expanding char list into the expansion table.                    
                </comment>
                <scope line="515"/>
                <declaration name="offset" type="int" line="520"/>
                <declaration name="valueList" type="int[]" line="522"/>
                <scope line="523"/>
                <declaration name="j" type="int" line="527"/>
                <scope line="528">
                    <declaration name="ch0" type="char" line="529"/>
                    <declaration name="ch1" type="char" line="530"/>
                    <declaration name="ch" type="int" line="531"/>
                    <scope line="532">
                        <scope line="534"/>
                    </scope>
                    <scope line="541"/>
                    <declaration name="mapValue" type="int" line="545"/>
                    <scope line="547"/>
                    <scope line="549"/>
                </scope>
                <scope line="554">
                    <declaration name="tmpBuf" type="int[]" line="557"/>
                    <scope line="558"/>
                </scope>
                <declaration name="tableIndex" type="int" line="564"/>
            </method>
            <method name="addContractFlags" type="void" line="570">
                <params>
                    <param name="chars" type="String"/>
                </params>
                <declaration name="c0" type="char" line="571"/>
                <declaration name="c" type="int" line="572"/>
                <declaration name="len" type="int" line="573"/>
                <scope line="574"/>
            </method>
            <declaration name="CHARINDEX" type="int" line="586"/>
            <declaration name="IGNORABLEMASK" type="int" line="588"/>
            <declaration name="PRIMARYORDERINCREMENT" type="int" line="589"/>
            <declaration name="SECONDARYORDERINCREMENT" type="int" line="590"/>
            <declaration name="TERTIARYORDERINCREMENT" type="int" line="591"/>
            <declaration name="INITIALTABLESIZE" type="int" line="592"/>
            <declaration name="MAXKEYSIZE" type="int" line="593"/>
            <declaration name="tables" type="RBCollationTables.BuildAPI" line="600"/>
            <declaration name="mPattern" type="MergeCollation" line="601"/>
            <declaration name="isOverIgnore" type="boolean" line="602"/>
            <declaration name="keyBuf" type="char[]" line="603"/>
            <declaration name="contractFlags" type="IntHashtable" line="604"/>
            <declaration name="frenchSec" type="boolean" line="609"/>
            <declaration name="seAsianSwapping" type="boolean" line="610"/>
            <declaration name="mapping" type="UCompactIntArray" line="612"/>
            <declaration name="contractTable" type="Vector" line="613"/>
            <declaration name="expandTable" type="Vector" line="614"/>
            <declaration name="maxSecOrder" type="short" line="616"/>
            <declaration name="maxTerOrder" type="short" line="617"/>
        </class>
    </source>