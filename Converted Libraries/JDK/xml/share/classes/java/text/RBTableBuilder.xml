<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.text">
        <import package="java.util.Vector"/>
        <import package="sun.text.UCompactIntArray"/>
        <import package="sun.text.IntHashtable"/>
        <import package="sun.text.ComposedCharIter"/>
        <import package="sun.text.CollatorUtilities"/>
        <import package="sun.text.normalizer.NormalizerImpl"/>
        <class name="RBTableBuilder" line="48">
            <comment line="584">
                ==============================================================                
            </comment>
            <comment line="585">
                constants                
            </comment>
            <comment line="586">
                ==============================================================                
            </comment>
            <comment line="587">
                need look up in .commit()                
            </comment>
            <comment line="596">
                ==============================================================                
            </comment>
            <comment line="597">
                instance variables                
            </comment>
            <comment line="598">
                ==============================================================                
            </comment>
            <comment line="600">
                variables used by the build process                
            </comment>
            <comment line="607">
                &quot;shadow&quot; copies of the instance variables in RBCollationTables                
            </comment>
            <comment line="608">
                (the values in these variables are copied back into RBCollationTables                
            </comment>
            <comment line="609">
                at the end of the build process)                
            </comment>
            <javadoc line="48">
                This class contains all the code to parse a RuleBasedCollator pattern
                  and build a RBCollationTables object from it.  A particular instance
                  of tis class exists only during the actual build process-- once an
                  RBCollationTables object has been built, the RBTableBuilder object
                  goes away.  This object carries all of the state which is only needed
                  during the build process, plus a &quot;shadow&quot; copy of all of the state
                  that will go into the tables object itself.  This object communicates
                  with RBCollationTables through a separate class, RBCollationTables.BuildAPI,
                  this is an inner class of RBCollationTables and provides a separate
                  private API for communication with RBTableBuilder.
                  This class isn&apos;t just an inner class of RBCollationTables itself because
                  of its large size.  For source-code readability, it seemed better for the
                  builder to have its own source file.                
            </javadoc>
            <method name="RBTableBuilder" type="constructor" line="65">
                <params>
                    <param name="tables" type="RBCollationTables.BuildAPI"/>
                </params>
            </method>
            <javadoc line="69">
                Create a table-based collation object with the given rules.
                  This is the main function that actually builds the tables and
                  stores them back in the RBCollationTables object.  It is called
                  ONLY by the RBCollationTables constructor.                
                <see>
                    java.util.RuleBasedCollator#RuleBasedCollator                    
                </see>
                <exception>
                    ParseException If the rules format is incorrect.                    
                </exception>
            </javadoc>
            <method name="build" type="void" line="79">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="decmp" type="int"/>
                </params>
                <comment line="87">
                    This array maps Unicode characters to their collation ordering                    
                </comment>
                <comment line="89">
                    Normalize the build rules.  Find occurances of all decomposed characters                    
                </comment>
                <comment line="90">
                    and normalize the rules before feeding into the builder.  By &quot;normalize&quot;,                    
                </comment>
                <comment line="91">
                    we mean that all precomposed Unicode characters must be converted into                    
                </comment>
                <comment line="92">
                    a base character and one or more combining characters (such as accents).                    
                </comment>
                <comment line="93">
                    When there are multiple combining characters attached to a base character,                    
                </comment>
                <comment line="94">
                    the combining characters must be in their canonical order                    
                </comment>
                <comment line="95">
                                        
                </comment>
                <comment line="96">
                    sherman/Note:                    
                </comment>
                <comment line="97">
                    (1)decmp will be NO_DECOMPOSITION only in ko locale to prevent decompose                    
                </comment>
                <comment line="98">
                    hangual syllables to jamos, so we can actually just call decompose with                    
                </comment>
                <comment line="99">
                    normalizer&apos;s IGNORE_HANGUL option turned on                    
                </comment>
                <comment line="100">
                                        
                </comment>
                <comment line="101">
                    (2)just call the &quot;special version&quot; in NormalizerImpl directly                    
                </comment>
                <comment line="102">
                    pattern = Normalizer.decompose(pattern, false, Normalizer.IGNORE_HANGUL, true);                    
                </comment>
                <comment line="103">
                                        
                </comment>
                <comment line="104">
                    Normalizer.Mode mode = CollatorUtilities.toNormalizerMode(decmp);                    
                </comment>
                <comment line="105">
                    pattern = Normalizer.normalize(pattern, mode, 0, true);                    
                </comment>
                <comment line="109">
                    Build the merged collation entries                    
                </comment>
                <comment line="110">
                    Since rules can be specified in any order in the string                    
                </comment>
                <comment line="111">
                    (e.g. &quot;c , C &lt; d , D &lt; e , E .... C &lt; CH&quot;)                    
                </comment>
                <comment line="112">
                    this splits all of the rules in the string out into separate                    
                </comment>
                <comment line="113">
                    objects and then sorts them.  In the above example, it merges the                    
                </comment>
                <comment line="114">
                    &quot;C &lt; CH&quot; rule in just before the &quot;C &lt; D&quot; rule.                    
                </comment>
                <comment line="115">
                                        
                </comment>
                <comment line="121">
                    Now walk though each entry and add it to my own tables                    
                </comment>
                <comment line="162">
                    System.out.println(&quot;mappingSize=&quot; + mapping.getKSize());
                    for (int j = 0; j &lt; 0xffff; j++) {
                    int value = mapping.elementAt(j);
                    if (value != RBCollationTables.UNMAPPED)
                    System.out.println(&quot;index=&quot; + Integer.toString(j, 16)
                    + &quot;, value=&quot; + Integer.toString(value, 16));
                    }                    
                </comment>
                <declaration name="isSource" type="boolean" line="80"/>
                <declaration name="i" type="int" line="81"/>
                <declaration name="expChars" type="String" line="82"/>
                <declaration name="groupChars" type="String" line="83"/>
                <declaration name="order" type="int" line="119"/>
                <scope line="123">
                    <declaration name="entry" type="PatternEntry" line="124"/>
                    <scope line="125">
                        <scope line="127"/>
                        <scope line="143"/>
                        <scope line="145">
                            <declaration name="ch" type="char" line="146"/>
                            <scope line="147"/>
                            <scope line="149"/>
                        </scope>
                        <scope line="152">
                            <declaration name="ch" type="char" line="153"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="175">
                Add expanding entries for pre-composed unicode characters so that this
                  collator can be used reasonably well with decomposition turned off.                
            </javadoc>
            <method name="addComposedChars" type="void" line="178">
                <comment line="179">
                    Iterate through all of the pre-composed characters in Unicode                    
                </comment>
                <comment line="184">
                                        
                </comment>
                <comment line="185">
                    We don&apos;t already have an ordering for this pre-composed character.                    
                </comment>
                <comment line="186">
                                        
                </comment>
                <comment line="187">
                    First, see if the decomposed string is already in our                    
                </comment>
                <comment line="188">
                    tables as a single contracting-string ordering.                    
                </comment>
                <comment line="189">
                    If so, just map the precomposed character to that order.                    
                </comment>
                <comment line="190">
                                        
                </comment>
                <comment line="191">
                    TODO: What we should really be doing here is trying to find the                    
                </comment>
                <comment line="192">
                    longest initial substring of the decomposition that is present                    
                </comment>
                <comment line="193">
                    in the tables as a contracting character sequence, and find its                    
                </comment>
                <comment line="194">
                    ordering.  Then do this recursively with the remaining chars                    
                </comment>
                <comment line="195">
                    so that we build a list of orderings, and add that list to                    
                </comment>
                <comment line="196">
                    the expansion table.                    
                </comment>
                <comment line="197">
                    That would be more correct but also significantly slower, so                    
                </comment>
                <comment line="198">
                    I&apos;m not totally sure it&apos;s worth doing.                    
                </comment>
                <comment line="199">
                                        
                </comment>
                <comment line="202">
                    sherman/Note: if this is 1 character decomposed string, the                    
                </comment>
                <comment line="203">
                    only thing need to do is to check if this decomposed character                    
                </comment>
                <comment line="204">
                    has an entry in our order table, this order is not necessary                    
                </comment>
                <comment line="205">
                    to be a contraction order, if it does have one, add an entry                    
                </comment>
                <comment line="206">
                    for the precomposed character by using the same order, the                    
                </comment>
                <comment line="207">
                    previous impl unnecessarily adds a single character expansion                    
                </comment>
                <comment line="208">
                    entry.                    
                </comment>
                <comment line="229">
                                        
                </comment>
                <comment line="230">
                    We don&apos;t have a contracting ordering for the entire string                    
                </comment>
                <comment line="231">
                    that results from the decomposition, but if we have orders                    
                </comment>
                <comment line="232">
                    for each individual character, we can add an expanding                    
                </comment>
                <comment line="233">
                    table entry for the pre-composed character                    
                </comment>
                <comment line="234">
                                        
                </comment>
                <declaration name="iter" type="ComposedCharIter" line="180"/>
                <declaration name="c" type="int" line="181"/>
                <scope line="182">
                    <scope line="183">
                        <declaration name="s" type="String" line="200"/>
                        <scope line="209">
                            <declaration name="order" type="int" line="210"/>
                            <scope line="211"/>
                        </scope>
                        <scope line="215">
                            <declaration name="ch0" type="char" line="216"/>
                            <scope line="217">
                                <declaration name="order" type="int" line="218"/>
                                <scope line="219"/>
                            </scope>
                        </scope>
                        <declaration name="contractOrder" type="int" line="225"/>
                        <scope line="226"/>
                        <scope line="228">
                            <declaration name="allThere" type="boolean" line="235"/>
                            <scope line="236">
                                <scope line="237"/>
                            </scope>
                            <scope line="242"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="250">
                Look up for unmapped values in the expanded character table.
                  When the expanding character tables are built by addExpandOrder,
                  it doesn&apos;t know what the final ordering of each character
                  in the expansion will be.  Instead, it just puts the raw character
                  code into the table, adding CHARINDEX as a flag.  Now that we&apos;ve
                  finished building the mapping table, we can go back and look up
                  that character to see what its real collation order is and
                  stick that into the expansion table.  That lets us avoid doing
                  a two-stage lookup later.                
            </javadoc>
            <method name="commit" type="void" line="263">
                <comment line="270">
                    found a expanding character that isn&apos;t filled in yet                    
                </comment>
                <comment line="273">
                    Get the real values for the non-filled entry                    
                </comment>
                <comment line="277">
                    The real value is still unmapped, maybe it&apos;s ignorable                    
                </comment>
                <comment line="280">
                    just fill in the value                    
                </comment>
                <scope line="264">
                    <scope line="265">
                        <declaration name="valueList" type="int[]" line="266"/>
                        <scope line="267">
                            <declaration name="order" type="int" line="268"/>
                            <scope line="269">
                                <declaration name="ch" type="int" line="271"/>
                                <declaration name="realValue" type="int" line="274"/>
                                <scope line="276"/>
                                <scope line="279"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="288">
                Increment of the last order based on the comparison level.                
            </javadoc>
            <method name="increment" type="int" line="292">
                <params>
                    <param name="aStrength" type="int"/>
                    <param name="lastValue" type="int"/>
                </params>
                <comment line="296">
                    increment priamry order  and mask off secondary and tertiary difference                    
                </comment>
                <comment line="302">
                    increment secondary order and mask off tertiary difference                    
                </comment>
                <comment line="305">
                    record max # of ignorable chars with secondary difference                    
                </comment>
                <comment line="310">
                    increment tertiary order                    
                </comment>
                <comment line="312">
                    record max # of ignorable chars with tertiary difference                    
                </comment>
            </method>
            <javadoc line="320">
                Adds a character and its designated order into the collation table.                
            </javadoc>
            <method name="addOrder" type="void" line="324">
                <params>
                    <param name="ch" type="int"/>
                    <param name="anOrder" type="int"/>
                </params>
                <comment line="325">
                    See if the char already has an order in the mapping table                    
                </comment>
                <comment line="329">
                    There&apos;s already an entry for this character that points to a contracting                    
                </comment>
                <comment line="330">
                    character table.  Instead of adding the character directly to the mapping                    
                </comment>
                <comment line="331">
                    table, we must add it to the contract table instead.                    
                </comment>
                <comment line="340">
                    add the entry to the mapping table,                    
                </comment>
                <comment line="341">
                    the same later entry replaces the previous one                    
                </comment>
                <declaration name="order" type="int" line="326"/>
                <scope line="328">
                    <declaration name="length" type="int" line="332"/>
                    <scope line="333"/>
                    <scope line="335"/>
                </scope>
                <scope line="339"/>
            </method>
            <method name="addContractOrder" type="void" line="346">
                <params>
                    <param name="groupChars" type="String"/>
                    <param name="anOrder" type="int"/>
                </params>
            </method>
            <javadoc line="350">
                Adds the contracting string into the collation table.                
            </javadoc>
            <method name="addContractOrder" type="void" line="355">
                <params>
                    <param name="groupChars" type="String"/>
                    <param name="anOrder" type="int"/>
                    <param name="fwd" type="boolean"/>
                </params>
                <comment line="360">
                    initial character                    
                </comment>
                <comment line="362">
                    char ch0 = groupChars.charAt(0);
                    int ch = Character.isHighSurrogate(ch0)?
                    Character.toCodePoint(ch0, groupChars.charAt(1)):ch0;                    
                </comment>
                <comment line="367">
                    See if the initial character of the string already has a contract table.                    
                </comment>
                <comment line="372">
                    We need to create a new table of contract entries for this base char                    
                </comment>
                <comment line="377">
                    Add the initial character&apos;s current ordering first. then                    
                </comment>
                <comment line="378">
                    update its mapping to point to this contract table                    
                </comment>
                <comment line="383">
                    Now add (or replace) this string in the table                    
                </comment>
                <comment line="391">
                    NOTE:  This little bit of logic is here to speed CollationElementIterator                    
                </comment>
                <comment line="392">
                    .nextContractChar().  This code ensures that the longest sequence in                    
                </comment>
                <comment line="393">
                    this list is always the _last_ one in the list.  This keeps                    
                </comment>
                <comment line="394">
                    nextContractChar() from having to search the entire list for the longest                    
                </comment>
                <comment line="395">
                    sequence.                    
                </comment>
                <comment line="404">
                    If this was a forward mapping for a contracting string, also add a                    
                </comment>
                <comment line="405">
                    reverse mapping for it, so that CollationElementIterator.previous                    
                </comment>
                <comment line="406">
                    can work right                    
                </comment>
                <scope line="356"/>
                <declaration name="ch" type="int" line="361"/>
                <declaration name="entry" type="int" line="368"/>
                <declaration name="entryTable" type="Vector" line="369"/>
                <scope line="371">
                    <declaration name="tableIndex" type="int" line="373"/>
                </scope>
                <declaration name="index" type="int" line="384"/>
                <scope line="385">
                    <declaration name="pair" type="EntryPair" line="386"/>
                </scope>
                <scope line="388">
                    <declaration name="pair" type="EntryPair" line="389"/>
                    <scope line="396"/>
                    <scope line="398"/>
                </scope>
                <scope line="407"/>
            </method>
            <javadoc line="414">
                If the given string has been specified as a contracting string
                  in this collation table, return its ordering.
                  Otherwise return UNMAPPED.                
            </javadoc>
            <method name="getContractOrder" type="int" line="420">
                <params>
                    <param name="groupChars" type="String"/>
                </params>
                <comment line="424">
                    char ch0 = groupChars.charAt(0);
                    int ch = Character.isHighSurrogate(ch0)?
                    Character.toCodePoint(ch0, groupChars.charAt(1)):ch0;                    
                </comment>
                <declaration name="result" type="int" line="421"/>
                <scope line="422">
                    <declaration name="ch" type="int" line="423"/>
                    <declaration name="entryTable" type="Vector" line="429"/>
                    <scope line="430">
                        <declaration name="index" type="int" line="431"/>
                        <scope line="432">
                            <declaration name="pair" type="EntryPair" line="433"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getCharOrder" type="int" line="441">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <declaration name="order" type="int" line="442"/>
                <scope line="444">
                    <declaration name="groupList" type="Vector" line="445"/>
                    <declaration name="pair" type="EntryPair" line="446"/>
                </scope>
            </method>
            <javadoc line="452">
                Get the entry of hash table of the contracting string in the collation
                  table.                
                <param>
                    ch the starting character of the contracting string                    
                </param>
            </javadoc>
            <method name="getContractValues" type="Vector" line="458">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <declaration name="index" type="int" line="459"/>
            </method>
            <method name="getContractValuesImpl" type="Vector" line="464">
                <params>
                    <param name="index" type="int"/>
                </params>
                <comment line="469">
                    not found                    
                </comment>
                <scope line="466"/>
                <scope line="470"/>
            </method>
            <javadoc line="475">
                Adds the expanding string into the collation table.                
            </javadoc>
            <method name="addExpandOrder" type="void" line="481">
                <params>
                    <param name="contractChars" type="String"/>
                    <param name="expandChars" type="String"/>
                    <param name="anOrder" type="int"/>
                </params>
                <comment line="482">
                    Create an expansion table entry                    
                </comment>
                <comment line="485">
                    And add its index into the main mapping table                    
                </comment>
                <comment line="491">
                    only add into table when it is a legal surrogate                    
                </comment>
                <declaration name="tableIndex" type="int" line="483"/>
                <scope line="486">
                    <declaration name="ch" type="char" line="487"/>
                    <scope line="488">
                        <declaration name="ch2" type="char" line="489"/>
                        <scope line="490"/>
                    </scope>
                    <scope line="494"/>
                </scope>
                <scope line="497"/>
            </method>
            <method name="addExpandOrder" type="void" line="504">
                <params>
                    <param name="ch" type="int"/>
                    <param name="expandChars" type="String"/>
                    <param name="anOrder" type="int"/>
                </params>
                <declaration name="tableIndex" type="int" line="505"/>
            </method>
            <javadoc line="509">
                Create a new entry in the expansion table that contains the orderings
                  for the given characers.  If anOrder is valid, it is added to the
                  beginning of the expanded list of orders.                
            </javadoc>
            <method name="addExpansion" type="int" line="514">
                <params>
                    <param name="anOrder" type="int"/>
                    <param name="expandChars" type="String"/>
                </params>
                <comment line="519">
                    If anOrder is valid, we want to add it at the beginning of the list                    
                </comment>
                <comment line="535">
                    ether we are missing the low surrogate or the next char                    
                </comment>
                <comment line="536">
                    is not a legal low surrogate, so stop loop                    
                </comment>
                <comment line="550">
                    can&apos;t find it in the table, will be filled in by commit().                    
                </comment>
                <comment line="555">
                    we had at least one supplementary character, the size of valueList                    
                </comment>
                <comment line="556">
                    is bigger than it really needs...                    
                </comment>
                <comment line="563">
                    Add the expanding char list into the expansion table.                    
                </comment>
                <scope line="515"/>
                <declaration name="offset" type="int" line="520"/>
                <declaration name="valueList" type="int[]" line="522"/>
                <scope line="523"/>
                <declaration name="j" type="int" line="527"/>
                <scope line="528">
                    <declaration name="ch0" type="char" line="529"/>
                    <declaration name="ch1" type="char" line="530"/>
                    <declaration name="ch" type="int" line="531"/>
                    <scope line="532">
                        <scope line="534"/>
                    </scope>
                    <scope line="541"/>
                    <declaration name="mapValue" type="int" line="545"/>
                    <scope line="547"/>
                    <scope line="549"/>
                </scope>
                <scope line="554">
                    <declaration name="tmpBuf" type="int[]" line="557"/>
                    <scope line="558"/>
                </scope>
                <declaration name="tableIndex" type="int" line="564"/>
            </method>
            <method name="addContractFlags" type="void" line="570">
                <params>
                    <param name="chars" type="String"/>
                </params>
                <declaration name="c0" type="char" line="571"/>
                <declaration name="c" type="int" line="572"/>
                <declaration name="len" type="int" line="573"/>
                <scope line="574"/>
            </method>
            <declaration name="CHARINDEX" type="int" line="586"/>
            <declaration name="IGNORABLEMASK" type="int" line="588"/>
            <declaration name="PRIMARYORDERINCREMENT" type="int" line="589"/>
            <declaration name="SECONDARYORDERINCREMENT" type="int" line="590"/>
            <declaration name="TERTIARYORDERINCREMENT" type="int" line="591"/>
            <declaration name="INITIALTABLESIZE" type="int" line="592"/>
            <declaration name="MAXKEYSIZE" type="int" line="593"/>
            <declaration name="tables" type="RBCollationTables.BuildAPI" line="600"/>
            <declaration name="mPattern" type="MergeCollation" line="601"/>
            <declaration name="isOverIgnore" type="boolean" line="602"/>
            <declaration name="keyBuf" type="char[]" line="603"/>
            <declaration name="contractFlags" type="IntHashtable" line="604"/>
            <declaration name="frenchSec" type="boolean" line="609"/>
            <declaration name="seAsianSwapping" type="boolean" line="610"/>
            <declaration name="mapping" type="UCompactIntArray" line="612"/>
            <declaration name="contractTable" type="Vector" line="613"/>
            <declaration name="expandTable" type="Vector" line="614"/>
            <declaration name="maxSecOrder" type="short" line="616"/>
            <declaration name="maxTerOrder" type="short" line="617"/>
        </class>
    </source>