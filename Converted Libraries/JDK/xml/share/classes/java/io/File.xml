<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.io">
        <import package="java.net.URI"/>
        <import package="java.net.URL"/>
        <import package="java.net.MalformedURLException"/>
        <import package="java.net.URISyntaxException"/>
        <import package="java.util.List"/>
        <import package="java.util.ArrayList"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.SecureRandom"/>
        <import package="java.nio.file.Path"/>
        <import package="java.nio.file.FileSystems"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="File" line="13">
            <implements interface="Serializable"/>
            <implements interface="Comparable">
                <type_params>
                    <type_param name="File"/>
                </type_params>
            </implements>
            <javadoc line="13">
                An abstract representation of file and directory pathnames.
                  &lt;p&gt; User interfaces and operating systems use system-dependent &lt;em&gt;pathname
                  strings&lt;/em&gt; to name files and directories.  This class presents an
                  abstract, system-independent view of hierarchical pathnames.  An
                  &lt;em&gt;abstract pathname&lt;/em&gt; has two components:
                  &lt;ol&gt;
                  &lt;li&gt; An optional system-dependent &lt;em&gt;prefix&lt;/em&gt; string,
                  such as a disk-drive specifier, &lt;code&gt;&quot;/&quot;&lt;/code&gt;&amp;nbsp;for the UNIX root
                  directory, or &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;&amp;nbsp;for a Microsoft Windows UNC pathname, and
                  &lt;li&gt; A sequence of zero or more string &lt;em&gt;names&lt;/em&gt;.
                  &lt;/ol&gt;
                  The first name in an abstract pathname may be a directory name or, in the
                  case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name
                  in an abstract pathname denotes a directory; the last name may denote
                  either a directory or a file.  The &lt;em&gt;empty&lt;/em&gt; abstract pathname has no
                  prefix and an empty name sequence.
                  &lt;p&gt; The conversion of a pathname string to or from an abstract pathname is
                  inherently system-dependent.  When an abstract pathname is converted into a
                  pathname string, each name is separated from the next by a single copy of
                  the default &lt;em&gt;separator character&lt;/em&gt;.  The default name-separator
                  character is defined by the system property &lt;code&gt;file.separator&lt;/code&gt;, and
                  is made available in the public static fields &lt;code&gt;{@link #separator}&lt;/code&gt; and &lt;code&gt;{@link #separatorChar}&lt;/code&gt; of this class.
                  When a pathname string is converted into an abstract pathname, the names
                  within it may be separated by the default name-separator character or by any
                  other name-separator character that is supported by the underlying system.
                  &lt;p&gt; A pathname, whether abstract or in string form, may be either
                  &lt;em&gt;absolute&lt;/em&gt; or &lt;em&gt;relative&lt;/em&gt;.  An absolute pathname is complete in
                  that no other information is required in order to locate the file that it
                  denotes.  A relative pathname, in contrast, must be interpreted in terms of
                  information taken from some other pathname.  By default the classes in the
                  &lt;code&gt;java.io&lt;/code&gt; package always resolve relative pathnames against the
                  current user directory.  This directory is named by the system property
                  &lt;code&gt;user.dir&lt;/code&gt;, and is typically the directory in which the Java
                  virtual machine was invoked.
                  &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking
                  the {@link #getParent} method of this class and consists of the pathname&apos;s
                  prefix and each name in the pathname&apos;s name sequence except for the last.
                  Each directory&apos;s absolute pathname is an ancestor of any &lt;tt&gt;File&lt;/tt&gt;
                  object with an absolute abstract pathname which begins with the directory&apos;s
                  absolute pathname.  For example, the directory denoted by the abstract
                  pathname &lt;tt&gt;&quot;/usr&quot;&lt;/tt&gt; is an ancestor of the directory denoted by the
                  pathname &lt;tt&gt;&quot;/usr/local/bin&quot;&lt;/tt&gt;.
                  &lt;p&gt; The prefix concept is used to handle root directories on UNIX platforms,
                  and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,
                  as follows:
                  &lt;ul&gt;
                  &lt;li&gt; For UNIX platforms, the prefix of an absolute pathname is always
                  &lt;code&gt;&quot;/&quot;&lt;/code&gt;.  Relative pathnames have no prefix.  The abstract pathname
                  denoting the root directory has the prefix &lt;code&gt;&quot;/&quot;&lt;/code&gt; and an empty
                  name sequence.
                  &lt;li&gt; For Microsoft Windows platforms, the prefix of a pathname that contains a drive
                  specifier consists of the drive letter followed by &lt;code&gt;&quot;:&quot;&lt;/code&gt; and
                  possibly followed by &lt;code&gt;&quot;\\&quot;&lt;/code&gt; if the pathname is absolute.  The
                  prefix of a UNC pathname is &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;; the hostname and the share
                  name are the first two names in the name sequence.  A relative pathname that
                  does not specify a drive has no prefix.
                  &lt;/ul&gt;
                  &lt;p&gt; Instances of this class may or may not denote an actual file-system
                  object such as a file or a directory.  If it does denote such an object
                  then that object resides in a &lt;i&gt;partition&lt;/i&gt;.  A partition is an
                  operating system-specific portion of storage for a file system.  A single
                  storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may
                  contain multiple partitions.  The object, if any, will reside on the
                  partition &lt;a name=&quot;partName&quot;&gt;named&lt;/a&gt; by some ancestor of the absolute
                  form of this pathname.
                  &lt;p&gt; A file system may implement restrictions to certain operations on the
                  actual file-system object, such as reading, writing, and executing.  These
                  restrictions are collectively known as &lt;i&gt;access permissions&lt;/i&gt;.  The file
                  system may have multiple sets of access permissions on a single object.
                  For example, one set may apply to the object&apos;s &lt;i&gt;owner&lt;/i&gt;, and another
                  may apply to all other users.  The access permissions on an object may
                  cause some methods in this class to fail.
                  &lt;p&gt; Instances of the &lt;code&gt;File&lt;/code&gt; class are immutable; that is, once
                  created, the abstract pathname represented by a &lt;code&gt;File&lt;/code&gt; object
                  will never change.
                  &lt;h4&gt;Interoperability with {@code java.nio.file} package&lt;/h4&gt;
                  &lt;p&gt; The &lt;a href=&quot;../../java/nio/file/package-summary.html&quot;&gt;{@code java.nio.file}&lt;/a&gt;
                  package defines interfaces and classes for the Java virtual machine to access
                  files, file attributes, and file systems. This API may be used to overcome
                  many of the limitations of the {@code java.io.File} class.
                  The {@link #toPath toPath} method may be used to obtain a {@link Path} that uses the abstract path represented by a {@code File} object to
                  locate a file. The resulting {@code Path} may be used with the {@link java.nio.file.Files} class to provide more efficient and extensive access to
                  additional file operations, file attributes, and I/O exceptions to help
                  diagnose errors when an operation on a file fails.                
                <author>
                    unascribed                    
                </author>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="fs" type="FileSystem" line="102"/>
            <javadoc line="102">
                The FileSystem object representing the platform&apos;s local file system.                
            </javadoc>
            <declaration name="path" type="String" line="106"/>
            <javadoc line="106">
                This abstract pathname&apos;s normalized pathname string.  A normalized
                  pathname string uses the default name-separator character and does not
                  contain any duplicate or redundant separators.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="prefixLength" type="int" line="113"/>
            <javadoc line="113">
                The length of this abstract pathname&apos;s prefix, or zero if it has no
                  prefix.                
            </javadoc>
            <javadoc line="118">
                Returns the length of this abstract pathname&apos;s prefix.
                  For use by FileSystem classes.                
            </javadoc>
            <method name="getPrefixLength" type="int" line="122"/>
            <declaration name="separatorChar" type="char" line="125"/>
            <javadoc line="125">
                The system-dependent default name-separator character.  This field is
                  initialized to contain the first character of the value of the system
                  property &lt;code&gt;file.separator&lt;/code&gt;.  On UNIX systems the value of this
                  field is &lt;code&gt;&apos;/&apos;&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;&apos;\\&apos;&lt;/code&gt;.                
                <see>
                    java.lang.System#getProperty(java.lang.String)                    
                </see>
            </javadoc>
            <declaration name="separator" type="String" line="133"/>
            <javadoc line="133">
                The system-dependent default name-separator character, represented as a
                  string for convenience.  This string contains a single character, namely
                  &lt;code&gt;{@link #separatorChar}&lt;/code&gt;.                
            </javadoc>
            <declaration name="pathSeparatorChar" type="char" line="139"/>
            <javadoc line="139">
                The system-dependent path-separator character.  This field is
                  initialized to contain the first character of the value of the system
                  property &lt;code&gt;path.separator&lt;/code&gt;.  This character is used to
                  separate filenames in a sequence of files given as a &lt;em&gt;path list&lt;/em&gt;.
                  On UNIX systems, this character is &lt;code&gt;&apos;:&apos;&lt;/code&gt;; on Microsoft Windows systems it
                  is &lt;code&gt;&apos;;&apos;&lt;/code&gt;.                
                <see>
                    java.lang.System#getProperty(java.lang.String)                    
                </see>
            </javadoc>
            <declaration name="pathSeparator" type="String" line="149"/>
            <javadoc line="149">
                The system-dependent path-separator character, represented as a string
                  for convenience.  This string contains a single character, namely
                  &lt;code&gt;{@link #pathSeparatorChar}&lt;/code&gt;.                
            </javadoc>
            <javadoc line="155">
                Internal constructor for already-normalized pathname strings.                
            </javadoc>
            <method name="File" type="constructor" line="158">
                <params>
                    <param name="pathname" type="String"/>
                    <param name="prefixLength" type="int"/>
                </params>
            </method>
            <javadoc line="162">
                Internal constructor for already-normalized pathname strings.
                  The parameter order is used to disambiguate this method from the
                  public(File, String) constructor.                
            </javadoc>
            <method name="File" type="constructor" line="167">
                <params>
                    <param name="child" type="String"/>
                    <param name="parent" type="File"/>
                </params>
            </method>
            <javadoc line="173">
                Creates a new &lt;code&gt;File&lt;/code&gt; instance by converting the given
                  pathname string into an abstract pathname.  If the given string is
                  the empty string, then the result is the empty abstract pathname.                
                <param>
                    pathname  A pathname string                    
                </param>
                <throws>
                    NullPointerExceptionIf the &lt;code&gt;pathname&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt;                    
                </throws>
            </javadoc>
            <method name="File" type="constructor" line="180">
                <params>
                    <param name="pathname" type="String"/>
                </params>
                <scope line="181"/>
            </method>
            <javadoc line="187">
                Creates a new &lt;code&gt;File&lt;/code&gt; instance from a parent pathname string
                  and a child pathname string.
                  &lt;p&gt; If &lt;code&gt;parent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then the new
                  &lt;code&gt;File&lt;/code&gt; instance is created as if by invoking the
                  single-argument &lt;code&gt;File&lt;/code&gt; constructor on the given
                  &lt;code&gt;child&lt;/code&gt; pathname string.
                  &lt;p&gt; Otherwise the &lt;code&gt;parent&lt;/code&gt; pathname string is taken to denote
                  a directory, and the &lt;code&gt;child&lt;/code&gt; pathname string is taken to
                  denote either a directory or a file.  If the &lt;code&gt;child&lt;/code&gt; pathname
                  string is absolute then it is converted into a relative pathname in a
                  system-dependent way.  If &lt;code&gt;parent&lt;/code&gt; is the empty string then
                  the new &lt;code&gt;File&lt;/code&gt; instance is created by converting
                  &lt;code&gt;child&lt;/code&gt; into an abstract pathname and resolving the result
                  against a system-dependent default directory.  Otherwise each pathname
                  string is converted into an abstract pathname and the child abstract
                  pathname is resolved against the parent.                
                <param>
                    parent  The parent pathname string                    
                </param>
                <param>
                    child   The child pathname string                    
                </param>
                <throws>
                    NullPointerExceptionIf &lt;code&gt;child&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </throws>
            </javadoc>
            <method name="File" type="constructor" line="208">
                <params>
                    <param name="parent" type="String"/>
                    <param name="child" type="String"/>
                </params>
                <scope line="209"/>
                <scope line="212">
                    <scope line="213"/>
                    <scope line="216"/>
                </scope>
                <scope line="220"/>
            </method>
            <javadoc line="225">
                Creates a new &lt;code&gt;File&lt;/code&gt; instance from a parent abstract
                  pathname and a child pathname string.
                  &lt;p&gt; If &lt;code&gt;parent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then the new
                  &lt;code&gt;File&lt;/code&gt; instance is created as if by invoking the
                  single-argument &lt;code&gt;File&lt;/code&gt; constructor on the given
                  &lt;code&gt;child&lt;/code&gt; pathname string.
                  &lt;p&gt; Otherwise the &lt;code&gt;parent&lt;/code&gt; abstract pathname is taken to
                  denote a directory, and the &lt;code&gt;child&lt;/code&gt; pathname string is taken
                  to denote either a directory or a file.  If the &lt;code&gt;child&lt;/code&gt;
                  pathname string is absolute then it is converted into a relative
                  pathname in a system-dependent way.  If &lt;code&gt;parent&lt;/code&gt; is the empty
                  abstract pathname then the new &lt;code&gt;File&lt;/code&gt; instance is created by
                  converting &lt;code&gt;child&lt;/code&gt; into an abstract pathname and resolving
                  the result against a system-dependent default directory.  Otherwise each
                  pathname string is converted into an abstract pathname and the child
                  abstract pathname is resolved against the parent.                
                <param>
                    parent  The parent abstract pathname                    
                </param>
                <param>
                    child   The child pathname string                    
                </param>
                <throws>
                    NullPointerExceptionIf &lt;code&gt;child&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </throws>
            </javadoc>
            <method name="File" type="constructor" line="246">
                <params>
                    <param name="parent" type="File"/>
                    <param name="child" type="String"/>
                </params>
                <scope line="247"/>
                <scope line="250">
                    <scope line="251"/>
                    <scope line="254"/>
                </scope>
                <scope line="258"/>
            </method>
            <javadoc line="263">
                Creates a new &lt;tt&gt;File&lt;/tt&gt; instance by converting the given
                  &lt;tt&gt;file:&lt;/tt&gt; URI into an abstract pathname.
                  &lt;p&gt; The exact form of a &lt;tt&gt;file:&lt;/tt&gt; URI is system-dependent, hence
                  the transformation performed by this constructor is also
                  system-dependent.
                  &lt;p&gt; For a given abstract pathname &lt;i&gt;f&lt;/i&gt; it is guaranteed that
                  &lt;blockquote&gt;&lt;tt&gt;
                  new File(&lt;/tt&gt;&lt;i&gt;&amp;nbsp;f&lt;/i&gt;&lt;tt&gt;.{@link #toURI() toURI}()).equals(&lt;/tt&gt;&lt;i&gt;&amp;nbsp;f&lt;/i&gt;&lt;tt&gt;.{@link #getAbsoluteFile() getAbsoluteFile}())
                  &lt;/tt&gt;&lt;/blockquote&gt;
                  so long as the original abstract pathname, the URI, and the new abstract
                  pathname are all created in (possibly different invocations of) the same
                  Java virtual machine.  This relationship typically does not hold,
                  however, when a &lt;tt&gt;file:&lt;/tt&gt; URI that is created in a virtual machine
                  on one operating system is converted into an abstract pathname in a
                  virtual machine on a different operating system.                
                <param>
                    uriAn absolute, hierarchical URI with a scheme equal to
                      &lt;tt&gt;&quot;file&quot;&lt;/tt&gt;, a non-empty path component, and undefined
                      authority, query, and fragment components                    
                </param>
                <throws>
                    NullPointerExceptionIf &lt;tt&gt;uri&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf the preconditions on the parameter do not hold                    
                </throws>
                <see>
                    #toURI()                    
                </see>
                <see>
                    java.net.URI                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="File" type="constructor" line="288">
                <params>
                    <param name="uri" type="URI"/>
                </params>
                <declaration name="scheme" type="String" line="291"/>
                <declaration name="p" type="String" line="296"/>
            </method>
            <javadoc line="303">
                Returns the name of the file or directory denoted by this abstract
                  pathname.  This is just the last name in the pathname&apos;s name
                  sequence.  If the pathname&apos;s name sequence is empty, then the empty
                  string is returned.                
                <return>
                    The name of the file or directory denoted by this abstract
                      pathname, or the empty string if this pathname&apos;s name sequence
                      is empty                    
                </return>
            </javadoc>
            <method name="getName" type="String" line="312">
                <declaration name="index" type="int" line="313"/>
            </method>
            <javadoc line="317">
                Returns the pathname string of this abstract pathname&apos;s parent, or
                  &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent directory.
                  &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the
                  pathname&apos;s prefix, if any, and each name in the pathname&apos;s name
                  sequence except for the last.  If the name sequence is empty then
                  the pathname does not name a parent directory.                
                <return>
                    The pathname string of the parent directory named by this
                      abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname
                      does not name a parent                    
                </return>
            </javadoc>
            <method name="getParent" type="String" line="328">
                <declaration name="index" type="int" line="329"/>
                <scope line="330"/>
            </method>
            <javadoc line="336">
                Returns the abstract pathname of this abstract pathname&apos;s parent,
                  or &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent
                  directory.
                  &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the
                  pathname&apos;s prefix, if any, and each name in the pathname&apos;s name
                  sequence except for the last.  If the name sequence is empty then
                  the pathname does not name a parent directory.                
                <return>
                    The abstract pathname of the parent directory named by this
                      abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname
                      does not name a parent                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getParentFile" type="File" line="349">
                <declaration name="p" type="String" line="350"/>
            </method>
            <javadoc line="354">
                Converts this abstract pathname into a pathname string.  The resulting
                  string uses the {@link #separator default name-separator character} to
                  separate the names in the name sequence.                
                <return>
                    The string form of this abstract pathname                    
                </return>
            </javadoc>
            <method name="getPath" type="String" line="360"/>
            <javadoc line="363">
                Tests whether this abstract pathname is absolute.  The definition of
                  absolute pathname is system dependent.  On UNIX systems, a pathname is
                  absolute if its prefix is &lt;code&gt;&quot;/&quot;&lt;/code&gt;.  On Microsoft Windows systems, a
                  pathname is absolute if its prefix is a drive specifier followed by
                  &lt;code&gt;&quot;\\&quot;&lt;/code&gt;, or if its prefix is &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if this abstract pathname is absolute,
                      &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
            </javadoc>
            <method name="isAbsolute" type="boolean" line="372"/>
            <javadoc line="375">
                Returns the absolute pathname string of this abstract pathname.
                  &lt;p&gt; If this abstract pathname is already absolute, then the pathname
                  string is simply returned as if by the &lt;code&gt;{@link #getPath}&lt;/code&gt;
                  method.  If this abstract pathname is the empty abstract pathname then
                  the pathname string of the current user directory, which is named by the
                  system property &lt;code&gt;user.dir&lt;/code&gt;, is returned.  Otherwise this
                  pathname is resolved in a system-dependent way.  On UNIX systems, a
                  relative pathname is made absolute by resolving it against the current
                  user directory.  On Microsoft Windows systems, a relative pathname is made absolute
                  by resolving it against the current directory of the drive named by the
                  pathname, if any; if not, it is resolved against the current user
                  directory.                
                <return>
                    The absolute pathname string denoting the same file or
                      directory as this abstract pathname                    
                </return>
                <throws>
                    SecurityExceptionIf a required system property value cannot be accessed.                    
                </throws>
                <see>
                    java.io.File#isAbsolute()                    
                </see>
            </javadoc>
            <method name="getAbsolutePath" type="String" line="393"/>
            <javadoc line="396">
                Returns the absolute form of this abstract pathname.  Equivalent to
                  &lt;code&gt;new&amp;nbsp;File(this.{@link #getAbsolutePath})&lt;/code&gt;.                
                <return>
                    The absolute abstract pathname denoting the same file or
                      directory as this abstract pathname                    
                </return>
                <throws>
                    SecurityExceptionIf a required system property value cannot be accessed.                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getAbsoluteFile" type="File" line="404">
                <declaration name="absPath" type="String" line="405"/>
            </method>
            <javadoc line="408">
                Returns the canonical pathname string of this abstract pathname.
                  &lt;p&gt; A canonical pathname is both absolute and unique.  The precise
                  definition of canonical form is system-dependent.  This method first
                  converts this pathname to absolute form if necessary, as if by invoking the{@link #getAbsolutePath} method, and then maps it to its unique form in a
                  system-dependent way.  This typically involves removing redundant names
                  such as &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; and &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; from the pathname, resolving
                  symbolic links (on UNIX platforms), and converting drive letters to a
                  standard case (on Microsoft Windows platforms).
                  &lt;p&gt; Every pathname that denotes an existing file or directory has a
                  unique canonical form.  Every pathname that denotes a nonexistent file
                  or directory also has a unique canonical form.  The canonical form of
                  the pathname of a nonexistent file or directory may be different from
                  the canonical form of the same pathname after the file or directory is
                  created.  Similarly, the canonical form of the pathname of an existing
                  file or directory may be different from the canonical form of the same
                  pathname after the file or directory is deleted.                
                <return>
                    The canonical pathname string denoting the same file or
                      directory as this abstract pathname                    
                </return>
                <throws>
                    IOExceptionIf an I/O error occurs, which is possible because the
                      construction of the canonical pathname may require
                      filesystem queries                    
                </throws>
                <throws>
                    SecurityExceptionIf a required system property value cannot be accessed, or
                      if a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead}&lt;/code&gt; method denies
                      read access to the file                    
                </throws>
                <since>
                    JDK1.1                    
                </since>
                <see>
                    Path#toRealPath                    
                </see>
            </javadoc>
            <method name="getCanonicalPath" type="String" line="436"/>
            <javadoc line="439">
                Returns the canonical form of this abstract pathname.  Equivalent to
                  &lt;code&gt;new&amp;nbsp;File(this.{@link #getCanonicalPath})&lt;/code&gt;.                
                <return>
                    The canonical pathname string denoting the same file or
                      directory as this abstract pathname                    
                </return>
                <throws>
                    IOExceptionIf an I/O error occurs, which is possible because the
                      construction of the canonical pathname may require
                      filesystem queries                    
                </throws>
                <throws>
                    SecurityExceptionIf a required system property value cannot be accessed, or
                      if a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead}&lt;/code&gt; method denies
                      read access to the file                    
                </throws>
                <since>
                    1.2                    
                </since>
                <see>
                    Path#toRealPath                    
                </see>
            </javadoc>
            <method name="getCanonicalFile" type="File" line="453">
                <declaration name="canonPath" type="String" line="454"/>
            </method>
            <method name="slashify" type="String" line="457">
                <params>
                    <param name="path" type="String"/>
                    <param name="isDirectory" type="boolean"/>
                </params>
                <declaration name="p" type="String" line="458"/>
            </method>
            <javadoc line="464">
                Converts this abstract pathname into a &lt;code&gt;file:&lt;/code&gt; URL.  The
                  exact form of the URL is system-dependent.  If it can be determined that
                  the file denoted by this abstract pathname is a directory, then the
                  resulting URL will end with a slash.                
                <return>
                    A URL object representing the equivalent file URL                    
                </return>
                <throws>
                    MalformedURLExceptionIf the path cannot be parsed as a URL                    
                </throws>
                <see>
                    #toURI()                    
                </see>
                <see>
                    java.net.URI                    
                </see>
                <see>
                    java.net.URI#toURL()                    
                </see>
                <see>
                    java.net.URL                    
                </see>
                <since>
                    1.2                    
                </since>
                <deprecated>
                    This method does not automatically escape characters that
                      are illegal in URLs.  It is recommended that new code convert an
                      abstract pathname into a URL by first converting it into a URI, via the{@link #toURI() toURI} method, and then converting the URI into a URL
                      via the {@link java.net.URI#toURL() URI.toURL} method.                    
                </deprecated>
            </javadoc>
            <method name="toURL" type="URL" line="481"/>
            <javadoc line="484">
                Constructs a &lt;tt&gt;file:&lt;/tt&gt; URI that represents this abstract pathname.
                  &lt;p&gt; The exact form of the URI is system-dependent.  If it can be
                  determined that the file denoted by this abstract pathname is a
                  directory, then the resulting URI will end with a slash.
                  &lt;p&gt; For a given abstract pathname &lt;i&gt;f&lt;/i&gt;, it is guaranteed that
                  &lt;blockquote&gt;&lt;tt&gt;
                  new {@link #File(java.net.URI) File}(&lt;/tt&gt;&lt;i&gt;&amp;nbsp;f&lt;/i&gt;&lt;tt&gt;.toURI()).equals(&lt;/tt&gt;&lt;i&gt;&amp;nbsp;f&lt;/i&gt;&lt;tt&gt;.{@link #getAbsoluteFile() getAbsoluteFile}())
                  &lt;/tt&gt;&lt;/blockquote&gt;
                  so long as the original abstract pathname, the URI, and the new abstract
                  pathname are all created in (possibly different invocations of) the same
                  Java virtual machine.  Due to the system-dependent nature of abstract
                  pathnames, however, this relationship typically does not hold when a
                  &lt;tt&gt;file:&lt;/tt&gt; URI that is created in a virtual machine on one operating
                  system is converted into an abstract pathname in a virtual machine on a
                  different operating system.
                  &lt;p&gt; Note that when this abstract pathname represents a UNC pathname then
                  all components of the UNC (including the server name component) are encoded
                  in the {@code URI} path. The authority component is undefined, meaning
                  that it is represented as {@code null}. The {@link Path} class defines the{@link Path#toUri toUri} method to encode the server name in the authority
                  component of the resulting {@code URI}. The {@link #toPath toPath} method
                  may be used to obtain a {@code Path} representing this abstract pathname.                
                <return>
                    An absolute, hierarchical URI with a scheme equal to
                      &lt;tt&gt;&quot;file&quot;&lt;/tt&gt;, a path representing this abstract pathname,
                      and undefined authority, query, and fragment components                    
                </return>
                <throws>
                    SecurityException If a required system property value cannot
                      be accessed.                    
                </throws>
                <see>
                    #File(java.net.URI)                    
                </see>
                <see>
                    java.net.URI                    
                </see>
                <see>
                    java.net.URI#toURL()                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="toURI" type="URI" line="516">
                <scope line="517">
                    <declaration name="f" type="File" line="518"/>
                    <declaration name="sp" type="String" line="519"/>
                </scope>
                <scope line="523"/>
            </method>
            <javadoc line="527">
                Tests whether the application can read the file denoted by this
                  abstract pathname.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the file specified by this
                      abstract pathname exists &lt;em&gt;and&lt;/em&gt; can be read by the
                      application; &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
                      method denies read access to the file                    
                </throws>
            </javadoc>
            <method name="canRead" type="boolean" line="536">
                <declaration name="security" type="SecurityManager" line="537"/>
                <scope line="538"/>
            </method>
            <javadoc line="543">
                Tests whether the application can modify the file denoted by this
                  abstract pathname.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the file system actually
                      contains a file denoted by this abstract pathname &lt;em&gt;and&lt;/em&gt;
                      the application is allowed to write to the file;
                      &lt;code&gt;false&lt;/code&gt; otherwise.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the file                    
                </throws>
            </javadoc>
            <method name="canWrite" type="boolean" line="553">
                <declaration name="security" type="SecurityManager" line="554"/>
                <scope line="555"/>
            </method>
            <javadoc line="560">
                Tests whether the file or directory denoted by this abstract pathname
                  exists.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the file or directory denoted
                      by this abstract pathname exists; &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
                      method denies read access to the file or directory                    
                </throws>
            </javadoc>
            <method name="exists" type="boolean" line="568">
                <declaration name="security" type="SecurityManager" line="569"/>
                <scope line="570"/>
            </method>
            <javadoc line="575">
                Tests whether the file denoted by this abstract pathname is a
                  directory.
                  &lt;p&gt; Where it is required to distinguish an I/O exception from the case
                  that the file is not a directory, or where several attributes of the
                  same file are required at the same time, then the {@link java.nio.file.Files#readAttributes(Path,Class,LinkOption[])Files.readAttributes} method may be used.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this
                      abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a directory;
                      &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
                      method denies read access to the file                    
                </throws>
            </javadoc>
            <method name="isDirectory" type="boolean" line="587">
                <declaration name="security" type="SecurityManager" line="588"/>
                <scope line="589"/>
            </method>
            <javadoc line="594">
                Tests whether the file denoted by this abstract pathname is a normal
                  file.  A file is &lt;em&gt;normal&lt;/em&gt; if it is not a directory and, in
                  addition, satisfies other system-dependent criteria.  Any non-directory
                  file created by a Java application is guaranteed to be a normal file.
                  &lt;p&gt; Where it is required to distinguish an I/O exception from the case
                  that the file is not a normal file, or where several attributes of the
                  same file are required at the same time, then the {@link java.nio.file.Files#readAttributes(Path,Class,LinkOption[])Files.readAttributes} method may be used.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this
                      abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a normal file;
                      &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
                      method denies read access to the file                    
                </throws>
            </javadoc>
            <method name="isFile" type="boolean" line="608">
                <declaration name="security" type="SecurityManager" line="609"/>
                <scope line="610"/>
            </method>
            <javadoc line="615">
                Tests whether the file named by this abstract pathname is a hidden
                  file.  The exact definition of &lt;em&gt;hidden&lt;/em&gt; is system-dependent.  On
                  UNIX systems, a file is considered to be hidden if its name begins with
                  a period character (&lt;code&gt;&apos;.&apos;&lt;/code&gt;).  On Microsoft Windows systems, a file is
                  considered to be hidden if it has been marked as such in the filesystem.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this
                      abstract pathname is hidden according to the conventions of the
                      underlying platform                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
                      method denies read access to the file                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="isHidden" type="boolean" line="628">
                <declaration name="security" type="SecurityManager" line="629"/>
                <scope line="630"/>
            </method>
            <javadoc line="635">
                Returns the time that the file denoted by this abstract pathname was
                  last modified.
                  &lt;p&gt; Where it is required to distinguish an I/O exception from the case
                  where {@code 0L} is returned, or where several attributes of the
                  same file are required at the same time, or where the time of last
                  access or the creation time are required, then the {@link java.nio.file.Files#readAttributes(Path,Class,LinkOption[])Files.readAttributes} method may be used.                
                <return>
                    A &lt;code&gt;long&lt;/code&gt; value representing the time the file was
                      last modified, measured in milliseconds since the epoch
                      (00:00:00 GMT, January 1, 1970), or &lt;code&gt;0L&lt;/code&gt; if the
                      file does not exist or if an I/O error occurs                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
                      method denies read access to the file                    
                </throws>
            </javadoc>
            <method name="lastModified" type="long" line="649">
                <declaration name="security" type="SecurityManager" line="650"/>
                <scope line="651"/>
            </method>
            <javadoc line="656">
                Returns the length of the file denoted by this abstract pathname.
                  The return value is unspecified if this pathname denotes a directory.
                  &lt;p&gt; Where it is required to distinguish an I/O exception from the case
                  that {@code 0L} is returned, or where several attributes of the same file
                  are required at the same time, then the {@link java.nio.file.Files#readAttributes(Path,Class,LinkOption[])Files.readAttributes} method may be used.                
                <return>
                    The length, in bytes, of the file denoted by this abstract
                      pathname, or &lt;code&gt;0L&lt;/code&gt; if the file does not exist.  Some
                      operating systems may return &lt;code&gt;0L&lt;/code&gt; for pathnames
                      denoting system-dependent entities such as devices or pipes.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
                      method denies read access to the file                    
                </throws>
            </javadoc>
            <method name="length" type="long" line="669">
                <declaration name="security" type="SecurityManager" line="670"/>
                <scope line="671"/>
            </method>
            <javadoc line="676">
                Atomically creates a new, empty file named by this abstract pathname if
                  and only if a file with this name does not yet exist.  The check for the
                  existence of the file and the creation of the file if it does not exist
                  are a single operation that is atomic with respect to all other
                  filesystem activities that might affect the file.
                  &lt;P&gt;
                  Note: this method should &lt;i&gt;not&lt;/i&gt; be used for file-locking, as
                  the resulting protocol cannot be made to work reliably. The{@link java.nio.channels.FileLock FileLock}facility should be used instead.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the named file does not exist and was
                      successfully created; &lt;code&gt;false&lt;/code&gt; if the named file
                      already exists                    
                </return>
                <throws>
                    IOExceptionIf an I/O error occurred                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the file                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="createNewFile" type="boolean" line="693">
                <declaration name="security" type="SecurityManager" line="694"/>
            </method>
            <javadoc line="698">
                Deletes the file or directory denoted by this abstract pathname.  If
                  this pathname denotes a directory, then the directory must be empty in
                  order to be deleted.
                  &lt;p&gt; Note that the {@link java.nio.file.Files} class defines the {@link java.nio.file.Files#delete(Path) delete} method to throw an {@link IOException}when a file cannot be deleted. This is useful for error reporting and to
                  diagnose why a file cannot be deleted.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the file or directory is
                      successfully deleted; &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkDelete}&lt;/code&gt; method denies
                      delete access to the file                    
                </throws>
            </javadoc>
            <method name="delete" type="boolean" line="709">
                <declaration name="security" type="SecurityManager" line="710"/>
                <scope line="711"/>
            </method>
            <javadoc line="716">
                Requests that the file or directory denoted by this abstract
                  pathname be deleted when the virtual machine terminates.
                  Files (or directories) are deleted in the reverse order that
                  they are registered. Invoking this method to delete a file or
                  directory that is already registered for deletion has no effect.
                  Deletion will be attempted only for normal termination of the
                  virtual machine, as defined by the Java Language Specification.
                  &lt;p&gt; Once deletion has been requested, it is not possible to cancel the
                  request.  This method should therefore be used with care.
                  &lt;P&gt;
                  Note: this method should &lt;i&gt;not&lt;/i&gt; be used for file-locking, as
                  the resulting protocol cannot be made to work reliably. The{@link java.nio.channels.FileLock FileLock}facility should be used instead.                
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkDelete}&lt;/code&gt; method denies
                      delete access to the file                    
                </throws>
                <see>
                    #delete                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="deleteOnExit" type="void" line="734">
                <declaration name="security" type="SecurityManager" line="735"/>
                <scope line="736"/>
            </method>
            <javadoc line="741">
                Returns an array of strings naming the files and directories in the
                  directory denoted by this abstract pathname.
                  &lt;p&gt; If this abstract pathname does not denote a directory, then this
                  method returns {@code null}.  Otherwise an array of strings is
                  returned, one for each file or directory in the directory.  Names
                  denoting the directory itself and the directory&apos;s parent directory are
                  not included in the result.  Each string is a file name rather than a
                  complete path.
                  &lt;p&gt; There is no guarantee that the name strings in the resulting array
                  will appear in any specific order; they are not, in particular,
                  guaranteed to appear in alphabetical order.
                  &lt;p&gt; Note that the {@link java.nio.file.Files} class defines the {@link java.nio.file.Files#newDirectoryStream(Path) newDirectoryStream} method to
                  open a directory and iterate over the names of the files in the directory.
                  This may use less resources when working with very large directories, and
                  may be more responsive when working with remote directories.                
                <return>
                    An array of strings naming the files and directories in the
                      directory denoted by this abstract pathname.  The array will be
                      empty if the directory is empty.  Returns {@code null} if
                      this abstract pathname does not denote a directory, or if an
                      I/O error occurs.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its {@link SecurityManager#checkRead(String)} method denies read access to
                      the directory                    
                </throws>
            </javadoc>
            <method name="list" type="String[]" line="765">
                <declaration name="security" type="SecurityManager" line="766"/>
                <scope line="767"/>
            </method>
            <javadoc line="772">
                Returns an array of strings naming the files and directories in the
                  directory denoted by this abstract pathname that satisfy the specified
                  filter.  The behavior of this method is the same as that of the{@link #list()} method, except that the strings in the returned array
                  must satisfy the filter.  If the given {@code filter} is {@code null}then all names are accepted.  Otherwise, a name satisfies the filter if
                  and only if the value {@code true} results when the {@link FilenameFilter#accept FilenameFilter.accept(File,&amp;nbsp;String)} method
                  of the filter is invoked on this abstract pathname and the name of a
                  file or directory in the directory that it denotes.                
                <param>
                    filterA filename filter                    
                </param>
                <return>
                    An array of strings naming the files and directories in the
                      directory denoted by this abstract pathname that were accepted
                      by the given {@code filter}.  The array will be empty if the
                      directory is empty or if no names were accepted by the filter.
                      Returns {@code null} if this abstract pathname does not denote
                      a directory, or if an I/O error occurs.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its {@link SecurityManager#checkRead(String)} method denies read access to
                      the directory                    
                </throws>
                <see>
                    java.nio.file.Files#newDirectoryStream(Path,String)                    
                </see>
            </javadoc>
            <method name="list" type="String[]" line="791">
                <params>
                    <param name="filter" type="FilenameFilter"/>
                </params>
                <declaration name="names" type="String" line="792"/>
                <scope line="793"/>
                <declaration name="v" type="List&amp;lt;String&amp;gt;" line="796"/>
                <scope line="797">
                    <scope line="798"/>
                </scope>
            </method>
            <javadoc line="804">
                Returns an array of abstract pathnames denoting the files in the
                  directory denoted by this abstract pathname.
                  &lt;p&gt; If this abstract pathname does not denote a directory, then this
                  method returns {@code null}.  Otherwise an array of {@code File} objects
                  is returned, one for each file or directory in the directory.  Pathnames
                  denoting the directory itself and the directory&apos;s parent directory are
                  not included in the result.  Each resulting abstract pathname is
                  constructed from this abstract pathname using the {@link #File(File,String) File(File,&amp;nbsp;String)} constructor.  Therefore if this
                  pathname is absolute then each resulting pathname is absolute; if this
                  pathname is relative then each resulting pathname will be relative to
                  the same directory.
                  &lt;p&gt; There is no guarantee that the name strings in the resulting array
                  will appear in any specific order; they are not, in particular,
                  guaranteed to appear in alphabetical order.
                  &lt;p&gt; Note that the {@link java.nio.file.Files} class defines the {@link java.nio.file.Files#newDirectoryStream(Path) newDirectoryStream} method
                  to open a directory and iterate over the names of the files in the
                  directory. This may use less resources when working with very large
                  directories.                
                <return>
                    An array of abstract pathnames denoting the files and
                      directories in the directory denoted by this abstract pathname.
                      The array will be empty if the directory is empty.  Returns{@code null} if this abstract pathname does not denote a
                      directory, or if an I/O error occurs.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its {@link SecurityManager#checkRead(String)} method denies read access to
                      the directory                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="listFiles" type="File[]" line="831">
                <declaration name="ss" type="String[]" line="832"/>
                <declaration name="n" type="int" line="834"/>
                <declaration name="fs" type="File[]" line="835"/>
                <scope line="836"/>
            </method>
            <javadoc line="841">
                Returns an array of abstract pathnames denoting the files and
                  directories in the directory denoted by this abstract pathname that
                  satisfy the specified filter.  The behavior of this method is the same
                  as that of the {@link #listFiles()} method, except that the pathnames in
                  the returned array must satisfy the filter.  If the given {@code filter}is {@code null} then all pathnames are accepted.  Otherwise, a pathname
                  satisfies the filter if and only if the value {@code true} results when
                  the {@link FilenameFilter#acceptFilenameFilter.accept(File,&amp;nbsp;String)} method of the filter is
                  invoked on this abstract pathname and the name of a file or directory in
                  the directory that it denotes.                
                <param>
                    filterA filename filter                    
                </param>
                <return>
                    An array of abstract pathnames denoting the files and
                      directories in the directory denoted by this abstract pathname.
                      The array will be empty if the directory is empty.  Returns{@code null} if this abstract pathname does not denote a
                      directory, or if an I/O error occurs.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its {@link SecurityManager#checkRead(String)} method denies read access to
                      the directory                    
                </throws>
                <since>
                    1.2                    
                </since>
                <see>
                    java.nio.file.Files#newDirectoryStream(Path,String)                    
                </see>
            </javadoc>
            <method name="listFiles" type="File[]" line="861">
                <params>
                    <param name="filter" type="FilenameFilter"/>
                </params>
                <declaration name="ss" type="String" line="862"/>
                <declaration name="files" type="ArrayList&amp;lt;File&amp;gt;" line="864"/>
            </method>
            <javadoc line="868">
                Returns an array of abstract pathnames denoting the files and
                  directories in the directory denoted by this abstract pathname that
                  satisfy the specified filter.  The behavior of this method is the same
                  as that of the {@link #listFiles()} method, except that the pathnames in
                  the returned array must satisfy the filter.  If the given {@code filter}is {@code null} then all pathnames are accepted.  Otherwise, a pathname
                  satisfies the filter if and only if the value {@code true} results when
                  the {@link FileFilter#accept FileFilter.accept(File)} method of the
                  filter is invoked on the pathname.                
                <param>
                    filterA file filter                    
                </param>
                <return>
                    An array of abstract pathnames denoting the files and
                      directories in the directory denoted by this abstract pathname.
                      The array will be empty if the directory is empty.  Returns{@code null} if this abstract pathname does not denote a
                      directory, or if an I/O error occurs.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its {@link SecurityManager#checkRead(String)} method denies read access to
                      the directory                    
                </throws>
                <since>
                    1.2                    
                </since>
                <see>
                    java.nio.file.Files#newDirectoryStream(Path,java.nio.file.DirectoryStream.Filter)                    
                </see>
            </javadoc>
            <method name="listFiles" type="File[]" line="887">
                <params>
                    <param name="filter" type="FileFilter"/>
                </params>
                <declaration name="ss" type="String" line="888"/>
                <declaration name="files" type="ArrayList&amp;lt;File&amp;gt;" line="890"/>
                <scope line="891">
                    <declaration name="f" type="File" line="892"/>
                </scope>
            </method>
            <javadoc line="897">
                Creates the directory named by this abstract pathname.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the directory was
                      created; &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method does not permit the named directory to be created                    
                </throws>
            </javadoc>
            <method name="mkdir" type="boolean" line="904">
                <declaration name="security" type="SecurityManager" line="905"/>
                <scope line="906"/>
            </method>
            <javadoc line="911">
                Creates the directory named by this abstract pathname, including any
                  necessary but nonexistent parent directories.  Note that if this
                  operation fails it may have succeeded in creating some of the necessary
                  parent directories.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the directory was created,
                      along with all necessary parent directories; &lt;code&gt;false&lt;/code&gt;
                      otherwise                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
                      method does not permit verification of the existence of the
                      named directory and all necessary parent directories; or if
                      the &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method does not permit the named directory and all necessary
                      parent directories to be created                    
                </throws>
            </javadoc>
            <method name="mkdirs" type="boolean" line="926">
                <scope line="927"/>
                <scope line="930"/>
                <declaration name="canonFile" type="File" line="933"/>
                <scope line="934"/>
                <scope line="937"/>
                <declaration name="parent" type="File" line="940"/>
            </method>
            <javadoc line="943">
                Renames the file denoted by this abstract pathname.
                  &lt;p&gt; Many aspects of the behavior of this method are inherently
                  platform-dependent: The rename operation might not be able to move a
                  file from one filesystem to another, it might not be atomic, and it
                  might not succeed if a file with the destination abstract pathname
                  already exists.  The return value should always be checked to make sure
                  that the rename operation was successful.
                  &lt;p&gt; Note that the {@link java.nio.file.Files} class defines the {@link java.nio.file.Files#move move} method to move or rename a file in a
                  platform independent manner.                
                <param>
                    dest  The new abstract pathname for the named file                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the renaming succeeded;
                      &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to either the old or new pathnames                    
                </throws>
                <throws>
                    NullPointerExceptionIf parameter &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </throws>
            </javadoc>
            <method name="renameTo" type="boolean" line="960">
                <params>
                    <param name="dest" type="File"/>
                </params>
                <declaration name="security" type="SecurityManager" line="961"/>
                <scope line="962"/>
            </method>
            <javadoc line="968">
                Sets the last-modified time of the file or directory named by this
                  abstract pathname.
                  &lt;p&gt; All platforms support file-modification times to the nearest second,
                  but some provide more precision.  The argument will be truncated to fit
                  the supported precision.  If the operation succeeds and no intervening
                  operations on the file take place, then the next invocation of the
                  &lt;code&gt;{@link #lastModified}&lt;/code&gt; method will return the (possibly
                  truncated) &lt;code&gt;time&lt;/code&gt; argument that was passed to this method.                
                <param>
                    time  The new last-modified time, measured in milliseconds since
                      the epoch (00:00:00 GMT, January 1, 1970)                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded;
                      &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
                <throws>
                    IllegalArgumentException  If the argument is negative                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the named file                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setLastModified" type="boolean" line="986">
                <params>
                    <param name="time" type="long"/>
                </params>
                <declaration name="security" type="SecurityManager" line="988"/>
                <scope line="989"/>
            </method>
            <javadoc line="994">
                Marks the file or directory named by this abstract pathname so that
                  only read operations are allowed.  After invoking this method the file
                  or directory is guaranteed not to change until it is either deleted or
                  marked to allow write access.  Whether or not a read-only file or
                  directory may be deleted depends upon the underlying system.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded;
                      &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the named file                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="setReadOnly" type="boolean" line="1006">
                <declaration name="security" type="SecurityManager" line="1007"/>
                <scope line="1008"/>
            </method>
            <javadoc line="1013">
                Sets the owner&apos;s or everybody&apos;s write permission for this abstract
                  pathname.
                  &lt;p&gt; The {@link java.nio.file.Files} class defines methods that operate on
                  file attributes including file permissions. This may be used when finer
                  manipulation of file permissions is required.                
                <param>
                    writableIf &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow write
                      operations; if &lt;code&gt;false&lt;/code&gt; to disallow write operations                    
                </param>
                <param>
                    ownerOnlyIf &lt;code&gt;true&lt;/code&gt;, the write permission applies only to the
                      owner&apos;s write permission; otherwise, it applies to everybody.  If
                      the underlying file system can not distinguish the owner&apos;s write
                      permission from that of others, then the permission will apply to
                      everybody, regardless of this value.                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded. The
                      operation will fail if the user does not have permission to change
                      the access permissions of this abstract pathname.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the named file                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setWritable" type="boolean" line="1033">
                <params>
                    <param name="writable" type="boolean"/>
                    <param name="ownerOnly" type="boolean"/>
                </params>
                <declaration name="security" type="SecurityManager" line="1034"/>
                <scope line="1035"/>
            </method>
            <javadoc line="1040">
                A convenience method to set the owner&apos;s write permission for this abstract
                  pathname.
                  &lt;p&gt; An invocation of this method of the form &lt;tt&gt;file.setWritable(arg)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;pre&gt;
                  file.setWritable(arg, true) &lt;/pre&gt;                
                <param>
                    writableIf &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow write
                      operations; if &lt;code&gt;false&lt;/code&gt; to disallow write operations                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
                      operation will fail if the user does not have permission to
                      change the access permissions of this abstract pathname.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the file                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setWritable" type="boolean" line="1056">
                <params>
                    <param name="writable" type="boolean"/>
                </params>
            </method>
            <javadoc line="1059">
                Sets the owner&apos;s or everybody&apos;s read permission for this abstract
                  pathname.
                  &lt;p&gt; The {@link java.nio.file.Files} class defines methods that operate on
                  file attributes including file permissions. This may be used when finer
                  manipulation of file permissions is required.                
                <param>
                    readableIf &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow read
                      operations; if &lt;code&gt;false&lt;/code&gt; to disallow read operations                    
                </param>
                <param>
                    ownerOnlyIf &lt;code&gt;true&lt;/code&gt;, the read permission applies only to the
                      owner&apos;s read permission; otherwise, it applies to everybody.  If
                      the underlying file system can not distinguish the owner&apos;s read
                      permission from that of others, then the permission will apply to
                      everybody, regardless of this value.                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
                      operation will fail if the user does not have permission to
                      change the access permissions of this abstract pathname.  If
                      &lt;code&gt;readable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
                      file system does not implement a read permission, then the
                      operation will fail.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the file                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setReadable" type="boolean" line="1082">
                <params>
                    <param name="readable" type="boolean"/>
                    <param name="ownerOnly" type="boolean"/>
                </params>
                <declaration name="security" type="SecurityManager" line="1083"/>
                <scope line="1084"/>
            </method>
            <javadoc line="1089">
                A convenience method to set the owner&apos;s read permission for this abstract
                  pathname.
                  &lt;p&gt;An invocation of this method of the form &lt;tt&gt;file.setReadable(arg)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;pre&gt;
                  file.setReadable(arg, true) &lt;/pre&gt;                
                <param>
                    readableIf &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow read
                      operations; if &lt;code&gt;false&lt;/code&gt; to disallow read operations                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
                      operation will fail if the user does not have permission to
                      change the access permissions of this abstract pathname.  If
                      &lt;code&gt;readable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
                      file system does not implement a read permission, then the
                      operation will fail.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the file                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setReadable" type="boolean" line="1108">
                <params>
                    <param name="readable" type="boolean"/>
                </params>
            </method>
            <javadoc line="1111">
                Sets the owner&apos;s or everybody&apos;s execute permission for this abstract
                  pathname.
                  &lt;p&gt; The {@link java.nio.file.Files} class defines methods that operate on
                  file attributes including file permissions. This may be used when finer
                  manipulation of file permissions is required.                
                <param>
                    executableIf &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow execute
                      operations; if &lt;code&gt;false&lt;/code&gt; to disallow execute operations                    
                </param>
                <param>
                    ownerOnlyIf &lt;code&gt;true&lt;/code&gt;, the execute permission applies only to the
                      owner&apos;s execute permission; otherwise, it applies to everybody.
                      If the underlying file system can not distinguish the owner&apos;s
                      execute permission from that of others, then the permission will
                      apply to everybody, regardless of this value.                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
                      operation will fail if the user does not have permission to
                      change the access permissions of this abstract pathname.  If
                      &lt;code&gt;executable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
                      file system does not implement an execute permission, then the
                      operation will fail.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the file                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setExecutable" type="boolean" line="1134">
                <params>
                    <param name="executable" type="boolean"/>
                    <param name="ownerOnly" type="boolean"/>
                </params>
                <declaration name="security" type="SecurityManager" line="1135"/>
                <scope line="1136"/>
            </method>
            <javadoc line="1141">
                A convenience method to set the owner&apos;s execute permission for this abstract
                  pathname.
                  &lt;p&gt;An invocation of this method of the form &lt;tt&gt;file.setExcutable(arg)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;pre&gt;
                  file.setExecutable(arg, true) &lt;/pre&gt;                
                <param>
                    executableIf &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow execute
                      operations; if &lt;code&gt;false&lt;/code&gt; to disallow execute operations                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
                      operation will fail if the user does not have permission to
                      change the access permissions of this abstract pathname.  If
                      &lt;code&gt;executable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
                      file system does not implement an excute permission, then the
                      operation will fail.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method denies write access to the file                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="setExecutable" type="boolean" line="1160">
                <params>
                    <param name="executable" type="boolean"/>
                </params>
            </method>
            <javadoc line="1163">
                Tests whether the application can execute the file denoted by this
                  abstract pathname.                
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the abstract pathname exists
                      &lt;em&gt;and&lt;/em&gt; the application is allowed to execute the file                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkExec(java.lang.String)}&lt;/code&gt;
                      method denies execute access to the file                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="canExecute" type="boolean" line="1172">
                <declaration name="security" type="SecurityManager" line="1173"/>
                <scope line="1174"/>
            </method>
            <javadoc line="1179">
                List the available filesystem roots.
                  &lt;p&gt; A particular Java platform may support zero or more
                  hierarchically-organized file systems.  Each file system has a{@code root} directory from which all other files in that file system
                  can be reached.  Windows platforms, for example, have a root directory
                  for each active drive; UNIX platforms have a single root directory,
                  namely {@code &quot;/&quot;}.  The set of available filesystem roots is affected
                  by various system-level operations such as the insertion or ejection of
                  removable media and the disconnecting or unmounting of physical or
                  virtual disk drives.
                  &lt;p&gt; This method returns an array of {@code File} objects that denote the
                  root directories of the available filesystem roots.  It is guaranteed
                  that the canonical pathname of any file physically present on the local
                  machine will begin with one of the roots returned by this method.
                  &lt;p&gt; The canonical pathname of a file that resides on some other machine
                  and is accessed via a remote-filesystem protocol such as SMB or NFS may
                  or may not begin with one of the roots returned by this method.  If the
                  pathname of a remote file is syntactically indistinguishable from the
                  pathname of a local file then it will begin with one of the roots
                  returned by this method.  Thus, for example, {@code File} objects
                  denoting the root directories of the mapped network drives of a Windows
                  platform will be returned by this method, while {@code File} objects
                  containing UNC pathnames will not be returned by this method.
                  &lt;p&gt; Unlike most methods in this class, this method does not throw
                  security exceptions.  If a security manager exists and its {@link SecurityManager#checkRead(String)} method denies read access to a
                  particular root directory, then that directory will not appear in the
                  result.                
                <return>
                    An array of {@code File} objects denoting the available
                      filesystem roots, or {@code null} if the set of roots could not
                      be determined.  The array will be empty if there are no
                      filesystem roots.                    
                </return>
                <since>
                    1.2                    
                </since>
                <see>
                    java.nio.file.FileStore                    
                </see>
            </javadoc>
            <method name="listRoots" type="File[]" line="1213"/>
            <javadoc line="1216">
                Returns the size of the partition &lt;a href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this
                  abstract pathname.                
                <return>
                    The size, in bytes, of the partition or &lt;tt&gt;0L&lt;/tt&gt; if this
                      abstract pathname does not name a partition                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager has been installed and it denies{@link RuntimePermission}&lt;tt&gt;(&quot;getFileSystemAttributes&quot;)&lt;/tt&gt;
                      or its {@link SecurityManager#checkRead(String)} method denies
                      read access to the file named by this abstract pathname                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getTotalSpace" type="long" line="1226">
                <declaration name="sm" type="SecurityManager" line="1227"/>
                <scope line="1228"/>
            </method>
            <javadoc line="1234">
                Returns the number of unallocated bytes in the partition &lt;a
                  href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this abstract path name.
                  &lt;p&gt; The returned number of unallocated bytes is a hint, but not
                  a guarantee, that it is possible to use most or any of these
                  bytes.  The number of unallocated bytes is most likely to be
                  accurate immediately after this call.  It is likely to be made
                  inaccurate by any external I/O operations including those made
                  on the system outside of this virtual machine.  This method
                  makes no guarantee that write operations to this file system
                  will succeed.                
                <return>
                    The number of unallocated bytes on the partition &lt;tt&gt;0L&lt;/tt&gt;
                      if the abstract pathname does not name a partition.  This
                      value will be less than or equal to the total file system size
                      returned by {@link #getTotalSpace}.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager has been installed and it denies{@link RuntimePermission}&lt;tt&gt;(&quot;getFileSystemAttributes&quot;)&lt;/tt&gt;
                      or its {@link SecurityManager#checkRead(String)} method denies
                      read access to the file named by this abstract pathname                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getFreeSpace" type="long" line="1254">
                <declaration name="sm" type="SecurityManager" line="1255"/>
                <scope line="1256"/>
            </method>
            <javadoc line="1262">
                Returns the number of bytes available to this virtual machine on the
                  partition &lt;a href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this abstract pathname.  When
                  possible, this method checks for write permissions and other operating
                  system restrictions and will therefore usually provide a more accurate
                  estimate of how much new data can actually be written than {@link #getFreeSpace}.
                  &lt;p&gt; The returned number of available bytes is a hint, but not a
                  guarantee, that it is possible to use most or any of these bytes.  The
                  number of unallocated bytes is most likely to be accurate immediately
                  after this call.  It is likely to be made inaccurate by any external
                  I/O operations including those made on the system outside of this
                  virtual machine.  This method makes no guarantee that write operations
                  to this file system will succeed.                
                <return>
                    The number of available bytes on the partition or &lt;tt&gt;0L&lt;/tt&gt;
                      if the abstract pathname does not name a partition.  On
                      systems where this information is not available, this method
                      will be equivalent to a call to {@link #getFreeSpace}.                    
                </return>
                <throws>
                    SecurityExceptionIf a security manager has been installed and it denies{@link RuntimePermission}&lt;tt&gt;(&quot;getFileSystemAttributes&quot;)&lt;/tt&gt;
                      or its {@link SecurityManager#checkRead(String)} method denies
                      read access to the file named by this abstract pathname                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getUsableSpace" type="long" line="1284">
                <declaration name="sm" type="SecurityManager" line="1285"/>
                <scope line="1286"/>
            </method>
            <class name="TempDirectory" line="1292">
                <method name="TempDirectory" type="constructor" line="1293"/>
                <declaration name="tmpdir" type="File" line="1295"/>
                <method name="location" type="File" line="1296"/>
                <declaration name="random" type="SecureRandom" line="1299"/>
                <method name="generateFile" type="File" line="1300">
                    <params>
                        <param name="prefix" type="String"/>
                        <param name="suffix" type="String"/>
                        <param name="dir" type="File"/>
                    </params>
                    <declaration name="n" type="long" line="1301"/>
                    <scope line="1302"/>
                    <scope line="1305"/>
                </method>
            </class>
            <javadoc line="1311">
                &lt;p&gt; Creates a new empty file in the specified directory, using the
                  given prefix and suffix strings to generate its name.  If this method
                  returns successfully then it is guaranteed that:
                  &lt;ol&gt;
                  &lt;li&gt; The file denoted by the returned abstract pathname did not exist
                  before this method was invoked, and
                  &lt;li&gt; Neither this method nor any of its variants will return the same
                  abstract pathname again in the current invocation of the virtual
                  machine.
                  &lt;/ol&gt;
                  This method provides only part of a temporary-file facility.  To arrange
                  for a file created by this method to be deleted automatically, use the
                  &lt;code&gt;{@link #deleteOnExit}&lt;/code&gt; method.
                  &lt;p&gt; The &lt;code&gt;prefix&lt;/code&gt; argument must be at least three characters
                  long.  It is recommended that the prefix be a short, meaningful string
                  such as &lt;code&gt;&quot;hjb&quot;&lt;/code&gt; or &lt;code&gt;&quot;mail&quot;&lt;/code&gt;.  The
                  &lt;code&gt;suffix&lt;/code&gt; argument may be &lt;code&gt;null&lt;/code&gt;, in which case the
                  suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used.
                  &lt;p&gt; To create the new file, the prefix and the suffix may first be
                  adjusted to fit the limitations of the underlying platform.  If the
                  prefix is too long then it will be truncated, but its first three
                  characters will always be preserved.  If the suffix is too long then it
                  too will be truncated, but if it begins with a period character
                  (&lt;code&gt;&apos;.&apos;&lt;/code&gt;) then the period and the first three characters
                  following it will always be preserved.  Once these adjustments have been
                  made the name of the new file will be generated by concatenating the
                  prefix, five or more internally-generated characters, and the suffix.
                  &lt;p&gt; If the &lt;code&gt;directory&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; then the
                  system-dependent default temporary-file directory will be used.  The
                  default temporary-file directory is specified by the system property
                  &lt;code&gt;java.io.tmpdir&lt;/code&gt;.  On UNIX systems the default value of this
                  property is typically &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; or &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt;; on
                  Microsoft Windows systems it is typically &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt;.  A different
                  value may be given to this system property when the Java virtual machine
                  is invoked, but programmatic changes to this property are not guaranteed
                  to have any effect upon the temporary directory used by this method.                
                <param>
                    prefix     The prefix string to be used in generating the file&apos;s
                      name; must be at least three characters long                    
                </param>
                <param>
                    suffix     The suffix string to be used in generating the file&apos;s
                      name; may be &lt;code&gt;null&lt;/code&gt;, in which case the
                      suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used                    
                </param>
                <param>
                    directory  The directory in which the file is to be created, or
                      &lt;code&gt;null&lt;/code&gt; if the default temporary-file
                      directory is to be used                    
                </param>
                <return>
                    An abstract pathname denoting a newly-created empty file                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the &lt;code&gt;prefix&lt;/code&gt; argument contains fewer than three
                      characters                    
                </throws>
                <throws>
                    IOException  If a file could not be created                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method does not allow a file to be created                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="createTempFile" type="File" line="1364">
                <params>
                    <param name="prefix" type="String"/>
                    <param name="suffix" type="String"/>
                    <param name="directory" type="File"/>
                </params>
                <declaration name="tmpdir" type="File" line="1367"/>
                <declaration name="sm" type="SecurityManager" line="1368"/>
                <declaration name="f" type="File" line="1369"/>
                <scope line="1370">
                    <scope line="1372">
                        <scope line="1373"/>
                        <scope line="1376"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1385">
                Creates an empty file in the default temporary-file directory, using
                  the given prefix and suffix to generate its name. Invoking this method
                  is equivalent to invoking &lt;code&gt;{@link #createTempFile(java.lang.String,java.lang.String,java.io.File)createTempFile(prefix,&amp;nbsp;suffix,&amp;nbsp;null)}&lt;/code&gt;.
                  &lt;p&gt; The {@link java.nio.file.Files#createTempFile(String,String,java.nio.file.attribute.FileAttribute[])Files.createTempFile} method provides an alternative method to create an
                  empty file in the temporary-file directory. Files created by that method
                  may have more restrictive access permissions to files created by this
                  method and so may be more suited to security-sensitive applications.                
                <param>
                    prefix     The prefix string to be used in generating the file&apos;s
                      name; must be at least three characters long                    
                </param>
                <param>
                    suffix     The suffix string to be used in generating the file&apos;s
                      name; may be &lt;code&gt;null&lt;/code&gt;, in which case the
                      suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used                    
                </param>
                <return>
                    An abstract pathname denoting a newly-created empty file                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf the &lt;code&gt;prefix&lt;/code&gt; argument contains fewer than three
                      characters                    
                </throws>
                <throws>
                    IOException  If a file could not be created                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
                      method does not allow a file to be created                    
                </throws>
                <since>
                    1.2                    
                </since>
                <see>
                    java.nio.file.Files#createTempDirectory(String,FileAttribute[])                    
                </see>
            </javadoc>
            <method name="createTempFile" type="File" line="1407">
                <params>
                    <param name="prefix" type="String"/>
                    <param name="suffix" type="String"/>
                </params>
            </method>
            <javadoc line="1410">
                Compares two abstract pathnames lexicographically.  The ordering
                  defined by this method depends upon the underlying system.  On UNIX
                  systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
                  systems it is not.                
                <param>
                    pathname  The abstract pathname to be compared to this abstract
                      pathname                    
                </param>
                <return>
                    Zero if the argument is equal to this abstract pathname, a
                      value less than zero if this abstract pathname is
                      lexicographically less than the argument, or a value greater
                      than zero if this abstract pathname is lexicographically
                      greater than the argument                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="compareTo" type="int" line="1424">
                <params>
                    <param name="pathname" type="File"/>
                </params>
            </method>
            <javadoc line="1427">
                Tests this abstract pathname for equality with the given object.
                  Returns &lt;code&gt;true&lt;/code&gt; if and only if the argument is not
                  &lt;code&gt;null&lt;/code&gt; and is an abstract pathname that denotes the same file
                  or directory as this abstract pathname.  Whether or not two abstract
                  pathnames are equal depends upon the underlying system.  On UNIX
                  systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
                  systems it is not.                
                <param>
                    obj   The object to be compared with this abstract pathname                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if and only if the objects are the same;
                      &lt;code&gt;false&lt;/code&gt; otherwise                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1439">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="1440"/>
            </method>
            <javadoc line="1445">
                Computes a hash code for this abstract pathname.  Because equality of
                  abstract pathnames is inherently system-dependent, so is the computation
                  of their hash codes.  On UNIX systems, the hash code of an abstract
                  pathname is equal to the exclusive &lt;em&gt;or&lt;/em&gt; of the hash code
                  of its pathname string and the decimal value
                  &lt;code&gt;1234321&lt;/code&gt;.  On Microsoft Windows systems, the hash
                  code is equal to the exclusive &lt;em&gt;or&lt;/em&gt; of the hash code of
                  its pathname string converted to lower case and the decimal
                  value &lt;code&gt;1234321&lt;/code&gt;.  Locale is not taken into account on
                  lowercasing the pathname string.                
                <return>
                    A hash code for this abstract pathname                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="1458"/>
            <javadoc line="1461">
                Returns the pathname string of this abstract pathname.  This is just the
                  string returned by the &lt;code&gt;{@link #getPath}&lt;/code&gt; method.                
                <return>
                    The string form of this abstract pathname                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1466"/>
            <javadoc line="1469">
                WriteObject is called to save this filename.
                  The separator character is saved also so it can be replaced
                  in case the path is reconstituted on a different host type.
                  &lt;p&gt;                
                <serialData>
                    Default fields followed by separator character.                    
                </serialData>
            </javadoc>
            <method name="writeObject" type="void" line="1476">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
            </method>
            <javadoc line="1480">
                readObject is called to restore this filename.
                  The original separator character is read.  If it is different
                  than the separator character on this system, then the old separator
                  is replaced by the local separator.                
            </javadoc>
            <method name="readObject" type="void" line="1486">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <declaration name="fields" type="ObjectInputStream.GetField" line="1487"/>
                <declaration name="pathField" type="String" line="1488"/>
                <declaration name="sep" type="char" line="1489"/>
            </method>
            <declaration name="serialVersionUID" type="long" line="1494"/>
            <javadoc line="1494">
                use serialVersionUID from JDK 1.0.2 for interoperability                
            </javadoc>
            <declaration name="filePath" type="Path" line="1498"/>
            <javadoc line="1499">
                Returns a {@link Path java.nio.file.Path} object constructed from the
                  this abstract path. The resulting {@code Path} is associated with the{@link java.nio.file.FileSystems#getDefault default-filesystem}.
                  &lt;p&gt; The first invocation of this method works as if invoking it were
                  equivalent to evaluating the expression:
                  &lt;blockquote&gt;&lt;pre&gt;{@link java.nio.file.FileSystems#getDefault FileSystems.getDefault}().{@link java.nio.file.FileSystem#getPath getPath}(this.{@link #getPath getPath}());
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  Subsequent invocations of this method return the same {@code Path}.
                  &lt;p&gt; If this abstract pathname is the empty abstract pathname then this
                  method returns a {@code Path} that may be used to access the current
                  user directory.                
                <return>
                    a {@code Path} constructed from this abstract path                    
                </return>
                <throws>
                    java.nio.file.InvalidPathExceptionif a {@code Path} object cannot be constructed from the abstract
                      path (see {@link java.nio.file.FileSystem#getPath FileSystem.getPath})                    
                </throws>
                <since>
                    1.7                    
                </since>
                <see>
                    Path#toFile                    
                </see>
            </javadoc>
            <method name="toPath" type="Path" line="1516">
                <declaration name="result" type="Path" line="1517"/>
                <scope line="1518">
                    <scope line="1519">
                        <scope line="1521"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>