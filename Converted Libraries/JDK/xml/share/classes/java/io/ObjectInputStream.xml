<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.io">
        <import package="java.io.ObjectStreamClass.WeakClassKey"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.lang.reflect.Array"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.lang.reflect.Proxy"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.concurrent.ConcurrentMap"/>
        <import package="java.util.concurrent.atomic.AtomicBoolean"/>
        <import package="java.io.ObjectStreamClass.processQueue"/>
        <class name="ObjectInputStream" line="45">
            <extends class="InputStream"/>
            <implements interface="ObjectInput"/>
            <implements interface="ObjectStreamConstants"/>
            <javadoc line="45">
                An ObjectInputStream deserializes primitive data and objects previously
                  written using an ObjectOutputStream.
                  &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
                  persistent storage for graphs of objects when used with a FileOutputStream
                  and FileInputStream respectively.  ObjectInputStream is used to recover
                  those objects previously serialized. Other uses include passing objects
                  between hosts using a socket stream or for marshaling and unmarshaling
                  arguments and parameters in a remote communication system.
                  &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
                  created from the stream match the classes present in the Java Virtual
                  Machine.  Classes are loaded as required using the standard mechanisms.
                  &lt;p&gt;Only objects that support the java.io.Serializable or
                  java.io.Externalizable interface can be read from streams.
                  &lt;p&gt;The method &lt;code&gt;readObject&lt;/code&gt; is used to read an object from the
                  stream.  Java&apos;s safe casting should be used to get the desired type.  In
                  Java, strings and arrays are objects and are treated as objects during
                  serialization. When read they need to be cast to the expected type.
                  &lt;p&gt;Primitive data types can be read from the stream using the appropriate
                  method on DataInput.
                  &lt;p&gt;The default deserialization mechanism for objects restores the contents
                  of each field to the value and type it had when it was written.  Fields
                  declared as transient or static are ignored by the deserialization process.
                  References to other objects cause those objects to be read from the stream
                  as necessary.  Graphs of objects are restored correctly using a reference
                  sharing mechanism.  New objects are always allocated when deserializing,
                  which prevents existing objects from being overwritten.
                  &lt;p&gt;Reading an object is analogous to running the constructors of a new
                  object.  Memory is allocated for the object and initialized to zero (NULL).
                  No-arg constructors are invoked for the non-serializable classes and then
                  the fields of the serializable classes are restored from the stream starting
                  with the serializable class closest to java.lang.object and finishing with
                  the object&apos;s most specific class.
                  &lt;p&gt;For example to read from a stream as written by the example in
                  ObjectOutputStream:
                  &lt;br&gt;
                  &lt;pre&gt;
                  FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);
                  ObjectInputStream ois = new ObjectInputStream(fis);
                  int i = ois.readInt();
                  String today = (String) ois.readObject();
                  Date date = (Date) ois.readObject();
                  ois.close();
                  &lt;/pre&gt;
                  &lt;p&gt;Classes control how they are serialized by implementing either the
                  java.io.Serializable or java.io.Externalizable interfaces.
                  &lt;p&gt;Implementing the Serializable interface allows object serialization to
                  save and restore the entire state of the object and it allows classes to
                  evolve between the time the stream is written and the time it is read.  It
                  automatically traverses references between objects, saving and restoring
                  entire graphs.
                  &lt;p&gt;Serializable classes that require special handling during the
                  serialization and deserialization process should implement the following
                  methods:&lt;p&gt;
                  &lt;pre&gt;
                  private void writeObject(java.io.ObjectOutputStream stream)
                  throws IOException;
                  private void readObject(java.io.ObjectInputStream stream)
                  throws IOException, ClassNotFoundException;
                  private void readObjectNoData()
                  throws ObjectStreamException;
                  &lt;/pre&gt;
                  &lt;p&gt;The readObject method is responsible for reading and restoring the state
                  of the object for its particular class using data written to the stream by
                  the corresponding writeObject method.  The method does not need to concern
                  itself with the state belonging to its superclasses or subclasses.  State is
                  restored by reading data from the ObjectInputStream for the individual
                  fields and making assignments to the appropriate fields of the object.
                  Reading primitive data types is supported by DataInput.
                  &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
                  custom data written by the corresponding writeObject method will cause an
                  OptionalDataException to be thrown with an eof field value of true.
                  Non-object reads which exceed the end of the allotted data will reflect the
                  end of data in the same way that they would indicate the end of the stream:
                  bytewise reads will return -1 as the byte read or number of bytes read, and
                  primitive reads will throw EOFExceptions.  If there is no corresponding
                  writeObject method, then the end of default serialized data marks the end of
                  the allotted data.
                  &lt;p&gt;Primitive and object read calls issued from within a readExternal method
                  behave in the same manner--if the stream is already positioned at the end of
                  data written by the corresponding writeExternal method, object reads will
                  throw OptionalDataExceptions with eof set to true, bytewise reads will
                  return -1, and primitive reads will throw EOFExceptions.  Note that this
                  behavior does not hold for streams written with the old
                  &lt;code&gt;ObjectStreamConstants.PROTOCOL_VERSION_1&lt;/code&gt; protocol, in which the
                  end of data written by writeExternal methods is not demarcated, and hence
                  cannot be detected.
                  &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
                  the object for its particular class in the event that the serialization
                  stream does not list the given class as a superclass of the object being
                  deserialized.  This may occur in cases where the receiving party uses a
                  different version of the deserialized instance&apos;s class than the sending
                  party, and the receiver&apos;s version extends classes that are not extended by
                  the sender&apos;s version.  This may also occur if the serialization stream has
                  been tampered; hence, readObjectNoData is useful for initializing
                  deserialized objects properly despite a &quot;hostile&quot; or incomplete source
                  stream.
                  &lt;p&gt;Serialization does not read or assign values to the fields of any object
                  that does not implement the java.io.Serializable interface.  Subclasses of
                  Objects that are not serializable can be serializable. In this case the
                  non-serializable class must have a no-arg constructor to allow its fields to
                  be initialized.  In this case it is the responsibility of the subclass to
                  save and restore the state of the non-serializable class. It is frequently
                  the case that the fields of that class are accessible (public, package, or
                  protected) or that there are get and set methods that can be used to restore
                  the state.
                  &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
                  the ObjectInputStream and abort the reading process.
                  &lt;p&gt;Implementing the Externalizable interface allows the object to assume
                  complete control over the contents and format of the object&apos;s serialized
                  form.  The methods of the Externalizable interface, writeExternal and
                  readExternal, are called to save and restore the objects state.  When
                  implemented by a class they can write and read their own state using all of
                  the methods of ObjectOutput and ObjectInput.  It is the responsibility of
                  the objects to handle any versioning that occurs.
                  &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
                  externalizable objects.  The serialized form of an enum constant consists
                  solely of its name; field values of the constant are not transmitted.  To
                  deserialize an enum constant, ObjectInputStream reads the constant name from
                  the stream; the deserialized constant is then obtained by calling the static
                  method &lt;code&gt;Enum.valueOf(Class, String)&lt;/code&gt; with the enum constant&apos;s
                  base type and the received constant name as arguments.  Like other
                  serializable or externalizable objects, enum constants can function as the
                  targets of back references appearing subsequently in the serialization
                  stream.  The process by which enum constants are deserialized cannot be
                  customized: any class-specific readObject, readObjectNoData, and readResolve
                  methods defined by enum types are ignored during deserialization.
                  Similarly, any serialPersistentFields or serialVersionUID field declarations
                  are also ignored--all enum types have a fixed serialVersionUID of 0L.                
                <author>
                    Mike Warres                    
                </author>
                <author>
                    Roger Riggs                    
                </author>
                <see>
                    java.io.DataInput                    
                </see>
                <see>
                    java.io.ObjectOutputStream                    
                </see>
                <see>
                    java.io.Serializable                    
                </see>
                <see>
                    &lt;a href=&quot;../../../platform/serialization/spec/input.html&quot;&gt; Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <declaration name="NULL_HANDLE" type="int" line="208"/>
            <javadoc line="208">
                handle value representing null                
            </javadoc>
            <declaration name="unsharedMarker" type="Object" line="211"/>
            <javadoc line="211">
                marker for unshared objects in internal handle table                
            </javadoc>
            <declaration name="primClasses" type="HashMap&lt;String,Class&lt;?&gt;&gt;" line="214"/>
            <javadoc line="214">
                table mapping primitive type names to corresponding class objects                
            </javadoc>
            <scope line="217"/>
            <class name="Caches" line="229">
                <comment line="2005">
                    REMIND: remove once hotspot inlines Float.intBitsToFloat                    
                </comment>
                <comment line="2013">
                    REMIND: remove once hotspot inlines Double.longBitsToDouble                    
                </comment>
                <comment line="2029">
                    REMIND: change name to something more accurate?                    
                </comment>
                <comment line="2357">
                    block data state fields; values meaningful only when blkmode true                    
                </comment>
                <comment line="2578">
                                        
                </comment>
                <comment line="2579">
                    The following methods are equivalent to their counterparts in
                     InputStream, except that they interpret data block boundaries and
                     read the requested data from within data blocks when in block data
                     mode.                    
                </comment>
                <comment line="2696">
                                        
                </comment>
                <comment line="2697">
                    The following methods are equivalent to their counterparts in
                     DataInputStream, except that they interpret data block boundaries
                     and read the requested data from within data blocks when in block
                     data mode.                    
                </comment>
                <comment line="2845">
                                        
                </comment>
                <comment line="2846">
                    The following methods read in spans of primitive data values.
                     Though equivalent to calling the corresponding primitive read
                     methods repeatedly, these methods are optimized for reading groups
                     of primitive data values more efficiently.                    
                </comment>
                <comment line="3209">
                    REMIND: add full description of exception propagation algorithm?                    
                </comment>
                <comment line="3212">
                                        
                </comment>
                <declaration name="subclassAudits" type="ConcurrentMap&lt;WeakClassKey,Boolean&gt;" line="230"/>
                <javadoc line="230">
                    cache of subclass security audit results                    
                </javadoc>
                <declaration name="subclassAuditsQueue" type="ReferenceQueue&lt;Class&lt;?&gt;&gt;" line="234"/>
                <javadoc line="234">
                    queue for WeakReferences to audited subclasses                    
                </javadoc>
            </class>
            <declaration name="bin" type="BlockDataInputStream" line="239"/>
            <javadoc line="239">
                filter stream for handling block data conversion                
            </javadoc>
            <declaration name="vlist" type="ValidationList" line="241"/>
            <javadoc line="241">
                validation callback list                
            </javadoc>
            <declaration name="depth" type="int" line="243"/>
            <javadoc line="243">
                recursion depth                
            </javadoc>
            <declaration name="closed" type="boolean" line="245"/>
            <javadoc line="245">
                whether stream is closed                
            </javadoc>
            <declaration name="handles" type="HandleTable" line="248"/>
            <javadoc line="248">
                wire handle -&gt; obj/exception map                
            </javadoc>
            <declaration name="passHandle" type="int" line="250"/>
            <javadoc line="250">
                scratch field for passing handle values up/down call stack                
            </javadoc>
            <declaration name="defaultDataEnd" type="boolean" line="252"/>
            <javadoc line="252">
                flag set when at end of field value block with no TC_ENDBLOCKDATA                
            </javadoc>
            <declaration name="primVals" type="byte[]" line="255"/>
            <javadoc line="255">
                buffer for reading primitive field values                
            </javadoc>
            <declaration name="enableOverride" type="boolean" line="258"/>
            <javadoc line="258">
                if true, invoke readObjectOverride() instead of readObject()                
            </javadoc>
            <declaration name="enableResolve" type="boolean" line="260"/>
            <javadoc line="260">
                if true, invoke resolveObject()                
            </javadoc>
            <declaration name="curContext" type="SerialCallbackContext" line="263"/>
            <javadoc line="263">
                Context during upcalls to class-defined readObject methods; holds
                  object currently being deserialized and descriptor for current class.
                  Null when not during readObject upcall.                
            </javadoc>
            <javadoc line="270">
                Creates an ObjectInputStream that reads from the specified InputStream.
                  A serialization stream header is read from the stream and verified.
                  This constructor will block until the corresponding ObjectOutputStream
                  has written and flushed the header.
                  &lt;p&gt;If a security manager is installed, this constructor will check for
                  the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
                  directly or indirectly by the constructor of a subclass which overrides
                  the ObjectInputStream.readFields or ObjectInputStream.readUnshared
                  methods.                
                <param>
                    in input stream to read from                    
                </param>
                <throws>
                    StreamCorruptedException if the stream header is incorrect                    
                </throws>
                <throws>
                    IOException if an I/O error occurs while reading stream header                    
                </throws>
                <throws>
                    SecurityException if untrusted subclass illegally overrides
                      security-sensitive methods                    
                </throws>
                <throws>
                    NullPointerException if &lt;code&gt;in&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </throws>
                <see>
                    ObjectInputStream#ObjectInputStream()                    
                </see>
                <see>
                    ObjectInputStream#readFields()                    
                </see>
                <see>
                    ObjectOutputStream#ObjectOutputStream(OutputStream)                    
                </see>
            </javadoc>
            <method name="ObjectInputStream" type="constructor" line="292">
                <params>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <javadoc line="302">
                Provide a way for subclasses that are completely reimplementing
                  ObjectInputStream to not have to allocate private data just used by this
                  implementation of ObjectInputStream.
                  &lt;p&gt;If there is a security manager installed, this method first calls the
                  security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method with the
                  &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;
                  permission to ensure it&apos;s ok to enable subclassing.                
                <throws>
                    SecurityException if a security manager exists and its
                      &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling
                      subclassing.                    
                </throws>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.io.SerializablePermission                    
                </see>
            </javadoc>
            <method name="ObjectInputStream" type="constructor" line="318">
                <declaration name="sm" type="SecurityManager" line="319"/>
                <scope line="320"/>
            </method>
            <javadoc line="329">
                Read an object from the ObjectInputStream.  The class of the object, the
                  signature of the class, and the values of the non-transient and
                  non-static fields of the class and all of its supertypes are read.
                  Default deserializing for a class can be overriden using the writeObject
                  and readObject methods.  Objects referenced by this object are read
                  transitively so that a complete equivalent graph of objects is
                  reconstructed by readObject.
                  &lt;p&gt;The root object is completely restored when all of its fields and the
                  objects it references are completely restored.  At this point the object
                  validation callbacks are executed in order based on their registered
                  priorities. The callbacks are registered by objects (in the readObject
                  special methods) as they are individually restored.
                  &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
                  classes that should not be deserialized.  All exceptions are fatal to
                  the InputStream and leave it in an indeterminate state; it is up to the
                  caller to ignore or recover the stream state.                
                <throws>
                    ClassNotFoundException Class of a serialized object cannot be
                      found.                    
                </throws>
                <throws>
                    InvalidClassException Something is wrong with a class used by
                      serialization.                    
                </throws>
                <throws>
                    StreamCorruptedException Control information in the
                      stream is inconsistent.                    
                </throws>
                <throws>
                    OptionalDataException Primitive data was found in the
                      stream instead of objects.                    
                </throws>
                <throws>
                    IOException Any of the usual Input/Output related exceptions.                    
                </throws>
            </javadoc>
            <method name="readObject" type="Object" line="361">
                <comment line="367">
                    if nested read, passHandle contains handle of enclosing object                    
                </comment>
                <scope line="362"/>
                <declaration name="outerHandle" type="int" line="367"/>
                <scope line="368">
                    <declaration name="obj" type="Object" line="369"/>
                    <declaration name="ex" type="ClassNotFoundException" line="371"/>
                    <scope line="372"/>
                    <scope line="375"/>
                </scope>
                <scope line="379">
                    <scope line="381"/>
                </scope>
            </method>
            <javadoc line="387">
                This method is called by trusted subclasses of ObjectOutputStream that
                  constructed ObjectOutputStream using the protected no-arg constructor.
                  The subclass is expected to provide an override method with the modifier
                  &quot;final&quot;.                
                <return>
                    the Object read from the stream.                    
                </return>
                <throws>
                    ClassNotFoundException Class definition of a serialized object
                      cannot be found.                    
                </throws>
                <throws>
                    OptionalDataException Primitive data was found in the stream
                      instead of objects.                    
                </throws>
                <throws>
                    IOException if I/O errors occurred while reading from the
                      underlying stream                    
                </throws>
                <see>
                    #ObjectInputStream()                    
                </see>
                <see>
                    #readObject()                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="readObjectOverride" type="Object" line="406"/>
            <javadoc line="410">
                Reads an &quot;unshared&quot; object from the ObjectInputStream.  This method is
                  identical to readObject, except that it prevents subsequent calls to
                  readObject and readUnshared from returning additional references to the
                  deserialized instance obtained via this call.  Specifically:
                  &lt;ul&gt;
                  &lt;li&gt;If readUnshared is called to deserialize a back-reference (the
                  stream representation of an object which has been written
                  previously to the stream), an ObjectStreamException will be
                  thrown.
                  &lt;li&gt;If readUnshared returns successfully, then any subsequent attempts
                  to deserialize back-references to the stream handle deserialized
                  by readUnshared will cause an ObjectStreamException to be thrown.
                  &lt;/ul&gt;
                  Deserializing an object via readUnshared invalidates the stream handle
                  associated with the returned object.  Note that this in itself does not
                  always guarantee that the reference returned by readUnshared is unique;
                  the deserialized object may define a readResolve method which returns an
                  object visible to other parties, or readUnshared may return a Class
                  object or enum constant obtainable elsewhere in the stream or through
                  external means. If the deserialized object defines a readResolve method
                  and the invocation of that method returns an array, then readUnshared
                  returns a shallow clone of that array; this guarantees that the returned
                  array object is unique and cannot be obtained a second time from an
                  invocation of readObject or readUnshared on the ObjectInputStream,
                  even if the underlying data stream has been manipulated.
                  &lt;p&gt;ObjectInputStream subclasses which override this method can only be
                  constructed in security contexts possessing the
                  &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
                  instantiate such a subclass without this permission will cause a
                  SecurityException to be thrown.                
                <return>
                    reference to deserialized object                    
                </return>
                <throws>
                    ClassNotFoundException if class of an object to deserialize
                      cannot be found                    
                </throws>
                <throws>
                    StreamCorruptedException if control information in the stream
                      is inconsistent                    
                </throws>
                <throws>
                    ObjectStreamException if object to deserialize has already
                      appeared in stream                    
                </throws>
                <throws>
                    OptionalDataException if primitive data is next in stream                    
                </throws>
                <throws>
                    IOException if an I/O error occurs during deserialization                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="readUnshared" type="Object" line="455">
                <comment line="457">
                    if nested read, passHandle contains handle of enclosing object                    
                </comment>
                <declaration name="outerHandle" type="int" line="457"/>
                <scope line="458">
                    <declaration name="obj" type="Object" line="459"/>
                    <declaration name="ex" type="ClassNotFoundException" line="461"/>
                    <scope line="462"/>
                    <scope line="465"/>
                </scope>
                <scope line="469">
                    <scope line="471"/>
                </scope>
            </method>
            <javadoc line="477">
                Read the non-static and non-transient fields of the current class from
                  this stream.  This may only be called from the readObject method of the
                  class being deserialized. It will throw the NotActiveException if it is
                  called otherwise.                
                <throws>
                    ClassNotFoundException if the class of a serialized object
                      could not be found.                    
                </throws>
                <throws>
                    IOException if an I/O error occurs.                    
                </throws>
                <throws>
                    NotActiveException if the stream is not currently reading
                      objects.                    
                </throws>
            </javadoc>
            <method name="defaultReadObject" type="void" line="491">
                <comment line="502">
                    Fix for 4360508: since stream does not contain terminating
                     TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
                     knows to simulate end-of-custom-data behavior.                    
                </comment>
                <scope line="492"/>
                <declaration name="curObj" type="Object" line="495"/>
                <declaration name="curDesc" type="ObjectStreamClass" line="496"/>
                <scope line="500"/>
                <declaration name="ex" type="ClassNotFoundException" line="508"/>
                <scope line="509"/>
            </method>
            <javadoc line="514">
                Reads the persistent fields from the stream and makes them available by
                  name.                
                <return>
                    the &lt;code&gt;GetField&lt;/code&gt; object representing the persistent
                      fields of the object being deserialized                    
                </return>
                <throws>
                    ClassNotFoundException if the class of a serialized object
                      could not be found.                    
                </throws>
                <throws>
                    IOException if an I/O error occurs.                    
                </throws>
                <throws>
                    NotActiveException if the stream is not currently reading
                      objects.                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="readFields" type="ObjectInputStream.GetField" line="529">
                <comment line="541">
                    Fix for 4360508: since stream does not contain terminating
                     TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
                     knows to simulate end-of-custom-data behavior.                    
                </comment>
                <scope line="530"/>
                <declaration name="curObj" type="Object" line="533"/>
                <declaration name="curDesc" type="ObjectStreamClass" line="534"/>
                <declaration name="getField" type="GetFieldImpl" line="536"/>
                <scope line="539"/>
            </method>
            <javadoc line="551">
                Register an object to be validated before the graph is returned.  While
                  similar to resolveObject these validations are called after the entire
                  graph has been reconstituted.  Typically, a readObject method will
                  register the object with the stream so that when all of the objects are
                  restored a final set of validations can be performed.                
                <param>
                    obj the object to receive the validation callback.                    
                </param>
                <param>
                    prio controls the order of callbacks;zero is a good default.
                      Use higher numbers to be called back earlier, lower numbers for
                      later callbacks. Within a priority, callbacks are processed in
                      no particular order.                    
                </param>
                <throws>
                    NotActiveException The stream is not currently reading objects
                      so it is invalid to register a callback.                    
                </throws>
                <throws>
                    InvalidObjectException The validation object is null.                    
                </throws>
            </javadoc>
            <method name="registerValidation" type="void" line="569">
                <params>
                    <param name="obj" type="ObjectInputValidation"/>
                    <param name="prio" type="int"/>
                </params>
                <scope line="570"/>
            </method>
            <javadoc line="576">
                Load the local class equivalent of the specified stream class
                  description.  Subclasses may implement this method to allow classes to
                  be fetched from an alternate source.
                  &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is
                  &lt;code&gt;annotateClass&lt;/code&gt;.  This method will be invoked only once for
                  each unique class in the stream.  This method can be implemented by
                  subclasses to use an alternate loading mechanism but must return a
                  &lt;code&gt;Class&lt;/code&gt; object. Once returned, if the class is not an array
                  class, its serialVersionUID is compared to the serialVersionUID of the
                  serialized class, and if there is a mismatch, the deserialization fails
                  and an {@link InvalidClassException} is thrown.
                  &lt;p&gt;The default implementation of this method in
                  &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling
                  &lt;pre&gt;
                  Class.forName(desc.getName(), false, loader)
                  &lt;/pre&gt;
                  where &lt;code&gt;loader&lt;/code&gt; is determined as follows: if there is a
                  method on the current thread&apos;s stack whose declaring class was
                  defined by a user-defined class loader (and was not a generated to
                  implement reflective invocations), then &lt;code&gt;loader&lt;/code&gt; is class
                  loader corresponding to the closest such method to the currently
                  executing frame; otherwise, &lt;code&gt;loader&lt;/code&gt; is
                  &lt;code&gt;null&lt;/code&gt;. If this call results in a
                  &lt;code&gt;ClassNotFoundException&lt;/code&gt; and the name of the passed
                  &lt;code&gt;ObjectStreamClass&lt;/code&gt; instance is the Java language keyword
                  for a primitive type or void, then the &lt;code&gt;Class&lt;/code&gt; object
                  representing that primitive type or void will be returned
                  (e.g., an &lt;code&gt;ObjectStreamClass&lt;/code&gt; with the name
                  &lt;code&gt;&quot;int&quot;&lt;/code&gt; will be resolved to &lt;code&gt;Integer.TYPE&lt;/code&gt;).
                  Otherwise, the &lt;code&gt;ClassNotFoundException&lt;/code&gt; will be thrown to
                  the caller of this method.                
                <param>
                    desc an instance of class &lt;code&gt;ObjectStreamClass&lt;/code&gt;                    
                </param>
                <return>
                    a &lt;code&gt;Class&lt;/code&gt; object corresponding to &lt;code&gt;desc&lt;/code&gt;                    
                </return>
                <throws>
                    IOException any of the usual Input/Output exceptions.                    
                </throws>
                <throws>
                    ClassNotFoundException if class of a serialized object cannot
                      be found.                    
                </throws>
            </javadoc>
            <method name="resolveClass" type="Class<?>" line="619">
                <params>
                    <param name="desc" type="ObjectStreamClass"/>
                </params>
                <declaration name="name" type="String" line="620"/>
                <scope line="621"/>
                <scope line="623">
                    <declaration name="cl" type="Class&lt;?&gt;" line="624"/>
                    <scope line="625"/>
                    <scope line="627"/>
                </scope>
            </method>
            <javadoc line="633">
                Returns a proxy class that implements the interfaces named in a proxy
                  class descriptor; subclasses may implement this method to read custom
                  data from the stream along with the descriptors for dynamic proxy
                  classes, allowing them to use an alternate loading mechanism for the
                  interfaces and the proxy class.
                  &lt;p&gt;This method is called exactly once for each unique proxy class
                  descriptor in the stream.
                  &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is
                  &lt;code&gt;annotateProxyClass&lt;/code&gt;.  For a given subclass of
                  &lt;code&gt;ObjectInputStream&lt;/code&gt; that overrides this method, the
                  &lt;code&gt;annotateProxyClass&lt;/code&gt; method in the corresponding subclass of
                  &lt;code&gt;ObjectOutputStream&lt;/code&gt; must write any data or objects read by
                  this method.
                  &lt;p&gt;The default implementation of this method in
                  &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling
                  &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; with the list of &lt;code&gt;Class&lt;/code&gt;
                  objects for the interfaces that are named in the &lt;code&gt;interfaces&lt;/code&gt;
                  parameter.  The &lt;code&gt;Class&lt;/code&gt; object for each interface name
                  &lt;code&gt;i&lt;/code&gt; is the value returned by calling
                  &lt;pre&gt;
                  Class.forName(i, false, loader)
                  &lt;/pre&gt;
                  where &lt;code&gt;loader&lt;/code&gt; is that of the first non-&lt;code&gt;null&lt;/code&gt;
                  class loader up the execution stack, or &lt;code&gt;null&lt;/code&gt; if no
                  non-&lt;code&gt;null&lt;/code&gt; class loaders are on the stack (the same class
                  loader choice used by the &lt;code&gt;resolveClass&lt;/code&gt; method).  Unless any
                  of the resolved interfaces are non-public, this same value of
                  &lt;code&gt;loader&lt;/code&gt; is also the class loader passed to
                  &lt;code&gt;Proxy.getProxyClass&lt;/code&gt;; if non-public interfaces are present,
                  their class loader is passed instead (if more than one non-public
                  interface class loader is encountered, an
                  &lt;code&gt;IllegalAccessError&lt;/code&gt; is thrown).
                  If &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; throws an
                  &lt;code&gt;IllegalArgumentException&lt;/code&gt;, &lt;code&gt;resolveProxyClass&lt;/code&gt;
                  will throw a &lt;code&gt;ClassNotFoundException&lt;/code&gt; containing the
                  &lt;code&gt;IllegalArgumentException&lt;/code&gt;.                
                <param>
                    interfaces the list of interface names that were
                      deserialized in the proxy class descriptor                    
                </param>
                <return>
                    a proxy class for the specified interfaces                    
                </return>
                <throws>
                    IOException any exception thrown by the underlying
                      &lt;code&gt;InputStream&lt;/code&gt;                    
                </throws>
                <throws>
                    ClassNotFoundException if the proxy class or any of the
                      named interfaces could not be found                    
                </throws>
                <see>
                    ObjectOutputStream#annotateProxyClass(Class)                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="resolveProxyClass" type="Class<?>" line="686">
                <params>
                    <param name="interfaces" type="String[]"/>
                </params>
                <comment line="692">
                    define proxy in class loader of non-public interface(s), if any                    
                </comment>
                <declaration name="latestLoader" type="ClassLoader" line="687"/>
                <declaration name="nonPublicLoader" type="ClassLoader" line="688"/>
                <declaration name="hasNonPublicInterface" type="boolean" line="689"/>
                <declaration name="classObjs" type="Class[]" line="692"/>
                <scope line="693">
                    <declaration name="cl" type="Class" line="694"/>
                    <scope line="695">
                        <scope line="696">
                            <scope line="697"/>
                        </scope>
                        <scope line="701"/>
                    </scope>
                </scope>
                <scope line="708"/>
                <scope line="712"/>
            </method>
            <javadoc line="717">
                This method will allow trusted subclasses of ObjectInputStream to
                  substitute one object for another during deserialization. Replacing
                  objects is disabled until enableResolveObject is called. The
                  enableResolveObject method checks that the stream requesting to resolve
                  object can be trusted. Every reference to serializable objects is passed
                  to resolveObject.  To insure that the private state of objects is not
                  unintentionally exposed only trusted streams may use resolveObject.
                  &lt;p&gt;This method is called after an object has been read but before it is
                  returned from readObject.  The default resolveObject method just returns
                  the same object.
                  &lt;p&gt;When a subclass is replacing objects it must insure that the
                  substituted object is compatible with every field where the reference
                  will be stored.  Objects whose type is not a subclass of the type of the
                  field or array element abort the serialization by raising an exception
                  and the object is not be stored.
                  &lt;p&gt;This method is called only once when each object is first
                  encountered.  All subsequent references to the object will be redirected
                  to the new object.                
                <param>
                    obj object to be substituted                    
                </param>
                <return>
                    the substituted object                    
                </return>
                <throws>
                    IOException Any of the usual Input/Output exceptions.                    
                </throws>
            </javadoc>
            <method name="resolveObject" type="Object" line="744">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="748">
                Enable the stream to allow objects read from the stream to be replaced.
                  When enabled, the resolveObject method is called for every object being
                  deserialized.
                  &lt;p&gt;If &lt;i&gt;enable&lt;/i&gt; is true, and there is a security manager installed,
                  this method first calls the security manager&apos;s
                  &lt;code&gt;checkPermission&lt;/code&gt; method with the
                  &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to
                  ensure it&apos;s ok to enable the stream to allow objects read from the
                  stream to be replaced.                
                <param>
                    enable true for enabling use of &lt;code&gt;resolveObject&lt;/code&gt; for
                      every object being deserialized                    
                </param>
                <return>
                    the previous setting before this method was invoked                    
                </return>
                <throws>
                    SecurityException if a security manager exists and its
                      &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling the stream
                      to allow objects read from the stream to be replaced.                    
                </throws>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.io.SerializablePermission                    
                </see>
            </javadoc>
            <method name="enableResolveObject" type="boolean" line="771">
                <params>
                    <param name="enable" type="boolean"/>
                </params>
                <scope line="772"/>
                <scope line="775">
                    <declaration name="sm" type="SecurityManager" line="776"/>
                    <scope line="777"/>
                </scope>
            </method>
            <javadoc line="785">
                The readStreamHeader method is provided to allow subclasses to read and
                  verify their own stream headers. It reads and verifies the magic number
                  and version number.                
                <throws>
                    IOException if there are I/O errors while reading from the
                      underlying &lt;code&gt;InputStream&lt;/code&gt;                    
                </throws>
                <throws>
                    StreamCorruptedException if control information in the stream
                      is inconsistent                    
                </throws>
            </javadoc>
            <method name="readStreamHeader" type="void" line="797">
                <declaration name="s0" type="short" line="798"/>
                <declaration name="s1" type="short" line="799"/>
                <scope line="800"/>
            </method>
            <javadoc line="806">
                Read a class descriptor from the serialization stream.  This method is
                  called when the ObjectInputStream expects a class descriptor as the next
                  item in the serialization stream.  Subclasses of ObjectInputStream may
                  override this method to read in class descriptors that have been written
                  in non-standard formats (by subclasses of ObjectOutputStream which have
                  overridden the &lt;code&gt;writeClassDescriptor&lt;/code&gt; method).  By default,
                  this method reads class descriptors according to the format defined in
                  the Object Serialization specification.                
                <return>
                    the class descriptor read                    
                </return>
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
                <throws>
                    ClassNotFoundException If the Class of a serialized object used
                      in the class descriptor representation cannot be found                    
                </throws>
                <see>
                    java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="readClassDescriptor" type="ObjectStreamClass" line="825">
                <declaration name="desc" type="ObjectStreamClass" line="826"/>
            </method>
            <javadoc line="831">
                Reads a byte of data. This method will block if no input is available.                
                <return>
                    the byte read, or -1 if the end of the stream is reached.                    
                </return>
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="read" type="int" line="837"/>
            <javadoc line="841">
                Reads into an array of bytes.  This method will block until some input
                  is available. Consider using java.io.DataInputStream.readFully to read
                  exactly &apos;length&apos; bytes.                
                <param>
                    buf the buffer into which the data is read                    
                </param>
                <param>
                    off the start offset of the data                    
                </param>
                <param>
                    len the maximum number of bytes read                    
                </param>
                <return>
                    the actual number of bytes read, -1 is returned when the end of
                      the stream is reached.                    
                </return>
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
                <see>
                    java.io.DataInputStream#readFully(byte[],int,int)                    
                </see>
            </javadoc>
            <method name="read" type="int" line="854">
                <params>
                    <param name="buf" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="855"/>
                <declaration name="endoff" type="int" line="858"/>
                <scope line="859"/>
            </method>
            <javadoc line="865">
                Returns the number of bytes that can be read without blocking.                
                <return>
                    the number of available bytes.                    
                </return>
                <throws>
                    IOException if there are I/O errors while reading from the
                      underlying &lt;code&gt;InputStream&lt;/code&gt;                    
                </throws>
            </javadoc>
            <method name="available" type="int" line="872"/>
            <javadoc line="876">
                Closes the input stream. Must be called to release any resources
                  associated with the stream.                
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="close" type="void" line="882">
                <comment line="884">
                    Even if stream already closed, propagate redundant close to
                     underlying stream to stay consistent with previous implementations.                    
                </comment>
                <scope line="888"/>
            </method>
            <javadoc line="894">
                Reads in a boolean.                
                <return>
                    the boolean read.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readBoolean" type="boolean" line="901"/>
            <javadoc line="905">
                Reads an 8 bit byte.                
                <return>
                    the 8 bit byte read.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readByte" type="byte" line="912"/>
            <javadoc line="916">
                Reads an unsigned 8 bit byte.                
                <return>
                    the 8 bit byte read.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readUnsignedByte" type="int" line="923"/>
            <javadoc line="927">
                Reads a 16 bit char.                
                <return>
                    the 16 bit char read.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readChar" type="char" line="934"/>
            <javadoc line="938">
                Reads a 16 bit short.                
                <return>
                    the 16 bit short read.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readShort" type="short" line="945"/>
            <javadoc line="949">
                Reads an unsigned 16 bit short.                
                <return>
                    the 16 bit short read.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readUnsignedShort" type="int" line="956"/>
            <javadoc line="960">
                Reads a 32 bit int.                
                <return>
                    the 32 bit integer read.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readInt" type="int" line="967"/>
            <javadoc line="971">
                Reads a 64 bit long.                
                <return>
                    the read 64 bit long.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readLong" type="long" line="978"/>
            <javadoc line="982">
                Reads a 32 bit float.                
                <return>
                    the 32 bit float read.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readFloat" type="float" line="989"/>
            <javadoc line="993">
                Reads a 64 bit double.                
                <return>
                    the 64 bit double read.                    
                </return>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readDouble" type="double" line="1000"/>
            <javadoc line="1004">
                Reads bytes, blocking until all bytes are read.                
                <param>
                    buf the buffer into which the data is read                    
                </param>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readFully" type="void" line="1011">
                <params>
                    <param name="buf" type="byte[]"/>
                </params>
            </method>
            <javadoc line="1015">
                Reads bytes, blocking until all bytes are read.                
                <param>
                    buf the buffer into which the data is read                    
                </param>
                <param>
                    off the start offset of the data                    
                </param>
                <param>
                    len the maximum number of bytes to read                    
                </param>
                <throws>
                    EOFException If end of file is reached.                    
                </throws>
                <throws>
                    IOException If other I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="readFully" type="void" line="1024">
                <params>
                    <param name="buf" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="endoff" type="int" line="1025"/>
                <scope line="1026"/>
            </method>
            <javadoc line="1032">
                Skips bytes.                
                <param>
                    len the number of bytes to be skipped                    
                </param>
                <return>
                    the actual number of bytes skipped.                    
                </return>
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="skipBytes" type="int" line="1039">
                <params>
                    <param name="len" type="int"/>
                </params>
            </method>
            <javadoc line="1043">
                Reads in a line that has been terminated by a \n, \r, \r\n or EOF.                
                <return>
                    a String copy of the line.                    
                </return>
                <throws>
                    IOException if there are I/O errors while reading from the
                      underlying &lt;code&gt;InputStream&lt;/code&gt;                    
                </throws>
                <deprecated>
                    This method does not properly convert bytes to characters.
                      see DataInputStream for the details and alternatives.                    
                </deprecated>
            </javadoc>
            <method name="readLine" type="String" line="1053"/>
            <javadoc line="1057">
                Reads a String in
                  &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
                  format.                
                <return>
                    the String.                    
                </return>
                <throws>
                    IOException if there are I/O errors while reading from the
                      underlying &lt;code&gt;InputStream&lt;/code&gt;                    
                </throws>
                <throws>
                    UTFDataFormatException if read bytes do not represent a valid
                      modified UTF-8 encoding of a string                    
                </throws>
            </javadoc>
            <method name="readUTF" type="String" line="1068"/>
            <class name="GetField" line="1072">
                <comment line="2005">
                    REMIND: remove once hotspot inlines Float.intBitsToFloat                    
                </comment>
                <comment line="2013">
                    REMIND: remove once hotspot inlines Double.longBitsToDouble                    
                </comment>
                <comment line="2029">
                    REMIND: change name to something more accurate?                    
                </comment>
                <comment line="2357">
                    block data state fields; values meaningful only when blkmode true                    
                </comment>
                <comment line="2578">
                                        
                </comment>
                <comment line="2579">
                    The following methods are equivalent to their counterparts in
                     InputStream, except that they interpret data block boundaries and
                     read the requested data from within data blocks when in block data
                     mode.                    
                </comment>
                <comment line="2696">
                                        
                </comment>
                <comment line="2697">
                    The following methods are equivalent to their counterparts in
                     DataInputStream, except that they interpret data block boundaries
                     and read the requested data from within data blocks when in block
                     data mode.                    
                </comment>
                <comment line="2845">
                                        
                </comment>
                <comment line="2846">
                    The following methods read in spans of primitive data values.
                     Though equivalent to calling the corresponding primitive read
                     methods repeatedly, these methods are optimized for reading groups
                     of primitive data values more efficiently.                    
                </comment>
                <comment line="3209">
                    REMIND: add full description of exception propagation algorithm?                    
                </comment>
                <comment line="3212">
                                        
                </comment>
                <javadoc line="1072">
                    Provide access to the persistent fields read from the input stream.                    
                </javadoc>
                <method name="getObjectStreamClass" type="ObjectStreamClass" line="1077"/>
                <javadoc line="1077">
                    Get the ObjectStreamClass that describes the fields in the stream.                    
                    <return>
                        the descriptor class that describes the serializable fields                        
                    </return>
                </javadoc>
                <method name="defaulted" type="boolean" line="1084"/>
                <javadoc line="1084">
                    Return true if the named field is defaulted and has no value in this
                      stream.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <return>
                        true, if and only if the named field is defaulted                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from
                          the underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
                          correspond to a serializable field                        
                    </throws>
                </javadoc>
                <method name="get" type="boolean" line="1097"/>
                <javadoc line="1097">
                    Get the value of the named boolean field from the persistent field.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <param>
                        val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
                          have a value                        
                    </param>
                    <return>
                        the value of the named &lt;code&gt;boolean&lt;/code&gt; field                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from the
                          underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
                          not serializable or if the field type is incorrect                        
                    </throws>
                </javadoc>
                <method name="get" type="byte" line="1112"/>
                <javadoc line="1112">
                    Get the value of the named byte field from the persistent field.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <param>
                        val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
                          have a value                        
                    </param>
                    <return>
                        the value of the named &lt;code&gt;byte&lt;/code&gt; field                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from the
                          underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
                          not serializable or if the field type is incorrect                        
                    </throws>
                </javadoc>
                <method name="get" type="char" line="1126"/>
                <javadoc line="1126">
                    Get the value of the named char field from the persistent field.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <param>
                        val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
                          have a value                        
                    </param>
                    <return>
                        the value of the named &lt;code&gt;char&lt;/code&gt; field                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from the
                          underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
                          not serializable or if the field type is incorrect                        
                    </throws>
                </javadoc>
                <method name="get" type="short" line="1140"/>
                <javadoc line="1140">
                    Get the value of the named short field from the persistent field.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <param>
                        val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
                          have a value                        
                    </param>
                    <return>
                        the value of the named &lt;code&gt;short&lt;/code&gt; field                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from the
                          underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
                          not serializable or if the field type is incorrect                        
                    </throws>
                </javadoc>
                <method name="get" type="int" line="1154"/>
                <javadoc line="1154">
                    Get the value of the named int field from the persistent field.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <param>
                        val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
                          have a value                        
                    </param>
                    <return>
                        the value of the named &lt;code&gt;int&lt;/code&gt; field                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from the
                          underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
                          not serializable or if the field type is incorrect                        
                    </throws>
                </javadoc>
                <method name="get" type="long" line="1168"/>
                <javadoc line="1168">
                    Get the value of the named long field from the persistent field.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <param>
                        val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
                          have a value                        
                    </param>
                    <return>
                        the value of the named &lt;code&gt;long&lt;/code&gt; field                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from the
                          underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
                          not serializable or if the field type is incorrect                        
                    </throws>
                </javadoc>
                <method name="get" type="float" line="1182"/>
                <javadoc line="1182">
                    Get the value of the named float field from the persistent field.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <param>
                        val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
                          have a value                        
                    </param>
                    <return>
                        the value of the named &lt;code&gt;float&lt;/code&gt; field                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from the
                          underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
                          not serializable or if the field type is incorrect                        
                    </throws>
                </javadoc>
                <method name="get" type="double" line="1196"/>
                <javadoc line="1196">
                    Get the value of the named double field from the persistent field.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <param>
                        val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
                          have a value                        
                    </param>
                    <return>
                        the value of the named &lt;code&gt;double&lt;/code&gt; field                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from the
                          underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
                          not serializable or if the field type is incorrect                        
                    </throws>
                </javadoc>
                <method name="get" type="Object" line="1210"/>
                <javadoc line="1210">
                    Get the value of the named Object field from the persistent field.                    
                    <param>
                        name the name of the field                        
                    </param>
                    <param>
                        val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
                          have a value                        
                    </param>
                    <return>
                        the value of the named &lt;code&gt;Object&lt;/code&gt; field                        
                    </return>
                    <throws>
                        IOException if there are I/O errors while reading from the
                          underlying &lt;code&gt;InputStream&lt;/code&gt;                        
                    </throws>
                    <throws>
                        IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
                          not serializable or if the field type is incorrect                        
                    </throws>
                </javadoc>
            </class>
            <javadoc line="1225">
                Verifies that this (possibly subclass) instance can be constructed
                  without violating security constraints: the subclass must not override
                  security-sensitive non-final methods, or else the
                  &quot;enableSubclassImplementation&quot; SerializablePermission is checked.                
            </javadoc>
            <method name="verifySubclass" type="void" line="1231">
                <declaration name="cl" type="Class" line="1232"/>
                <scope line="1233"/>
                <declaration name="sm" type="SecurityManager" line="1236"/>
                <scope line="1237"/>
                <declaration name="key" type="WeakClassKey" line="1241"/>
                <declaration name="result" type="Boolean" line="1242"/>
                <scope line="1243"/>
                <scope line="1247"/>
            </method>
            <javadoc line="1253">
                Performs reflective checks on given subclass to verify that it doesn&apos;t
                  override security-sensitive non-final methods.  Returns true if subclass
                  is &quot;safe&quot;, false otherwise.                
            </javadoc>
            <method name="auditSubclass" type="boolean" line="1258">
                <params>
                    <param name="subcl" type="Class<?>"/>
                </params>
                <anonymous_class line="1260">
                    <method name="run" type="Boolean" line="1261">
                        <scope line="1265">
                            <scope line="1266"/>
                            <scope line="1270"/>
                            <scope line="1272"/>
                            <scope line="1275"/>
                        </scope>
                    </method>
                </anonymous_class>
                <declaration name="result" type="Boolean" line="1259"/>
            </method>
            <javadoc line="1285">
                Clears internal data structures.                
            </javadoc>
            <method name="clear" type="void" line="1288"/>
            <javadoc line="1293">
                Underlying readObject implementation.                
            </javadoc>
            <method name="readObject0" type="Object" line="1296">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <comment line="1304">
                    Fix for 4360508: stream is currently at the end of a field
                     value block written via default serialization; since there
                     is no terminating TC_ENDBLOCKDATA tag, simulate
                     end-of-custom-data behavior explicitly.                    
                </comment>
                <comment line="1358">
                    force header read                    
                </comment>
                <declaration name="oldMode" type="boolean" line="1297"/>
                <scope line="1298">
                    <declaration name="remain" type="int" line="1299"/>
                    <scope line="1300"/>
                    <scope line="1302"/>
                </scope>
                <declaration name="tc" type="byte" line="1314"/>
                <scope line="1315"/>
                <scope line="1321">
                    <declaration name="ex" type="IOException" line="1350"/>
                    <scope line="1355"/>
                    <scope line="1360"/>
                    <scope line="1366"/>
                    <scope line="1368"/>
                </scope>
                <scope line="1377"/>
            </method>
            <javadoc line="1383">
                If resolveObject has been enabled and given object does not have an
                  exception associated with it, calls resolveObject to determine
                  replacement for object, and updates handle table accordingly.  Returns
                  replacement object, or echoes provided object if no replacement
                  occurred.  Expects that passHandle is set to given object&apos;s handle prior
                  to calling this method.                
            </javadoc>
            <method name="checkResolve" type="Object" line="1391">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="1392"/>
                <declaration name="rep" type="Object" line="1395"/>
                <scope line="1396"/>
            </method>
            <javadoc line="1402">
                Reads string without allowing it to be replaced in stream.  Called from
                  within ObjectStreamClass.read().                
            </javadoc>
            <method name="readTypeString" type="String" line="1406">
                <declaration name="oldHandle" type="int" line="1407"/>
                <scope line="1408">
                    <declaration name="tc" type="byte" line="1409"/>
                </scope>
                <scope line="1425"/>
            </method>
            <javadoc line="1430">
                Reads in null code, sets passHandle to NULL_HANDLE and returns null.                
            </javadoc>
            <method name="readNull" type="Object" line="1433">
                <scope line="1434"/>
            </method>
            <javadoc line="1441">
                Reads in object handle, sets passHandle to the read handle, and returns
                  object associated with the handle.                
            </javadoc>
            <method name="readHandle" type="Object" line="1445">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <comment line="1457">
                    REMIND: what type of exception to throw here?                    
                </comment>
                <comment line="1464">
                    REMIND: what type of exception to throw here?                    
                </comment>
                <scope line="1446"/>
                <scope line="1450"/>
                <scope line="1455"/>
                <declaration name="obj" type="Object" line="1461"/>
                <scope line="1462"/>
            </method>
            <javadoc line="1470">
                Reads in and returns class object.  Sets passHandle to class object&apos;s
                  assigned handle.  Returns null if class is unresolvable (in which case a
                  ClassNotFoundException will be associated with the class&apos; handle in the
                  handle table).                
            </javadoc>
            <method name="readClass" type="Class" line="1476">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <scope line="1477"/>
                <declaration name="desc" type="ObjectStreamClass" line="1480"/>
                <declaration name="cl" type="Class" line="1481"/>
                <declaration name="resolveEx" type="ClassNotFoundException" line="1484"/>
                <scope line="1485"/>
            </method>
            <javadoc line="1493">
                Reads in and returns (possibly null) class descriptor.  Sets passHandle
                  to class descriptor&apos;s assigned handle.  If class descriptor cannot be
                  resolved to a class in the local VM, a ClassNotFoundException is
                  associated with the class descriptor&apos;s handle.                
            </javadoc>
            <method name="readClassDesc" type="ObjectStreamClass" line="1501">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <declaration name="tc" type="byte" line="1502"/>
            </method>
            <javadoc line="1522">
                Reads in and returns class descriptor for a dynamic proxy class.  Sets
                  passHandle to proxy class descriptor&apos;s assigned handle.  If proxy class
                  descriptor cannot be resolved to a class in the local VM, a
                  ClassNotFoundException is associated with the descriptor&apos;s handle.                
            </javadoc>
            <method name="readProxyDesc" type="ObjectStreamClass" line="1530">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <scope line="1531"/>
                <declaration name="desc" type="ObjectStreamClass" line="1535"/>
                <declaration name="descHandle" type="int" line="1536"/>
                <declaration name="numIfaces" type="int" line="1539"/>
                <declaration name="ifaces" type="String[]" line="1540"/>
                <scope line="1541"/>
                <declaration name="cl" type="Class" line="1545"/>
                <declaration name="resolveEx" type="ClassNotFoundException" line="1546"/>
                <scope line="1548">
                    <scope line="1549"/>
                </scope>
                <scope line="1552"/>
            </method>
            <javadoc line="1564">
                Reads in and returns class descriptor for a class that is not a dynamic
                  proxy class.  Sets passHandle to class descriptor&apos;s assigned handle.  If
                  class descriptor cannot be resolved to a class in the local VM, a
                  ClassNotFoundException is associated with the descriptor&apos;s handle.                
            </javadoc>
            <method name="readNonProxyDesc" type="ObjectStreamClass" line="1572">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <scope line="1573"/>
                <declaration name="desc" type="ObjectStreamClass" line="1577"/>
                <declaration name="descHandle" type="int" line="1578"/>
                <declaration name="readDesc" type="ObjectStreamClass" line="1581"/>
                <scope line="1582"/>
                <scope line="1584"/>
                <declaration name="cl" type="Class" line="1589"/>
                <declaration name="resolveEx" type="ClassNotFoundException" line="1590"/>
                <scope line="1592">
                    <scope line="1593"/>
                </scope>
                <scope line="1596"/>
            </method>
            <javadoc line="1608">
                Reads in and returns new string.  Sets passHandle to new string&apos;s
                  assigned handle.                
            </javadoc>
            <method name="readString" type="String" line="1612">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <declaration name="str" type="String" line="1613"/>
                <declaration name="tc" type="byte" line="1614"/>
            </method>
            <javadoc line="1633">
                Reads in and returns array object, or null if array class is
                  unresolvable.  Sets passHandle to array&apos;s assigned handle.                
            </javadoc>
            <method name="readArray" type="Object" line="1637">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <scope line="1638"/>
                <declaration name="desc" type="ObjectStreamClass" line="1642"/>
                <declaration name="len" type="int" line="1643"/>
                <declaration name="array" type="Object" line="1645"/>
                <declaration name="cl" type="Class" line="1646"/>
                <scope line="1647"/>
                <declaration name="arrayHandle" type="int" line="1652"/>
                <declaration name="resolveEx" type="ClassNotFoundException" line="1653"/>
                <scope line="1654"/>
                <scope line="1658">
                    <scope line="1659"/>
                </scope>
                <scope line="1662">
                    <scope line="1663"/>
                    <scope line="1665"/>
                    <scope line="1667"/>
                    <scope line="1669"/>
                    <scope line="1671"/>
                    <scope line="1673"/>
                    <scope line="1675"/>
                    <scope line="1677"/>
                    <scope line="1679"/>
                </scope>
                <scope line="1682">
                    <declaration name="oa" type="Object[]" line="1683"/>
                    <scope line="1684"/>
                </scope>
            </method>
            <javadoc line="1695">
                Reads in and returns enum constant, or null if enum type is
                  unresolvable.  Sets passHandle to enum constant&apos;s assigned handle.                
            </javadoc>
            <method name="readEnum" type="Enum" line="1699">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <scope line="1700"/>
                <declaration name="desc" type="ObjectStreamClass" line="1704"/>
                <scope line="1705"/>
                <declaration name="enumHandle" type="int" line="1709"/>
                <declaration name="resolveEx" type="ClassNotFoundException" line="1710"/>
                <scope line="1711"/>
                <declaration name="name" type="String" line="1715"/>
                <declaration name="en" type="Enum" line="1716"/>
                <declaration name="cl" type="Class" line="1717"/>
                <scope line="1718">
                    <scope line="1719"/>
                    <scope line="1721"/>
                    <scope line="1726"/>
                </scope>
            </method>
            <javadoc line="1736">
                Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
                  ObjectStreamClass, array, or enum constant) object, or null if object&apos;s
                  class is unresolvable (in which case a ClassNotFoundException will be
                  associated with object&apos;s handle).  Sets passHandle to object&apos;s assigned
                  handle.                
            </javadoc>
            <method name="readOrdinaryObject" type="Object" line="1745">
                <params>
                    <param name="unshared" type="boolean"/>
                </params>
                <scope line="1746"/>
                <declaration name="desc" type="ObjectStreamClass" line="1750"/>
                <declaration name="obj" type="Object" line="1753"/>
                <scope line="1754"/>
                <scope line="1756"/>
                <declaration name="resolveEx" type="ClassNotFoundException" line="1763"/>
                <scope line="1764"/>
                <scope line="1768"/>
                <scope line="1770"/>
                <scope line="1779">
                    <declaration name="rep" type="Object" line="1780"/>
                    <scope line="1781"/>
                    <scope line="1784"/>
                </scope>
            </method>
            <javadoc line="1792">
                If obj is non-null, reads externalizable data by invoking readExternal()
                  method of obj; otherwise, attempts to skip over externalizable data.
                  Expects that passHandle is set to obj&apos;s handle before this method is
                  called.                
            </javadoc>
            <method name="readExternalData" type="void" line="1800">
                <params>
                    <param name="obj" type="Externalizable"/>
                    <param name="desc" type="ObjectStreamClass"/>
                </params>
                <comment line="1813">
                    In most cases, the handle table has already propagated
                     a CNFException to passHandle at this point; this mark
                     call is included to address cases where the readExternal
                     method has cons&apos;ed and thrown a new CNFException of its
                     own.                    
                </comment>
                <comment line="1829">
                    At this point, if the externalizable data was not written in
                     block-data form and either the externalizable class doesn&apos;t exist
                     locally (i.e., obj == null) or readExternal() just threw a
                     CNFException, then the stream is probably in an inconsistent state,
                     since some (or all) of the externalizable data may not have been
                     consumed.  Since there&apos;s no &quot;correct&quot; action to take in this case,
                     we mimic the behavior of past serialization implementations and
                     blindly hope that the stream is in sync; if it isn&apos;t and additional
                     externalizable data remains in the stream, a subsequent read will
                     most likely throw a StreamCorruptedException.                    
                </comment>
                <declaration name="oldContext" type="SerialCallbackContext" line="1801"/>
                <scope line="1803">
                    <declaration name="blocked" type="boolean" line="1804"/>
                    <scope line="1805"/>
                    <scope line="1808">
                        <scope line="1809"/>
                        <scope line="1811"/>
                    </scope>
                    <scope line="1822"/>
                </scope>
                <scope line="1825"/>
            </method>
            <javadoc line="1842">
                Reads (or attempts to skip, if obj is null or is tagged with a
                  ClassNotFoundException) instance data for each serializable class of
                  object in stream, from superclass to subclass.  Expects that passHandle
                  is set to obj&apos;s handle before this method is called.                
            </javadoc>
            <method name="readSerialData" type="void" line="1850">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="desc" type="ObjectStreamClass"/>
                </params>
                <comment line="1869">
                    In most cases, the handle table has already
                     propagated a CNFException to passHandle at this
                     point; this mark call is included to address cases
                     where the custom readObject method has cons&apos;ed and
                     thrown a new CNFException of its own.                    
                </comment>
                <comment line="1882">
                    defaultDataEnd may have been set indirectly by custom
                     readObject() method when calling defaultReadObject() or
                     readFields(); clear it to restore normal read behavior.                    
                </comment>
                <declaration name="slots" type="ObjectStreamClass.ClassDataSlot[]" line="1851"/>
                <scope line="1852">
                    <declaration name="slotDesc" type="ObjectStreamClass" line="1853"/>
                    <scope line="1855">
                        <scope line="1859">
                            <declaration name="oldContext" type="SerialCallbackContext" line="1860"/>
                            <scope line="1862"/>
                            <scope line="1867"/>
                            <scope line="1876"/>
                        </scope>
                        <scope line="1887"/>
                        <scope line="1890"/>
                        <scope line="1892"/>
                    </scope>
                    <scope line="1895">
                        <scope line="1899"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1906">
                Skips over all block data and objects until TC_ENDBLOCKDATA is
                  encountered.                
            </javadoc>
            <method name="skipCustomData" type="void" line="1910">
                <declaration name="oldHandle" type="int" line="1911"/>
                <scope line="1912">
                    <scope line="1913"/>
                </scope>
            </method>
            <javadoc line="1935">
                Reads in values of serializable fields declared by given class
                  descriptor.  If obj is non-null, sets field values in obj.  Expects that
                  passHandle is set to obj&apos;s handle before this method is called.                
            </javadoc>
            <method name="defaultReadFields" type="void" line="1942">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="desc" type="ObjectStreamClass"/>
                </params>
                <comment line="1944">
                    REMIND: is isInstance check necessary?                    
                </comment>
                <declaration name="cl" type="Class" line="1944"/>
                <scope line="1945"/>
                <declaration name="primDataSize" type="int" line="1949"/>
                <scope line="1950"/>
                <scope line="1954"/>
                <declaration name="objHandle" type="int" line="1958"/>
                <declaration name="fields" type="ObjectStreamField[]" line="1959"/>
                <declaration name="objVals" type="Object[]" line="1960"/>
                <declaration name="numPrimFields" type="int" line="1961"/>
                <scope line="1962">
                    <declaration name="f" type="ObjectStreamField" line="1963"/>
                    <scope line="1965"/>
                </scope>
                <scope line="1969"/>
            </method>
            <javadoc line="1975">
                Reads in and returns IOException that caused serialization to abort.
                  All stream state is discarded prior to reading in fatal exception.  Sets
                  passHandle to fatal exception&apos;s handle.                
            </javadoc>
            <method name="readFatalException" type="IOException" line="1980">
                <scope line="1981"/>
            </method>
            <javadoc line="1988">
                If recursion depth is 0, clears internal data structures; otherwise,
                  throws a StreamCorruptedException.  This method is called when a
                  TC_RESET typecode is encountered.                
            </javadoc>
            <method name="handleReset" type="void" line="1993">
                <scope line="1994"/>
            </method>
            <method name="bytesToFloats" type="void" line="2001"/>
            <javadoc line="2001">
                Converts specified span of bytes into float values.                
            </javadoc>
            <method name="bytesToDoubles" type="void" line="2009"/>
            <javadoc line="2009">
                Converts specified span of bytes into double values.                
            </javadoc>
            <method name="latestUserDefinedLoader" type="ClassLoader" line="2017"/>
            <javadoc line="2017">
                Returns the first non-null class loader (not counting class loaders of
                  generated reflection implementation classes) up the execution stack, or
                  null if only code from the null class loader is on the stack.  This
                  method is also called via reflection by the following RMI-IIOP class:
                  com.sun.corba.se.internal.util.JDKClassLoader
                  This method should not be removed or its signature changed without
                  corresponding modifications to the above class.                
            </javadoc>
            <class name="GetFieldImpl" line="2031">
                <extends class="GetField"/>
                <comment line="2005">
                    REMIND: remove once hotspot inlines Float.intBitsToFloat                    
                </comment>
                <comment line="2013">
                    REMIND: remove once hotspot inlines Double.longBitsToDouble                    
                </comment>
                <comment line="2029">
                    REMIND: change name to something more accurate?                    
                </comment>
                <comment line="2357">
                    block data state fields; values meaningful only when blkmode true                    
                </comment>
                <comment line="2578">
                                        
                </comment>
                <comment line="2579">
                    The following methods are equivalent to their counterparts in
                     InputStream, except that they interpret data block boundaries and
                     read the requested data from within data blocks when in block data
                     mode.                    
                </comment>
                <comment line="2696">
                                        
                </comment>
                <comment line="2697">
                    The following methods are equivalent to their counterparts in
                     DataInputStream, except that they interpret data block boundaries
                     and read the requested data from within data blocks when in block
                     data mode.                    
                </comment>
                <comment line="2845">
                                        
                </comment>
                <comment line="2846">
                    The following methods read in spans of primitive data values.
                     Though equivalent to calling the corresponding primitive read
                     methods repeatedly, these methods are optimized for reading groups
                     of primitive data values more efficiently.                    
                </comment>
                <comment line="3209">
                    REMIND: add full description of exception propagation algorithm?                    
                </comment>
                <comment line="3212">
                                        
                </comment>
                <javadoc line="2031">
                    Default GetField implementation.                    
                </javadoc>
                <declaration name="desc" type="ObjectStreamClass" line="2036"/>
                <javadoc line="2036">
                    class descriptor describing serializable fields                    
                </javadoc>
                <declaration name="primVals" type="byte[]" line="2038"/>
                <javadoc line="2038">
                    primitive field values                    
                </javadoc>
                <declaration name="objVals" type="Object[]" line="2040"/>
                <javadoc line="2040">
                    object field values                    
                </javadoc>
                <declaration name="objHandles" type="int[]" line="2042"/>
                <javadoc line="2042">
                    object field value handles                    
                </javadoc>
                <javadoc line="2045">
                    Creates GetFieldImpl object for reading fields defined in given
                      class descriptor.                    
                </javadoc>
                <method name="GetFieldImpl" type="constructor" line="2049">
                    <params>
                        <param name="desc" type="ObjectStreamClass"/>
                    </params>
                </method>
                <method name="getObjectStreamClass" type="ObjectStreamClass" line="2056"/>
                <method name="defaulted" type="boolean" line="2060">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                </method>
                <method name="get" type="boolean" line="2064">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="boolean"/>
                    </params>
                    <declaration name="off" type="int" line="2065"/>
                </method>
                <method name="get" type="byte" line="2069">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="byte"/>
                    </params>
                    <declaration name="off" type="int" line="2070"/>
                </method>
                <method name="get" type="char" line="2074">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="char"/>
                    </params>
                    <declaration name="off" type="int" line="2075"/>
                </method>
                <method name="get" type="short" line="2079">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="short"/>
                    </params>
                    <declaration name="off" type="int" line="2080"/>
                </method>
                <method name="get" type="int" line="2084">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="int"/>
                    </params>
                    <declaration name="off" type="int" line="2085"/>
                </method>
                <method name="get" type="float" line="2089">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="float"/>
                    </params>
                    <declaration name="off" type="int" line="2090"/>
                </method>
                <method name="get" type="long" line="2094">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="long"/>
                    </params>
                    <declaration name="off" type="int" line="2095"/>
                </method>
                <method name="get" type="double" line="2099">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="double"/>
                    </params>
                    <declaration name="off" type="int" line="2100"/>
                </method>
                <method name="get" type="Object" line="2104">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="Object"/>
                    </params>
                    <declaration name="off" type="int" line="2105"/>
                    <scope line="2106">
                        <declaration name="objHandle" type="int" line="2107"/>
                    </scope>
                    <scope line="2111"/>
                </method>
                <javadoc line="2116">
                    Reads primitive and object field values from stream.                    
                </javadoc>
                <method name="readFields" type="void" line="2119">
                    <declaration name="oldHandle" type="int" line="2122"/>
                    <declaration name="fields" type="ObjectStreamField[]" line="2123"/>
                    <declaration name="numPrimFields" type="int" line="2124"/>
                    <scope line="2125"/>
                </method>
                <javadoc line="2133">
                    Returns offset of field with given name and type.  A specified type
                      of null matches all types, Object.class matches all non-primitive
                      types, and any other non-null type matches assignable types only.
                      If no matching field is found in the (incoming) class
                      descriptor but a matching field is present in the associated local
                      class descriptor, returns -1.  Throws IllegalArgumentException if
                      neither incoming nor local class descriptor contains a match.                    
                </javadoc>
                <method name="getFieldOffset" type="int" line="2142">
                    <params>
                        <param name="name" type="String"/>
                        <param name="type" type="Class"/>
                    </params>
                    <declaration name="field" type="ObjectStreamField" line="2143"/>
                    <scope line="2144"/>
                    <scope line="2146"/>
                    <scope line="2148"/>
                </method>
            </class>
            <class name="ValidationList" line="2155">
                <comment line="2005">
                    REMIND: remove once hotspot inlines Float.intBitsToFloat                    
                </comment>
                <comment line="2013">
                    REMIND: remove once hotspot inlines Double.longBitsToDouble                    
                </comment>
                <comment line="2029">
                    REMIND: change name to something more accurate?                    
                </comment>
                <comment line="2357">
                    block data state fields; values meaningful only when blkmode true                    
                </comment>
                <comment line="2578">
                                        
                </comment>
                <comment line="2579">
                    The following methods are equivalent to their counterparts in
                     InputStream, except that they interpret data block boundaries and
                     read the requested data from within data blocks when in block data
                     mode.                    
                </comment>
                <comment line="2696">
                                        
                </comment>
                <comment line="2697">
                    The following methods are equivalent to their counterparts in
                     DataInputStream, except that they interpret data block boundaries
                     and read the requested data from within data blocks when in block
                     data mode.                    
                </comment>
                <comment line="2845">
                                        
                </comment>
                <comment line="2846">
                    The following methods read in spans of primitive data values.
                     Though equivalent to calling the corresponding primitive read
                     methods repeatedly, these methods are optimized for reading groups
                     of primitive data values more efficiently.                    
                </comment>
                <comment line="3209">
                    REMIND: add full description of exception propagation algorithm?                    
                </comment>
                <comment line="3212">
                                        
                </comment>
                <javadoc line="2155">
                    Prioritized list of callbacks to be performed once object graph has been
                      completely deserialized.                    
                </javadoc>
                <class name="Callback" line="2161">
                    <declaration name="obj" type="ObjectInputValidation" line="2162"/>
                    <declaration name="priority" type="int" line="2163"/>
                    <declaration name="next" type="Callback" line="2164"/>
                    <declaration name="acc" type="AccessControlContext" line="2165"/>
                    <method name="Callback" type="constructor" line="2169">
                        <params>
                            <param name="obj" type="ObjectInputValidation"/>
                            <param name="priority" type="int"/>
                            <param name="next" type="Callback"/>
                            <param name="acc" type="AccessControlContext"/>
                        </params>
                    </method>
                </class>
                <declaration name="list" type="Callback" line="2177"/>
                <javadoc line="2177">
                    linked list of callbacks                    
                </javadoc>
                <javadoc line="2180">
                    Creates new (empty) ValidationList.                    
                </javadoc>
                <method name="ValidationList" type="constructor" line="2183"/>
                <javadoc line="2186">
                    Registers callback.  Throws InvalidObjectException if callback
                      object is null.                    
                </javadoc>
                <method name="register" type="void" line="2192">
                    <params>
                        <param name="obj" type="ObjectInputValidation"/>
                        <param name="priority" type="int"/>
                    </params>
                    <scope line="2193"/>
                    <declaration name="prev" type="Callback" line="2197"/>
                    <scope line="2198"/>
                    <declaration name="acc" type="AccessControlContext" line="2202"/>
                    <scope line="2203"/>
                    <scope line="2205"/>
                </method>
                <javadoc line="2210">
                    Invokes all registered callbacks and clears the callback list.
                      Callbacks with higher priorities are called first; those with equal
                      priorities may be called in any order.  If any of the callbacks
                      throws an InvalidObjectException, the callback process is terminated
                      and the exception propagated upwards.                    
                </javadoc>
                <method name="doCallbacks" type="void" line="2217">
                    <scope line="2218">
                        <scope line="2219">
                            <anonymous_class line="2222">
                                <method name="run" type="Void" line="2223"/>
                            </anonymous_class>
                        </scope>
                    </scope>
                    <scope line="2230"/>
                </method>
                <javadoc line="2236">
                    Resets the callback list to its initial (empty) state.                    
                </javadoc>
                <method name="clear" type="void" line="2239"/>
            </class>
            <class name="PeekInputStream" line="2244">
                <extends class="InputStream"/>
                <comment line="2005">
                    REMIND: remove once hotspot inlines Float.intBitsToFloat                    
                </comment>
                <comment line="2013">
                    REMIND: remove once hotspot inlines Double.longBitsToDouble                    
                </comment>
                <comment line="2029">
                    REMIND: change name to something more accurate?                    
                </comment>
                <comment line="2357">
                    block data state fields; values meaningful only when blkmode true                    
                </comment>
                <comment line="2578">
                                        
                </comment>
                <comment line="2579">
                    The following methods are equivalent to their counterparts in
                     InputStream, except that they interpret data block boundaries and
                     read the requested data from within data blocks when in block data
                     mode.                    
                </comment>
                <comment line="2696">
                                        
                </comment>
                <comment line="2697">
                    The following methods are equivalent to their counterparts in
                     DataInputStream, except that they interpret data block boundaries
                     and read the requested data from within data blocks when in block
                     data mode.                    
                </comment>
                <comment line="2845">
                                        
                </comment>
                <comment line="2846">
                    The following methods read in spans of primitive data values.
                     Though equivalent to calling the corresponding primitive read
                     methods repeatedly, these methods are optimized for reading groups
                     of primitive data values more efficiently.                    
                </comment>
                <comment line="3209">
                    REMIND: add full description of exception propagation algorithm?                    
                </comment>
                <comment line="3212">
                                        
                </comment>
                <javadoc line="2244">
                    Input stream supporting single-byte peek operations.                    
                </javadoc>
                <declaration name="in" type="InputStream" line="2249"/>
                <javadoc line="2249">
                    underlying stream                    
                </javadoc>
                <declaration name="peekb" type="int" line="2251"/>
                <javadoc line="2251">
                    peeked byte                    
                </javadoc>
                <javadoc line="2254">
                    Creates new PeekInputStream on top of given underlying stream.                    
                </javadoc>
                <method name="PeekInputStream" type="constructor" line="2257">
                    <params>
                        <param name="in" type="InputStream"/>
                    </params>
                </method>
                <javadoc line="2261">
                    Peeks at next byte value in stream.  Similar to read(), except
                      that it does not consume the read value.                    
                </javadoc>
                <method name="peek" type="int" line="2265"/>
                <method name="read" type="int" line="2269">
                    <scope line="2270">
                        <declaration name="v" type="int" line="2271"/>
                    </scope>
                    <scope line="2274"/>
                </method>
                <method name="read" type="int" line="2279">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <scope line="2280"/>
                    <scope line="2282"/>
                    <scope line="2284">
                        <declaration name="n" type="int" line="2288"/>
                    </scope>
                </method>
                <method name="readFully" type="void" line="2293">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="n" type="int" line="2294"/>
                    <scope line="2295">
                        <declaration name="count" type="int" line="2296"/>
                        <scope line="2297"/>
                    </scope>
                </method>
                <method name="skip" type="long" line="2304">
                    <params>
                        <param name="n" type="long"/>
                    </params>
                    <scope line="2305"/>
                    <declaration name="skipped" type="int" line="2308"/>
                    <scope line="2309"/>
                </method>
                <method name="available" type="int" line="2317"/>
                <method name="close" type="void" line="2321"/>
            </class>
            <class name="BlockDataInputStream" line="2326">
                <extends class="InputStream"/>
                <comment line="2005">
                    REMIND: remove once hotspot inlines Float.intBitsToFloat                    
                </comment>
                <comment line="2013">
                    REMIND: remove once hotspot inlines Double.longBitsToDouble                    
                </comment>
                <comment line="2029">
                    REMIND: change name to something more accurate?                    
                </comment>
                <comment line="2357">
                    block data state fields; values meaningful only when blkmode true                    
                </comment>
                <comment line="2578">
                                        
                </comment>
                <comment line="2579">
                    The following methods are equivalent to their counterparts in
                     InputStream, except that they interpret data block boundaries and
                     read the requested data from within data blocks when in block data
                     mode.                    
                </comment>
                <comment line="2696">
                                        
                </comment>
                <comment line="2697">
                    The following methods are equivalent to their counterparts in
                     DataInputStream, except that they interpret data block boundaries
                     and read the requested data from within data blocks when in block
                     data mode.                    
                </comment>
                <comment line="2845">
                                        
                </comment>
                <comment line="2846">
                    The following methods read in spans of primitive data values.
                     Though equivalent to calling the corresponding primitive read
                     methods repeatedly, these methods are optimized for reading groups
                     of primitive data values more efficiently.                    
                </comment>
                <comment line="3209">
                    REMIND: add full description of exception propagation algorithm?                    
                </comment>
                <comment line="3212">
                                        
                </comment>
                <implements interface="DataInput"/>
                <javadoc line="2326">
                    Input stream with two modes: in default mode, inputs data written in the
                      same format as DataOutputStream; in &quot;block data&quot; mode, inputs data
                      bracketed by block data markers (see object serialization specification
                      for details).  Buffering depends on block data mode: when in default
                      mode, no data is buffered in advance; when in block data mode, all data
                      for the current data block is read in at once (and buffered).                    
                </javadoc>
                <declaration name="MAX_BLOCK_SIZE" type="int" line="2337"/>
                <javadoc line="2337">
                    maximum data block length                    
                </javadoc>
                <declaration name="MAX_HEADER_SIZE" type="int" line="2339"/>
                <javadoc line="2339">
                    maximum data block header length                    
                </javadoc>
                <declaration name="CHAR_BUF_SIZE" type="int" line="2341"/>
                <javadoc line="2341">
                    (tunable) length of char buffer (for reading strings)                    
                </javadoc>
                <declaration name="HEADER_BLOCKED" type="int" line="2343"/>
                <javadoc line="2343">
                    readBlockHeader() return value indicating header read may block                    
                </javadoc>
                <declaration name="buf" type="byte[]" line="2346"/>
                <javadoc line="2346">
                    buffer for reading general/block data                    
                </javadoc>
                <declaration name="hbuf" type="byte[]" line="2348"/>
                <javadoc line="2348">
                    buffer for reading block data headers                    
                </javadoc>
                <declaration name="cbuf" type="char[]" line="2350"/>
                <javadoc line="2350">
                    char buffer for fast string reads                    
                </javadoc>
                <declaration name="blkmode" type="boolean" line="2353"/>
                <javadoc line="2353">
                    block data mode                    
                </javadoc>
                <declaration name="pos" type="int" line="2357"/>
                <javadoc line="2357">
                    current offset into buf                    
                </javadoc>
                <declaration name="end" type="int" line="2359"/>
                <javadoc line="2359">
                    end offset of valid data in buf, or -1 if no more block data                    
                </javadoc>
                <declaration name="unread" type="int" line="2361"/>
                <javadoc line="2361">
                    number of bytes in current block yet to be read from stream                    
                </javadoc>
                <declaration name="in" type="PeekInputStream" line="2364"/>
                <javadoc line="2364">
                    underlying stream (wrapped in peekable filter stream)                    
                </javadoc>
                <declaration name="din" type="DataInputStream" line="2366"/>
                <javadoc line="2366">
                    loopback stream (for data reads that span data blocks)                    
                </javadoc>
                <javadoc line="2369">
                    Creates new BlockDataInputStream on top of given underlying stream.
                      Block data mode is turned off by default.                    
                </javadoc>
                <method name="BlockDataInputStream" type="constructor" line="2373">
                    <params>
                        <param name="in" type="InputStream"/>
                    </params>
                </method>
                <javadoc line="2378">
                    Sets block data mode to the given mode (true == on, false == off)
                      and returns the previous mode value.  If the new mode is the same as
                      the old mode, no action is taken.  Throws IllegalStateException if
                      block data mode is being switched from on to off while unconsumed
                      block data is still present in the stream.                    
                </javadoc>
                <method name="setBlockDataMode" type="boolean" line="2385">
                    <params>
                        <param name="newmode" type="boolean"/>
                    </params>
                    <scope line="2386"/>
                    <scope line="2389"/>
                    <scope line="2393"/>
                </method>
                <javadoc line="2400">
                    Returns true if the stream is currently in block data mode, false
                      otherwise.                    
                </javadoc>
                <method name="getBlockDataMode" type="boolean" line="2404"/>
                <javadoc line="2408">
                    If in block data mode, skips to the end of the current group of data
                      blocks (but does not unset block data mode).  If not in block data
                      mode, throws an IllegalStateException.                    
                </javadoc>
                <method name="skipBlockData" type="void" line="2413">
                    <scope line="2414"/>
                    <scope line="2417"/>
                </method>
                <javadoc line="2422">
                    Attempts to read in the next block data header (if any).  If
                      canBlock is false and a full header cannot be read without possibly
                      blocking, returns HEADER_BLOCKED, else if the next element in the
                      stream is a block data header, returns the block data length
                      specified by the header, else returns -1.                    
                </javadoc>
                <method name="readBlockHeader" type="int" line="2429">
                    <params>
                        <param name="canBlock" type="boolean"/>
                    </params>
                    <comment line="2432">
                        Fix for 4360508: stream is currently at the end of a field
                         value block written via default serialization; since there
                         is no terminating TC_ENDBLOCKDATA tag, simulate
                         end-of-custom-data behavior explicitly.                        
                    </comment>
                    <comment line="2469">
                        TC_RESETs may occur in between data blocks.
                         Unfortunately, this case must be parsed at a lower
                         level than other typecodes, since primitive data
                         reads may span data blocks separated by a TC_RESET.                        
                    </comment>
                    <scope line="2430"/>
                    <scope line="2439">
                        <scope line="2440">
                            <declaration name="avail" type="int" line="2441"/>
                            <scope line="2442"/>
                            <declaration name="tc" type="int" line="2446"/>
                            <scope line="2449"/>
                            <scope line="2456"/>
                            <declaration name="len" type="int" line="2460"/>
                            <scope line="2461"/>
                            <scope line="2480"/>
                        </scope>
                    </scope>
                    <scope line="2488"/>
                </method>
                <javadoc line="2494">
                    Refills internal buffer buf with block data.  Any data in buf at the
                      time of the call is considered consumed.  Sets the pos, end, and
                      unread fields to reflect the new amount of available block data; if
                      the next element in the stream is not a data block, sets pos and
                      unread to 0 and end to -1.                    
                </javadoc>
                <method name="refill" type="void" line="2501">
                    <scope line="2502">
                        <scope line="2503">
                            <scope line="2505">
                                <declaration name="n" type="int" line="2506"/>
                                <scope line="2508"/>
                                <scope line="2511"/>
                            </scope>
                            <scope line="2515">
                                <declaration name="n" type="int" line="2516"/>
                                <scope line="2517"/>
                                <scope line="2520"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="2526"/>
                </method>
                <javadoc line="2534">
                    If in block data mode, returns the number of unconsumed bytes
                      remaining in the current data block.  If not in block data mode,
                      throws an IllegalStateException.                    
                </javadoc>
                <method name="currentBlockRemaining" type="int" line="2539">
                    <scope line="2540"/>
                    <scope line="2542"/>
                </method>
                <javadoc line="2547">
                    Peeks at (but does not consume) and returns the next byte value in
                      the stream, or -1 if the end of the stream/block data (if in block
                      data mode) has been reached.                    
                </javadoc>
                <method name="peek" type="int" line="2552">
                    <scope line="2553">
                        <scope line="2554"/>
                    </scope>
                    <scope line="2558"/>
                </method>
                <javadoc line="2563">
                    Peeks at (but does not consume) and returns the next byte value in
                      the stream, or throws EOFException if end of stream/block data has
                      been reached.                    
                </javadoc>
                <method name="peekByte" type="byte" line="2568">
                    <declaration name="val" type="int" line="2569"/>
                    <scope line="2570"/>
                </method>
                <method name="read" type="int" line="2585">
                    <scope line="2586">
                        <scope line="2587"/>
                    </scope>
                    <scope line="2591"/>
                </method>
                <method name="read" type="int" line="2596">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                </method>
                <method name="skip" type="long" line="2600">
                    <params>
                        <param name="len" type="long"/>
                    </params>
                    <declaration name="remain" type="long" line="2601"/>
                    <scope line="2602">
                        <scope line="2603">
                            <scope line="2604"/>
                            <scope line="2607"/>
                            <declaration name="nread" type="int" line="2610"/>
                        </scope>
                        <scope line="2613">
                            <declaration name="nread" type="int" line="2614"/>
                            <scope line="2615"/>
                        </scope>
                    </scope>
                </method>
                <method name="available" type="int" line="2624">
                    <comment line="2646">
                        avoid unnecessary call to in.available() if possible                        
                    </comment>
                    <scope line="2625">
                        <scope line="2626">
                            <declaration name="n" type="int" line="2627"/>
                        </scope>
                        <declaration name="unreadAvail" type="int" line="2646"/>
                    </scope>
                    <scope line="2649"/>
                </method>
                <method name="close" type="void" line="2654">
                    <scope line="2655"/>
                </method>
                <javadoc line="2663">
                    Attempts to read len bytes into byte array b at offset off.  Returns
                      the number of bytes read, or -1 if the end of stream/block data has
                      been reached.  If copy is true, reads values into an intermediate
                      buffer before copying them to b (to avoid exposing a reference to
                      b).                    
                </javadoc>
                <method name="read" type="int" line="2670">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                        <param name="copy" type="boolean"/>
                    </params>
                    <scope line="2671"/>
                    <scope line="2673">
                        <scope line="2674"/>
                        <scope line="2677"/>
                        <declaration name="nread" type="int" line="2680"/>
                    </scope>
                    <scope line="2684">
                        <declaration name="nread" type="int" line="2685"/>
                        <scope line="2686"/>
                    </scope>
                    <scope line="2690"/>
                </method>
                <method name="readFully" type="void" line="2703">
                    <params>
                        <param name="b" type="byte[]"/>
                    </params>
                </method>
                <method name="readFully" type="void" line="2707">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                </method>
                <method name="readFully" type="void" line="2713">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                        <param name="copy" type="boolean"/>
                    </params>
                    <scope line="2714">
                        <declaration name="n" type="int" line="2715"/>
                        <scope line="2716"/>
                    </scope>
                </method>
                <method name="skipBytes" type="int" line="2724">
                    <params>
                        <param name="n" type="int"/>
                    </params>
                </method>
                <method name="readBoolean" type="boolean" line="2728">
                    <declaration name="v" type="int" line="2729"/>
                    <scope line="2730"/>
                </method>
                <method name="readByte" type="byte" line="2736">
                    <declaration name="v" type="int" line="2737"/>
                    <scope line="2738"/>
                </method>
                <method name="readUnsignedByte" type="int" line="2744">
                    <declaration name="v" type="int" line="2745"/>
                    <scope line="2746"/>
                </method>
                <method name="readChar" type="char" line="2752">
                    <scope line="2753"/>
                    <scope line="2756"/>
                    <declaration name="v" type="char" line="2759"/>
                </method>
                <method name="readShort" type="short" line="2764">
                    <scope line="2765"/>
                    <scope line="2768"/>
                    <declaration name="v" type="short" line="2771"/>
                </method>
                <method name="readUnsignedShort" type="int" line="2776">
                    <scope line="2777"/>
                    <scope line="2780"/>
                    <declaration name="v" type="int" line="2783"/>
                </method>
                <method name="readInt" type="int" line="2788">
                    <scope line="2789"/>
                    <scope line="2792"/>
                    <declaration name="v" type="int" line="2795"/>
                </method>
                <method name="readFloat" type="float" line="2800">
                    <scope line="2801"/>
                    <scope line="2804"/>
                    <declaration name="v" type="float" line="2807"/>
                </method>
                <method name="readLong" type="long" line="2812">
                    <scope line="2813"/>
                    <scope line="2816"/>
                    <declaration name="v" type="long" line="2819"/>
                </method>
                <method name="readDouble" type="double" line="2824">
                    <scope line="2825"/>
                    <scope line="2828"/>
                    <declaration name="v" type="double" line="2831"/>
                </method>
                <method name="readUTF" type="String" line="2836"/>
                <method name="readLine" type="String" line="2840">
                    <comment line="2842">
                        deprecated, not worth optimizing                        
                    </comment>
                </method>
                <method name="readBooleans" type="void" line="2852">
                    <params>
                        <param name="v" type="boolean[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="stop" type="int" line="2853"/>
                    <scope line="2854">
                        <scope line="2855">
                            <declaration name="span" type="int" line="2856"/>
                        </scope>
                        <scope line="2860"/>
                        <scope line="2863"/>
                        <scope line="2867"/>
                    </scope>
                </method>
                <method name="readChars" type="void" line="2873">
                    <params>
                        <param name="v" type="char[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="stop" type="int" line="2874"/>
                    <scope line="2875">
                        <scope line="2876">
                            <declaration name="span" type="int" line="2877"/>
                        </scope>
                        <scope line="2881"/>
                        <scope line="2884"/>
                        <scope line="2888"/>
                    </scope>
                </method>
                <method name="readShorts" type="void" line="2895">
                    <params>
                        <param name="v" type="short[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="stop" type="int" line="2896"/>
                    <scope line="2897">
                        <scope line="2898">
                            <declaration name="span" type="int" line="2899"/>
                        </scope>
                        <scope line="2903"/>
                        <scope line="2906"/>
                        <scope line="2910"/>
                    </scope>
                </method>
                <method name="readInts" type="void" line="2917">
                    <params>
                        <param name="v" type="int[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="stop" type="int" line="2918"/>
                    <scope line="2919">
                        <scope line="2920">
                            <declaration name="span" type="int" line="2921"/>
                        </scope>
                        <scope line="2925"/>
                        <scope line="2928"/>
                        <scope line="2932"/>
                    </scope>
                </method>
                <method name="readFloats" type="void" line="2939">
                    <params>
                        <param name="v" type="float[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="span" type="int" line="2940"/>
                    <scope line="2941">
                        <scope line="2942"/>
                        <scope line="2946"/>
                        <scope line="2949"/>
                    </scope>
                </method>
                <method name="readLongs" type="void" line="2959">
                    <params>
                        <param name="v" type="long[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="stop" type="int" line="2960"/>
                    <scope line="2961">
                        <scope line="2962">
                            <declaration name="span" type="int" line="2963"/>
                        </scope>
                        <scope line="2967"/>
                        <scope line="2970"/>
                        <scope line="2974"/>
                    </scope>
                </method>
                <method name="readDoubles" type="void" line="2981">
                    <params>
                        <param name="v" type="double[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="span" type="int" line="2982"/>
                    <scope line="2983">
                        <scope line="2984"/>
                        <scope line="2988"/>
                        <scope line="2991"/>
                    </scope>
                </method>
                <javadoc line="3001">
                    Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
                      identical to standard UTF, except that it uses an 8 byte header
                      (instead of the standard 2 bytes) to convey the UTF encoding length.                    
                </javadoc>
                <method name="readLongUTF" type="String" line="3006"/>
                <javadoc line="3010">
                    Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
                      or 8-byte length header) of a UTF encoding, which occupies the next
                      utflen bytes.                    
                </javadoc>
                <method name="readUTFBody" type="String" line="3015">
                    <params>
                        <param name="utflen" type="long"/>
                    </params>
                    <comment line="3028">
                        near block boundary, read one byte at a time                        
                    </comment>
                    <comment line="3031">
                        shift and refill buffer manually                        
                    </comment>
                    <declaration name="sbuf" type="StringBuilder" line="3016"/>
                    <scope line="3017"/>
                    <scope line="3021">
                        <declaration name="avail" type="int" line="3022"/>
                        <scope line="3023"/>
                        <scope line="3025">
                            <scope line="3026"/>
                            <scope line="3029">
                                <scope line="3031"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="3044">
                    Reads span of UTF-encoded characters out of internal buffer
                      (starting at offset pos and ending at or before offset end),
                      consuming no more than utflen bytes.  Appends read characters to
                      sbuf.  Returns the number of bytes consumed.                    
                </javadoc>
                <method name="readUTFSpan" type="long" line="3052">
                    <params>
                        <param name="sbuf" type="StringBuilder"/>
                        <param name="utflen" type="long"/>
                    </params>
                    <comment line="3057">
                        stop short of last char unless all of utf bytes in buffer                        
                    </comment>
                    <comment line="3073">
                        1 byte format: 0xxxxxxx                        
                    </comment>
                    <comment line="3078">
                        2 byte format: 110xxxxx 10xxxxxx                        
                    </comment>
                    <comment line="3087">
                        3 byte format: 1110xxxx 10xxxxxx 10xxxxxx                        
                    </comment>
                    <comment line="3099">
                        10xx xxxx, 1111 xxxx                        
                    </comment>
                    <comment line="3107">
                        Fix for 4450867: if a malformed utf char causes the
                         conversion loop to scan past the expected end of the utf
                         string, only consume the expected number of utf bytes.                        
                    </comment>
                    <declaration name="cpos" type="int" line="3053"/>
                    <declaration name="start" type="int" line="3054"/>
                    <declaration name="avail" type="int" line="3055"/>
                    <declaration name="stop" type="int" line="3057"/>
                    <declaration name="outOfBounds" type="boolean" line="3058"/>
                    <scope line="3060">
                        <scope line="3061">
                            <declaration name="b1" type="int" line="3062"/>
                            <scope line="3079"/>
                            <scope line="3090"/>
                        </scope>
                    </scope>
                    <scope line="3102"/>
                    <scope line="3104">
                        <scope line="3105"/>
                    </scope>
                </method>
                <javadoc line="3120">
                    Reads in single UTF-encoded character one byte at a time, appends
                      the character to sbuf, and returns the number of bytes consumed.
                      This method is used when reading in UTF strings written in block
                      data mode to handle UTF-encoded characters which (potentially)
                      straddle block-data boundaries.                    
                </javadoc>
                <method name="readUTFChar" type="int" line="3129">
                    <params>
                        <param name="sbuf" type="StringBuilder"/>
                        <param name="utflen" type="long"/>
                    </params>
                    <comment line="3141">
                        1 byte format: 0xxxxxxx                        
                    </comment>
                    <comment line="3146">
                        2 byte format: 110xxxxx 10xxxxxx                        
                    </comment>
                    <comment line="3158">
                        3 byte format: 1110xxxx 10xxxxxx 10xxxxxx                        
                    </comment>
                    <comment line="3161">
                        consume remaining byte                        
                    </comment>
                    <comment line="3175">
                        10xx xxxx, 1111 xxxx                        
                    </comment>
                    <declaration name="b1" type="int" line="3130"/>
                    <scope line="3146"/>
                    <scope line="3150"/>
                    <scope line="3158">
                        <scope line="3159"/>
                    </scope>
                    <scope line="3166"/>
                </method>
            </class>
            <class name="HandleTable" line="3180">
                <comment line="2005">
                    REMIND: remove once hotspot inlines Float.intBitsToFloat                    
                </comment>
                <comment line="2013">
                    REMIND: remove once hotspot inlines Double.longBitsToDouble                    
                </comment>
                <comment line="2029">
                    REMIND: change name to something more accurate?                    
                </comment>
                <comment line="2357">
                    block data state fields; values meaningful only when blkmode true                    
                </comment>
                <comment line="2578">
                                        
                </comment>
                <comment line="2579">
                    The following methods are equivalent to their counterparts in
                     InputStream, except that they interpret data block boundaries and
                     read the requested data from within data blocks when in block data
                     mode.                    
                </comment>
                <comment line="2696">
                                        
                </comment>
                <comment line="2697">
                    The following methods are equivalent to their counterparts in
                     DataInputStream, except that they interpret data block boundaries
                     and read the requested data from within data blocks when in block
                     data mode.                    
                </comment>
                <comment line="2845">
                                        
                </comment>
                <comment line="2846">
                    The following methods read in spans of primitive data values.
                     Though equivalent to calling the corresponding primitive read
                     methods repeatedly, these methods are optimized for reading groups
                     of primitive data values more efficiently.                    
                </comment>
                <comment line="3209">
                    REMIND: add full description of exception propagation algorithm?                    
                </comment>
                <comment line="3212">
                                        
                </comment>
                <javadoc line="3180">
                    Unsynchronized table which tracks wire handle to object mappings, as
                      well as ClassNotFoundExceptions associated with deserialized objects.
                      This class implements an exception-propagation algorithm for
                      determining which objects should have ClassNotFoundExceptions associated
                      with them, taking into account cycles and discontinuities (e.g., skipped
                      fields) in the object graph.
                      &lt;p&gt;General use of the table is as follows: during deserialization, a
                      given object is first assigned a handle by calling the assign method.
                      This method leaves the assigned handle in an &quot;open&quot; state, wherein
                      dependencies on the exception status of other handles can be registered
                      by calling the markDependency method, or an exception can be directly
                      associated with the handle by calling markException.  When a handle is
                      tagged with an exception, the HandleTable assumes responsibility for
                      propagating the exception to any other objects which depend
                      (transitively) on the exception-tagged object.
                      &lt;p&gt;Once all exception information/dependencies for the handle have been
                      registered, the handle should be &quot;closed&quot; by calling the finish method
                      on it.  The act of finishing a handle allows the exception propagation
                      algorithm to aggressively prune dependency links, lessening the
                      performance/memory impact of exception tracking.
                      &lt;p&gt;Note that the exception propagation algorithm used depends on handles
                      being assigned/finished in LIFO order; however, for simplicity as well
                      as memory conservation, it does not enforce this constraint.                    
                </javadoc>
                <declaration name="STATUS_OK" type="byte" line="3212"/>
                <declaration name="STATUS_UNKNOWN" type="byte" line="3213"/>
                <declaration name="STATUS_EXCEPTION" type="byte" line="3214"/>
                <declaration name="status" type="byte[]" line="3216"/>
                <javadoc line="3216">
                    array mapping handle -&gt; object status                    
                </javadoc>
                <declaration name="entries" type="Object[]" line="3218"/>
                <javadoc line="3218">
                    array mapping handle -&gt; object/exception (depending on status)                    
                </javadoc>
                <declaration name="deps" type="HandleList[]" line="3220"/>
                <javadoc line="3220">
                    array mapping handle -&gt; list of dependent handles (if any)                    
                </javadoc>
                <declaration name="lowDep" type="int" line="3222"/>
                <javadoc line="3222">
                    lowest unresolved dependency                    
                </javadoc>
                <declaration name="size" type="int" line="3224"/>
                <javadoc line="3224">
                    number of handles in table                    
                </javadoc>
                <javadoc line="3227">
                    Creates handle table with the given initial capacity.                    
                </javadoc>
                <method name="HandleTable" type="constructor" line="3230">
                    <params>
                        <param name="initialCapacity" type="int"/>
                    </params>
                </method>
                <javadoc line="3236">
                    Assigns next available handle to given object, and returns assigned
                      handle.  Once object has been completely deserialized (and all
                      dependencies on other objects identified), the handle should be
                      &quot;closed&quot; by passing it to finish().                    
                </javadoc>
                <method name="assign" type="int" line="3242">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="3243"/>
                </method>
                <javadoc line="3251">
                    Registers a dependency (in exception status) of one handle on
                      another.  The dependent handle must be &quot;open&quot; (i.e., assigned, but
                      not finished yet).  No action is taken if either dependent or target
                      handle is NULL_HANDLE.                    
                </javadoc>
                <method name="markDependency" type="void" line="3257">
                    <params>
                        <param name="dependent" type="int"/>
                        <param name="target" type="int"/>
                    </params>
                    <comment line="3267">
                        ignore dependencies on objs with no exception                        
                    </comment>
                    <comment line="3271">
                        eagerly propagate exception                        
                    </comment>
                    <comment line="3277">
                        add to dependency list of target                        
                    </comment>
                    <comment line="3283">
                        remember lowest unresolved target seen                        
                    </comment>
                    <scope line="3258"/>
                    <scope line="3277"/>
                    <scope line="3283"/>
                </method>
                <javadoc line="3301">
                    Associates a ClassNotFoundException (if one not already associated)
                      with the currently active handle and propagates it to other
                      referencing objects as appropriate.  The specified handle must be
                      &quot;open&quot; (i.e., assigned, but not finished yet).                    
                </javadoc>
                <method name="markException" type="void" line="3307">
                    <params>
                        <param name="handle" type="int"/>
                        <param name="ex" type="ClassNotFoundException"/>
                    </params>
                    <comment line="3314">
                        propagate exception to dependents                        
                    </comment>
                    <declaration name="dlist" type="HandleList" line="3314"/>
                    <scope line="3315">
                        <declaration name="ndeps" type="int" line="3316"/>
                        <scope line="3317"/>
                    </scope>
                </method>
                <javadoc line="3332">
                    Marks given handle as finished, meaning that no new dependencies
                      will be marked for handle.  Calls to the assign and finish methods
                      must occur in LIFO order.                    
                </javadoc>
                <method name="finish" type="void" line="3337">
                    <params>
                        <param name="handle" type="int"/>
                    </params>
                    <comment line="3341">
                        no pending unknowns, only resolve current handle                        
                    </comment>
                    <comment line="3344">
                        pending unknowns now clearable, resolve all upward handles                        
                    </comment>
                    <comment line="3348">
                        unresolved backrefs present, can&apos;t resolve anything yet                        
                    </comment>
                    <comment line="3352">
                        change STATUS_UNKNOWN -&gt; STATUS_OK in selected span of handles                        
                    </comment>
                    <declaration name="end" type="int" line="3338"/>
                    <scope line="3339"/>
                    <scope line="3342"/>
                    <scope line="3346"/>
                    <scope line="3352"/>
                </method>
                <javadoc line="3369">
                    Assigns a new object to the given handle.  The object previously
                      associated with the handle is forgotten.  This method has no effect
                      if the given handle already has an exception associated with it.
                      This method may be called at any time after the handle is assigned.                    
                </javadoc>
                <method name="setObject" type="void" line="3375">
                    <params>
                        <param name="handle" type="int"/>
                        <param name="obj" type="Object"/>
                    </params>
                </method>
                <javadoc line="3390">
                    Looks up and returns object associated with the given handle.
                      Returns null if the given handle is NULL_HANDLE, or if it has an
                      associated ClassNotFoundException.                    
                </javadoc>
                <method name="lookupObject" type="Object" line="3395">
                    <params>
                        <param name="handle" type="int"/>
                    </params>
                </method>
                <javadoc line="3401">
                    Looks up and returns ClassNotFoundException associated with the
                      given handle.  Returns null if the given handle is NULL_HANDLE, or
                      if there is no ClassNotFoundException associated with the handle.                    
                </javadoc>
                <method name="lookupException" type="ClassNotFoundException" line="3406">
                    <params>
                        <param name="handle" type="int"/>
                    </params>
                </method>
                <javadoc line="3412">
                    Resets table to its initial state.                    
                </javadoc>
                <method name="clear" type="void" line="3415"/>
                <javadoc line="3423">
                    Returns number of handles registered in table.                    
                </javadoc>
                <method name="size" type="int" line="3426"/>
                <javadoc line="3430">
                    Expands capacity of internal arrays.                    
                </javadoc>
                <method name="grow" type="void" line="3433">
                    <declaration name="newCapacity" type="int" line="3434"/>
                    <declaration name="newStatus" type="byte[]" line="3436"/>
                    <declaration name="newEntries" type="Object[]" line="3437"/>
                    <declaration name="newDeps" type="HandleList[]" line="3438"/>
                </method>
                <class name="HandleList" line="3449">
                    <javadoc line="3449">
                        Simple growable list of (integer) handles.                        
                    </javadoc>
                    <declaration name="list" type="int[]" line="3453"/>
                    <declaration name="size" type="int" line="3454"/>
                    <method name="HandleList" type="constructor" line="3456"/>
                    <method name="add" type="void" line="3459">
                        <params>
                            <param name="handle" type="int"/>
                        </params>
                        <scope line="3460">
                            <declaration name="newList" type="int[]" line="3461"/>
                        </scope>
                    </method>
                    <method name="get" type="int" line="3468">
                        <params>
                            <param name="index" type="int"/>
                        </params>
                        <scope line="3469"/>
                    </method>
                    <method name="size" type="int" line="3475"/>
                </class>
            </class>
            <javadoc line="3481">
                Method for cloning arrays in case of using unsharing reading                
            </javadoc>
            <method name="cloneArray" type="Object" line="3484">
                <params>
                    <param name="array" type="Object"/>
                </params>
                <scope line="3485"/>
                <scope line="3487"/>
                <scope line="3489"/>
                <scope line="3491"/>
                <scope line="3493"/>
                <scope line="3495"/>
                <scope line="3497"/>
                <scope line="3499"/>
                <scope line="3501"/>
                <scope line="3503"/>
            </method>
        </class>
    </source>