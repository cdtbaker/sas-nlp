<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.io">
        <import package="java.util.concurrent.atomic.AtomicReferenceFieldUpdater"/>
        <class name="BufferedInputStream" line="29">
            <extends class="FilterInputStream"/>
            <javadoc line="29">
                A &lt;code&gt;BufferedInputStream&lt;/code&gt; adds
                  functionality to another input stream-namely,
                  the ability to buffer the input and to
                  support the &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;
                  methods. When  the &lt;code&gt;BufferedInputStream&lt;/code&gt;
                  is created, an internal buffer array is
                  created. As bytes  from the stream are read
                  or skipped, the internal buffer is refilled
                  as necessary  from the contained input stream,
                  many bytes at a time. The &lt;code&gt;mark&lt;/code&gt;
                  operation  remembers a point in the input
                  stream and the &lt;code&gt;reset&lt;/code&gt; operation
                  causes all the  bytes read since the most
                  recent &lt;code&gt;mark&lt;/code&gt; operation to be
                  reread before new bytes are  taken from
                  the contained input stream.                
                <author>
                    Arthur van Hoff                    
                </author>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="defaultBufferSize" type="int" line="53"/>
            <declaration name="buf" type="byte" line="55"/>
            <javadoc line="55">
                The internal buffer array where the data is stored. When necessary,
                  it may be replaced by another array of
                  a different size.                
            </javadoc>
            <declaration name="bufUpdater" type="AtomicReferenceFieldUpdater&lt;BufferedInputStream,byte[]&gt;" line="62"/>
            <javadoc line="62">
                Atomic updater to provide compareAndSet for buf. This is
                  necessary because closes can be asynchronous. We use nullness
                  of buf[] as primary indicator that this stream is closed. (The
                  &quot;in&quot; field is also nulled out on close.)                
            </javadoc>
            <declaration name="count" type="int" line="73"/>
            <javadoc line="73">
                The index one greater than the index of the last valid byte in
                  the buffer.
                  This value is always
                  in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;buf.length&lt;/code&gt;;
                  elements &lt;code&gt;buf[0]&lt;/code&gt;  through &lt;code&gt;buf[count-1]
                  &lt;/code&gt;contain buffered input data obtained
                  from the underlying  input stream.                
            </javadoc>
            <declaration name="pos" type="int" line="84"/>
            <javadoc line="84">
                The current position in the buffer. This is the index of the next
                  character to be read from the &lt;code&gt;buf&lt;/code&gt; array.
                  &lt;p&gt;
                  This value is always in the range &lt;code&gt;0&lt;/code&gt;
                  through &lt;code&gt;count&lt;/code&gt;. If it is less
                  than &lt;code&gt;count&lt;/code&gt;, then  &lt;code&gt;buf[pos]&lt;/code&gt;
                  is the next byte to be supplied as input;
                  if it is equal to &lt;code&gt;count&lt;/code&gt;, then
                  the  next &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;
                  operation will require more bytes to be
                  read from the contained  input stream.                
                <see>
                    java.io.BufferedInputStream#buf                    
                </see>
            </javadoc>
            <declaration name="markpos" type="int" line="101"/>
            <javadoc line="101">
                The value of the &lt;code&gt;pos&lt;/code&gt; field at the time the last
                  &lt;code&gt;mark&lt;/code&gt; method was called.
                  &lt;p&gt;
                  This value is always
                  in the range &lt;code&gt;-1&lt;/code&gt; through &lt;code&gt;pos&lt;/code&gt;.
                  If there is no marked position in  the input
                  stream, this field is &lt;code&gt;-1&lt;/code&gt;. If
                  there is a marked position in the input
                  stream,  then &lt;code&gt;buf[markpos]&lt;/code&gt;
                  is the first byte to be supplied as input
                  after a &lt;code&gt;reset&lt;/code&gt; operation. If
                  &lt;code&gt;markpos&lt;/code&gt; is not &lt;code&gt;-1&lt;/code&gt;,
                  then all bytes from positions &lt;code&gt;buf[markpos]&lt;/code&gt;
                  through  &lt;code&gt;buf[pos-1]&lt;/code&gt; must remain
                  in the buffer array (though they may be
                  moved to  another place in the buffer array,
                  with suitable adjustments to the values
                  of &lt;code&gt;count&lt;/code&gt;,  &lt;code&gt;pos&lt;/code&gt;,
                  and &lt;code&gt;markpos&lt;/code&gt;); they may not
                  be discarded unless and until the difference
                  between &lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;markpos&lt;/code&gt;
                  exceeds &lt;code&gt;marklimit&lt;/code&gt;.                
                <see>
                    java.io.BufferedInputStream#mark(int)                    
                </see>
                <see>
                    java.io.BufferedInputStream#pos                    
                </see>
            </javadoc>
            <declaration name="marklimit" type="int" line="130"/>
            <javadoc line="130">
                The maximum read ahead allowed after a call to the
                  &lt;code&gt;mark&lt;/code&gt; method before subsequent calls to the
                  &lt;code&gt;reset&lt;/code&gt; method fail.
                  Whenever the difference between &lt;code&gt;pos&lt;/code&gt;
                  and &lt;code&gt;markpos&lt;/code&gt; exceeds &lt;code&gt;marklimit&lt;/code&gt;,
                  then the  mark may be dropped by setting
                  &lt;code&gt;markpos&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt;.                
                <see>
                    java.io.BufferedInputStream#mark(int)                    
                </see>
                <see>
                    java.io.BufferedInputStream#reset()                    
                </see>
            </javadoc>
            <javadoc line="144">
                Check to make sure that underlying input stream has not been
                  nulled out due to close; if not return it;                
            </javadoc>
            <method name="getInIfOpen" type="InputStream" line="148">
                <declaration name="input" type="InputStream" line="149"/>
            </method>
            <javadoc line="155">
                Check to make sure that buffer has not been nulled out due to
                  close; if not return it;                
            </javadoc>
            <method name="getBufIfOpen" type="byte[]" line="159">
                <declaration name="buffer" type="byte[]" line="160"/>
            </method>
            <javadoc line="166">
                Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt;
                  and saves its  argument, the input stream
                  &lt;code&gt;in&lt;/code&gt;, for later use. An internal
                  buffer array is created and  stored in &lt;code&gt;buf&lt;/code&gt;.                
                <param>
                    in   the underlying input stream.                    
                </param>
            </javadoc>
            <method name="BufferedInputStream" type="constructor" line="174">
                <params>
                    <param name="in" type="InputStream"/>
                </params>
            </method>
            <javadoc line="178">
                Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt;
                  with the specified buffer size,
                  and saves its  argument, the input stream
                  &lt;code&gt;in&lt;/code&gt;, for later use.  An internal
                  buffer array of length  &lt;code&gt;size&lt;/code&gt;
                  is created and stored in &lt;code&gt;buf&lt;/code&gt;.                
                <param>
                    in     the underlying input stream.                    
                </param>
                <param>
                    size   the buffer size.                    
                </param>
                <exception>
                    IllegalArgumentException if size <= 0.                    
                </exception>
            </javadoc>
            <method name="BufferedInputStream" type="constructor" line="190">
                <params>
                    <param name="in" type="InputStream"/>
                    <param name="size" type="int"/>
                </params>
                <scope line="192"/>
            </method>
            <javadoc line="198">
                Fills the buffer with more data, taking into account
                  shuffling and other tricks for dealing with marks.
                  Assumes that it is being called by a synchronized method.
                  This method also assumes that all data has already been read in,
                  hence pos &gt; count.                
            </javadoc>
            <method name="fill" type="void" line="205">
                <comment line="208">
                                        
                </comment>
                <comment line="209">
                                        
                </comment>
                <comment line="210">
                                        
                </comment>
                <comment line="216">
                                        
                </comment>
                <comment line="217">
                                        
                </comment>
                <comment line="218">
                                        
                </comment>
                <comment line="225">
                    Can&apos;t replace buf if there was an async close.                    
                </comment>
                <comment line="226">
                    Note: This would need to be changed if fill()                    
                </comment>
                <comment line="227">
                    is ever made accessible to multiple threads.                    
                </comment>
                <comment line="228">
                    But for now, the only way CAS can fail is via close.                    
                </comment>
                <comment line="229">
                    assert buf == null;                    
                </comment>
                <declaration name="buffer" type="byte[]" line="206"/>
                <scope line="210">
                    <declaration name="sz" type="int" line="211"/>
                </scope>
                <scope line="215"/>
                <scope line="218">
                    <declaration name="nsz" type="int" line="219"/>
                    <declaration name="nbuf" type="byte" line="222"/>
                    <scope line="224"/>
                </scope>
                <declaration name="n" type="int" line="235"/>
            </method>
            <javadoc line="240">
                See
                  the general contract of the &lt;code&gt;read&lt;/code&gt;
                  method of &lt;code&gt;InputStream&lt;/code&gt;.                
                <return>
                    the next byte of data, or <code>-1</code> if the end of the
                      stream is reached.                    
                </return>
                <exception>
                    IOException  if this input stream has been closed by
                      invoking its {@link #close()} method,
                      or an I/O error occurs.                    
                </exception>
                <see>
                    java.io.FilterInputStream#in                    
                </see>
            </javadoc>
            <method name="read" type="int" line="252">
                <scope line="253"/>
            </method>
            <javadoc line="261">
                Read characters into a portion of an array, reading from the underlying
                  stream at most once if necessary.                
            </javadoc>
            <method name="read1" type="int" line="265">
                <params>
                    <param name="b" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="268">
                    If the requested length is at least as large as the buffer, and
                    if there is no markreset activity, do not bother to copy the
                    bytes into the local buffer.  In this way buffered streams will                    
                </comment>
                <declaration name="avail" type="int" line="266"/>
                <scope line="267">
                    <scope line="272"/>
                </scope>
                <declaration name="cnt" type="int" line="279"/>
            </method>
            <javadoc line="285">
                Reads bytes from this byte-input stream into the specified byte array,
                  starting at the given offset.
                  &lt;p&gt; This method implements the general contract of the corresponding
                  &lt;code&gt;{@link InputStream#read(byte[],int,int) read}&lt;/code&gt; method of
                  the &lt;code&gt;{@link InputStream}&lt;/code&gt; class.  As an additional
                  convenience, it attempts to read as many bytes as possible by repeatedly
                  invoking the &lt;code&gt;read&lt;/code&gt; method of the underlying stream.  This
                  iterated &lt;code&gt;read&lt;/code&gt; continues until one of the following
                  conditions becomes true: &lt;ul&gt;
                  &lt;li&gt; The specified number of bytes have been read,
                  &lt;li&gt; The &lt;code&gt;read&lt;/code&gt; method of the underlying stream returns
                  &lt;code&gt;-1&lt;/code&gt;, indicating end-of-file, or
                  &lt;li&gt; The &lt;code&gt;available&lt;/code&gt; method of the underlying stream
                  returns zero, indicating that further input requests would block.
                  &lt;/ul&gt; If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns
                  &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns
                  &lt;code&gt;-1&lt;/code&gt;.  Otherwise this method returns the number of bytes
                  actually read.
                  &lt;p&gt; Subclasses of this class are encouraged, but not required, to
                  attempt to read as many bytes as possible in the same fashion.                
                <param>
                    b     destination buffer.                    
                </param>
                <param>
                    off   offset at which to start storing bytes.                    
                </param>
                <param>
                    len   maximum number of bytes to read.                    
                </param>
                <return>
                    the number of bytes read, or <code>-1</code> if the end of
                      the stream has been reached.                    
                </return>
                <exception>
                    IOException  if this input stream has been closed by
                      invoking its {@link #close()} method,
                      or an I/O error occurs.                    
                </exception>
            </javadoc>
            <method name="read" type="int" line="324">
                <params>
                    <param name="b" type="byte"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="325">
                    Check for closed stream                    
                </comment>
                <comment line="340">
                    if not closed but no bytes available, return                    
                </comment>
                <scope line="326"/>
                <scope line="328"/>
                <declaration name="n" type="int" line="332"/>
                <scope line="333">
                    <declaration name="nread" type="int" line="334"/>
                    <declaration name="input" type="InputStream" line="341"/>
                </scope>
            </method>
            <javadoc line="347">
                See the general contract of the &lt;code&gt;skip&lt;/code&gt;
                  method of &lt;code&gt;InputStream&lt;/code&gt;.                
                <exception>
                    IOException  if the stream does not support seek,
                      or if this input stream has been closed by
                      invoking its {@link #close()} method, or an
                      I/O error occurs.                    
                </exception>
            </javadoc>
            <method name="skip" type="long" line="356">
                <params>
                    <param name="n" type="long"/>
                </params>
                <comment line="357">
                    Check for closed stream                    
                </comment>
                <comment line="364">
                    If no mark position set then don&apos;t keep in buffer                    
                </comment>
                <comment line="368">
                    Fill in buffer to save bytes for reset                    
                </comment>
                <scope line="358"/>
                <declaration name="avail" type="long" line="361"/>
                <scope line="363"/>
                <declaration name="skipped" type="long" line="375"/>
            </method>
            <javadoc line="380">
                Returns an estimate of the number of bytes that can be read (or
                  skipped over) from this input stream without blocking by the next
                  invocation of a method for this input stream. The next invocation might be
                  the same thread or another thread.  A single read or skip of this
                  many bytes will not block, but may read or skip fewer bytes.
                  &lt;p&gt;
                  This method returns the sum of the number of bytes remaining to be read in
                  the buffer (&lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt;) and the result of calling the{@link java.io.FilterInputStream#in in}.available().                
                <return>
                    an estimate of the number of bytes that can be read (or skipped
                      over) from this input stream without blocking.                    
                </return>
                <exception>
                    IOException  if this input stream has been closed by
                      invoking its {@link #close()} method,
                      or an I/O error occurs.                    
                </exception>
            </javadoc>
            <method name="available" type="int" line="397">
                <declaration name="n" type="int" line="398"/>
                <declaration name="avail" type="int" line="399"/>
            </method>
            <javadoc line="405">
                See the general contract of the &lt;code&gt;mark&lt;/code&gt;
                  method of &lt;code&gt;InputStream&lt;/code&gt;.                
                <param>
                    readlimit   the maximum limit of bytes that can be read before
                      the mark position becomes invalid.                    
                </param>
                <see>
                    java.io.BufferedInputStream#reset()                    
                </see>
            </javadoc>
            <method name="mark" type="void" line="413">
                <params>
                    <param name="readlimit" type="int"/>
                </params>
            </method>
            <javadoc line="418">
                See the general contract of the &lt;code&gt;reset&lt;/code&gt;
                  method of &lt;code&gt;InputStream&lt;/code&gt;.
                  &lt;p&gt;
                  If &lt;code&gt;markpos&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;
                  (no mark has been set or the mark has been
                  invalidated), an &lt;code&gt;IOException&lt;/code&gt;
                  is thrown. Otherwise, &lt;code&gt;pos&lt;/code&gt; is
                  set equal to &lt;code&gt;markpos&lt;/code&gt;.                
                <exception>
                    IOException  if this stream has not been marked or,
                      if the mark has been invalidated, or the stream
                      has been closed by invoking its {@link #close()}method, or an I/O error occurs.                    
                </exception>
                <see>
                    java.io.BufferedInputStream#mark(int)                    
                </see>
            </javadoc>
            <method name="reset" type="void" line="434">
                <comment line="435">
                    Cause exception if closed                    
                </comment>
            </method>
            <javadoc line="441">
                Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt;
                  and &lt;code&gt;reset&lt;/code&gt; methods. The &lt;code&gt;markSupported&lt;/code&gt;
                  method of &lt;code&gt;BufferedInputStream&lt;/code&gt; returns
                  &lt;code&gt;true&lt;/code&gt;.                
                <return>
                    a <code>boolean</code> indicating if this stream type supports
                      the <code>mark</code> and <code>reset</code> methods.                    
                </return>
                <see>
                    java.io.InputStream#mark(int)                    
                </see>
                <see>
                    java.io.InputStream#reset()                    
                </see>
            </javadoc>
            <method name="markSupported" type="boolean" line="452"/>
            <javadoc line="456">
                Closes this input stream and releases any system resources
                  associated with the stream.
                  Once the stream has been closed, further read(), available(), reset(),
                  or skip() invocations will throw an IOException.
                  Closing a previously closed stream has no effect.                
                <exception>
                    IOException  if an I/O error occurs.                    
                </exception>
            </javadoc>
            <method name="close" type="void" line="465">
                <comment line="475">
                    Else retry in case a new buf was CASed in fill()                    
                </comment>
                <declaration name="buffer" type="byte[]" line="466"/>
                <scope line="467">
                    <scope line="468">
                        <declaration name="input" type="InputStream" line="469"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>