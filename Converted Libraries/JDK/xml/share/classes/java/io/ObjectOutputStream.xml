<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.io">
        <import package="java.io.ObjectStreamClass.WeakClassKey"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.List"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.concurrent.ConcurrentMap"/>
        <import package="java.io.ObjectStreamClass.processQueue"/>
        <import package="java.io.SerialCallbackContext"/>
        <class name="ObjectOutputStream" line="13">
            <extends class="OutputStream"/>
            <implements interface="ObjectOutput"/>
            <implements interface="ObjectStreamConstants"/>
            <javadoc line="13">
                An ObjectOutputStream writes primitive data types and graphs of Java objects
                  to an OutputStream.  The objects can be read (reconstituted) using an
                  ObjectInputStream.  Persistent storage of objects can be accomplished by
                  using a file for the stream.  If the stream is a network socket stream, the
                  objects can be reconstituted on another host or in another process.
                  &lt;p&gt;Only objects that support the java.io.Serializable interface can be
                  written to streams.  The class of each serializable object is encoded
                  including the class name and signature of the class, the values of the
                  object&apos;s fields and arrays, and the closure of any other objects referenced
                  from the initial objects.
                  &lt;p&gt;The method writeObject is used to write an object to the stream.  Any
                  object, including Strings and arrays, is written with writeObject. Multiple
                  objects or primitives can be written to the stream.  The objects must be
                  read back from the corresponding ObjectInputstream with the same types and
                  in the same order as they were written.
                  &lt;p&gt;Primitive data types can also be written to the stream using the
                  appropriate methods from DataOutput. Strings can also be written using the
                  writeUTF method.
                  &lt;p&gt;The default serialization mechanism for an object writes the class of the
                  object, the class signature, and the values of all non-transient and
                  non-static fields.  References to other objects (except in transient or
                  static fields) cause those objects to be written also. Multiple references
                  to a single object are encoded using a reference sharing mechanism so that
                  graphs of objects can be restored to the same shape as when the original was
                  written.
                  &lt;p&gt;For example to write an object that can be read by the example in
                  ObjectInputStream:
                  &lt;br&gt;
                  &lt;pre&gt;
                  FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;);
                  ObjectOutputStream oos = new ObjectOutputStream(fos);
                  oos.writeInt(12345);
                  oos.writeObject(&quot;Today&quot;);
                  oos.writeObject(new Date());
                  oos.close();
                  &lt;/pre&gt;
                  &lt;p&gt;Classes that require special handling during the serialization and
                  deserialization process must implement special methods with these exact
                  signatures:
                  &lt;br&gt;
                  &lt;pre&gt;
                  private void readObject(java.io.ObjectInputStream stream)
                  throws IOException, ClassNotFoundException;
                  private void writeObject(java.io.ObjectOutputStream stream)
                  throws IOException
                  private void readObjectNoData()
                  throws ObjectStreamException;
                  &lt;/pre&gt;
                  &lt;p&gt;The writeObject method is responsible for writing the state of the object
                  for its particular class so that the corresponding readObject method can
                  restore it.  The method does not need to concern itself with the state
                  belonging to the object&apos;s superclasses or subclasses.  State is saved by
                  writing the individual fields to the ObjectOutputStream using the
                  writeObject method or by using the methods for primitive data types
                  supported by DataOutput.
                  &lt;p&gt;Serialization does not write out the fields of any object that does not
                  implement the java.io.Serializable interface.  Subclasses of Objects that
                  are not serializable can be serializable. In this case the non-serializable
                  class must have a no-arg constructor to allow its fields to be initialized.
                  In this case it is the responsibility of the subclass to save and restore
                  the state of the non-serializable class. It is frequently the case that the
                  fields of that class are accessible (public, package, or protected) or that
                  there are get and set methods that can be used to restore the state.
                  &lt;p&gt;Serialization of an object can be prevented by implementing writeObject
                  and readObject methods that throw the NotSerializableException.  The
                  exception will be caught by the ObjectOutputStream and abort the
                  serialization process.
                  &lt;p&gt;Implementing the Externalizable interface allows the object to assume
                  complete control over the contents and format of the object&apos;s serialized
                  form.  The methods of the Externalizable interface, writeExternal and
                  readExternal, are called to save and restore the objects state.  When
                  implemented by a class they can write and read their own state using all of
                  the methods of ObjectOutput and ObjectInput.  It is the responsibility of
                  the objects to handle any versioning that occurs.
                  &lt;p&gt;Enum constants are serialized differently than ordinary serializable or
                  externalizable objects.  The serialized form of an enum constant consists
                  solely of its name; field values of the constant are not transmitted.  To
                  serialize an enum constant, ObjectOutputStream writes the string returned by
                  the constant&apos;s name method.  Like other serializable or externalizable
                  objects, enum constants can function as the targets of back references
                  appearing subsequently in the serialization stream.  The process by which
                  enum constants are serialized cannot be customized; any class-specific
                  writeObject and writeReplace methods defined by enum types are ignored
                  during serialization.  Similarly, any serialPersistentFields or
                  serialVersionUID field declarations are also ignored--all enum types have a
                  fixed serialVersionUID of 0L.
                  &lt;p&gt;Primitive data, excluding serializable fields and externalizable data, is
                  written to the ObjectOutputStream in block-data records. A block data record
                  is composed of a header and data. The block data header consists of a marker
                  and the number of bytes to follow the header.  Consecutive primitive data
                  writes are merged into one block-data record.  The blocking factor used for
                  a block-data record will be 1024 bytes.  Each block-data record will be
                  filled up to 1024 bytes, or be written whenever there is a termination of
                  block-data mode.  Calls to the ObjectOutputStream methods writeObject,
                  defaultWriteObject and writeFields initially terminate any existing
                  block-data record.                
                <author>
                    Mike Warres                    
                </author>
                <author>
                    Roger Riggs                    
                </author>
                <see>
                    java.io.DataOutput                    
                </see>
                <see>
                    java.io.ObjectInputStream                    
                </see>
                <see>
                    java.io.Serializable                    
                </see>
                <see>
                    java.io.Externalizable                    
                </see>
                <see>
                    <a href="../../../platform/serialization/spec/output.html">Object Serialization Specification, Section 2, Object Output Classes</a>                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <class name="Caches" line="120">
                <declaration name="subclassAudits" type="ConcurrentMap&lt;WeakClassKey,Boolean&gt;" line="121"/>
                <javadoc line="121">
                    cache of subclass security audit results                    
                </javadoc>
                <declaration name="subclassAuditsQueue" type="ReferenceQueue&lt;Class&lt;?&gt;&gt;" line="125"/>
                <javadoc line="125">
                    queue for WeakReferences to audited subclasses                    
                </javadoc>
            </class>
            <declaration name="bout" type="BlockDataOutputStream" line="130"/>
            <javadoc line="130">
                filter stream for handling block data conversion                
            </javadoc>
            <declaration name="handles" type="HandleTable" line="134"/>
            <javadoc line="134">
                obj -&gt; wire handle map                
            </javadoc>
            <declaration name="subs" type="ReplaceTable" line="138"/>
            <javadoc line="138">
                obj -&gt; replacement obj map                
            </javadoc>
            <declaration name="protocol" type="int" line="142"/>
            <javadoc line="142">
                stream protocol version                
            </javadoc>
            <declaration name="depth" type="int" line="146"/>
            <javadoc line="146">
                recursion depth                
            </javadoc>
            <declaration name="primVals" type="byte[]" line="150"/>
            <javadoc line="150">
                buffer for writing primitive field values                
            </javadoc>
            <declaration name="enableOverride" type="boolean" line="154"/>
            <javadoc line="154">
                if true, invoke writeObjectOverride() instead of writeObject()                
            </javadoc>
            <declaration name="enableReplace" type="boolean" line="158"/>
            <javadoc line="158">
                if true, invoke replaceObject()                
            </javadoc>
            <declaration name="curContext" type="SerialCallbackContext" line="162"/>
            <javadoc line="162">
                Context during upcalls to class-defined writeObject methods; holds
                  object currently being serialized and descriptor for current class.
                  Null when not during writeObject upcall.                
            </javadoc>
            <declaration name="curPut" type="PutFieldImpl" line="168"/>
            <javadoc line="168">
                current PutField object                
            </javadoc>
            <declaration name="debugInfoStack" type="DebugTraceInfoStack" line="172"/>
            <javadoc line="172">
                custom storage for debug trace info                
            </javadoc>
            <declaration name="extendedDebugInfo" type="boolean" line="176"/>
            <javadoc line="176">
                value of &quot;sun.io.serialization.extendedDebugInfo&quot; property,
                  as true or false for extended information about exception&apos;s place                
            </javadoc>
            <javadoc line="181">
                Creates an ObjectOutputStream that writes to the specified OutputStream.
                  This constructor writes the serialization stream header to the
                  underlying stream; callers may wish to flush the stream immediately to
                  ensure that constructors for receiving ObjectInputStreams will not block
                  when reading the header.
                  &lt;p&gt;If a security manager is installed, this constructor will check for
                  the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
                  directly or indirectly by the constructor of a subclass which overrides
                  the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared
                  methods.                
                <param>
                    out output stream to write to                    
                </param>
                <throws>
                    IOException if an I/O error occurs while writing stream header                    
                </throws>
                <throws>
                    SecurityException if untrusted subclass illegally overrides
                      security-sensitive methods                    
                </throws>
                <throws>
                    NullPointerException if <code>out</code> is <code>null</code>                    
                </throws>
                <since>
                    1.4                    
                </since>
                <see>
                    ObjectOutputStream#ObjectOutputStream()                    
                </see>
                <see>
                    ObjectOutputStream#putFields()                    
                </see>
                <see>
                    ObjectInputStream#ObjectInputStream(InputStream)                    
                </see>
            </javadoc>
            <method name="ObjectOutputStream" type="constructor" line="202">
                <params>
                    <param name="out" type="OutputStream"/>
                </params>
                <scope line="210"/>
                <scope line="213"/>
            </method>
            <javadoc line="217">
                Provide a way for subclasses that are completely reimplementing
                  ObjectOutputStream to not have to allocate private data just used by
                  this implementation of ObjectOutputStream.
                  &lt;p&gt;If there is a security manager installed, this method first calls the
                  security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method with a
                  &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;
                  permission to ensure it&apos;s ok to enable subclassing.                
                <throws>
                    SecurityException if a security manager exists and its
                      <code>checkPermission</code> method denies enabling
                      subclassing.                    
                </throws>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.io.SerializablePermission                    
                </see>
            </javadoc>
            <method name="ObjectOutputStream" type="constructor" line="231">
                <declaration name="sm" type="SecurityManager" line="232"/>
                <scope line="233"/>
            </method>
            <javadoc line="242">
                Specify stream protocol version to use when writing the stream.
                  &lt;p&gt;This routine provides a hook to enable the current version of
                  Serialization to write in a format that is backwards compatible to a
                  previous version of the stream format.
                  &lt;p&gt;Every effort will be made to avoid introducing additional
                  backwards incompatibilities; however, sometimes there is no
                  other alternative.                
                <param>
                    version use ProtocolVersion from java.io.ObjectStreamConstants.                    
                </param>
                <throws>
                    IllegalStateException if called after any objects
                      have been serialized.                    
                </throws>
                <throws>
                    IllegalArgumentException if invalid version is passed in.                    
                </throws>
                <throws>
                    IOException if I/O errors occur                    
                </throws>
                <see>
                    java.io.ObjectStreamConstants#PROTOCOL_VERSION_1                    
                </see>
                <see>
                    java.io.ObjectStreamConstants#PROTOCOL_VERSION_2                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="useProtocolVersion" type="void" line="259">
                <params>
                    <param name="version" type="int"/>
                </params>
                <scope line="260"/>
            </method>
            <javadoc line="272">
                Write the specified object to the ObjectOutputStream.  The class of the
                  object, the signature of the class, and the values of the non-transient
                  and non-static fields of the class and all of its supertypes are
                  written.  Default serialization for a class can be overridden using the
                  writeObject and the readObject methods.  Objects referenced by this
                  object are written transitively so that a complete equivalent graph of
                  objects can be reconstructed by an ObjectInputStream.
                  &lt;p&gt;Exceptions are thrown for problems with the OutputStream and for
                  classes that should not be serialized.  All exceptions are fatal to the
                  OutputStream, which is left in an indeterminate state, and it is up to
                  the caller to ignore or recover the stream state.                
                <throws>
                    InvalidClassException Something is wrong with a class used by
                      serialization.                    
                </throws>
                <throws>
                    NotSerializableException Some object to be serialized does not
                      implement the java.io.Serializable interface.                    
                </throws>
                <throws>
                    IOException Any exception thrown by the underlying
                      OutputStream.                    
                </throws>
            </javadoc>
            <method name="writeObject" type="void" line="291">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="292"/>
                <scope line="296"/>
                <scope line="299">
                    <scope line="300"/>
                </scope>
            </method>
            <javadoc line="306">
                Method used by subclasses to override the default writeObject method.
                  This method is called by trusted subclasses of ObjectInputStream that
                  constructed ObjectInputStream using the protected no-arg constructor.
                  The subclass is expected to provide an override method with the modifier
                  &quot;final&quot;.                
                <param>
                    obj object to be written to the underlying stream                    
                </param>
                <throws>
                    IOException if there are I/O errors while writing to the
                      underlying stream                    
                </throws>
                <see>
                    #ObjectOutputStream()                    
                </see>
                <see>
                    #writeObject(Object)                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="writeObjectOverride" type="void" line="319">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="321">
                Writes an &quot;unshared&quot; object to the ObjectOutputStream.  This method is
                  identical to writeObject, except that it always writes the given object
                  as a new, unique object in the stream (as opposed to a back-reference
                  pointing to a previously serialized instance).  Specifically:
                  &lt;ul&gt;
                  &lt;li&gt;An object written via writeUnshared is always serialized in the
                  same manner as a newly appearing object (an object that has not
                  been written to the stream yet), regardless of whether or not the
                  object has been written previously.
                  &lt;li&gt;If writeObject is used to write an object that has been previously
                  written with writeUnshared, the previous writeUnshared operation
                  is treated as if it were a write of a separate object.  In other
                  words, ObjectOutputStream will never generate back-references to
                  object data written by calls to writeUnshared.
                  &lt;/ul&gt;
                  While writing an object via writeUnshared does not in itself guarantee a
                  unique reference to the object when it is deserialized, it allows a
                  single object to be defined multiple times in a stream, so that multiple
                  calls to readUnshared by the receiver will not conflict.  Note that the
                  rules described above only apply to the base-level object written with
                  writeUnshared, and not to any transitively referenced sub-objects in the
                  object graph to be serialized.
                  &lt;p&gt;ObjectOutputStream subclasses which override this method can only be
                  constructed in security contexts possessing the
                  &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
                  instantiate such a subclass without this permission will cause a
                  SecurityException to be thrown.                
                <param>
                    obj object to write to stream                    
                </param>
                <throws>
                    NotSerializableException if an object in the graph to be
                      serialized does not implement the Serializable interface                    
                </throws>
                <throws>
                    InvalidClassException if a problem exists with the class of an
                      object to be serialized                    
                </throws>
                <throws>
                    IOException if an I/O error occurs during serialization                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="writeUnshared" type="void" line="357">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <scope line="358"/>
                <scope line="361">
                    <scope line="362"/>
                </scope>
            </method>
            <javadoc line="368">
                Write the non-static and non-transient fields of the current class to
                  this stream.  This may only be called from the writeObject method of the
                  class being serialized. It will throw the NotActiveException if it is
                  called otherwise.                
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      <code>OutputStream</code>                    
                </throws>
            </javadoc>
            <method name="defaultWriteObject" type="void" line="376">
                <scope line="377"/>
                <declaration name="curObj" type="Object" line="380"/>
                <declaration name="curDesc" type="ObjectStreamClass" line="381"/>
            </method>
            <javadoc line="386">
                Retrieve the object used to buffer persistent fields to be written to
                  the stream.  The fields will be written to the stream when writeFields
                  method is called.                
                <return>
                    an instance of the class Putfield that holds the serializable
                      fields                    
                </return>
                <throws>
                    IOException if I/O errors occur                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="putFields" type="ObjectOutputStream.PutField" line="395">
                <scope line="396">
                    <scope line="397"/>
                    <declaration name="curObj" type="Object" line="400"/>
                    <declaration name="curDesc" type="ObjectStreamClass" line="401"/>
                </scope>
            </method>
            <javadoc line="406">
                Write the buffered fields to the stream.                
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
                <throws>
                    NotActiveException Called when a classes writeObject method was
                      not called to write the state of the object.                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="writeFields" type="void" line="414">
                <scope line="415"/>
            </method>
            <javadoc line="422">
                Reset will disregard the state of any objects already written to the
                  stream.  The state is reset to be the same as a new ObjectOutputStream.
                  The current point in the stream is marked as reset so the corresponding
                  ObjectInputStream will be reset at the same point.  Objects previously
                  written to the stream will not be refered to as already being in the
                  stream.  They will be written to the stream again.                
                <throws>
                    IOException if reset() is invoked while serializing an object.                    
                </throws>
            </javadoc>
            <method name="reset" type="void" line="431">
                <scope line="432"/>
            </method>
            <javadoc line="440">
                Subclasses may implement this method to allow class data to be stored in
                  the stream. By default this method does nothing.  The corresponding
                  method in ObjectInputStream is resolveClass.  This method is called
                  exactly once for each unique class in the stream.  The class name and
                  signature will have already been written to the stream.  This method may
                  make free use of the ObjectOutputStream to save any representation of
                  the class it deems suitable (for example, the bytes of the class file).
                  The resolveClass method in the corresponding subclass of
                  ObjectInputStream must read and use any data or objects written by
                  annotateClass.                
                <param>
                    cl the class to annotate custom data for                    
                </param>
                <throws>
                    IOException Any exception thrown by the underlying
                      OutputStream.                    
                </throws>
            </javadoc>
            <method name="annotateClass" type="void" line="455">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="457">
                Subclasses may implement this method to store custom data in the stream
                  along with descriptors for dynamic proxy classes.
                  &lt;p&gt;This method is called exactly once for each unique proxy class
                  descriptor in the stream.  The default implementation of this method in
                  &lt;code&gt;ObjectOutputStream&lt;/code&gt; does nothing.
                  &lt;p&gt;The corresponding method in &lt;code&gt;ObjectInputStream&lt;/code&gt; is
                  &lt;code&gt;resolveProxyClass&lt;/code&gt;.  For a given subclass of
                  &lt;code&gt;ObjectOutputStream&lt;/code&gt; that overrides this method, the
                  &lt;code&gt;resolveProxyClass&lt;/code&gt; method in the corresponding subclass of
                  &lt;code&gt;ObjectInputStream&lt;/code&gt; must read any data or objects written by
                  &lt;code&gt;annotateProxyClass&lt;/code&gt;.                
                <param>
                    cl the proxy class to annotate custom data for                    
                </param>
                <throws>
                    IOException any exception thrown by the underlying
                      <code>OutputStream</code>                    
                </throws>
                <see>
                    ObjectInputStream#resolveProxyClass(String[])                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="annotateProxyClass" type="void" line="475">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="477">
                This method will allow trusted subclasses of ObjectOutputStream to
                  substitute one object for another during serialization. Replacing
                  objects is disabled until enableReplaceObject is called. The
                  enableReplaceObject method checks that the stream requesting to do
                  replacement can be trusted.  The first occurrence of each object written
                  into the serialization stream is passed to replaceObject.  Subsequent
                  references to the object are replaced by the object returned by the
                  original call to replaceObject.  To ensure that the private state of
                  objects is not unintentionally exposed, only trusted streams may use
                  replaceObject.
                  &lt;p&gt;The ObjectOutputStream.writeObject method takes a parameter of type
                  Object (as opposed to type Serializable) to allow for cases where
                  non-serializable objects are replaced by serializable ones.
                  &lt;p&gt;When a subclass is replacing objects it must insure that either a
                  complementary substitution must be made during deserialization or that
                  the substituted object is compatible with every field where the
                  reference will be stored.  Objects whose type is not a subclass of the
                  type of the field or array element abort the serialization by raising an
                  exception and the object is not be stored.
                  &lt;p&gt;This method is called only once when each object is first
                  encountered.  All subsequent references to the object will be redirected
                  to the new object. This method should return the object to be
                  substituted or the original object.
                  &lt;p&gt;Null can be returned as the object to be substituted, but may cause
                  NullReferenceException in classes that contain references to the
                  original object since they may be expecting an object instead of
                  null.                
                <param>
                    obj the object to be replaced                    
                </param>
                <return>
                    the alternate object that replaced the specified one                    
                </return>
                <throws>
                    IOException Any exception thrown by the underlying
                      OutputStream.                    
                </throws>
            </javadoc>
            <method name="replaceObject" type="Object" line="510">
                <params>
                    <param name="obj" type="Object"/>
                </params>
            </method>
            <javadoc line="513">
                Enable the stream to do replacement of objects in the stream.  When
                  enabled, the replaceObject method is called for every object being
                  serialized.
                  &lt;p&gt;If &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager
                  installed, this method first calls the security manager&apos;s
                  &lt;code&gt;checkPermission&lt;/code&gt; method with a
                  &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to
                  ensure it&apos;s ok to enable the stream to do replacement of objects in the
                  stream.                
                <param>
                    enable boolean parameter to enable replacement of objects                    
                </param>
                <return>
                    the previous setting before this method was invoked                    
                </return>
                <throws>
                    SecurityException if a security manager exists and its
                      <code>checkPermission</code> method denies enabling the stream
                      to do replacement of objects in the stream.                    
                </throws>
                <see>
                    SecurityManager#checkPermission                    
                </see>
                <see>
                    java.io.SerializablePermission                    
                </see>
            </javadoc>
            <method name="enableReplaceObject" type="boolean" line="531">
                <params>
                    <param name="enable" type="boolean"/>
                </params>
                <scope line="532"/>
                <scope line="535">
                    <declaration name="sm" type="SecurityManager" line="536"/>
                    <scope line="537"/>
                </scope>
            </method>
            <javadoc line="544">
                The writeStreamHeader method is provided so subclasses can append or
                  prepend their own header to the stream.  It writes the magic number and
                  version to the stream.                
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeStreamHeader" type="void" line="551"/>
            <javadoc line="555">
                Write the specified class descriptor to the ObjectOutputStream.  Class
                  descriptors are used to identify the classes of objects written to the
                  stream.  Subclasses of ObjectOutputStream may override this method to
                  customize the way in which class descriptors are written to the
                  serialization stream.  The corresponding method in ObjectInputStream,
                  &lt;code&gt;readClassDescriptor&lt;/code&gt;, should then be overridden to
                  reconstitute the class descriptor from its custom stream representation.
                  By default, this method writes class descriptors according to the format
                  defined in the Object Serialization specification.
                  &lt;p&gt;Note that this method will only be called if the ObjectOutputStream
                  is not using the old serialization stream format (set by calling
                  ObjectOutputStream&apos;s &lt;code&gt;useProtocolVersion&lt;/code&gt; method).  If this
                  serialization stream is using the old format
                  (&lt;code&gt;PROTOCOL_VERSION_1&lt;/code&gt;), the class descriptor will be written
                  internally in a manner that cannot be overridden or customized.                
                <param>
                    desc class descriptor to write to the stream                    
                </param>
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
                <see>
                    java.io.ObjectInputStream#readClassDescriptor()                    
                </see>
                <see>
                    #useProtocolVersion(int)                    
                </see>
                <see>
                    java.io.ObjectStreamConstants#PROTOCOL_VERSION_1                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="writeClassDescriptor" type="void" line="578">
                <params>
                    <param name="desc" type="ObjectStreamClass"/>
                </params>
            </method>
            <javadoc line="581">
                Writes a byte. This method will block until the byte is actually
                  written.                
                <param>
                    val the byte to be written to the stream                    
                </param>
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="write" type="void" line="587">
                <params>
                    <param name="val" type="int"/>
                </params>
            </method>
            <javadoc line="590">
                Writes an array of bytes. This method will block until the bytes are
                  actually written.                
                <param>
                    buf the data to be written                    
                </param>
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="write" type="void" line="596">
                <params>
                    <param name="buf" type="byte[]"/>
                </params>
            </method>
            <javadoc line="599">
                Writes a sub array of bytes.                
                <param>
                    buf the data to be written                    
                </param>
                <param>
                    off the start offset in the data                    
                </param>
                <param>
                    len the number of bytes that are written                    
                </param>
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="write" type="void" line="606">
                <params>
                    <param name="buf" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="607"/>
                <declaration name="endoff" type="int" line="610"/>
                <scope line="611"/>
            </method>
            <javadoc line="616">
                Flushes the stream. This will write any buffered output bytes and flush
                  through to the underlying stream.                
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="flush" type="void" line="621"/>
            <javadoc line="624">
                Drain any buffered data in ObjectOutputStream.  Similar to flush but
                  does not propagate the flush to the underlying stream.                
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="drain" type="void" line="630"/>
            <javadoc line="633">
                Closes the stream. This method must be called to release any resources
                  associated with the stream.                
                <throws>
                    IOException If an I/O error has occurred.                    
                </throws>
            </javadoc>
            <method name="close" type="void" line="638"/>
            <javadoc line="643">
                Writes a boolean.                
                <param>
                    val the boolean to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeBoolean" type="void" line="649">
                <params>
                    <param name="val" type="boolean"/>
                </params>
            </method>
            <javadoc line="652">
                Writes an 8 bit byte.                
                <param>
                    val the byte value to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeByte" type="void" line="658">
                <params>
                    <param name="val" type="int"/>
                </params>
            </method>
            <javadoc line="661">
                Writes a 16 bit short.                
                <param>
                    val the short value to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeShort" type="void" line="667">
                <params>
                    <param name="val" type="int"/>
                </params>
            </method>
            <javadoc line="670">
                Writes a 16 bit char.                
                <param>
                    val the char value to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeChar" type="void" line="676">
                <params>
                    <param name="val" type="int"/>
                </params>
            </method>
            <javadoc line="679">
                Writes a 32 bit int.                
                <param>
                    val the integer value to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeInt" type="void" line="685">
                <params>
                    <param name="val" type="int"/>
                </params>
            </method>
            <javadoc line="688">
                Writes a 64 bit long.                
                <param>
                    val the long value to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeLong" type="void" line="694">
                <params>
                    <param name="val" type="long"/>
                </params>
            </method>
            <javadoc line="697">
                Writes a 32 bit float.                
                <param>
                    val the float value to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeFloat" type="void" line="703">
                <params>
                    <param name="val" type="float"/>
                </params>
            </method>
            <javadoc line="706">
                Writes a 64 bit double.                
                <param>
                    val the double value to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeDouble" type="void" line="712">
                <params>
                    <param name="val" type="double"/>
                </params>
            </method>
            <javadoc line="715">
                Writes a String as a sequence of bytes.                
                <param>
                    str the String of bytes to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeBytes" type="void" line="721">
                <params>
                    <param name="str" type="String"/>
                </params>
            </method>
            <javadoc line="724">
                Writes a String as a sequence of chars.                
                <param>
                    str the String of chars to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeChars" type="void" line="730">
                <params>
                    <param name="str" type="String"/>
                </params>
            </method>
            <javadoc line="733">
                Primitive data write of this String in
                  &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
                  format.  Note that there is a
                  significant difference between writing a String into the stream as
                  primitive data or as an Object. A String instance written by writeObject
                  is written into the stream as a String initially. Future writeObject()
                  calls write references to the string into the stream.                
                <param>
                    str the String to be written                    
                </param>
                <throws>
                    IOException if I/O errors occur while writing to the underlying
                      stream                    
                </throws>
            </javadoc>
            <method name="writeUTF" type="void" line="745">
                <params>
                    <param name="str" type="String"/>
                </params>
            </method>
            <class name="PutField" line="748">
                <javadoc line="748">
                    Provide programmatic access to the persistent fields to be written
                      to ObjectOutput.                    
                    <since>
                        1.2                        
                    </since>
                </javadoc>
                <method name="put" type="void" line="754"/>
                <javadoc line="754">
                    Put the value of the named boolean field into the persistent field.                    
                    <param>
                        name the name of the serializable field                        
                    </param>
                    <param>
                        val the value to assign to the field                        
                    </param>
                    <throws>
                        IllegalArgumentException if <code>name</code> does not
                          match the name of a serializable field for the class whose fields
                          are being written, or if the type of the named field is not
                          <code>boolean</code>                        
                    </throws>
                </javadoc>
                <method name="put" type="void" line="764"/>
                <javadoc line="764">
                    Put the value of the named byte field into the persistent field.                    
                    <param>
                        name the name of the serializable field                        
                    </param>
                    <param>
                        val the value to assign to the field                        
                    </param>
                    <throws>
                        IllegalArgumentException if <code>name</code> does not
                          match the name of a serializable field for the class whose fields
                          are being written, or if the type of the named field is not
                          <code>byte</code>                        
                    </throws>
                </javadoc>
                <method name="put" type="void" line="774"/>
                <javadoc line="774">
                    Put the value of the named char field into the persistent field.                    
                    <param>
                        name the name of the serializable field                        
                    </param>
                    <param>
                        val the value to assign to the field                        
                    </param>
                    <throws>
                        IllegalArgumentException if <code>name</code> does not
                          match the name of a serializable field for the class whose fields
                          are being written, or if the type of the named field is not
                          <code>char</code>                        
                    </throws>
                </javadoc>
                <method name="put" type="void" line="784"/>
                <javadoc line="784">
                    Put the value of the named short field into the persistent field.                    
                    <param>
                        name the name of the serializable field                        
                    </param>
                    <param>
                        val the value to assign to the field                        
                    </param>
                    <throws>
                        IllegalArgumentException if <code>name</code> does not
                          match the name of a serializable field for the class whose fields
                          are being written, or if the type of the named field is not
                          <code>short</code>                        
                    </throws>
                </javadoc>
                <method name="put" type="void" line="794"/>
                <javadoc line="794">
                    Put the value of the named int field into the persistent field.                    
                    <param>
                        name the name of the serializable field                        
                    </param>
                    <param>
                        val the value to assign to the field                        
                    </param>
                    <throws>
                        IllegalArgumentException if <code>name</code> does not
                          match the name of a serializable field for the class whose fields
                          are being written, or if the type of the named field is not
                          <code>int</code>                        
                    </throws>
                </javadoc>
                <method name="put" type="void" line="804"/>
                <javadoc line="804">
                    Put the value of the named long field into the persistent field.                    
                    <param>
                        name the name of the serializable field                        
                    </param>
                    <param>
                        val the value to assign to the field                        
                    </param>
                    <throws>
                        IllegalArgumentException if <code>name</code> does not
                          match the name of a serializable field for the class whose fields
                          are being written, or if the type of the named field is not
                          <code>long</code>                        
                    </throws>
                </javadoc>
                <method name="put" type="void" line="814"/>
                <javadoc line="814">
                    Put the value of the named float field into the persistent field.                    
                    <param>
                        name the name of the serializable field                        
                    </param>
                    <param>
                        val the value to assign to the field                        
                    </param>
                    <throws>
                        IllegalArgumentException if <code>name</code> does not
                          match the name of a serializable field for the class whose fields
                          are being written, or if the type of the named field is not
                          <code>float</code>                        
                    </throws>
                </javadoc>
                <method name="put" type="void" line="824"/>
                <javadoc line="824">
                    Put the value of the named double field into the persistent field.                    
                    <param>
                        name the name of the serializable field                        
                    </param>
                    <param>
                        val the value to assign to the field                        
                    </param>
                    <throws>
                        IllegalArgumentException if <code>name</code> does not
                          match the name of a serializable field for the class whose fields
                          are being written, or if the type of the named field is not
                          <code>double</code>                        
                    </throws>
                </javadoc>
                <method name="put" type="void" line="834"/>
                <javadoc line="834">
                    Put the value of the named Object field into the persistent field.                    
                    <param>
                        name the name of the serializable field                        
                    </param>
                    <param>
                        val the value to assign to the field
                          (which may be <code>null</code>)                        
                    </param>
                    <throws>
                        IllegalArgumentException if <code>name</code> does not
                          match the name of a serializable field for the class whose fields
                          are being written, or if the type of the named field is not a
                          reference type                        
                    </throws>
                </javadoc>
                <method name="write" type="void" line="845"/>
                <javadoc line="845">
                    Write the data and fields to the specified ObjectOutput stream,
                      which must be the same stream that produced this
                      &lt;code&gt;PutField&lt;/code&gt; object.                    
                    <param>
                        out the stream to write the data and fields to                        
                    </param>
                    <throws>
                        IOException if I/O errors occur while writing to the
                          underlying stream                        
                    </throws>
                    <throws>
                        IllegalArgumentException if the specified stream is not
                          the same stream that produced this <code>PutField</code>
                          object                        
                    </throws>
                    <deprecated>
                        This method does not write the values contained by this
                          <code>PutField</code> object in a proper format, and may
                          result in corruption of the serialization stream.  The
                          correct way to write <code>PutField</code> data is by
                          calling the {@link java.io.ObjectOutputStream#writeFields()}method.                        
                    </deprecated>
                </javadoc>
            </class>
            <javadoc line="863">
                Returns protocol version in use.                
            </javadoc>
            <method name="getProtocolVersion" type="int" line="866"/>
            <javadoc line="869">
                Writes string without allowing it to be replaced in stream.  Used by
                  ObjectStreamClass to write class descriptor type strings.                
            </javadoc>
            <method name="writeTypeString" type="void" line="873">
                <params>
                    <param name="str" type="String"/>
                </params>
                <declaration name="handle" type="int" line="874"/>
                <scope line="875"/>
                <scope line="878"/>
                <scope line="881"/>
            </method>
            <javadoc line="885">
                Verifies that this (possibly subclass) instance can be constructed
                  without violating security constraints: the subclass must not override
                  security-sensitive non-final methods, or else the
                  &quot;enableSubclassImplementation&quot; SerializablePermission is checked.                
            </javadoc>
            <method name="verifySubclass" type="void" line="891">
                <declaration name="cl" type="Class" line="892"/>
                <scope line="893"/>
                <declaration name="sm" type="SecurityManager" line="896"/>
                <scope line="897"/>
                <declaration name="key" type="WeakClassKey" line="901"/>
                <declaration name="result" type="Boolean" line="902"/>
                <scope line="903"/>
                <scope line="907"/>
            </method>
            <javadoc line="912">
                Performs reflective checks on given subclass to verify that it doesn&apos;t
                  override security-sensitive non-final methods.  Returns true if subclass
                  is &quot;safe&quot;, false otherwise.                
            </javadoc>
            <method name="auditSubclass" type="boolean" line="917">
                <params>
                    <param name="subcl" type="Class"/>
                </params>
                <anonymous_class line="918">
                    <method name="run" type="Boolean" line="919">
                        <scope line="920">
                            <scope line="921"/>
                            <scope line="925"/>
                            <scope line="927"/>
                            <scope line="931"/>
                        </scope>
                    </method>
                </anonymous_class>
                <declaration name="result" type="Boolean" line="918"/>
            </method>
            <javadoc line="940">
                Clears internal data structures.                
            </javadoc>
            <method name="clear" type="void" line="943"/>
            <javadoc line="947">
                Underlying writeObject/writeUnshared implementation.                
            </javadoc>
            <method name="writeObject0" type="void" line="950">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="unshared" type="boolean"/>
                </params>
                <declaration name="oldMode" type="boolean" line="951"/>
                <scope line="953">
                    <declaration name="h" type="int" line="954"/>
                    <scope line="955"/>
                    <scope line="959"/>
                    <scope line="963"/>
                    <scope line="967"/>
                    <declaration name="orig" type="Object" line="971"/>
                    <declaration name="cl" type="Class" line="972"/>
                    <declaration name="desc" type="ObjectStreamClass" line="973"/>
                    <scope line="974">
                        <declaration name="repCl" type="Class" line="975"/>
                        <scope line="977"/>
                    </scope>
                    <scope line="982">
                        <declaration name="rep" type="Object" line="983"/>
                        <scope line="984"/>
                    </scope>
                    <scope line="990">
                        <scope line="992"/>
                        <scope line="996"/>
                        <scope line="1000"/>
                        <scope line="1004"/>
                    </scope>
                    <scope line="1009"/>
                    <scope line="1012"/>
                    <scope line="1015"/>
                    <scope line="1018"/>
                    <scope line="1021">
                        <scope line="1022"/>
                        <scope line="1025"/>
                    </scope>
                </scope>
                <scope line="1030"/>
            </method>
            <javadoc line="1035">
                Writes null code to stream.                
            </javadoc>
            <method name="writeNull" type="void" line="1038"/>
            <javadoc line="1041">
                Writes given object handle to stream.                
            </javadoc>
            <method name="writeHandle" type="void" line="1044">
                <params>
                    <param name="handle" type="int"/>
                </params>
            </method>
            <javadoc line="1048">
                Writes representation of given class to stream.                
            </javadoc>
            <method name="writeClass" type="void" line="1051">
                <params>
                    <param name="cl" type="Class"/>
                    <param name="unshared" type="boolean"/>
                </params>
            </method>
            <javadoc line="1056">
                Writes representation of given class descriptor to stream.                
            </javadoc>
            <method name="writeClassDesc" type="void" line="1059">
                <params>
                    <param name="desc" type="ObjectStreamClass"/>
                    <param name="unshared" type="boolean"/>
                </params>
                <declaration name="handle" type="int" line="1060"/>
                <scope line="1061"/>
                <scope line="1064"/>
                <scope line="1067"/>
                <scope line="1070"/>
            </method>
            <javadoc line="1074">
                Writes class descriptor representing a dynamic proxy class to stream.                
            </javadoc>
            <method name="writeProxyDesc" type="void" line="1077">
                <params>
                    <param name="desc" type="ObjectStreamClass"/>
                    <param name="unshared" type="boolean"/>
                </params>
                <declaration name="cl" type="Class" line="1080"/>
                <declaration name="ifaces" type="Class[]" line="1081"/>
                <scope line="1083"/>
            </method>
            <javadoc line="1092">
                Writes class descriptor representing a standard (i.e., not a dynamic
                  proxy) class to stream.                
            </javadoc>
            <method name="writeNonProxyDesc" type="void" line="1096">
                <params>
                    <param name="desc" type="ObjectStreamClass"/>
                    <param name="unshared" type="boolean"/>
                </params>
                <scope line="1099"/>
                <scope line="1102"/>
                <declaration name="cl" type="Class" line="1105"/>
            </method>
            <javadoc line="1112">
                Writes given string to stream, using standard or long UTF format
                  depending on string length.                
            </javadoc>
            <method name="writeString" type="void" line="1116">
                <params>
                    <param name="str" type="String"/>
                    <param name="unshared" type="boolean"/>
                </params>
                <declaration name="utflen" type="long" line="1118"/>
                <scope line="1119"/>
                <scope line="1123"/>
            </method>
            <javadoc line="1128">
                Writes given array object to stream.                
            </javadoc>
            <method name="writeArray" type="void" line="1131">
                <params>
                    <param name="array" type="Object"/>
                    <param name="desc" type="ObjectStreamClass"/>
                    <param name="unshared" type="boolean"/>
                </params>
                <declaration name="ccl" type="Class" line="1135"/>
                <scope line="1136">
                    <scope line="1137">
                        <declaration name="ia" type="int[]" line="1138"/>
                    </scope>
                    <scope line="1142">
                        <declaration name="ba" type="byte[]" line="1143"/>
                    </scope>
                    <scope line="1147">
                        <declaration name="ja" type="long[]" line="1148"/>
                    </scope>
                    <scope line="1152">
                        <declaration name="fa" type="float[]" line="1153"/>
                    </scope>
                    <scope line="1157">
                        <declaration name="da" type="double[]" line="1158"/>
                    </scope>
                    <scope line="1162">
                        <declaration name="sa" type="short[]" line="1163"/>
                    </scope>
                    <scope line="1167">
                        <declaration name="ca" type="char[]" line="1168"/>
                    </scope>
                    <scope line="1172">
                        <declaration name="za" type="boolean[]" line="1173"/>
                    </scope>
                    <scope line="1177"/>
                </scope>
                <scope line="1181">
                    <declaration name="objs" type="Object[]" line="1182"/>
                    <declaration name="len" type="int" line="1183"/>
                    <scope line="1185"/>
                    <scope line="1188">
                        <scope line="1189">
                            <scope line="1190"/>
                            <scope line="1193"/>
                            <scope line="1196">
                                <scope line="1197"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1203">
                        <scope line="1204"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1210">
                Writes given enum constant to stream.                
            </javadoc>
            <method name="writeEnum" type="void" line="1213">
                <params>
                    <param name="en" type="Enum"/>
                    <param name="desc" type="ObjectStreamClass"/>
                    <param name="unshared" type="boolean"/>
                </params>
                <declaration name="sdesc" type="ObjectStreamClass" line="1215"/>
            </method>
            <javadoc line="1220">
                Writes representation of a &quot;ordinary&quot; (i.e., not a String, Class,
                  ObjectStreamClass, array, or enum constant) serializable object to the
                  stream.                
            </javadoc>
            <method name="writeOrdinaryObject" type="void" line="1225">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="desc" type="ObjectStreamClass"/>
                    <param name="unshared" type="boolean"/>
                </params>
                <scope line="1226"/>
                <scope line="1229">
                    <scope line="1234"/>
                    <scope line="1237"/>
                </scope>
                <scope line="1241">
                    <scope line="1242"/>
                </scope>
            </method>
            <javadoc line="1247">
                Writes externalizable data of given object by invoking its
                  writeExternal() method.                
            </javadoc>
            <method name="writeExternalData" type="void" line="1251">
                <params>
                    <param name="obj" type="Externalizable"/>
                </params>
                <declaration name="oldPut" type="PutFieldImpl" line="1252"/>
                <scope line="1254"/>
                <declaration name="oldContext" type="SerialCallbackContext" line="1257"/>
                <scope line="1258">
                    <scope line="1260"/>
                    <scope line="1263"/>
                </scope>
                <scope line="1270">
                    <scope line="1272"/>
                </scope>
            </method>
            <javadoc line="1278">
                Writes instance data for each serializable class of given object, from
                  superclass to subclass.                
            </javadoc>
            <method name="writeSerialData" type="void" line="1282">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="desc" type="ObjectStreamClass"/>
                </params>
                <declaration name="slots" type="ObjectStreamClass.ClassDataSlot[]" line="1283"/>
                <scope line="1284">
                    <declaration name="slotDesc" type="ObjectStreamClass" line="1285"/>
                    <scope line="1286">
                        <declaration name="oldPut" type="PutFieldImpl" line="1287"/>
                        <declaration name="oldContext" type="SerialCallbackContext" line="1289"/>
                        <scope line="1290"/>
                        <scope line="1293"/>
                        <scope line="1300">
                            <scope line="1303"/>
                        </scope>
                    </scope>
                    <scope line="1309"/>
                </scope>
            </method>
            <javadoc line="1314">
                Fetches and writes values of serializable fields of given object to
                  stream.  The given class descriptor specifies which field values to
                  write, and in which order they should be written.                
            </javadoc>
            <method name="defaultWriteFields" type="void" line="1319">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="desc" type="ObjectStreamClass"/>
                </params>
                <declaration name="primDataSize" type="int" line="1321"/>
                <scope line="1322"/>
                <declaration name="fields" type="ObjectStreamField[]" line="1327"/>
                <declaration name="objVals" type="Object[]" line="1328"/>
                <declaration name="numPrimFields" type="int" line="1329"/>
                <scope line="1331">
                    <scope line="1332"/>
                    <scope line="1335"/>
                    <scope line="1338">
                        <scope line="1339"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1345">
                Attempts to write to stream fatal IOException that has caused
                  serialization to abort.                
            </javadoc>
            <method name="writeFatalException" type="void" line="1349">
                <params>
                    <param name="ex" type="IOException"/>
                </params>
                <declaration name="oldMode" type="boolean" line="1351"/>
                <scope line="1352"/>
                <scope line="1357"/>
            </method>
            <method name="floatsToBytes" type="void" line="1361"/>
            <javadoc line="1361">
                Converts specified span of float values into byte values.                
            </javadoc>
            <method name="doublesToBytes" type="void" line="1365"/>
            <javadoc line="1365">
                Converts specified span of double values into byte values.                
            </javadoc>
            <class name="PutFieldImpl" line="1369">
                <extends class="PutField"/>
                <javadoc line="1369">
                    Default PutField implementation.                    
                </javadoc>
                <declaration name="desc" type="ObjectStreamClass" line="1373"/>
                <javadoc line="1373">
                    class descriptor describing serializable fields                    
                </javadoc>
                <declaration name="primVals" type="byte[]" line="1377"/>
                <javadoc line="1377">
                    primitive field values                    
                </javadoc>
                <declaration name="objVals" type="Object[]" line="1381"/>
                <javadoc line="1381">
                    object field values                    
                </javadoc>
                <javadoc line="1385">
                    Creates PutFieldImpl object for writing fields defined in given
                      class descriptor.                    
                </javadoc>
                <method name="PutFieldImpl" type="constructor" line="1389">
                    <params>
                        <param name="desc" type="ObjectStreamClass"/>
                    </params>
                </method>
                <method name="put" type="void" line="1394">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="boolean"/>
                    </params>
                </method>
                <method name="put" type="void" line="1397">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="byte"/>
                    </params>
                </method>
                <method name="put" type="void" line="1400">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="char"/>
                    </params>
                </method>
                <method name="put" type="void" line="1403">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="short"/>
                    </params>
                </method>
                <method name="put" type="void" line="1406">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="int"/>
                    </params>
                </method>
                <method name="put" type="void" line="1409">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="float"/>
                    </params>
                </method>
                <method name="put" type="void" line="1412">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="long"/>
                    </params>
                </method>
                <method name="put" type="void" line="1415">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="double"/>
                    </params>
                </method>
                <method name="put" type="void" line="1418">
                    <params>
                        <param name="name" type="String"/>
                        <param name="val" type="Object"/>
                    </params>
                </method>
                <method name="write" type="void" line="1421">
                    <params>
                        <param name="out" type="ObjectOutput"/>
                    </params>
                    <scope line="1422"/>
                    <declaration name="fields" type="ObjectStreamField[]" line="1426"/>
                    <declaration name="numPrimFields" type="int" line="1427"/>
                    <scope line="1428">
                        <scope line="1429"/>
                    </scope>
                </method>
                <javadoc line="1435">
                    Writes buffered primitive data and object fields to stream.                    
                </javadoc>
                <method name="writeFields" type="void" line="1438">
                    <declaration name="fields" type="ObjectStreamField[]" line="1440"/>
                    <declaration name="numPrimFields" type="int" line="1441"/>
                    <scope line="1442">
                        <scope line="1443"/>
                        <scope line="1446"/>
                        <scope line="1449">
                            <scope line="1450"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="1456">
                    Returns offset of field with given name and type.  A specified type
                      of null matches all types, Object.class matches all non-primitive
                      types, and any other non-null type matches assignable types only.
                      Throws IllegalArgumentException if no matching field found.                    
                </javadoc>
                <method name="getFieldOffset" type="int" line="1462">
                    <params>
                        <param name="name" type="String"/>
                        <param name="type" type="Class"/>
                    </params>
                    <declaration name="field" type="ObjectStreamField" line="1463"/>
                    <scope line="1464"/>
                </method>
            </class>
            <class name="BlockDataOutputStream" line="1470">
                <extends class="OutputStream"/>
                <implements interface="DataOutput"/>
                <javadoc line="1470">
                    Buffered output stream with two modes: in default mode, outputs data in
                      same format as DataOutputStream; in &quot;block data&quot; mode, outputs data
                      bracketed by block data markers (see object serialization specification
                      for details).                    
                </javadoc>
                <declaration name="MAX_BLOCK_SIZE" type="int" line="1477"/>
                <javadoc line="1477">
                    maximum data block length                    
                </javadoc>
                <declaration name="MAX_HEADER_SIZE" type="int" line="1481"/>
                <javadoc line="1481">
                    maximum data block header length                    
                </javadoc>
                <declaration name="CHAR_BUF_SIZE" type="int" line="1485"/>
                <javadoc line="1485">
                    (tunable) length of char buffer (for writing strings)                    
                </javadoc>
                <declaration name="buf" type="byte[]" line="1489"/>
                <javadoc line="1489">
                    buffer for writing general/block data                    
                </javadoc>
                <declaration name="hbuf" type="byte[]" line="1493"/>
                <javadoc line="1493">
                    buffer for writing block data headers                    
                </javadoc>
                <declaration name="cbuf" type="char[]" line="1497"/>
                <javadoc line="1497">
                    char buffer for fast string writes                    
                </javadoc>
                <declaration name="blkmode" type="boolean" line="1501"/>
                <javadoc line="1501">
                    block data mode                    
                </javadoc>
                <declaration name="pos" type="int" line="1505"/>
                <javadoc line="1505">
                    current offset into buf                    
                </javadoc>
                <declaration name="out" type="OutputStream" line="1509"/>
                <javadoc line="1509">
                    underlying output stream                    
                </javadoc>
                <declaration name="dout" type="DataOutputStream" line="1513"/>
                <javadoc line="1513">
                    loopback stream (for data writes that span data blocks)                    
                </javadoc>
                <javadoc line="1517">
                    Creates new BlockDataOutputStream on top of given underlying stream.
                      Block data mode is turned off by default.                    
                </javadoc>
                <method name="BlockDataOutputStream" type="constructor" line="1521">
                    <params>
                        <param name="out" type="OutputStream"/>
                    </params>
                </method>
                <javadoc line="1525">
                    Sets block data mode to the given mode (true == on, false == off)
                      and returns the previous mode value.  If the new mode is the same as
                      the old mode, no action is taken.  If the new mode differs from the
                      old mode, any buffered data is flushed before switching to the new
                      mode.                    
                </javadoc>
                <method name="setBlockDataMode" type="boolean" line="1532">
                    <params>
                        <param name="mode" type="boolean"/>
                    </params>
                    <scope line="1533"/>
                </method>
                <javadoc line="1540">
                    Returns true if the stream is currently in block data mode, false
                      otherwise.                    
                </javadoc>
                <method name="getBlockDataMode" type="boolean" line="1544"/>
                <method name="write" type="void" line="1547">
                    <params>
                        <param name="b" type="int"/>
                    </params>
                    <scope line="1548"/>
                </method>
                <method name="write" type="void" line="1553">
                    <params>
                        <param name="b" type="byte[]"/>
                    </params>
                </method>
                <method name="write" type="void" line="1556">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                </method>
                <method name="flush" type="void" line="1559"/>
                <method name="close" type="void" line="1563"/>
                <javadoc line="1567">
                    Writes specified span of byte values from given array.  If copy is
                      true, copies the values to an intermediate buffer before writing
                      them to underlying stream (to avoid exposing a reference to the
                      original byte array).                    
                </javadoc>
                <method name="write" type="void" line="1573">
                    <params>
                        <param name="b" type="byte[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                        <param name="copy" type="boolean"/>
                    </params>
                    <scope line="1574"/>
                    <scope line="1579">
                        <scope line="1580"/>
                        <scope line="1583"/>
                        <scope line="1589">
                            <declaration name="wlen" type="int" line="1590"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="1598">
                    Writes all buffered data from this stream to the underlying stream,
                      but does not flush underlying stream.                    
                </javadoc>
                <method name="drain" type="void" line="1602">
                    <scope line="1603"/>
                    <scope line="1606"/>
                </method>
                <javadoc line="1612">
                    Writes block data header.  Data blocks shorter than 256 bytes are
                      prefixed with a 2-byte header; all others start with a 5-byte
                      header.                    
                </javadoc>
                <method name="writeBlockHeader" type="void" line="1617">
                    <params>
                        <param name="len" type="int"/>
                    </params>
                    <scope line="1618"/>
                    <scope line="1623"/>
                </method>
                <method name="writeBoolean" type="void" line="1629">
                    <params>
                        <param name="v" type="boolean"/>
                    </params>
                    <scope line="1630"/>
                </method>
                <method name="writeByte" type="void" line="1635">
                    <params>
                        <param name="v" type="int"/>
                    </params>
                    <scope line="1636"/>
                </method>
                <method name="writeChar" type="void" line="1641">
                    <params>
                        <param name="v" type="int"/>
                    </params>
                    <scope line="1642"/>
                    <scope line="1646"/>
                </method>
                <method name="writeShort" type="void" line="1650">
                    <params>
                        <param name="v" type="int"/>
                    </params>
                    <scope line="1651"/>
                    <scope line="1655"/>
                </method>
                <method name="writeInt" type="void" line="1659">
                    <params>
                        <param name="v" type="int"/>
                    </params>
                    <scope line="1660"/>
                    <scope line="1664"/>
                </method>
                <method name="writeFloat" type="void" line="1668">
                    <params>
                        <param name="v" type="float"/>
                    </params>
                    <scope line="1669"/>
                    <scope line="1673"/>
                </method>
                <method name="writeLong" type="void" line="1677">
                    <params>
                        <param name="v" type="long"/>
                    </params>
                    <scope line="1678"/>
                    <scope line="1682"/>
                </method>
                <method name="writeDouble" type="void" line="1686">
                    <params>
                        <param name="v" type="double"/>
                    </params>
                    <scope line="1687"/>
                    <scope line="1691"/>
                </method>
                <method name="writeBytes" type="void" line="1695">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <declaration name="endoff" type="int" line="1696"/>
                    <declaration name="cpos" type="int" line="1697"/>
                    <declaration name="csize" type="int" line="1698"/>
                    <scope line="1699">
                        <scope line="1700"/>
                        <scope line="1705"/>
                        <declaration name="n" type="int" line="1708"/>
                        <declaration name="stop" type="int" line="1709"/>
                        <scope line="1710"/>
                    </scope>
                </method>
                <method name="writeChars" type="void" line="1716">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <declaration name="endoff" type="int" line="1717"/>
                    <scope line="1718">
                        <declaration name="csize" type="int" line="1719"/>
                    </scope>
                </method>
                <method name="writeUTF" type="void" line="1725">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <method name="writeBooleans" type="void" line="1728">
                    <params>
                        <param name="v" type="boolean[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="endoff" type="int" line="1729"/>
                    <scope line="1730">
                        <scope line="1731"/>
                        <declaration name="stop" type="int" line="1734"/>
                        <scope line="1735"/>
                    </scope>
                </method>
                <method name="writeChars" type="void" line="1740">
                    <params>
                        <param name="v" type="char[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="limit" type="int" line="1741"/>
                    <declaration name="endoff" type="int" line="1742"/>
                    <scope line="1743">
                        <scope line="1744">
                            <declaration name="avail" type="int" line="1745"/>
                            <declaration name="stop" type="int" line="1746"/>
                            <scope line="1747"/>
                        </scope>
                        <scope line="1752"/>
                    </scope>
                </method>
                <method name="writeShorts" type="void" line="1757">
                    <params>
                        <param name="v" type="short[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="limit" type="int" line="1758"/>
                    <declaration name="endoff" type="int" line="1759"/>
                    <scope line="1760">
                        <scope line="1761">
                            <declaration name="avail" type="int" line="1762"/>
                            <declaration name="stop" type="int" line="1763"/>
                            <scope line="1764"/>
                        </scope>
                        <scope line="1769"/>
                    </scope>
                </method>
                <method name="writeInts" type="void" line="1774">
                    <params>
                        <param name="v" type="int[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="limit" type="int" line="1775"/>
                    <declaration name="endoff" type="int" line="1776"/>
                    <scope line="1777">
                        <scope line="1778">
                            <declaration name="avail" type="int" line="1779"/>
                            <declaration name="stop" type="int" line="1780"/>
                            <scope line="1781"/>
                        </scope>
                        <scope line="1786"/>
                    </scope>
                </method>
                <method name="writeFloats" type="void" line="1791">
                    <params>
                        <param name="v" type="float[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="limit" type="int" line="1792"/>
                    <declaration name="endoff" type="int" line="1793"/>
                    <scope line="1794">
                        <scope line="1795">
                            <declaration name="avail" type="int" line="1796"/>
                            <declaration name="chunklen" type="int" line="1797"/>
                        </scope>
                        <scope line="1802"/>
                    </scope>
                </method>
                <method name="writeLongs" type="void" line="1807">
                    <params>
                        <param name="v" type="long[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="limit" type="int" line="1808"/>
                    <declaration name="endoff" type="int" line="1809"/>
                    <scope line="1810">
                        <scope line="1811">
                            <declaration name="avail" type="int" line="1812"/>
                            <declaration name="stop" type="int" line="1813"/>
                            <scope line="1814"/>
                        </scope>
                        <scope line="1819"/>
                    </scope>
                </method>
                <method name="writeDoubles" type="void" line="1824">
                    <params>
                        <param name="v" type="double[]"/>
                        <param name="off" type="int"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="limit" type="int" line="1825"/>
                    <declaration name="endoff" type="int" line="1826"/>
                    <scope line="1827">
                        <scope line="1828">
                            <declaration name="avail" type="int" line="1829"/>
                            <declaration name="chunklen" type="int" line="1830"/>
                        </scope>
                        <scope line="1835"/>
                    </scope>
                </method>
                <javadoc line="1840">
                    Returns the length in bytes of the UTF encoding of the given string.                    
                </javadoc>
                <method name="getUTFLength" type="long" line="1843">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <declaration name="len" type="int" line="1844"/>
                    <declaration name="utflen" type="long" line="1845"/>
                    <scope line="1846">
                        <declaration name="csize" type="int" line="1847"/>
                        <scope line="1849">
                            <declaration name="c" type="char" line="1850"/>
                            <scope line="1851"/>
                            <scope line="1854"/>
                            <scope line="1857"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="1865">
                    Writes the given string in UTF format.  This method is used in
                      situations where the UTF encoding length of the string is already
                      known; specifying it explicitly avoids a prescan of the string to
                      determine its UTF length.                    
                </javadoc>
                <method name="writeUTF" type="void" line="1871">
                    <params>
                        <param name="s" type="String"/>
                        <param name="utflen" type="long"/>
                    </params>
                    <scope line="1872"/>
                    <scope line="1876"/>
                    <scope line="1879"/>
                </method>
                <javadoc line="1883">
                    Writes given string in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
                      identical to standard UTF, except that it uses an 8 byte header
                      (instead of the standard 2 bytes) to convey the UTF encoding length.                    
                </javadoc>
                <method name="writeLongUTF" type="void" line="1888">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <javadoc line="1891">
                    Writes given string in &quot;long&quot; UTF format, where the UTF encoding
                      length of the string is already known.                    
                </javadoc>
                <method name="writeLongUTF" type="void" line="1895">
                    <params>
                        <param name="s" type="String"/>
                        <param name="utflen" type="long"/>
                    </params>
                    <scope line="1897"/>
                    <scope line="1900"/>
                </method>
                <javadoc line="1904">
                    Writes the &quot;body&quot; (i.e., the UTF representation minus the 2-byte or
                      8-byte length header) of the UTF encoding for the given string.                    
                </javadoc>
                <method name="writeUTFBody" type="void" line="1908">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <declaration name="limit" type="int" line="1909"/>
                    <declaration name="len" type="int" line="1910"/>
                    <scope line="1911">
                        <declaration name="csize" type="int" line="1912"/>
                        <scope line="1914">
                            <declaration name="c" type="char" line="1915"/>
                            <scope line="1916">
                                <scope line="1917"/>
                                <scope line="1920"/>
                                <scope line="1926"/>
                            </scope>
                            <scope line="1932">
                                <scope line="1933"/>
                                <scope line="1936"/>
                                <scope line="1941"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
            </class>
            <class name="HandleTable" line="1951">
                <javadoc line="1951">
                    Lightweight identity hash table which maps objects to integer handles,
                      assigned in ascending order.                    
                </javadoc>
                <declaration name="size" type="int" line="1956"/>
                <declaration name="threshold" type="int" line="1957"/>
                <declaration name="loadFactor" type="float" line="1958"/>
                <declaration name="spine" type="int[]" line="1959"/>
                <declaration name="next" type="int[]" line="1960"/>
                <declaration name="objs" type="Object[]" line="1961"/>
                <javadoc line="1962">
                    Creates new HandleTable with given capacity and load factor.                    
                </javadoc>
                <method name="HandleTable" type="constructor" line="1965">
                    <params>
                        <param name="initialCapacity" type="int"/>
                        <param name="loadFactor" type="float"/>
                    </params>
                </method>
                <javadoc line="1973">
                    Assigns next available handle to given object, and returns handle
                      value.  Handles are assigned in ascending order starting at 0.                    
                </javadoc>
                <method name="assign" type="int" line="1977">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="1978"/>
                    <scope line="1981"/>
                </method>
                <javadoc line="1987">
                    Looks up and returns handle associated with given object, or -1 if
                      no mapping found.                    
                </javadoc>
                <method name="lookup" type="int" line="1991">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="1992"/>
                    <declaration name="index" type="int" line="1995"/>
                    <scope line="1996">
                        <scope line="1997"/>
                    </scope>
                </method>
                <javadoc line="2003">
                    Resets table to its initial (empty) state.                    
                </javadoc>
                <method name="clear" type="void" line="2006"/>
                <javadoc line="2011">
                    Returns the number of mappings currently in table.                    
                </javadoc>
                <method name="size" type="int" line="2014"/>
                <javadoc line="2017">
                    Inserts mapping object -&gt; handle mapping into table.  Assumes table
                      is large enough to accommodate new mapping.                    
                </javadoc>
                <method name="insert" type="void" line="2021">
                    <params>
                        <param name="obj" type="Object"/>
                        <param name="handle" type="int"/>
                    </params>
                    <declaration name="index" type="int" line="2022"/>
                </method>
                <javadoc line="2027">
                    Expands the hash &quot;spine&quot; -- equivalent to increasing the number of
                      buckets in a conventional hash table.                    
                </javadoc>
                <method name="growSpine" type="void" line="2031">
                    <scope line="2035"/>
                </method>
                <javadoc line="2039">
                    Increases hash table capacity by lengthening entry arrays.                    
                </javadoc>
                <method name="growEntries" type="void" line="2042">
                    <declaration name="newLength" type="int" line="2043"/>
                    <declaration name="newNext" type="int[]" line="2044"/>
                    <declaration name="newObjs" type="Object[]" line="2047"/>
                </method>
                <javadoc line="2051">
                    Returns hash value for given object.                    
                </javadoc>
                <method name="hash" type="int" line="2054">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                </method>
            </class>
            <class name="ReplaceTable" line="2058">
                <javadoc line="2058">
                    Lightweight identity hash table which maps objects to replacement
                      objects.                    
                </javadoc>
                <declaration name="htab" type="HandleTable" line="2063"/>
                <declaration name="reps" type="Object[]" line="2064"/>
                <javadoc line="2065">
                    Creates new ReplaceTable with given capacity and load factor.                    
                </javadoc>
                <method name="ReplaceTable" type="constructor" line="2068">
                    <params>
                        <param name="initialCapacity" type="int"/>
                        <param name="loadFactor" type="float"/>
                    </params>
                </method>
                <javadoc line="2072">
                    Enters mapping from object to replacement object.                    
                </javadoc>
                <method name="assign" type="void" line="2075">
                    <params>
                        <param name="obj" type="Object"/>
                        <param name="rep" type="Object"/>
                    </params>
                    <declaration name="index" type="int" line="2076"/>
                    <scope line="2077"/>
                </method>
                <javadoc line="2082">
                    Looks up and returns replacement for given object.  If no
                      replacement is found, returns the lookup object itself.                    
                </javadoc>
                <method name="lookup" type="Object" line="2086">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <declaration name="index" type="int" line="2087"/>
                </method>
                <javadoc line="2090">
                    Resets table to its initial (empty) state.                    
                </javadoc>
                <method name="clear" type="void" line="2093"/>
                <javadoc line="2097">
                    Returns the number of mappings currently in table.                    
                </javadoc>
                <method name="size" type="int" line="2100"/>
                <javadoc line="2103">
                    Increases table capacity.                    
                </javadoc>
                <method name="grow" type="void" line="2106">
                    <declaration name="newReps" type="Object[]" line="2107"/>
                </method>
            </class>
            <class name="DebugTraceInfoStack" line="2112">
                <javadoc line="2112">
                    Stack to keep debug information about the state of the
                      serialization process, for embedding in exception messages.                    
                </javadoc>
                <declaration name="stack" type="List&lt;String&gt;" line="2117"/>
                <method name="DebugTraceInfoStack" type="constructor" line="2118"/>
                <javadoc line="2121">
                    Removes all of the elements from enclosed list.                    
                </javadoc>
                <method name="clear" type="void" line="2124"/>
                <javadoc line="2127">
                    Removes the object at the top of enclosed list.                    
                </javadoc>
                <method name="pop" type="void" line="2130"/>
                <javadoc line="2133">
                    Pushes a String onto the top of enclosed list.                    
                </javadoc>
                <method name="push" type="void" line="2136">
                    <params>
                        <param name="entry" type="String"/>
                    </params>
                </method>
                <javadoc line="2139">
                    Returns a string representation of this object                    
                </javadoc>
                <method name="toString" type="String" line="2142">
                    <declaration name="buffer" type="StringBuilder" line="2143"/>
                    <scope line="2144">
                        <scope line="2145"/>
                    </scope>
                </method>
            </class>
        </class>
    </source>