<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.io">
        <import package="java.lang.ref.Reference"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Member"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.lang.reflect.Modifier"/>
        <import package="java.lang.reflect.Proxy"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.MessageDigest"/>
        <import package="java.security.NoSuchAlgorithmException"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collections"/>
        <import package="java.util.Comparator"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Set"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.concurrent.ConcurrentMap"/>
        <import package="sun.misc.Unsafe"/>
        <import package="sun.reflect.ReflectionFactory"/>
        <class name="ObjectStreamClass" line="54">
            <implements interface="Serializable"/>
            <javadoc line="54">
                Serialization&apos;s descriptor for classes.  It contains the name and
                  serialVersionUID of the class.  The ObjectStreamClass for a specific class
                  loaded in this Java VM can be found/created using the lookup method.
                  &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
                  &lt;a href=&quot;../../../platform/serialization/spec/class.html#4100&quot;&gt;Object
                  Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.                
                <author>
                    Mike Warres                    
                </author>
                <author>
                    Roger Riggs                    
                </author>
                <see>
                    ObjectStreamField                    
                </see>
                <see>
                    <a href="../../../platform/serialization/spec/class.html">Object Serialization Specification, Section 4, Class Descriptors</a>                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <declaration name="NO_FIELDS" type="ObjectStreamField[]" line="71"/>
            <javadoc line="71">
                serialPersistentFields value indicating no serializable fields                
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="75"/>
            <declaration name="serialPersistentFields" type="ObjectStreamField[]" line="76"/>
            <declaration name="reflFactory" type="ReflectionFactory" line="79"/>
            <javadoc line="79">
                reflection factory for obtaining serialization constructors                
            </javadoc>
            <class name="Caches" line="84">
                <comment line="1824">
                    REMIND: dynamically generate these?                    
                </comment>
                <declaration name="localDescs" type="ConcurrentMap&lt;WeakClassKey,Reference&lt;?&gt;&gt;" line="85"/>
                <javadoc line="85">
                    cache mapping local classes -&gt; descriptors                    
                </javadoc>
                <declaration name="reflectors" type="ConcurrentMap&lt;FieldReflectorKey,Reference&lt;?&gt;&gt;" line="89"/>
                <javadoc line="89">
                    cache mapping field group/local desc pairs -&gt; field reflectors                    
                </javadoc>
                <declaration name="localDescsQueue" type="ReferenceQueue&lt;Class&lt;?&gt;&gt;" line="93"/>
                <javadoc line="93">
                    queue for WeakReferences to local classes                    
                </javadoc>
                <declaration name="reflectorsQueue" type="ReferenceQueue&lt;Class&lt;?&gt;&gt;" line="96"/>
                <javadoc line="96">
                    queue for WeakReferences to field reflectors keys                    
                </javadoc>
            </class>
            <declaration name="cl" type="Class&lt;?&gt;" line="101"/>
            <javadoc line="101">
                class associated with this descriptor (if any)                
            </javadoc>
            <declaration name="name" type="String" line="103"/>
            <javadoc line="103">
                name of class represented by this descriptor                
            </javadoc>
            <declaration name="suid" type="Long" line="105"/>
            <javadoc line="105">
                serialVersionUID of represented class (null if not computed yet)                
            </javadoc>
            <declaration name="isProxy" type="boolean" line="108"/>
            <javadoc line="108">
                true if represents dynamic proxy class                
            </javadoc>
            <declaration name="isEnum" type="boolean" line="110"/>
            <javadoc line="110">
                true if represents enum type                
            </javadoc>
            <declaration name="serializable" type="boolean" line="112"/>
            <javadoc line="112">
                true if represented class implements Serializable                
            </javadoc>
            <declaration name="externalizable" type="boolean" line="114"/>
            <javadoc line="114">
                true if represented class implements Externalizable                
            </javadoc>
            <declaration name="hasWriteObjectData" type="boolean" line="116"/>
            <javadoc line="116">
                true if desc has data written by class-defined writeObject method                
            </javadoc>
            <declaration name="hasBlockExternalData" type="boolean" line="118"/>
            <javadoc line="118">
                true if desc has externalizable data written in block data format; this
                  must be true by default to accommodate ObjectInputStream subclasses which
                  override readClassDescriptor() to return class descriptors obtained from
                  ObjectStreamClass.lookup() (see 4461737)                
            </javadoc>
            <declaration name="resolveEx" type="ClassNotFoundException" line="126"/>
            <javadoc line="126">
                exception (if any) thrown while attempting to resolve class                
            </javadoc>
            <declaration name="deserializeEx" type="InvalidClassException" line="128"/>
            <javadoc line="128">
                exception (if any) to throw if non-enum deserialization attempted                
            </javadoc>
            <declaration name="serializeEx" type="InvalidClassException" line="130"/>
            <javadoc line="130">
                exception (if any) to throw if non-enum serialization attempted                
            </javadoc>
            <declaration name="defaultSerializeEx" type="InvalidClassException" line="132"/>
            <javadoc line="132">
                exception (if any) to throw if default serialization attempted                
            </javadoc>
            <declaration name="fields" type="ObjectStreamField[]" line="135"/>
            <javadoc line="135">
                serializable fields                
            </javadoc>
            <declaration name="primDataSize" type="int" line="137"/>
            <javadoc line="137">
                aggregate marshalled size of primitive fields                
            </javadoc>
            <declaration name="numObjFields" type="int" line="139"/>
            <javadoc line="139">
                number of non-primitive fields                
            </javadoc>
            <declaration name="fieldRefl" type="FieldReflector" line="141"/>
            <javadoc line="141">
                reflector for setting/getting serializable field values                
            </javadoc>
            <declaration name="dataLayout" type="ClassDataSlot[]" line="143"/>
            <javadoc line="143">
                data layout of serialized objects described by this class desc                
            </javadoc>
            <declaration name="cons" type="Constructor" line="146"/>
            <javadoc line="146">
                serialization-appropriate constructor, or null if none                
            </javadoc>
            <declaration name="writeObjectMethod" type="Method" line="148"/>
            <javadoc line="148">
                class-defined writeObject method, or null if none                
            </javadoc>
            <declaration name="readObjectMethod" type="Method" line="150"/>
            <javadoc line="150">
                class-defined readObject method, or null if none                
            </javadoc>
            <declaration name="readObjectNoDataMethod" type="Method" line="152"/>
            <javadoc line="152">
                class-defined readObjectNoData method, or null if none                
            </javadoc>
            <declaration name="writeReplaceMethod" type="Method" line="154"/>
            <javadoc line="154">
                class-defined writeReplace method, or null if none                
            </javadoc>
            <declaration name="readResolveMethod" type="Method" line="156"/>
            <javadoc line="156">
                class-defined readResolve method, or null if none                
            </javadoc>
            <declaration name="localDesc" type="ObjectStreamClass" line="159"/>
            <javadoc line="159">
                local class descriptor for represented class (may point to self)                
            </javadoc>
            <declaration name="superDesc" type="ObjectStreamClass" line="161"/>
            <javadoc line="161">
                superclass descriptor appearing in stream                
            </javadoc>
            <method name="initNative" type="void" line="164"/>
            <javadoc line="164">
                Initializes native code.                
            </javadoc>
            <scope line="168"/>
            <javadoc line="172">
                Find the descriptor for a class that can be serialized.  Creates an
                  ObjectStreamClass instance if one does not exist yet for class. Null is
                  returned if the specified class does not implement java.io.Serializable
                  or java.io.Externalizable.                
                <param>
                    cl class for which to get the descriptor                    
                </param>
                <return>
                    the class descriptor for the specified class                    
                </return>
            </javadoc>
            <method name="lookup" type="ObjectStreamClass" line="181">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="185">
                Returns the descriptor for any class, regardless of whether it
                  implements {@link Serializable}.                
                <param>
                    cl class for which to get the descriptor                    
                </param>
                <return>
                    the class descriptor for the specified class                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="lookupAny" type="ObjectStreamClass" line="193">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="197">
                Returns the name of the class described by this descriptor.
                  This method returns the name of the class in the format that
                  is used by the {@link Class#getName} method.                
                <return>
                    a string representing the name of the class                    
                </return>
            </javadoc>
            <method name="getName" type="String" line="204"/>
            <javadoc line="208">
                Return the serialVersionUID for this class.  The serialVersionUID
                  defines a set of classes all with the same name that have evolved from a
                  common root class and agree to be serialized and deserialized using a
                  common format.  NonSerializable classes have a serialVersionUID of 0L.                
                <return>
                    the SUID of the class described by this descriptor                    
                </return>
            </javadoc>
            <method name="getSerialVersionUID" type="long" line="216">
                <comment line="217">
                    REMIND: synchronize instead of relying on volatile?                    
                </comment>
                <scope line="218">
                    <anonymous_class line="220">
                        <method name="run" type="Long" line="221"/>
                    </anonymous_class>
                </scope>
            </method>
            <javadoc line="230">
                Return the class in the local VM that this version is mapped to.  Null
                  is returned if there is no corresponding local class.                
                <return>
                    the <code>Class</code> instance that this descriptor represents                    
                </return>
            </javadoc>
            <method name="forClass" type="Class<?>" line="236"/>
            <javadoc line="240">
                Return an array of the fields of this serializable class.                
                <return>
                    an array containing an element for each persistent field of
                      this class. Returns an array of length zero if there are no
                      fields.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getFields" type="ObjectStreamField[]" line="248"/>
            <javadoc line="252">
                Get the field of this class by name.                
                <param>
                    name the name of the data field to look for                    
                </param>
                <return>
                    The ObjectStreamField object of the named field or null if
                      there is no such named field.                    
                </return>
            </javadoc>
            <method name="getField" type="ObjectStreamField" line="259">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <javadoc line="263">
                Return a string describing this ObjectStreamClass.                
            </javadoc>
            <method name="toString" type="String" line="266"/>
            <javadoc line="271">
                Looks up and returns class descriptor for given class, or null if class
                  is non-serializable and &quot;all&quot; is set to false.                
                <param>
                    cl class to look up                    
                </param>
                <param>
                    all if true, return descriptors for all classes; if false, only
                      return descriptors for serializable classes                    
                </param>
            </javadoc>
            <method name="lookup" type="ObjectStreamClass" line="279">
                <params>
                    <param name="cl" type="Class<?>"/>
                    <param name="all" type="boolean"/>
                </params>
                <comment line="308">
                    check common case first                    
                </comment>
                <comment line="314">
                    Handle nested call situation described by 4803747: waiting
                     for future value to be set by a lookup() call further up the
                     stack will result in deadlock, so calculate and set the
                     future value here instead.                    
                </comment>
                <comment line="334">
                    nested lookup call already set future                    
                </comment>
                <scope line="280"/>
                <declaration name="key" type="WeakClassKey" line="284"/>
                <declaration name="ref" type="Reference&lt;?&gt;" line="285"/>
                <declaration name="entry" type="Object" line="286"/>
                <scope line="287"/>
                <declaration name="future" type="EntryFuture" line="290"/>
                <scope line="291">
                    <declaration name="newEntry" type="EntryFuture" line="292"/>
                    <declaration name="newRef" type="Reference&lt;?&gt;" line="293"/>
                    <scope line="294">
                        <scope line="295"/>
                        <scope line="299"/>
                    </scope>
                    <scope line="303"/>
                </scope>
                <scope line="308"/>
                <scope line="311">
                    <scope line="313"/>
                    <scope line="321"/>
                </scope>
                <scope line="325">
                    <scope line="326"/>
                    <scope line="328"/>
                    <scope line="331"/>
                    <scope line="333"/>
                </scope>
                <scope line="339"/>
                <scope line="341"/>
                <scope line="343"/>
                <scope line="345"/>
            </method>
            <class name="EntryFuture" line="350">
                <comment line="1824">
                    REMIND: dynamically generate these?                    
                </comment>
                <javadoc line="350">
                    Placeholder used in class descriptor and field reflector lookup tables
                      for an entry in the process of being initialized.  (Internal) callers
                      which receive an EntryFuture belonging to another thread as the result
                      of a lookup should call the get() method of the EntryFuture; this will
                      return the actual entry once it is ready for use and has been set().  To
                      conserve objects, EntryFutures synchronize on themselves.                    
                </javadoc>
                <declaration name="unset" type="Object" line="360"/>
                <declaration name="owner" type="Thread" line="361"/>
                <declaration name="entry" type="Object" line="362"/>
                <javadoc line="364">
                    Attempts to set the value contained by this EntryFuture.  If the
                      EntryFuture&apos;s value has not been set already, then the value is
                      saved, any callers blocked in the get() method are notified, and
                      true is returned.  If the value has already been set, then no saving
                      or notification occurs, and false is returned.                    
                </javadoc>
                <method name="set" type="boolean" line="371">
                    <params>
                        <param name="entry" type="Object"/>
                    </params>
                    <scope line="372"/>
                </method>
                <javadoc line="380">
                    Returns the value contained by this EntryFuture, blocking if
                      necessary until a value is set.                    
                </javadoc>
                <method name="get" type="Object" line="384">
                    <declaration name="interrupted" type="boolean" line="385"/>
                    <scope line="386">
                        <scope line="387"/>
                        <scope line="389"/>
                    </scope>
                    <scope line="393">
                        <anonymous_class line="395">
                            <method name="run" type="Void" line="396"/>
                        </anonymous_class>
                    </scope>
                </method>
                <javadoc line="406">
                    Returns the thread that created this EntryFuture.                    
                </javadoc>
                <method name="getOwner" type="Thread" line="409"/>
            </class>
            <javadoc line="414">
                Creates local class descriptor representing given class.                
            </javadoc>
            <method name="ObjectStreamClass" type="constructor" line="417">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <comment line="480">
                    field mismatches impossible when matching local fields vs. self                    
                </comment>
                <declaration name="superCl" type="Class&lt;?&gt;" line="425"/>
                <scope line="429">
                    <anonymous_class line="430">
                        <method name="run" type="Void" line="431">
                            <scope line="432"/>
                            <scope line="437"/>
                            <scope line="443"/>
                            <scope line="446"/>
                            <scope line="451"/>
                            <scope line="453"/>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="472"/>
                <scope line="477"/>
                <scope line="479"/>
                <scope line="484">
                    <scope line="485"/>
                    <scope line="487"/>
                </scope>
                <scope line="492">
                    <scope line="493"/>
                </scope>
            </method>
            <javadoc line="500">
                Creates blank class descriptor which should be initialized via a
                  subsequent call to initProxy(), initNonProxy() or readNonProxy().                
            </javadoc>
            <method name="ObjectStreamClass" type="constructor" line="504"/>
            <javadoc line="507">
                Initializes class descriptor representing a proxy class.                
            </javadoc>
            <method name="initProxy" type="void" line="514">
                <params>
                    <param name="cl" type="Class<?>"/>
                    <param name="resolveEx" type="ClassNotFoundException"/>
                    <param name="superDesc" type="ObjectStreamClass"/>
                </params>
                <scope line="523">
                    <scope line="525"/>
                </scope>
            </method>
            <javadoc line="539">
                Initializes class descriptor representing a non-proxy class.                
            </javadoc>
            <method name="initNonProxy" type="void" line="547">
                <params>
                    <param name="model" type="ObjectStreamClass"/>
                    <param name="cl" type="Class<?>"/>
                    <param name="resolveEx" type="ClassNotFoundException"/>
                    <param name="superDesc" type="ObjectStreamClass"/>
                </params>
                <comment line="620">
                    reassign to matched fields so as to reflect local unshared settings                    
                </comment>
                <scope line="563">
                    <scope line="565"/>
                    <scope line="569"/>
                    <scope line="578"/>
                    <scope line="586"/>
                    <scope line="592">
                        <scope line="595"/>
                        <scope line="603"/>
                    </scope>
                    <scope line="615"/>
                </scope>
            </method>
            <javadoc line="624">
                Reads non-proxy class descriptor information from given input stream.
                  The resulting class descriptor is not fully functional; it can only be
                  used as input to the ObjectInputStream.resolveClass() and
                  ObjectStreamClass.initNonProxy() methods.                
            </javadoc>
            <method name="readNonProxy" type="void" line="632">
                <params>
                    <param name="in" type="ObjectInputStream"/>
                </params>
                <declaration name="flags" type="byte" line="637"/>
                <declaration name="sflag" type="boolean" line="644"/>
                <scope line="646"/>
                <scope line="652"/>
                <declaration name="numFields" type="int" line="657"/>
                <scope line="658"/>
                <scope line="664">
                    <declaration name="tcode" type="char" line="665"/>
                    <declaration name="fname" type="String" line="666"/>
                    <declaration name="signature" type="String" line="667"/>
                    <scope line="669"/>
                    <scope line="671"/>
                </scope>
            </method>
            <javadoc line="679">
                Writes non-proxy class descriptor information to given output stream.                
            </javadoc>
            <method name="writeNonProxy" type="void" line="682">
                <params>
                    <param name="out" type="ObjectOutputStream"/>
                </params>
                <declaration name="flags" type="byte" line="686"/>
                <scope line="687">
                    <declaration name="protocol" type="int" line="689"/>
                    <scope line="690"/>
                </scope>
                <scope line="693"/>
                <scope line="696"/>
                <scope line="699"/>
                <scope line="705">
                    <declaration name="f" type="ObjectStreamField" line="706"/>
                    <scope line="709"/>
                </scope>
            </method>
            <javadoc line="715">
                Returns ClassNotFoundException (if any) thrown while attempting to
                  resolve local class corresponding to this class descriptor.                
            </javadoc>
            <method name="getResolveException" type="ClassNotFoundException" line="719"/>
            <javadoc line="723">
                Throws an InvalidClassException if object instances referencing this
                  class descriptor should not be allowed to deserialize.  This method does
                  not apply to deserialization of enum constants.                
            </javadoc>
            <method name="checkDeserialize" type="void" line="728">
                <scope line="729">
                    <declaration name="ice" type="InvalidClassException" line="730"/>
                </scope>
            </method>
            <javadoc line="738">
                Throws an InvalidClassException if objects whose class is represented by
                  this descriptor should not be allowed to serialize.  This method does
                  not apply to serialization of enum constants.                
            </javadoc>
            <method name="checkSerialize" type="void" line="743">
                <scope line="744">
                    <declaration name="ice" type="InvalidClassException" line="745"/>
                </scope>
            </method>
            <javadoc line="753">
                Throws an InvalidClassException if objects whose class is represented by
                  this descriptor should not be permitted to use default serialization
                  (e.g., if the class declares serializable fields that do not correspond
                  to actual fields, and hence must use the GetField API).  This method
                  does not apply to deserialization of enum constants.                
            </javadoc>
            <method name="checkDefaultSerialize" type="void" line="760">
                <scope line="761">
                    <declaration name="ice" type="InvalidClassException" line="762"/>
                </scope>
            </method>
            <javadoc line="770">
                Returns superclass descriptor.  Note that on the receiving side, the
                  superclass descriptor may be bound to a class that is not a superclass
                  of the subclass descriptor&apos;s bound class.                
            </javadoc>
            <method name="getSuperDesc" type="ObjectStreamClass" line="775"/>
            <javadoc line="779">
                Returns the &quot;local&quot; class descriptor for the class associated with this
                  class descriptor (i.e., the result of
                  ObjectStreamClass.lookup(this.forClass())) or null if there is no class
                  associated with this descriptor.                
            </javadoc>
            <method name="getLocalDesc" type="ObjectStreamClass" line="785"/>
            <javadoc line="789">
                Returns arrays of ObjectStreamFields representing the serializable
                  fields of the represented class.  If copy is true, a clone of this class
                  descriptor&apos;s field array is returned, otherwise the array itself is
                  returned.                
            </javadoc>
            <method name="getFields" type="ObjectStreamField[]" line="795">
                <params>
                    <param name="copy" type="boolean"/>
                </params>
            </method>
            <javadoc line="799">
                Looks up a serializable field of the represented class by name and type.
                  A specified type of null matches all types, Object.class matches all
                  non-primitive types, and any other non-null type matches assignable
                  types only.  Returns matching field, or null if no match found.                
            </javadoc>
            <method name="getField" type="ObjectStreamField" line="805">
                <params>
                    <param name="name" type="String"/>
                    <param name="type" type="Class<?>"/>
                </params>
                <scope line="806">
                    <declaration name="f" type="ObjectStreamField" line="807"/>
                    <scope line="808">
                        <scope line="811"/>
                        <declaration name="ftype" type="Class&lt;?&gt;" line="814"/>
                        <scope line="815"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="823">
                Returns true if class descriptor represents a dynamic proxy class, false
                  otherwise.                
            </javadoc>
            <method name="isProxy" type="boolean" line="827"/>
            <javadoc line="831">
                Returns true if class descriptor represents an enum type, false
                  otherwise.                
            </javadoc>
            <method name="isEnum" type="boolean" line="835"/>
            <javadoc line="839">
                Returns true if represented class implements Externalizable, false
                  otherwise.                
            </javadoc>
            <method name="isExternalizable" type="boolean" line="843"/>
            <javadoc line="847">
                Returns true if represented class implements Serializable, false
                  otherwise.                
            </javadoc>
            <method name="isSerializable" type="boolean" line="851"/>
            <javadoc line="855">
                Returns true if class descriptor represents externalizable class that
                  has written its data in 1.2 (block data) format, false otherwise.                
            </javadoc>
            <method name="hasBlockExternalData" type="boolean" line="859"/>
            <javadoc line="863">
                Returns true if class descriptor represents serializable (but not
                  externalizable) class which has written its data via a custom
                  writeObject() method, false otherwise.                
            </javadoc>
            <method name="hasWriteObjectData" type="boolean" line="868"/>
            <javadoc line="872">
                Returns true if represented class is serializable/externalizable and can
                  be instantiated by the serialization runtime--i.e., if it is
                  externalizable and defines a public no-arg constructor, or if it is
                  non-externalizable and its first non-serializable superclass defines an
                  accessible no-arg constructor.  Otherwise, returns false.                
            </javadoc>
            <method name="isInstantiable" type="boolean" line="879"/>
            <javadoc line="883">
                Returns true if represented class is serializable (but not
                  externalizable) and defines a conformant writeObject method.  Otherwise,
                  returns false.                
            </javadoc>
            <method name="hasWriteObjectMethod" type="boolean" line="888"/>
            <javadoc line="892">
                Returns true if represented class is serializable (but not
                  externalizable) and defines a conformant readObject method.  Otherwise,
                  returns false.                
            </javadoc>
            <method name="hasReadObjectMethod" type="boolean" line="897"/>
            <javadoc line="901">
                Returns true if represented class is serializable (but not
                  externalizable) and defines a conformant readObjectNoData method.
                  Otherwise, returns false.                
            </javadoc>
            <method name="hasReadObjectNoDataMethod" type="boolean" line="906"/>
            <javadoc line="910">
                Returns true if represented class is serializable or externalizable and
                  defines a conformant writeReplace method.  Otherwise, returns false.                
            </javadoc>
            <method name="hasWriteReplaceMethod" type="boolean" line="914"/>
            <javadoc line="918">
                Returns true if represented class is serializable or externalizable and
                  defines a conformant readResolve method.  Otherwise, returns false.                
            </javadoc>
            <method name="hasReadResolveMethod" type="boolean" line="922"/>
            <javadoc line="926">
                Creates a new instance of the represented class.  If the class is
                  externalizable, invokes its public no-arg constructor; otherwise, if the
                  class is serializable, invokes the no-arg constructor of the first
                  non-serializable superclass.  Throws UnsupportedOperationException if
                  this class descriptor is not associated with a class, if the associated
                  class is non-serializable or if the appropriate no-arg constructor is
                  inaccessible/unavailable.                
            </javadoc>
            <method name="newInstance" type="Object" line="938">
                <comment line="943">
                    should not occur, as access checks have been suppressed                    
                </comment>
                <scope line="939">
                    <scope line="940"/>
                    <scope line="942"/>
                </scope>
                <scope line="946"/>
            </method>
            <javadoc line="951">
                Invokes the writeObject method of the represented serializable class.
                  Throws UnsupportedOperationException if this class descriptor is not
                  associated with a class, or if the class is externalizable,
                  non-serializable or does not define writeObject.                
            </javadoc>
            <method name="invokeWriteObject" type="void" line="959">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="out" type="ObjectOutputStream"/>
                </params>
                <comment line="971">
                    should not occur, as access checks have been suppressed                    
                </comment>
                <scope line="960">
                    <scope line="961"/>
                    <scope line="963">
                        <declaration name="th" type="Throwable" line="964"/>
                        <scope line="965"/>
                        <scope line="967"/>
                    </scope>
                    <scope line="970"/>
                </scope>
                <scope line="974"/>
            </method>
            <javadoc line="979">
                Invokes the readObject method of the represented serializable class.
                  Throws UnsupportedOperationException if this class descriptor is not
                  associated with a class, or if the class is externalizable,
                  non-serializable or does not define readObject.                
            </javadoc>
            <method name="invokeReadObject" type="void" line="988">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="in" type="ObjectInputStream"/>
                </params>
                <comment line="1002">
                    should not occur, as access checks have been suppressed                    
                </comment>
                <scope line="989">
                    <scope line="990"/>
                    <scope line="992">
                        <declaration name="th" type="Throwable" line="993"/>
                        <scope line="994"/>
                        <scope line="996"/>
                        <scope line="998"/>
                    </scope>
                    <scope line="1001"/>
                </scope>
                <scope line="1005"/>
            </method>
            <javadoc line="1010">
                Invokes the readObjectNoData method of the represented serializable
                  class.  Throws UnsupportedOperationException if this class descriptor is
                  not associated with a class, or if the class is externalizable,
                  non-serializable or does not define readObjectNoData.                
            </javadoc>
            <method name="invokeReadObjectNoData" type="void" line="1018">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="1030">
                    should not occur, as access checks have been suppressed                    
                </comment>
                <scope line="1019">
                    <scope line="1020"/>
                    <scope line="1022">
                        <declaration name="th" type="Throwable" line="1023"/>
                        <scope line="1024"/>
                        <scope line="1026"/>
                    </scope>
                    <scope line="1029"/>
                </scope>
                <scope line="1033"/>
            </method>
            <javadoc line="1038">
                Invokes the writeReplace method of the represented serializable class and
                  returns the result.  Throws UnsupportedOperationException if this class
                  descriptor is not associated with a class, or if the class is
                  non-serializable or does not define writeReplace.                
            </javadoc>
            <method name="invokeWriteReplace" type="Object" line="1046">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="1056">
                    never reached                    
                </comment>
                <comment line="1059">
                    should not occur, as access checks have been suppressed                    
                </comment>
                <scope line="1047">
                    <scope line="1048"/>
                    <scope line="1050">
                        <declaration name="th" type="Throwable" line="1051"/>
                        <scope line="1052"/>
                        <scope line="1054"/>
                    </scope>
                    <scope line="1058"/>
                </scope>
                <scope line="1062"/>
            </method>
            <javadoc line="1067">
                Invokes the readResolve method of the represented serializable class and
                  returns the result.  Throws UnsupportedOperationException if this class
                  descriptor is not associated with a class, or if the class is
                  non-serializable or does not define readResolve.                
            </javadoc>
            <method name="invokeReadResolve" type="Object" line="1075">
                <params>
                    <param name="obj" type="Object"/>
                </params>
                <comment line="1085">
                    never reached                    
                </comment>
                <comment line="1088">
                    should not occur, as access checks have been suppressed                    
                </comment>
                <scope line="1076">
                    <scope line="1077"/>
                    <scope line="1079">
                        <declaration name="th" type="Throwable" line="1080"/>
                        <scope line="1081"/>
                        <scope line="1083"/>
                    </scope>
                    <scope line="1087"/>
                </scope>
                <scope line="1091"/>
            </method>
            <class name="ClassDataSlot" line="1096">
                <comment line="1824">
                    REMIND: dynamically generate these?                    
                </comment>
                <javadoc line="1096">
                    Class representing the portion of an object&apos;s serialized form allotted
                      to data described by a given class descriptor.  If &quot;hasData&quot; is false,
                      the object&apos;s serialized form does not contain data associated with the
                      class descriptor.                    
                </javadoc>
                <declaration name="desc" type="ObjectStreamClass" line="1104"/>
                <javadoc line="1104">
                    class descriptor &quot;occupying&quot; this slot                    
                </javadoc>
                <declaration name="hasData" type="boolean" line="1106"/>
                <javadoc line="1106">
                    true if serialized form includes data for this slot&apos;s descriptor                    
                </javadoc>
                <method name="ClassDataSlot" type="constructor" line="1109">
                    <params>
                        <param name="desc" type="ObjectStreamClass"/>
                        <param name="hasData" type="boolean"/>
                    </params>
                </method>
            </class>
            <javadoc line="1115">
                Returns array of ClassDataSlot instances representing the data layout
                  (including superclass data) for serialized objects described by this
                  class descriptor.  ClassDataSlots are ordered by inheritance with those
                  containing &quot;higher&quot; superclasses appearing first.  The final
                  ClassDataSlot contains a reference to this descriptor.                
            </javadoc>
            <method name="getClassDataLayout" type="ClassDataSlot[]" line="1122">
                <comment line="1123">
                    REMIND: synchronize instead of relying on volatile?                    
                </comment>
                <scope line="1124"/>
            </method>
            <method name="getClassDataLayout0" type="ClassDataSlot[]" line="1132">
                <comment line="1136">
                    locate closest non-serializable superclass                    
                </comment>
                <comment line="1143">
                    search up inheritance hierarchy for class with matching name                    
                </comment>
                <comment line="1153">
                    add &quot;no data&quot; slot for each unmatched class below match                    
                </comment>
                <comment line="1162">
                    record descriptor/class pairing                    
                </comment>
                <comment line="1166">
                    add &quot;no data&quot; slot for any leftover unmatched classes                    
                </comment>
                <comment line="1172">
                    order slots from superclass -&gt; subclass                    
                </comment>
                <declaration name="slots" type="ArrayList&lt;ClassDataSlot&gt;" line="1133"/>
                <declaration name="start" type="Class&lt;?&gt;" line="1134"/>
                <scope line="1137"/>
                <scope line="1141">
                    <declaration name="searchName" type="String" line="1144"/>
                    <declaration name="match" type="Class&lt;?&gt;" line="1145"/>
                    <scope line="1146">
                        <scope line="1147"/>
                    </scope>
                    <scope line="1154">
                        <scope line="1155"/>
                    </scope>
                </scope>
                <scope line="1167"/>
            </method>
            <javadoc line="1177">
                Returns aggregate size (in bytes) of marshalled primitive field values
                  for represented class.                
            </javadoc>
            <method name="getPrimDataSize" type="int" line="1181"/>
            <javadoc line="1185">
                Returns number of non-primitive serializable fields of represented
                  class.                
            </javadoc>
            <method name="getNumObjFields" type="int" line="1189"/>
            <javadoc line="1193">
                Fetches the serializable primitive field values of object obj and
                  marshals them into byte array buf starting at offset 0.  It is the
                  responsibility of the caller to ensure that obj is of the proper type if
                  non-null.                
            </javadoc>
            <method name="getPrimFieldValues" type="void" line="1199">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="buf" type="byte[]"/>
                </params>
            </method>
            <javadoc line="1203">
                Sets the serializable primitive fields of object obj using values
                  unmarshalled from byte array buf starting at offset 0.  It is the
                  responsibility of the caller to ensure that obj is of the proper type if
                  non-null.                
            </javadoc>
            <method name="setPrimFieldValues" type="void" line="1209">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="buf" type="byte[]"/>
                </params>
            </method>
            <javadoc line="1213">
                Fetches the serializable object field values of object obj and stores
                  them in array vals starting at offset 0.  It is the responsibility of
                  the caller to ensure that obj is of the proper type if non-null.                
            </javadoc>
            <method name="getObjFieldValues" type="void" line="1218">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="vals" type="Object[]"/>
                </params>
            </method>
            <javadoc line="1222">
                Sets the serializable object fields of object obj using values from
                  array vals starting at offset 0.  It is the responsibility of the caller
                  to ensure that obj is of the proper type if non-null.                
            </javadoc>
            <method name="setObjFieldValues" type="void" line="1227">
                <params>
                    <param name="obj" type="Object"/>
                    <param name="vals" type="Object[]"/>
                </params>
            </method>
            <javadoc line="1231">
                Calculates and sets serializable field offsets, as well as primitive
                  data size and object field count totals.  Throws InvalidClassException
                  if fields are illegally ordered.                
            </javadoc>
            <method name="computeFieldOffsets" type="void" line="1236">
                <declaration name="firstObjIndex" type="int" line="1239"/>
                <scope line="1241">
                    <declaration name="f" type="ObjectStreamField" line="1242"/>
                    <scope line="1270"/>
                </scope>
                <scope line="1281"/>
            </method>
            <javadoc line="1286">
                If given class is the same as the class associated with this class
                  descriptor, returns reference to this class descriptor.  Otherwise,
                  returns variant of this class descriptor bound to given class.                
            </javadoc>
            <method name="getVariantFor" type="ObjectStreamClass" line="1293">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <scope line="1294"/>
                <declaration name="desc" type="ObjectStreamClass" line="1297"/>
                <scope line="1298"/>
                <scope line="1300"/>
            </method>
            <javadoc line="1306">
                Returns public no-arg constructor of given class, or null if none found.
                  Access checks are disabled on the returned constructor (if any), since
                  the defining class may still be non-public.                
            </javadoc>
            <method name="getExternalizableConstructor" type="Constructor" line="1311">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <scope line="1312">
                    <declaration name="cons" type="Constructor" line="1313"/>
                </scope>
                <scope line="1317"/>
            </method>
            <javadoc line="1322">
                Returns subclass-accessible no-arg constructor of first non-serializable
                  superclass, or null if none found.  Access checks are disabled on the
                  returned constructor (if any).                
            </javadoc>
            <method name="getSerializableConstructor" type="Constructor" line="1327">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <declaration name="initCl" type="Class&lt;?&gt;" line="1328"/>
                <scope line="1329">
                    <scope line="1330"/>
                </scope>
                <scope line="1334">
                    <declaration name="cons" type="Constructor" line="1335"/>
                    <declaration name="mods" type="int" line="1336"/>
                    <scope line="1340"/>
                </scope>
                <scope line="1346"/>
            </method>
            <javadoc line="1351">
                Returns non-static, non-abstract method with given signature provided it
                  is defined by or accessible (via inheritance) by the given class, or
                  null if no match found.  Access checks are disabled on the returned
                  method (if any).                
            </javadoc>
            <method name="getInheritableMethod" type="Method" line="1360">
                <params>
                    <param name="cl" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="argTypes" type="Class<?>[]"/>
                    <param name="returnType" type="Class<?>"/>
                </params>
                <declaration name="meth" type="Method" line="1361"/>
                <declaration name="defCl" type="Class&lt;?&gt;" line="1362"/>
                <scope line="1363">
                    <scope line="1364"/>
                    <scope line="1367"/>
                </scope>
                <scope line="1372"/>
                <declaration name="mods" type="int" line="1376"/>
                <scope line="1377"/>
                <scope line="1379"/>
                <scope line="1381"/>
                <scope line="1383"/>
            </method>
            <javadoc line="1388">
                Returns non-static private method with given signature defined by given
                  class, or null if none found.  Access checks are disabled on the
                  returned method (if any).                
            </javadoc>
            <method name="getPrivateMethod" type="Method" line="1396">
                <params>
                    <param name="cl" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="argTypes" type="Class<?>[]"/>
                    <param name="returnType" type="Class<?>"/>
                </params>
                <scope line="1397">
                    <declaration name="meth" type="Method" line="1398"/>
                    <declaration name="mods" type="int" line="1400"/>
                </scope>
                <scope line="1404"/>
            </method>
            <javadoc line="1409">
                Returns true if classes are defined in the same runtime package, false
                  otherwise.                
            </javadoc>
            <method name="packageEquals" type="boolean" line="1413">
                <params>
                    <param name="cl1" type="Class<?>"/>
                    <param name="cl2" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="1418">
                Returns package name of given class.                
            </javadoc>
            <method name="getPackageName" type="String" line="1421">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <declaration name="s" type="String" line="1422"/>
                <declaration name="i" type="int" line="1423"/>
                <scope line="1424"/>
            </method>
            <javadoc line="1431">
                Compares class names for equality, ignoring package names.  Returns true
                  if class names equal, false otherwise.                
            </javadoc>
            <method name="classNamesEqual" type="boolean" line="1435">
                <params>
                    <param name="name1" type="String"/>
                    <param name="name2" type="String"/>
                </params>
            </method>
            <javadoc line="1441">
                Returns JVM type signature for given class.                
            </javadoc>
            <method name="getClassSignature" type="String" line="1444">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <declaration name="sbuf" type="StringBuilder" line="1445"/>
                <scope line="1446"/>
                <scope line="1450">
                    <scope line="1451"/>
                    <scope line="1453"/>
                    <scope line="1455"/>
                    <scope line="1457"/>
                    <scope line="1459"/>
                    <scope line="1461"/>
                    <scope line="1463"/>
                    <scope line="1465"/>
                    <scope line="1467"/>
                    <scope line="1469"/>
                </scope>
                <scope line="1472"/>
            </method>
            <javadoc line="1478">
                Returns JVM type signature for given list of parameters and return type.                
            </javadoc>
            <method name="getMethodSignature" type="String" line="1483">
                <params>
                    <param name="paramTypes" type="Class<?>[]"/>
                    <param name="retType" type="Class<?>"/>
                </params>
                <declaration name="sbuf" type="StringBuilder" line="1484"/>
                <scope line="1486"/>
            </method>
            <javadoc line="1494">
                Convenience method for throwing an exception that is either a
                  RuntimeException, Error, or of some unexpected type (in which case it is
                  wrapped inside an IOException).                
            </javadoc>
            <method name="throwMiscException" type="void" line="1499">
                <params>
                    <param name="th" type="Throwable"/>
                </params>
                <scope line="1500"/>
                <scope line="1502"/>
                <scope line="1504">
                    <declaration name="ex" type="IOException" line="1505"/>
                </scope>
            </method>
            <javadoc line="1511">
                Returns ObjectStreamField array describing the serializable fields of
                  the given class.  Serializable fields backed by an actual field of the
                  class are represented by ObjectStreamFields with corresponding non-null
                  Field objects.  Throws InvalidClassException if the (explicitly
                  declared) serializable fields are invalid.                
            </javadoc>
            <method name="getSerialFields" type="ObjectStreamField[]" line="1520">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <declaration name="fields" type="ObjectStreamField[]" line="1521"/>
                <scope line="1526">
                    <scope line="1527"/>
                </scope>
                <scope line="1531"/>
            </method>
            <javadoc line="1537">
                Returns serializable fields of given class as defined explicitly by a
                  &quot;serialPersistentFields&quot; field, or null if no appropriate
                  &quot;serialPersistentFields&quot; field is defined.  Serializable fields backed
                  by an actual field of the class are represented by ObjectStreamFields
                  with corresponding non-null Field objects.  For compatibility with past
                  releases, a &quot;serialPersistentFields&quot; field with a null value is
                  considered equivalent to not declaring &quot;serialPersistentFields&quot;.  Throws
                  InvalidClassException if the declared serializable fields are
                  invalid--e.g., if multiple fields share the same name.                
            </javadoc>
            <method name="getDeclaredSerialFields" type="ObjectStreamField[]" line="1550">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <declaration name="serialPersistentFields" type="ObjectStreamField[]" line="1551"/>
                <scope line="1552">
                    <declaration name="f" type="Field" line="1553"/>
                    <declaration name="mask" type="int" line="1554"/>
                    <scope line="1555"/>
                </scope>
                <scope line="1559"/>
                <scope line="1561"/>
                <scope line="1563"/>
                <declaration name="boundFields" type="ObjectStreamField[]" line="1567"/>
                <declaration name="fieldNames" type="Set&lt;String&gt;" line="1569"/>
                <scope line="1571">
                    <declaration name="spf" type="ObjectStreamField" line="1572"/>
                    <declaration name="fname" type="String" line="1574"/>
                    <scope line="1575"/>
                    <scope line="1581">
                        <declaration name="f" type="Field" line="1582"/>
                        <scope line="1585"/>
                    </scope>
                    <scope line="1589"/>
                    <scope line="1591"/>
                </scope>
            </method>
            <javadoc line="1599">
                Returns array of ObjectStreamFields corresponding to all non-static
                  non-transient fields declared by given class.  Each ObjectStreamField
                  contains a Field object for the field it represents.  If no default
                  serializable fields exist, NO_FIELDS is returned.                
            </javadoc>
            <method name="getDefaultSerialFields" type="ObjectStreamField[]" line="1605">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <declaration name="clFields" type="Field[]" line="1606"/>
                <declaration name="list" type="ArrayList&lt;ObjectStreamField&gt;" line="1607"/>
                <declaration name="mask" type="int" line="1608"/>
                <scope line="1610">
                    <scope line="1611"/>
                </scope>
                <declaration name="size" type="int" line="1615"/>
            </method>
            <javadoc line="1620">
                Returns explicit serial version UID value declared by given class, or
                  null if none.                
            </javadoc>
            <method name="getDeclaredSUID" type="Long" line="1624">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <scope line="1625">
                    <declaration name="f" type="Field" line="1626"/>
                    <declaration name="mask" type="int" line="1627"/>
                    <scope line="1628"/>
                </scope>
                <scope line="1632"/>
            </method>
            <javadoc line="1637">
                Computes the default serial version UID value for the given class.                
            </javadoc>
            <method name="computeDefaultSUID" type="long" line="1640">
                <params>
                    <param name="cl" type="Class<?>"/>
                </params>
                <comment line="1656">
                    compensate for javac bug in which ABSTRACT bit was set for an
                     interface only if the interface declared methods                    
                </comment>
                <comment line="1669">
                    compensate for change in 1.2FCS in which
                     Class.getInterfaces() was modified to return Cloneable and
                     Serializable for array classes.                    
                </comment>
                <scope line="1642"/>
                <scope line="1646">
                    <declaration name="bout" type="ByteArrayOutputStream" line="1647"/>
                    <declaration name="dout" type="DataOutputStream" line="1648"/>
                    <declaration name="classMods" type="int" line="1652"/>
                    <declaration name="methods" type="Method[]" line="1660"/>
                    <scope line="1661"/>
                    <scope line="1668">
                        <declaration name="interfaces" type="Class&lt;?&gt;[]" line="1674"/>
                        <declaration name="ifaceNames" type="String[]" line="1675"/>
                        <scope line="1676"/>
                        <scope line="1680"/>
                    </scope>
                    <declaration name="fields" type="Field[]" line="1685"/>
                    <declaration name="fieldSigs" type="MemberSignature[]" line="1686"/>
                    <scope line="1687"/>
                    <anonymous_class line="1690">
                        <method name="compare" type="int" line="1691">
                            <params>
                                <param name="ms1" type="MemberSignature"/>
                                <param name="ms2" type="MemberSignature"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <scope line="1695">
                        <declaration name="sig" type="MemberSignature" line="1696"/>
                        <declaration name="mods" type="int" line="1697"/>
                        <scope line="1703"/>
                    </scope>
                    <scope line="1710"/>
                    <declaration name="cons" type="Constructor[]" line="1716"/>
                    <declaration name="consSigs" type="MemberSignature[]" line="1717"/>
                    <scope line="1718"/>
                    <anonymous_class line="1721">
                        <method name="compare" type="int" line="1722">
                            <params>
                                <param name="ms1" type="MemberSignature"/>
                                <param name="ms2" type="MemberSignature"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <scope line="1726">
                        <declaration name="sig" type="MemberSignature" line="1727"/>
                        <declaration name="mods" type="int" line="1728"/>
                        <scope line="1733"/>
                    </scope>
                    <declaration name="methSigs" type="MemberSignature[]" line="1740"/>
                    <scope line="1741"/>
                    <anonymous_class line="1744">
                        <method name="compare" type="int" line="1745">
                            <params>
                                <param name="ms1" type="MemberSignature"/>
                                <param name="ms2" type="MemberSignature"/>
                            </params>
                            <declaration name="comp" type="int" line="1746"/>
                            <scope line="1747"/>
                        </method>
                    </anonymous_class>
                    <scope line="1753">
                        <declaration name="sig" type="MemberSignature" line="1754"/>
                        <declaration name="mods" type="int" line="1755"/>
                        <scope line="1760"/>
                    </scope>
                    <declaration name="md" type="MessageDigest" line="1769"/>
                    <declaration name="hashBytes" type="byte[]" line="1770"/>
                    <declaration name="hash" type="long" line="1771"/>
                    <scope line="1772"/>
                </scope>
                <scope line="1776"/>
                <scope line="1778"/>
            </method>
            <method name="hasStaticInitializer" type="boolean" line="1783"/>
            <javadoc line="1783">
                Returns true if the given class defines a static initializer method,
                  false otherwise.                
            </javadoc>
            <class name="MemberSignature" line="1789">
                <comment line="1824">
                    REMIND: dynamically generate these?                    
                </comment>
                <javadoc line="1789">
                    Class for computing and caching field/constructor/method signatures
                      during serialVersionUID calculation.                    
                </javadoc>
                <declaration name="member" type="Member" line="1795"/>
                <declaration name="name" type="String" line="1796"/>
                <declaration name="signature" type="String" line="1797"/>
                <method name="MemberSignature" type="constructor" line="1799">
                    <params>
                        <param name="field" type="Field"/>
                    </params>
                </method>
                <method name="MemberSignature" type="constructor" line="1805">
                    <params>
                        <param name="cons" type="Constructor"/>
                    </params>
                </method>
                <method name="MemberSignature" type="constructor" line="1812">
                    <params>
                        <param name="meth" type="Method"/>
                    </params>
                </method>
            </class>
            <class name="FieldReflector" line="1820">
                <comment line="1824">
                    REMIND: dynamically generate these?                    
                </comment>
                <javadoc line="1820">
                    Class for setting and retrieving serializable field values in batch.                    
                </javadoc>
                <declaration name="unsafe" type="Unsafe" line="1826"/>
                <javadoc line="1826">
                    handle for performing unsafe operations                    
                </javadoc>
                <declaration name="fields" type="ObjectStreamField[]" line="1829"/>
                <javadoc line="1829">
                    fields to operate on                    
                </javadoc>
                <declaration name="numPrimFields" type="int" line="1831"/>
                <javadoc line="1831">
                    number of primitive fields                    
                </javadoc>
                <declaration name="readKeys" type="long[]" line="1833"/>
                <javadoc line="1833">
                    unsafe field keys for reading fields - may contain dupes                    
                </javadoc>
                <declaration name="writeKeys" type="long[]" line="1835"/>
                <javadoc line="1835">
                    unsafe fields keys for writing fields - no dupes                    
                </javadoc>
                <declaration name="offsets" type="int[]" line="1837"/>
                <javadoc line="1837">
                    field data offsets                    
                </javadoc>
                <declaration name="typeCodes" type="char[]" line="1839"/>
                <javadoc line="1839">
                    field type codes                    
                </javadoc>
                <declaration name="types" type="Class&lt;?&gt;[]" line="1841"/>
                <javadoc line="1841">
                    field types                    
                </javadoc>
                <javadoc line="1844">
                    Constructs FieldReflector capable of setting/getting values from the
                      subset of fields whose ObjectStreamFields contain non-null
                      reflective Field objects.  ObjectStreamFields with null Fields are
                      treated as filler, for which get operations return default values
                      and set operations discard given values.                    
                </javadoc>
                <method name="FieldReflector" type="constructor" line="1851">
                    <params>
                        <param name="fields" type="ObjectStreamField[]"/>
                    </params>
                    <declaration name="nfields" type="int" line="1853"/>
                    <declaration name="typeList" type="ArrayList&lt;Class&lt;?&gt;&gt;" line="1858"/>
                    <declaration name="usedKeys" type="Set&lt;Long&gt;" line="1859"/>
                    <scope line="1862">
                        <declaration name="f" type="ObjectStreamField" line="1863"/>
                        <declaration name="rf" type="Field" line="1864"/>
                        <declaration name="key" type="long" line="1865"/>
                        <scope line="1872"/>
                    </scope>
                </method>
                <javadoc line="1881">
                    Returns list of ObjectStreamFields representing fields operated on
                      by this reflector.  The shared/unshared values and Field objects
                      contained by ObjectStreamFields in the list reflect their bindings
                      to locally defined serializable fields.                    
                </javadoc>
                <method name="getFields" type="ObjectStreamField[]" line="1887"/>
                <javadoc line="1891">
                    Fetches the serializable primitive field values of object obj and
                      marshals them into byte array buf starting at offset 0.  The caller
                      is responsible for ensuring that obj is of the proper type.                    
                </javadoc>
                <method name="getPrimFieldValues" type="void" line="1896">
                    <params>
                        <param name="obj" type="Object"/>
                        <param name="buf" type="byte[]"/>
                    </params>
                    <comment line="1900">
                        assuming checkDefaultSerialize() has been called on the class
                         descriptor this FieldReflector was obtained from, no field keys
                         in array should be equal to Unsafe.INVALID_FIELD_OFFSET.                        
                    </comment>
                    <scope line="1897"/>
                    <scope line="1904">
                        <declaration name="key" type="long" line="1905"/>
                        <declaration name="off" type="int" line="1906"/>
                    </scope>
                </method>
                <javadoc line="1946">
                    Sets the serializable primitive fields of object obj using values
                      unmarshalled from byte array buf starting at offset 0.  The caller
                      is responsible for ensuring that obj is of the proper type.                    
                </javadoc>
                <method name="setPrimFieldValues" type="void" line="1951">
                    <params>
                        <param name="obj" type="Object"/>
                        <param name="buf" type="byte[]"/>
                    </params>
                    <comment line="1958">
                        discard value                        
                    </comment>
                    <scope line="1952"/>
                    <scope line="1955">
                        <declaration name="key" type="long" line="1956"/>
                        <scope line="1957"/>
                        <declaration name="off" type="int" line="1960"/>
                    </scope>
                </method>
                <javadoc line="2000">
                    Fetches the serializable object field values of object obj and
                      stores them in array vals starting at offset 0.  The caller is
                      responsible for ensuring that obj is of the proper type.                    
                </javadoc>
                <method name="getObjFieldValues" type="void" line="2005">
                    <params>
                        <param name="obj" type="Object"/>
                        <param name="vals" type="Object[]"/>
                    </params>
                    <comment line="2009">
                        assuming checkDefaultSerialize() has been called on the class
                         descriptor this FieldReflector was obtained from, no field keys
                         in array should be equal to Unsafe.INVALID_FIELD_OFFSET.                        
                    </comment>
                    <scope line="2006"/>
                    <scope line="2013"/>
                </method>
                <javadoc line="2026">
                    Sets the serializable object fields of object obj using values from
                      array vals starting at offset 0.  The caller is responsible for
                      ensuring that obj is of the proper type; however, attempts to set a
                      field with a value of the wrong type will trigger an appropriate
                      ClassCastException.                    
                </javadoc>
                <method name="setObjFieldValues" type="void" line="2033">
                    <params>
                        <param name="obj" type="Object"/>
                        <param name="vals" type="Object[]"/>
                    </params>
                    <comment line="2040">
                        discard value                        
                    </comment>
                    <scope line="2034"/>
                    <scope line="2037">
                        <declaration name="key" type="long" line="2038"/>
                        <scope line="2039"/>
                        <declaration name="val" type="Object" line="2045"/>
                        <scope line="2048">
                            <declaration name="f" type="Field" line="2049"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <javadoc line="2068">
                Matches given set of serializable fields with serializable fields
                  described by the given local class descriptor, and returns a
                  FieldReflector instance capable of setting/getting values from the
                  subset of fields that match (non-matching fields are treated as filler,
                  for which get operations return default values and set operations
                  discard given values).  Throws InvalidClassException if unresolvable
                  type conflicts exist between the two sets of fields.                
            </javadoc>
            <method name="getReflector" type="FieldReflector" line="2080">
                <params>
                    <param name="fields" type="ObjectStreamField[]"/>
                    <param name="localDesc" type="ObjectStreamClass"/>
                </params>
                <comment line="2081">
                    class irrelevant if no fields                    
                </comment>
                <comment line="2110">
                    check common case first                    
                </comment>
                <declaration name="cl" type="Class&lt;?&gt;" line="2082"/>
                <declaration name="key" type="FieldReflectorKey" line="2085"/>
                <declaration name="ref" type="Reference&lt;?&gt;" line="2087"/>
                <declaration name="entry" type="Object" line="2088"/>
                <scope line="2089"/>
                <declaration name="future" type="EntryFuture" line="2092"/>
                <scope line="2093">
                    <declaration name="newEntry" type="EntryFuture" line="2094"/>
                    <declaration name="newRef" type="Reference&lt;?&gt;" line="2095"/>
                    <scope line="2096">
                        <scope line="2097"/>
                        <scope line="2101"/>
                    </scope>
                    <scope line="2105"/>
                </scope>
                <scope line="2110"/>
                <scope line="2112"/>
                <scope line="2114">
                    <scope line="2115"/>
                    <scope line="2117"/>
                </scope>
                <scope line="2124"/>
                <scope line="2126"/>
                <scope line="2128"/>
                <scope line="2130"/>
                <scope line="2132"/>
            </method>
            <class name="FieldReflectorKey" line="2137">
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="Class<?>"/>
                    </type_params>
                </extends>
                <comment line="1824">
                    REMIND: dynamically generate these?                    
                </comment>
                <javadoc line="2137">
                    FieldReflector cache lookup key.  Keys are considered equal if they
                      refer to the same class and equivalent field formats.                    
                </javadoc>
                <declaration name="sigs" type="String" line="2143"/>
                <declaration name="hash" type="int" line="2144"/>
                <declaration name="nullClass" type="boolean" line="2145"/>
                <method name="FieldReflectorKey" type="constructor" line="2149">
                    <params>
                        <param name="cl" type="Class<?>"/>
                        <param name="fields" type="ObjectStreamField[]"/>
                        <param name="queue" type="ReferenceQueue<Class<?>>"/>
                    </params>
                    <declaration name="sbuf" type="StringBuilder" line="2152"/>
                    <scope line="2153">
                        <declaration name="f" type="ObjectStreamField" line="2154"/>
                    </scope>
                </method>
                <method name="hashCode" type="int" line="2161"/>
                <method name="equals" type="boolean" line="2165">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="2166"/>
                    <scope line="2170">
                        <declaration name="other" type="FieldReflectorKey" line="2171"/>
                        <declaration name="referent" type="Class&lt;?&gt;" line="2172"/>
                    </scope>
                    <scope line="2177"/>
                </method>
            </class>
            <javadoc line="2183">
                Matches given set of serializable fields with serializable fields
                  obtained from the given local class descriptor (which contain bindings
                  to reflective Field objects).  Returns list of ObjectStreamFields in
                  which each ObjectStreamField whose signature matches that of a local
                  field contains a Field object for that field; unmatched
                  ObjectStreamFields contain null Field objects.  Shared/unshared settings
                  of the returned ObjectStreamFields also reflect those of matched local
                  ObjectStreamFields.  Throws InvalidClassException if unresolvable type
                  conflicts exist between the two sets of fields.                
            </javadoc>
            <method name="matchFields" type="ObjectStreamField[]" line="2197">
                <params>
                    <param name="fields" type="ObjectStreamField[]"/>
                    <param name="localDesc" type="ObjectStreamClass"/>
                </params>
                <comment line="2201">
                    Even if fields == localFields, we cannot simply return localFields
                     here.  In previous implementations of serialization,
                     ObjectStreamField.getType() returned Object.class if the
                     ObjectStreamField represented a non-primitive field and belonged to
                     a non-local class descriptor.  To preserve this (questionable)
                     behavior, the ObjectStreamField instances returned by matchFields
                     cannot report non-primitive types other than Object.class; hence
                     localFields cannot be returned directly.                    
                </comment>
                <declaration name="localFields" type="ObjectStreamField[]" line="2198"/>
                <declaration name="matches" type="ObjectStreamField[]" line="2212"/>
                <scope line="2213">
                    <declaration name="f" type="ObjectStreamField" line="2214"/>
                    <scope line="2215">
                        <declaration name="lf" type="ObjectStreamField" line="2216"/>
                        <scope line="2217">
                            <scope line="2220"/>
                            <scope line="2224"/>
                            <scope line="2227"/>
                        </scope>
                    </scope>
                    <scope line="2233"/>
                </scope>
            </method>
            <javadoc line="2243">
                Removes from the specified map any keys that have been enqueued
                  on the specified reference queue.                
            </javadoc>
            <method name="processQueue" type="void" line="2250">
                <params>
                    <param name="queue" type="ReferenceQueue<Class<?>>"/>
                    <param name="map" type="ConcurrentMap<? extends WeakReference<Class<?>>,?>"/>
                </params>
                <declaration name="ref" type="Reference&lt;? extends Class&lt;?&gt;&gt;" line="2251"/>
                <scope line="2252"/>
            </method>
            <class name="WeakClassKey" line="2257">
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="Class<?>"/>
                    </type_params>
                </extends>
                <comment line="1824">
                    REMIND: dynamically generate these?                    
                </comment>
                <javadoc line="2257">
                    Weak key for Class objects.                    
                </javadoc>
                <declaration name="hash" type="int" line="2262"/>
                <javadoc line="2262">
                    saved value of the referent&apos;s identity hash code, to maintain
                      a consistent hash code after the referent has been cleared                    
                </javadoc>
                <javadoc line="2268">
                    Create a new WeakClassKey to the given object, registered
                      with a queue.                    
                </javadoc>
                <method name="WeakClassKey" type="constructor" line="2272">
                    <params>
                        <param name="cl" type="Class<?>"/>
                        <param name="refQueue" type="ReferenceQueue<Class<?>>"/>
                    </params>
                </method>
                <javadoc line="2277">
                    Returns the identity hash code of the original referent.                    
                </javadoc>
                <method name="hashCode" type="int" line="2280"/>
                <javadoc line="2284">
                    Returns true if the given object is this identical
                      WeakClassKey instance, or, if this object&apos;s referent has not
                      been cleared, if the given object is another WeakClassKey
                      instance with the identical non-null referent as this one.                    
                </javadoc>
                <method name="equals" type="boolean" line="2290">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                    <scope line="2291"/>
                    <scope line="2295">
                        <declaration name="referent" type="Object" line="2296"/>
                    </scope>
                    <scope line="2299"/>
                </method>
            </class>
        </class>
    </source>