<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <import package="java.io"/>
        <import package="java.util.concurrent.atomic.AtomicLong"/>
        <import package="sun.misc.Unsafe"/>
        <class name="Random" line="5">
            <implements interface="java.io.Serializable"/>
            <javadoc line="5">
                An instance of this class is used to generate a stream of
                  pseudorandom numbers. The class uses a 48-bit seed, which is
                  modified using a linear congruential formula. (See Donald Knuth,
                  &lt;i&gt;The Art of Computer Programming, Volume 2&lt;/i&gt;, Section 3.2.1.)
                  &lt;p&gt;
                  If two instances of {@code Random} are created with the same
                  seed, and the same sequence of method calls is made for each, they
                  will generate and return identical sequences of numbers. In order to
                  guarantee this property, particular algorithms are specified for the
                  class {@code Random}. Java implementations must use all the algorithms
                  shown here for the class {@code Random}, for the sake of absolute
                  portability of Java code. However, subclasses of class {@code Random}are permitted to use other algorithms, so long as they adhere to the
                  general contracts for all the methods.
                  &lt;p&gt;
                  The algorithms implemented by class {@code Random} use a{@code protected} utility method that on each invocation can supply
                  up to 32 pseudorandomly generated bits.
                  &lt;p&gt;
                  Many applications will find the method {@link Math#random} simpler to use.
                  &lt;p&gt;Instances of {@code java.util.Random} are threadsafe.
                  However, the concurrent use of the same {@code java.util.Random}instance across threads may encounter contention and consequent
                  poor performance. Consider instead using{@link java.util.concurrent.ThreadLocalRandom} in multithreaded
                  designs.
                  &lt;p&gt;Instances of {@code java.util.Random} are not cryptographically
                  secure.  Consider instead using {@link java.security.SecureRandom} to
                  get a cryptographically secure pseudo-random number generator for use
                  by security-sensitive applications.                
                <author>
                    Frank Yellin                    
                </author>
                <since>
                    1.0                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="36"/>
            <javadoc line="36">
                use serialVersionUID from JDK 1.1 for interoperability                
            </javadoc>
            <declaration name="seed" type="AtomicLong" line="40"/>
            <javadoc line="40">
                The internal state associated with this pseudorandom number generator.
                  (The specs for the methods in this class describe the ongoing
                  computation of this value.)                
            </javadoc>
            <declaration name="multiplier" type="long" line="46"/>
            <declaration name="addend" type="long" line="47"/>
            <declaration name="mask" type="long" line="48"/>
            <javadoc line="49">
                Creates a new random number generator. This constructor sets
                  the seed of the random number generator to a value very likely
                  to be distinct from any other invocation of this constructor.                
            </javadoc>
            <method name="Random" type="constructor" line="54"/>
            <method name="seedUniquifier" type="long" line="57">
                <scope line="58">
                    <declaration name="current" type="long" line="59"/>
                    <declaration name="next" type="long" line="60"/>
                </scope>
            </method>
            <declaration name="seedUniquifier" type="AtomicLong" line="64"/>
            <javadoc line="65">
                Creates a new random number generator using a single {@code long} seed.
                  The seed is the initial value of the internal state of the pseudorandom
                  number generator which is maintained by method {@link #next}.
                  &lt;p&gt;The invocation {@code new Random(seed)} is equivalent to:
                  &lt;pre&gt; {@codeRandom rnd = new Random();
                  rnd.setSeed(seed);}&lt;/pre&gt;                
                <param>
                    seed the initial seed                    
                </param>
                <see>
                    #setSeed(long)                    
                </see>
            </javadoc>
            <method name="Random" type="constructor" line="75">
                <params>
                    <param name="seed" type="long"/>
                </params>
            </method>
            <method name="initialScramble" type="long" line="78">
                <params>
                    <param name="seed" type="long"/>
                </params>
            </method>
            <javadoc line="81">
                Sets the seed of this random number generator using a single{@code long} seed. The general contract of {@code setSeed} is
                  that it alters the state of this random number generator object
                  so as to be in exactly the same state as if it had just been
                  created with the argument {@code seed} as a seed. The method{@code setSeed} is implemented by class {@code Random} by
                  atomically updating the seed to
                  &lt;pre&gt;{@code (seed ^ 0x5DEECE66DL) &amp; ((1L &lt;&lt; 48) - 1)}&lt;/pre&gt;
                  and clearing the {@code haveNextNextGaussian} flag used by {@link #nextGaussian}.
                  &lt;p&gt;The implementation of {@code setSeed} by class {@code Random}happens to use only 48 bits of the given seed. In general, however,
                  an overriding method may use all 64 bits of the {@code long}argument as a seed value.                
                <param>
                    seed the initial seed                    
                </param>
            </javadoc>
            <method name="setSeed" type="void" line="93">
                <params>
                    <param name="seed" type="long"/>
                </params>
            </method>
            <javadoc line="97">
                Generates the next pseudorandom number. Subclasses should
                  override this, as this is used by all other methods.
                  &lt;p&gt;The general contract of {@code next} is that it returns an{@code int} value and if the argument {@code bits} is between{@code 1} and {@code 32} (inclusive), then that many low-order
                  bits of the returned value will be (approximately) independently
                  chosen bit values, each of which is (approximately) equally
                  likely to be {@code 0} or {@code 1}. The method {@code next} is
                  implemented by class {@code Random} by atomically updating the seed to
                  &lt;pre&gt;{@code (seed  0x5DEECE66DL + 0xBL) &amp; ((1L &lt;&lt; 48) - 1)}&lt;/pre&gt;
                  and returning
                  &lt;pre&gt;{@code (int)(seed &gt;&gt;&gt; (48 - bits))}.&lt;/pre&gt;
                  This is a linear congruential pseudorandom number generator, as
                  defined by D. H. Lehmer and described by Donald E. Knuth in
                  &lt;i&gt;The Art of Computer Programming,&lt;/i&gt; Volume 3:
                  &lt;i&gt;Seminumerical Algorithms&lt;/i&gt;, section 3.2.1.                
                <param>
                    bits random bits                    
                </param>
                <return>
                    the next pseudorandom value from this random number
                      generator's sequence                    
                </return>
                <since>
                    1.1                    
                </since>
            </javadoc>
            <method name="next" type="int" line="117">
                <params>
                    <param name="bits" type="int"/>
                </params>
                <declaration name="oldseed" type="long" line="118"/>
                <declaration name="seed" type="AtomicLong" line="119"/>
                <scope line="120"/>
            </method>
            <javadoc line="127">
                Generates random bytes and places them into a user-supplied
                  byte array.  The number of random bytes produced is equal to
                  the length of the byte array.
                  &lt;p&gt;The method {@code nextBytes} is implemented by class {@code Random}as if by:
                  &lt;pre&gt; {@code}public void nextBytes(byte[] bytes) 
                  for (int i = 0; i &lt; bytes.length; )
                  for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4);
                  n-- &gt; 0; rnd &gt;&gt;= 8)
                  bytes[i++] = (byte)rnd;
                  }}&lt;/pre&gt;                
                <param>
                    bytes the byte array to fill with random bytes                    
                </param>
                <throws>
                    NullPointerException if the byte array is null                    
                </throws>
                <since>
                    1.1                    
                </since>
            </javadoc>
            <method name="nextBytes" type="void" line="142">
                <params>
                    <param name="bytes" type="byte[]"/>
                </params>
            </method>
            <javadoc line="145">
                Returns the next pseudorandom, uniformly distributed {@code int}value from this random number generator&apos;s sequence. The general
                  contract of {@code nextInt} is that one {@code int} value is
                  pseudorandomly generated and returned. All 2&lt;font size=&quot;-1&quot;&gt;&lt;sup&gt;32
                  &lt;/sup&gt;&lt;/font&gt; possible {@code int} values are produced with
                  (approximately) equal probability.
                  &lt;p&gt;The method {@code nextInt} is implemented by class {@code Random}as if by:
                  &lt;pre&gt; {@code}public int nextInt() 
                  return next(32);
                  }}&lt;/pre&gt;                
                <return>
                    the next pseudorandom, uniformly distributed {@code int}value from this random number generator's sequence                    
                </return>
            </javadoc>
            <method name="nextInt" type="int" line="157"/>
            <javadoc line="160">
                Returns a pseudorandom, uniformly distributed {@code int} value
                  between 0 (inclusive) and the specified value (exclusive), drawn from
                  this random number generator&apos;s sequence.  The general contract of{@code nextInt} is that one {@code int} value in the specified range
                  is pseudorandomly generated and returned.  All {@code n} possible{@code int} values are produced with (approximately) equal
                  probability.  The method {@code nextInt(int n)} is implemented by
                  class {@code Random} as if by:
                  &lt;pre&gt; {@code}public int nextInt(int n) 
                  if (n &lt;= 0)
                  throw new IllegalArgumentException(&quot;n must be positive&quot;);
                  if ((n &amp; -n) == n)  // i.e., n is a power of 2
                  return (int)((n  (long)next(31)) &gt;&gt; 31);
                  int bits, val;
                  do {
                  bits = next(31);
                  val = bits % n;
                  } while (bits - val + (n-1) &lt; 0);
                  return val;
                  }}&lt;/pre&gt;
                  &lt;p&gt;The hedge &quot;approximately&quot; is used in the foregoing description only
                  because the next method is only approximately an unbiased source of
                  independently chosen bits.  If it were a perfect source of randomly
                  chosen bits, then the algorithm shown would choose {@code int}values from the stated range with perfect uniformity.
                  &lt;p&gt;
                  The algorithm is slightly tricky.  It rejects values that would result
                  in an uneven distribution (due to the fact that 2^31 is not divisible
                  by n). The probability of a value being rejected depends on n.  The
                  worst case is n=2^30+1, for which the probability of a reject is 1/2,
                  and the expected number of iterations before the loop terminates is 2.
                  &lt;p&gt;
                  The algorithm treats the case where n is a power of two specially: it
                  returns the correct number of high-order bits from the underlying
                  pseudo-random number generator.  In the absence of special treatment,
                  the correct number of &lt;i&gt;low-order&lt;/i&gt; bits would be returned.  Linear
                  congruential pseudo-random number generators such as the one
                  implemented by this class are known to have short periods in the
                  sequence of values of their low-order bits.  Thus, this special case
                  greatly increases the length of the sequence of values returned by
                  successive calls to this method if n is a small power of two.                
                <param>
                    n the bound on the random number to be returned.  Must be
                      positive.                    
                </param>
                <return>
                    the next pseudorandom, uniformly distributed {@code int}value between {@code 0} (inclusive) and {@code n} (exclusive)
                      from this random number generator's sequence                    
                </return>
                <throws>
                    IllegalArgumentException if n is not positive                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="nextInt" type="int" line="206">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="bits" type="int" line="209"/>
                <scope line="210"/>
            </method>
            <javadoc line="217">
                Returns the next pseudorandom, uniformly distributed {@code long}value from this random number generator&apos;s sequence. The general
                  contract of {@code nextLong} is that one {@code long} value is
                  pseudorandomly generated and returned.
                  &lt;p&gt;The method {@code nextLong} is implemented by class {@code Random}as if by:
                  &lt;pre&gt; {@code}public long nextLong() 
                  return ((long)next(32) &lt;&lt; 32) + next(32);
                  }}&lt;/pre&gt;
                  Because class {@code Random} uses a seed with only 48 bits,
                  this algorithm will not return all possible {@code long} values.                
                <return>
                    the next pseudorandom, uniformly distributed {@code long}value from this random number generator's sequence                    
                </return>
            </javadoc>
            <method name="nextLong" type="long" line="229"/>
            <javadoc line="232">
                Returns the next pseudorandom, uniformly distributed{@code boolean} value from this random number generator&apos;s
                  sequence. The general contract of {@code nextBoolean} is that one{@code boolean} value is pseudorandomly generated and returned.  The
                  values {@code true} and {@code false} are produced with
                  (approximately) equal probability.
                  &lt;p&gt;The method {@code nextBoolean} is implemented by class {@code Random}as if by:
                  &lt;pre&gt; {@code}public boolean nextBoolean() 
                  return next(1) != 0;
                  }}&lt;/pre&gt;                
                <return>
                    the next pseudorandom, uniformly distributed{@code boolean} value from this random number generator's
                      sequence                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="nextBoolean" type="boolean" line="245"/>
            <javadoc line="248">
                Returns the next pseudorandom, uniformly distributed {@code float}value between {@code 0.0} and {@code 1.0} from this random
                  number generator&apos;s sequence.
                  &lt;p&gt;The general contract of {@code nextFloat} is that one{@code float} value, chosen (approximately) uniformly from the
                  range {@code 0.0f} (inclusive) to {@code 1.0f} (exclusive), is
                  pseudorandomly generated and returned. All 2&lt;font
                  size=&quot;-1&quot;&gt;&lt;sup&gt;24&lt;/sup&gt;&lt;/font&gt; possible {@code float} values
                  of the form &lt;i&gt;m&amp;nbsp;x&amp;nbsp&lt;/i&gt;2&lt;font
                  size=&quot;-1&quot;&gt;&lt;sup&gt;-24&lt;/sup&gt;&lt;/font&gt;, where &lt;i&gt;m&lt;/i&gt; is a positive
                  integer less than 2&lt;font size=&quot;-1&quot;&gt;&lt;sup&gt;24&lt;/sup&gt; &lt;/font&gt;, are
                  produced with (approximately) equal probability.
                  &lt;p&gt;The method {@code nextFloat} is implemented by class {@code Random}as if by:
                  &lt;pre&gt; {@code}public float nextFloat() 
                  return next(24) / ((float)(1 &lt;&lt; 24));
                  }}&lt;/pre&gt;
                  &lt;p&gt;The hedge &quot;approximately&quot; is used in the foregoing description only
                  because the next method is only approximately an unbiased source of
                  independently chosen bits. If it were a perfect source of randomly
                  chosen bits, then the algorithm shown would choose {@code float}values from the stated range with perfect uniformity.&lt;p&gt;
                  [In early versions of Java, the result was incorrectly calculated as:
                  &lt;pre&gt; {@codereturn next(30) / ((float)(1 &lt;&lt; 30));}&lt;/pre&gt;
                  This might seem to be equivalent, if not better, but in fact it
                  introduced a slight nonuniformity because of the bias in the rounding
                  of floating-point numbers: it was slightly more likely that the
                  low-order bit of the significand would be 0 than that it would be 1.]                
                <return>
                    the next pseudorandom, uniformly distributed {@code float}value between {@code 0.0} and {@code 1.0} from this
                      random number generator's sequence                    
                </return>
            </javadoc>
            <method name="nextFloat" type="float" line="276"/>
            <javadoc line="279">
                Returns the next pseudorandom, uniformly distributed{@code double} value between {@code 0.0} and{@code 1.0} from this random number generator&apos;s sequence.
                  &lt;p&gt;The general contract of {@code nextDouble} is that one{@code double} value, chosen (approximately) uniformly from the
                  range {@code 0.0d} (inclusive) to {@code 1.0d} (exclusive), is
                  pseudorandomly generated and returned.
                  &lt;p&gt;The method {@code nextDouble} is implemented by class {@code Random}as if by:
                  &lt;pre&gt; {@code}public double nextDouble() 
                  return (((long)next(26) &lt;&lt; 27) + next(27))
                  / (double)(1L &lt;&lt; 53);
                  }}&lt;/pre&gt;
                  &lt;p&gt;The hedge &quot;approximately&quot; is used in the foregoing description only
                  because the {@code next} method is only approximately an unbiased
                  source of independently chosen bits. If it were a perfect source of
                  randomly chosen bits, then the algorithm shown would choose{@code double} values from the stated range with perfect uniformity.
                  &lt;p&gt;[In early versions of Java, the result was incorrectly calculated as:
                  &lt;pre&gt; {@codereturn (((long)next(27) &lt;&lt; 27) + next(27))
                  / (double)(1L &lt;&lt; 54);}&lt;/pre&gt;
                  This might seem to be equivalent, if not better, but in fact it
                  introduced a large nonuniformity because of the bias in the rounding
                  of floating-point numbers: it was three times as likely that the
                  low-order bit of the significand would be 0 than that it would be 1!
                  This nonuniformity probably doesn&apos;t matter much in practice, but we
                  strive for perfection.]                
                <return>
                    the next pseudorandom, uniformly distributed {@code double}value between {@code 0.0} and {@code 1.0} from this
                      random number generator's sequence                    
                </return>
                <see>
                    Math#random                    
                </see>
            </javadoc>
            <method name="nextDouble" type="double" line="306"/>
            <declaration name="nextNextGaussian" type="double" line="309"/>
            <declaration name="haveNextNextGaussian" type="boolean" line="310"/>
            <javadoc line="311">
                Returns the next pseudorandom, Gaussian (&quot;normally&quot;) distributed{@code double} value with mean {@code 0.0} and standard
                  deviation {@code 1.0} from this random number generator&apos;s sequence.
                  &lt;p&gt;
                  The general contract of {@code nextGaussian} is that one{@code double} value, chosen from (approximately) the usual
                  normal distribution with mean {@code 0.0} and standard deviation{@code 1.0}, is pseudorandomly generated and returned.
                  &lt;p&gt;The method {@code nextGaussian} is implemented by class{@code Random} as if by a threadsafe version of the following:
                  &lt;pre&gt; {@codeprivate double nextNextGaussian;
                  private boolean haveNextNextGaussian = false;}public double nextGaussian() 
                  if (haveNextNextGaussian) {
                  haveNextNextGaussian = false;
                  return nextNextGaussian;
                  } else {
                  double v1, v2, s;
                  do {
                  v1 = 2  nextDouble() - 1;   // between -1.0 and 1.0
                  v2 = 2  nextDouble() - 1;   // between -1.0 and 1.0
                  s = v1  v1 + v2  v2;
                  } while (s &gt;= 1 || s == 0);
                  double multiplier = StrictMath.sqrt(-2  StrictMath.log(s)/s);
                  nextNextGaussian = v2  multiplier;
                  haveNextNextGaussian = true;
                  return v1  multiplier;
                  }
                  }}&lt;/pre&gt;
                  This uses the &lt;i&gt;polar method&lt;/i&gt; of G. E. P. Box, M. E. Muller, and
                  G. Marsaglia, as described by Donald E. Knuth in &lt;i&gt;The Art of
                  Computer Programming&lt;/i&gt;, Volume 3: &lt;i&gt;Seminumerical Algorithms&lt;/i&gt;,
                  section 3.4.1, subsection C, algorithm P. Note that it generates two
                  independent values at the cost of only one call to {@code StrictMath.log}and one call to {@code StrictMath.sqrt}.                
                <return>
                    the next pseudorandom, Gaussian ("normally") distributed{@code double} value with mean {@code 0.0} and
                      standard deviation {@code 1.0} from this random number
                      generator's sequence                    
                </return>
            </javadoc>
            <method name="nextGaussian" type="double" line="345">
                <scope line="346"/>
                <scope line="350">
                    <declaration name="v1" type="double" line="351"/>
                    <scope line="352"/>
                    <declaration name="multiplier" type="double" line="358"/>
                </scope>
            </method>
            <declaration name="serialPersistentFields" type="ObjectStreamField[]" line="364"/>
            <javadoc line="364">
                Serializable fields for Random.                
                <serialField>
                    seed long
                      seed for random computations                    
                </serialField>
                <serialField>
                    nextNextGaussian double
                      next Gaussian to be returned                    
                </serialField>
                <serialField>
                    haveNextNextGaussian boolean
                      nextNextGaussian is valid                    
                </serialField>
            </javadoc>
            <javadoc line="374">
                Reconstitute the {@code Random} instance from a stream (that is,
                  deserialize it).                
            </javadoc>
            <method name="readObject" type="void" line="378">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <declaration name="fields" type="ObjectInputStream.GetField" line="379"/>
                <declaration name="seedVal" type="long" line="380"/>
            </method>
            <javadoc line="386">
                Save the {@code Random} instance to a stream.                
            </javadoc>
            <method name="writeObject" type="void" line="389">
                <params>
                    <param name="s" type="ObjectOutputStream"/>
                </params>
                <declaration name="fields" type="ObjectOutputStream.PutField" line="390"/>
            </method>
            <declaration name="unsafe" type="Unsafe" line="396"/>
            <declaration name="seedOffset" type="long" line="397"/>
            <scope line="398">
                <scope line="399"/>
                <scope line="402"/>
            </scope>
            <method name="resetSeed" type="void" line="406">
                <params>
                    <param name="seedVal" type="long"/>
                </params>
            </method>
        </class>
    </source>