<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <class name="WeakHashMap" line="31">
            <type_params>
                <type_param name="K"/>
                <type_param name="V"/>
            </type_params>
            <extends class="AbstractMap">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </extends>
            <comment line="257">
                internal utilities                
            </comment>
            <comment line="829">
                Views                
            </comment>
            <implements interface="Map">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </implements>
            <javadoc line="31">
                Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface, with
                  &lt;em&gt;weak keys&lt;/em&gt;.
                  An entry in a &lt;tt&gt;WeakHashMap&lt;/tt&gt; will automatically be removed when
                  its key is no longer in ordinary use.  More precisely, the presence of a
                  mapping for a given key will not prevent the key from being discarded by the
                  garbage collector, that is, made finalizable, finalized, and then reclaimed.
                  When a key has been discarded its entry is effectively removed from the map,
                  so this class behaves somewhat differently from other &lt;tt&gt;Map&lt;/tt&gt;
                  implementations.
                  &lt;p&gt; Both null values and the null key are supported. This class has
                  performance characteristics similar to those of the &lt;tt&gt;HashMap&lt;/tt&gt;
                  class, and has the same efficiency parameters of &lt;em&gt;initial capacity&lt;/em&gt;
                  and &lt;em&gt;load factor&lt;/em&gt;.
                  &lt;p&gt; Like most collection classes, this class is not synchronized.
                  A synchronized &lt;tt&gt;WeakHashMap&lt;/tt&gt; may be constructed using the{@link Collections#synchronizedMap Collections.synchronizedMap}method.
                  &lt;p&gt; This class is intended primarily for use with key objects whose
                  &lt;tt&gt;equals&lt;/tt&gt; methods test for object identity using the
                  &lt;tt&gt;==&lt;/tt&gt; operator.  Once such a key is discarded it can never be
                  recreated, so it is impossible to do a lookup of that key in a
                  &lt;tt&gt;WeakHashMap&lt;/tt&gt; at some later time and be surprised that its entry
                  has been removed.  This class will work perfectly well with key objects
                  whose &lt;tt&gt;equals&lt;/tt&gt; methods are not based upon object identity, such
                  as &lt;tt&gt;String&lt;/tt&gt; instances.  With such recreatable key objects,
                  however, the automatic removal of &lt;tt&gt;WeakHashMap&lt;/tt&gt; entries whose
                  keys have been discarded may prove to be confusing.
                  &lt;p&gt; The behavior of the &lt;tt&gt;WeakHashMap&lt;/tt&gt; class depends in part upon
                  the actions of the garbage collector, so several familiar (though not
                  required) &lt;tt&gt;Map&lt;/tt&gt; invariants do not hold for this class.  Because
                  the garbage collector may discard keys at any time, a
                  &lt;tt&gt;WeakHashMap&lt;/tt&gt; may behave as though an unknown thread is silently
                  removing entries.  In particular, even if you synchronize on a
                  &lt;tt&gt;WeakHashMap&lt;/tt&gt; instance and invoke none of its mutator methods, it
                  is possible for the &lt;tt&gt;size&lt;/tt&gt; method to return smaller values over
                  time, for the &lt;tt&gt;isEmpty&lt;/tt&gt; method to return &lt;tt&gt;false&lt;/tt&gt; and
                  then &lt;tt&gt;true&lt;/tt&gt;, for the &lt;tt&gt;containsKey&lt;/tt&gt; method to return
                  &lt;tt&gt;true&lt;/tt&gt; and later &lt;tt&gt;false&lt;/tt&gt; for a given key, for the
                  &lt;tt&gt;get&lt;/tt&gt; method to return a value for a given key but later return
                  &lt;tt&gt;null&lt;/tt&gt;, for the &lt;tt&gt;put&lt;/tt&gt; method to return
                  &lt;tt&gt;null&lt;/tt&gt; and the &lt;tt&gt;remove&lt;/tt&gt; method to return
                  &lt;tt&gt;false&lt;/tt&gt; for a key that previously appeared to be in the map, and
                  for successive examinations of the key set, the value collection, and
                  the entry set to yield successively smaller numbers of elements.
                  &lt;p&gt; Each key object in a &lt;tt&gt;WeakHashMap&lt;/tt&gt; is stored indirectly as
                  the referent of a weak reference.  Therefore a key will automatically be
                  removed only after the weak references to it, both inside and outside of the
                  map, have been cleared by the garbage collector.
                  &lt;p&gt; &lt;strong&gt;Implementation note:&lt;/strong&gt; The value objects in a
                  &lt;tt&gt;WeakHashMap&lt;/tt&gt; are held by ordinary strong references.  Thus care
                  should be taken to ensure that value objects do not strongly refer to their
                  own keys, either directly or indirectly, since that will prevent the keys
                  from being discarded.  Note that a value object may refer indirectly to its
                  key via the &lt;tt&gt;WeakHashMap&lt;/tt&gt; itself; that is, a value object may
                  strongly refer to some other key object whose associated value object, in
                  turn, strongly refers to the key of the first value object.  One way
                  to deal with this is to wrap values themselves within
                  &lt;tt&gt;WeakReferences&lt;/tt&gt; before
                  inserting, as in: &lt;tt&gt;m.put(key, new WeakReference(value))&lt;/tt&gt;,
                  and then unwrapping upon each &lt;tt&gt;get&lt;/tt&gt;.
                  &lt;p&gt;The iterators returned by the &lt;tt&gt;iterator&lt;/tt&gt; method of the collections
                  returned by all of this class&apos;s &quot;collection view methods&quot; are
                  &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after the
                  iterator is created, in any way except through the iterator&apos;s own
                  &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a {@link ConcurrentModificationException}.  Thus, in the face of concurrent
                  modification, the iterator fails quickly and cleanly, rather than risking
                  arbitrary, non-deterministic behavior at an undetermined time in the future.
                  &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                  as it is, generally speaking, impossible to make any hard guarantees in the
                  presence of unsynchronized concurrent modification.  Fail-fast iterators
                  throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.
                  Therefore, it would be wrong to write a program that depended on this
                  exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators
                  should be used only to detect bugs.&lt;/i&gt;
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <param>
                    &lt;K&gt;
                       the type of keys maintained by this map                    
                </param>
                <param>
                    &lt;V&gt;
                       the type of mapped values                    
                </param>
                <author>
                    Doug Lea                    
                </author>
                <author>
                    Josh Bloch                    
                </author>
                <author>
                    Mark Reinhold                    
                </author>
                <since>
                    1.2                    
                </since>
                <see>
                    java.util.HashMap                    
                </see>
                <see>
                    java.lang.ref.WeakReference                    
                </see>
            </javadoc>
            <declaration name="DEFAULT_INITIAL_CAPACITY" type="int" line="134"/>
            <javadoc line="134">
                The default initial capacity -- MUST be a power of two.                
            </javadoc>
            <declaration name="MAXIMUM_CAPACITY" type="int" line="139"/>
            <javadoc line="139">
                The maximum capacity, used if a higher value is implicitly specified
                  by either of the constructors with arguments.
                  MUST be a power of two &lt;= 1&lt;&lt;30.                
            </javadoc>
            <declaration name="DEFAULT_LOAD_FACTOR" type="float" line="146"/>
            <javadoc line="146">
                The load factor used when none specified in constructor.                
            </javadoc>
            <declaration name="table" type="Entry&lt;K,V&gt;[]" line="151"/>
            <javadoc line="151">
                The table, resized as necessary. Length MUST Always be a power of two.                
            </javadoc>
            <declaration name="size" type="int" line="156"/>
            <javadoc line="156">
                The number of key-value mappings contained in this weak hash map.                
            </javadoc>
            <declaration name="threshold" type="int" line="161"/>
            <javadoc line="161">
                The next size value at which to resize (capacity  load factor).                
            </javadoc>
            <declaration name="loadFactor" type="float" line="166"/>
            <javadoc line="166">
                The load factor for the hash table.                
            </javadoc>
            <declaration name="queue" type="ReferenceQueue&lt;Object&gt;" line="171"/>
            <javadoc line="171">
                Reference queue for cleared WeakEntries                
            </javadoc>
            <declaration name="modCount" type="int" line="176"/>
            <javadoc line="176">
                The number of times this WeakHashMap has been structurally modified.
                  Structural modifications are those that change the number of
                  mappings in the map or otherwise modify its internal structure
                  (e.g., rehash).  This field is used to make iterators on
                  Collection-views of the map fail-fast.                
                <see>
                    ConcurrentModificationException                    
                </see>
            </javadoc>
            <method name="newTable" type="Entry<K,V>[]" line="188">
                <params>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="192">
                Constructs a new, empty &lt;tt&gt;WeakHashMap&lt;/tt&gt; with the given initial
                  capacity and the given load factor.                
                <param>
                    initialCapacity The initial capacity of the &lt;tt&gt;WeakHashMap&lt;/tt&gt;                    
                </param>
                <param>
                    loadFactor      The load factor of the &lt;tt&gt;WeakHashMap&lt;/tt&gt;                    
                </param>
                <throws>
                    IllegalArgumentException if the initial capacity is negative,
                      or if the load factor is nonpositive.                    
                </throws>
            </javadoc>
            <method name="WeakHashMap" type="constructor" line="201">
                <params>
                    <param name="initialCapacity" type="int"/>
                    <param name="loadFactor" type="float"/>
                </params>
                <declaration name="capacity" type="int" line="211"/>
            </method>
            <javadoc line="219">
                Constructs a new, empty &lt;tt&gt;WeakHashMap&lt;/tt&gt; with the given initial
                  capacity and the default load factor (0.75).                
                <param>
                    initialCapacity The initial capacity of the &lt;tt&gt;WeakHashMap&lt;/tt&gt;                    
                </param>
                <throws>
                    IllegalArgumentException if the initial capacity is negative                    
                </throws>
            </javadoc>
            <method name="WeakHashMap" type="constructor" line="226">
                <params>
                    <param name="initialCapacity" type="int"/>
                </params>
            </method>
            <javadoc line="230">
                Constructs a new, empty &lt;tt&gt;WeakHashMap&lt;/tt&gt; with the default initial
                  capacity (16) and load factor (0.75).                
            </javadoc>
            <method name="WeakHashMap" type="constructor" line="234"/>
            <javadoc line="240">
                Constructs a new &lt;tt&gt;WeakHashMap&lt;/tt&gt; with the same mappings as the
                  specified map.  The &lt;tt&gt;WeakHashMap&lt;/tt&gt; is created with the default
                  load factor (0.75) and an initial capacity sufficient to hold the
                  mappings in the specified map.                
                <param>
                    m the map whose mappings are to be placed in this map                    
                </param>
                <throws>
                    NullPointerException if the specified map is null                    
                </throws>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="WeakHashMap" type="constructor" line="250">
                <params>
                    <param name="m" type="Map<? extends K,? extends V>"/>
                </params>
            </method>
            <declaration name="NULL_KEY" type="Object" line="258"/>
            <javadoc line="258">
                Value representing null keys inside tables.                
            </javadoc>
            <javadoc line="263">
                Use NULL_KEY for key if it is null.                
            </javadoc>
            <method name="maskNull" type="Object" line="266">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="270">
                Returns internal representation of null key back to caller as null.                
            </javadoc>
            <method name="unmaskNull" type="Object" line="273">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="277">
                Checks for equality of non-null reference x and possibly-null y.  By
                  default uses Object.equals.                
            </javadoc>
            <method name="eq" type="boolean" line="281">
                <params>
                    <param name="x" type="Object"/>
                    <param name="y" type="Object"/>
                </params>
            </method>
            <javadoc line="285">
                Returns index for hash code h.                
            </javadoc>
            <method name="indexFor" type="int" line="288">
                <params>
                    <param name="h" type="int"/>
                    <param name="length" type="int"/>
                </params>
            </method>
            <javadoc line="292">
                Expunges stale entries from the table.                
            </javadoc>
            <method name="expungeStaleEntries" type="void" line="295">
                <comment line="312">
                    Must not null out e.next;
                     stale entries may be in use by a HashIterator                    
                </comment>
                <comment line="314">
                    Help GC                    
                </comment>
                <scope line="296">
                    <scope line="297">
                        <declaration name="e" type="Entry&lt;K,V&gt;" line="298"/>
                        <declaration name="i" type="int" line="300"/>
                        <declaration name="prev" type="Entry&lt;K,V&gt;" line="302"/>
                        <declaration name="p" type="Entry&lt;K,V&gt;" line="303"/>
                        <scope line="304">
                            <declaration name="next" type="Entry&lt;K,V&gt;" line="305"/>
                            <scope line="306"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="324">
                Returns the table after first expunging stale entries.                
            </javadoc>
            <method name="getTable" type="Entry<K,V>[]" line="327"/>
            <javadoc line="332">
                Returns the number of key-value mappings in this map.
                  This result is a snapshot, and may not reflect unprocessed
                  entries that will be removed before next attempted access
                  because they are no longer referenced.                
            </javadoc>
            <method name="size" type="int" line="338"/>
            <javadoc line="345">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
                  This result is a snapshot, and may not reflect unprocessed
                  entries that will be removed before next attempted access
                  because they are no longer referenced.                
            </javadoc>
            <method name="isEmpty" type="boolean" line="351"/>
            <javadoc line="355">
                Returns the value to which the specified key is mapped,
                  or {@code null} if this map contains no mapping for the key.
                  &lt;p&gt;More formally, if this map contains a mapping from a key{@code k} to a value {@code v} such that {@code (key==null ? k==null :
                  key.equals(k))}, then this method returns {@code v}; otherwise
                  it returns {@code null}.  (There can be at most one such mapping.)
                  &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
                  indicate that the map contains no mapping for the key; it&apos;s also
                  possible that the map explicitly maps the key to {@code null}.
                  The {@link #containsKey containsKey} operation may be used to
                  distinguish these two cases.                
                <see>
                    #put(Object,Object)                    
                </see>
            </javadoc>
            <method name="get" type="V" line="372">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="k" type="Object" line="373"/>
                <declaration name="h" type="int" line="374"/>
                <declaration name="tab" type="Entry&lt;K,V&gt;[]" line="375"/>
                <declaration name="index" type="int" line="376"/>
                <declaration name="e" type="Entry&lt;K,V&gt;" line="377"/>
                <scope line="378"/>
            </method>
            <javadoc line="386">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the
                  specified key.                
                <param>
                    key   The key whose presence in this map is to be tested                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if there is a mapping for &lt;tt&gt;key&lt;/tt&gt;;
                      &lt;tt&gt;false&lt;/tt&gt; otherwise                    
                </return>
            </javadoc>
            <method name="containsKey" type="boolean" line="394">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="398">
                Returns the entry associated with the specified key in this map.
                  Returns null if the map contains no mapping for this key.                
            </javadoc>
            <method name="getEntry" type="Entry<K,V>" line="402">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="k" type="Object" line="403"/>
                <declaration name="h" type="int" line="404"/>
                <declaration name="tab" type="Entry&lt;K,V&gt;[]" line="405"/>
                <declaration name="index" type="int" line="406"/>
                <declaration name="e" type="Entry&lt;K,V&gt;" line="407"/>
            </method>
            <javadoc line="413">
                Associates the specified value with the specified key in this map.
                  If the map previously contained a mapping for this key, the old
                  value is replaced.                
                <param>
                    key key with which the specified value is to be associated.                    
                </param>
                <param>
                    value value to be associated with the specified key.                    
                </param>
                <return>
                    the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
                      &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
                      (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
                      previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)                    
                </return>
            </javadoc>
            <method name="put" type="V" line="425">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
                <declaration name="k" type="Object" line="426"/>
                <declaration name="h" type="int" line="427"/>
                <declaration name="tab" type="Entry&lt;K,V&gt;[]" line="428"/>
                <declaration name="i" type="int" line="429"/>
                <scope line="431">
                    <scope line="432">
                        <declaration name="oldValue" type="V" line="433"/>
                    </scope>
                </scope>
                <declaration name="e" type="Entry&lt;K,V&gt;" line="441"/>
            </method>
            <javadoc line="448">
                Rehashes the contents of this map into a new array with a
                  larger capacity.  This method is called automatically when the
                  number of keys in this map reaches its threshold.
                  If current capacity is MAXIMUM_CAPACITY, this method does not
                  resize the map, but sets threshold to Integer.MAX_VALUE.
                  This has the effect of preventing future calls.                
                <param>
                    newCapacity the new capacity, MUST be a power of two;
                      must be greater than current capacity unless current
                      capacity is MAXIMUM_CAPACITY (in which case value
                      is irrelevant).                    
                </param>
            </javadoc>
            <method name="resize" type="void" line="462">
                <params>
                    <param name="newCapacity" type="int"/>
                </params>
                <comment line="475">
                    If ignoring null elements and processing ref queue caused massive
                     shrinkage, then restore old table.  This should be rare, but avoids
                     unbounded expansion of garbage-filled tables.                    
                </comment>
                <declaration name="oldTable" type="Entry&lt;K,V&gt;[]" line="463"/>
                <declaration name="oldCapacity" type="int" line="464"/>
                <scope line="465"/>
                <declaration name="newTable" type="Entry&lt;K,V&gt;[]" line="470"/>
                <scope line="479"/>
                <scope line="481"/>
            </method>
            <javadoc line="488">
                Transfers all entries from src to dest tables                
            </javadoc>
            <method name="transfer" type="void" line="489">
                <params>
                    <param name="src" type="Entry<K,V>[]"/>
                    <param name="dest" type="Entry<K,V>[]"/>
                </params>
                <comment line="498">
                    Help GC                    
                </comment>
                <comment line="499">
                    &quot;   &quot;                    
                </comment>
                <scope line="490">
                    <declaration name="e" type="Entry&lt;K,V&gt;" line="491"/>
                    <scope line="493">
                        <declaration name="next" type="Entry&lt;K,V&gt;" line="494"/>
                        <declaration name="key" type="Object" line="495"/>
                        <scope line="496"/>
                        <scope line="500">
                            <declaration name="i" type="int" line="501"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="510">
                Copies all of the mappings from the specified map to this map.
                  These mappings will replace any mappings that this map had for any
                  of the keys currently in the specified map.                
                <param>
                    m mappings to be stored in this map.                    
                </param>
                <throws>
                    NullPointerException if the specified map is null.                    
                </throws>
            </javadoc>
            <method name="putAll" type="void" line="518">
                <params>
                    <param name="m" type="Map<? extends K,? extends V>"/>
                </params>
                <comment line="524">
                    Expand the map if the map if the number of mappings to be added
                     is greater than or equal to threshold.  This is conservative; the
                     obvious condition is (m.size() + size) &gt;= threshold, but this
                     condition could result in a map with twice the appropriate capacity,
                     if the keys to be added overlap with the keys already in this map.
                     By using the conservative calculation, we subject ourself
                     to at most one extra resize.                    
                </comment>
                <declaration name="numKeysToBeAdded" type="int" line="519"/>
                <scope line="532">
                    <declaration name="targetCapacity" type="int" line="533"/>
                    <declaration name="newCapacity" type="int" line="536"/>
                </scope>
            </method>
            <javadoc line="547">
                Removes the mapping for a key from this weak hash map if it is present.
                  More formally, if this map contains a mapping from key &lt;tt&gt;k&lt;/tt&gt; to
                  value &lt;tt&gt;v&lt;/tt&gt; such that &lt;code&gt;(key==null ?  k==null :
                  key.equals(k))&lt;/code&gt;, that mapping is removed.  (The map can contain
                  at most one such mapping.)
                  &lt;p&gt;Returns the value to which this map previously associated the key,
                  or &lt;tt&gt;null&lt;/tt&gt; if the map contained no mapping for the key.  A
                  return value of &lt;tt&gt;null&lt;/tt&gt; does not &lt;i&gt;necessarily&lt;/i&gt; indicate
                  that the map contained no mapping for the key; it&apos;s also possible
                  that the map explicitly mapped the key to &lt;tt&gt;null&lt;/tt&gt;.
                  &lt;p&gt;The map will not contain a mapping for the specified key once the
                  call returns.                
                <param>
                    key key whose mapping is to be removed from the map                    
                </param>
                <return>
                    the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
                      &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;                    
                </return>
            </javadoc>
            <method name="remove" type="V" line="567">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="k" type="Object" line="568"/>
                <declaration name="h" type="int" line="569"/>
                <declaration name="tab" type="Entry&lt;K,V&gt;[]" line="570"/>
                <declaration name="i" type="int" line="571"/>
                <declaration name="prev" type="Entry&lt;K,V&gt;" line="572"/>
                <declaration name="e" type="Entry&lt;K,V&gt;" line="573"/>
                <scope line="575">
                    <declaration name="next" type="Entry&lt;K,V&gt;" line="576"/>
                    <scope line="577"/>
                </scope>
            </method>
            <javadoc line="593">
                Special version of remove needed by Entry set                
            </javadoc>
            <method name="removeMapping" type="boolean" line="594">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="tab" type="Entry&lt;K,V&gt;[]" line="597"/>
                <declaration name="entry" type="Map.Entry&lt;?,?&gt;" line="598"/>
                <declaration name="k" type="Object" line="599"/>
                <declaration name="h" type="int" line="600"/>
                <declaration name="i" type="int" line="601"/>
                <declaration name="prev" type="Entry&lt;K,V&gt;" line="602"/>
                <declaration name="e" type="Entry&lt;K,V&gt;" line="603"/>
                <scope line="605">
                    <declaration name="next" type="Entry&lt;K,V&gt;" line="606"/>
                    <scope line="607"/>
                </scope>
            </method>
            <javadoc line="623">
                Removes all of the mappings from this map.
                  The map will be empty after this call returns.                
            </javadoc>
            <method name="clear" type="void" line="627">
                <comment line="629">
                    clear out ref queue. We don&apos;t need to expunge entries
                     since table is getting cleared.                    
                </comment>
                <comment line="638">
                    Allocation of array may have caused GC, which may have caused
                     additional entries to go stale.  Removing these entries from the
                     reference queue will make them eligible for reclamation.                    
                </comment>
            </method>
            <javadoc line="644">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
                  specified value.                
                <param>
                    value value whose presence in this map is to be tested                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
                      specified value                    
                </return>
            </javadoc>
            <method name="containsValue" type="boolean" line="652">
                <params>
                    <param name="value" type="Object"/>
                </params>
                <declaration name="tab" type="Entry&lt;K,V&gt;[]" line="656"/>
            </method>
            <javadoc line="664">
                Special-case code for containsValue with null argument                
            </javadoc>
            <method name="containsNullValue" type="boolean" line="667">
                <declaration name="tab" type="Entry&lt;K,V&gt;[]" line="668"/>
            </method>
            <class name="Entry" line="676">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="Object"/>
                    </type_params>
                </extends>
                <implements interface="Map.Entry">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <javadoc line="676">
                    The entries in this hash table extend WeakReference, using its main ref
                      field as the key.                    
                </javadoc>
                <declaration name="value" type="V" line="681"/>
                <declaration name="hash" type="int" line="682"/>
                <declaration name="next" type="Entry&lt;K,V&gt;" line="683"/>
                <javadoc line="685">
                    Creates new entry.                    
                </javadoc>
                <method name="Entry" type="constructor" line="690">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="value" type="V"/>
                        <param name="queue" type="ReferenceQueue<Object>"/>
                        <param name="hash" type="int"/>
                        <param name="next" type="Entry<K,V>"/>
                    </params>
                </method>
                <method name="getKey" type="K" line="698"/>
                <method name="getValue" type="V" line="702"/>
                <method name="setValue" type="V" line="706">
                    <params>
                        <param name="newValue" type="V"/>
                    </params>
                    <declaration name="oldValue" type="V" line="707"/>
                </method>
                <method name="equals" type="boolean" line="712">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="e" type="Map.Entry&lt;?,?&gt;" line="715"/>
                    <declaration name="k1" type="K" line="716"/>
                    <declaration name="k2" type="Object" line="717"/>
                    <scope line="718">
                        <declaration name="v1" type="V" line="719"/>
                        <declaration name="v2" type="Object" line="720"/>
                    </scope>
                </method>
                <method name="hashCode" type="int" line="727">
                    <declaration name="k" type="K" line="728"/>
                    <declaration name="v" type="V" line="729"/>
                </method>
                <method name="toString" type="String" line="734"/>
            </class>
            <class name="HashIterator" line="739">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <declaration name="index" type="int" line="740"/>
                <declaration name="entry" type="Entry&lt;K,V&gt;" line="741"/>
                <declaration name="lastReturned" type="Entry&lt;K,V&gt;" line="742"/>
                <declaration name="expectedModCount" type="int" line="743"/>
                <declaration name="nextKey" type="Object" line="745"/>
                <javadoc line="745">
                    Strong reference needed to avoid disappearance of key
                      between hasNext and next                    
                </javadoc>
                <declaration name="currentKey" type="Object" line="751"/>
                <javadoc line="751">
                    Strong reference needed to avoid disappearance of key
                      between nextEntry() and any use of the entry                    
                </javadoc>
                <method name="HashIterator" type="constructor" line="757"/>
                <method name="hasNext" type="boolean" line="761">
                    <comment line="776">
                        hold on to key in strong ref                        
                    </comment>
                    <declaration name="t" type="Entry&lt;K,V&gt;[]" line="762"/>
                    <scope line="764">
                        <declaration name="e" type="Entry&lt;K,V&gt;" line="765"/>
                        <declaration name="i" type="int" line="766"/>
                        <scope line="771"/>
                    </scope>
                </method>
                <javadoc line="782">
                    The common parts of next() across different types of iterators                    
                </javadoc>
                <method name="nextEntry" type="Entry<K,V>" line="783"/>
                <method name="remove" type="void" line="796"/>
            </class>
            <class name="ValueIterator" line="810">
                <extends class="HashIterator">
                    <type_params>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <method name="next" type="V" line="811"/>
            </class>
            <class name="KeyIterator" line="816">
                <extends class="HashIterator">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </extends>
                <method name="next" type="K" line="817"/>
            </class>
            <class name="EntryIterator" line="822">
                <extends class="HashIterator">
                    <type_params>
                        <type_param name="Map.Entry<K,V>"/>
                    </type_params>
                </extends>
                <method name="next" type="Map.Entry<K,V>" line="823"/>
            </class>
            <declaration name="entrySet" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="830"/>
            <javadoc line="832">
                Returns a {@link Set} view of the keys contained in this map.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  If the map is modified
                  while an iteration over the set is in progress (except through
                  the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of
                  the iteration are undefined.  The set supports element removal,
                  which removes the corresponding mapping from the map, via the
                  &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
                  &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
                  operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;
                  operations.                
            </javadoc>
            <method name="keySet" type="Set<K>" line="845">
                <declaration name="ks" type="Set&lt;K&gt;" line="846"/>
            </method>
            <class name="KeySet" line="850">
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </extends>
                <method name="iterator" type="Iterator<K>" line="851"/>
                <method name="size" type="int" line="855"/>
                <method name="contains" type="boolean" line="859">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="863">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="864"/>
                </method>
                <method name="clear" type="void" line="872"/>
            </class>
            <javadoc line="877">
                Returns a {@link Collection} view of the values contained in this map.
                  The collection is backed by the map, so changes to the map are
                  reflected in the collection, and vice-versa.  If the map is
                  modified while an iteration over the collection is in progress
                  (except through the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation),
                  the results of the iteration are undefined.  The collection
                  supports element removal, which removes the corresponding
                  mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
                  &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
                  &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not
                  support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.                
            </javadoc>
            <method name="values" type="Collection<V>" line="890">
                <declaration name="vs" type="Collection&lt;V&gt;" line="891"/>
            </method>
            <class name="Values" line="895">
                <extends class="AbstractCollection">
                    <type_params>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <method name="iterator" type="Iterator<V>" line="896"/>
                <method name="size" type="int" line="900"/>
                <method name="contains" type="boolean" line="904">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="908"/>
            </class>
            <javadoc line="913">
                Returns a {@link Set} view of the mappings contained in this map.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  If the map is modified
                  while an iteration over the set is in progress (except through
                  the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the
                  &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the
                  iterator) the results of the iteration are undefined.  The set
                  supports element removal, which removes the corresponding
                  mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
                  &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and
                  &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the
                  &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.                
            </javadoc>
            <method name="entrySet" type="Set<Map.Entry<K,V>>" line="927">
                <declaration name="es" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="928"/>
            </method>
            <class name="EntrySet" line="932">
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="Map.Entry<K,V>"/>
                    </type_params>
                </extends>
                <method name="iterator" type="Iterator<Map.Entry<K,V>>" line="933"/>
                <method name="contains" type="boolean" line="937">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="e" type="Map.Entry&lt;?,?&gt;" line="940"/>
                    <declaration name="candidate" type="Entry&lt;K,V&gt;" line="941"/>
                </method>
                <method name="remove" type="boolean" line="945">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="size" type="int" line="949"/>
                <method name="clear" type="void" line="953"/>
                <method name="deepCopy" type="List<Map.Entry<K,V>>" line="957">
                    <declaration name="list" type="List&lt;Map.Entry&lt;K,V&gt;&gt;" line="958"/>
                </method>
                <method name="toArray" type="Object[]" line="964"/>
                <method name="toArray" type="T[]" line="968">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
            </class>
        </class>
    </source>