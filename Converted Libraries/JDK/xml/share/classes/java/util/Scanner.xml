<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <import package="java.nio.file.Path"/>
        <import package="java.nio.file.Files"/>
        <import package="java.util.regex"/>
        <import package="java.io"/>
        <import package="java.math"/>
        <import package="java.nio"/>
        <import package="java.nio.channels"/>
        <import package="java.nio.charset"/>
        <import package="java.text"/>
        <import package="java.util.Locale"/>
        <import package="sun.misc.LRUCache"/>
        <class name="Scanner" line="41">
            <comment line="351">
                Internal buffer used to hold input                
            </comment>
            <comment line="354">
                Size of internal character buffer                
            </comment>
            <comment line="355">
                change to 1024;                
            </comment>
            <comment line="357">
                The index into the buffer currently held by the Scanner                
            </comment>
            <comment line="360">
                Internal matcher used for finding delimiters                
            </comment>
            <comment line="363">
                Pattern used to delimit tokens                
            </comment>
            <comment line="366">
                Pattern found in last hasNext operation                
            </comment>
            <comment line="369">
                Position after last hasNext operation                
            </comment>
            <comment line="372">
                Result after last hasNext operation                
            </comment>
            <comment line="375">
                The input source                
            </comment>
            <comment line="378">
                Boolean is true if source is done                
            </comment>
            <comment line="381">
                Boolean indicating more input is required                
            </comment>
            <comment line="384">
                Boolean indicating if a delim has been skipped this operation                
            </comment>
            <comment line="387">
                A store of a position that the scanner may fall back to                
            </comment>
            <comment line="390">
                A cache of the last primitive type scanned                
            </comment>
            <comment line="393">
                Boolean indicating if a match result is available                
            </comment>
            <comment line="396">
                Boolean indicating if this scanner has been closed                
            </comment>
            <comment line="399">
                The current radix used by this scanner                
            </comment>
            <comment line="402">
                The default radix for this scanner                
            </comment>
            <comment line="405">
                The locale used by this scanner                
            </comment>
            <comment line="408">
                A cache of the last few recently used Patterns                
            </comment>
            <comment line="419">
                A holder of the last IOException encountered                
            </comment>
            <comment line="422">
                A pattern for java whitespace                
            </comment>
            <comment line="426">
                A pattern for any token                
            </comment>
            <comment line="429">
                A pattern for non-ASCII digits                
            </comment>
            <comment line="433">
                Fields and methods to support scanning primitive types                
            </comment>
            <comment line="566">
                Constructors                
            </comment>
            <comment line="784">
                Private primitives used to support scanning                
            </comment>
            <comment line="815">
                Clears both regular cache and type cache                
            </comment>
            <comment line="821">
                Also clears both the regular cache and the type cache                
            </comment>
            <comment line="829">
                Also clears both the regular cache and the type cache                
            </comment>
            <comment line="838">
                Tries to read more input. May block.                
            </comment>
            <comment line="869">
                After this method is called there will either be an exception
                 or else there will be space in the buffer                
            </comment>
            <comment line="896">
                When a buffer compaction/reallocation occurs the saved indexes must
                 be modified appropriately                
            </comment>
            <comment line="903">
                If we are at the end of input then NoSuchElement;
                 If there is still input left then InputMismatch                
            </comment>
            <comment line="913">
                Returns true if a complete token or partial token is in the buffer.
                 It is not necessary to find a complete token since a partial token
                 means that there will be another token with or without more input.                
            </comment>
            <comment line="932">
                Returns a &quot;complete token&quot; that matches the specified pattern
                
                 A token is complete if surrounded by delims; a partial token
                 is prefixed by delims but not postfixed by them
                
                 The position is advanced to the end of that complete token
                
                 Pattern == null means accept any token at all
                
                 Triple return:
                 1. valid string means it was found
                 2. null with needInput=false means we won&apos;t ever find it
                 3. null with needInput=true means try again after readInput                
            </comment>
            <comment line="1043">
                Finds the specified pattern in the buffer up to horizon.
                 Returns a match for the specified input pattern.                
            </comment>
            <comment line="1089">
                Returns a match for the specified input pattern anchored at
                 the current position                
            </comment>
            <comment line="1113">
                Throws if the scanner is closed                
            </comment>
            <comment line="1119">
                Public methods                
            </comment>
            <comment line="1308">
                The next operation should occur in the specified radix but
                 the default is left untouched.                
            </comment>
            <comment line="1597">
                Public methods that ignore delimiters                
            </comment>
            <comment line="1796">
                Convenience methods for scanning primitives                
            </comment>
            <comment line="2464">
                Convenience methods for scanning multi precision numbers                
            </comment>
            <implements interface="Iterator">
                <type_params>
                    <type_param name="String"/>
                </type_params>
            </implements>
            <implements interface="Closeable"/>
            <javadoc line="41">
                A simple text scanner which can parse primitive types and strings using
                  regular expressions.
                  &lt;p&gt;A &lt;code&gt;Scanner&lt;/code&gt; breaks its input into tokens using a
                  delimiter pattern, which by default matches whitespace. The resulting
                  tokens may then be converted into values of different types using the
                  various &lt;tt&gt;next&lt;/tt&gt; methods.
                  &lt;p&gt;For example, this code allows a user to read a number from
                  &lt;tt&gt;System.in&lt;/tt&gt;:
                  &lt;blockquote&gt;&lt;pre&gt;
                  Scanner sc = new Scanner(System.in);
                  int i = sc.nextInt();
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;As another example, this code allows &lt;code&gt;long&lt;/code&gt; types to be
                  assigned from entries in a file &lt;code&gt;myNumbers&lt;/code&gt;:
                  &lt;blockquote&gt;&lt;pre&gt;
                  Scanner sc = new Scanner(new File(&quot;myNumbers&quot;));
                  while (sc.hasNextLong()) {
                  long aLong = sc.nextLong();
                  }&lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;The scanner can also use delimiters other than whitespace. This
                  example reads several items in from a string:
                  &lt;blockquote&gt;&lt;pre&gt;
                  String input = &quot;1 fish 2 fish red fish blue fish&quot;;
                  Scanner s = new Scanner(input).useDelimiter(&quot;\\sfish\\s&quot;);
                  System.out.println(s.nextInt());
                  System.out.println(s.nextInt());
                  System.out.println(s.next());
                  System.out.println(s.next());
                  s.close(); &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  prints the following output:
                  &lt;blockquote&gt;&lt;pre&gt;
                  1
                  2
                  red
                  blue &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;The same output can be generated with this code, which uses a regular
                  expression to parse all four tokens at once:
                  &lt;blockquote&gt;&lt;pre&gt;
                  String input = &quot;1 fish 2 fish red fish blue fish&quot;;
                  Scanner s = new Scanner(input);
                  s.findInLine(&quot;(\\d+) fish (\\d+) fish (\\w+) fish (\\w+)&quot;);
                  MatchResult result = s.match();
                  for (int i=1; i&lt;=result.groupCount(); i++)
                  System.out.println(result.group(i));
                  s.close(); &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;The &lt;a name=&quot;default-delimiter&quot;&gt;default whitespace delimiter&lt;/a&gt; used
                  by a scanner is as recognized by {@link java.lang.Character}.{@link java.lang.Character#isWhitespace(char) isWhitespace}. The {@link #reset}method will reset the value of the scanner&apos;s delimiter to the default
                  whitespace delimiter regardless of whether it was previously changed.
                  &lt;p&gt;A scanning operation may block waiting for input.
                  &lt;p&gt;The {@link #next} and {@link #hasNext} methods and their
                  primitive-type companion methods (such as {@link #nextInt} and{@link #hasNextInt}) first skip any input that matches the delimiter
                  pattern, and then attempt to return the next token. Both &lt;tt&gt;hasNext&lt;/tt&gt;
                  and &lt;tt&gt;next&lt;/tt&gt; methods may block waiting for further input.  Whether a
                  &lt;tt&gt;hasNext&lt;/tt&gt; method blocks has no connection to whether or not its
                  associated &lt;tt&gt;next&lt;/tt&gt; method will block.
                  &lt;p&gt; The {@link #findInLine}, {@link #findWithinHorizon}, and {@link #skip}methods operate independently of the delimiter pattern. These methods will
                  attempt to match the specified pattern with no regard to delimiters in the
                  input and thus can be used in special circumstances where delimiters are
                  not relevant. These methods may block waiting for more input.
                  &lt;p&gt;When a scanner throws an {@link InputMismatchException}, the scanner
                  will not pass the token that caused the exception, so that it may be
                  retrieved or skipped via some other method.
                  &lt;p&gt;Depending upon the type of delimiting pattern, empty tokens may be
                  returned. For example, the pattern &lt;tt&gt;&quot;\\s+&quot;&lt;/tt&gt; will return no empty
                  tokens since it matches multiple instances of the delimiter. The delimiting
                  pattern &lt;tt&gt;&quot;\\s&quot;&lt;/tt&gt; could return empty tokens since it only passes one
                  space at a time.
                  &lt;p&gt; A scanner can read text from any object which implements the {@link java.lang.Readable} interface.  If an invocation of the underlying
                  readable&apos;s {@link java.lang.Readable#read} method throws an {@link java.io.IOException} then the scanner assumes that the end of the input
                  has been reached.  The most recent &lt;tt&gt;IOException&lt;/tt&gt; thrown by the
                  underlying readable can be retrieved via the {@link #ioException} method.
                  &lt;p&gt;When a &lt;code&gt;Scanner&lt;/code&gt; is closed, it will close its input source
                  if the source implements the {@link java.io.Closeable} interface.
                  &lt;p&gt;A &lt;code&gt;Scanner&lt;/code&gt; is not safe for multithreaded use without
                  external synchronization.
                  &lt;p&gt;Unless otherwise mentioned, passing a &lt;code&gt;null&lt;/code&gt; parameter into
                  any method of a &lt;code&gt;Scanner&lt;/code&gt; will cause a
                  &lt;code&gt;NullPointerException&lt;/code&gt; to be thrown.
                  &lt;p&gt;A scanner will default to interpreting numbers as decimal unless a
                  different radix has been set by using the {@link #useRadix} method. The{@link #reset} method will reset the value of the scanner&apos;s radix to
                  &lt;code&gt;10&lt;/code&gt; regardless of whether it was previously changed.
                  &lt;a name=&quot;localized-numbers&quot;&gt;
                  &lt;h4&gt; Localized numbers &lt;/h4&gt;
                  &lt;p&gt; An instance of this class is capable of scanning numbers in the standard
                  formats as well as in the formats of the scanner&apos;s locale. A scanner&apos;s
                  &lt;a name=&quot;initial-locale&quot;&gt;initial locale &lt;/a&gt;is the value returned by the {@link java.util.Locale#getDefault} method; it may be changed via the {@link #useLocale} method. The {@link #reset} method will reset the value of the
                  scanner&apos;s locale to the initial locale regardless of whether it was
                  previously changed.
                  &lt;p&gt;The localized formats are defined in terms of the following parameters,
                  which for a particular locale are taken from that locale&apos;s {@link java.text.DecimalFormat DecimalFormat} object, &lt;tt&gt;df&lt;/tt&gt;, and its and{@link java.text.DecimalFormatSymbols DecimalFormatSymbols} object,
                  &lt;tt&gt;dfs&lt;/tt&gt;.
                  &lt;blockquote&gt;&lt;table&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalGroupSeparator&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The character used to separate thousands groups,
                  &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;dfs.&lt;/tt&gt;{@link java.text.DecimalFormatSymbols#getGroupingSeparatorgetGroupingSeparator()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalDecimalSeparator&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The character used for the decimal point,
                  &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;dfs.&lt;/tt&gt;{@link java.text.DecimalFormatSymbols#getDecimalSeparatorgetDecimalSeparator()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalPositivePrefix&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that appears before a positive number (may
                  be empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;df.&lt;/tt&gt;{@link java.text.DecimalFormat#getPositivePrefixgetPositivePrefix()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalPositiveSuffix&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that appears after a positive number (may be
                  empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;df.&lt;/tt&gt;{@link java.text.DecimalFormat#getPositiveSuffixgetPositiveSuffix()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalNegativePrefix&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that appears before a negative number (may
                  be empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;df.&lt;/tt&gt;{@link java.text.DecimalFormat#getNegativePrefixgetNegativePrefix()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalNegativeSuffix&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that appears after a negative number (may be
                  empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;df.&lt;/tt&gt;{@link java.text.DecimalFormat#getNegativeSuffixgetNegativeSuffix()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalNaN&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that represents not-a-number for
                  floating-point values,
                  &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;dfs.&lt;/tt&gt;{@link java.text.DecimalFormatSymbols#getNaNgetNaN()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalInfinity&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that represents infinity for floating-point
                  values, &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;dfs.&lt;/tt&gt;{@link java.text.DecimalFormatSymbols#getInfinitygetInfinity()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;
                  &lt;a name=&quot;number-syntax&quot;&gt;
                  &lt;h4&gt; Number syntax &lt;/h4&gt;
                  &lt;p&gt; The strings that can be parsed as numbers by an instance of this class
                  are specified in terms of the following regular-expression grammar, where
                  Rmax is the highest digit in the radix being used (for example, Rmax is 9
                  in base 10).
                  &lt;p&gt;
                  &lt;table cellspacing=0 cellpadding=0 align=center&gt;
                  &lt;tr&gt;&lt;td valign=top align=right&gt;&lt;i&gt;NonASCIIDigit&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;= A non-ASCII character c for which{@link java.lang.Character#isDigit Character.isDigit}&lt;tt&gt;(c)&lt;/tt&gt;
                  returns&amp;nbsp;true&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;Non0Digit&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= [1-&lt;/tt&gt;&lt;i&gt;Rmax&lt;/i&gt;&lt;tt&gt;] | &lt;/tt&gt;&lt;i&gt;NonASCIIDigit&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;Digit&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= [0-&lt;/tt&gt;&lt;i&gt;Rmax&lt;/i&gt;&lt;tt&gt;] | &lt;/tt&gt;&lt;i&gt;NonASCIIDigit&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top align=right&gt;&lt;i&gt;GroupedNumeral&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;
                  &lt;table cellpadding=0 cellspacing=0&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;= (&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;i&gt;Non0Digit&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;?
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;?&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;(&amp;nbsp;&lt;/tt&gt;&lt;i&gt;LocalGroupSeparator&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt; )+ )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;Numeral&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= ( ( &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;+ )
                  | &lt;/tt&gt;&lt;i&gt;GroupedNumeral&lt;/i&gt;&lt;tt&gt; )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top align=right&gt;
                  &lt;a name=&quot;Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;&lt;tt&gt;= ( [-+]? ( &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;tt&gt;
                  ) )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalPositivePrefix&lt;/i&gt;&lt;tt&gt; &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalPositiveSuffix&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalNegativePrefix&lt;/i&gt;&lt;tt&gt; &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalNegativeSuffix&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;DecimalNumeral&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalDecimalSeparator&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalDecimalSeparator&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;+&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;Exponent&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= ( [eE] [+-]? &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;+ )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;
                  &lt;a name=&quot;Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= ( [-+]? &lt;/tt&gt;&lt;i&gt;DecimalNumeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Exponent&lt;/i&gt;&lt;tt&gt;? )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalPositivePrefix&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;DecimalNumeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalPositiveSuffix&lt;/i&gt;
                  &lt;/tt&gt;&lt;i&gt;Exponent&lt;/i&gt;&lt;tt&gt;?&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalNegativePrefix&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;DecimalNumeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalNegativeSuffix&lt;/i&gt;
                  &lt;/tt&gt;&lt;i&gt;Exponent&lt;/i&gt;&lt;tt&gt;?&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;HexFloat&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= [-+]? 0[xX][0-9a-fA-F]\.[0-9a-fA-F]+
                  ([pP][-+]?[0-9]+)?&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;NonNumber&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;&lt;tt&gt;= NaN
                  | &lt;/tt&gt;&lt;i&gt;LocalNan&lt;/i&gt;&lt;tt&gt;
                  | Infinity
                  | &lt;/tt&gt;&lt;i&gt;LocalInfinity&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;SignedNonNumber&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= ( [-+]? &lt;/tt&gt;&lt;i&gt;NonNumber&lt;/i&gt;&lt;tt&gt; )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalPositivePrefix&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;NonNumber&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalPositiveSuffix&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalNegativePrefix&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;NonNumber&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalNegativeSuffix&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top align=right&gt;
                  &lt;a name=&quot;Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;&lt;tt&gt;= &lt;/tt&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;HexFloat&lt;/i&gt;&lt;tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;SignedNonNumber&lt;/i&gt;&lt;tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/center&gt;
                  &lt;p&gt; Whitespace is not significant in the above regular expressions.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="buf" type="CharBuffer" line="351"/>
            <declaration name="BUFFER_SIZE" type="int" line="354"/>
            <declaration name="position" type="int" line="357"/>
            <declaration name="matcher" type="Matcher" line="360"/>
            <declaration name="delimPattern" type="Pattern" line="363"/>
            <declaration name="hasNextPattern" type="Pattern" line="366"/>
            <declaration name="hasNextPosition" type="int" line="369"/>
            <declaration name="hasNextResult" type="String" line="372"/>
            <declaration name="source" type="Readable" line="375"/>
            <declaration name="sourceClosed" type="boolean" line="378"/>
            <declaration name="needInput" type="boolean" line="381"/>
            <declaration name="skipped" type="boolean" line="384"/>
            <declaration name="savedScannerPosition" type="int" line="387"/>
            <declaration name="typeCache" type="Object" line="390"/>
            <declaration name="matchValid" type="boolean" line="393"/>
            <declaration name="closed" type="boolean" line="396"/>
            <declaration name="radix" type="int" line="399"/>
            <declaration name="defaultRadix" type="int" line="402"/>
            <declaration name="locale" type="Locale" line="405"/>
            <declaration name="patternCache" type="LRUCache&lt;String,Pattern&gt;" line="408"/>
            <anonymous_class line="409">
                <method name="create" type="Pattern" line="410">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <method name="hasName" type="boolean" line="413">
                    <params>
                        <param name="p" type="Pattern"/>
                        <param name="s" type="String"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="lastException" type="IOException" line="419"/>
            <declaration name="WHITESPACE_PATTERN" type="Pattern" line="422"/>
            <declaration name="FIND_ANY_PATTERN" type="Pattern" line="426"/>
            <declaration name="NON_ASCII_DIGIT" type="Pattern" line="429"/>
            <declaration name="groupSeparator" type="String" line="434"/>
            <javadoc line="434">
                Locale dependent values used to scan numbers                
            </javadoc>
            <declaration name="decimalSeparator" type="String" line="438"/>
            <declaration name="nanString" type="String" line="439"/>
            <declaration name="infinityString" type="String" line="440"/>
            <declaration name="positivePrefix" type="String" line="441"/>
            <declaration name="negativePrefix" type="String" line="442"/>
            <declaration name="positiveSuffix" type="String" line="443"/>
            <declaration name="negativeSuffix" type="String" line="444"/>
            <declaration name="boolPattern" type="Pattern" line="446"/>
            <javadoc line="446">
                Fields and an accessor method to match booleans                
            </javadoc>
            <declaration name="BOOLEAN_PATTERN" type="String" line="450"/>
            <method name="boolPattern" type="Pattern" line="451">
                <declaration name="bp" type="Pattern" line="452"/>
            </method>
            <declaration name="integerPattern" type="Pattern" line="459"/>
            <javadoc line="459">
                Fields and methods to match bytes, shorts, ints, and longs                
            </javadoc>
            <declaration name="digits" type="String" line="463"/>
            <declaration name="non0Digit" type="String" line="464"/>
            <declaration name="SIMPLE_GROUP_INDEX" type="int" line="465"/>
            <method name="buildIntegerPatternString" type="String" line="466">
                <comment line="469">
                    \\p{javaDigit} is not guaranteed to be appropriate
                     here but what can we do? The final authority will be
                     whatever parse method is invoked, so ultimately the
                     Scanner will do the right thing                    
                </comment>
                <comment line="476">
                    digit++ is the possessive form which is necessary for reducing
                     backtracking that would otherwise cause unacceptable performance                    
                </comment>
                <declaration name="radixDigits" type="String" line="467"/>
                <declaration name="digit" type="String" line="472"/>
                <declaration name="groupedNumeral" type="String" line="473"/>
                <declaration name="numeral" type="String" line="477"/>
                <declaration name="javaStyleInteger" type="String" line="478"/>
                <declaration name="negativeInteger" type="String" line="479"/>
                <declaration name="positiveInteger" type="String" line="480"/>
            </method>
            <method name="integerPattern" type="Pattern" line="485">
                <scope line="486"/>
            </method>
            <declaration name="separatorPattern" type="Pattern" line="492"/>
            <javadoc line="492">
                Fields and an accessor method to match line separators                
            </javadoc>
            <declaration name="linePattern" type="Pattern" line="496"/>
            <declaration name="LINE_SEPARATOR_PATTERN" type="String" line="497"/>
            <declaration name="LINE_PATTERN" type="String" line="499"/>
            <method name="separatorPattern" type="Pattern" line="501">
                <declaration name="sp" type="Pattern" line="502"/>
            </method>
            <method name="linePattern" type="Pattern" line="508">
                <declaration name="lp" type="Pattern" line="509"/>
            </method>
            <declaration name="floatPattern" type="Pattern" line="515"/>
            <javadoc line="515">
                Fields and methods to match floats and doubles                
            </javadoc>
            <declaration name="decimalPattern" type="Pattern" line="519"/>
            <method name="buildFloatAndDecimalPattern" type="void" line="520">
                <comment line="522">
                    \\p{javaDigit} may not be perfect, see above                    
                </comment>
                <comment line="527">
                    Once again digit++ is used for performance, as above                    
                </comment>
                <declaration name="digit" type="String" line="522"/>
                <declaration name="exponent" type="String" line="523"/>
                <declaration name="groupedNumeral" type="String" line="524"/>
                <declaration name="numeral" type="String" line="527"/>
                <declaration name="decimalNumeral" type="String" line="528"/>
                <declaration name="nonNumber" type="String" line="531"/>
                <declaration name="positiveFloat" type="String" line="533"/>
                <declaration name="negativeFloat" type="String" line="535"/>
                <declaration name="decimal" type="String" line="537"/>
                <declaration name="hexFloat" type="String" line="539"/>
                <declaration name="positiveNonNumber" type="String" line="541"/>
                <declaration name="negativeNonNumber" type="String" line="543"/>
                <declaration name="signedNonNumber" type="String" line="545"/>
            </method>
            <method name="floatPattern" type="Pattern" line="552">
                <scope line="553"/>
            </method>
            <method name="decimalPattern" type="Pattern" line="558">
                <scope line="559"/>
            </method>
            <javadoc line="567">
                Constructs a &lt;code&gt;Scanner&lt;/code&gt; that returns values scanned
                  from the specified source delimited by the specified pattern.                
                <param>
                    source A character source implementing the Readable interface                    
                </param>
                <param>
                    pattern A delimiting pattern                    
                </param>
                <return>
                    A scanner with the specified source and pattern                    
                </return>
            </javadoc>
            <method name="Scanner" type="constructor" line="575">
                <params>
                    <param name="source" type="Readable"/>
                    <param name="pattern" type="Pattern"/>
                </params>
            </method>
            <javadoc line="588">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified source.                
                <param>
                    source A character source implementing the {@link Readable}interface                    
                </param>
            </javadoc>
            <method name="Scanner" type="constructor" line="595">
                <params>
                    <param name="source" type="Readable"/>
                </params>
            </method>
            <javadoc line="599">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified input stream. Bytes from the stream are converted
                  into characters using the underlying platform&apos;s{@linkplain java.nio.charset.Charset#defaultCharset() default charset}.                
                <param>
                    source An input stream to be scanned                    
                </param>
            </javadoc>
            <method name="Scanner" type="constructor" line="607">
                <params>
                    <param name="source" type="InputStream"/>
                </params>
            </method>
            <javadoc line="611">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified input stream. Bytes from the stream are converted
                  into characters using the specified charset.                
                <param>
                    source An input stream to be scanned                    
                </param>
                <param>
                    charsetName The encoding type used to convert bytes from the
                      stream into characters to be scanned                    
                </param>
                <throws>
                    IllegalArgumentException if the specified character set
                      does not exist                    
                </throws>
            </javadoc>
            <method name="Scanner" type="constructor" line="622">
                <params>
                    <param name="source" type="InputStream"/>
                    <param name="charsetName" type="String"/>
                </params>
            </method>
            <javadoc line="627">
                Returns a charset object for the given charset name.                
                <throws>
                    NullPointerException          is csn is null                    
                </throws>
                <throws>
                    IllegalArgumentException      if the charset is not supported                    
                </throws>
            </javadoc>
            <method name="toCharset" type="Charset" line="632">
                <params>
                    <param name="csn" type="String"/>
                </params>
                <comment line="638">
                    IllegalArgumentException should be thrown                    
                </comment>
                <scope line="634"/>
                <scope line="636"/>
            </method>
            <method name="makeReadable" type="Readable" line="642">
                <params>
                    <param name="source" type="InputStream"/>
                    <param name="charset" type="Charset"/>
                </params>
            </method>
            <javadoc line="646">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified file. Bytes from the file are converted into
                  characters using the underlying platform&apos;s{@linkplain java.nio.charset.Charset#defaultCharset() default charset}.                
                <param>
                    source A file to be scanned                    
                </param>
                <throws>
                    FileNotFoundException if source is not found                    
                </throws>
            </javadoc>
            <method name="Scanner" type="constructor" line="655">
                <params>
                    <param name="source" type="File"/>
                </params>
            </method>
            <javadoc line="659">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified file. Bytes from the file are converted into
                  characters using the specified charset.                
                <param>
                    source A file to be scanned                    
                </param>
                <param>
                    charsetName The encoding type used to convert bytes from the file
                      into characters to be scanned                    
                </param>
                <throws>
                    FileNotFoundException if source is not found                    
                </throws>
                <throws>
                    IllegalArgumentException if the specified encoding is
                      not found                    
                </throws>
            </javadoc>
            <method name="Scanner" type="constructor" line="673">
                <params>
                    <param name="source" type="File"/>
                    <param name="charsetName" type="String"/>
                </params>
            </method>
            <method name="Scanner" type="constructor" line="679">
                <params>
                    <param name="source" type="File"/>
                    <param name="dec" type="CharsetDecoder"/>
                </params>
            </method>
            <method name="toDecoder" type="CharsetDecoder" line="683">
                <params>
                    <param name="charsetName" type="String"/>
                </params>
                <scope line="685"/>
                <scope line="687"/>
            </method>
            <method name="makeReadable" type="Readable" line="693">
                <params>
                    <param name="source" type="ReadableByteChannel"/>
                    <param name="dec" type="CharsetDecoder"/>
                </params>
            </method>
            <javadoc line="697">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified file. Bytes from the file are converted into
                  characters using the underlying platform&apos;s{@linkplain java.nio.charset.Charset#defaultCharset() default charset}.                
                <param>
                    sourcethe path to the file to be scanned                    
                </param>
                <throws>
                    IOExceptionif an I/O error occurs opening source                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="Scanner" type="constructor" line="712">
                <params>
                    <param name="source" type="Path"/>
                </params>
            </method>
            <javadoc line="716">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified file. Bytes from the file are converted into
                  characters using the specified charset.                
                <param>
                    sourcethe path to the file to be scanned                    
                </param>
                <param>
                    charsetNameThe encoding type used to convert bytes from the file
                      into characters to be scanned                    
                </param>
                <throws>
                    IOExceptionif an I/O error occurs opening source                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif the specified encoding is not found                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="Scanner" type="constructor" line="732">
                <params>
                    <param name="source" type="Path"/>
                    <param name="charsetName" type="String"/>
                </params>
            </method>
            <method name="Scanner" type="constructor" line="736">
                <params>
                    <param name="source" type="Path"/>
                    <param name="charset" type="Charset"/>
                </params>
            </method>
            <javadoc line="740">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified string.                
                <param>
                    source A string to scan                    
                </param>
            </javadoc>
            <method name="Scanner" type="constructor" line="746">
                <params>
                    <param name="source" type="String"/>
                </params>
            </method>
            <javadoc line="750">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified channel. Bytes from the source are converted into
                  characters using the underlying platform&apos;s{@linkplain java.nio.charset.Charset#defaultCharset() default charset}.                
                <param>
                    source A channel to scan                    
                </param>
            </javadoc>
            <method name="Scanner" type="constructor" line="758">
                <params>
                    <param name="source" type="ReadableByteChannel"/>
                </params>
            </method>
            <method name="makeReadable" type="Readable" line="763">
                <params>
                    <param name="source" type="ReadableByteChannel"/>
                </params>
            </method>
            <javadoc line="767">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified channel. Bytes from the source are converted into
                  characters using the specified charset.                
                <param>
                    source A channel to scan                    
                </param>
                <param>
                    charsetName The encoding type used to convert bytes from the
                      channel into characters to be scanned                    
                </param>
                <throws>
                    IllegalArgumentException if the specified character set
                      does not exist                    
                </throws>
            </javadoc>
            <method name="Scanner" type="constructor" line="778">
                <params>
                    <param name="source" type="ReadableByteChannel"/>
                    <param name="charsetName" type="String"/>
                </params>
            </method>
            <method name="saveState" type="void" line="785"/>
            <method name="revertState" type="void" line="789"/>
            <method name="revertState" type="boolean" line="795">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <method name="cacheResult" type="void" line="802"/>
            <method name="cacheResult" type="void" line="808">
                <params>
                    <param name="result" type="String"/>
                </params>
            </method>
            <method name="clearCaches" type="void" line="815"/>
            <method name="getCachedResult" type="String" line="821"/>
            <method name="useTypeCache" type="void" line="829"/>
            <method name="readInput" type="void" line="838">
                <comment line="843">
                    Prepare to receive data                    
                </comment>
                <comment line="864">
                    Restore current position and limit for reading                    
                </comment>
                <declaration name="p" type="int" line="843"/>
                <declaration name="n" type="int" line="847"/>
                <scope line="848"/>
                <scope line="850"/>
                <scope line="855"/>
            </method>
            <method name="makeSpace" type="boolean" line="870">
                <comment line="876">
                    Gain space by compacting buffer                    
                </comment>
                <comment line="884">
                    Gain space by growing buffer                    
                </comment>
                <declaration name="offset" type="int" line="872"/>
                <scope line="876"/>
                <declaration name="newSize" type="int" line="884"/>
                <declaration name="newBuf" type="CharBuffer" line="885"/>
            </method>
            <method name="translateSavedIndexes" type="void" line="897">
                <params>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <method name="throwFor" type="void" line="904"/>
            <method name="hasTokenInBuffer" type="boolean" line="915">
                <comment line="921">
                    Skip delims first                    
                </comment>
                <comment line="925">
                    If we are sitting at the end, no more tokens in buffer                    
                </comment>
            </method>
            <method name="getCompleteTokenInBuffer" type="String" line="946">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <comment line="950">
                    Skip delims first                    
                </comment>
                <comment line="952">
                    Enforcing only one skip of leading delims                    
                </comment>
                <comment line="955">
                    If more input could extend the delimiters then we must wait
                     for more input                    
                </comment>
                <comment line="961">
                    The delims were whole and the matcher should skip them                    
                </comment>
                <comment line="967">
                    If we are sitting at the end, no more tokens in buffer                    
                </comment>
                <comment line="975">
                    Must look for next delims. Simply attempting to match the
                     pattern at this point may find a match but it might not be
                     the first longest match because of missing input, or it might
                     match a partial token instead of the whole thing.                    
                </comment>
                <comment line="980">
                    Then look for next delims                    
                </comment>
                <comment line="984">
                    Zero length delimiter match; we should find the next one
                     using the automatic advance past a zero length match;
                     Otherwise we have just found the same one we just skipped                    
                </comment>
                <comment line="990">
                    In the rare case that more input could cause the match
                     to be lost and there is more input coming we must wait
                     for more input. Note that hitting the end is okay as long
                     as the match cannot go away. It is the beginning of the
                     next delims we want to be sure about, we don&apos;t care if
                     they potentially extend further.                    
                </comment>
                <comment line="1001">
                    There is a complete token.                    
                </comment>
                <comment line="1003">
                    Must continue with match to provide valid MatchResult                    
                </comment>
                <comment line="1006">
                    Attempt to match against the desired pattern                    
                </comment>
                <comment line="1013">
                    Complete token but it does not match                    
                </comment>
                <comment line="1018">
                    If we can&apos;t find the next delims but no more input is coming,
                     then we can treat the remainder as a whole token                    
                </comment>
                <comment line="1022">
                    Must continue with match to provide valid MatchResult                    
                </comment>
                <comment line="1025">
                    Last token; Match the pattern here or throw                    
                </comment>
                <comment line="1033">
                    Last piece does not match                    
                </comment>
                <comment line="1037">
                    There is a partial token in the buffer; must read more
                     to complete it                    
                </comment>
                <scope line="951">
                    <scope line="953">
                        <scope line="956"/>
                    </scope>
                </scope>
                <scope line="967"/>
                <declaration name="foundNextDelim" type="boolean" line="981"/>
                <scope line="982"/>
                <scope line="988">
                    <scope line="995"/>
                    <declaration name="tokenEnd" type="int" line="999"/>
                    <scope line="1001"/>
                    <scope line="1008">
                        <declaration name="s" type="String" line="1009"/>
                    </scope>
                    <scope line="1012"/>
                </scope>
                <scope line="1019">
                    <scope line="1020"/>
                    <scope line="1027">
                        <declaration name="s" type="String" line="1028"/>
                    </scope>
                </scope>
            </method>
            <method name="findPatternInBuffer" type="String" line="1044">
                <params>
                    <param name="pattern" type="Pattern"/>
                    <param name="horizon" type="int"/>
                </params>
                <comment line="1059">
                    The match may be longer if didn&apos;t hit horizon or real end                    
                </comment>
                <comment line="1061">
                    Hit an artificial end; try to extend the match                    
                </comment>
                <comment line="1065">
                    The match could go away depending on what is next                    
                </comment>
                <comment line="1067">
                    Rare case: we hit the end of input and it happens
                     that it is at the horizon and the end of input is
                     required for the match.                    
                </comment>
                <comment line="1074">
                    Did not hit end, or hit real end, or hit horizon                    
                </comment>
                <comment line="1082">
                    If there is no specified horizon, or if we have not searched
                     to the specified horizon yet, get more input                    
                </comment>
                <declaration name="bufferLimit" type="int" line="1047"/>
                <declaration name="horizonLimit" type="int" line="1048"/>
                <declaration name="searchLimit" type="int" line="1049"/>
                <scope line="1050"/>
                <scope line="1056">
                    <scope line="1057">
                        <scope line="1059"/>
                        <scope line="1065"/>
                    </scope>
                </scope>
            </method>
            <method name="matchPatternInBuffer" type="String" line="1090">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <comment line="1097">
                    Get more input and try again                    
                </comment>
                <comment line="1108">
                    Read more to find pattern                    
                </comment>
                <scope line="1094">
                    <scope line="1095"/>
                </scope>
            </method>
            <method name="ensureOpen" type="void" line="1113"/>
            <javadoc line="1120">
                Closes this scanner.
                  &lt;p&gt; If this scanner has not yet been closed then if its underlying{@linkplain java.lang.Readable readable} also implements the {@link java.io.Closeable} interface then the readable&apos;s &lt;tt&gt;close&lt;/tt&gt; method
                  will be invoked.  If this scanner is already closed then invoking this
                  method will have no effect.
                  &lt;p&gt;Attempting to perform search operations after a scanner has
                  been closed will result in an {@link IllegalStateException}.                
            </javadoc>
            <method name="close" type="void" line="1133">
                <scope line="1136">
                    <scope line="1137"/>
                    <scope line="1139"/>
                </scope>
            </method>
            <javadoc line="1148">
                Returns the &lt;code&gt;IOException&lt;/code&gt; last thrown by this
                  &lt;code&gt;Scanner&lt;/code&gt;&apos;s underlying &lt;code&gt;Readable&lt;/code&gt;. This method
                  returns &lt;code&gt;null&lt;/code&gt; if no such exception exists.                
                <return>
                    the last exception thrown by this scanner's readable                    
                </return>
            </javadoc>
            <method name="ioException" type="IOException" line="1155"/>
            <javadoc line="1159">
                Returns the &lt;code&gt;Pattern&lt;/code&gt; this &lt;code&gt;Scanner&lt;/code&gt; is currently
                  using to match delimiters.                
                <return>
                    this scanner's delimiting pattern.                    
                </return>
            </javadoc>
            <method name="delimiter" type="Pattern" line="1165"/>
            <javadoc line="1169">
                Sets this scanner&apos;s delimiting pattern to the specified pattern.                
                <param>
                    pattern A delimiting pattern                    
                </param>
                <return>
                    this scanner                    
                </return>
            </javadoc>
            <method name="useDelimiter" type="Scanner" line="1175">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
            </method>
            <javadoc line="1180">
                Sets this scanner&apos;s delimiting pattern to a pattern constructed from
                  the specified &lt;code&gt;String&lt;/code&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;useDelimiter(pattern)&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;useDelimiter(Pattern.compile(pattern))&lt;/tt&gt;.
                  &lt;p&gt; Invoking the {@link #reset} method will set the scanner&apos;s delimiter
                  to the &lt;a href= &quot;#default-delimiter&quot;&gt;default&lt;/a&gt;.                
                <param>
                    pattern A string specifying a delimiting pattern                    
                </param>
                <return>
                    this scanner                    
                </return>
            </javadoc>
            <method name="useDelimiter" type="Scanner" line="1194">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1199">
                Returns this scanner&apos;s locale.
                  &lt;p&gt;A scanner&apos;s locale affects many elements of its default
                  primitive matching regular expressions; see
                  &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.                
                <return>
                    this scanner's locale                    
                </return>
            </javadoc>
            <method name="locale" type="Locale" line="1208"/>
            <javadoc line="1212">
                Sets this scanner&apos;s locale to the specified locale.
                  &lt;p&gt;A scanner&apos;s locale affects many elements of its default
                  primitive matching regular expressions; see
                  &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.
                  &lt;p&gt;Invoking the {@link #reset} method will set the scanner&apos;s locale to
                  the &lt;a href= &quot;#initial-locale&quot;&gt;initial locale&lt;/a&gt;.                
                <param>
                    locale A string specifying the locale to use                    
                </param>
                <return>
                    this scanner                    
                </return>
            </javadoc>
            <method name="useLocale" type="Scanner" line="1225">
                <params>
                    <param name="locale" type="Locale"/>
                </params>
                <comment line="1235">
                    These must be literalized to avoid collision with regex
                     metacharacters such as dot or parenthesis                    
                </comment>
                <comment line="1240">
                    Quoting the nonzero length locale-specific things
                     to avoid potential conflict with metacharacters                    
                </comment>
                <comment line="1257">
                    Force rebuilding and recompilation of locale dependent
                     primitive patterns                    
                </comment>
                <declaration name="df" type="DecimalFormat" line="1230"/>
                <declaration name="dfs" type="DecimalFormatSymbols" line="1232"/>
            </method>
            <javadoc line="1264">
                Returns this scanner&apos;s default radix.
                  &lt;p&gt;A scanner&apos;s radix affects elements of its default
                  number matching regular expressions; see
                  &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.                
                <return>
                    the default radix of this scanner                    
                </return>
            </javadoc>
            <method name="radix" type="int" line="1273"/>
            <javadoc line="1277">
                Sets this scanner&apos;s default radix to the specified radix.
                  &lt;p&gt;A scanner&apos;s radix affects elements of its default
                  number matching regular expressions; see
                  &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.
                  &lt;p&gt;If the radix is less than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt;
                  or greater than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then an
                  &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
                  &lt;p&gt;Invoking the {@link #reset} method will set the scanner&apos;s radix to
                  &lt;code&gt;10&lt;/code&gt;.                
                <param>
                    radix The radix to use when scanning numbers                    
                </param>
                <return>
                    this scanner                    
                </return>
                <throws>
                    IllegalArgumentException if radix is out of range                    
                </throws>
            </javadoc>
            <method name="useRadix" type="Scanner" line="1295">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="1303">
                    Force rebuilding and recompilation of radix dependent patterns                    
                </comment>
            </method>
            <method name="setRadix" type="void" line="1309">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="1312">
                    Force rebuilding and recompilation of radix dependent patterns                    
                </comment>
                <scope line="1310"/>
            </method>
            <javadoc line="1317">
                Returns the match result of the last scanning operation performed
                  by this scanner. This method throws &lt;code&gt;IllegalStateException&lt;/code&gt;
                  if no match has been performed, or if the last match was
                  not successful.
                  &lt;p&gt;The various &lt;code&gt;next&lt;/code&gt;methods of &lt;code&gt;Scanner&lt;/code&gt;
                  make a match result available if they complete without throwing an
                  exception. For instance, after an invocation of the {@link #nextInt}method that returned an int, this method returns a
                  &lt;code&gt;MatchResult&lt;/code&gt; for the search of the
                  &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression
                  defined above. Similarly the {@link #findInLine},{@link #findWithinHorizon}, and {@link #skip} methods will make a
                  match available if they succeed.                
                <return>
                    a match result for the last match operation                    
                </return>
                <throws>
                    IllegalStateException  If no match result is available                    
                </throws>
            </javadoc>
            <method name="match" type="MatchResult" line="1336"/>
            <javadoc line="1342">
                &lt;p&gt;Returns the string representation of this &lt;code&gt;Scanner&lt;/code&gt;. The
                  string representation of a &lt;code&gt;Scanner&lt;/code&gt; contains information
                  that may be useful for debugging. The exact format is unspecified.                
                <return>
                    The string representation of this scanner                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1349">
                <declaration name="sb" type="StringBuilder" line="1350"/>
            </method>
            <javadoc line="1369">
                Returns true if this scanner has another token in its input.
                  This method may block while waiting for input to scan.
                  The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner has another token                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
                <see>
                    java.util.Iterator                    
                </see>
            </javadoc>
            <method name="hasNext" type="boolean" line="1378">
                <scope line="1381"/>
                <declaration name="result" type="boolean" line="1386"/>
            </method>
            <javadoc line="1390">
                Finds and returns the next complete token from this scanner.
                  A complete token is preceded and followed by input that matches
                  the delimiter pattern. This method may block while waiting for input
                  to scan, even if a previous invocation of {@link #hasNext} returned
                  &lt;code&gt;true&lt;/code&gt;.                
                <return>
                    the next token                    
                </return>
                <throws>
                    NoSuchElementException if no more tokens are available                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
                <see>
                    java.util.Iterator                    
                </see>
            </javadoc>
            <method name="next" type="String" line="1402">
                <scope line="1406">
                    <declaration name="token" type="String" line="1407"/>
                    <scope line="1408"/>
                </scope>
            </method>
            <javadoc line="1420">
                The remove operation is not supported by this implementation of
                  &lt;code&gt;Iterator&lt;/code&gt;.                
                <throws>
                    UnsupportedOperationException if this method is invoked.                    
                </throws>
                <see>
                    java.util.Iterator                    
                </see>
            </javadoc>
            <method name="remove" type="void" line="1427"/>
            <javadoc line="1431">
                Returns true if the next token matches the pattern constructed from the
                  specified string. The scanner does not advance past any input.
                  &lt;p&gt; An invocation of this method of the form &lt;tt&gt;hasNext(pattern)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;tt&gt;hasNext(Pattern.compile(pattern))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to scan                    
                </param>
                <return>
                    true if and only if this scanner has another token matching
                      the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNext" type="boolean" line="1444">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1448">
                Returns the next token if it matches the pattern constructed from the
                  specified string.  If the match is successful, the scanner advances
                  past the input that matched the pattern.
                  &lt;p&gt; An invocation of this method of the form &lt;tt&gt;next(pattern)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;tt&gt;next(Pattern.compile(pattern))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to scan                    
                </param>
                <return>
                    the next token                    
                </return>
                <throws>
                    NoSuchElementException if no such tokens are available                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="next" type="String" line="1462">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1466">
                Returns true if the next complete token matches the specified pattern.
                  A complete token is prefixed and postfixed by input that matches
                  the delimiter pattern. This method may block while waiting for input.
                  The scanner does not advance past any input.                
                <param>
                    pattern the pattern to scan for                    
                </param>
                <return>
                    true if and only if this scanner has another token matching
                      the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNext" type="boolean" line="1477">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <scope line="1484">
                    <scope line="1485"/>
                </scope>
            </method>
            <javadoc line="1497">
                Returns the next token if it matches the specified pattern. This
                  method may block while waiting for input to scan, even if a previous
                  invocation of {@link #hasNext(Pattern)} returned &lt;code&gt;true&lt;/code&gt;.
                  If the match is successful, the scanner advances past the input that
                  matched the pattern.                
                <param>
                    pattern the pattern to scan for                    
                </param>
                <return>
                    the next token                    
                </return>
                <throws>
                    NoSuchElementException if no more tokens are available                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="next" type="String" line="1509">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <comment line="1515">
                    Did we already find this pattern?                    
                </comment>
                <comment line="1520">
                    Search for the pattern                    
                </comment>
                <scope line="1520">
                    <declaration name="token" type="String" line="1521"/>
                    <scope line="1522"/>
                </scope>
            </method>
            <javadoc line="1534">
                Returns true if there is another line in the input of this scanner.
                  This method may block while waiting for input. The scanner does not
                  advance past any input.                
                <return>
                    true if and only if this scanner has another line of input                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextLine" type="boolean" line="1542">
                <declaration name="result" type="String" line="1545"/>
                <scope line="1546">
                    <declaration name="mr" type="MatchResult" line="1547"/>
                    <declaration name="lineSep" type="String" line="1548"/>
                    <scope line="1549"/>
                    <scope line="1554"/>
                </scope>
            </method>
            <javadoc line="1562">
                Advances this scanner past the current line and returns the input
                  that was skipped.
                  This method returns the rest of the current line, excluding any line
                  separator at the end. The position is set to the beginning of the next
                  line.
                  &lt;p&gt;Since this method continues to search through the input looking
                  for a line separator, it may buffer all of the input searching for
                  the line to skip if no line separators are present.                
                <return>
                    the line that was skipped                    
                </return>
                <throws>
                    NoSuchElementException if no line was found                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextLine" type="String" line="1578">
                <declaration name="result" type="String" line="1583"/>
                <declaration name="mr" type="MatchResult" line="1586"/>
                <declaration name="lineSep" type="String" line="1587"/>
            </method>
            <javadoc line="1598">
                Attempts to find the next occurrence of a pattern constructed from the
                  specified string, ignoring delimiters.
                  &lt;p&gt;An invocation of this method of the form &lt;tt&gt;findInLine(pattern)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;tt&gt;findInLine(Pattern.compile(pattern))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to search for                    
                </param>
                <return>
                    the text that matched the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="findInLine" type="String" line="1610">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1614">
                Attempts to find the next occurrence of the specified pattern ignoring
                  delimiters. If the pattern is found before the next line separator, the
                  scanner advances past the input that matched and returns the string that
                  matched the pattern.
                  If no such pattern is detected in the input up to the next line
                  separator, then &lt;code&gt;null&lt;/code&gt; is returned and the scanner&apos;s
                  position is unchanged. This method may block waiting for input that
                  matches the pattern.
                  &lt;p&gt;Since this method continues to search through the input looking
                  for the specified pattern, it may buffer all of the input searching for
                  the desired token if no line separators are present.                
                <param>
                    pattern the pattern to scan for                    
                </param>
                <return>
                    the text that matched the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="findInLine" type="String" line="1632">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <comment line="1638">
                    Expand buffer to include the next newline or end of input                    
                </comment>
                <comment line="1645">
                    up to next newline                    
                </comment>
                <comment line="1651">
                    up to end of input                    
                </comment>
                <comment line="1656">
                    If there is nothing between the current pos and the next
                     newline simply return null, invoking findWithinHorizon
                     with &quot;horizon=0&quot; will scan beyond the line bound.                    
                </comment>
                <comment line="1661">
                    Search for the pattern                    
                </comment>
                <declaration name="endPosition" type="int" line="1638"/>
                <scope line="1640">
                    <declaration name="token" type="String" line="1641"/>
                    <scope line="1642"/>
                    <scope line="1646"/>
                    <scope line="1648"/>
                </scope>
                <declaration name="horizonForLine" type="int" line="1654"/>
            </method>
            <javadoc line="1664">
                Attempts to find the next occurrence of a pattern constructed from the
                  specified string, ignoring delimiters.
                  &lt;p&gt;An invocation of this method of the form
                  &lt;tt&gt;findWithinHorizon(pattern)&lt;/tt&gt; behaves in exactly the same way as
                  the invocation
                  &lt;tt&gt;findWithinHorizon(Pattern.compile(pattern, horizon))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to search for                    
                </param>
                <return>
                    the text that matched the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
                <throws>
                    IllegalArgumentException if horizon is negative                    
                </throws>
            </javadoc>
            <method name="findWithinHorizon" type="String" line="1678">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="horizon" type="int"/>
                </params>
            </method>
            <javadoc line="1682">
                Attempts to find the next occurrence of the specified pattern.
                  &lt;p&gt;This method searches through the input up to the specified
                  search horizon, ignoring delimiters. If the pattern is found the
                  scanner advances past the input that matched and returns the string
                  that matched the pattern. If no such pattern is detected then the
                  null is returned and the scanner&apos;s position remains unchanged. This
                  method may block waiting for input that matches the pattern.
                  &lt;p&gt;A scanner will never search more than &lt;code&gt;horizon&lt;/code&gt; code
                  points beyond its current position. Note that a match may be clipped
                  by the horizon; that is, an arbitrary match result may have been
                  different if the horizon had been larger. The scanner treats the
                  horizon as a transparent, non-anchoring bound (see {@link Matcher#useTransparentBounds} and {@link Matcher#useAnchoringBounds}).
                  &lt;p&gt;If horizon is &lt;code&gt;0&lt;/code&gt;, then the horizon is ignored and
                  this method continues to search through the input looking for the
                  specified pattern without bound. In this case it may buffer all of
                  the input searching for the pattern.
                  &lt;p&gt;If horizon is negative, then an IllegalArgumentException is
                  thrown.                
                <param>
                    pattern the pattern to scan for                    
                </param>
                <return>
                    the text that matched the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
                <throws>
                    IllegalArgumentException if horizon is negative                    
                </throws>
            </javadoc>
            <method name="findWithinHorizon" type="String" line="1712">
                <params>
                    <param name="pattern" type="Pattern"/>
                    <param name="horizon" type="int"/>
                </params>
                <comment line="1721">
                    Search for the pattern                    
                </comment>
                <comment line="1731">
                    up to end of input                    
                </comment>
                <scope line="1721">
                    <declaration name="token" type="String" line="1722"/>
                    <scope line="1723"/>
                </scope>
            </method>
            <javadoc line="1735">
                Skips input that matches the specified pattern, ignoring delimiters.
                  This method will skip input if an anchored match of the specified
                  pattern succeeds.
                  &lt;p&gt;If a match to the specified pattern is not found at the
                  current position, then no input is skipped and a
                  &lt;tt&gt;NoSuchElementException&lt;/tt&gt; is thrown.
                  &lt;p&gt;Since this method seeks to match the specified pattern starting at
                  the scanner&apos;s current position, patterns that can match a lot of
                  input (&quot;.&quot;, for example) may cause the scanner to buffer a large
                  amount of input.
                  &lt;p&gt;Note that it is possible to skip something without risking a
                  &lt;code&gt;NoSuchElementException&lt;/code&gt; by using a pattern that can
                  match nothing, e.g., &lt;code&gt;sc.skip(&quot;[ \t]&quot;)&lt;/code&gt;.                
                <param>
                    pattern a string specifying the pattern to skip over                    
                </param>
                <return>
                    this scanner                    
                </return>
                <throws>
                    NoSuchElementException if the specified pattern is not found                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="skip" type="Scanner" line="1758">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <comment line="1765">
                    Search for the pattern                    
                </comment>
                <scope line="1765">
                    <declaration name="token" type="String" line="1766"/>
                    <scope line="1767"/>
                </scope>
            </method>
            <javadoc line="1779">
                Skips input that matches a pattern constructed from the specified
                  string.
                  &lt;p&gt; An invocation of this method of the form &lt;tt&gt;skip(pattern)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;tt&gt;skip(Pattern.compile(pattern))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to skip over                    
                </param>
                <return>
                    this scanner                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="skip" type="Scanner" line="1791">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1797">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a boolean value using a case insensitive pattern
                  created from the string &quot;true|false&quot;.  The scanner does not
                  advance past the input that matched.                
                <return>
                    true if and only if this scanner's next token is a valid
                      boolean value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextBoolean" type="boolean" line="1807"/>
            <javadoc line="1811">
                Scans the next token of the input into a boolean value and returns
                  that value. This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid boolean value.
                  If the match is successful, the scanner advances past the input that
                  matched.                
                <return>
                    the boolean scanned from the input                    
                </return>
                <throws>
                    InputMismatchException if the next token is not a valid boolean                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextBoolean" type="boolean" line="1823"/>
            <javadoc line="1828">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a byte value in the default radix using the{@link #nextByte} method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      byte value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextByte" type="boolean" line="1837"/>
            <javadoc line="1841">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a byte value in the specified radix using the{@link #nextByte} method. The scanner does not advance past any input.                
                <param>
                    radix the radix used to interpret the token as a byte value                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      byte value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextByte" type="boolean" line="1851">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="1855">
                    Cache it                    
                </comment>
                <declaration name="result" type="boolean" line="1853"/>
                <scope line="1854">
                    <scope line="1855">
                        <declaration name="s" type="String" line="1856"/>
                    </scope>
                    <scope line="1860"/>
                </scope>
            </method>
            <javadoc line="1867">
                Scans the next token of the input as a &lt;tt&gt;byte&lt;/tt&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextByte()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextByte(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>byte</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextByte" type="byte" line="1882"/>
            <javadoc line="1886">
                Scans the next token of the input as a &lt;tt&gt;byte&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid byte value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;byte&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Byte#parseByte(String,int) Byte.parseByte} with the
                  specified radix.                
                <param>
                    radix the radix used to interpret the token as a byte value                    
                </param>
                <return>
                    the <tt>byte</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextByte" type="byte" line="1912">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="1914">
                    Check cached result                    
                </comment>
                <comment line="1923">
                    Search for next byte                    
                </comment>
                <comment line="1930">
                    don&apos;t skip bad token                    
                </comment>
                <scope line="1915">
                    <declaration name="val" type="byte" line="1916"/>
                </scope>
                <scope line="1923">
                    <declaration name="s" type="String" line="1924"/>
                </scope>
                <scope line="1928"/>
            </method>
            <javadoc line="1934">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a short value in the default radix using the{@link #nextShort} method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      short value in the default radix                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextShort" type="boolean" line="1943"/>
            <javadoc line="1947">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a short value in the specified radix using the{@link #nextShort} method. The scanner does not advance past any input.                
                <param>
                    radix the radix used to interpret the token as a short value                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      short value in the specified radix                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextShort" type="boolean" line="1957">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="1961">
                    Cache it                    
                </comment>
                <declaration name="result" type="boolean" line="1959"/>
                <scope line="1960">
                    <scope line="1961">
                        <declaration name="s" type="String" line="1962"/>
                    </scope>
                    <scope line="1966"/>
                </scope>
            </method>
            <javadoc line="1973">
                Scans the next token of the input as a &lt;tt&gt;short&lt;/tt&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextShort()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextShort(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>short</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextShort" type="short" line="1988"/>
            <javadoc line="1992">
                Scans the next token of the input as a &lt;tt&gt;short&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid short value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;short&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Short#parseShort(String,int) Short.parseShort} with the
                  specified radix.                
                <param>
                    radix the radix used to interpret the token as a short value                    
                </param>
                <return>
                    the <tt>short</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextShort" type="short" line="2018">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="2020">
                    Check cached result                    
                </comment>
                <comment line="2029">
                    Search for next short                    
                </comment>
                <comment line="2036">
                    don&apos;t skip bad token                    
                </comment>
                <scope line="2021">
                    <declaration name="val" type="short" line="2022"/>
                </scope>
                <scope line="2029">
                    <declaration name="s" type="String" line="2030"/>
                </scope>
                <scope line="2034"/>
            </method>
            <javadoc line="2040">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as an int value in the default radix using the{@link #nextInt} method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      int value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextInt" type="boolean" line="2049"/>
            <javadoc line="2053">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as an int value in the specified radix using the{@link #nextInt} method. The scanner does not advance past any input.                
                <param>
                    radix the radix used to interpret the token as an int value                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      int value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextInt" type="boolean" line="2063">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="2067">
                    Cache it                    
                </comment>
                <declaration name="result" type="boolean" line="2065"/>
                <scope line="2066">
                    <scope line="2067">
                        <declaration name="s" type="String" line="2068"/>
                    </scope>
                    <scope line="2072"/>
                </scope>
            </method>
            <javadoc line="2079">
                The integer token must be stripped of prefixes, group separators,
                  and suffixes, non ascii digits must be converted into ascii digits
                  before parse will accept it.                
            </javadoc>
            <method name="processIntegerToken" type="String" line="2084">
                <params>
                    <param name="token" type="String"/>
                </params>
                <declaration name="result" type="String" line="2085"/>
                <declaration name="isNegative" type="boolean" line="2086"/>
                <declaration name="preLen" type="int" line="2087"/>
                <scope line="2088"/>
                <declaration name="sufLen" type="int" line="2092"/>
                <scope line="2093"/>
            </method>
            <javadoc line="2103">
                Scans the next token of the input as an &lt;tt&gt;int&lt;/tt&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextInt()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextInt(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>int</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextInt" type="int" line="2118"/>
            <javadoc line="2122">
                Scans the next token of the input as an &lt;tt&gt;int&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid int value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into an &lt;tt&gt;int&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Integer#parseInt(String,int) Integer.parseInt} with the
                  specified radix.                
                <param>
                    radix the radix used to interpret the token as an int value                    
                </param>
                <return>
                    the <tt>int</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextInt" type="int" line="2148">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="2150">
                    Check cached result                    
                </comment>
                <comment line="2159">
                    Search for next int                    
                </comment>
                <comment line="2166">
                    don&apos;t skip bad token                    
                </comment>
                <scope line="2151">
                    <declaration name="val" type="int" line="2152"/>
                </scope>
                <scope line="2159">
                    <declaration name="s" type="String" line="2160"/>
                </scope>
                <scope line="2164"/>
            </method>
            <javadoc line="2170">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a long value in the default radix using the{@link #nextLong} method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      long value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextLong" type="boolean" line="2179"/>
            <javadoc line="2183">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a long value in the specified radix using the{@link #nextLong} method. The scanner does not advance past any input.                
                <param>
                    radix the radix used to interpret the token as a long value                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      long value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextLong" type="boolean" line="2193">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="2197">
                    Cache it                    
                </comment>
                <declaration name="result" type="boolean" line="2195"/>
                <scope line="2196">
                    <scope line="2197">
                        <declaration name="s" type="String" line="2198"/>
                    </scope>
                    <scope line="2202"/>
                </scope>
            </method>
            <javadoc line="2209">
                Scans the next token of the input as a &lt;tt&gt;long&lt;/tt&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextLong()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextLong(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>long</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextLong" type="long" line="2224"/>
            <javadoc line="2228">
                Scans the next token of the input as a &lt;tt&gt;long&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid long value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;long&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Long#parseLong(String,int) Long.parseLong} with the
                  specified radix.                
                <param>
                    radix the radix used to interpret the token as an int value                    
                </param>
                <return>
                    the <tt>long</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextLong" type="long" line="2254">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="2256">
                    Check cached result                    
                </comment>
                <comment line="2271">
                    don&apos;t skip bad token                    
                </comment>
                <scope line="2257">
                    <declaration name="val" type="long" line="2258"/>
                </scope>
                <scope line="2264">
                    <declaration name="s" type="String" line="2265"/>
                </scope>
                <scope line="2269"/>
            </method>
            <javadoc line="2275">
                The float token must be stripped of prefixes, group separators,
                  and suffixes, non ascii digits must be converted into ascii digits
                  before parseFloat will accept it.
                  If there are non-ascii digits in the token these digits must
                  be processed before the token is passed to parseFloat.                
            </javadoc>
            <method name="processFloatToken" type="String" line="2283">
                <params>
                    <param name="token" type="String"/>
                </params>
                <comment line="2307">
                    Translate non-ASCII digits                    
                </comment>
                <declaration name="result" type="String" line="2284"/>
                <declaration name="isNegative" type="boolean" line="2287"/>
                <declaration name="preLen" type="int" line="2288"/>
                <scope line="2289"/>
                <declaration name="sufLen" type="int" line="2293"/>
                <scope line="2294"/>
                <declaration name="m" type="Matcher" line="2307"/>
                <scope line="2308">
                    <declaration name="inASCII" type="StringBuilder" line="2309"/>
                    <scope line="2310">
                        <declaration name="nextChar" type="char" line="2311"/>
                        <scope line="2312">
                            <declaration name="d" type="int" line="2313"/>
                        </scope>
                        <scope line="2318"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2328">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a float value using the {@link #nextFloat}method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      float value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextFloat" type="boolean" line="2337">
                <comment line="2341">
                    Cache it                    
                </comment>
                <declaration name="result" type="boolean" line="2339"/>
                <scope line="2340">
                    <scope line="2341">
                        <declaration name="s" type="String" line="2342"/>
                    </scope>
                    <scope line="2344"/>
                </scope>
            </method>
            <javadoc line="2351">
                Scans the next token of the input as a &lt;tt&gt;float&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid float value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above
                  then the token is converted into a &lt;tt&gt;float&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Float#parseFloat Float.parseFloat}. If the token matches
                  the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot;
                  is passed to {@link Float#parseFloat(String) Float.parseFloat} as
                  appropriate.                
                <return>
                    the <tt>float</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Float</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextFloat" type="float" line="2378">
                <comment line="2380">
                    Check cached result                    
                </comment>
                <comment line="2391">
                    don&apos;t skip bad token                    
                </comment>
                <scope line="2380">
                    <declaration name="val" type="float" line="2381"/>
                </scope>
                <scope line="2387"/>
                <scope line="2389"/>
            </method>
            <javadoc line="2395">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a double value using the {@link #nextDouble}method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      double value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextDouble" type="boolean" line="2404">
                <comment line="2408">
                    Cache it                    
                </comment>
                <declaration name="result" type="boolean" line="2406"/>
                <scope line="2407">
                    <scope line="2408">
                        <declaration name="s" type="String" line="2409"/>
                    </scope>
                    <scope line="2411"/>
                </scope>
            </method>
            <javadoc line="2418">
                Scans the next token of the input as a &lt;tt&gt;double&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid double value.
                  If the translation is successful, the scanner advances past the input
                  that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above
                  then the token is converted into a &lt;tt&gt;double&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Double#parseDouble Double.parseDouble}. If the token matches
                  the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot;
                  is passed to {@link Double#parseDouble(String) Double.parseDouble} as
                  appropriate.                
                <return>
                    the <tt>double</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Float</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if the input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextDouble" type="double" line="2445">
                <comment line="2447">
                    Check cached result                    
                </comment>
                <comment line="2455">
                    Search for next float                    
                </comment>
                <comment line="2459">
                    don&apos;t skip bad token                    
                </comment>
                <scope line="2447">
                    <declaration name="val" type="double" line="2448"/>
                </scope>
                <scope line="2455"/>
                <scope line="2457"/>
            </method>
            <javadoc line="2465">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a &lt;code&gt;BigInteger&lt;/code&gt; in the default radix using the{@link #nextBigInteger} method. The scanner does not advance past any
                  input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      <code>BigInteger</code>                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextBigInteger" type="boolean" line="2475"/>
            <javadoc line="2479">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a &lt;code&gt;BigInteger&lt;/code&gt; in the specified radix using
                  the {@link #nextBigInteger} method. The scanner does not advance past
                  any input.                
                <param>
                    radix the radix used to interpret the token as an integer                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      <code>BigInteger</code>                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextBigInteger" type="boolean" line="2490">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="2494">
                    Cache it                    
                </comment>
                <declaration name="result" type="boolean" line="2492"/>
                <scope line="2493">
                    <scope line="2494">
                        <declaration name="s" type="String" line="2495"/>
                    </scope>
                    <scope line="2499"/>
                </scope>
            </method>
            <javadoc line="2506">
                Scans the next token of the input as a {@link java.math.BigIntegerBigInteger}.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextBigInteger()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextBigInteger(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>BigInteger</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if the input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextBigInteger" type="BigInteger" line="2522"/>
            <javadoc line="2526">
                Scans the next token of the input as a {@link java.math.BigIntegerBigInteger}.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;BigInteger&lt;/tt&gt; value as if
                  by removing all group separators, mapping non-ASCII digits into ASCII
                  digits via the {@link Character#digit Character.digit}, and passing the
                  resulting string to the {@link java.math.BigInteger#BigInteger(java.lang.String)BigInteger(String, int)} constructor with the specified radix.                
                <param>
                    radix the radix used to interpret the token                    
                </param>
                <return>
                    the <tt>BigInteger</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if the input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextBigInteger" type="BigInteger" line="2547">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="2549">
                    Check cached result                    
                </comment>
                <comment line="2558">
                    Search for next int                    
                </comment>
                <comment line="2565">
                    don&apos;t skip bad token                    
                </comment>
                <scope line="2550">
                    <declaration name="val" type="BigInteger" line="2551"/>
                </scope>
                <scope line="2558">
                    <declaration name="s" type="String" line="2559"/>
                </scope>
                <scope line="2563"/>
            </method>
            <javadoc line="2569">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a &lt;code&gt;BigDecimal&lt;/code&gt; using the{@link #nextBigDecimal} method. The scanner does not advance past any
                  input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      <code>BigDecimal</code>                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextBigDecimal" type="boolean" line="2579">
                <comment line="2583">
                    Cache it                    
                </comment>
                <declaration name="result" type="boolean" line="2581"/>
                <scope line="2582">
                    <scope line="2583">
                        <declaration name="s" type="String" line="2584"/>
                    </scope>
                    <scope line="2586"/>
                </scope>
            </method>
            <javadoc line="2593">
                Scans the next token of the input as a {@link java.math.BigDecimalBigDecimal}.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;BigDecimal&lt;/tt&gt; value as if
                  by removing all group separators, mapping non-ASCII digits into ASCII
                  digits via the {@link Character#digit Character.digit}, and passing the
                  resulting string to the {@link java.math.BigDecimal#BigDecimal(java.lang.String) BigDecimal(String)}constructor.                
                <return>
                    the <tt>BigDecimal</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Decimal</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if the input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextBigDecimal" type="BigDecimal" line="2613">
                <comment line="2615">
                    Check cached result                    
                </comment>
                <comment line="2623">
                    Search for next float                    
                </comment>
                <comment line="2628">
                    don&apos;t skip bad token                    
                </comment>
                <scope line="2615">
                    <declaration name="val" type="BigDecimal" line="2616"/>
                </scope>
                <scope line="2623">
                    <declaration name="s" type="String" line="2624"/>
                </scope>
                <scope line="2626"/>
            </method>
            <javadoc line="2632">
                Resets this scanner.
                  &lt;p&gt; Resetting a scanner discards all of its explicit state
                  information which may have been changed by invocations of {@link #useDelimiter}, {@link #useLocale}, or {@link #useRadix}.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;scanner.reset()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation
                  &lt;blockquote&gt;&lt;pre&gt;
                  scanner.useDelimiter(&quot;\\p{javaWhitespace}+&quot;)
                  .useLocale(Locale.getDefault())
                  .useRadix(10);
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <return>
                    this scanner                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="reset" type="Scanner" line="2653"/>
        </class>
    </source>