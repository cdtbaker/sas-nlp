<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <import package="java.nio.file.Path"/>
        <import package="java.nio.file.Files"/>
        <import package="java.util.regex"/>
        <import package="java.io"/>
        <import package="java.math"/>
        <import package="java.nio"/>
        <import package="java.nio.channels"/>
        <import package="java.nio.charset"/>
        <import package="java.text"/>
        <import package="java.util.Locale"/>
        <import package="sun.misc.LRUCache"/>
        <class name="Scanner" line="13">
            <implements interface="Iterator">
                <type_params>
                    <type_param name="String"/>
                </type_params>
            </implements>
            <implements interface="Closeable"/>
            <javadoc line="13">
                A simple text scanner which can parse primitive types and strings using
                  regular expressions.
                  &lt;p&gt;A &lt;code&gt;Scanner&lt;/code&gt; breaks its input into tokens using a
                  delimiter pattern, which by default matches whitespace. The resulting
                  tokens may then be converted into values of different types using the
                  various &lt;tt&gt;next&lt;/tt&gt; methods.
                  &lt;p&gt;For example, this code allows a user to read a number from
                  &lt;tt&gt;System.in&lt;/tt&gt;:
                  &lt;blockquote&gt;&lt;pre&gt;
                  Scanner sc = new Scanner(System.in);
                  int i = sc.nextInt();
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;As another example, this code allows &lt;code&gt;long&lt;/code&gt; types to be
                  assigned from entries in a file &lt;code&gt;myNumbers&lt;/code&gt;:
                  &lt;blockquote&gt;&lt;pre&gt;
                  Scanner sc = new Scanner(new File(&quot;myNumbers&quot;));
                  while (sc.hasNextLong()) {
                  long aLong = sc.nextLong();
                  }&lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;The scanner can also use delimiters other than whitespace. This
                  example reads several items in from a string:
                  &lt;blockquote&gt;&lt;pre&gt;
                  String input = &quot;1 fish 2 fish red fish blue fish&quot;;
                  Scanner s = new Scanner(input).useDelimiter(&quot;\\sfish\\s&quot;);
                  System.out.println(s.nextInt());
                  System.out.println(s.nextInt());
                  System.out.println(s.next());
                  System.out.println(s.next());
                  s.close(); &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;
                  prints the following output:
                  &lt;blockquote&gt;&lt;pre&gt;
                  1
                  2
                  red
                  blue &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;The same output can be generated with this code, which uses a regular
                  expression to parse all four tokens at once:
                  &lt;blockquote&gt;&lt;pre&gt;
                  String input = &quot;1 fish 2 fish red fish blue fish&quot;;
                  Scanner s = new Scanner(input);
                  s.findInLine(&quot;(\\d+) fish (\\d+) fish (\\w+) fish (\\w+)&quot;);
                  MatchResult result = s.match();
                  for (int i=1; i&lt;=result.groupCount(); i++)
                  System.out.println(result.group(i));
                  s.close(); &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt;The &lt;a name=&quot;default-delimiter&quot;&gt;default whitespace delimiter&lt;/a&gt; used
                  by a scanner is as recognized by {@link java.lang.Character}.{@link java.lang.Character#isWhitespace(char) isWhitespace}. The {@link #reset}method will reset the value of the scanner&apos;s delimiter to the default
                  whitespace delimiter regardless of whether it was previously changed.
                  &lt;p&gt;A scanning operation may block waiting for input.
                  &lt;p&gt;The {@link #next} and {@link #hasNext} methods and their
                  primitive-type companion methods (such as {@link #nextInt} and{@link #hasNextInt}) first skip any input that matches the delimiter
                  pattern, and then attempt to return the next token. Both &lt;tt&gt;hasNext&lt;/tt&gt;
                  and &lt;tt&gt;next&lt;/tt&gt; methods may block waiting for further input.  Whether a
                  &lt;tt&gt;hasNext&lt;/tt&gt; method blocks has no connection to whether or not its
                  associated &lt;tt&gt;next&lt;/tt&gt; method will block.
                  &lt;p&gt; The {@link #findInLine}, {@link #findWithinHorizon}, and {@link #skip}methods operate independently of the delimiter pattern. These methods will
                  attempt to match the specified pattern with no regard to delimiters in the
                  input and thus can be used in special circumstances where delimiters are
                  not relevant. These methods may block waiting for more input.
                  &lt;p&gt;When a scanner throws an {@link InputMismatchException}, the scanner
                  will not pass the token that caused the exception, so that it may be
                  retrieved or skipped via some other method.
                  &lt;p&gt;Depending upon the type of delimiting pattern, empty tokens may be
                  returned. For example, the pattern &lt;tt&gt;&quot;\\s+&quot;&lt;/tt&gt; will return no empty
                  tokens since it matches multiple instances of the delimiter. The delimiting
                  pattern &lt;tt&gt;&quot;\\s&quot;&lt;/tt&gt; could return empty tokens since it only passes one
                  space at a time.
                  &lt;p&gt; A scanner can read text from any object which implements the {@link java.lang.Readable} interface.  If an invocation of the underlying
                  readable&apos;s {@link java.lang.Readable#read} method throws an {@link java.io.IOException} then the scanner assumes that the end of the input
                  has been reached.  The most recent &lt;tt&gt;IOException&lt;/tt&gt; thrown by the
                  underlying readable can be retrieved via the {@link #ioException} method.
                  &lt;p&gt;When a &lt;code&gt;Scanner&lt;/code&gt; is closed, it will close its input source
                  if the source implements the {@link java.io.Closeable} interface.
                  &lt;p&gt;A &lt;code&gt;Scanner&lt;/code&gt; is not safe for multithreaded use without
                  external synchronization.
                  &lt;p&gt;Unless otherwise mentioned, passing a &lt;code&gt;null&lt;/code&gt; parameter into
                  any method of a &lt;code&gt;Scanner&lt;/code&gt; will cause a
                  &lt;code&gt;NullPointerException&lt;/code&gt; to be thrown.
                  &lt;p&gt;A scanner will default to interpreting numbers as decimal unless a
                  different radix has been set by using the {@link #useRadix} method. The{@link #reset} method will reset the value of the scanner&apos;s radix to
                  &lt;code&gt;10&lt;/code&gt; regardless of whether it was previously changed.
                  &lt;a name=&quot;localized-numbers&quot;&gt;
                  &lt;h4&gt; Localized numbers &lt;/h4&gt;
                  &lt;p&gt; An instance of this class is capable of scanning numbers in the standard
                  formats as well as in the formats of the scanner&apos;s locale. A scanner&apos;s
                  &lt;a name=&quot;initial-locale&quot;&gt;initial locale &lt;/a&gt;is the value returned by the {@link java.util.Locale#getDefault} method; it may be changed via the {@link #useLocale} method. The {@link #reset} method will reset the value of the
                  scanner&apos;s locale to the initial locale regardless of whether it was
                  previously changed.
                  &lt;p&gt;The localized formats are defined in terms of the following parameters,
                  which for a particular locale are taken from that locale&apos;s {@link java.text.DecimalFormat DecimalFormat} object, &lt;tt&gt;df&lt;/tt&gt;, and its and{@link java.text.DecimalFormatSymbols DecimalFormatSymbols} object,
                  &lt;tt&gt;dfs&lt;/tt&gt;.
                  &lt;blockquote&gt;&lt;table&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalGroupSeparator&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The character used to separate thousands groups,
                  &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;dfs.&lt;/tt&gt;{@link java.text.DecimalFormatSymbols#getGroupingSeparatorgetGroupingSeparator()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalDecimalSeparator&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The character used for the decimal point,
                  &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;dfs.&lt;/tt&gt;{@link java.text.DecimalFormatSymbols#getDecimalSeparatorgetDecimalSeparator()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalPositivePrefix&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that appears before a positive number (may
                  be empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;df.&lt;/tt&gt;{@link java.text.DecimalFormat#getPositivePrefixgetPositivePrefix()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalPositiveSuffix&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that appears after a positive number (may be
                  empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;df.&lt;/tt&gt;{@link java.text.DecimalFormat#getPositiveSuffixgetPositiveSuffix()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalNegativePrefix&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that appears before a negative number (may
                  be empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;df.&lt;/tt&gt;{@link java.text.DecimalFormat#getNegativePrefixgetNegativePrefix()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalNegativeSuffix&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that appears after a negative number (may be
                  empty), &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;df.&lt;/tt&gt;{@link java.text.DecimalFormat#getNegativeSuffixgetNegativeSuffix()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalNaN&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that represents not-a-number for
                  floating-point values,
                  &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;dfs.&lt;/tt&gt;{@link java.text.DecimalFormatSymbols#getNaNgetNaN()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;i&gt;LocalInfinity&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;top&quot;&gt;The string that represents infinity for floating-point
                  values, &lt;i&gt;i.e.,&lt;/i&gt;&amp;nbsp;&lt;tt&gt;dfs.&lt;/tt&gt;{@link java.text.DecimalFormatSymbols#getInfinitygetInfinity()}&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;
                  &lt;a name=&quot;number-syntax&quot;&gt;
                  &lt;h4&gt; Number syntax &lt;/h4&gt;
                  &lt;p&gt; The strings that can be parsed as numbers by an instance of this class
                  are specified in terms of the following regular-expression grammar, where
                  Rmax is the highest digit in the radix being used (for example, Rmax is 9
                  in base 10).
                  &lt;p&gt;
                  &lt;table cellspacing=0 cellpadding=0 align=center&gt;
                  &lt;tr&gt;&lt;td valign=top align=right&gt;&lt;i&gt;NonASCIIDigit&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;= A non-ASCII character c for which{@link java.lang.Character#isDigit Character.isDigit}&lt;tt&gt;(c)&lt;/tt&gt;
                  returns&amp;nbsp;true&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;Non0Digit&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= [1-&lt;/tt&gt;&lt;i&gt;Rmax&lt;/i&gt;&lt;tt&gt;] | &lt;/tt&gt;&lt;i&gt;NonASCIIDigit&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;Digit&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= [0-&lt;/tt&gt;&lt;i&gt;Rmax&lt;/i&gt;&lt;tt&gt;] | &lt;/tt&gt;&lt;i&gt;NonASCIIDigit&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top align=right&gt;&lt;i&gt;GroupedNumeral&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;
                  &lt;table cellpadding=0 cellspacing=0&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;= (&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;i&gt;Non0Digit&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;?
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;?&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;(&amp;nbsp;&lt;/tt&gt;&lt;i&gt;LocalGroupSeparator&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt; )+ )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;Numeral&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= ( ( &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;+ )
                  | &lt;/tt&gt;&lt;i&gt;GroupedNumeral&lt;/i&gt;&lt;tt&gt; )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top align=right&gt;
                  &lt;a name=&quot;Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;&lt;tt&gt;= ( [-+]? ( &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;tt&gt;
                  ) )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalPositivePrefix&lt;/i&gt;&lt;tt&gt; &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalPositiveSuffix&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalNegativePrefix&lt;/i&gt;&lt;tt&gt; &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalNegativeSuffix&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;DecimalNumeral&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;Numeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalDecimalSeparator&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalDecimalSeparator&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;+&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;Exponent&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= ( [eE] [+-]? &lt;/tt&gt;&lt;i&gt;Digit&lt;/i&gt;&lt;tt&gt;+ )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;
                  &lt;a name=&quot;Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= ( [-+]? &lt;/tt&gt;&lt;i&gt;DecimalNumeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;Exponent&lt;/i&gt;&lt;tt&gt;? )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalPositivePrefix&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;DecimalNumeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalPositiveSuffix&lt;/i&gt;
                  &lt;/tt&gt;&lt;i&gt;Exponent&lt;/i&gt;&lt;tt&gt;?&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalNegativePrefix&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;DecimalNumeral&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalNegativeSuffix&lt;/i&gt;
                  &lt;/tt&gt;&lt;i&gt;Exponent&lt;/i&gt;&lt;tt&gt;?&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;HexFloat&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= [-+]? 0[xX][0-9a-fA-F]\.[0-9a-fA-F]+
                  ([pP][-+]?[0-9]+)?&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;NonNumber&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;&lt;tt&gt;= NaN
                  | &lt;/tt&gt;&lt;i&gt;LocalNan&lt;/i&gt;&lt;tt&gt;
                  | Infinity
                  | &lt;/tt&gt;&lt;i&gt;LocalInfinity&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;SignedNonNumber&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;= ( [-+]? &lt;/tt&gt;&lt;i&gt;NonNumber&lt;/i&gt;&lt;tt&gt; )&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalPositivePrefix&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;NonNumber&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalPositiveSuffix&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;LocalNegativePrefix&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;NonNumber&lt;/i&gt;&lt;tt&gt;
                  &lt;/tt&gt;&lt;i&gt;LocalNegativeSuffix&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=top align=right&gt;
                  &lt;a name=&quot;Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&amp;nbsp;&amp;nbsp;::&lt;/td&gt;
                  &lt;td valign=top&gt;&lt;tt&gt;= &lt;/tt&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;HexFloat&lt;/i&gt;&lt;tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;| &lt;/tt&gt;&lt;i&gt;SignedNonNumber&lt;/i&gt;&lt;tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;/center&gt;
                  &lt;p&gt; Whitespace is not significant in the above regular expressions.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="buf" type="CharBuffer" line="242"/>
            <declaration name="BUFFER_SIZE" type="int" line="243"/>
            <declaration name="position" type="int" line="244"/>
            <declaration name="matcher" type="Matcher" line="245"/>
            <declaration name="delimPattern" type="Pattern" line="246"/>
            <declaration name="hasNextPattern" type="Pattern" line="247"/>
            <declaration name="hasNextPosition" type="int" line="248"/>
            <declaration name="hasNextResult" type="String" line="249"/>
            <declaration name="source" type="Readable" line="250"/>
            <declaration name="sourceClosed" type="boolean" line="251"/>
            <declaration name="needInput" type="boolean" line="252"/>
            <declaration name="skipped" type="boolean" line="253"/>
            <declaration name="savedScannerPosition" type="int" line="254"/>
            <declaration name="typeCache" type="Object" line="255"/>
            <declaration name="matchValid" type="boolean" line="256"/>
            <declaration name="closed" type="boolean" line="257"/>
            <declaration name="radix" type="int" line="258"/>
            <declaration name="defaultRadix" type="int" line="259"/>
            <declaration name="locale" type="Locale" line="260"/>
            <declaration name="patternCache" type="LRUCache&lt;String,Pattern&gt;" line="261"/>
            <anonymous_class line="261">
                <method name="create" type="Pattern" line="262">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <method name="hasName" type="boolean" line="265">
                    <params>
                        <param name="p" type="Pattern"/>
                        <param name="s" type="String"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="lastException" type="IOException" line="270"/>
            <declaration name="WHITESPACE_PATTERN" type="Pattern" line="271"/>
            <declaration name="FIND_ANY_PATTERN" type="Pattern" line="272"/>
            <declaration name="NON_ASCII_DIGIT" type="Pattern" line="273"/>
            <declaration name="groupSeparator" type="String" line="274"/>
            <javadoc line="274">
                Locale dependent values used to scan numbers                
            </javadoc>
            <declaration name="decimalSeparator" type="String" line="278"/>
            <declaration name="nanString" type="String" line="279"/>
            <declaration name="infinityString" type="String" line="280"/>
            <declaration name="positivePrefix" type="String" line="281"/>
            <declaration name="negativePrefix" type="String" line="282"/>
            <declaration name="positiveSuffix" type="String" line="283"/>
            <declaration name="negativeSuffix" type="String" line="284"/>
            <declaration name="boolPattern" type="Pattern" line="285"/>
            <javadoc line="285">
                Fields and an accessor method to match booleans                
            </javadoc>
            <declaration name="BOOLEAN_PATTERN" type="String" line="289"/>
            <method name="boolPattern" type="Pattern" line="290">
                <declaration name="bp" type="Pattern" line="291"/>
            </method>
            <declaration name="integerPattern" type="Pattern" line="295"/>
            <javadoc line="295">
                Fields and methods to match bytes, shorts, ints, and longs                
            </javadoc>
            <declaration name="digits" type="String" line="299"/>
            <declaration name="non0Digit" type="String" line="300"/>
            <declaration name="SIMPLE_GROUP_INDEX" type="int" line="301"/>
            <method name="buildIntegerPatternString" type="String" line="302">
                <declaration name="radixDigits" type="String" line="303"/>
                <declaration name="digit" type="String" line="304"/>
                <declaration name="groupedNumeral" type="String" line="305"/>
                <declaration name="numeral" type="String" line="306"/>
                <declaration name="javaStyleInteger" type="String" line="307"/>
                <declaration name="negativeInteger" type="String" line="308"/>
                <declaration name="positiveInteger" type="String" line="309"/>
            </method>
            <method name="integerPattern" type="Pattern" line="312">
                <scope line="313"/>
            </method>
            <declaration name="separatorPattern" type="Pattern" line="318"/>
            <javadoc line="318">
                Fields and an accessor method to match line separators                
            </javadoc>
            <declaration name="linePattern" type="Pattern" line="322"/>
            <declaration name="LINE_SEPARATOR_PATTERN" type="String" line="323"/>
            <declaration name="LINE_PATTERN" type="String" line="324"/>
            <method name="separatorPattern" type="Pattern" line="325">
                <declaration name="sp" type="Pattern" line="326"/>
            </method>
            <method name="linePattern" type="Pattern" line="330">
                <declaration name="lp" type="Pattern" line="331"/>
            </method>
            <declaration name="floatPattern" type="Pattern" line="335"/>
            <javadoc line="335">
                Fields and methods to match floats and doubles                
            </javadoc>
            <declaration name="decimalPattern" type="Pattern" line="339"/>
            <method name="buildFloatAndDecimalPattern" type="void" line="340">
                <declaration name="digit" type="String" line="341"/>
                <declaration name="exponent" type="String" line="342"/>
                <declaration name="groupedNumeral" type="String" line="343"/>
                <declaration name="numeral" type="String" line="344"/>
                <declaration name="decimalNumeral" type="String" line="345"/>
                <declaration name="nonNumber" type="String" line="346"/>
                <declaration name="positiveFloat" type="String" line="347"/>
                <declaration name="negativeFloat" type="String" line="348"/>
                <declaration name="decimal" type="String" line="349"/>
                <declaration name="hexFloat" type="String" line="350"/>
                <declaration name="positiveNonNumber" type="String" line="351"/>
                <declaration name="negativeNonNumber" type="String" line="352"/>
                <declaration name="signedNonNumber" type="String" line="353"/>
            </method>
            <method name="floatPattern" type="Pattern" line="357">
                <scope line="358"/>
            </method>
            <method name="decimalPattern" type="Pattern" line="363">
                <scope line="364"/>
            </method>
            <javadoc line="369">
                Constructs a &lt;code&gt;Scanner&lt;/code&gt; that returns values scanned
                  from the specified source delimited by the specified pattern.                
                <param>
                    source A character source implementing the Readable interface                    
                </param>
                <param>
                    pattern A delimiting pattern                    
                </param>
                <return>
                    A scanner with the specified source and pattern                    
                </return>
            </javadoc>
            <method name="Scanner" type="constructor" line="376">
                <params>
                    <param name="source" type="Readable"/>
                    <param name="pattern" type="Pattern"/>
                </params>
            </method>
            <javadoc line="388">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified source.                
                <param>
                    source A character source implementing the {@link Readable}interface                    
                </param>
            </javadoc>
            <method name="Scanner" type="constructor" line="393">
                <params>
                    <param name="source" type="Readable"/>
                </params>
            </method>
            <javadoc line="396">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified input stream. Bytes from the stream are converted
                  into characters using the underlying platform&apos;s{@linkplain java.nio.charset.Charset#defaultCharset() default charset}.                
                <param>
                    source An input stream to be scanned                    
                </param>
            </javadoc>
            <method name="Scanner" type="constructor" line="402">
                <params>
                    <param name="source" type="InputStream"/>
                </params>
            </method>
            <javadoc line="405">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified input stream. Bytes from the stream are converted
                  into characters using the specified charset.                
                <param>
                    source An input stream to be scanned                    
                </param>
                <param>
                    charsetName The encoding type used to convert bytes from the
                      stream into characters to be scanned                    
                </param>
                <throws>
                    IllegalArgumentException if the specified character set
                      does not exist                    
                </throws>
            </javadoc>
            <method name="Scanner" type="constructor" line="415">
                <params>
                    <param name="source" type="InputStream"/>
                    <param name="charsetName" type="String"/>
                </params>
            </method>
            <javadoc line="418">
                Returns a charset object for the given charset name.                
                <throws>
                    NullPointerException          is csn is null                    
                </throws>
                <throws>
                    IllegalArgumentException      if the charset is not supported                    
                </throws>
            </javadoc>
            <method name="toCharset" type="Charset" line="423">
                <params>
                    <param name="csn" type="String"/>
                </params>
                <scope line="425"/>
                <scope line="428"/>
            </method>
            <method name="makeReadable" type="Readable" line="432">
                <params>
                    <param name="source" type="InputStream"/>
                    <param name="charset" type="Charset"/>
                </params>
            </method>
            <javadoc line="435">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified file. Bytes from the file are converted into
                  characters using the underlying platform&apos;s{@linkplain java.nio.charset.Charset#defaultCharset() default charset}.                
                <param>
                    source A file to be scanned                    
                </param>
                <throws>
                    FileNotFoundException if source is not found                    
                </throws>
            </javadoc>
            <method name="Scanner" type="constructor" line="442">
                <params>
                    <param name="source" type="File"/>
                </params>
            </method>
            <javadoc line="445">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified file. Bytes from the file are converted into
                  characters using the specified charset.                
                <param>
                    source A file to be scanned                    
                </param>
                <param>
                    charsetName The encoding type used to convert bytes from the file
                      into characters to be scanned                    
                </param>
                <throws>
                    FileNotFoundException if source is not found                    
                </throws>
                <throws>
                    IllegalArgumentException if the specified encoding is
                      not found                    
                </throws>
            </javadoc>
            <method name="Scanner" type="constructor" line="456">
                <params>
                    <param name="source" type="File"/>
                    <param name="charsetName" type="String"/>
                </params>
            </method>
            <method name="Scanner" type="constructor" line="459">
                <params>
                    <param name="source" type="File"/>
                    <param name="dec" type="CharsetDecoder"/>
                </params>
            </method>
            <method name="toDecoder" type="CharsetDecoder" line="462">
                <params>
                    <param name="charsetName" type="String"/>
                </params>
                <scope line="464"/>
                <scope line="467"/>
            </method>
            <method name="makeReadable" type="Readable" line="471">
                <params>
                    <param name="source" type="ReadableByteChannel"/>
                    <param name="dec" type="CharsetDecoder"/>
                </params>
            </method>
            <javadoc line="474">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified file. Bytes from the file are converted into
                  characters using the underlying platform&apos;s{@linkplain java.nio.charset.Charset#defaultCharset() default charset}.                
                <param>
                    sourcethe path to the file to be scanned                    
                </param>
                <throws>
                    IOExceptionif an I/O error occurs opening source                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="Scanner" type="constructor" line="482">
                <params>
                    <param name="source" type="Path"/>
                </params>
            </method>
            <javadoc line="485">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified file. Bytes from the file are converted into
                  characters using the specified charset.                
                <param>
                    sourcethe path to the file to be scanned                    
                </param>
                <param>
                    charsetNameThe encoding type used to convert bytes from the file
                      into characters to be scanned                    
                </param>
                <throws>
                    IOExceptionif an I/O error occurs opening source                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif the specified encoding is not found                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="Scanner" type="constructor" line="496">
                <params>
                    <param name="source" type="Path"/>
                    <param name="charsetName" type="String"/>
                </params>
            </method>
            <method name="Scanner" type="constructor" line="499">
                <params>
                    <param name="source" type="Path"/>
                    <param name="charset" type="Charset"/>
                </params>
            </method>
            <javadoc line="502">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified string.                
                <param>
                    source A string to scan                    
                </param>
            </javadoc>
            <method name="Scanner" type="constructor" line="507">
                <params>
                    <param name="source" type="String"/>
                </params>
            </method>
            <javadoc line="510">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified channel. Bytes from the source are converted into
                  characters using the underlying platform&apos;s{@linkplain java.nio.charset.Charset#defaultCharset() default charset}.                
                <param>
                    source A channel to scan                    
                </param>
            </javadoc>
            <method name="Scanner" type="constructor" line="516">
                <params>
                    <param name="source" type="ReadableByteChannel"/>
                </params>
            </method>
            <method name="makeReadable" type="Readable" line="519">
                <params>
                    <param name="source" type="ReadableByteChannel"/>
                </params>
            </method>
            <javadoc line="522">
                Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned
                  from the specified channel. Bytes from the source are converted into
                  characters using the specified charset.                
                <param>
                    source A channel to scan                    
                </param>
                <param>
                    charsetName The encoding type used to convert bytes from the
                      channel into characters to be scanned                    
                </param>
                <throws>
                    IllegalArgumentException if the specified character set
                      does not exist                    
                </throws>
            </javadoc>
            <method name="Scanner" type="constructor" line="532">
                <params>
                    <param name="source" type="ReadableByteChannel"/>
                    <param name="charsetName" type="String"/>
                </params>
            </method>
            <method name="saveState" type="void" line="535"/>
            <method name="revertState" type="void" line="538"/>
            <method name="revertState" type="boolean" line="543">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <method name="cacheResult" type="void" line="549"/>
            <method name="cacheResult" type="void" line="554">
                <params>
                    <param name="result" type="String"/>
                </params>
            </method>
            <method name="clearCaches" type="void" line="559"/>
            <method name="getCachedResult" type="String" line="563"/>
            <method name="useTypeCache" type="void" line="569"/>
            <method name="readInput" type="void" line="575">
                <declaration name="p" type="int" line="577"/>
                <declaration name="n" type="int" line="580"/>
                <scope line="581"/>
                <scope line="584"/>
                <scope line="588"/>
            </method>
            <method name="makeSpace" type="boolean" line="596">
                <declaration name="offset" type="int" line="598"/>
                <scope line="600"/>
                <declaration name="newSize" type="int" line="607"/>
                <declaration name="newBuf" type="CharBuffer" line="608"/>
            </method>
            <method name="translateSavedIndexes" type="void" line="617">
                <params>
                    <param name="offset" type="int"/>
                </params>
            </method>
            <method name="throwFor" type="void" line="620"/>
            <method name="hasTokenInBuffer" type="boolean" line="625"/>
            <method name="getCompleteTokenInBuffer" type="String" line="633">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <scope line="636">
                    <scope line="638">
                        <scope line="639"/>
                    </scope>
                </scope>
                <scope line="647"/>
                <declaration name="foundNextDelim" type="boolean" line="653"/>
                <scope line="654"/>
                <scope line="657">
                    <scope line="658"/>
                    <declaration name="tokenEnd" type="int" line="662"/>
                    <scope line="663"/>
                    <scope line="668">
                        <declaration name="s" type="String" line="669"/>
                    </scope>
                    <scope line="673"/>
                </scope>
                <scope line="677">
                    <scope line="678"/>
                    <scope line="683">
                        <declaration name="s" type="String" line="684"/>
                    </scope>
                </scope>
            </method>
            <method name="findPatternInBuffer" type="String" line="693">
                <params>
                    <param name="pattern" type="Pattern"/>
                    <param name="horizon" type="int"/>
                </params>
                <declaration name="bufferLimit" type="int" line="696"/>
                <declaration name="horizonLimit" type="int" line="697"/>
                <declaration name="searchLimit" type="int" line="698"/>
                <scope line="699"/>
                <scope line="704">
                    <scope line="705">
                        <scope line="706"/>
                        <scope line="710"/>
                    </scope>
                </scope>
            </method>
            <method name="matchPatternInBuffer" type="String" line="722">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <scope line="726">
                    <scope line="727"/>
                </scope>
            </method>
            <method name="ensureOpen" type="void" line="738"/>
            <javadoc line="741">
                Closes this scanner.
                  &lt;p&gt; If this scanner has not yet been closed then if its underlying{@linkplain java.lang.Readable readable} also implements the {@link java.io.Closeable} interface then the readable&apos;s &lt;tt&gt;close&lt;/tt&gt; method
                  will be invoked.  If this scanner is already closed then invoking this
                  method will have no effect.
                  &lt;p&gt;Attempting to perform search operations after a scanner has
                  been closed will result in an {@link IllegalStateException}.                
            </javadoc>
            <method name="close" type="void" line="749">
                <scope line="751">
                    <scope line="752"/>
                    <scope line="755"/>
                </scope>
            </method>
            <javadoc line="763">
                Returns the &lt;code&gt;IOException&lt;/code&gt; last thrown by this
                  &lt;code&gt;Scanner&lt;/code&gt;&apos;s underlying &lt;code&gt;Readable&lt;/code&gt;. This method
                  returns &lt;code&gt;null&lt;/code&gt; if no such exception exists.                
                <return>
                    the last exception thrown by this scanner's readable                    
                </return>
            </javadoc>
            <method name="ioException" type="IOException" line="769"/>
            <javadoc line="772">
                Returns the &lt;code&gt;Pattern&lt;/code&gt; this &lt;code&gt;Scanner&lt;/code&gt; is currently
                  using to match delimiters.                
                <return>
                    this scanner's delimiting pattern.                    
                </return>
            </javadoc>
            <method name="delimiter" type="Pattern" line="777"/>
            <javadoc line="780">
                Sets this scanner&apos;s delimiting pattern to the specified pattern.                
                <param>
                    pattern A delimiting pattern                    
                </param>
                <return>
                    this scanner                    
                </return>
            </javadoc>
            <method name="useDelimiter" type="Scanner" line="785">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
            </method>
            <javadoc line="789">
                Sets this scanner&apos;s delimiting pattern to a pattern constructed from
                  the specified &lt;code&gt;String&lt;/code&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;useDelimiter(pattern)&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;useDelimiter(Pattern.compile(pattern))&lt;/tt&gt;.
                  &lt;p&gt; Invoking the {@link #reset} method will set the scanner&apos;s delimiter
                  to the &lt;a href= &quot;#default-delimiter&quot;&gt;default&lt;/a&gt;.                
                <param>
                    pattern A string specifying a delimiting pattern                    
                </param>
                <return>
                    this scanner                    
                </return>
            </javadoc>
            <method name="useDelimiter" type="Scanner" line="800">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="804">
                Returns this scanner&apos;s locale.
                  &lt;p&gt;A scanner&apos;s locale affects many elements of its default
                  primitive matching regular expressions; see
                  &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.                
                <return>
                    this scanner's locale                    
                </return>
            </javadoc>
            <method name="locale" type="Locale" line="811"/>
            <javadoc line="814">
                Sets this scanner&apos;s locale to the specified locale.
                  &lt;p&gt;A scanner&apos;s locale affects many elements of its default
                  primitive matching regular expressions; see
                  &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.
                  &lt;p&gt;Invoking the {@link #reset} method will set the scanner&apos;s locale to
                  the &lt;a href= &quot;#initial-locale&quot;&gt;initial locale&lt;/a&gt;.                
                <param>
                    locale A string specifying the locale to use                    
                </param>
                <return>
                    this scanner                    
                </return>
            </javadoc>
            <method name="useLocale" type="Scanner" line="824">
                <params>
                    <param name="locale" type="Locale"/>
                </params>
                <declaration name="df" type="DecimalFormat" line="827"/>
                <declaration name="dfs" type="DecimalFormatSymbols" line="828"/>
            </method>
            <javadoc line="845">
                Returns this scanner&apos;s default radix.
                  &lt;p&gt;A scanner&apos;s radix affects elements of its default
                  number matching regular expressions; see
                  &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.                
                <return>
                    the default radix of this scanner                    
                </return>
            </javadoc>
            <method name="radix" type="int" line="852"/>
            <javadoc line="855">
                Sets this scanner&apos;s default radix to the specified radix.
                  &lt;p&gt;A scanner&apos;s radix affects elements of its default
                  number matching regular expressions; see
                  &lt;a href= &quot;#localized-numbers&quot;&gt;localized numbers&lt;/a&gt; above.
                  &lt;p&gt;If the radix is less than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt;
                  or greater than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then an
                  &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
                  &lt;p&gt;Invoking the {@link #reset} method will set the scanner&apos;s radix to
                  &lt;code&gt;10&lt;/code&gt;.                
                <param>
                    radix The radix to use when scanning numbers                    
                </param>
                <return>
                    this scanner                    
                </return>
                <throws>
                    IllegalArgumentException if radix is out of range                    
                </throws>
            </javadoc>
            <method name="useRadix" type="Scanner" line="869">
                <params>
                    <param name="radix" type="int"/>
                </params>
            </method>
            <method name="setRadix" type="void" line="876">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <scope line="877"/>
            </method>
            <javadoc line="882">
                Returns the match result of the last scanning operation performed
                  by this scanner. This method throws &lt;code&gt;IllegalStateException&lt;/code&gt;
                  if no match has been performed, or if the last match was
                  not successful.
                  &lt;p&gt;The various &lt;code&gt;next&lt;/code&gt;methods of &lt;code&gt;Scanner&lt;/code&gt;
                  make a match result available if they complete without throwing an
                  exception. For instance, after an invocation of the {@link #nextInt}method that returned an int, this method returns a
                  &lt;code&gt;MatchResult&lt;/code&gt; for the search of the
                  &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression
                  defined above. Similarly the {@link #findInLine},{@link #findWithinHorizon}, and {@link #skip} methods will make a
                  match available if they succeed.                
                <return>
                    a match result for the last match operation                    
                </return>
                <throws>
                    IllegalStateException  If no match result is available                    
                </throws>
            </javadoc>
            <method name="match" type="MatchResult" line="897"/>
            <javadoc line="901">
                &lt;p&gt;Returns the string representation of this &lt;code&gt;Scanner&lt;/code&gt;. The
                  string representation of a &lt;code&gt;Scanner&lt;/code&gt; contains information
                  that may be useful for debugging. The exact format is unspecified.                
                <return>
                    The string representation of this scanner                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="907">
                <declaration name="sb" type="StringBuilder" line="908"/>
            </method>
            <javadoc line="926">
                Returns true if this scanner has another token in its input.
                  This method may block while waiting for input to scan.
                  The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner has another token                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
                <see>
                    java.util.Iterator                    
                </see>
            </javadoc>
            <method name="hasNext" type="boolean" line="934">
                <scope line="937"/>
                <declaration name="result" type="boolean" line="941"/>
            </method>
            <javadoc line="944">
                Finds and returns the next complete token from this scanner.
                  A complete token is preceded and followed by input that matches
                  the delimiter pattern. This method may block while waiting for input
                  to scan, even if a previous invocation of {@link #hasNext} returned
                  &lt;code&gt;true&lt;/code&gt;.                
                <return>
                    the next token                    
                </return>
                <throws>
                    NoSuchElementException if no more tokens are available                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
                <see>
                    java.util.Iterator                    
                </see>
            </javadoc>
            <method name="next" type="String" line="955">
                <scope line="958">
                    <declaration name="token" type="String" line="959"/>
                    <scope line="960"/>
                </scope>
            </method>
            <javadoc line="969">
                The remove operation is not supported by this implementation of
                  &lt;code&gt;Iterator&lt;/code&gt;.                
                <throws>
                    UnsupportedOperationException if this method is invoked.                    
                </throws>
                <see>
                    java.util.Iterator                    
                </see>
            </javadoc>
            <method name="remove" type="void" line="975"/>
            <javadoc line="978">
                Returns true if the next token matches the pattern constructed from the
                  specified string. The scanner does not advance past any input.
                  &lt;p&gt; An invocation of this method of the form &lt;tt&gt;hasNext(pattern)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;tt&gt;hasNext(Pattern.compile(pattern))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to scan                    
                </param>
                <return>
                    true if and only if this scanner has another token matching
                      the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNext" type="boolean" line="989">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="992">
                Returns the next token if it matches the pattern constructed from the
                  specified string.  If the match is successful, the scanner advances
                  past the input that matched the pattern.
                  &lt;p&gt; An invocation of this method of the form &lt;tt&gt;next(pattern)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;tt&gt;next(Pattern.compile(pattern))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to scan                    
                </param>
                <return>
                    the next token                    
                </return>
                <throws>
                    NoSuchElementException if no such tokens are available                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="next" type="String" line="1004">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1007">
                Returns true if the next complete token matches the specified pattern.
                  A complete token is prefixed and postfixed by input that matches
                  the delimiter pattern. This method may block while waiting for input.
                  The scanner does not advance past any input.                
                <param>
                    pattern the pattern to scan for                    
                </param>
                <return>
                    true if and only if this scanner has another token matching
                      the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNext" type="boolean" line="1017">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <scope line="1022">
                    <scope line="1023"/>
                </scope>
            </method>
            <javadoc line="1032">
                Returns the next token if it matches the specified pattern. This
                  method may block while waiting for input to scan, even if a previous
                  invocation of {@link #hasNext(Pattern)} returned &lt;code&gt;true&lt;/code&gt;.
                  If the match is successful, the scanner advances past the input that
                  matched the pattern.                
                <param>
                    pattern the pattern to scan for                    
                </param>
                <return>
                    the next token                    
                </return>
                <throws>
                    NoSuchElementException if no more tokens are available                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="next" type="String" line="1043">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <scope line="1048">
                    <declaration name="token" type="String" line="1049"/>
                    <scope line="1050"/>
                </scope>
            </method>
            <javadoc line="1059">
                Returns true if there is another line in the input of this scanner.
                  This method may block while waiting for input. The scanner does not
                  advance past any input.                
                <return>
                    true if and only if this scanner has another line of input                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextLine" type="boolean" line="1066">
                <declaration name="result" type="String" line="1068"/>
                <scope line="1069">
                    <declaration name="mr" type="MatchResult" line="1070"/>
                    <declaration name="lineSep" type="String" line="1071"/>
                    <scope line="1072"/>
                    <scope line="1076"/>
                </scope>
            </method>
            <javadoc line="1083">
                Advances this scanner past the current line and returns the input
                  that was skipped.
                  This method returns the rest of the current line, excluding any line
                  separator at the end. The position is set to the beginning of the next
                  line.
                  &lt;p&gt;Since this method continues to search through the input looking
                  for a line separator, it may buffer all of the input searching for
                  the line to skip if no line separators are present.                
                <return>
                    the line that was skipped                    
                </return>
                <throws>
                    NoSuchElementException if no line was found                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextLine" type="String" line="1096">
                <declaration name="result" type="String" line="1099"/>
                <declaration name="mr" type="MatchResult" line="1101"/>
                <declaration name="lineSep" type="String" line="1102"/>
            </method>
            <javadoc line="1107">
                Attempts to find the next occurrence of a pattern constructed from the
                  specified string, ignoring delimiters.
                  &lt;p&gt;An invocation of this method of the form &lt;tt&gt;findInLine(pattern)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;tt&gt;findInLine(Pattern.compile(pattern))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to search for                    
                </param>
                <return>
                    the text that matched the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="findInLine" type="String" line="1117">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1120">
                Attempts to find the next occurrence of the specified pattern ignoring
                  delimiters. If the pattern is found before the next line separator, the
                  scanner advances past the input that matched and returns the string that
                  matched the pattern.
                  If no such pattern is detected in the input up to the next line
                  separator, then &lt;code&gt;null&lt;/code&gt; is returned and the scanner&apos;s
                  position is unchanged. This method may block waiting for input that
                  matches the pattern.
                  &lt;p&gt;Since this method continues to search through the input looking
                  for the specified pattern, it may buffer all of the input searching for
                  the desired token if no line separators are present.                
                <param>
                    pattern the pattern to scan for                    
                </param>
                <return>
                    the text that matched the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="findInLine" type="String" line="1136">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <declaration name="endPosition" type="int" line="1140"/>
                <scope line="1142">
                    <declaration name="token" type="String" line="1143"/>
                    <scope line="1144"/>
                    <scope line="1148"/>
                    <scope line="1151"/>
                </scope>
                <declaration name="horizonForLine" type="int" line="1157"/>
            </method>
            <javadoc line="1161">
                Attempts to find the next occurrence of a pattern constructed from the
                  specified string, ignoring delimiters.
                  &lt;p&gt;An invocation of this method of the form
                  &lt;tt&gt;findWithinHorizon(pattern)&lt;/tt&gt; behaves in exactly the same way as
                  the invocation
                  &lt;tt&gt;findWithinHorizon(Pattern.compile(pattern, horizon))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to search for                    
                </param>
                <return>
                    the text that matched the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
                <throws>
                    IllegalArgumentException if horizon is negative                    
                </throws>
            </javadoc>
            <method name="findWithinHorizon" type="String" line="1173">
                <params>
                    <param name="pattern" type="String"/>
                    <param name="horizon" type="int"/>
                </params>
            </method>
            <javadoc line="1176">
                Attempts to find the next occurrence of the specified pattern.
                  &lt;p&gt;This method searches through the input up to the specified
                  search horizon, ignoring delimiters. If the pattern is found the
                  scanner advances past the input that matched and returns the string
                  that matched the pattern. If no such pattern is detected then the
                  null is returned and the scanner&apos;s position remains unchanged. This
                  method may block waiting for input that matches the pattern.
                  &lt;p&gt;A scanner will never search more than &lt;code&gt;horizon&lt;/code&gt; code
                  points beyond its current position. Note that a match may be clipped
                  by the horizon; that is, an arbitrary match result may have been
                  different if the horizon had been larger. The scanner treats the
                  horizon as a transparent, non-anchoring bound (see {@link Matcher#useTransparentBounds} and {@link Matcher#useAnchoringBounds}).
                  &lt;p&gt;If horizon is &lt;code&gt;0&lt;/code&gt;, then the horizon is ignored and
                  this method continues to search through the input looking for the
                  specified pattern without bound. In this case it may buffer all of
                  the input searching for the pattern.
                  &lt;p&gt;If horizon is negative, then an IllegalArgumentException is
                  thrown.                
                <param>
                    pattern the pattern to scan for                    
                </param>
                <return>
                    the text that matched the specified pattern                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
                <throws>
                    IllegalArgumentException if horizon is negative                    
                </throws>
            </javadoc>
            <method name="findWithinHorizon" type="String" line="1200">
                <params>
                    <param name="pattern" type="Pattern"/>
                    <param name="horizon" type="int"/>
                </params>
                <scope line="1205">
                    <declaration name="token" type="String" line="1206"/>
                    <scope line="1207"/>
                </scope>
            </method>
            <javadoc line="1216">
                Skips input that matches the specified pattern, ignoring delimiters.
                  This method will skip input if an anchored match of the specified
                  pattern succeeds.
                  &lt;p&gt;If a match to the specified pattern is not found at the
                  current position, then no input is skipped and a
                  &lt;tt&gt;NoSuchElementException&lt;/tt&gt; is thrown.
                  &lt;p&gt;Since this method seeks to match the specified pattern starting at
                  the scanner&apos;s current position, patterns that can match a lot of
                  input (&quot;.&quot;, for example) may cause the scanner to buffer a large
                  amount of input.
                  &lt;p&gt;Note that it is possible to skip something without risking a
                  &lt;code&gt;NoSuchElementException&lt;/code&gt; by using a pattern that can
                  match nothing, e.g., &lt;code&gt;sc.skip(&quot;[ \t]&quot;)&lt;/code&gt;.                
                <param>
                    pattern a string specifying the pattern to skip over                    
                </param>
                <return>
                    this scanner                    
                </return>
                <throws>
                    NoSuchElementException if the specified pattern is not found                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="skip" type="Scanner" line="1235">
                <params>
                    <param name="pattern" type="Pattern"/>
                </params>
                <scope line="1239">
                    <declaration name="token" type="String" line="1240"/>
                    <scope line="1241"/>
                </scope>
            </method>
            <javadoc line="1250">
                Skips input that matches a pattern constructed from the specified
                  string.
                  &lt;p&gt; An invocation of this method of the form &lt;tt&gt;skip(pattern)&lt;/tt&gt;
                  behaves in exactly the same way as the invocation
                  &lt;tt&gt;skip(Pattern.compile(pattern))&lt;/tt&gt;.                
                <param>
                    pattern a string specifying the pattern to skip over                    
                </param>
                <return>
                    this scanner                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="skip" type="Scanner" line="1260">
                <params>
                    <param name="pattern" type="String"/>
                </params>
            </method>
            <javadoc line="1263">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a boolean value using a case insensitive pattern
                  created from the string &quot;true|false&quot;.  The scanner does not
                  advance past the input that matched.                
                <return>
                    true if and only if this scanner's next token is a valid
                      boolean value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextBoolean" type="boolean" line="1272"/>
            <javadoc line="1275">
                Scans the next token of the input into a boolean value and returns
                  that value. This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid boolean value.
                  If the match is successful, the scanner advances past the input that
                  matched.                
                <return>
                    the boolean scanned from the input                    
                </return>
                <throws>
                    InputMismatchException if the next token is not a valid boolean                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextBoolean" type="boolean" line="1286"/>
            <javadoc line="1290">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a byte value in the default radix using the{@link #nextByte} method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      byte value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextByte" type="boolean" line="1297"/>
            <javadoc line="1300">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a byte value in the specified radix using the{@link #nextByte} method. The scanner does not advance past any input.                
                <param>
                    radix the radix used to interpret the token as a byte value                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      byte value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextByte" type="boolean" line="1308">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <declaration name="result" type="boolean" line="1310"/>
                <scope line="1311">
                    <scope line="1312">
                        <declaration name="s" type="String" line="1313"/>
                    </scope>
                    <scope line="1316"/>
                </scope>
            </method>
            <javadoc line="1322">
                Scans the next token of the input as a &lt;tt&gt;byte&lt;/tt&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextByte()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextByte(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>byte</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextByte" type="byte" line="1334"/>
            <javadoc line="1337">
                Scans the next token of the input as a &lt;tt&gt;byte&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid byte value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;byte&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Byte#parseByte(String,int) Byte.parseByte} with the
                  specified radix.                
                <param>
                    radix the radix used to interpret the token as a byte value                    
                </param>
                <return>
                    the <tt>byte</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextByte" type="byte" line="1359">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <scope line="1360">
                    <declaration name="val" type="byte" line="1361"/>
                </scope>
                <scope line="1367">
                    <declaration name="s" type="String" line="1368"/>
                </scope>
                <scope line="1372"/>
            </method>
            <javadoc line="1377">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a short value in the default radix using the{@link #nextShort} method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      short value in the default radix                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextShort" type="boolean" line="1384"/>
            <javadoc line="1387">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a short value in the specified radix using the{@link #nextShort} method. The scanner does not advance past any input.                
                <param>
                    radix the radix used to interpret the token as a short value                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      short value in the specified radix                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextShort" type="boolean" line="1395">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <declaration name="result" type="boolean" line="1397"/>
                <scope line="1398">
                    <scope line="1399">
                        <declaration name="s" type="String" line="1400"/>
                    </scope>
                    <scope line="1403"/>
                </scope>
            </method>
            <javadoc line="1409">
                Scans the next token of the input as a &lt;tt&gt;short&lt;/tt&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextShort()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextShort(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>short</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextShort" type="short" line="1421"/>
            <javadoc line="1424">
                Scans the next token of the input as a &lt;tt&gt;short&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid short value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;short&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Short#parseShort(String,int) Short.parseShort} with the
                  specified radix.                
                <param>
                    radix the radix used to interpret the token as a short value                    
                </param>
                <return>
                    the <tt>short</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextShort" type="short" line="1446">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <scope line="1447">
                    <declaration name="val" type="short" line="1448"/>
                </scope>
                <scope line="1454">
                    <declaration name="s" type="String" line="1455"/>
                </scope>
                <scope line="1459"/>
            </method>
            <javadoc line="1464">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as an int value in the default radix using the{@link #nextInt} method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      int value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextInt" type="boolean" line="1471"/>
            <javadoc line="1474">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as an int value in the specified radix using the{@link #nextInt} method. The scanner does not advance past any input.                
                <param>
                    radix the radix used to interpret the token as an int value                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      int value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextInt" type="boolean" line="1482">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <declaration name="result" type="boolean" line="1484"/>
                <scope line="1485">
                    <scope line="1486">
                        <declaration name="s" type="String" line="1487"/>
                    </scope>
                    <scope line="1490"/>
                </scope>
            </method>
            <javadoc line="1496">
                The integer token must be stripped of prefixes, group separators,
                  and suffixes, non ascii digits must be converted into ascii digits
                  before parse will accept it.                
            </javadoc>
            <method name="processIntegerToken" type="String" line="1501">
                <params>
                    <param name="token" type="String"/>
                </params>
                <declaration name="result" type="String" line="1502"/>
                <declaration name="isNegative" type="boolean" line="1503"/>
                <declaration name="preLen" type="int" line="1504"/>
                <scope line="1505"/>
                <declaration name="sufLen" type="int" line="1509"/>
                <scope line="1510"/>
            </method>
            <javadoc line="1517">
                Scans the next token of the input as an &lt;tt&gt;int&lt;/tt&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextInt()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextInt(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>int</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextInt" type="int" line="1529"/>
            <javadoc line="1532">
                Scans the next token of the input as an &lt;tt&gt;int&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid int value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into an &lt;tt&gt;int&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Integer#parseInt(String,int) Integer.parseInt} with the
                  specified radix.                
                <param>
                    radix the radix used to interpret the token as an int value                    
                </param>
                <return>
                    the <tt>int</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextInt" type="int" line="1554">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <scope line="1555">
                    <declaration name="val" type="int" line="1556"/>
                </scope>
                <scope line="1562">
                    <declaration name="s" type="String" line="1563"/>
                </scope>
                <scope line="1567"/>
            </method>
            <javadoc line="1572">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a long value in the default radix using the{@link #nextLong} method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      long value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextLong" type="boolean" line="1579"/>
            <javadoc line="1582">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a long value in the specified radix using the{@link #nextLong} method. The scanner does not advance past any input.                
                <param>
                    radix the radix used to interpret the token as a long value                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      long value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextLong" type="boolean" line="1590">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <declaration name="result" type="boolean" line="1592"/>
                <scope line="1593">
                    <scope line="1594">
                        <declaration name="s" type="String" line="1595"/>
                    </scope>
                    <scope line="1598"/>
                </scope>
            </method>
            <javadoc line="1604">
                Scans the next token of the input as a &lt;tt&gt;long&lt;/tt&gt;.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextLong()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextLong(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>long</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextLong" type="long" line="1616"/>
            <javadoc line="1619">
                Scans the next token of the input as a &lt;tt&gt;long&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid long value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;long&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Long#parseLong(String,int) Long.parseLong} with the
                  specified radix.                
                <param>
                    radix the radix used to interpret the token as an int value                    
                </param>
                <return>
                    the <tt>long</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextLong" type="long" line="1641">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <scope line="1642">
                    <declaration name="val" type="long" line="1643"/>
                </scope>
                <scope line="1649">
                    <declaration name="s" type="String" line="1650"/>
                </scope>
                <scope line="1654"/>
            </method>
            <javadoc line="1659">
                The float token must be stripped of prefixes, group separators,
                  and suffixes, non ascii digits must be converted into ascii digits
                  before parseFloat will accept it.
                  If there are non-ascii digits in the token these digits must
                  be processed before the token is passed to parseFloat.                
            </javadoc>
            <method name="processFloatToken" type="String" line="1666">
                <params>
                    <param name="token" type="String"/>
                </params>
                <declaration name="result" type="String" line="1667"/>
                <declaration name="isNegative" type="boolean" line="1669"/>
                <declaration name="preLen" type="int" line="1670"/>
                <scope line="1671"/>
                <declaration name="sufLen" type="int" line="1675"/>
                <scope line="1676"/>
                <declaration name="m" type="Matcher" line="1683"/>
                <scope line="1684">
                    <declaration name="inASCII" type="StringBuilder" line="1685"/>
                    <scope line="1686">
                        <declaration name="nextChar" type="char" line="1687"/>
                        <scope line="1688">
                            <declaration name="d" type="int" line="1689"/>
                        </scope>
                        <scope line="1693"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1701">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a float value using the {@link #nextFloat}method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      float value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextFloat" type="boolean" line="1708">
                <declaration name="result" type="boolean" line="1710"/>
                <scope line="1711">
                    <scope line="1712">
                        <declaration name="s" type="String" line="1713"/>
                    </scope>
                    <scope line="1716"/>
                </scope>
            </method>
            <javadoc line="1722">
                Scans the next token of the input as a &lt;tt&gt;float&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid float value as
                  described below. If the translation is successful, the scanner advances
                  past the input that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above
                  then the token is converted into a &lt;tt&gt;float&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Float#parseFloat Float.parseFloat}. If the token matches
                  the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot;
                  is passed to {@link Float#parseFloat(String) Float.parseFloat} as
                  appropriate.                
                <return>
                    the <tt>float</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Float</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextFloat" type="float" line="1745">
                <scope line="1746">
                    <declaration name="val" type="float" line="1747"/>
                </scope>
                <scope line="1753"/>
                <scope line="1756"/>
            </method>
            <javadoc line="1761">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a double value using the {@link #nextDouble}method. The scanner does not advance past any input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      double value                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextDouble" type="boolean" line="1768">
                <declaration name="result" type="boolean" line="1770"/>
                <scope line="1771">
                    <scope line="1772">
                        <declaration name="s" type="String" line="1773"/>
                    </scope>
                    <scope line="1776"/>
                </scope>
            </method>
            <javadoc line="1782">
                Scans the next token of the input as a &lt;tt&gt;double&lt;/tt&gt;.
                  This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;
                  if the next token cannot be translated into a valid double value.
                  If the translation is successful, the scanner advances past the input
                  that matched.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above
                  then the token is converted into a &lt;tt&gt;double&lt;/tt&gt; value as if by
                  removing all locale specific prefixes, group separators, and locale
                  specific suffixes, then mapping non-ASCII digits into ASCII
                  digits via {@link Character#digit Character.digit}, prepending a
                  negative sign (-) if the locale specific negative prefixes and suffixes
                  were present, and passing the resulting string to{@link Double#parseDouble Double.parseDouble}. If the token matches
                  the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot;
                  is passed to {@link Double#parseDouble(String) Double.parseDouble} as
                  appropriate.                
                <return>
                    the <tt>double</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Float</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if the input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextDouble" type="double" line="1805">
                <scope line="1806">
                    <declaration name="val" type="double" line="1807"/>
                </scope>
                <scope line="1813"/>
                <scope line="1816"/>
            </method>
            <javadoc line="1821">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a &lt;code&gt;BigInteger&lt;/code&gt; in the default radix using the{@link #nextBigInteger} method. The scanner does not advance past any
                  input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      <code>BigInteger</code>                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextBigInteger" type="boolean" line="1829"/>
            <javadoc line="1832">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a &lt;code&gt;BigInteger&lt;/code&gt; in the specified radix using
                  the {@link #nextBigInteger} method. The scanner does not advance past
                  any input.                
                <param>
                    radix the radix used to interpret the token as an integer                    
                </param>
                <return>
                    true if and only if this scanner's next token is a valid
                      <code>BigInteger</code>                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextBigInteger" type="boolean" line="1842">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <declaration name="result" type="boolean" line="1844"/>
                <scope line="1845">
                    <scope line="1846">
                        <declaration name="s" type="String" line="1847"/>
                    </scope>
                    <scope line="1850"/>
                </scope>
            </method>
            <javadoc line="1856">
                Scans the next token of the input as a {@link java.math.BigIntegerBigInteger}.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;nextBigInteger()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation &lt;tt&gt;nextBigInteger(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
                  is the default radix of this scanner.                
                <return>
                    the <tt>BigInteger</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if the input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextBigInteger" type="BigInteger" line="1868"/>
            <javadoc line="1871">
                Scans the next token of the input as a {@link java.math.BigIntegerBigInteger}.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;BigInteger&lt;/tt&gt; value as if
                  by removing all group separators, mapping non-ASCII digits into ASCII
                  digits via the {@link Character#digit Character.digit}, and passing the
                  resulting string to the {@link java.math.BigInteger#BigInteger(java.lang.String)BigInteger(String, int)} constructor with the specified radix.                
                <param>
                    radix the radix used to interpret the token                    
                </param>
                <return>
                    the <tt>BigInteger</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Integer</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if the input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextBigInteger" type="BigInteger" line="1886">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <scope line="1887">
                    <declaration name="val" type="BigInteger" line="1888"/>
                </scope>
                <scope line="1894">
                    <declaration name="s" type="String" line="1895"/>
                </scope>
                <scope line="1899"/>
            </method>
            <javadoc line="1904">
                Returns true if the next token in this scanner&apos;s input can be
                  interpreted as a &lt;code&gt;BigDecimal&lt;/code&gt; using the{@link #nextBigDecimal} method. The scanner does not advance past any
                  input.                
                <return>
                    true if and only if this scanner's next token is a valid
                      <code>BigDecimal</code>                    
                </return>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="hasNextBigDecimal" type="boolean" line="1912">
                <declaration name="result" type="boolean" line="1914"/>
                <scope line="1915">
                    <scope line="1916">
                        <declaration name="s" type="String" line="1917"/>
                    </scope>
                    <scope line="1920"/>
                </scope>
            </method>
            <javadoc line="1926">
                Scans the next token of the input as a {@link java.math.BigDecimalBigDecimal}.
                  &lt;p&gt; If the next token matches the &lt;a
                  href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined
                  above then the token is converted into a &lt;tt&gt;BigDecimal&lt;/tt&gt; value as if
                  by removing all group separators, mapping non-ASCII digits into ASCII
                  digits via the {@link Character#digit Character.digit}, and passing the
                  resulting string to the {@link java.math.BigDecimal#BigDecimal(java.lang.String) BigDecimal(String)}constructor.                
                <return>
                    the <tt>BigDecimal</tt> scanned from the input                    
                </return>
                <throws>
                    InputMismatchExceptionif the next token does not match the <i>Decimal</i>
                      regular expression, or is out of range                    
                </throws>
                <throws>
                    NoSuchElementException if the input is exhausted                    
                </throws>
                <throws>
                    IllegalStateException if this scanner is closed                    
                </throws>
            </javadoc>
            <method name="nextBigDecimal" type="BigDecimal" line="1940">
                <scope line="1941">
                    <declaration name="val" type="BigDecimal" line="1942"/>
                </scope>
                <scope line="1948">
                    <declaration name="s" type="String" line="1949"/>
                </scope>
                <scope line="1952"/>
            </method>
            <javadoc line="1957">
                Resets this scanner.
                  &lt;p&gt; Resetting a scanner discards all of its explicit state
                  information which may have been changed by invocations of {@link #useDelimiter}, {@link #useLocale}, or {@link #useRadix}.
                  &lt;p&gt; An invocation of this method of the form
                  &lt;tt&gt;scanner.reset()&lt;/tt&gt; behaves in exactly the same way as the
                  invocation
                  &lt;blockquote&gt;&lt;pre&gt;
                  scanner.useDelimiter(&quot;\\p{javaWhitespace}+&quot;)
                  .useLocale(Locale.getDefault())
                  .useRadix(10);
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <return>
                    this scanner                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="reset" type="Scanner" line="1972"/>
        </class>
    </source>