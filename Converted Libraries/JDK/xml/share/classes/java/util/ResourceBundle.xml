<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <import package="java.io.IOException"/>
        <import package="java.io.InputStream"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.lang.ref.SoftReference"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.net.JarURLConnection"/>
        <import package="java.net.URL"/>
        <import package="java.net.URLConnection"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.util.concurrent.ConcurrentHashMap"/>
        <import package="java.util.concurrent.ConcurrentMap"/>
        <import package="java.util.jar.JarEntry"/>
        <import package="sun.util.locale.BaseLocale"/>
        <import package="sun.util.locale.LocaleObjectCache"/>
        <class name="ResourceBundle" line="63">
            <comment line="414">
                Automatic determination of the ClassLoader to be used to load
                 resources on behalf of the client.  N.B. The client is getLoader&apos;s
                 caller&apos;s caller.                
            </comment>
            <javadoc line="63">
                Resource bundles contain locale-specific objects.  When your program needs a
                  locale-specific resource, a &lt;code&gt;String&lt;/code&gt; for example, your program can
                  load it from the resource bundle that is appropriate for the current user&apos;s
                  locale. In this way, you can write program code that is largely independent
                  of the user&apos;s locale isolating most, if not all, of the locale-specific
                  information in resource bundles.
                  &lt;p&gt;
                  This allows you to write programs that can:
                  &lt;UL type=SQUARE&gt;
                  &lt;LI&gt; be easily localized, or translated, into different languages
                  &lt;LI&gt; handle multiple locales at once
                  &lt;LI&gt; be easily modified later to support even more locales
                  &lt;/UL&gt;
                  &lt;P&gt;
                  Resource bundles belong to families whose members share a common base
                  name, but whose names also have additional components that identify
                  their locales. For example, the base name of a family of resource
                  bundles might be &quot;MyResources&quot;. The family should have a default
                  resource bundle which simply has the same name as its family -
                  &quot;MyResources&quot; - and will be used as the bundle of last resort if a
                  specific locale is not supported. The family can then provide as
                  many locale-specific members as needed, for example a German one
                  named &quot;MyResources_de&quot;.
                  &lt;P&gt;
                  Each resource bundle in a family contains the same items, but the items have
                  been translated for the locale represented by that resource bundle.
                  For example, both &quot;MyResources&quot; and &quot;MyResources_de&quot; may have a
                  &lt;code&gt;String&lt;/code&gt; that&apos;s used on a button for canceling operations.
                  In &quot;MyResources&quot; the &lt;code&gt;String&lt;/code&gt; may contain &quot;Cancel&quot; and in
                  &quot;MyResources_de&quot; it may contain &quot;Abbrechen&quot;.
                  &lt;P&gt;
                  If there are different resources for different countries, you
                  can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for
                  the German language (de) in Switzerland (CH). If you want to only
                  modify some of the resources
                  in the specialization, you can do so.
                  &lt;P&gt;
                  When your program needs a locale-specific object, it loads
                  the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the{@link #getBundle(java.lang.String,java.util.Locale) getBundle}method:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  ResourceBundle myResources =
                  ResourceBundle.getBundle(&quot;MyResources&quot;, currentLocale);
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;P&gt;
                  Resource bundles contain key/value pairs. The keys uniquely
                  identify a locale-specific object in the bundle. Here&apos;s an
                  example of a &lt;code&gt;ListResourceBundle&lt;/code&gt; that contains
                  two key/value pairs:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  public class MyResources extends ListResourceBundle {
                  protected Object[][] getContents() {
                  return new Object[][] {
                  // LOCALIZE THE SECOND STRING OF EACH ARRAY (e.g., &quot;OK&quot;)
                  {&quot;OkKey&quot;, &quot;OK&quot;},
                  {&quot;CancelKey&quot;, &quot;Cancel&quot;},
                  // END OF MATERIAL TO LOCALIZE
                  };
                  }
                  }
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  Keys are always &lt;code&gt;String&lt;/code&gt;s.
                  In this example, the keys are &quot;OkKey&quot; and &quot;CancelKey&quot;.
                  In the above example, the values
                  are also &lt;code&gt;String&lt;/code&gt;s--&quot;OK&quot; and &quot;Cancel&quot;--but
                  they don&apos;t have to be. The values can be any type of object.
                  &lt;P&gt;
                  You retrieve an object from resource bundle using the appropriate
                  getter method. Because &quot;OkKey&quot; and &quot;CancelKey&quot;
                  are both strings, you would use &lt;code&gt;getString&lt;/code&gt; to retrieve them:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  button1 = new Button(myResources.getString(&quot;OkKey&quot;));
                  button2 = new Button(myResources.getString(&quot;CancelKey&quot;));
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  The getter methods all require the key as an argument and return
                  the object if found. If the object is not found, the getter method
                  throws a &lt;code&gt;MissingResourceException&lt;/code&gt;.
                  &lt;P&gt;
                  Besides &lt;code&gt;getString&lt;/code&gt;, &lt;code&gt;ResourceBundle&lt;/code&gt; also provides
                  a method for getting string arrays, &lt;code&gt;getStringArray&lt;/code&gt;,
                  as well as a generic &lt;code&gt;getObject&lt;/code&gt; method for any other
                  type of object. When using &lt;code&gt;getObject&lt;/code&gt;, you&apos;ll
                  have to cast the result to the appropriate type. For example:
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  int[] myIntegers = (int[]) myResources.getObject(&quot;intList&quot;);
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  &lt;P&gt;
                  The Java Platform provides two subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt;,
                  &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt;,
                  that provide a fairly simple way to create resources.
                  As you saw briefly in a previous example, &lt;code&gt;ListResourceBundle&lt;/code&gt;
                  manages its resource as a list of key/value pairs.
                  &lt;code&gt;PropertyResourceBundle&lt;/code&gt; uses a properties file to manage
                  its resources.
                  &lt;p&gt;
                  If &lt;code&gt;ListResourceBundle&lt;/code&gt; or &lt;code&gt;PropertyResourceBundle&lt;/code&gt;
                  do not suit your needs, you can write your own &lt;code&gt;ResourceBundle&lt;/code&gt;
                  subclass.  Your subclasses must override two methods: &lt;code&gt;handleGetObject&lt;/code&gt;
                  and &lt;code&gt;getKeys()&lt;/code&gt;.
                  &lt;h4&gt;ResourceBundle.Control&lt;/h4&gt;
                  The {@link ResourceBundle.Control} class provides information necessary
                  to perform the bundle loading process by the &lt;code&gt;getBundle&lt;/code&gt;
                  factory methods that take a &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
                  instance. You can implement your own subclass in order to enable
                  non-standard resource bundle formats, change the search strategy, or
                  define caching parameters. Refer to the descriptions of the class and the{@link #getBundle(String,Locale,ClassLoader,Control) getBundle}factory method for details.
                  &lt;h4&gt;Cache Management&lt;/h4&gt;
                  Resource bundle instances created by the &lt;code&gt;getBundle&lt;/code&gt; factory
                  methods are cached by default, and the factory methods return the same
                  resource bundle instance multiple times if it has been
                  cached. &lt;code&gt;getBundle&lt;/code&gt; clients may clear the cache, manage the
                  lifetime of cached resource bundle instances using time-to-live values,
                  or specify not to cache resource bundle instances. Refer to the
                  descriptions of the {@linkplain #getBundle(String,Locale,ClassLoader,Control) &lt;code&gt;getBundle&lt;/code&gt; factory method}, {@link #clearCache(ClassLoader) clearCache}, {@link Control#getTimeToLive(String,Locale)ResourceBundle.Control.getTimeToLive}, and {@link Control#needsReload(String,Locale,String,ClassLoader,ResourceBundle,long) ResourceBundle.Control.needsReload} for details.
                  &lt;h4&gt;Example&lt;/h4&gt;
                  The following is a very simple example of a &lt;code&gt;ResourceBundle&lt;/code&gt;
                  subclass, &lt;code&gt;MyResources&lt;/code&gt;, that manages two resources (for a larger number of
                  resources you would probably use a &lt;code&gt;Map&lt;/code&gt;).
                  Notice that you don&apos;t need to supply a value if
                  a &quot;parent-level&quot; &lt;code&gt;ResourceBundle&lt;/code&gt; handles the same
                  key with the same value (as for the okKey below).
                  &lt;blockquote&gt;
                  &lt;pre&gt;
                  // default (English language, United States)
                  public class MyResources extends ResourceBundle {
                  public Object handleGetObject(String key) {
                  if (key.equals(&quot;okKey&quot;)) return &quot;Ok&quot;;
                  if (key.equals(&quot;cancelKey&quot;)) return &quot;Cancel&quot;;
                  return null;
                  }
                  public Enumeration&amp;lt;String&amp;gt; getKeys() {
                  return Collections.enumeration(keySet());
                  }
                  // Overrides handleKeySet() so that the getKeys() implementation
                  // can rely on the keySet() value.
                  protected Set&amp;lt;String&amp;gt; handleKeySet() {
                  return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;okKey&quot;, &quot;cancelKey&quot;));
                  }
                  }
                  // German language
                  public class MyResources_de extends MyResources {
                  public Object handleGetObject(String key) {
                  // don&apos;t need okKey, since parent level handles it.
                  if (key.equals(&quot;cancelKey&quot;)) return &quot;Abbrechen&quot;;
                  return null;
                  }
                  protected Set&amp;lt;String&amp;gt; handleKeySet() {
                  return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;cancelKey&quot;));
                  }
                  }
                  &lt;/pre&gt;
                  &lt;/blockquote&gt;
                  You do not have to restrict yourself to using a single family of
                  &lt;code&gt;ResourceBundle&lt;/code&gt;s. For example, you could have a set of bundles for
                  exception messages, &lt;code&gt;ExceptionResources&lt;/code&gt;
                  (&lt;code&gt;ExceptionResources_fr&lt;/code&gt;, &lt;code&gt;ExceptionResources_de&lt;/code&gt;, ...),
                  and one for widgets, &lt;code&gt;WidgetResource&lt;/code&gt; (&lt;code&gt;WidgetResources_fr&lt;/code&gt;,
                  &lt;code&gt;WidgetResources_de&lt;/code&gt;, ...); breaking up the resources however you like.                
                <see>
                    ListResourceBundle                    
                </see>
                <see>
                    PropertyResourceBundle                    
                </see>
                <see>
                    MissingResourceException                    
                </see>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <declaration name="INITIAL_CACHE_SIZE" type="int" line="268"/>
            <javadoc line="268">
                initial size of the bundle cache                
            </javadoc>
            <declaration name="NONEXISTENT_BUNDLE" type="ResourceBundle" line="271"/>
            <javadoc line="271">
                constant indicating that no resource bundle exists                
            </javadoc>
            <anonymous_class line="272">
                <method name="getKeys" type="Enumeration<String>" line="273"/>
                <method name="handleGetObject" type="Object" line="274">
                    <params>
                        <param name="key" type="String"/>
                    </params>
                </method>
                <method name="toString" type="String" line="275"/>
            </anonymous_class>
            <declaration name="cacheList" type="ConcurrentMap&lt;CacheKey,BundleReference&gt;" line="279"/>
            <javadoc line="279">
                The cache is a map from cache keys (with bundle base name, locale, and
                  class loader) to either a resource bundle or NONEXISTENT_BUNDLE wrapped by a
                  BundleReference.
                  The cache is a ConcurrentMap, allowing the cache to be searched
                  concurrently by multiple threads.  This will also allow the cache keys
                  to be reclaimed along with the ClassLoaders they reference.
                  This variable would be better named &quot;cache&quot;, but we keep the old
                  name for compatibility with some workarounds for bug 4212439.                
            </javadoc>
            <declaration name="referenceQueue" type="ReferenceQueue" line="294"/>
            <javadoc line="294">
                Queue for reference objects referring to class loaders or bundles.                
            </javadoc>
            <declaration name="parent" type="ResourceBundle" line="299"/>
            <javadoc line="299">
                The parent bundle of this bundle.
                  The parent bundle is searched by {@link #getObject getObject}when this bundle does not contain a particular resource.                
            </javadoc>
            <declaration name="locale" type="Locale" line="306"/>
            <javadoc line="306">
                The locale for this bundle.                
            </javadoc>
            <declaration name="name" type="String" line="311"/>
            <javadoc line="311">
                The base bundle name for this bundle.                
            </javadoc>
            <declaration name="expired" type="boolean" line="316"/>
            <javadoc line="316">
                The flag indicating this bundle has expired in the cache.                
            </javadoc>
            <declaration name="cacheKey" type="CacheKey" line="321"/>
            <javadoc line="321">
                The back link to the cache key. null if this bundle isn&apos;t in
                  the cache (yet) or has expired.                
            </javadoc>
            <declaration name="keySet" type="Set&lt;String&gt;" line="327"/>
            <javadoc line="327">
                A Set of the keys contained only in this ResourceBundle.                
            </javadoc>
            <javadoc line="332">
                Sole constructor.  (For invocation by subclass constructors, typically
                  implicit.)                
            </javadoc>
            <method name="ResourceBundle" type="constructor" line="336"/>
            <javadoc line="339">
                Gets a string for the given key from this resource bundle or one of its parents.
                  Calling this method is equivalent to calling
                  &lt;blockquote&gt;
                  &lt;code&gt;(String) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
                  &lt;/blockquote&gt;                
                <param>
                    key the key for the desired string                    
                </param>
                <exception>
                    NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <exception>
                    MissingResourceException if no object for the given key can be found                    
                </exception>
                <exception>
                    ClassCastException if the object found for the given key is not a string                    
                </exception>
                <return>
                    the string for the given key                    
                </return>
            </javadoc>
            <method name="getString" type="String" line="352">
                <params>
                    <param name="key" type="String"/>
                </params>
            </method>
            <javadoc line="356">
                Gets a string array for the given key from this resource bundle or one of its parents.
                  Calling this method is equivalent to calling
                  &lt;blockquote&gt;
                  &lt;code&gt;(String[]) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
                  &lt;/blockquote&gt;                
                <param>
                    key the key for the desired string array                    
                </param>
                <exception>
                    NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <exception>
                    MissingResourceException if no object for the given key can be found                    
                </exception>
                <exception>
                    ClassCastException if the object found for the given key is not a string array                    
                </exception>
                <return>
                    the string array for the given key                    
                </return>
            </javadoc>
            <method name="getStringArray" type="String[]" line="369">
                <params>
                    <param name="key" type="String"/>
                </params>
            </method>
            <javadoc line="373">
                Gets an object for the given key from this resource bundle or one of its parents.
                  This method first tries to obtain the object from this resource bundle using{@link #handleGetObject(java.lang.String) handleGetObject}.
                  If not successful, and the parent resource bundle is not null,
                  it calls the parent&apos;s &lt;code&gt;getObject&lt;/code&gt; method.
                  If still not successful, it throws a MissingResourceException.                
                <param>
                    key the key for the desired object                    
                </param>
                <exception>
                    NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <exception>
                    MissingResourceException if no object for the given key can be found                    
                </exception>
                <return>
                    the object for the given key                    
                </return>
            </javadoc>
            <method name="getObject" type="Object" line="386">
                <params>
                    <param name="key" type="String"/>
                </params>
                <declaration name="obj" type="Object" line="387"/>
                <scope line="388">
                    <scope line="389"/>
                </scope>
            </method>
            <javadoc line="402">
                Returns the locale of this resource bundle. This method can be used after a
                  call to getBundle() to determine whether the resource bundle returned really
                  corresponds to the requested locale or is a fallback.                
                <return>
                    the locale of this resource bundle                    
                </return>
            </javadoc>
            <method name="getLocale" type="Locale" line="409"/>
            <method name="getLoader" type="ClassLoader" line="418">
                <comment line="421">
                                        
                </comment>
                <comment line="425">
                    When the caller&apos;s loader is the boot class loader, cl is null
                     here. In that case, ClassLoader.getSystemClassLoader() may
                     return the same class loader that the application is
                     using. We therefore use a wrapper ClassLoader to create a
                     separate scope for bundles loaded on behalf of the Java
                     runtime so that these bundles cannot be returned from the
                     cache to the application (5048280).                    
                </comment>
                <declaration name="stack" type="Class[]" line="419"/>
                <declaration name="c" type="Class" line="421"/>
                <declaration name="cl" type="ClassLoader" line="422"/>
                <scope line="423"/>
            </method>
            <method name="getClassContext" type="Class[]" line="436"/>
            <class name="RBClassLoader" line="438">
                <extends class="ClassLoader"/>
                <comment line="493">
                    These three are the actual keys for lookup in Map.                    
                </comment>
                <comment line="498">
                    bundle format which is necessary for calling
                     Control.needsReload().                    
                </comment>
                <comment line="502">
                    These time values are in CacheKey so that NONEXISTENT_BUNDLE
                     doesn&apos;t need to be cloned for caching.                    
                </comment>
                <comment line="505">
                    The time when the bundle has been loaded                    
                </comment>
                <comment line="508">
                    The time when the bundle expires in the cache, or either
                     Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.                    
                </comment>
                <comment line="512">
                    Placeholder for an error report by a Throwable                    
                </comment>
                <comment line="515">
                    Hash code value cache to avoid recalculating the hash code
                     of this instance.                    
                </comment>
                <javadoc line="438">
                    A wrapper of ClassLoader.getSystemClassLoader().                    
                </javadoc>
                <declaration name="INSTANCE" type="RBClassLoader" line="442"/>
                <anonymous_class line="443">
                    <method name="run" type="RBClassLoader" line="444"/>
                </anonymous_class>
                <declaration name="loader" type="ClassLoader" line="448"/>
                <method name="RBClassLoader" type="constructor" line="450"/>
                <method name="loadClass" type="Class<?>" line="452">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                    <scope line="453"/>
                </method>
                <method name="getResource" type="URL" line="458">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                    <scope line="459"/>
                </method>
                <method name="getResourceAsStream" type="InputStream" line="464">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                    <scope line="465"/>
                </method>
            </class>
            <javadoc line="472">
                Sets the parent bundle of this bundle.
                  The parent bundle is searched by {@link #getObject getObject}when this bundle does not contain a particular resource.                
                <param>
                    parent this bundle&apos;s parent bundle.                    
                </param>
            </javadoc>
            <method name="setParent" type="void" line="479">
                <params>
                    <param name="parent" type="ResourceBundle"/>
                </params>
            </method>
            <class name="CacheKey" line="484">
                <comment line="493">
                    These three are the actual keys for lookup in Map.                    
                </comment>
                <comment line="498">
                    bundle format which is necessary for calling
                     Control.needsReload().                    
                </comment>
                <comment line="502">
                    These time values are in CacheKey so that NONEXISTENT_BUNDLE
                     doesn&apos;t need to be cloned for caching.                    
                </comment>
                <comment line="505">
                    The time when the bundle has been loaded                    
                </comment>
                <comment line="508">
                    The time when the bundle expires in the cache, or either
                     Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.                    
                </comment>
                <comment line="512">
                    Placeholder for an error report by a Throwable                    
                </comment>
                <comment line="515">
                    Hash code value cache to avoid recalculating the hash code
                     of this instance.                    
                </comment>
                <implements interface="Cloneable"/>
                <javadoc line="484">
                    Key used for cached resource bundles.  The key checks the base
                      name, the locale, and the class loader to determine if the
                      resource is a match to the requested one. The loader may be
                      null, but the base name and the locale must have a non-null
                      value.                    
                </javadoc>
                <declaration name="name" type="String" line="493"/>
                <declaration name="locale" type="Locale" line="494"/>
                <declaration name="loaderRef" type="LoaderReference" line="495"/>
                <declaration name="format" type="String" line="499"/>
                <declaration name="loadTime" type="long" line="505"/>
                <declaration name="expirationTime" type="long" line="509"/>
                <declaration name="cause" type="Throwable" line="512"/>
                <declaration name="hashCodeCache" type="int" line="516"/>
                <method name="CacheKey" type="constructor" line="518">
                    <params>
                        <param name="baseName" type="String"/>
                        <param name="locale" type="Locale"/>
                        <param name="loader" type="ClassLoader"/>
                    </params>
                    <scope line="521"/>
                    <scope line="523"/>
                </method>
                <method name="getName" type="String" line="529"/>
                <method name="setName" type="CacheKey" line="533">
                    <params>
                        <param name="baseName" type="String"/>
                    </params>
                    <scope line="534"/>
                </method>
                <method name="getLocale" type="Locale" line="541"/>
                <method name="setLocale" type="CacheKey" line="545">
                    <params>
                        <param name="locale" type="Locale"/>
                    </params>
                    <scope line="546"/>
                </method>
                <method name="getLoader" type="ClassLoader" line="553"/>
                <method name="equals" type="boolean" line="557">
                    <params>
                        <param name="other" type="Object"/>
                    </params>
                    <comment line="564">
                        quick check to see if they are not equal                        
                    </comment>
                    <comment line="568">
                        are the names the same?                        
                    </comment>
                    <comment line="572">
                        are the locales the same?                        
                    </comment>
                    <comment line="576">
                        are refs (both non-null) or (both null)?                        
                    </comment>
                    <comment line="582">
                        with a null reference we can no longer find
                         out which class loader was referenced; so
                         treat it as unequal                        
                    </comment>
                    <scope line="558"/>
                    <scope line="561">
                        <declaration name="otherEntry" type="CacheKey" line="562"/>
                        <scope line="564"/>
                        <scope line="568"/>
                        <scope line="572"/>
                        <scope line="576"/>
                        <declaration name="loader" type="ClassLoader" line="579"/>
                    </scope>
                    <scope line="586"/>
                    <scope line="587"/>
                </method>
                <method name="hashCode" type="int" line="592"/>
                <method name="calculateHashCode" type="void" line="596">
                    <declaration name="loader" type="ClassLoader" line="599"/>
                    <scope line="600"/>
                </method>
                <method name="clone" type="Object" line="605">
                    <comment line="613">
                        Clear the reference to a Throwable                        
                    </comment>
                    <comment line="617">
                        this should never happen                        
                    </comment>
                    <scope line="606">
                        <declaration name="clone" type="CacheKey" line="607"/>
                        <scope line="608"/>
                    </scope>
                    <scope line="615"/>
                </method>
                <method name="getFormat" type="String" line="621"/>
                <method name="setFormat" type="void" line="625">
                    <params>
                        <param name="format" type="String"/>
                    </params>
                </method>
                <method name="setCause" type="void" line="629">
                    <params>
                        <param name="cause" type="Throwable"/>
                    </params>
                    <comment line="634">
                        Override the cause if the previous one is
                         ClassNotFoundException.                        
                    </comment>
                    <scope line="630"/>
                    <scope line="632">
                        <scope line="635"/>
                    </scope>
                </method>
                <method name="getCause" type="Throwable" line="641"/>
                <method name="toString" type="String" line="645">
                    <declaration name="l" type="String" line="646"/>
                    <scope line="647">
                        <scope line="648"/>
                        <scope line="650"/>
                    </scope>
                </method>
            </class>
            <interface name="CacheKeyReference">
                <comment line="493">
                    These three are the actual keys for lookup in Map.                    
                </comment>
                <comment line="498">
                    bundle format which is necessary for calling
                     Control.needsReload().                    
                </comment>
                <comment line="502">
                    These time values are in CacheKey so that NONEXISTENT_BUNDLE
                     doesn&apos;t need to be cloned for caching.                    
                </comment>
                <comment line="505">
                    The time when the bundle has been loaded                    
                </comment>
                <comment line="508">
                    The time when the bundle expires in the cache, or either
                     Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.                    
                </comment>
                <comment line="512">
                    Placeholder for an error report by a Throwable                    
                </comment>
                <comment line="515">
                    Hash code value cache to avoid recalculating the hash code
                     of this instance.                    
                </comment>
                <javadoc line="659">
                    The common interface to get a CacheKey in LoaderReference and
                      BundleReference.                    
                </javadoc>
                <method name="getCacheKey" type="CacheKey" line="664"/>
            </interface>
            <class name="LoaderReference" line="667">
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="ClassLoader"/>
                    </type_params>
                </extends>
                <comment line="493">
                    These three are the actual keys for lookup in Map.                    
                </comment>
                <comment line="498">
                    bundle format which is necessary for calling
                     Control.needsReload().                    
                </comment>
                <comment line="502">
                    These time values are in CacheKey so that NONEXISTENT_BUNDLE
                     doesn&apos;t need to be cloned for caching.                    
                </comment>
                <comment line="505">
                    The time when the bundle has been loaded                    
                </comment>
                <comment line="508">
                    The time when the bundle expires in the cache, or either
                     Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.                    
                </comment>
                <comment line="512">
                    Placeholder for an error report by a Throwable                    
                </comment>
                <comment line="515">
                    Hash code value cache to avoid recalculating the hash code
                     of this instance.                    
                </comment>
                <implements interface="CacheKeyReference"/>
                <javadoc line="667">
                    References to class loaders are weak references, so that they can be
                      garbage collected when nobody else is using them. The ResourceBundle
                      class has no reason to keep class loaders alive.                    
                </javadoc>
                <declaration name="cacheKey" type="CacheKey" line="674"/>
                <method name="LoaderReference" type="constructor" line="676">
                    <params>
                        <param name="referent" type="ClassLoader"/>
                        <param name="q" type="ReferenceQueue"/>
                        <param name="key" type="CacheKey"/>
                    </params>
                </method>
                <method name="getCacheKey" type="CacheKey" line="681"/>
            </class>
            <class name="BundleReference" line="686">
                <extends class="SoftReference">
                    <type_params>
                        <type_param name="ResourceBundle"/>
                    </type_params>
                </extends>
                <comment line="493">
                    These three are the actual keys for lookup in Map.                    
                </comment>
                <comment line="498">
                    bundle format which is necessary for calling
                     Control.needsReload().                    
                </comment>
                <comment line="502">
                    These time values are in CacheKey so that NONEXISTENT_BUNDLE
                     doesn&apos;t need to be cloned for caching.                    
                </comment>
                <comment line="505">
                    The time when the bundle has been loaded                    
                </comment>
                <comment line="508">
                    The time when the bundle expires in the cache, or either
                     Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.                    
                </comment>
                <comment line="512">
                    Placeholder for an error report by a Throwable                    
                </comment>
                <comment line="515">
                    Hash code value cache to avoid recalculating the hash code
                     of this instance.                    
                </comment>
                <implements interface="CacheKeyReference"/>
                <javadoc line="686">
                    References to bundles are soft references so that they can be garbage
                      collected when they have no hard references.                    
                </javadoc>
                <declaration name="cacheKey" type="CacheKey" line="692"/>
                <method name="BundleReference" type="constructor" line="694">
                    <params>
                        <param name="referent" type="ResourceBundle"/>
                        <param name="q" type="ReferenceQueue"/>
                        <param name="key" type="CacheKey"/>
                    </params>
                </method>
                <method name="getCacheKey" type="CacheKey" line="699"/>
            </class>
            <javadoc line="704">
                Gets a resource bundle using the specified base name, the default locale,
                  and the caller&apos;s class loader. Calling this method is equivalent to calling
                  &lt;blockquote&gt;
                  &lt;code&gt;getBundle(baseName, Locale.getDefault(), this.getClass().getClassLoader())&lt;/code&gt;,
                  &lt;/blockquote&gt;
                  except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
                  privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.
                  See {@link #getBundle(String,Locale,ClassLoader) getBundle}for a complete description of the search and instantiation strategy.                
                <param>
                    baseName the base name of the resource bundle, a fully qualified class name                    
                </param>
                <exception>
                    java.lang.NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <exception>
                    MissingResourceExceptionif no resource bundle for the specified base name can be found                    
                </exception>
                <return>
                    a resource bundle for the given base name and the default locale                    
                </return>
            </javadoc>
            <method name="getBundle" type="ResourceBundle" line="723">
                <params>
                    <param name="baseName" type="String"/>
                </params>
                <comment line="726">
                                        
                </comment>
            </method>
            <javadoc line="730">
                Returns a resource bundle using the specified base name, the
                  default locale and the specified control. Calling this method
                  is equivalent to calling
                  &lt;pre&gt;
                  getBundle(baseName, Locale.getDefault(),
                  this.getClass().getClassLoader(), control),
                  &lt;/pre&gt;
                  except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
                  privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link #getBundle(String,Locale,ClassLoader,Control) getBundle} for the
                  complete description of the resource bundle loading process with a
                  &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.                
                <param>
                    baseNamethe base name of the resource bundle, a fully qualified class
                      name                    
                </param>
                <param>
                    controlthe control which gives information for the resource bundle
                      loading process                    
                </param>
                <return>
                    a resource bundle for the given base name and the default
                      locale                    
                </return>
                <exception>
                    NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;control&lt;/code&gt; is
                      &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <exception>
                    MissingResourceExceptionif no resource bundle for the specified base name can be found                    
                </exception>
                <exception>
                    IllegalArgumentExceptionif the given &lt;code&gt;control&lt;/code&gt; doesn&apos;t perform properly
                      (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)
                      Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as
                      needed.                    
                </exception>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getBundle" type="ResourceBundle" line="765">
                <params>
                    <param name="baseName" type="String"/>
                    <param name="control" type="Control"/>
                </params>
                <comment line="768">
                                        
                </comment>
            </method>
            <javadoc line="772">
                Gets a resource bundle using the specified base name and locale,
                  and the caller&apos;s class loader. Calling this method is equivalent to calling
                  &lt;blockquote&gt;
                  &lt;code&gt;getBundle(baseName, locale, this.getClass().getClassLoader())&lt;/code&gt;,
                  &lt;/blockquote&gt;
                  except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
                  privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.
                  See {@link #getBundle(String,Locale,ClassLoader) getBundle}for a complete description of the search and instantiation strategy.                
                <param>
                    baseNamethe base name of the resource bundle, a fully qualified class name                    
                </param>
                <param>
                    localethe locale for which a resource bundle is desired                    
                </param>
                <exception>
                    NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <exception>
                    MissingResourceExceptionif no resource bundle for the specified base name can be found                    
                </exception>
                <return>
                    a resource bundle for the given base name and locale                    
                </return>
            </javadoc>
            <method name="getBundle" type="ResourceBundle" line="795">
                <params>
                    <param name="baseName" type="String"/>
                    <param name="locale" type="Locale"/>
                </params>
                <comment line="798">
                                        
                </comment>
            </method>
            <javadoc line="802">
                Returns a resource bundle using the specified base name, target
                  locale and control, and the caller&apos;s class loader. Calling this
                  method is equivalent to calling
                  &lt;pre&gt;
                  getBundle(baseName, targetLocale, this.getClass().getClassLoader(),
                  control),
                  &lt;/pre&gt;
                  except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
                  privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link #getBundle(String,Locale,ClassLoader,Control) getBundle} for the
                  complete description of the resource bundle loading process with a
                  &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.                
                <param>
                    baseNamethe base name of the resource bundle, a fully qualified
                      class name                    
                </param>
                <param>
                    targetLocalethe locale for which a resource bundle is desired                    
                </param>
                <param>
                    controlthe control which gives information for the resource
                      bundle loading process                    
                </param>
                <return>
                    a resource bundle for the given base name and a
                      &lt;code&gt;Locale&lt;/code&gt; in &lt;code&gt;locales&lt;/code&gt;                    
                </return>
                <exception>
                    NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locales&lt;/code&gt; or
                      &lt;code&gt;control&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <exception>
                    MissingResourceExceptionif no resource bundle for the specified base name in any
                      of the &lt;code&gt;locales&lt;/code&gt; can be found.                    
                </exception>
                <exception>
                    IllegalArgumentExceptionif the given &lt;code&gt;control&lt;/code&gt; doesn&apos;t perform properly
                      (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)
                      Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as
                      needed.                    
                </exception>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getBundle" type="ResourceBundle" line="840">
                <params>
                    <param name="baseName" type="String"/>
                    <param name="targetLocale" type="Locale"/>
                    <param name="control" type="Control"/>
                </params>
                <comment line="843">
                                        
                </comment>
            </method>
            <javadoc line="847">
                Gets a resource bundle using the specified base name, locale, and class
                  loader.
                  &lt;p&gt;&lt;a name=&quot;default_behavior&quot;/&gt;This method behaves the same as calling{@link #getBundle(String,Locale,ClassLoader,Control)} passing a
                  default instance of {@link Control}. The following describes this behavior.
                  &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; uses the base name, the specified locale, and
                  the default locale (obtained from {@link java.util.Locale#getDefault()Locale.getDefault}) to generate a sequence of &lt;a
                  name=&quot;candidates&quot;&gt;&lt;em&gt;candidate bundle names&lt;/em&gt;&lt;/a&gt;.  If the specified
                  locale&apos;s language, script, country, and variant are all empty strings,
                  then the base name is the only candidate bundle name.  Otherwise, a list
                  of candidate locales is generated from the attribute values of the
                  specified locale (language, script, country and variant) and appended to
                  the base name.  Typically, this will look like the following:
                  &lt;pre&gt;
                  baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
                  baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country
                  baseName + &quot;_&quot; + language + &quot;_&quot; + script
                  baseName + &quot;_&quot; + language + &quot;_&quot; + country + &quot;_&quot; + variant
                  baseName + &quot;_&quot; + language + &quot;_&quot; + country
                  baseName + &quot;_&quot; + language
                  &lt;/pre&gt;
                  &lt;p&gt;Candidate bundle names where the final component is an empty string
                  are omitted, along with the underscore.  For example, if country is an
                  empty string, the second and the fifth candidate bundle names above
                  would be omitted.  Also, if script is an empty string, the candidate names
                  including script are omitted.  For example, a locale with language &quot;de&quot;
                  and variant &quot;JAVA&quot; will produce candidate names with base name
                  &quot;MyResource&quot; below.
                  &lt;pre&gt;
                  MyResource_de__JAVA
                  MyResource_de
                  &lt;/pre&gt;
                  In the case that the variant contains one or more underscores (&apos;_&apos;), a
                  sequence of bundle names generated by truncating the last underscore and
                  the part following it is inserted after a candidate bundle name with the
                  original variant.  For example, for a locale with language &quot;en&quot;, script
                  &quot;Latn, country &quot;US&quot; and variant &quot;WINDOWS_VISTA&quot;, and bundle base name
                  &quot;MyResource&quot;, the list of candidate bundle names below is generated:
                  &lt;pre&gt;
                  MyResource_en_Latn_US_WINDOWS_VISTA
                  MyResource_en_Latn_US_WINDOWS
                  MyResource_en_Latn_US
                  MyResource_en_Latn
                  MyResource_en_US_WINDOWS_VISTA
                  MyResource_en_US_WINDOWS
                  MyResource_en_US
                  MyResource_en
                  &lt;/pre&gt;
                  &lt;blockquote&gt;&lt;b&gt;Note:&lt;/b&gt; For some &lt;code&gt;Locale&lt;/code&gt;s, the list of
                  candidate bundle names contains extra names, or the order of bundle names
                  is slightly modified.  See the description of the default implementation
                  of {@link Control#getCandidateLocales(String,Locale)getCandidateLocales} for details.&lt;/blockquote&gt;
                  &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; then iterates over the candidate bundle names
                  to find the first one for which it can &lt;em&gt;instantiate&lt;/em&gt; an actual
                  resource bundle. It uses the default controls&apos; {@link Control#getFormatsgetFormats} method, which generates two bundle names for each generated
                  name, the first a class name and the second a properties file name. For
                  each candidate bundle name, it attempts to create a resource bundle:
                  &lt;ul&gt;&lt;li&gt;First, it attempts to load a class using the generated class name.
                  If such a class can be found and loaded using the specified class
                  loader, is assignment compatible with ResourceBundle, is accessible from
                  ResourceBundle, and can be instantiated, &lt;code&gt;getBundle&lt;/code&gt; creates a
                  new instance of this class and uses it as the &lt;em&gt;result resource
                  bundle&lt;/em&gt;.
                  &lt;li&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; attempts to locate a property
                  resource file using the generated properties file name.  It generates a
                  path name from the candidate bundle name by replacing all &quot;.&quot; characters
                  with &quot;/&quot; and appending the string &quot;.properties&quot;.  It attempts to find a
                  &quot;resource&quot; with this name using {@link java.lang.ClassLoader#getResource(java.lang.String)ClassLoader.getResource}.  (Note that a &quot;resource&quot; in the sense of
                  &lt;code&gt;getResource&lt;/code&gt; has nothing to do with the contents of a
                  resource bundle, it is just a container of data, such as a file.)  If it
                  finds a &quot;resource&quot;, it attempts to create a new {@link PropertyResourceBundle} instance from its contents.  If successful, this
                  instance becomes the &lt;em&gt;result resource bundle&lt;/em&gt;.  &lt;/ul&gt;
                  &lt;p&gt;This continues until a result resource bundle is instantiated or the
                  list of candidate bundle names is exhausted.  If no matching resource
                  bundle is found, the default control&apos;s {@link Control#getFallbackLocalegetFallbackLocale} method is called, which returns the current default
                  locale.  A new sequence of candidate locale names is generated using this
                  locale and and searched again, as above.
                  &lt;p&gt;If still no result bundle is found, the base name alone is looked up. If
                  this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.
                  &lt;p&gt;&lt;a name=&quot;parent_chain&quot;/&gt; Once a result resource bundle has been found,
                  its &lt;em&gt;parent chain&lt;/em&gt; is instantiated.  If the result bundle already
                  has a parent (perhaps because it was returned from a cache) the chain is
                  complete.
                  &lt;p&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; examines the remainder of the
                  candidate locale list that was used during the pass that generated the
                  result resource bundle.  (As before, candidate bundle names where the
                  final component is an empty string are omitted.)  When it comes to the
                  end of the candidate list, it tries the plain bundle name.  With each of the
                  candidate bundle names it attempts to instantiate a resource bundle (first
                  looking for a class and then a properties file, as described above).
                  &lt;p&gt;Whenever it succeeds, it calls the previously instantiated resource
                  bundle&apos;s {@link #setParent(java.util.ResourceBundle) setParent} method
                  with the new resource bundle.  This continues until the list of names
                  is exhausted or the current bundle already has a non-null parent.
                  &lt;p&gt;Once the parent chain is complete, the bundle is returned.
                  &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;code&gt;getBundle&lt;/code&gt; caches instantiated resource
                  bundles and might return the same resource bundle instance multiple times.
                  &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;The &lt;code&gt;baseName&lt;/code&gt; argument should be a fully
                  qualified class name. However, for compatibility with earlier versions,
                  Sun&apos;s Java SE Runtime Environments do not verify this, and so it is
                  possible to access &lt;code&gt;PropertyResourceBundle&lt;/code&gt;s by specifying a
                  path name (using &quot;/&quot;) instead of a fully qualified class name (using
                  &quot;.&quot;).
                  &lt;p&gt;&lt;a name=&quot;default_behavior_example&quot;/&gt;
                  &lt;strong&gt;Example:&lt;/strong&gt;
                  &lt;p&gt;
                  The following class and property files are provided:
                  &lt;pre&gt;
                  MyResources.class
                  MyResources.properties
                  MyResources_fr.properties
                  MyResources_fr_CH.class
                  MyResources_fr_CH.properties
                  MyResources_en.properties
                  MyResources_es_ES.class
                  &lt;/pre&gt;
                  The contents of all files are valid (that is, public non-abstract
                  subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt; for the &quot;.class&quot; files,
                  syntactically correct &quot;.properties&quot; files).  The default locale is
                  &lt;code&gt;Locale(&quot;en&quot;, &quot;GB&quot;)&lt;/code&gt;.
                  &lt;p&gt;Calling &lt;code&gt;getBundle&lt;/code&gt; with the locale arguments below will
                  instantiate resource bundles as follows:
                  &lt;table&gt;
                  &lt;tr&gt;&lt;td&gt;Locale(&quot;fr&quot;, &quot;CH&quot;)&lt;/td&gt;&lt;td&gt;MyResources_fr_CH.class, parent MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;Locale(&quot;fr&quot;, &quot;FR&quot;)&lt;/td&gt;&lt;td&gt;MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/td&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;Locale(&quot;en&quot;, &quot;US&quot;)&lt;/td&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;Locale(&quot;es&quot;, &quot;ES&quot;)&lt;/td&gt;&lt;td&gt;MyResources_es_ES.class, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;p&gt;The file MyResources_fr_CH.properties is never used because it is
                  hidden by the MyResources_fr_CH.class. Likewise, MyResources.properties
                  is also hidden by MyResources.class.                
                <param>
                    baseName the base name of the resource bundle, a fully qualified class name                    
                </param>
                <param>
                    locale the locale for which a resource bundle is desired                    
                </param>
                <param>
                    loader the class loader from which to load the resource bundle                    
                </param>
                <return>
                    a resource bundle for the given base name and locale                    
                </return>
                <exception>
                    java.lang.NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <exception>
                    MissingResourceExceptionif no resource bundle for the specified base name can be found                    
                </exception>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="getBundle" type="ResourceBundle" line="1024">
                <params>
                    <param name="baseName" type="String"/>
                    <param name="locale" type="Locale"/>
                    <param name="loader" type="ClassLoader"/>
                </params>
                <scope line="1025"/>
            </method>
            <javadoc line="1031">
                Returns a resource bundle using the specified base name, target
                  locale, class loader and control. Unlike the {@linkplain #getBundle(String,Locale,ClassLoader) &lt;code&gt;getBundle&lt;/code&gt;
                  factory methods with no &lt;code&gt;control&lt;/code&gt; argument}, the given
                  &lt;code&gt;control&lt;/code&gt; specifies how to locate and instantiate resource
                  bundles. Conceptually, the bundle loading process with the given
                  &lt;code&gt;control&lt;/code&gt; is performed in the following steps.
                  &lt;p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;This factory method looks up the resource bundle in the cache for
                  the specified &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt; and
                  &lt;code&gt;loader&lt;/code&gt;.  If the requested resource bundle instance is
                  found in the cache and the time-to-live periods of the instance and
                  all of its parent instances have not expired, the instance is returned
                  to the caller. Otherwise, this factory method proceeds with the
                  loading process below.&lt;/li&gt;
                  &lt;li&gt;The {@link ResourceBundle.Control#getFormats(String)control.getFormats} method is called to get resource bundle formats
                  to produce bundle or resource names. The strings
                  &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;
                  designate class-based and {@linkplain PropertyResourceBundleproperty}-based resource bundles, respectively. Other strings
                  starting with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions
                  and must not be used for application-defined formats. Other strings
                  designate application-defined formats.&lt;/li&gt;
                  &lt;li&gt;The {@link ResourceBundle.Control#getCandidateLocales(String,Locale) control.getCandidateLocales} method is called with the target
                  locale to get a list of &lt;em&gt;candidate &lt;code&gt;Locale&lt;/code&gt;s&lt;/em&gt; for
                  which resource bundles are searched.&lt;/li&gt;
                  &lt;li&gt;The {@link ResourceBundle.Control#newBundle(String,Locale,String,ClassLoader,boolean) control.newBundle} method is called to
                  instantiate a &lt;code&gt;ResourceBundle&lt;/code&gt; for the base bundle name, a
                  candidate locale, and a format. (Refer to the note on the cache
                  lookup below.) This step is iterated over all combinations of the
                  candidate locales and formats until the &lt;code&gt;newBundle&lt;/code&gt; method
                  returns a &lt;code&gt;ResourceBundle&lt;/code&gt; instance or the iteration has
                  used up all the combinations. For example, if the candidate locales
                  are &lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;, &lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt; and
                  &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; and the formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;
                  and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, then the following is the
                  sequence of locale-format combinations to be used to call
                  &lt;code&gt;control.newBundle&lt;/code&gt;.
                  &lt;table style=&quot;width: 50%; text-align: left; margin-left: 40px;&quot;
                  border=&quot;0&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
                  &lt;tbody&gt;&lt;code&gt;
                  &lt;tr&gt;
                  &lt;td
                  style=&quot;vertical-align: top; text-align: left; font-weight: bold; width: 50%;&quot;&gt;Locale&lt;br&gt;
                  &lt;/td&gt;
                  &lt;td
                  style=&quot;vertical-align: top; text-align: left; font-weight: bold; width: 50%;&quot;&gt;format&lt;br&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;br&gt;
                  &lt;/td&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;java.class&lt;br&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/td&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;java.properties&lt;br&gt;
                  &lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;Locale(&quot;de&quot;)&lt;/td&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;java.class&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;Locale(&quot;de&quot;)&lt;/td&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;java.properties&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;Locale(&quot;&quot;)&lt;br&gt;
                  &lt;/td&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;java.class&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;Locale(&quot;&quot;)&lt;/td&gt;
                  &lt;td style=&quot;vertical-align: top; width: 50%;&quot;&gt;java.properties&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/code&gt;&lt;/tbody&gt;
                  &lt;/table&gt;
                  &lt;/li&gt;
                  &lt;li&gt;If the previous step has found no resource bundle, proceed to
                  Step 6. If a bundle has been found that is a base bundle (a bundle
                  for &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;), and the candidate locale list only contained
                  &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;, return the bundle to the caller. If a bundle
                  has been found that is a base bundle, but the candidate locale list
                  contained locales other than Locale(&quot;&quot;), put the bundle on hold and
                  proceed to Step 6. If a bundle has been found that is not a base
                  bundle, proceed to Step 7.&lt;/li&gt;
                  &lt;li&gt;The {@link ResourceBundle.Control#getFallbackLocale(String,Locale) control.getFallbackLocale} method is called to get a fallback
                  locale (alternative to the current target locale) to try further
                  finding a resource bundle. If the method returns a non-null locale,
                  it becomes the next target locale and the loading process starts over
                  from Step 3. Otherwise, if a base bundle was found and put on hold in
                  a previous Step 5, it is returned to the caller now. Otherwise, a
                  MissingResourceException is thrown.&lt;/li&gt;
                  &lt;li&gt;At this point, we have found a resource bundle that&apos;s not the
                  base bundle. If this bundle set its parent during its instantiation,
                  it is returned to the caller. Otherwise, its &lt;a
                  href=&quot;./ResourceBundle.html#parent_chain&quot;&gt;parent chain&lt;/a&gt; is
                  instantiated based on the list of candidate locales from which it was
                  found. Finally, the bundle is returned to the caller.&lt;/li&gt;
                  &lt;/ol&gt;
                  &lt;p&gt;During the resource bundle loading process above, this factory
                  method looks up the cache before calling the {@link Control#newBundle(String,Locale,String,ClassLoader,boolean)control.newBundle} method.  If the time-to-live period of the
                  resource bundle found in the cache has expired, the factory method
                  calls the {@link ResourceBundle.Control#needsReload(String,Locale,String,ClassLoader,ResourceBundle,long) control.needsReload}method to determine whether the resource bundle needs to be reloaded.
                  If reloading is required, the factory method calls
                  &lt;code&gt;control.newBundle&lt;/code&gt; to reload the resource bundle.  If
                  &lt;code&gt;control.newBundle&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the factory
                  method puts a dummy resource bundle in the cache as a mark of
                  nonexistent resource bundles in order to avoid lookup overhead for
                  subsequent requests. Such dummy resource bundles are under the same
                  expiration control as specified by &lt;code&gt;control&lt;/code&gt;.
                  &lt;p&gt;All resource bundles loaded are cached by default. Refer to{@link Control#getTimeToLive(String,Locale)control.getTimeToLive} for details.
                  &lt;p&gt;The following is an example of the bundle loading process with the
                  default &lt;code&gt;ResourceBundle.Control&lt;/code&gt; implementation.
                  &lt;p&gt;Conditions:
                  &lt;ul&gt;
                  &lt;li&gt;Base bundle name: &lt;code&gt;foo.bar.Messages&lt;/code&gt;
                  &lt;li&gt;Requested &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#ITALY}&lt;/li&gt;
                  &lt;li&gt;Default &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#FRENCH}&lt;/li&gt;
                  &lt;li&gt;Available resource bundles:
                  &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and
                  &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;First, &lt;code&gt;getBundle&lt;/code&gt; tries loading a resource bundle in
                  the following sequence.
                  &lt;ul&gt;
                  &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it_IT&lt;/code&gt;
                  &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it_IT.properties&lt;/code&gt;
                  &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it.properties&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;At this point, &lt;code&gt;getBundle&lt;/code&gt; finds
                  &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;, which is put on hold
                  because it&apos;s the base bundle.  &lt;code&gt;getBundle&lt;/code&gt; calls {@link Control#getFallbackLocale(String,Locale)control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)} which
                  returns &lt;code&gt;Locale.FRENCH&lt;/code&gt;. Next, &lt;code&gt;getBundle&lt;/code&gt;
                  tries loading a bundle in the following sequence.
                  &lt;ul&gt;
                  &lt;li&gt;class &lt;code&gt;foo.bar.Messages_fr&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;file &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; finds
                  &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and creates a
                  &lt;code&gt;ResourceBundle&lt;/code&gt; instance. Then, &lt;code&gt;getBundle&lt;/code&gt;
                  sets up its parent chain from the list of the candiate locales.  Only
                  &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt; is found in the list and
                  &lt;code&gt;getBundle&lt;/code&gt; creates a &lt;code&gt;ResourceBundle&lt;/code&gt; instance
                  that becomes the parent of the instance for
                  &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;.                
                <param>
                    baseNamethe base name of the resource bundle, a fully qualified
                      class name                    
                </param>
                <param>
                    targetLocalethe locale for which a resource bundle is desired                    
                </param>
                <param>
                    loaderthe class loader from which to load the resource bundle                    
                </param>
                <param>
                    controlthe control which gives information for the resource
                      bundle loading process                    
                </param>
                <return>
                    a resource bundle for the given base name and locale                    
                </return>
                <exception>
                    NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt;,
                      &lt;code&gt;loader&lt;/code&gt;, or &lt;code&gt;control&lt;/code&gt; is
                      &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <exception>
                    MissingResourceExceptionif no resource bundle for the specified base name can be found                    
                </exception>
                <exception>
                    IllegalArgumentExceptionif the given &lt;code&gt;control&lt;/code&gt; doesn&apos;t perform properly
                      (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)
                      Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as
                      needed.                    
                </exception>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getBundle" type="ResourceBundle" line="1242">
                <params>
                    <param name="baseName" type="String"/>
                    <param name="targetLocale" type="Locale"/>
                    <param name="loader" type="ClassLoader"/>
                    <param name="control" type="Control"/>
                </params>
                <scope line="1243"/>
            </method>
            <method name="getBundleImpl" type="ResourceBundle" line="1250">
                <params>
                    <param name="baseName" type="String"/>
                    <param name="locale" type="Locale"/>
                    <param name="loader" type="ClassLoader"/>
                    <param name="control" type="Control"/>
                </params>
                <comment line="1256">
                    We create a CacheKey here for use by this call. The base
                     name and loader will never change during the bundle loading
                     process. We have to make sure that the locale is set before
                     using it as a cache key.                    
                </comment>
                <comment line="1263">
                    Quick lookup of the cache.                    
                </comment>
                <comment line="1270">
                    If this bundle and all of its parents are valid (not expired),
                     then return this bundle. If any of the bundles is expired, we
                     don&apos;t call control.needsReload here but instead drop into the
                     complete loading process below.                    
                </comment>
                <comment line="1278">
                    No valid bundle was found in the cache, so we need to load the
                     resource bundle and its parents.                    
                </comment>
                <comment line="1299">
                    If the loaded bundle is the base bundle and exactly for the
                     requested locale or the only candidate locale, then take the
                     bundle as the resulting one. If the loaded bundle is the base
                     bundle, it&apos;s put on hold until we finish processing all
                     fallback locales.                    
                </comment>
                <comment line="1312">
                    If the base bundle has been loaded, keep the reference in
                     baseBundle so that we can avoid any redundant loading in case
                     the control specify not to cache bundles.                    
                </comment>
                <scope line="1251"/>
                <declaration name="cacheKey" type="CacheKey" line="1259"/>
                <declaration name="bundle" type="ResourceBundle" line="1260"/>
                <declaration name="bundleRef" type="BundleReference" line="1263"/>
                <scope line="1264"/>
                <scope line="1273"/>
                <declaration name="isKnownControl" type="boolean" line="1280"/>
                <declaration name="formats" type="List&lt;String&gt;" line="1282"/>
                <scope line="1283"/>
                <declaration name="baseBundle" type="ResourceBundle" line="1287"/>
                <scope line="1290">
                    <declaration name="candidateLocales" type="List&lt;Locale&gt;" line="1291"/>
                    <scope line="1292"/>
                    <scope line="1303">
                        <declaration name="isBaseBundle" type="boolean" line="1304"/>
                        <scope line="1307"/>
                        <scope line="1314"/>
                    </scope>
                </scope>
                <scope line="1320">
                    <scope line="1321"/>
                </scope>
            </method>
            <javadoc line="1330">
                Checks if the given &lt;code&gt;List&lt;/code&gt; is not null, not empty,
                  not having null in its elements.                
            </javadoc>
            <method name="checkList" type="boolean" line="1334">
                <params>
                    <param name="a" type="List"/>
                </params>
                <declaration name="valid" type="boolean" line="1335"/>
                <scope line="1336">
                    <declaration name="size" type="int" line="1337"/>
                    <scope line="1338"/>
                </scope>
            </method>
            <method name="findBundle" type="ResourceBundle" line="1350">
                <params>
                    <param name="cacheKey" type="CacheKey"/>
                    <param name="candidateLocales" type="List<Locale>"/>
                    <param name="formats" type="List<String>"/>
                    <param name="index" type="int"/>
                    <param name="control" type="Control"/>
                    <param name="baseBundle" type="ResourceBundle"/>
                </params>
                <comment line="1361">
                    Before we do the real loading work, see whether we need to
                     do some housekeeping: If references to class loaders or
                     resource bundles have been nulled out, remove all related
                     information from the cache.                    
                </comment>
                <comment line="1370">
                    flag indicating the resource bundle has expired in the cache                    
                </comment>
                <comment line="1373">
                    First, look up the cache to see if it&apos;s in the cache, without
                     attempting to load bundle.                    
                </comment>
                <comment line="1380">
                    If its parent is the one asked for by the candidate
                     locales (the runtime lookup path), we can take the cached
                     one. (If it&apos;s not identical, then we&apos;d have to check the
                     parent&apos;s parents to be consistent with what&apos;s been
                     requested.)                    
                </comment>
                <comment line="1388">
                    Otherwise, remove the cached one since we can&apos;t keep
                     the same bundles having different parents.                    
                </comment>
                <comment line="1411">
                    Put NONEXISTENT_BUNDLE in the cache as a mark that there&apos;s no bundle
                     instance for the locale.                    
                </comment>
                <declaration name="targetLocale" type="Locale" line="1351"/>
                <declaration name="parent" type="ResourceBundle" line="1352"/>
                <scope line="1353"/>
                <scope line="1356"/>
                <declaration name="ref" type="Object" line="1364"/>
                <scope line="1365"/>
                <declaration name="expiredBundle" type="boolean" line="1370"/>
                <declaration name="bundle" type="ResourceBundle" line="1375"/>
                <scope line="1376">
                    <scope line="1378">
                        <scope line="1384"/>
                        <declaration name="bundleRef" type="BundleReference" line="1389"/>
                        <scope line="1390"/>
                    </scope>
                </scope>
                <scope line="1396">
                    <declaration name="constKey" type="CacheKey" line="1397"/>
                    <scope line="1399">
                        <scope line="1401">
                            <scope line="1402"/>
                        </scope>
                    </scope>
                    <scope line="1413">
                        <scope line="1414"/>
                    </scope>
                </scope>
            </method>
            <method name="loadBundle" type="ResourceBundle" line="1425">
                <params>
                    <param name="cacheKey" type="CacheKey"/>
                    <param name="formats" type="List<String>"/>
                    <param name="control" type="Control"/>
                    <param name="reload" type="boolean"/>
                </params>
                <comment line="1428">
                    Here we actually load the bundle in the order of formats
                     specified by the getFormats() value.                    
                </comment>
                <comment line="1440">
                    We need to handle the LinkageError case due to
                     inconsistent case-sensitivity in ClassLoader.
                     See 6572242 for details.                    
                </comment>
                <comment line="1448">
                    Set the format in the cache key so that it can be
                     used when calling needsReload later.                    
                </comment>
                <comment line="1453">
                    Bundle provider might reuse instances. So we should make
                     sure to clear the expired flag here.                    
                </comment>
                <declaration name="targetLocale" type="Locale" line="1429"/>
                <declaration name="bundle" type="ResourceBundle" line="1431"/>
                <declaration name="size" type="int" line="1432"/>
                <scope line="1433">
                    <declaration name="format" type="String" line="1434"/>
                    <scope line="1435"/>
                    <scope line="1438"/>
                    <scope line="1443"/>
                    <scope line="1446"/>
                </scope>
            </method>
            <method name="isValidBundle" type="boolean" line="1462">
                <params>
                    <param name="bundle" type="ResourceBundle"/>
                </params>
            </method>
            <javadoc line="1466">
                Determines whether any of resource bundles in the parent chain,
                  including the leaf, have expired.                
            </javadoc>
            <method name="hasValidParentChain" type="boolean" line="1470">
                <params>
                    <param name="bundle" type="ResourceBundle"/>
                </params>
                <declaration name="now" type="long" line="1471"/>
                <scope line="1472">
                    <scope line="1473"/>
                    <declaration name="key" type="CacheKey" line="1476"/>
                    <scope line="1477">
                        <declaration name="expirationTime" type="long" line="1478"/>
                        <scope line="1479"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1488">
                Throw a MissingResourceException with proper message                
            </javadoc>
            <method name="throwMissingResourceException" type="void" line="1493">
                <params>
                    <param name="baseName" type="String"/>
                    <param name="locale" type="Locale"/>
                    <param name="cause" type="Throwable"/>
                </params>
                <comment line="1495">
                    If the cause is a MissingResourceException, avoid creating
                     a long chain. (6355009)                    
                </comment>
                <comment line="1502">
                    className                    
                </comment>
                <comment line="1503">
                    key                    
                </comment>
                <scope line="1496"/>
            </method>
            <javadoc line="1506">
                Finds a bundle in the cache. Any expired bundles are marked as
                  `expired&apos; and removed from the cache upon return.                
                <param>
                    cacheKey the key to look up the cache                    
                </param>
                <param>
                    control the Control to be used for the expiration control                    
                </param>
                <return>
                    the cached bundle, or null if the bundle is not found in the
                      cache or its parent has expired. &lt;code&gt;bundle.expire&lt;/code&gt; is true
                      upon return if the bundle in the cache has expired.                    
                </return>
            </javadoc>
            <method name="findBundleInCache" type="ResourceBundle" line="1517">
                <params>
                    <param name="cacheKey" type="CacheKey"/>
                    <param name="control" type="Control"/>
                </params>
                <comment line="1529">
                    If the parent has expired, then this one must also expire. We
                     check only the immediate parent because the actual loading is
                     done from the root (base) to leaf (child) and the purpose of
                     checking is to propagate expiration towards the leaf. For
                     example, if the requested locale is ja_JP_JP and there are
                     bundles for all of the candidates in the cache, we have a list,
                    
                     base &lt;- ja &lt;- ja_JP &lt;- ja_JP_JP
                    
                     If ja has expired, then it will reload ja and the list becomes a
                     tree.
                    
                     base &lt;- ja (new)
                      &quot;   &lt;- ja (expired) &lt;- ja_JP &lt;- ja_JP_JP
                    
                     When looking up ja_JP in the cache, it finds ja_JP in the cache
                     which references to the expired ja. Then, ja_JP is marked as
                     expired and removed from the cache. This will be propagated to
                     ja_JP_JP.
                    
                     Now, it&apos;s possible, for example, that while loading new ja_JP,
                     someone else has started loading the same bundle and finds the
                     base bundle has expired. Then, what we get from the first
                     getBundle call includes the expired base bundle. However, if
                     someone else didn&apos;t start its loading, we wouldn&apos;t know if the
                     base bundle has expired at the end of the loading process. The
                     expiration control doesn&apos;t guarantee that the returned bundle and
                     its parents haven&apos;t expired.
                    
                     We could check the entire parent chain to see if there&apos;s any in
                     the chain that has expired. But this process may never end. An
                     extreme case would be that getTimeToLive returns 0 and
                     needsReload always returns true.                    
                </comment>
                <comment line="1573">
                    its TTL period has expired.                    
                </comment>
                <comment line="1575">
                    Synchronize here to call needsReload to avoid
                     redundant concurrent calls for the same bundle.                    
                </comment>
                <comment line="1592">
                    If the bundle needs to be reloaded, then
                     remove the bundle from the cache, but
                     return the bundle with the expired flag
                     on.                    
                </comment>
                <comment line="1599">
                    Update the expiration control info. and reuse
                     the same bundle instance                    
                </comment>
                <comment line="1606">
                    We just remove NONEXISTENT_BUNDLE from the cache.                    
                </comment>
                <declaration name="bundleRef" type="BundleReference" line="1518"/>
                <scope line="1519"/>
                <declaration name="bundle" type="ResourceBundle" line="1522"/>
                <scope line="1523"/>
                <declaration name="p" type="ResourceBundle" line="1526"/>
                <scope line="1561"/>
                <scope line="1567">
                    <declaration name="key" type="CacheKey" line="1568"/>
                    <declaration name="expirationTime" type="long" line="1569"/>
                    <scope line="1571">
                        <scope line="1573">
                            <scope line="1576">
                                <scope line="1579">
                                    <scope line="1580"/>
                                    <scope line="1587"/>
                                    <scope line="1590"/>
                                    <scope line="1597"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="1604"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1614">
                Put a new bundle in the cache.                
                <param>
                    cacheKey the key for the resource bundle                    
                </param>
                <param>
                    bundle the resource bundle to be put in the cache                    
                </param>
                <return>
                    the ResourceBundle for the cacheKey; if someone has put
                      the bundle before this call, the one found in the cache is
                      returned.                    
                </return>
            </javadoc>
            <method name="putBundleInCache" type="ResourceBundle" line="1625">
                <params>
                    <param name="cacheKey" type="CacheKey"/>
                    <param name="bundle" type="ResourceBundle"/>
                    <param name="control" type="Control"/>
                </params>
                <comment line="1633">
                    Put the bundle in the cache if it&apos;s not been in the cache.                    
                </comment>
                <comment line="1636">
                    If someone else has put the same bundle in the cache before
                     us and it has not expired, we should use the one in the cache.                    
                </comment>
                <comment line="1641">
                    Clear the back link to the cache key                    
                </comment>
                <comment line="1644">
                    Clear the reference in the BundleReference so that
                     it won&apos;t be enqueued.                    
                </comment>
                <comment line="1648">
                    Replace the invalid (garbage collected or expired)
                     instance with the valid one.                    
                </comment>
                <scope line="1627">
                    <declaration name="key" type="CacheKey" line="1628"/>
                    <declaration name="bundleRef" type="BundleReference" line="1629"/>
                    <declaration name="result" type="BundleReference" line="1633"/>
                    <scope line="1637">
                        <declaration name="rb" type="ResourceBundle" line="1638"/>
                        <scope line="1639"/>
                        <scope line="1646"/>
                    </scope>
                </scope>
            </method>
            <method name="setExpirationTime" type="void" line="1656">
                <params>
                    <param name="cacheKey" type="CacheKey"/>
                    <param name="control" type="Control"/>
                </params>
                <comment line="1661">
                    If any expiration time is specified, set the time to be
                     expired in the cache.                    
                </comment>
                <declaration name="ttl" type="long" line="1657"/>
                <scope line="1659">
                    <declaration name="now" type="long" line="1662"/>
                </scope>
                <scope line="1665"/>
                <scope line="1667"/>
            </method>
            <javadoc line="1672">
                Removes all resource bundles from the cache that have been loaded
                  using the caller&apos;s class loader.                
                <since>
                    1.6                    
                </since>
                <see>
                    ResourceBundle.Control#getTimeToLive(String,Locale)                    
                </see>
            </javadoc>
            <method name="clearCache" type="void" line="1679"/>
            <javadoc line="1683">
                Removes all resource bundles from the cache that have been loaded
                  using the given class loader.                
                <param>
                    loader the class loader                    
                </param>
                <exception>
                    NullPointerException if &lt;code&gt;loader&lt;/code&gt; is null                    
                </exception>
                <since>
                    1.6                    
                </since>
                <see>
                    ResourceBundle.Control#getTimeToLive(String,Locale)                    
                </see>
            </javadoc>
            <method name="clearCache" type="void" line="1692">
                <params>
                    <param name="loader" type="ClassLoader"/>
                </params>
                <scope line="1693"/>
                <declaration name="set" type="Set&lt;CacheKey&gt;" line="1696"/>
                <scope line="1697">
                    <scope line="1698"/>
                </scope>
            </method>
            <method name="handleGetObject" type="Object" line="1704"/>
            <javadoc line="1704">
                Gets an object for the given key from this resource bundle.
                  Returns null if this resource bundle does not contain an
                  object for the given key.                
                <param>
                    key the key for the desired object                    
                </param>
                <exception>
                    NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <return>
                    the object for the given key, or null                    
                </return>
            </javadoc>
            <method name="getKeys" type="Enumeration<String>" line="1715"/>
            <javadoc line="1715">
                Returns an enumeration of the keys.                
                <return>
                    an &lt;code&gt;Enumeration&lt;/code&gt; of the keys contained in
                      this &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.                    
                </return>
            </javadoc>
            <javadoc line="1723">
                Determines whether the given &lt;code&gt;key&lt;/code&gt; is contained in
                  this &lt;code&gt;ResourceBundle&lt;/code&gt; or its parent bundles.                
                <param>
                    keythe resource &lt;code&gt;key&lt;/code&gt;                    
                </param>
                <return>
                    &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;key&lt;/code&gt; is
                      contained in this &lt;code&gt;ResourceBundle&lt;/code&gt; or its
                      parent bundles; &lt;code&gt;false&lt;/code&gt; otherwise.                    
                </return>
                <exception>
                    NullPointerExceptionif &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </exception>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="containsKey" type="boolean" line="1736">
                <params>
                    <param name="key" type="String"/>
                </params>
                <scope line="1737"/>
                <scope line="1740">
                    <scope line="1741"/>
                </scope>
            </method>
            <javadoc line="1748">
                Returns a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this
                  &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.                
                <return>
                    a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this
                      &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="keySet" type="Set<String>" line="1756">
                <declaration name="keys" type="Set&lt;String&gt;" line="1757"/>
                <scope line="1758"/>
            </method>
            <javadoc line="1764">
                Returns a &lt;code&gt;Set&lt;/code&gt; of the keys contained &lt;em&gt;only&lt;/em&gt;
                  in this &lt;code&gt;ResourceBundle&lt;/code&gt;.
                  &lt;p&gt;The default implementation returns a &lt;code&gt;Set&lt;/code&gt; of the
                  keys returned by the {@link #getKeys() getKeys} method except
                  for the ones for which the {@link #handleGetObject(String)handleGetObject} method returns &lt;code&gt;null&lt;/code&gt;. Once the
                  &lt;code&gt;Set&lt;/code&gt; has been created, the value is kept in this
                  &lt;code&gt;ResourceBundle&lt;/code&gt; in order to avoid producing the
                  same &lt;code&gt;Set&lt;/code&gt; in subsequent calls. Subclasses can
                  override this method for faster handling.                
                <return>
                    a &lt;code&gt;Set&lt;/code&gt; of the keys contained only in this
                      &lt;code&gt;ResourceBundle&lt;/code&gt;                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="handleKeySet" type="Set<String>" line="1781">
                <scope line="1782">
                    <scope line="1783">
                        <scope line="1784">
                            <declaration name="keys" type="Set&lt;String&gt;" line="1785"/>
                            <declaration name="enumKeys" type="Enumeration&lt;String&gt;" line="1786"/>
                            <scope line="1787">
                                <declaration name="key" type="String" line="1788"/>
                                <scope line="1789"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <class name="Control" line="1802">
                <comment line="493">
                    These three are the actual keys for lookup in Map.                    
                </comment>
                <comment line="498">
                    bundle format which is necessary for calling
                     Control.needsReload().                    
                </comment>
                <comment line="502">
                    These time values are in CacheKey so that NONEXISTENT_BUNDLE
                     doesn&apos;t need to be cloned for caching.                    
                </comment>
                <comment line="505">
                    The time when the bundle has been loaded                    
                </comment>
                <comment line="508">
                    The time when the bundle expires in the cache, or either
                     Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.                    
                </comment>
                <comment line="512">
                    Placeholder for an error report by a Throwable                    
                </comment>
                <comment line="515">
                    Hash code value cache to avoid recalculating the hash code
                     of this instance.                    
                </comment>
                <javadoc line="1802">
                    &lt;code&gt;ResourceBundle.Control&lt;/code&gt; defines a set of callback methods
                      that are invoked by the {@link ResourceBundle#getBundle(String,Locale,ClassLoader,Control) ResourceBundle.getBundle} factory
                      methods during the bundle loading process. In other words, a
                      &lt;code&gt;ResourceBundle.Control&lt;/code&gt; collaborates with the factory
                      methods for loading resource bundles. The default implementation of
                      the callback methods provides the information necessary for the
                      factory methods to perform the &lt;a
                      href=&quot;./ResourceBundle.html#default_behavior&quot;&gt;default behavior&lt;/a&gt;.
                      &lt;p&gt;In addition to the callback methods, the {@link #toBundleName(String,Locale) toBundleName} and {@link #toResourceName(String,String) toResourceName} methods are defined
                      primarily for convenience in implementing the callback
                      methods. However, the &lt;code&gt;toBundleName&lt;/code&gt; method could be
                      overridden to provide different conventions in the organization and
                      packaging of localized resources.  The &lt;code&gt;toResourceName&lt;/code&gt;
                      method is &lt;code&gt;final&lt;/code&gt; to avoid use of wrong resource and class
                      name separators.
                      &lt;p&gt;Two factory methods, {@link #getControl(List)} and {@link #getNoFallbackControl(List)}, provide
                      &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances that implement common
                      variations of the default bundle loading process.
                      &lt;p&gt;The formats returned by the {@link Control#getFormats(String)getFormats} method and candidate locales returned by the {@link ResourceBundle.Control#getCandidateLocales(String,Locale)getCandidateLocales} method must be consistent in all
                      &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; invocations for the same base
                      bundle. Otherwise, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; methods
                      may return unintended bundles. For example, if only
                      &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; is returned by the &lt;code&gt;getFormats&lt;/code&gt;
                      method for the first call to &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;
                      and only &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for the second call, then the
                      second call will return the class-based one that has been cached
                      during the first call.
                      &lt;p&gt;A &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instance must be thread-safe
                      if it&apos;s simultaneously used by multiple threads.
                      &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; does not synchronize to call
                      the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; methods. The default
                      implementations of the methods are thread-safe.
                      &lt;p&gt;Applications can specify &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
                      instances returned by the &lt;code&gt;getControl&lt;/code&gt; factory methods or
                      created from a subclass of &lt;code&gt;ResourceBundle.Control&lt;/code&gt; to
                      customize the bundle loading process. The following are examples of
                      changing the default bundle loading process.
                      &lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;
                      &lt;p&gt;The following code lets &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; look
                      up only properties-based resources.
                      &lt;pre&gt;
                      import java.util.;
                      import static java.util.ResourceBundle.Control.;
                      ...
                      ResourceBundle bundle =
                      ResourceBundle.getBundle(&quot;MyResources&quot;, new Locale(&quot;fr&quot;, &quot;CH&quot;),
                      ResourceBundle.Control.getControl(FORMAT_PROPERTIES));
                      &lt;/pre&gt;
                      Given the resource bundles in the &lt;a
                      href=&quot;./ResourceBundle.html#default_behavior_example&quot;&gt;example&lt;/a&gt; in
                      the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; description, this
                      &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; call loads
                      &lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt; whose parent is
                      &lt;code&gt;MyResources_fr.properties&lt;/code&gt; whose parent is
                      &lt;code&gt;MyResources.properties&lt;/code&gt;. (&lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt;
                      is not hidden, but &lt;code&gt;MyResources_fr_CH.class&lt;/code&gt; is.)
                      &lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;
                      &lt;p&gt;The following is an example of loading XML-based bundles
                      using {@link Properties#loadFromXML(java.io.InputStream)Properties.loadFromXML}.
                      &lt;pre&gt;
                      ResourceBundle rb = ResourceBundle.getBundle(&quot;Messages&quot;,
                      new ResourceBundle.Control() {
                      public List&amp;lt;String&amp;gt; getFormats(String baseName) {
                      if (baseName == null)
                      throw new NullPointerException();
                      return Arrays.asList(&quot;xml&quot;);
                      }
                      public ResourceBundle newBundle(String baseName,
                      Locale locale,
                      String format,
                      ClassLoader loader,
                      boolean reload)
                      throws IllegalAccessException,
                      InstantiationException,
                      IOException {
                      if (baseName == null || locale == null
                      || format == null || loader == null)
                      throw new NullPointerException();
                      ResourceBundle bundle = null;
                      if (format.equals(&quot;xml&quot;)) {
                      String bundleName = toBundleName(baseName, locale);
                      String resourceName = toResourceName(bundleName, format);
                      InputStream stream = null;
                      if (reload) {
                      URL url = loader.getResource(resourceName);
                      if (url != null) {
                      URLConnection connection = url.openConnection();
                      if (connection != null) {
                      // Disable caches to get fresh data for
                      // reloading.
                      connection.setUseCaches(false);
                      stream = connection.getInputStream();
                      }
                      }
                      } else {
                      stream = loader.getResourceAsStream(resourceName);
                      }
                      if (stream != null) {
                      BufferedInputStream bis = new BufferedInputStream(stream);
                      bundle = new XMLResourceBundle(bis);
                      bis.close();
                      }
                      }
                      return bundle;
                      }
                      });
                      ...
                      private static class XMLResourceBundle extends ResourceBundle {
                      private Properties props;
                      XMLResourceBundle(InputStream stream) throws IOException {
                      props = new Properties();
                      props.loadFromXML(stream);
                      }
                      protected Object handleGetObject(String key) {
                      return props.getProperty(key);
                      }
                      public Enumeration&amp;lt;String&amp;gt; getKeys() {
                      ...
                      }
                      }
                      &lt;/pre&gt;                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <declaration name="FORMAT_DEFAULT" type="List&lt;String&gt;" line="1950"/>
                <javadoc line="1950">
                    The default format &lt;code&gt;List&lt;/code&gt;, which contains the strings
                      &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, in
                      this order. This &lt;code&gt;List&lt;/code&gt; is {@linkplain Collections#unmodifiableList(List) unmodifiable}.                    
                    <see>
                        #getFormats(String)                        
                    </see>
                </javadoc>
                <declaration name="FORMAT_CLASS" type="List&lt;String&gt;" line="1962"/>
                <javadoc line="1962">
                    The class-only format &lt;code&gt;List&lt;/code&gt; containing
                      &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is {@linkplain Collections#unmodifiableList(List) unmodifiable}.                    
                    <see>
                        #getFormats(String)                        
                    </see>
                </javadoc>
                <declaration name="FORMAT_PROPERTIES" type="List&lt;String&gt;" line="1972"/>
                <javadoc line="1972">
                    The properties-only format &lt;code&gt;List&lt;/code&gt; containing
                      &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is{@linkplain Collections#unmodifiableList(List) unmodifiable}.                    
                    <see>
                        #getFormats(String)                        
                    </see>
                </javadoc>
                <declaration name="TTL_DONT_CACHE" type="long" line="1982"/>
                <javadoc line="1982">
                    The time-to-live constant for not caching loaded resource bundle
                      instances.                    
                    <see>
                        #getTimeToLive(String,Locale)                        
                    </see>
                </javadoc>
                <declaration name="TTL_NO_EXPIRATION_CONTROL" type="long" line="1990"/>
                <javadoc line="1990">
                    The time-to-live constant for disabling the expiration control
                      for loaded resource bundle instances in the cache.                    
                    <see>
                        #getTimeToLive(String,Locale)                        
                    </see>
                </javadoc>
                <declaration name="INSTANCE" type="Control" line="1998"/>
                <javadoc line="2000">
                    Sole constructor. (For invocation by subclass constructors,
                      typically implicit.)                    
                </javadoc>
                <method name="Control" type="constructor" line="2004"/>
                <javadoc line="2007">
                    Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link #getFormats(String) getFormats} method returns the specified
                      &lt;code&gt;formats&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must be equal to
                      one of {@link Control#FORMAT_PROPERTIES}, {@link Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}. &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
                      instances returned by this method are singletons and thread-safe.
                      &lt;p&gt;Specifying {@link Control#FORMAT_DEFAULT} is equivalent to
                      instantiating the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; class,
                      except that this method returns a singleton.                    
                    <param>
                        formatsthe formats to be returned by the
                          &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method                        
                    </param>
                    <return>
                        a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the
                          specified &lt;code&gt;formats&lt;/code&gt;                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                        
                    </exception>
                    <exception>
                        IllegalArgumentExceptionif &lt;code&gt;formats&lt;/code&gt; is unknown                        
                    </exception>
                </javadoc>
                <method name="getControl" type="Control" line="2030">
                    <params>
                        <param name="formats" type="List<String>"/>
                    </params>
                    <scope line="2031"/>
                    <scope line="2034"/>
                    <scope line="2037"/>
                </method>
                <javadoc line="2043">
                    Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link #getFormats(String) getFormats} method returns the specified
                      &lt;code&gt;formats&lt;/code&gt; and the {@link Control#getFallbackLocale(String,Locale) getFallbackLocale}method returns &lt;code&gt;null&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must
                      be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
                      &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances returned by this
                      method are singletons and thread-safe.                    
                    <param>
                        formatsthe formats to be returned by the
                          &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method                        
                    </param>
                    <return>
                        a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the
                          specified &lt;code&gt;formats&lt;/code&gt; with no fallback
                          &lt;code&gt;Locale&lt;/code&gt; support                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                        
                    </exception>
                    <exception>
                        IllegalArgumentExceptionif &lt;code&gt;formats&lt;/code&gt; is unknown                        
                    </exception>
                </javadoc>
                <method name="getNoFallbackControl" type="Control" line="2065">
                    <params>
                        <param name="formats" type="List<String>"/>
                    </params>
                    <scope line="2066"/>
                    <scope line="2069"/>
                    <scope line="2072"/>
                </method>
                <javadoc line="2078">
                    Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing
                      formats to be used to load resource bundles for the given
                      &lt;code&gt;baseName&lt;/code&gt;. The &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;
                      factory method tries to load resource bundles with formats in the
                      order specified by the list. The list returned by this method
                      must have at least one &lt;code&gt;String&lt;/code&gt;. The predefined
                      formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; for class-based resource
                      bundles and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for {@linkplain PropertyResourceBundle properties-based} ones. Strings starting
                      with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions and
                      must not be used by application-defined formats.
                      &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
                      &lt;code&gt;List&lt;/code&gt;.  However, the returned &lt;code&gt;List&lt;/code&gt; must
                      not be mutated after it has been returned by
                      &lt;code&gt;getFormats&lt;/code&gt;.
                      &lt;p&gt;The default implementation returns {@link #FORMAT_DEFAULT} so
                      that the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method
                      looks up first class-based resource bundles, then
                      properties-based ones.                    
                    <param>
                        baseNamethe base name of the resource bundle, a fully qualified class
                          name                        
                    </param>
                    <return>
                        a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing
                          formats for loading resource bundles.                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt; is null                        
                    </exception>
                    <see>
                        #FORMAT_DEFAULT                        
                    </see>
                    <see>
                        #FORMAT_CLASS                        
                    </see>
                    <see>
                        #FORMAT_PROPERTIES                        
                    </see>
                </javadoc>
                <method name="getFormats" type="List<String>" line="2112">
                    <params>
                        <param name="baseName" type="String"/>
                    </params>
                    <scope line="2113"/>
                </method>
                <javadoc line="2119">
                    Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s as candidate
                      locales for &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;. This
                      method is called by the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;
                      factory method each time the factory method tries finding a
                      resource bundle for a target &lt;code&gt;Locale&lt;/code&gt;.
                      &lt;p&gt;The sequence of the candidate locales also corresponds to the
                      runtime resource lookup path (also known as the &lt;I&gt;parent
                      chain&lt;/I&gt;), if the corresponding resource bundles for the
                      candidate locales exist and their parents are not defined by
                      loaded resource bundles themselves.  The last element of the list
                      must be a {@linkplain Locale#ROOT root locale} if it is desired to
                      have the base bundle as the terminal of the parent chain.
                      &lt;p&gt;If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the
                      root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root
                      &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the
                      &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only
                      the base bundle as the resulting resource bundle.
                      &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
                      &lt;code&gt;List&lt;/code&gt;. However, the returned &lt;code&gt;List&lt;/code&gt; must not
                      be mutated after it has been returned by
                      &lt;code&gt;getCandidateLocales&lt;/code&gt;.
                      &lt;p&gt;The default implementation returns a &lt;code&gt;List&lt;/code&gt; containing
                      &lt;code&gt;Locale&lt;/code&gt;s using the rules described below.  In the
                      description below, &lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;V&lt;/em&gt;
                      respectively represent non-empty language, script, country, and
                      variant.  For example, [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] represents a
                      &lt;code&gt;Locale&lt;/code&gt; that has non-empty values only for language and
                      country.  The form &lt;em&gt;L&lt;/em&gt;(&quot;xx&quot;) represents the (non-empty)
                      language value is &quot;xx&quot;.  For all cases, &lt;code&gt;Locale&lt;/code&gt;s whose
                      final component values are empty strings are omitted.
                      &lt;ol&gt;&lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with an empty script value,
                      append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component
                      one by one as below:
                      &lt;ul&gt;
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]
                      &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;
                      &lt;/ul&gt;
                      &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a non-empty script value,
                      append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component
                      up to language, then append candidates generated from the
                      &lt;code&gt;Locale&lt;/code&gt; with country and variant restored:
                      &lt;ul&gt;
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]
                      &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;
                      &lt;/ul&gt;
                      &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a variant value consisting
                      of multiple subtags separated by underscore, generate candidate
                      &lt;code&gt;Locale&lt;/code&gt;s by omitting the variant subtags one by one, then
                      insert them after every occurence of &lt;code&gt; Locale&lt;/code&gt;s with the
                      full variant value in the original list.  For example, if the
                      the variant consists of two subtags &lt;em&gt;V1&lt;/em&gt; and &lt;em&gt;V2&lt;/em&gt;:
                      &lt;ul&gt;
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]
                      &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;
                      &lt;/ul&gt;
                      &lt;li&gt;Special cases for Chinese.  When an input &lt;code&gt;Locale&lt;/code&gt; has the
                      language &quot;zh&quot; (Chinese) and an empty script value, either &quot;Hans&quot; (Simplified) or
                      &quot;Hant&quot; (Traditional) might be supplied, depending on the country.
                      When the country is &quot;CN&quot; (China) or &quot;SG&quot; (Singapore), &quot;Hans&quot; is supplied.
                      When the country is &quot;HK&quot; (Hong Kong SAR China), &quot;MO&quot; (Macau SAR China),
                      or &quot;TW&quot; (Taiwan), &quot;Hant&quot; is supplied.  For all other countries or when the country
                      is empty, no script is supplied.  For example, for &lt;code&gt;Locale(&quot;zh&quot;, &quot;CN&quot;)
                      &lt;/code&gt;, the candidate list will be:
                      &lt;ul&gt;
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]
                      &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;
                      &lt;/ul&gt;
                      For &lt;code&gt;Locale(&quot;zh&quot;, &quot;TW&quot;)&lt;/code&gt;, the candidate list will be:
                      &lt;ul&gt;
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]
                      &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;
                      &lt;/ul&gt;
                      &lt;li&gt;Special cases for Norwegian.  Both &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;,
                      &quot;NY&quot;)&lt;/code&gt; and &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; represent Norwegian
                      Nynorsk.  When a locale&apos;s language is &quot;nn&quot;, the standard candidate
                      list is generated up to [&lt;em&gt;L&lt;/em&gt;(&quot;nn&quot;)], and then the following
                      candidates are added:
                      &lt;ul&gt;&lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;NY&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]
                      &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;
                      &lt;/ul&gt;
                      If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first
                      converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is
                      followed.
                      &lt;p&gt;Also, Java treats the language &quot;no&quot; as a synonym of Norwegian
                      Bokm&amp;#xE5;l &quot;nb&quot;.  Except for the single case &lt;code&gt;Locale(&quot;no&quot;,
                      &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; (handled above), when an input &lt;code&gt;Locale&lt;/code&gt;
                      has language &quot;no&quot; or &quot;nb&quot;, candidate &lt;code&gt;Locale&lt;/code&gt;s with
                      language code &quot;no&quot; and &quot;nb&quot; are interleaved, first using the
                      requested language, then using its synonym. For example,
                      &lt;code&gt;Locale(&quot;nb&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; generates the following
                      candidate list:
                      &lt;ul&gt;
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;)]
                      &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]
                      &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;
                      &lt;/ul&gt;
                      &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; would generate the same list
                      except that locales with &quot;no&quot; would appear before the corresponding
                      locales with &quot;nb&quot;.&lt;/li&gt;
                      &lt;/li&gt;
                      &lt;/ol&gt;
                      &lt;p&gt;The default implementation uses an {@link ArrayList} that
                      overriding implementations may modify before returning it to the
                      caller. However, a subclass must not modify it after it has
                      been returned by &lt;code&gt;getCandidateLocales&lt;/code&gt;.
                      &lt;p&gt;For example, if the given &lt;code&gt;baseName&lt;/code&gt; is &quot;Messages&quot;
                      and the given &lt;code&gt;locale&lt;/code&gt; is
                      &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then a
                      &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s:
                      &lt;pre&gt;
                      Locale(&quot;ja&quot;, &quot;&quot;, &quot;XX&quot;)
                      Locale(&quot;ja&quot;)
                      Locale.ROOT
                      &lt;/pre&gt;
                      is returned. And if the resource bundles for the &quot;ja&quot; and
                      &quot;&quot; &lt;code&gt;Locale&lt;/code&gt;s are found, then the runtime resource
                      lookup path (parent chain) is:
                      &lt;pre&gt;
                      Messages_ja -&gt; Messages
                      &lt;/pre&gt;                    
                    <param>
                        baseNamethe base name of the resource bundle, a fully
                          qualified class name                        
                    </param>
                    <param>
                        localethe locale for which a resource bundle is desired                        
                    </param>
                    <return>
                        a &lt;code&gt;List&lt;/code&gt; of candidate
                          &lt;code&gt;Locale&lt;/code&gt;s for the given &lt;code&gt;locale&lt;/code&gt;                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is
                          &lt;code&gt;null&lt;/code&gt;                        
                    </exception>
                </javadoc>
                <method name="getCandidateLocales" type="List<Locale>" line="2299">
                    <params>
                        <param name="baseName" type="String"/>
                        <param name="locale" type="Locale"/>
                    </params>
                    <scope line="2300"/>
                </method>
                <declaration name="CANDIDATES_CACHE" type="CandidateListCache" line="2306"/>
                <class name="CandidateListCache" line="2308">
                    <extends class="LocaleObjectCache">
                        <type_params>
                            <type_param name="BaseLocale"/>
                            <type_param name="List<Locale>"/>
                        </type_params>
                    </extends>
                    <method name="createObject" type="List<Locale>" line="2309">
                        <params>
                            <param name="base" type="BaseLocale"/>
                        </params>
                        <comment line="2316">
                            Special handling for Norwegian                            
                        </comment>
                        <comment line="2329">
                            Insert a locale replacing &quot;nb&quot; with &quot;no&quot; for every list entry                            
                        </comment>
                        <comment line="2341">
                            Insert no_NO_NY, no_NO, no after nn                            
                        </comment>
                        <comment line="2349">
                            Special handling for Chinese                            
                        </comment>
                        <comment line="2352">
                            Supply script for users who want to use zh_Hans/zh_Hant
                             as bundle names (recommended for Java7+)                            
                        </comment>
                        <comment line="2360">
                            Supply region(country) for users who still package Chinese
                             bundles using old convension.                            
                        </comment>
                        <declaration name="language" type="String" line="2310"/>
                        <declaration name="script" type="String" line="2311"/>
                        <declaration name="region" type="String" line="2312"/>
                        <declaration name="variant" type="String" line="2313"/>
                        <declaration name="isNorwegianBokmal" type="boolean" line="2316"/>
                        <declaration name="isNorwegianNynorsk" type="boolean" line="2317"/>
                        <scope line="2318">
                            <scope line="2319"/>
                            <scope line="2322"/>
                        </scope>
                        <scope line="2326">
                            <declaration name="tmpList" type="List&lt;Locale&gt;" line="2327"/>
                            <declaration name="bokmalList" type="List&lt;Locale&gt;" line="2329"/>
                            <scope line="2330">
                                <scope line="2332"/>
                            </scope>
                        </scope>
                        <scope line="2339">
                            <declaration name="nynorskList" type="List&lt;Locale&gt;" line="2341"/>
                            <declaration name="idx" type="int" line="2342"/>
                        </scope>
                        <scope line="2349">
                            <scope line="2350">
                                <scope line="2353"/>
                                <scope line="2355"/>
                            </scope>
                            <scope line="2358">
                                <scope line="2361"/>
                                <scope line="2363"/>
                            </scope>
                        </scope>
                    </method>
                    <method name="getDefaultList" type="List<Locale>" line="2372">
                        <params>
                            <param name="language" type="String"/>
                            <param name="script" type="String"/>
                            <param name="region" type="String"/>
                            <param name="variant" type="String"/>
                        </params>
                        <comment line="2398">
                            With script, after truncating variant, region and script,
                             start over without script.                            
                        </comment>
                        <comment line="2412">
                            Add root locale at the end                            
                        </comment>
                        <declaration name="variants" type="List&lt;String&gt;" line="2373"/>
                        <scope line="2375">
                            <declaration name="idx" type="int" line="2377"/>
                            <scope line="2378"/>
                        </scope>
                        <declaration name="list" type="List&lt;Locale&gt;" line="2384"/>
                        <scope line="2386">
                            <scope line="2387"/>
                        </scope>
                        <scope line="2391"/>
                        <scope line="2394">
                            <scope line="2399">
                                <scope line="2400"/>
                            </scope>
                            <scope line="2404"/>
                        </scope>
                        <scope line="2408"/>
                    </method>
                </class>
                <javadoc line="2418">
                    Returns a &lt;code&gt;Locale&lt;/code&gt; to be used as a fallback locale for
                      further resource bundle searches by the
                      &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method. This method
                      is called from the factory method every time when no resulting
                      resource bundle has been found for &lt;code&gt;baseName&lt;/code&gt; and
                      &lt;code&gt;locale&lt;/code&gt;, where locale is either the parameter for
                      &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; or the previous fallback
                      locale returned by this method.
                      &lt;p&gt;The method returns &lt;code&gt;null&lt;/code&gt; if no further fallback
                      search is desired.
                      &lt;p&gt;The default implementation returns the {@linkplain Locale#getDefault() default &lt;code&gt;Locale&lt;/code&gt;} if the given
                      &lt;code&gt;locale&lt;/code&gt; isn&apos;t the default one.  Otherwise,
                      &lt;code&gt;null&lt;/code&gt; is returned.                    
                    <param>
                        baseNamethe base name of the resource bundle, a fully
                          qualified class name for which
                          &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been
                          unable to find any resource bundles (except for the
                          base bundle)                        
                    </param>
                    <param>
                        localethe &lt;code&gt;Locale&lt;/code&gt; for which
                          &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been
                          unable to find any resource bundles (except for the
                          base bundle)                        
                    </param>
                    <return>
                        a &lt;code&gt;Locale&lt;/code&gt; for the fallback search,
                          or &lt;code&gt;null&lt;/code&gt; if no further fallback search
                          is desired.                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;
                          is &lt;code&gt;null&lt;/code&gt;                        
                    </exception>
                </javadoc>
                <method name="getFallbackLocale" type="Locale" line="2454">
                    <params>
                        <param name="baseName" type="String"/>
                        <param name="locale" type="Locale"/>
                    </params>
                    <scope line="2455"/>
                    <declaration name="defaultLocale" type="Locale" line="2458"/>
                </method>
                <javadoc line="2462">
                    Instantiates a resource bundle for the given bundle name of the
                      given format and locale, using the given class loader if
                      necessary. This method returns &lt;code&gt;null&lt;/code&gt; if there is no
                      resource bundle available for the given parameters. If a resource
                      bundle can&apos;t be instantiated due to an unexpected error, the
                      error must be reported by throwing an &lt;code&gt;Error&lt;/code&gt; or
                      &lt;code&gt;Exception&lt;/code&gt; rather than simply returning
                      &lt;code&gt;null&lt;/code&gt;.
                      &lt;p&gt;If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it
                      indicates that this method is being called because the previously
                      loaded resource bundle has expired.
                      &lt;p&gt;The default implementation instantiates a
                      &lt;code&gt;ResourceBundle&lt;/code&gt; as follows.
                      &lt;ul&gt;
                      &lt;li&gt;The bundle name is obtained by calling {@link #toBundleName(String,Locale) toBundleName(baseName,
                      locale)}.&lt;/li&gt;
                      &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;, the{@link Class} specified by the bundle name is loaded by calling{@link ClassLoader#loadClass(String)}. Then, a
                      &lt;code&gt;ResourceBundle&lt;/code&gt; is instantiated by calling {@link Class#newInstance()}.  Note that the &lt;code&gt;reload&lt;/code&gt; flag is
                      ignored for loading class-based resource bundles in this default
                      implementation.&lt;/li&gt;
                      &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;,{@link #toResourceName(String,String) toResourceName(bundlename,
                      &quot;properties&quot;)} is called to get the resource name.
                      If &lt;code&gt;reload&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, {@link ClassLoader#getResource(String) load.getResource} is called
                      to get a {@link URL} for creating a {@link URLConnection}. This &lt;code&gt;URLConnection&lt;/code&gt; is used to{@linkplain URLConnection#setUseCaches(boolean) disable the
                      caches} of the underlying resource loading layers,
                      and to {@linkplain URLConnection#getInputStream() get an
                      &lt;code&gt;InputStream&lt;/code&gt;}.
                      Otherwise, {@link ClassLoader#getResourceAsStream(String)loader.getResourceAsStream} is called to get an {@link InputStream}. Then, a {@link PropertyResourceBundle} is constructed with the
                      &lt;code&gt;InputStream&lt;/code&gt;.&lt;/li&gt;
                      &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is neither &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;
                      nor &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, an
                      &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.&lt;/li&gt;
                      &lt;/ul&gt;                    
                    <param>
                        baseNamethe base bundle name of the resource bundle, a fully
                          qualified class name                        
                    </param>
                    <param>
                        localethe locale for which the resource bundle should be
                          instantiated                        
                    </param>
                    <param>
                        formatthe resource bundle format to be loaded                        
                    </param>
                    <param>
                        loaderthe &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle                        
                    </param>
                    <param>
                        reloadthe flag to indicate bundle reloading; &lt;code&gt;true&lt;/code&gt;
                          if reloading an expired resource bundle,
                          &lt;code&gt;false&lt;/code&gt; otherwise                        
                    </param>
                    <return>
                        the resource bundle instance,
                          or &lt;code&gt;null&lt;/code&gt; if none could be found.                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;bundleName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,
                          &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is
                          &lt;code&gt;null&lt;/code&gt;, or if &lt;code&gt;null&lt;/code&gt; is returned by{@link #toBundleName(String,Locale) toBundleName}                        
                    </exception>
                    <exception>
                        IllegalArgumentExceptionif &lt;code&gt;format&lt;/code&gt; is unknown, or if the resource
                          found for the given parameters contains malformed data.                        
                    </exception>
                    <exception>
                        ClassCastExceptionif the loaded class cannot be cast to &lt;code&gt;ResourceBundle&lt;/code&gt;                        
                    </exception>
                    <exception>
                        IllegalAccessExceptionif the class or its nullary constructor is not
                          accessible.                        
                    </exception>
                    <exception>
                        InstantiationExceptionif the instantiation of a class fails for some other
                          reason.                        
                    </exception>
                    <exception>
                        ExceptionInInitializerErrorif the initialization provoked by this method fails.                        
                    </exception>
                    <exception>
                        SecurityExceptionIf a security manager is present and creation of new
                          instances is denied. See {@link Class#newInstance()}for details.                        
                    </exception>
                    <exception>
                        IOExceptionif an error occurred when reading resources using
                          any I/O operations                        
                    </exception>
                </javadoc>
                <method name="newBundle" type="ResourceBundle" line="2560">
                    <params>
                        <param name="baseName" type="String"/>
                        <param name="locale" type="Locale"/>
                        <param name="format" type="String"/>
                        <param name="loader" type="ClassLoader"/>
                        <param name="reload" type="boolean"/>
                    </params>
                    <comment line="2569">
                        If the class isn&apos;t a ResourceBundle subclass, throw a
                         ClassCastException.                        
                    </comment>
                    <comment line="2594">
                        Disable caches to get fresh data for
                         reloading.                        
                    </comment>
                    <declaration name="bundleName" type="String" line="2561"/>
                    <declaration name="bundle" type="ResourceBundle" line="2562"/>
                    <scope line="2563">
                        <scope line="2564">
                            <declaration name="bundleClass" type="Class&lt;? extends ResourceBundle&gt;" line="2565"/>
                            <scope line="2570"/>
                            <scope line="2572"/>
                        </scope>
                        <scope line="2576"/>
                    </scope>
                    <scope line="2578">
                        <declaration name="resourceName" type="String" line="2579"/>
                        <declaration name="classLoader" type="ClassLoader" line="2580"/>
                        <declaration name="reloadFlag" type="boolean" line="2581"/>
                        <declaration name="stream" type="InputStream" line="2582"/>
                        <scope line="2583">
                            <anonymous_class line="2585">
                                <method name="run" type="InputStream" line="2586">
                                    <comment line="2594">
                                        Disable caches to get fresh data for
                                         reloading.                                        
                                    </comment>
                                    <declaration name="is" type="InputStream" line="2587"/>
                                    <scope line="2588">
                                        <declaration name="url" type="URL" line="2589"/>
                                        <scope line="2590">
                                            <declaration name="connection" type="URLConnection" line="2591"/>
                                            <scope line="2592"/>
                                        </scope>
                                    </scope>
                                    <scope line="2599"/>
                                </method>
                            </anonymous_class>
                        </scope>
                        <scope line="2605"/>
                        <scope line="2608">
                            <scope line="2609"/>
                            <scope line="2611"/>
                        </scope>
                    </scope>
                    <scope line="2615"/>
                </method>
                <javadoc line="2621">
                    Returns the time-to-live (TTL) value for resource bundles that
                      are loaded under this
                      &lt;code&gt;ResourceBundle.Control&lt;/code&gt;. Positive time-to-live values
                      specify the number of milliseconds a bundle can remain in the
                      cache without being validated against the source data from which
                      it was constructed. The value 0 indicates that a bundle must be
                      validated each time it is retrieved from the cache. {@link #TTL_DONT_CACHE} specifies that loaded resource bundles are not
                      put in the cache. {@link #TTL_NO_EXPIRATION_CONTROL} specifies
                      that loaded resource bundles are put in the cache with no
                      expiration control.
                      &lt;p&gt;The expiration affects only the bundle loading process by the
                      &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method.  That is,
                      if the factory method finds a resource bundle in the cache that
                      has expired, the factory method calls the {@link #needsReload(String,Locale,String,ClassLoader,ResourceBundle,long) needsReload} method to determine whether the resource
                      bundle needs to be reloaded. If &lt;code&gt;needsReload&lt;/code&gt; returns
                      &lt;code&gt;true&lt;/code&gt;, the cached resource bundle instance is removed
                      from the cache. Otherwise, the instance stays in the cache,
                      updated with the new TTL value returned by this method.
                      &lt;p&gt;All cached resource bundles are subject to removal from the
                      cache due to memory constraints of the runtime environment.
                      Returning a large positive value doesn&apos;t mean to lock loaded
                      resource bundles in the cache.
                      &lt;p&gt;The default implementation returns {@link #TTL_NO_EXPIRATION_CONTROL}.                    
                    <param>
                        baseNamethe base name of the resource bundle for which the
                          expiration value is specified.                        
                    </param>
                    <param>
                        localethe locale of the resource bundle for which the
                          expiration value is specified.                        
                    </param>
                    <return>
                        the time (0 or a positive millisecond offset from the
                          cached time) to get loaded bundles expired in the cache,{@link #TTL_NO_EXPIRATION_CONTROL} to disable the
                          expiration control, or {@link #TTL_DONT_CACHE} to disable
                          caching.                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is
                          &lt;code&gt;null&lt;/code&gt;                        
                    </exception>
                </javadoc>
                <method name="getTimeToLive" type="long" line="2667">
                    <params>
                        <param name="baseName" type="String"/>
                        <param name="locale" type="Locale"/>
                    </params>
                    <scope line="2668"/>
                </method>
                <javadoc line="2674">
                    Determines if the expired &lt;code&gt;bundle&lt;/code&gt; in the cache needs
                      to be reloaded based on the loading time given by
                      &lt;code&gt;loadTime&lt;/code&gt; or some other criteria. The method returns
                      &lt;code&gt;true&lt;/code&gt; if reloading is required; &lt;code&gt;false&lt;/code&gt;
                      otherwise. &lt;code&gt;loadTime&lt;/code&gt; is a millisecond offset since
                      the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt;
                      Epoch&lt;/a&gt;.
                      The calling &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method
                      calls this method on the &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
                      instance used for its current invocation, not on the instance
                      used in the invocation that originally loaded the resource
                      bundle.
                      &lt;p&gt;The default implementation compares &lt;code&gt;loadTime&lt;/code&gt; and
                      the last modified time of the source data of the resource
                      bundle. If it&apos;s determined that the source data has been modified
                      since &lt;code&gt;loadTime&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is
                      returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. This
                      implementation assumes that the given &lt;code&gt;format&lt;/code&gt; is the
                      same string as its file suffix if it&apos;s not one of the default
                      formats, &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; or
                      &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;.                    
                    <param>
                        baseNamethe base bundle name of the resource bundle, a
                          fully qualified class name                        
                    </param>
                    <param>
                        localethe locale for which the resource bundle
                          should be instantiated                        
                    </param>
                    <param>
                        formatthe resource bundle format to be loaded                        
                    </param>
                    <param>
                        loaderthe &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle                        
                    </param>
                    <param>
                        bundlethe resource bundle instance that has been expired
                          in the cache                        
                    </param>
                    <param>
                        loadTimethe time when &lt;code&gt;bundle&lt;/code&gt; was loaded and put
                          in the cache                        
                    </param>
                    <return>
                        &lt;code&gt;true&lt;/code&gt; if the expired bundle needs to be
                          reloaded; &lt;code&gt;false&lt;/code&gt; otherwise.                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,
                          &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;loader&lt;/code&gt;, or
                          &lt;code&gt;bundle&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                        
                    </exception>
                </javadoc>
                <method name="needsReload" type="boolean" line="2724">
                    <params>
                        <param name="baseName" type="String"/>
                        <param name="locale" type="Locale"/>
                        <param name="format" type="String"/>
                        <param name="loader" type="ClassLoader"/>
                        <param name="bundle" type="ResourceBundle"/>
                        <param name="loadTime" type="long"/>
                    </params>
                    <comment line="2740">
                        disable caches to get the correct data                        
                    </comment>
                    <comment line="2759">
                        ignore other exceptions                        
                    </comment>
                    <scope line="2725"/>
                    <scope line="2728"/>
                    <declaration name="result" type="boolean" line="2731"/>
                    <scope line="2732">
                        <declaration name="resourceName" type="String" line="2733"/>
                        <declaration name="url" type="URL" line="2734"/>
                        <scope line="2735">
                            <declaration name="lastModified" type="long" line="2736"/>
                            <declaration name="connection" type="URLConnection" line="2737"/>
                            <scope line="2738">
                                <scope line="2741">
                                    <declaration name="ent" type="JarEntry" line="2742"/>
                                    <scope line="2743">
                                        <scope line="2745"/>
                                    </scope>
                                </scope>
                                <scope line="2749"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="2755"/>
                    <scope line="2757"/>
                </method>
                <javadoc line="2763">
                    Converts the given &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;
                      to the bundle name. This method is called from the default
                      implementation of the {@link #newBundle(String,Locale,String,ClassLoader,boolean) newBundle} and {@link #needsReload(String,Locale,String,ClassLoader,ResourceBundle,long) needsReload}methods.
                      &lt;p&gt;This implementation returns the following value:
                      &lt;pre&gt;
                      baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
                      &lt;/pre&gt;
                      where &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;country&lt;/code&gt;,
                      and &lt;code&gt;variant&lt;/code&gt; are the language, script, country, and variant
                      values of &lt;code&gt;locale&lt;/code&gt;, respectively. Final component values that
                      are empty Strings are omitted along with the preceding &apos;_&apos;.  When the
                      script is empty, the script value is ommitted along with the preceding &apos;_&apos;.
                      If all of the values are empty strings, then &lt;code&gt;baseName&lt;/code&gt;
                      is returned.
                      &lt;p&gt;For example, if &lt;code&gt;baseName&lt;/code&gt; is
                      &lt;code&gt;&quot;baseName&quot;&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt; is
                      &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then
                      &lt;code&gt;&quot;baseName_ja_&amp;thinsp;_XX&quot;&lt;/code&gt; is returned. If the given
                      locale is &lt;code&gt;Locale(&quot;en&quot;)&lt;/code&gt;, then
                      &lt;code&gt;&quot;baseName_en&quot;&lt;/code&gt; is returned.
                      &lt;p&gt;Overriding this method allows applications to use different
                      conventions in the organization and packaging of localized
                      resources.                    
                    <param>
                        baseNamethe base name of the resource bundle, a fully
                          qualified class name                        
                    </param>
                    <param>
                        localethe locale for which a resource bundle should be
                          loaded                        
                    </param>
                    <return>
                        the bundle name for the resource bundle                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;
                          is &lt;code&gt;null&lt;/code&gt;                        
                    </exception>
                </javadoc>
                <method name="toBundleName" type="String" line="2805">
                    <params>
                        <param name="baseName" type="String"/>
                        <param name="locale" type="Locale"/>
                    </params>
                    <scope line="2806"/>
                    <declaration name="language" type="String" line="2810"/>
                    <declaration name="script" type="String" line="2811"/>
                    <declaration name="country" type="String" line="2812"/>
                    <declaration name="variant" type="String" line="2813"/>
                    <scope line="2815"/>
                    <declaration name="sb" type="StringBuilder" line="2819"/>
                    <scope line="2821">
                        <scope line="2822"/>
                        <scope line="2824"/>
                        <scope line="2826"/>
                    </scope>
                    <scope line="2829">
                        <scope line="2830"/>
                        <scope line="2832"/>
                        <scope line="2834"/>
                    </scope>
                </method>
                <javadoc line="2842">
                    Converts the given &lt;code&gt;bundleName&lt;/code&gt; to the form required
                      by the {@link ClassLoader#getResource ClassLoader.getResource}method by replacing all occurrences of &lt;code&gt;&apos;.&apos;&lt;/code&gt; in
                      &lt;code&gt;bundleName&lt;/code&gt; with &lt;code&gt;&apos;/&apos;&lt;/code&gt; and appending a
                      &lt;code&gt;&apos;.&apos;&lt;/code&gt; and the given file &lt;code&gt;suffix&lt;/code&gt;. For
                      example, if &lt;code&gt;bundleName&lt;/code&gt; is
                      &lt;code&gt;&quot;foo.bar.MyResources_ja_JP&quot;&lt;/code&gt; and &lt;code&gt;suffix&lt;/code&gt;
                      is &lt;code&gt;&quot;properties&quot;&lt;/code&gt;, then
                      &lt;code&gt;&quot;foo/bar/MyResources_ja_JP.properties&quot;&lt;/code&gt; is returned.                    
                    <param>
                        bundleNamethe bundle name                        
                    </param>
                    <param>
                        suffixthe file type suffix                        
                    </param>
                    <return>
                        the converted resource name                        
                    </return>
                    <exception>
                        NullPointerExceptionif &lt;code&gt;bundleName&lt;/code&gt; or &lt;code&gt;suffix&lt;/code&gt;
                          is &lt;code&gt;null&lt;/code&gt;                        
                    </exception>
                </javadoc>
                <method name="toResourceName" type="String" line="2862">
                    <params>
                        <param name="bundleName" type="String"/>
                        <param name="suffix" type="String"/>
                    </params>
                    <declaration name="sb" type="StringBuilder" line="2863"/>
                </method>
            </class>
            <class name="SingleFormatControl" line="2869">
                <extends class="Control"/>
                <comment line="493">
                    These three are the actual keys for lookup in Map.                    
                </comment>
                <comment line="498">
                    bundle format which is necessary for calling
                     Control.needsReload().                    
                </comment>
                <comment line="502">
                    These time values are in CacheKey so that NONEXISTENT_BUNDLE
                     doesn&apos;t need to be cloned for caching.                    
                </comment>
                <comment line="505">
                    The time when the bundle has been loaded                    
                </comment>
                <comment line="508">
                    The time when the bundle expires in the cache, or either
                     Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.                    
                </comment>
                <comment line="512">
                    Placeholder for an error report by a Throwable                    
                </comment>
                <comment line="515">
                    Hash code value cache to avoid recalculating the hash code
                     of this instance.                    
                </comment>
                <declaration name="PROPERTIES_ONLY" type="Control" line="2870"/>
                <declaration name="CLASS_ONLY" type="Control" line="2873"/>
                <declaration name="formats" type="List&lt;String&gt;" line="2876"/>
                <method name="SingleFormatControl" type="constructor" line="2878">
                    <params>
                        <param name="formats" type="List<String>"/>
                    </params>
                </method>
                <method name="getFormats" type="List<String>" line="2882">
                    <params>
                        <param name="baseName" type="String"/>
                    </params>
                    <scope line="2883"/>
                </method>
            </class>
            <class name="NoFallbackControl" line="2890">
                <extends class="SingleFormatControl"/>
                <comment line="493">
                    These three are the actual keys for lookup in Map.                    
                </comment>
                <comment line="498">
                    bundle format which is necessary for calling
                     Control.needsReload().                    
                </comment>
                <comment line="502">
                    These time values are in CacheKey so that NONEXISTENT_BUNDLE
                     doesn&apos;t need to be cloned for caching.                    
                </comment>
                <comment line="505">
                    The time when the bundle has been loaded                    
                </comment>
                <comment line="508">
                    The time when the bundle expires in the cache, or either
                     Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.                    
                </comment>
                <comment line="512">
                    Placeholder for an error report by a Throwable                    
                </comment>
                <comment line="515">
                    Hash code value cache to avoid recalculating the hash code
                     of this instance.                    
                </comment>
                <declaration name="NO_FALLBACK" type="Control" line="2891"/>
                <declaration name="PROPERTIES_ONLY_NO_FALLBACK" type="Control" line="2894"/>
                <declaration name="CLASS_ONLY_NO_FALLBACK" type="Control" line="2897"/>
                <method name="NoFallbackControl" type="constructor" line="2900">
                    <params>
                        <param name="formats" type="List<String>"/>
                    </params>
                </method>
                <method name="getFallbackLocale" type="Locale" line="2904">
                    <params>
                        <param name="baseName" type="String"/>
                        <param name="locale" type="Locale"/>
                    </params>
                    <scope line="2905"/>
                </method>
            </class>
        </class>
    </source>