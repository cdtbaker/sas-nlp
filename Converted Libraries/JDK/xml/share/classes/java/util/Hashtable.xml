<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <import package="java.io"/>
        <class name="Hashtable" line="29">
            <type_params>
                <type_param name="K"/>
                <type_param name="V"/>
            </type_params>
            <extends class="Dictionary">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </extends>
            <comment line="595">
                Views                
            </comment>
            <comment line="763">
                Comparison and hashing                
            </comment>
            <comment line="1007">
                Types of Enumerations/Iterations                
            </comment>
            <implements interface="Map">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </implements>
            <implements interface="Cloneable"/>
            <implements interface="java.io.Serializable"/>
            <javadoc line="29">
                This class implements a hash table, which maps keys to values. Any
                  non-&lt;code&gt;null&lt;/code&gt; object can be used as a key or as a value. &lt;p&gt;
                  To successfully store and retrieve objects from a hashtable, the
                  objects used as keys must implement the &lt;code&gt;hashCode&lt;/code&gt;
                  method and the &lt;code&gt;equals&lt;/code&gt; method. &lt;p&gt;
                  An instance of &lt;code&gt;Hashtable&lt;/code&gt; has two parameters that affect its
                  performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The
                  &lt;i&gt;capacity&lt;/i&gt; is the number of &lt;i&gt;buckets&lt;/i&gt; in the hash table, and the
                  &lt;i&gt;initial capacity&lt;/i&gt; is simply the capacity at the time the hash table
                  is created.  Note that the hash table is &lt;i&gt;open&lt;/i&gt;: in the case of a &quot;hash
                  collision&quot;, a single bucket stores multiple entries, which must be searched
                  sequentially.  The &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash
                  table is allowed to get before its capacity is automatically increased.
                  The initial capacity and load factor parameters are merely hints to
                  the implementation.  The exact details as to when and whether the rehash
                  method is invoked are implementation-dependent.&lt;p&gt;
                  Generally, the default load factor (.75) offers a good tradeoff between
                  time and space costs.  Higher values decrease the space overhead but
                  increase the time cost to look up an entry (which is reflected in most
                  &lt;tt&gt;Hashtable&lt;/tt&gt; operations, including &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).&lt;p&gt;
                  The initial capacity controls a tradeoff between wasted space and the
                  need for &lt;code&gt;rehash&lt;/code&gt; operations, which are time-consuming.
                  No &lt;code&gt;rehash&lt;/code&gt; operations will &lt;i&gt;ever&lt;/i&gt; occur if the initial
                  capacity is greater than the maximum number of entries the
                  &lt;tt&gt;Hashtable&lt;/tt&gt; will contain divided by its load factor.  However,
                  setting the initial capacity too high can waste space.&lt;p&gt;
                  If many entries are to be made into a &lt;code&gt;Hashtable&lt;/code&gt;,
                  creating it with a sufficiently large capacity may allow the
                  entries to be inserted more efficiently than letting it perform
                  automatic rehashing as needed to grow the table. &lt;p&gt;
                  This example creates a hashtable of numbers. It uses the names of
                  the numbers as keys:
                  &lt;pre&gt;   {@codeHashtable&lt;String, Integer&gt; numbers
                  = new Hashtable&lt;String, Integer&gt;();
                  numbers.put(&quot;one&quot;, 1);
                  numbers.put(&quot;two&quot;, 2);
                  numbers.put(&quot;three&quot;, 3);}&lt;/pre&gt;
                  &lt;p&gt;To retrieve a number, use the following code:
                  &lt;pre&gt;   {@codeInteger n = numbers.get(&quot;two&quot;);}if (n != null) 
                  System.out.println(&quot;two = &quot; + n);
                  }}&lt;/pre&gt;
                  &lt;p&gt;The iterators returned by the &lt;tt&gt;iterator&lt;/tt&gt; method of the collections
                  returned by all of this class&apos;s &quot;collection view methods&quot; are
                  &lt;em&gt;fail-fast&lt;/em&gt;: if the Hashtable is structurally modified at any time
                  after the iterator is created, in any way except through the iterator&apos;s own
                  &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a {@link ConcurrentModificationException}.  Thus, in the face of concurrent
                  modification, the iterator fails quickly and cleanly, rather than risking
                  arbitrary, non-deterministic behavior at an undetermined time in the future.
                  The Enumerations returned by Hashtable&apos;s keys and elements methods are
                  &lt;em&gt;not&lt;/em&gt; fail-fast.
                  &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                  as it is, generally speaking, impossible to make any hard guarantees in the
                  presence of unsynchronized concurrent modification.  Fail-fast iterators
                  throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.
                  Therefore, it would be wrong to write a program that depended on this
                  exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
                  should be used only to detect bugs.&lt;/i&gt;
                  &lt;p&gt;As of the Java 2 platform v1.2, this class was retrofitted to
                  implement the {@link Map} interface, making it a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.  Unlike the new collection
                  implementations, {@code Hashtable} is synchronized.  If a
                  thread-safe implementation is not needed, it is recommended to use{@link HashMap} in place of {@code Hashtable}.  If a thread-safe
                  highly-concurrent implementation is desired, then it is recommended
                  to use {@link java.util.concurrent.ConcurrentHashMap} in place of{@code Hashtable}.                
                <author>
                    Arthur van Hoff                    
                </author>
                <author>
                    Josh Bloch                    
                </author>
                <author>
                    Neal Gafter                    
                </author>
                <see>
                    Object#equals(java.lang.Object)                    
                </see>
                <see>
                    Object#hashCode()                    
                </see>
                <see>
                    Hashtable#rehash()                    
                </see>
                <see>
                    Collection                    
                </see>
                <see>
                    Map                    
                </see>
                <see>
                    HashMap                    
                </see>
                <see>
                    TreeMap                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <declaration name="table" type="Entry[]" line="129"/>
            <javadoc line="129">
                The hash table data.                
            </javadoc>
            <declaration name="count" type="int" line="134"/>
            <javadoc line="134">
                The total number of entries in the hash table.                
            </javadoc>
            <declaration name="threshold" type="int" line="139"/>
            <javadoc line="139">
                The table is rehashed when its size exceeds this threshold.  (The
                  value of this field is (int)(capacity  loadFactor).)                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="loadFactor" type="float" line="147"/>
            <javadoc line="147">
                The load factor for the hashtable.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="modCount" type="int" line="154"/>
            <javadoc line="154">
                The number of times this Hashtable has been structurally modified
                  Structural modifications are those that change the number of entries in
                  the Hashtable or otherwise modify its internal structure (e.g.,
                  rehash).  This field is used to make iterators on Collection-views of
                  the Hashtable fail-fast.  (See ConcurrentModificationException).                
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="163"/>
            <javadoc line="163">
                use serialVersionUID from JDK 1.0.2 for interoperability                
            </javadoc>
            <javadoc line="166">
                Constructs a new, empty hashtable with the specified initial
                  capacity and the specified load factor.                
                <param>
                    initialCapacity   the initial capacity of the hashtable.                    
                </param>
                <param>
                    loadFactor        the load factor of the hashtable.                    
                </param>
                <exception>
                    IllegalArgumentException  if the initial capacity is less
                      than zero, or if the load factor is nonpositive.                    
                </exception>
            </javadoc>
            <method name="Hashtable" type="constructor" line="175">
                <params>
                    <param name="initialCapacity" type="int"/>
                    <param name="loadFactor" type="float"/>
                </params>
            </method>
            <javadoc line="189">
                Constructs a new, empty hashtable with the specified initial capacity
                  and default load factor (0.75).                
                <param>
                    initialCapacity   the initial capacity of the hashtable.                    
                </param>
                <exception>
                    IllegalArgumentException if the initial capacity is less
                      than zero.                    
                </exception>
            </javadoc>
            <method name="Hashtable" type="constructor" line="197">
                <params>
                    <param name="initialCapacity" type="int"/>
                </params>
            </method>
            <javadoc line="201">
                Constructs a new, empty hashtable with a default initial capacity (11)
                  and load factor (0.75).                
            </javadoc>
            <method name="Hashtable" type="constructor" line="205"/>
            <javadoc line="209">
                Constructs a new hashtable with the same mappings as the given
                  Map.  The hashtable is created with an initial capacity sufficient to
                  hold the mappings in the given Map and a default load factor (0.75).                
                <param>
                    t the map whose mappings are to be placed in this map.                    
                </param>
                <throws>
                    NullPointerException if the specified map is null.                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="Hashtable" type="constructor" line="218">
                <params>
                    <param name="t" type="Map<? extends K,? extends V>"/>
                </params>
            </method>
            <javadoc line="223">
                Returns the number of keys in this hashtable.                
                <return>
                    the number of keys in this hashtable.                    
                </return>
            </javadoc>
            <method name="size" type="int" line="228"/>
            <javadoc line="232">
                Tests if this hashtable maps no keys to values.                
                <return>
                    <code>true</code> if this hashtable maps no keys to values;
                      <code>false</code> otherwise.                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="238"/>
            <javadoc line="242">
                Returns an enumeration of the keys in this hashtable.                
                <return>
                    an enumeration of the keys in this hashtable.                    
                </return>
                <see>
                    Enumeration                    
                </see>
                <see>
                    #elements()                    
                </see>
                <see>
                    #keySet()                    
                </see>
                <see>
                    Map                    
                </see>
            </javadoc>
            <method name="keys" type="Enumeration<K>" line="251"/>
            <javadoc line="255">
                Returns an enumeration of the values in this hashtable.
                  Use the Enumeration methods on the returned object to fetch the elements
                  sequentially.                
                <return>
                    an enumeration of the values in this hashtable.                    
                </return>
                <see>
                    java.util.Enumeration                    
                </see>
                <see>
                    #keys()                    
                </see>
                <see>
                    #values()                    
                </see>
                <see>
                    Map                    
                </see>
            </javadoc>
            <method name="elements" type="Enumeration<V>" line="266"/>
            <javadoc line="270">
                Tests if some key maps into the specified value in this hashtable.
                  This operation is more expensive than the {@link #containsKeycontainsKey} method.
                  &lt;p&gt;Note that this method is identical in functionality to{@link #containsValue containsValue}, (which is part of the{@link Map} interface in the collections framework).                
                <param>
                    value   a value to search for                    
                </param>
                <return>
                    <code>true</code> if and only if some key maps to the
                      <code>value</code> argument in this hashtable as
                      determined by the <tt>equals</tt> method;
                      <code>false</code> otherwise.                    
                </return>
                <exception>
                    NullPointerException  if the value is <code>null</code>                    
                </exception>
            </javadoc>
            <method name="contains" type="boolean" line="286">
                <params>
                    <param name="value" type="Object"/>
                </params>
                <scope line="287"/>
                <declaration name="tab" type="Entry" line="291"/>
                <scope line="292">
                    <scope line="293">
                        <scope line="294"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="302">
                Returns true if this hashtable maps one or more keys to this value.
                  &lt;p&gt;Note that this method is identical in functionality to {@link #contains contains} (which predates the {@link Map} interface).                
                <param>
                    value value whose presence in this hashtable is to be tested                    
                </param>
                <return>
                    <tt>true</tt> if this map maps one or more keys to the
                      specified value                    
                </return>
                <throws>
                    NullPointerException  if the value is <code>null</code>                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="containsValue" type="boolean" line="314">
                <params>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="318">
                Tests if the specified object is a key in this hashtable.                
                <param>
                    key   possible key                    
                </param>
                <return>
                    <code>true</code> if and only if the specified object
                      is a key in this hashtable, as determined by the
                      <tt>equals</tt> method; <code>false</code> otherwise.                    
                </return>
                <throws>
                    NullPointerException  if the key is <code>null</code>                    
                </throws>
                <see>
                    #contains(Object)                    
                </see>
            </javadoc>
            <method name="containsKey" type="boolean" line="328">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="tab" type="Entry" line="329"/>
                <declaration name="hash" type="int" line="330"/>
                <declaration name="index" type="int" line="331"/>
                <scope line="332">
                    <scope line="333"/>
                </scope>
            </method>
            <javadoc line="340">
                Returns the value to which the specified key is mapped,
                  or {@code null} if this map contains no mapping for the key.
                  &lt;p&gt;More formally, if this map contains a mapping from a key{@code k} to a value {@code v} such that {@code (key.equals(k))},
                  then this method returns {@code v}; otherwise it returns{@code null}.  (There can be at most one such mapping.)                
                <param>
                    key the key whose associated value is to be returned                    
                </param>
                <return>
                    the value to which the specified key is mapped, or{@code null} if this map contains no mapping for the key                    
                </return>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
                <see>
                    #put(Object,Object)                    
                </see>
            </javadoc>
            <method name="get" type="V" line="355">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="tab" type="Entry" line="356"/>
                <declaration name="hash" type="int" line="357"/>
                <declaration name="index" type="int" line="358"/>
                <scope line="359">
                    <scope line="360"/>
                </scope>
            </method>
            <declaration name="MAX_ARRAY_SIZE" type="int" line="367"/>
            <javadoc line="367">
                The maximum size of array to allocate.
                  Some VMs reserve some header words in an array.
                  Attempts to allocate larger arrays may result in
                  OutOfMemoryError: Requested array size exceeds VM limit                
            </javadoc>
            <javadoc line="375">
                Increases the capacity of and internally reorganizes this
                  hashtable, in order to accommodate and access its entries more
                  efficiently.  This method is called automatically when the
                  number of keys in the hashtable exceeds this hashtable&apos;s capacity
                  and load factor.                
            </javadoc>
            <method name="rehash" type="void" line="382">
                <comment line="386">
                    overflow-conscious code                    
                </comment>
                <comment line="390">
                    Keep running with MAX_ARRAY_SIZE buckets                    
                </comment>
                <declaration name="oldCapacity" type="int" line="383"/>
                <declaration name="oldMap" type="Entry[]" line="384"/>
                <declaration name="newCapacity" type="int" line="387"/>
                <scope line="388"/>
                <declaration name="newMap" type="Entry[]" line="394"/>
                <scope line="400">
                    <scope line="401">
                        <declaration name="e" type="Entry&lt;K,V&gt;" line="402"/>
                        <declaration name="index" type="int" line="405"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="412">
                Maps the specified &lt;code&gt;key&lt;/code&gt; to the specified
                  &lt;code&gt;value&lt;/code&gt; in this hashtable. Neither the key nor the
                  value can be &lt;code&gt;null&lt;/code&gt;. &lt;p&gt;
                  The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method
                  with a key that is equal to the original key.                
                <param>
                    key     the hashtable key                    
                </param>
                <param>
                    value   the value                    
                </param>
                <return>
                    the previous value of the specified key in this hashtable,
                      or <code>null</code> if it did not have one                    
                </return>
                <exception>
                    NullPointerException  if the key or value is
                      <code>null</code>                    
                </exception>
                <see>
                    Object#equals(Object)                    
                </see>
                <see>
                    #get(Object)                    
                </see>
            </javadoc>
            <method name="put" type="V" line="429">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
                <comment line="430">
                    Make sure the value is not null                    
                </comment>
                <comment line="435">
                    Makes sure the key is not already in the hashtable.                    
                </comment>
                <comment line="449">
                    Rehash the table if the threshold is exceeded                    
                </comment>
                <comment line="456">
                    Creates the new entry.                    
                </comment>
                <scope line="431"/>
                <declaration name="tab" type="Entry" line="436"/>
                <declaration name="hash" type="int" line="437"/>
                <declaration name="index" type="int" line="438"/>
                <scope line="439">
                    <scope line="440">
                        <declaration name="old" type="V" line="441"/>
                    </scope>
                </scope>
                <scope line="448"/>
                <declaration name="e" type="Entry&lt;K,V&gt;" line="457"/>
            </method>
            <javadoc line="463">
                Removes the key (and its corresponding value) from this
                  hashtable. This method does nothing if the key is not in the hashtable.                
                <param>
                    key   the key that needs to be removed                    
                </param>
                <return>
                    the value to which the key had been mapped in this hashtable,
                      or <code>null</code> if the key did not have a mapping                    
                </return>
                <throws>
                    NullPointerException  if the key is <code>null</code>                    
                </throws>
            </javadoc>
            <method name="remove" type="V" line="472">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="tab" type="Entry" line="473"/>
                <declaration name="hash" type="int" line="474"/>
                <declaration name="index" type="int" line="475"/>
                <scope line="476">
                    <scope line="477">
                        <scope line="479"/>
                        <scope line="481"/>
                        <declaration name="oldValue" type="V" line="485"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="493">
                Copies all of the mappings from the specified map to this hashtable.
                  These mappings will replace any mappings that this hashtable had for any
                  of the keys currently in the specified map.                
                <param>
                    t mappings to be stored in this map                    
                </param>
                <throws>
                    NullPointerException if the specified map is null                    
                </throws>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="putAll" type="void" line="502">
                <params>
                    <param name="t" type="Map<? extends K,? extends V>"/>
                </params>
            </method>
            <javadoc line="507">
                Clears this hashtable so that it contains no keys.                
            </javadoc>
            <method name="clear" type="void" line="510">
                <declaration name="tab" type="Entry" line="511"/>
            </method>
            <javadoc line="518">
                Creates a shallow copy of this hashtable. All the structure of the
                  hashtable itself is copied, but the keys and values are not cloned.
                  This is a relatively expensive operation.                
                <return>
                    a clone of the hashtable                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="525">
                <comment line="539">
                    this shouldn&apos;t happen, since we are Cloneable                    
                </comment>
                <scope line="526">
                    <declaration name="t" type="Hashtable&lt;K,V&gt;" line="527"/>
                    <scope line="529"/>
                </scope>
                <scope line="538"/>
            </method>
            <javadoc line="544">
                Returns a string representation of this &lt;tt&gt;Hashtable&lt;/tt&gt; object
                  in the form of a set of entries, enclosed in braces and separated
                  by the ASCII characters &quot;&lt;tt&gt;,&amp;nbsp;&lt;/tt&gt;&quot; (comma and space). Each
                  entry is rendered as the key, an equals sign &lt;tt&gt;=&lt;/tt&gt;, and the
                  associated element, where the &lt;tt&gt;toString&lt;/tt&gt; method is used to
                  convert the key and element to strings.                
                <return>
                    a string representation of this hashtable                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="554">
                <declaration name="max" type="int" line="555"/>
                <declaration name="sb" type="StringBuilder" line="559"/>
                <declaration name="it" type="Iterator&lt;Map.Entry&lt;K,V&gt;&gt;" line="560"/>
                <scope line="563">
                    <declaration name="e" type="Map.Entry&lt;K,V&gt;" line="564"/>
                    <declaration name="key" type="K" line="565"/>
                    <declaration name="value" type="V" line="566"/>
                </scope>
            </method>
            <method name="getEnumeration" type="Enumeration<T>" line="578">
                <params>
                    <param name="type" type="int"/>
                </params>
                <scope line="579"/>
                <scope line="581"/>
            </method>
            <method name="getIterator" type="Iterator<T>" line="586">
                <params>
                    <param name="type" type="int"/>
                </params>
                <scope line="587"/>
                <scope line="589"/>
            </method>
            <declaration name="keySet" type="Set&lt;K&gt;" line="596"/>
            <javadoc line="596">
                Each of these fields are initialized to contain an instance of the
                  appropriate view the first time this view is requested.  The views are
                  stateless, so there&apos;s no reason to create more than one of each.                
            </javadoc>
            <declaration name="entrySet" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="602"/>
            <declaration name="values" type="Collection&lt;V&gt;" line="603"/>
            <javadoc line="605">
                Returns a {@link Set} view of the keys contained in this map.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  If the map is modified
                  while an iteration over the set is in progress (except through
                  the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of
                  the iteration are undefined.  The set supports element removal,
                  which removes the corresponding mapping from the map, via the
                  &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
                  &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
                  operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;
                  operations.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="keySet" type="Set<K>" line="620"/>
            <class name="KeySet" line="626">
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </extends>
                <comment line="970">
                    Map.Entry Ops                    
                </comment>
                <comment line="1075">
                    Iterator methods                    
                </comment>
                <method name="iterator" type="Iterator<K>" line="627"/>
                <method name="size" type="int" line="630"/>
                <method name="contains" type="boolean" line="633">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="636">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="639"/>
            </class>
            <javadoc line="644">
                Returns a {@link Set} view of the mappings contained in this map.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  If the map is modified
                  while an iteration over the set is in progress (except through
                  the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the
                  &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the
                  iterator) the results of the iteration are undefined.  The set
                  supports element removal, which removes the corresponding
                  mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
                  &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and
                  &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the
                  &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="entrySet" type="Set<Map.Entry<K,V>>" line="660"/>
            <class name="EntrySet" line="666">
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="Map.Entry<K,V>"/>
                    </type_params>
                </extends>
                <comment line="970">
                    Map.Entry Ops                    
                </comment>
                <comment line="1075">
                    Iterator methods                    
                </comment>
                <method name="iterator" type="Iterator<Map.Entry<K,V>>" line="667"/>
                <method name="add" type="boolean" line="671">
                    <params>
                        <param name="o" type="Map.Entry<K,V>"/>
                    </params>
                </method>
                <method name="contains" type="boolean" line="675">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="entry" type="Map.Entry" line="678"/>
                    <declaration name="key" type="Object" line="679"/>
                    <declaration name="tab" type="Entry[]" line="680"/>
                    <declaration name="hash" type="int" line="681"/>
                    <declaration name="index" type="int" line="682"/>
                </method>
                <method name="remove" type="boolean" line="690">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="entry" type="Map.Entry&lt;K,V&gt;" line="693"/>
                    <declaration name="key" type="K" line="694"/>
                    <declaration name="tab" type="Entry[]" line="695"/>
                    <declaration name="hash" type="int" line="696"/>
                    <declaration name="index" type="int" line="697"/>
                    <scope line="700">
                        <scope line="701"/>
                    </scope>
                </method>
                <method name="size" type="int" line="716"/>
                <method name="clear" type="void" line="720"/>
            </class>
            <javadoc line="725">
                Returns a {@link Collection} view of the values contained in this map.
                  The collection is backed by the map, so changes to the map are
                  reflected in the collection, and vice-versa.  If the map is
                  modified while an iteration over the collection is in progress
                  (except through the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation),
                  the results of the iteration are undefined.  The collection
                  supports element removal, which removes the corresponding
                  mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
                  &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
                  &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not
                  support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="values" type="Collection<V>" line="740"/>
            <class name="ValueCollection" line="747">
                <extends class="AbstractCollection">
                    <type_params>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="970">
                    Map.Entry Ops                    
                </comment>
                <comment line="1075">
                    Iterator methods                    
                </comment>
                <method name="iterator" type="Iterator<V>" line="748"/>
                <method name="size" type="int" line="751"/>
                <method name="contains" type="boolean" line="754">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="757"/>
            </class>
            <javadoc line="764">
                Compares the specified Object with this Map for equality,
                  as per the definition in the Map interface.                
                <param>
                    o object to be compared for equality with this hashtable                    
                </param>
                <return>
                    true if the specified Object is equal to this Map                    
                </return>
                <see>
                    Map#equals(Object)                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="equals" type="boolean" line="773">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="t" type="Map&lt;K,V&gt;" line="779"/>
                <scope line="783">
                    <declaration name="i" type="Iterator&lt;Map.Entry&lt;K,V&gt;&gt;" line="784"/>
                    <scope line="785">
                        <declaration name="e" type="Map.Entry&lt;K,V&gt;" line="786"/>
                        <declaration name="key" type="K" line="787"/>
                        <declaration name="value" type="V" line="788"/>
                        <scope line="789"/>
                        <scope line="792"/>
                    </scope>
                </scope>
                <scope line="797"/>
                <scope line="799"/>
            </method>
            <javadoc line="806">
                Returns the hash code value for this Map as per the definition in the
                  Map interface.                
                <see>
                    Map#hashCode()                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="813">
                <comment line="814">
                    This code detects the recursion caused by computing the hash code
                     of a self-referential hash table and prevents the stack overflow
                     that would otherwise result.  This allows certain 1.1-era
                     applets with self-referential hash tables to work.  This code
                     abuses the loadFactor field to do double-duty as a hashCode
                     in progress flag, so as not to worsen the space performance.
                     A negative load factor indicates that hash code computation is
                     in progress.                    
                </comment>
                <comment line="826">
                    Returns zero                    
                </comment>
                <comment line="828">
                    Mark hashCode computation in progress                    
                </comment>
                <comment line="833">
                    Mark hashCode computation complete                    
                </comment>
                <declaration name="h" type="int" line="824"/>
                <declaration name="tab" type="Entry[]" line="829"/>
            </method>
            <javadoc line="838">
                Save the state of the Hashtable to a stream (i.e., serialize it).                
                <serialData>
                    The <i>capacity</i> of the Hashtable (the length of the
                      bucket array) is emitted (int), followed by the
                      <i>size</i> of the Hashtable (the number of key-value
                      mappings), followed by the key (Object) and value (Object)
                      for each key-value mapping represented by the Hashtable
                      The key-value mappings are emitted in no particular order.                    
                </serialData>
            </javadoc>
            <method name="writeObject" type="void" line="849">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <comment line="853">
                    Write out the length, threshold, loadfactor                    
                </comment>
                <comment line="856">
                    Write out length, count of elements                    
                </comment>
                <comment line="860">
                    Stack copies of the entries in the table                    
                </comment>
                <comment line="872">
                    Write out the key/value objects from the stacked entries                    
                </comment>
                <declaration name="entryStack" type="Entry&lt;Object,Object&gt;" line="850"/>
                <scope line="852">
                    <scope line="861">
                        <declaration name="entry" type="Entry" line="862"/>
                        <scope line="864"/>
                    </scope>
                </scope>
                <scope line="873"/>
            </method>
            <javadoc line="880">
                Reconstitute the Hashtable from a stream (i.e., deserialize it).                
            </javadoc>
            <method name="readObject" type="void" line="885">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="886">
                    Read in the length, threshold, and loadfactor                    
                </comment>
                <comment line="889">
                    Read the original length of the array and number of elements                    
                </comment>
                <comment line="893">
                    Compute new size with a bit of room 5% to grow but                    
                </comment>
                <comment line="894">
                    no larger than the original size.  Make the length                    
                </comment>
                <comment line="895">
                    odd if it&apos;s large enough, this helps distribute the entries.                    
                </comment>
                <comment line="896">
                    Guard against the length ending up zero, that&apos;s not valid.                    
                </comment>
                <comment line="906">
                    Read the number of elements and then all the key/value objects                    
                </comment>
                <comment line="910">
                    synch could be eliminated for performance                    
                </comment>
                <declaration name="origlength" type="int" line="890"/>
                <declaration name="elements" type="int" line="891"/>
                <declaration name="length" type="int" line="897"/>
                <declaration name="table" type="Entry[]" line="903"/>
                <scope line="907">
                    <declaration name="key" type="K" line="908"/>
                    <declaration name="value" type="V" line="909"/>
                </scope>
            </method>
            <javadoc line="916">
                The put method used by readObject. This is provided because put
                  is overridable and should not be called in readObject since the
                  subclass will not yet be initialized.
                  &lt;p&gt;This differs from the regular put method in several ways. No
                  checking for rehashing is necessary since the number of elements
                  initially in the table is known. The modCount is not incremented
                  because we are creating a new instance. Also, no return value
                  is needed.                
            </javadoc>
            <method name="reconstitutionPut" type="void" line="929">
                <params>
                    <param name="tab" type="Entry[]"/>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
                <comment line="933">
                    Makes sure the key is not already in the hashtable.                    
                </comment>
                <comment line="934">
                    This should not happen in deserialized version.                    
                </comment>
                <comment line="942">
                    Creates the new entry.                    
                </comment>
                <scope line="930"/>
                <declaration name="hash" type="int" line="935"/>
                <declaration name="index" type="int" line="936"/>
                <scope line="937">
                    <scope line="938"/>
                </scope>
                <declaration name="e" type="Entry&lt;K,V&gt;" line="943"/>
            </method>
            <class name="Entry" line="948">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <comment line="970">
                    Map.Entry Ops                    
                </comment>
                <comment line="1075">
                    Iterator methods                    
                </comment>
                <implements interface="Map.Entry">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <javadoc line="948">
                    Hashtable collision list.                    
                </javadoc>
                <declaration name="hash" type="int" line="952"/>
                <declaration name="key" type="K" line="953"/>
                <declaration name="value" type="V" line="954"/>
                <declaration name="next" type="Entry&lt;K,V&gt;" line="955"/>
                <method name="Entry" type="constructor" line="957">
                    <params>
                        <param name="hash" type="int"/>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                        <param name="next" type="Entry<K,V>"/>
                    </params>
                </method>
                <method name="clone" type="Object" line="964"/>
                <method name="getKey" type="K" line="971"/>
                <method name="getValue" type="V" line="975"/>
                <method name="setValue" type="V" line="979">
                    <params>
                        <param name="value" type="V"/>
                    </params>
                    <declaration name="oldValue" type="V" line="983"/>
                </method>
                <method name="equals" type="boolean" line="988">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="e" type="Map.Entry" line="991"/>
                </method>
                <method name="hashCode" type="int" line="997"/>
                <method name="toString" type="String" line="1001"/>
            </class>
            <declaration name="KEYS" type="int" line="1007"/>
            <declaration name="VALUES" type="int" line="1008"/>
            <declaration name="ENTRIES" type="int" line="1009"/>
            <class name="Enumerator" line="1011">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <comment line="970">
                    Map.Entry Ops                    
                </comment>
                <comment line="1075">
                    Iterator methods                    
                </comment>
                <implements interface="Enumeration">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <javadoc line="1011">
                    A hashtable enumerator class.  This class implements both the
                      Enumeration and Iterator interfaces, but individual instances
                      can be created with the Iterator methods disabled.  This is necessary
                      to avoid unintentionally increasing the capabilities granted a user
                      by passing an Enumeration.                    
                </javadoc>
                <declaration name="table" type="Entry[]" line="1019"/>
                <declaration name="index" type="int" line="1020"/>
                <declaration name="entry" type="Entry&lt;K,V&gt;" line="1021"/>
                <declaration name="lastReturned" type="Entry&lt;K,V&gt;" line="1022"/>
                <declaration name="type" type="int" line="1023"/>
                <declaration name="iterator" type="boolean" line="1025"/>
                <javadoc line="1025">
                    Indicates whether this Enumerator is serving as an Iterator
                      or an Enumeration.  (true -&gt; Iterator).                    
                </javadoc>
                <declaration name="expectedModCount" type="int" line="1031"/>
                <javadoc line="1031">
                    The modCount value that the iterator believes that the backing
                      Hashtable should have.  If this expectation is violated, the iterator
                      has detected concurrent modification.                    
                </javadoc>
                <method name="Enumerator" type="constructor" line="1038">
                    <params>
                        <param name="type" type="int"/>
                        <param name="iterator" type="boolean"/>
                    </params>
                </method>
                <method name="hasMoreElements" type="boolean" line="1043">
                    <comment line="1047">
                                                
                    </comment>
                    <declaration name="e" type="Entry&lt;K,V&gt;" line="1044"/>
                    <declaration name="i" type="int" line="1045"/>
                    <declaration name="t" type="Entry[]" line="1046"/>
                    <scope line="1048"/>
                </method>
                <method name="nextElement" type="T" line="1056">
                    <comment line="1060">
                                                
                    </comment>
                    <declaration name="et" type="Entry&lt;K,V&gt;" line="1057"/>
                    <declaration name="i" type="int" line="1058"/>
                    <declaration name="t" type="Entry[]" line="1059"/>
                    <scope line="1061"/>
                    <scope line="1066">
                        <declaration name="e" type="Entry&lt;K,V&gt;" line="1067"/>
                    </scope>
                </method>
                <method name="hasNext" type="boolean" line="1075"/>
                <method name="next" type="T" line="1079"/>
                <method name="remove" type="void" line="1085">
                    <scope line="1093">
                        <declaration name="tab" type="Entry[]" line="1094"/>
                        <declaration name="index" type="int" line="1095"/>
                        <scope line="1098">
                            <scope line="1099"/>
                        </scope>
                    </scope>
                </method>
            </class>
        </class>
    </source>