<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <class name="AbstractList" line="2">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="AbstractCollection">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <implements interface="List">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </implements>
            <javadoc line="2">
                This class provides a skeletal implementation of the {@link List}interface to minimize the effort required to implement this interface
                  backed by a &quot;random access&quot; data store (such as an array).  For sequential
                  access data (such as a linked list), {@link AbstractSequentialList} should
                  be used in preference to this class.
                  &lt;p&gt;To implement an unmodifiable list, the programmer needs only to extend
                  this class and provide implementations for the {@link #get(int)} and{@link List#size() size()} methods.
                  &lt;p&gt;To implement a modifiable list, the programmer must additionally
                  override the {@link #set(int,Object) set(int, E)} method (which otherwise
                  throws an {@code UnsupportedOperationException}).  If the list is
                  variable-size the programmer must additionally override the{@link #add(int,Object) add(int, E)} and {@link #remove(int)} methods.
                  &lt;p&gt;The programmer should generally provide a void (no argument) and collection
                  constructor, as per the recommendation in the {@link Collection} interface
                  specification.
                  &lt;p&gt;Unlike the other abstract collection implementations, the programmer does
                  &lt;i&gt;not&lt;/i&gt; have to provide an iterator implementation; the iterator and
                  list iterator are implemented by this class, on top of the &quot;random access&quot;
                  methods:{@link #get(int)},{@link #set(int,Object) set(int, E)},{@link #add(int,Object) add(int, E)} and{@link #remove(int)}.
                  &lt;p&gt;The documentation for each non-abstract method in this class describes its
                  implementation in detail.  Each of these methods may be overridden if the
                  collection being implemented admits a more efficient implementation.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <author>
                    Josh Bloch                    
                </author>
                <author>
                    Neal Gafter                    
                </author>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <javadoc line="31">
                Sole constructor.  (For invocation by subclass constructors, typically
                  implicit.)                
            </javadoc>
            <method name="AbstractList" type="constructor" line="35"/>
            <javadoc line="37">
                Appends the specified element to the end of this list (optional
                  operation).
                  &lt;p&gt;Lists that support this operation may place limitations on what
                  elements may be added to this list.  In particular, some
                  lists will refuse to add null elements, and others will impose
                  restrictions on the type of elements that may be added.  List
                  classes should clearly specify in their documentation any restrictions
                  on what elements may be added.
                  &lt;p&gt;This implementation calls {@code add(size(), e)}.
                  &lt;p&gt;Note that this implementation throws an{@code UnsupportedOperationException} unless{@link #add(int,Object) add(int, E)} is overridden.                
                <param>
                    e element to be appended to this list                    
                </param>
                <return>
                    {@code true} (as specified by {@link Collection#add})                    
                </return>
                <throws>
                    UnsupportedOperationException if the {@code add} operation
                      is not supported by this list                    
                </throws>
                <throws>
                    ClassCastException if the class of the specified element
                      prevents it from being added to this list                    
                </throws>
                <throws>
                    NullPointerException if the specified element is null and this
                      list does not permit null elements                    
                </throws>
                <throws>
                    IllegalArgumentException if some property of this element
                      prevents it from being added to this list                    
                </throws>
            </javadoc>
            <method name="add" type="boolean" line="59">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <method name="get" type="E" line="63"/>
            <javadoc line="63">
                {@inheritDoc}                
                <throws>
                    IndexOutOfBoundsException {@inheritDoc}                    
                </throws>
            </javadoc>
            <javadoc line="68">
                {@inheritDoc}&lt;p&gt;This implementation always throws an{@code UnsupportedOperationException}.                
                <throws>
                    UnsupportedOperationException {@inheritDoc}                    
                </throws>
                <throws>
                    ClassCastException            {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException          {@inheritDoc}                    
                </throws>
                <throws>
                    IllegalArgumentException      {@inheritDoc}                    
                </throws>
                <throws>
                    IndexOutOfBoundsException     {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="set" type="E" line="76">
                <params>
                    <param name="index" type="int"/>
                    <param name="element" type="E"/>
                </params>
            </method>
            <javadoc line="79">
                {@inheritDoc}&lt;p&gt;This implementation always throws an{@code UnsupportedOperationException}.                
                <throws>
                    UnsupportedOperationException {@inheritDoc}                    
                </throws>
                <throws>
                    ClassCastException            {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException          {@inheritDoc}                    
                </throws>
                <throws>
                    IllegalArgumentException      {@inheritDoc}                    
                </throws>
                <throws>
                    IndexOutOfBoundsException     {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="add" type="void" line="87">
                <params>
                    <param name="index" type="int"/>
                    <param name="element" type="E"/>
                </params>
            </method>
            <javadoc line="90">
                {@inheritDoc}&lt;p&gt;This implementation always throws an{@code UnsupportedOperationException}.                
                <throws>
                    UnsupportedOperationException {@inheritDoc}                    
                </throws>
                <throws>
                    IndexOutOfBoundsException     {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="remove" type="E" line="95">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <javadoc line="98">
                {@inheritDoc}&lt;p&gt;This implementation first gets a list iterator (with{@code listIterator()}).  Then, it iterates over the list until the
                  specified element is found or the end of the list is reached.                
                <throws>
                    ClassCastException   {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="indexOf" type="int" line="104">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="it" type="ListIterator&amp;lt;E&amp;gt;" line="105"/>
                <scope line="106"/>
                <scope line="109"/>
            </method>
            <javadoc line="114">
                {@inheritDoc}&lt;p&gt;This implementation first gets a list iterator that points to the end
                  of the list (with {@code listIterator(size())}).  Then, it iterates
                  backwards over the list until the specified element is found, or the
                  beginning of the list is reached.                
                <throws>
                    ClassCastException   {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="lastIndexOf" type="int" line="122">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="it" type="ListIterator&amp;lt;E&amp;gt;" line="123"/>
                <scope line="124"/>
                <scope line="127"/>
            </method>
            <javadoc line="132">
                Removes all of the elements from this list (optional operation).
                  The list will be empty after this call returns.
                  &lt;p&gt;This implementation calls {@code removeRange(0, size())}.
                  &lt;p&gt;Note that this implementation throws an{@code UnsupportedOperationException} unless {@code remove(int
                  index)} or {@code removeRange(int fromIndex, int toIndex)} is
                  overridden.                
                <throws>
                    UnsupportedOperationException if the {@code clear} operation
                      is not supported by this list                    
                </throws>
            </javadoc>
            <method name="clear" type="void" line="142"/>
            <javadoc line="145">
                {@inheritDoc}&lt;p&gt;This implementation gets an iterator over the specified collection
                  and iterates over it, inserting the elements obtained from the
                  iterator into this list at the appropriate position, one at a time,
                  using {@code add(int, E)}.
                  Many implementations will override this method for efficiency.
                  &lt;p&gt;Note that this implementation throws an{@code UnsupportedOperationException} unless{@link #add(int,Object) add(int, E)} is overridden.                
                <throws>
                    UnsupportedOperationException {@inheritDoc}                    
                </throws>
                <throws>
                    ClassCastException            {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException          {@inheritDoc}                    
                </throws>
                <throws>
                    IllegalArgumentException      {@inheritDoc}                    
                </throws>
                <throws>
                    IndexOutOfBoundsException     {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="addAll" type="boolean" line="158">
                <params>
                    <param name="index" type="int"/>
                    <param name="c" type="Collection&lt;? extends E&gt;"/>
                </params>
                <declaration name="modified" type="boolean" line="160"/>
                <scope line="161"/>
            </method>
            <javadoc line="167">
                Returns an iterator over the elements in this list in proper sequence.
                  &lt;p&gt;This implementation returns a straightforward implementation of the
                  iterator interface, relying on the backing list&apos;s {@code size()},{@code get(int)}, and {@code remove(int)} methods.
                  &lt;p&gt;Note that the iterator returned by this method will throw an{@link UnsupportedOperationException} in response to its{@code remove} method unless the list&apos;s {@code remove(int)} method is
                  overridden.
                  &lt;p&gt;This implementation can be made to throw runtime exceptions in the
                  face of concurrent modification, as described in the specification
                  for the (protected) {@link #modCount} field.                
                <return>
                    an iterator over the elements in this list in proper sequence                    
                </return>
            </javadoc>
            <method name="iterator" type="Iterator&lt;E&gt;" line="178"/>
            <javadoc line="181">
                {@inheritDoc}&lt;p&gt;This implementation returns {@code listIterator(0)}.                
                <see>
                    #listIterator(int)                    
                </see>
            </javadoc>
            <method name="listIterator" type="ListIterator&lt;E&gt;" line="185"/>
            <javadoc line="188">
                {@inheritDoc}&lt;p&gt;This implementation returns a straightforward implementation of the{@code ListIterator} interface that extends the implementation of the{@code Iterator} interface returned by the {@code iterator()} method.
                  The {@code ListIterator} implementation relies on the backing list&apos;s{@code get(int)}, {@code set(int, E)}, {@code add(int, E)}and {@code remove(int)} methods.
                  &lt;p&gt;Note that the list iterator returned by this implementation will
                  throw an {@link UnsupportedOperationException} in response to its{@code remove}, {@code set} and {@code add} methods unless the
                  list&apos;s {@code remove(int)}, {@code set(int, E)}, and{@code add(int, E)} methods are overridden.
                  &lt;p&gt;This implementation can be made to throw runtime exceptions in the
                  face of concurrent modification, as described in the specification for
                  the (protected) {@link #modCount} field.                
                <throws>
                    IndexOutOfBoundsException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="listIterator" type="ListIterator&lt;E&gt;" line="199">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <class name="Itr" line="203">
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="cursor" type="int" line="204"/>
                <javadoc line="204">
                    Index of element to be returned by subsequent call to next.                    
                </javadoc>
                <declaration name="lastRet" type="int" line="208"/>
                <javadoc line="208">
                    Index of element returned by most recent call to next or
                      previous.  Reset to -1 if this element is deleted by a call
                      to remove.                    
                </javadoc>
                <declaration name="expectedModCount" type="int" line="214"/>
                <javadoc line="214">
                    The modCount value that the iterator believes that the backing
                      List should have.  If this expectation is violated, the iterator
                      has detected concurrent modification.                    
                </javadoc>
                <method name="hasNext" type="boolean" line="220"/>
                <method name="next" type="E" line="223">
                    <scope line="225">
                        <declaration name="i" type="int" line="226"/>
                        <declaration name="next" type="E" line="227"/>
                    </scope>
                    <scope line="232"/>
                </method>
                <method name="remove" type="void" line="237">
                    <scope line="240"/>
                    <scope line="246"/>
                </method>
                <method name="checkForComodification" type="void" line="250"/>
            </class>
            <class name="ListItr" line="254">
                <extends class="Itr"/>
                <implements interface="ListIterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <method name="ListItr" type="constructor" line="255">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="hasPrevious" type="boolean" line="258"/>
                <method name="previous" type="E" line="261">
                    <scope line="263">
                        <declaration name="i" type="int" line="264"/>
                        <declaration name="previous" type="E" line="265"/>
                    </scope>
                    <scope line="269"/>
                </method>
                <method name="nextIndex" type="int" line="274"/>
                <method name="previousIndex" type="int" line="277"/>
                <method name="set" type="void" line="280">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                    <scope line="283"/>
                    <scope line="287"/>
                </method>
                <method name="add" type="void" line="291">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                    <scope line="293">
                        <declaration name="i" type="int" line="294"/>
                    </scope>
                    <scope line="300"/>
                </method>
            </class>
            <javadoc line="305">
                {@inheritDoc}&lt;p&gt;This implementation returns a list that subclasses{@code AbstractList}.  The subclass stores, in private fields, the
                  offset of the subList within the backing list, the size of the subList
                  (which can change over its lifetime), and the expected{@code modCount} value of the backing list.  There are two variants
                  of the subclass, one of which implements {@code RandomAccess}.
                  If this list implements {@code RandomAccess} the returned list will
                  be an instance of the subclass that implements {@code RandomAccess}.
                  &lt;p&gt;The subclass&apos;s {@code set(int, E)}, {@code get(int)},{@code add(int, E)}, {@code remove(int)}, {@code addAll(int,
                  Collection)} and {@code removeRange(int, int)} methods all
                  delegate to the corresponding methods on the backing abstract list,
                  after bounds-checking the index and adjusting for the offset.  The{@code addAll(Collection c)} method merely returns {@code addAll(size,
                  c)}.
                  &lt;p&gt;The {@code listIterator(int)} method returns a &quot;wrapper object&quot;
                  over a list iterator on the backing list, which is created with the
                  corresponding method on the backing list.  The {@code iterator} method
                  merely returns {@code listIterator()}, and the {@code size} method
                  merely returns the subclass&apos;s {@code size} field.
                  &lt;p&gt;All methods first check to see if the actual {@code modCount} of
                  the backing list is equal to its expected value, and throw a{@code ConcurrentModificationException} if it is not.                
                <throws>
                    IndexOutOfBoundsException if an endpoint index value is out of range{@code (fromIndex &lt; 0 || toIndex &gt; size)}                    
                </throws>
                <throws>
                    IllegalArgumentException if the endpoint indices are out of order{@code (fromIndex &gt; toIndex)}                    
                </throws>
            </javadoc>
            <method name="subList" type="List&lt;E&gt;" line="327">
                <params>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="330">
                Compares the specified object with this list for equality.  Returns{@code true} if and only if the specified object is also a list, both
                  lists have the same size, and all corresponding pairs of elements in
                  the two lists are &lt;i&gt;equal&lt;/i&gt;.  (Two elements {@code e1} and{@code e2} are &lt;i&gt;equal&lt;/i&gt; if {@code (e1==null ? e2==null :
                  e1.equals(e2))}.)  In other words, two lists are defined to be
                  equal if they contain the same elements in the same order.&lt;p&gt;
                  This implementation first checks if the specified object is this
                  list. If so, it returns {@code true}; if not, it checks if the
                  specified object is a list. If not, it returns {@code false}; if so,
                  it iterates over both lists, comparing corresponding pairs of elements.
                  If any comparison returns {@code false}, this method returns{@code false}.  If either iterator runs out of elements before the
                  other it returns {@code false} (as the lists are of unequal length);
                  otherwise it returns {@code true} when the iterations complete.                
                <param>
                    o the object to be compared for equality with this list                    
                </param>
                <return>
                    {@code true} if the specified object is equal to this list                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="346">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="e1" type="ListIterator&amp;lt;E&amp;gt;" line="349"/>
                <declaration name="e2" type="ListIterator" line="350"/>
                <scope line="351">
                    <declaration name="o1" type="E" line="352"/>
                    <declaration name="o2" type="Object" line="353"/>
                </scope>
            </method>
            <javadoc line="358">
                Returns the hash code value for this list.
                  &lt;p&gt;This implementation uses exactly the code that is used to define the
                  list hash function in the documentation for the {@link List#hashCode}method.                
                <return>
                    the hash code value for this list                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="364">
                <declaration name="hashCode" type="int" line="365"/>
            </method>
            <javadoc line="369">
                Removes from this list all of the elements whose index is between{@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
                  Shifts any succeeding elements to the left (reduces their index).
                  This call shortens the list by {@code (toIndex - fromIndex)} elements.
                  (If {@code toIndex==fromIndex}, this operation has no effect.)
                  &lt;p&gt;This method is called by the {@code clear} operation on this list
                  and its subLists.  Overriding this method to take advantage of
                  the internals of the list implementation can &lt;i&gt;substantially&lt;/i&gt;
                  improve the performance of the {@code clear} operation on this list
                  and its subLists.
                  &lt;p&gt;This implementation gets a list iterator positioned before{@code fromIndex}, and repeatedly calls {@code ListIterator.next}followed by {@code ListIterator.remove} until the entire range has
                  been removed.  &lt;b&gt;Note: if {@code ListIterator.remove} requires linear
                  time, this implementation requires quadratic time.&lt;/b&gt;                
                <param>
                    fromIndex index of first element to be removed                    
                </param>
                <param>
                    toIndex index after last element to be removed                    
                </param>
            </javadoc>
            <method name="removeRange" type="void" line="385">
                <params>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <declaration name="it" type="ListIterator&amp;lt;E&amp;gt;" line="386"/>
                <scope line="387"/>
            </method>
            <declaration name="modCount" type="int" line="392"/>
            <javadoc line="392">
                The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;.
                  Structural modifications are those that change the size of the
                  list, or otherwise perturb it in such a fashion that iterations in
                  progress may yield incorrect results.
                  &lt;p&gt;This field is used by the iterator and list iterator implementation
                  returned by the {@code iterator} and {@code listIterator} methods.
                  If the value of this field changes unexpectedly, the iterator (or list
                  iterator) will throw a {@code ConcurrentModificationException} in
                  response to the {@code next}, {@code remove}, {@code previous},{@code set} or {@code add} operations.  This provides
                  &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in
                  the face of concurrent modification during iteration.
                  &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass
                  wishes to provide fail-fast iterators (and list iterators), then it
                  merely has to increment this field in its {@code add(int, E)} and{@code remove(int)} methods (and any other methods that it overrides
                  that result in structural modifications to the list).  A single call to{@code add(int, E)} or {@code remove(int)} must add no more than
                  one to this field, or the iterators (and list iterators) will throw
                  bogus {@code ConcurrentModificationExceptions}.  If an implementation
                  does not wish to provide fail-fast iterators, this field may be
                  ignored.                
            </javadoc>
            <method name="rangeCheckForAdd" type="void" line="414">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <method name="outOfBoundsMsg" type="String" line="417">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
        </class>
        <class name="SubList" line="421">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="AbstractList">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <declaration name="l" type="AbstractList&amp;lt;E&amp;gt;" line="422"/>
            <declaration name="offset" type="int" line="423"/>
            <declaration name="size" type="int" line="424"/>
            <method name="SubList" type="constructor" line="425">
                <params>
                    <param name="list" type="AbstractList&lt;E&gt;"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <method name="set" type="E" line="434">
                <params>
                    <param name="index" type="int"/>
                    <param name="element" type="E"/>
                </params>
            </method>
            <method name="get" type="E" line="439">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <method name="size" type="int" line="444"/>
            <method name="add" type="void" line="448">
                <params>
                    <param name="index" type="int"/>
                    <param name="element" type="E"/>
                </params>
            </method>
            <method name="remove" type="E" line="455">
                <params>
                    <param name="index" type="int"/>
                </params>
                <declaration name="result" type="E" line="458"/>
            </method>
            <method name="removeRange" type="void" line="463">
                <params>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <method name="addAll" type="boolean" line="469">
                <params>
                    <param name="c" type="Collection&lt;? extends E&gt;"/>
                </params>
            </method>
            <method name="addAll" type="boolean" line="472">
                <params>
                    <param name="index" type="int"/>
                    <param name="c" type="Collection&lt;? extends E&gt;"/>
                </params>
                <declaration name="cSize" type="int" line="474"/>
            </method>
            <method name="iterator" type="Iterator&lt;E&gt;" line="482"/>
            <method name="listIterator" type="ListIterator&lt;E&gt;" line="485">
                <params>
                    <param name="index" type="int"/>
                </params>
                <anonymous_class line="488">
                    <declaration name="i" type="ListIterator&amp;lt;E&amp;gt;" line="489"/>
                    <method name="hasNext" type="boolean" line="490"/>
                    <method name="next" type="E" line="493"/>
                    <method name="hasPrevious" type="boolean" line="497"/>
                    <method name="previous" type="E" line="500"/>
                    <method name="nextIndex" type="int" line="504"/>
                    <method name="previousIndex" type="int" line="507"/>
                    <method name="remove" type="void" line="510"/>
                    <method name="set" type="void" line="515">
                        <params>
                            <param name="e" type="E"/>
                        </params>
                    </method>
                    <method name="add" type="void" line="518">
                        <params>
                            <param name="e" type="E"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <method name="subList" type="List&lt;E&gt;" line="526">
                <params>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <method name="rangeCheck" type="void" line="529">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <method name="rangeCheckForAdd" type="void" line="532">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <method name="outOfBoundsMsg" type="String" line="535">
                <params>
                    <param name="index" type="int"/>
                </params>
            </method>
            <method name="checkForComodification" type="void" line="538"/>
        </class>
        <class name="RandomAccessSubList" line="542">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="SubList">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <implements interface="RandomAccess"/>
            <method name="RandomAccessSubList" type="constructor" line="543">
                <params>
                    <param name="list" type="AbstractList&lt;E&gt;"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <method name="subList" type="List&lt;E&gt;" line="546">
                <params>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
        </class>
    </source>