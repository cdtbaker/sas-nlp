<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.regex">
        <class name="Matcher" line="2">
            <implements interface="MatchResult"/>
            <javadoc line="2">
                An engine that performs match operations on a {@link java.lang.CharSequence&lt;/code&gt;character sequence&lt;code&gt;} by interpreting a {@link Pattern}.
                  &lt;p&gt; A matcher is created from a pattern by invoking the pattern&apos;s {@link Pattern#matcher matcher} method.  Once created, a matcher can be used to
                  perform three different kinds of match operations:
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt; The {@link #matches matches} method attempts to match the entire
                  input sequence against the pattern.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The {@link #lookingAt lookingAt} method attempts to match the
                  input sequence, starting at the beginning, against the pattern.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The {@link #find find} method scans the input sequence looking for
                  the next subsequence that matches the pattern.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt; Each of these methods returns a boolean indicating success or failure.
                  More information about a successful match can be obtained by querying the
                  state of the matcher.
                  &lt;p&gt; A matcher finds matches in a subset of its input called the
                  &lt;i&gt;region&lt;/i&gt;. By default, the region contains all of the matcher&apos;s input.
                  The region can be modified via the{@link #region region} method and queried
                  via the {@link #regionStart regionStart} and {@link #regionEnd regionEnd}methods. The way that the region boundaries interact with some pattern
                  constructs can be changed. See {@link #useAnchoringBoundsuseAnchoringBounds} and {@link #useTransparentBounds useTransparentBounds}for more details.
                  &lt;p&gt; This class also defines methods for replacing matched subsequences with
                  new strings whose contents can, if desired, be computed from the match
                  result.  The {@link #appendReplacement appendReplacement} and {@link #appendTail appendTail} methods can be used in tandem in order to collect
                  the result into an existing string buffer, or the more convenient {@link #replaceAll replaceAll} method can be used to create a string in which every
                  matching subsequence in the input sequence is replaced.
                  &lt;p&gt; The explicit state of a matcher includes the start and end indices of
                  the most recent successful match.  It also includes the start and end
                  indices of the input subsequence captured by each &lt;a
                  href=&quot;Pattern.html#cg&quot;&gt;capturing group&lt;/a&gt; in the pattern as well as a total
                  count of such subsequences.  As a convenience, methods are also provided for
                  returning these captured subsequences in string form.
                  &lt;p&gt; The explicit state of a matcher is initially undefined; attempting to
                  query any part of it before a successful match will cause an {@link IllegalStateException} to be thrown.  The explicit state of a matcher is
                  recomputed by every match operation.
                  &lt;p&gt; The implicit state of a matcher includes the input character sequence as
                  well as the &lt;i&gt;append position&lt;/i&gt;, which is initially zero and is updated
                  by the {@link #appendReplacement appendReplacement} method.
                  &lt;p&gt; A matcher may be reset explicitly by invoking its {@link #reset()}method or, if a new input sequence is desired, its {@link #reset(java.lang.CharSequence) reset(CharSequence)} method.  Resetting a
                  matcher discards its explicit state information and sets the append position
                  to zero.
                  &lt;p&gt; Instances of this class are not safe for use by multiple concurrent
                  threads. &lt;/p&gt;                
                <author>
                    Mike McCloskey                    
                </author>
                <author>
                    Mark Reinhold                    
                </author>
                <author>
                    JSR-51 Expert Group                    
                </author>
                <since>
                    1.4                    
                </since>
                <spec>
                    JSR-51                    
                </spec>
            </javadoc>
            <declaration name="parentPattern" type="Pattern" line="51"/>
            <javadoc line="51">
                The Pattern object that created this Matcher.                
            </javadoc>
            <declaration name="groups" type="int[]" line="55"/>
            <javadoc line="55">
                The storage used by groups. They may contain invalid values if
                  a group was skipped during the matching.                
            </javadoc>
            <declaration name="from" type="int" line="60"/>
            <javadoc line="60">
                The range within the sequence that is to be matched. Anchors
                  will match at these &quot;hard&quot; boundaries. Changing the region
                  changes these values.                
            </javadoc>
            <declaration name="lookbehindTo" type="int" line="66"/>
            <javadoc line="66">
                Lookbehind uses this value to ensure that the subexpression
                  match ends at the point where the lookbehind was encountered.                
            </javadoc>
            <declaration name="text" type="CharSequence" line="71"/>
            <javadoc line="71">
                The original string being matched.                
            </javadoc>
            <declaration name="ENDANCHOR" type="int" line="75"/>
            <javadoc line="75">
                Matcher state used by the last node. NOANCHOR is used when a
                  match does not have to consume all of the input. ENDANCHOR is
                  the mode used for matching all the input.                
            </javadoc>
            <declaration name="NOANCHOR" type="int" line="81"/>
            <declaration name="acceptMode" type="int" line="82"/>
            <declaration name="first" type="int" line="83"/>
            <javadoc line="83">
                The range of string that last matched the pattern. If the last
                  match failed then first is -1; last initially holds 0 then it
                  holds the index of the end of the last match (which is where the
                  next search starts).                
            </javadoc>
            <declaration name="oldLast" type="int" line="90"/>
            <javadoc line="90">
                The end index of what matched in the last match operation.                
            </javadoc>
            <declaration name="lastAppendPosition" type="int" line="94"/>
            <javadoc line="94">
                The index of the last position appended in a substitution.                
            </javadoc>
            <declaration name="locals" type="int[]" line="98"/>
            <javadoc line="98">
                Storage used by nodes to tell what repetition they are on in
                  a pattern, and where groups begin. The nodes themselves are stateless,
                  so they rely on this field to hold state during a match.                
            </javadoc>
            <declaration name="hitEnd" type="boolean" line="104"/>
            <javadoc line="104">
                Boolean indicating whether or not more input could change
                  the results of the last match.
                  If hitEnd is true, and a match was found, then more input
                  might cause a different match to be found.
                  If hitEnd is true and a match was not found, then more
                  input could cause a match to be found.
                  If hitEnd is false and a match was found, then more input
                  will not change the match.
                  If hitEnd is false and a match was not found, then more
                  input will not cause a match to be found.                
            </javadoc>
            <declaration name="requireEnd" type="boolean" line="117"/>
            <javadoc line="117">
                Boolean indicating whether or not more input could change
                  a positive match into a negative one.
                  If requireEnd is true, and a match was found, then more
                  input could cause the match to be lost.
                  If requireEnd is false and a match was found, then more
                  input might change the match but the match won&apos;t be lost.
                  If a match was not found, then requireEnd has no meaning.                
            </javadoc>
            <declaration name="transparentBounds" type="boolean" line="127"/>
            <javadoc line="127">
                If transparentBounds is true then the boundaries of this
                  matcher&apos;s region are transparent to lookahead, lookbehind,
                  and boundary matching constructs that try to see beyond them.                
            </javadoc>
            <declaration name="anchoringBounds" type="boolean" line="133"/>
            <javadoc line="133">
                If anchoringBounds is true then the boundaries of this
                  matcher&apos;s region match anchors such as ^ and $.                
            </javadoc>
            <javadoc line="138">
                No default constructor.                
            </javadoc>
            <method name="Matcher" type="constructor" line="141"/>
            <javadoc line="143">
                All matchers have the state used by Pattern during a match.                
            </javadoc>
            <method name="Matcher" type="constructor" line="146">
                <params>
                    <param name="parent" type="Pattern"/>
                    <param name="text" type="CharSequence"/>
                </params>
                <declaration name="parentGroupCount" type="int" line="149"/>
            </method>
            <javadoc line="154">
                Returns the pattern that is interpreted by this matcher.                
                <return>
                    The pattern for which this matcher was created                    
                </return>
            </javadoc>
            <method name="pattern" type="Pattern" line="158"/>
            <javadoc line="161">
                Returns the match state of this matcher as a {@link MatchResult}.
                  The result is unaffected by subsequent operations performed upon this
                  matcher.                
                <return>
                    a &lt;code&gt;MatchResult&lt;/code&gt; with the state of this matcher                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toMatchResult" type="MatchResult" line="168">
                <declaration name="result" type="Matcher" line="169"/>
            </method>
            <javadoc line="175">
                Changes the &lt;tt&gt;Pattern&lt;/tt&gt; that this &lt;tt&gt;Matcher&lt;/tt&gt; uses to
                  find matches with.
                  &lt;p&gt; This method causes this matcher to lose information
                  about the groups of the last match that occurred. The
                  matcher&apos;s position in the input is maintained and its
                  last append position is unaffected.&lt;/p&gt;                
                <param>
                    newPatternThe new pattern used by this matcher                    
                </param>
                <return>
                    This matcher                    
                </return>
                <throws>
                    IllegalArgumentExceptionIf newPattern is &lt;tt&gt;null&lt;/tt&gt;                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="usePattern" type="Matcher" line="187">
                <params>
                    <param name="newPattern" type="Pattern"/>
                </params>
                <declaration name="parentGroupCount" type="int" line="190"/>
            </method>
            <javadoc line="197">
                Resets this matcher.
                  &lt;p&gt; Resetting a matcher discards all of its explicit state information
                  and sets its append position to zero. The matcher&apos;s region is set to the
                  default region, which is its entire character sequence. The anchoring
                  and transparency of this matcher&apos;s region boundaries are unaffected.                
                <return>
                    This matcher                    
                </return>
            </javadoc>
            <method name="reset" type="Matcher" line="205"/>
            <javadoc line="216">
                Resets this matcher with a new input sequence.
                  &lt;p&gt; Resetting a matcher discards all of its explicit state information
                  and sets its append position to zero.  The matcher&apos;s region is set to
                  the default region, which is its entire character sequence.  The
                  anchoring and transparency of this matcher&apos;s region boundaries are
                  unaffected.                
                <param>
                    inputThe new input character sequence                    
                </param>
                <return>
                    This matcher                    
                </return>
            </javadoc>
            <method name="reset" type="Matcher" line="226">
                <params>
                    <param name="input" type="CharSequence"/>
                </params>
            </method>
            <javadoc line="230">
                Returns the start index of the previous match.  &lt;/p&gt;                
                <return>
                    The index of the first character matched                    
                </return>
                <throws>
                    IllegalStateExceptionIf no match has yet been attempted,
                      or if the previous match operation failed                    
                </throws>
            </javadoc>
            <method name="start" type="int" line="236"/>
            <javadoc line="240">
                Returns the start index of the subsequence captured by the given group
                  during the previous match operation.
                  &lt;p&gt; &lt;a href=&quot;Pattern.html#cg&quot;&gt;Capturing groups&lt;/a&gt; are indexed from left
                  to right, starting at one.  Group zero denotes the entire pattern, so
                  the expression &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;start(0)&lt;/tt&gt; is equivalent to
                  &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;start()&lt;/tt&gt;.  &lt;/p&gt;                
                <param>
                    groupThe index of a capturing group in this matcher&apos;s pattern                    
                </param>
                <return>
                    The index of the first character captured by the group,
                      or &lt;tt&gt;-1&lt;/tt&gt; if the match was successful but the group
                      itself did not match anything                    
                </return>
                <throws>
                    IllegalStateExceptionIf no match has yet been attempted,
                      or if the previous match operation failed                    
                </throws>
                <throws>
                    IndexOutOfBoundsExceptionIf there is no capturing group in the pattern
                      with the given index                    
                </throws>
            </javadoc>
            <method name="start" type="int" line="256">
                <params>
                    <param name="group" type="int"/>
                </params>
            </method>
            <javadoc line="261">
                Returns the offset after the last character matched.  &lt;/p&gt;                
                <return>
                    The offset after the last character matched                    
                </return>
                <throws>
                    IllegalStateExceptionIf no match has yet been attempted,
                      or if the previous match operation failed                    
                </throws>
            </javadoc>
            <method name="end" type="int" line="267"/>
            <javadoc line="271">
                Returns the offset after the last character of the subsequence
                  captured by the given group during the previous match operation.
                  &lt;p&gt; &lt;a href=&quot;Pattern.html#cg&quot;&gt;Capturing groups&lt;/a&gt; are indexed from left
                  to right, starting at one.  Group zero denotes the entire pattern, so
                  the expression &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;end(0)&lt;/tt&gt; is equivalent to
                  &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;end()&lt;/tt&gt;.  &lt;/p&gt;                
                <param>
                    groupThe index of a capturing group in this matcher&apos;s pattern                    
                </param>
                <return>
                    The offset after the last character captured by the group,
                      or &lt;tt&gt;-1&lt;/tt&gt; if the match was successful
                      but the group itself did not match anything                    
                </return>
                <throws>
                    IllegalStateExceptionIf no match has yet been attempted,
                      or if the previous match operation failed                    
                </throws>
                <throws>
                    IndexOutOfBoundsExceptionIf there is no capturing group in the pattern
                      with the given index                    
                </throws>
            </javadoc>
            <method name="end" type="int" line="287">
                <params>
                    <param name="group" type="int"/>
                </params>
            </method>
            <javadoc line="292">
                Returns the input subsequence matched by the previous match.
                  &lt;p&gt; For a matcher &lt;i&gt;m&lt;/i&gt; with input sequence &lt;i&gt;s&lt;/i&gt;,
                  the expressions &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;group()&lt;/tt&gt; and
                  &lt;i&gt;s.&lt;/i&gt;&lt;tt&gt;substring(&lt;/tt&gt;&lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;start(),&lt;/tt&gt;&amp;nbsp;&lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;end())&lt;/tt&gt;
                  are equivalent.  &lt;/p&gt;
                  &lt;p&gt; Note that some patterns, for example &lt;tt&gt;a&lt;/tt&gt;, match the empty
                  string.  This method will return the empty string when the pattern
                  successfully matches the empty string in the input.  &lt;/p&gt;                
                <return>
                    The (possibly empty) subsequence matched by the previous match,
                      in string form                    
                </return>
                <throws>
                    IllegalStateExceptionIf no match has yet been attempted,
                      or if the previous match operation failed                    
                </throws>
            </javadoc>
            <method name="group" type="String" line="306"/>
            <javadoc line="309">
                Returns the input subsequence captured by the given group during the
                  previous match operation.
                  &lt;p&gt; For a matcher &lt;i&gt;m&lt;/i&gt;, input sequence &lt;i&gt;s&lt;/i&gt;, and group index
                  &lt;i&gt;g&lt;/i&gt;, the expressions &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;group(&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; and
                  &lt;i&gt;s.&lt;/i&gt;&lt;tt&gt;substring(&lt;/tt&gt;&lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;start(&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;&lt;tt&gt;),&lt;/tt&gt;&amp;nbsp;&lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;end(&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;&lt;tt&gt;))&lt;/tt&gt;
                  are equivalent.  &lt;/p&gt;
                  &lt;p&gt; &lt;a href=&quot;Pattern.html#cg&quot;&gt;Capturing groups&lt;/a&gt; are indexed from left
                  to right, starting at one.  Group zero denotes the entire pattern, so
                  the expression &lt;tt&gt;m.group(0)&lt;/tt&gt; is equivalent to &lt;tt&gt;m.group()&lt;/tt&gt;.
                  &lt;/p&gt;
                  &lt;p&gt; If the match was successful but the group specified failed to match
                  any part of the input sequence, then &lt;tt&gt;null&lt;/tt&gt; is returned. Note
                  that some groups, for example &lt;tt&gt;(a)&lt;/tt&gt;, match the empty string.
                  This method will return the empty string when such a group successfully
                  matches the empty string in the input.  &lt;/p&gt;                
                <param>
                    groupThe index of a capturing group in this matcher&apos;s pattern                    
                </param>
                <return>
                    The (possibly empty) subsequence captured by the group
                      during the previous match, or &lt;tt&gt;null&lt;/tt&gt; if the group
                      failed to match part of the input                    
                </return>
                <throws>
                    IllegalStateExceptionIf no match has yet been attempted,
                      or if the previous match operation failed                    
                </throws>
                <throws>
                    IndexOutOfBoundsExceptionIf there is no capturing group in the pattern
                      with the given index                    
                </throws>
            </javadoc>
            <method name="group" type="String" line="334">
                <params>
                    <param name="group" type="int"/>
                </params>
            </method>
            <javadoc line="340">
                Returns the input subsequence captured by the given
                  &lt;a href=&quot;Pattern.html#groupname&quot;&gt;named-capturing group&lt;/a&gt; during the previous
                  match operation.
                  &lt;p&gt; If the match was successful but the group specified failed to match
                  any part of the input sequence, then &lt;tt&gt;null&lt;/tt&gt; is returned. Note
                  that some groups, for example &lt;tt&gt;(a)&lt;/tt&gt;, match the empty string.
                  This method will return the empty string when such a group successfully
                  matches the empty string in the input.  &lt;/p&gt;                
                <param>
                    nameThe name of a named-capturing group in this matcher&apos;s pattern                    
                </param>
                <return>
                    The (possibly empty) subsequence captured by the named group
                      during the previous match, or &lt;tt&gt;null&lt;/tt&gt; if the group
                      failed to match part of the input                    
                </return>
                <throws>
                    IllegalStateExceptionIf no match has yet been attempted,
                      or if the previous match operation failed                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf there is no capturing group in the pattern
                      with the given name                    
                </throws>
            </javadoc>
            <method name="group" type="String" line="358">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="group" type="int" line="362"/>
            </method>
            <javadoc line="366">
                Returns the number of capturing groups in this matcher&apos;s pattern.
                  &lt;p&gt; Group zero denotes the entire pattern by convention. It is not
                  included in this count.
                  &lt;p&gt; Any non-negative integer smaller than or equal to the value
                  returned by this method is guaranteed to be a valid group index for
                  this matcher.  &lt;/p&gt;                
                <return>
                    The number of capturing groups in this matcher&apos;s pattern                    
                </return>
            </javadoc>
            <method name="groupCount" type="int" line="375"/>
            <javadoc line="378">
                Attempts to match the entire region against the pattern.
                  &lt;p&gt; If the match succeeds then more information can be obtained via the
                  &lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;end&lt;/tt&gt;, and &lt;tt&gt;group&lt;/tt&gt; methods.  &lt;/p&gt;                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if, and only if, the entire region sequence
                      matches this matcher&apos;s pattern                    
                </return>
            </javadoc>
            <method name="matches" type="boolean" line="385"/>
            <javadoc line="388">
                Attempts to find the next subsequence of the input sequence that matches
                  the pattern.
                  &lt;p&gt; This method starts at the beginning of this matcher&apos;s region, or, if
                  a previous invocation of the method was successful and the matcher has
                  not since been reset, at the first character not matched by the previous
                  match.
                  &lt;p&gt; If the match succeeds then more information can be obtained via the
                  &lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;end&lt;/tt&gt;, and &lt;tt&gt;group&lt;/tt&gt; methods.  &lt;/p&gt;                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if, and only if, a subsequence of the input
                      sequence matches this matcher&apos;s pattern                    
                </return>
            </javadoc>
            <method name="find" type="boolean" line="400">
                <declaration name="nextSearchIndex" type="int" line="401"/>
                <scope line="404"/>
            </method>
            <javadoc line="410">
                Resets this matcher and then attempts to find the next subsequence of
                  the input sequence that matches the pattern, starting at the specified
                  index.
                  &lt;p&gt; If the match succeeds then more information can be obtained via the
                  &lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;end&lt;/tt&gt;, and &lt;tt&gt;group&lt;/tt&gt; methods, and subsequent
                  invocations of the {@link #find()} method will start at the first
                  character not matched by this match.  &lt;/p&gt;                
                <throws>
                    IndexOutOfBoundsExceptionIf start is less than zero or if start is greater than the
                      length of the input sequence.                    
                </throws>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if, and only if, a subsequence of the input
                      sequence starting at the given index matches this matcher&apos;s
                      pattern                    
                </return>
            </javadoc>
            <method name="find" type="boolean" line="424">
                <params>
                    <param name="start" type="int"/>
                </params>
                <declaration name="limit" type="int" line="425"/>
            </method>
            <javadoc line="430">
                Attempts to match the input sequence, starting at the beginning of the
                  region, against the pattern.
                  &lt;p&gt; Like the {@link #matches matches} method, this method always starts
                  at the beginning of the region; unlike that method, it does not
                  require that the entire region be matched.
                  &lt;p&gt; If the match succeeds then more information can be obtained via the
                  &lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;end&lt;/tt&gt;, and &lt;tt&gt;group&lt;/tt&gt; methods.  &lt;/p&gt;                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if, and only if, a prefix of the input
                      sequence matches this matcher&apos;s pattern                    
                </return>
            </javadoc>
            <method name="lookingAt" type="boolean" line="441"/>
            <javadoc line="444">
                Returns a literal replacement &lt;code&gt;String&lt;/code&gt; for the specified
                  &lt;code&gt;String&lt;/code&gt;.
                  This method produces a &lt;code&gt;String&lt;/code&gt; that will work
                  as a literal replacement &lt;code&gt;s&lt;/code&gt; in the
                  &lt;code&gt;appendReplacement&lt;/code&gt; method of the {@link Matcher} class.
                  The &lt;code&gt;String&lt;/code&gt; produced will match the sequence of characters
                  in &lt;code&gt;s&lt;/code&gt; treated as a literal sequence. Slashes (&apos;\&apos;) and
                  dollar signs (&apos;$&apos;) will be given no special meaning.                
                <param>
                    s The string to be literalized                    
                </param>
                <return>
                    A literal string replacement                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="quoteReplacement" type="String" line="457">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="sb" type="StringBuilder" line="459"/>
                <scope line="460">
                    <declaration name="c" type="char" line="461"/>
                    <scope line="462"/>
                </scope>
            </method>
            <javadoc line="469">
                Implements a non-terminal append-and-replace step.
                  &lt;p&gt; This method performs the following actions: &lt;/p&gt;
                  &lt;ol&gt;
                  &lt;li&gt;&lt;p&gt; It reads characters from the input sequence, starting at the
                  append position, and appends them to the given string buffer.  It
                  stops after reading the last character preceding the previous match,
                  that is, the character at index {@link #start()}&amp;nbsp;&lt;tt&gt;-&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;1&lt;/tt&gt;.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; It appends the given replacement string to the string buffer.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; It sets the append position of this matcher to the index of
                  the last character matched, plus one, that is, to {@link #end()}.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ol&gt;
                  &lt;p&gt; The replacement string may contain references to subsequences
                  captured during the previous match: Each occurrence of
                  &lt;tt&gt;${&lt;/tt&gt;&lt;i&gt;name&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; or &lt;tt&gt;$&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;
                  will be replaced by the result of evaluating the corresponding{@link #group(String) group(name)} or {@link #group(int) group(g)&lt;/tt&gt;}respectively. For  &lt;tt&gt;$&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;&lt;tt&gt;&lt;/tt&gt;,
                  the first number after the &lt;tt&gt;$&lt;/tt&gt; is always treated as part of
                  the group reference. Subsequent numbers are incorporated into g if
                  they would form a legal group reference. Only the numerals &apos;0&apos;
                  through &apos;9&apos; are considered as potential components of the group
                  reference. If the second group matched the string &lt;tt&gt;&quot;foo&quot;&lt;/tt&gt;, for
                  example, then passing the replacement string &lt;tt&gt;&quot;$2bar&quot;&lt;/tt&gt; would
                  cause &lt;tt&gt;&quot;foobar&quot;&lt;/tt&gt; to be appended to the string buffer. A dollar
                  sign (&lt;tt&gt;$&lt;/tt&gt;) may be included as a literal in the replacement
                  string by preceding it with a backslash (&lt;tt&gt;\$&lt;/tt&gt;).
                  &lt;p&gt; Note that backslashes (&lt;tt&gt;\&lt;/tt&gt;) and dollar signs (&lt;tt&gt;$&lt;/tt&gt;) in
                  the replacement string may cause the results to be different than if it
                  were being treated as a literal replacement string. Dollar signs may be
                  treated as references to captured subsequences as described above, and
                  backslashes are used to escape literal characters in the replacement
                  string.
                  &lt;p&gt; This method is intended to be used in a loop together with the{@link #appendTail appendTail} and {@link #find find} methods.  The
                  following code, for example, writes &lt;tt&gt;one dog two dogs in the
                  yard&lt;/tt&gt; to the standard-output stream: &lt;/p&gt;
                  &lt;blockquote&gt;&lt;pre&gt;
                  Pattern p = Pattern.compile(&quot;cat&quot;);
                  Matcher m = p.matcher(&quot;one cat two cats in the yard&quot;);
                  StringBuffer sb = new StringBuffer();
                  while (m.find()) {
                  m.appendReplacement(sb, &quot;dog&quot;);
                  }
                  m.appendTail(sb);
                  System.out.println(sb.toString());&lt;/pre&gt;&lt;/blockquote&gt;                
                <param>
                    sbThe target string buffer                    
                </param>
                <param>
                    replacementThe replacement string                    
                </param>
                <return>
                    This matcher                    
                </return>
                <throws>
                    IllegalStateExceptionIf no match has yet been attempted,
                      or if the previous match operation failed                    
                </throws>
                <throws>
                    IllegalArgumentExceptionIf the replacement string refers to a named-capturing
                      group that does not exist in the pattern                    
                </throws>
                <throws>
                    IndexOutOfBoundsExceptionIf the replacement string refers to a capturing group
                      that does not exist in the pattern                    
                </throws>
            </javadoc>
            <method name="appendReplacement" type="Matcher" line="524">
                <params>
                    <param name="sb" type="StringBuffer"/>
                    <param name="replacement" type="String"/>
                </params>
                <declaration name="cursor" type="int" line="526"/>
                <declaration name="result" type="StringBuilder" line="527"/>
                <scope line="528">
                    <declaration name="nextChar" type="char" line="529"/>
                    <scope line="530"/>
                    <scope line="536">
                        <declaration name="refNum" type="int" line="539"/>
                        <scope line="540">
                            <declaration name="gsb" type="StringBuilder" line="542"/>
                            <scope line="543">
                                <scope line="545"/>
                                <scope line="549"/>
                            </scope>
                            <declaration name="gname" type="String" line="555"/>
                        </scope>
                        <scope line="561">
                            <declaration name="done" type="boolean" line="565"/>
                            <scope line="566">
                                <scope line="567"/>
                                <declaration name="nextDigit" type="int" line="570"/>
                                <scope line="571"/>
                                <declaration name="newRefNum" type="int" line="574"/>
                                <scope line="575"/>
                                <scope line="578"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="586"/>
                </scope>
            </method>
            <javadoc line="596">
                Implements a terminal append-and-replace step.
                  &lt;p&gt; This method reads characters from the input sequence, starting at
                  the append position, and appends them to the given string buffer.  It is
                  intended to be invoked after one or more invocations of the {@link #appendReplacement appendReplacement} method in order to copy the
                  remainder of the input sequence.  &lt;/p&gt;                
                <param>
                    sbThe target string buffer                    
                </param>
                <return>
                    The target string buffer                    
                </return>
            </javadoc>
            <method name="appendTail" type="StringBuffer" line="605">
                <params>
                    <param name="sb" type="StringBuffer"/>
                </params>
            </method>
            <javadoc line="609">
                Replaces every subsequence of the input sequence that matches the
                  pattern with the given replacement string.
                  &lt;p&gt; This method first resets this matcher.  It then scans the input
                  sequence looking for matches of the pattern.  Characters that are not
                  part of any match are appended directly to the result string; each match
                  is replaced in the result by the replacement string.  The replacement
                  string may contain references to captured subsequences as in the {@link #appendReplacement appendReplacement} method.
                  &lt;p&gt; Note that backslashes (&lt;tt&gt;\&lt;/tt&gt;) and dollar signs (&lt;tt&gt;$&lt;/tt&gt;) in
                  the replacement string may cause the results to be different than if it
                  were being treated as a literal replacement string. Dollar signs may be
                  treated as references to captured subsequences as described above, and
                  backslashes are used to escape literal characters in the replacement
                  string.
                  &lt;p&gt; Given the regular expression &lt;tt&gt;ab&lt;/tt&gt;, the input
                  &lt;tt&gt;&quot;aabfooaabfooabfoob&quot;&lt;/tt&gt;, and the replacement string
                  &lt;tt&gt;&quot;-&quot;&lt;/tt&gt;, an invocation of this method on a matcher for that
                  expression would yield the string &lt;tt&gt;&quot;-foo-foo-foo-&quot;&lt;/tt&gt;.
                  &lt;p&gt; Invoking this method changes this matcher&apos;s state.  If the matcher
                  is to be used in further matching operations then it should first be
                  reset.  &lt;/p&gt;                
                <param>
                    replacementThe replacement string                    
                </param>
                <return>
                    The string constructed by replacing each matching subsequence
                      by the replacement string, substituting captured subsequences
                      as needed                    
                </return>
            </javadoc>
            <method name="replaceAll" type="String" line="635">
                <params>
                    <param name="replacement" type="String"/>
                </params>
                <declaration name="result" type="boolean" line="637"/>
                <scope line="638">
                    <declaration name="sb" type="StringBuffer" line="639"/>
                    <scope line="640"/>
                </scope>
            </method>
            <javadoc line="650">
                Replaces the first subsequence of the input sequence that matches the
                  pattern with the given replacement string.
                  &lt;p&gt; This method first resets this matcher.  It then scans the input
                  sequence looking for a match of the pattern.  Characters that are not
                  part of the match are appended directly to the result string; the match
                  is replaced in the result by the replacement string.  The replacement
                  string may contain references to captured subsequences as in the {@link #appendReplacement appendReplacement} method.
                  &lt;p&gt;Note that backslashes (&lt;tt&gt;\&lt;/tt&gt;) and dollar signs (&lt;tt&gt;$&lt;/tt&gt;) in
                  the replacement string may cause the results to be different than if it
                  were being treated as a literal replacement string. Dollar signs may be
                  treated as references to captured subsequences as described above, and
                  backslashes are used to escape literal characters in the replacement
                  string.
                  &lt;p&gt; Given the regular expression &lt;tt&gt;dog&lt;/tt&gt;, the input
                  &lt;tt&gt;&quot;zzzdogzzzdogzzz&quot;&lt;/tt&gt;, and the replacement string
                  &lt;tt&gt;&quot;cat&quot;&lt;/tt&gt;, an invocation of this method on a matcher for that
                  expression would yield the string &lt;tt&gt;&quot;zzzcatzzzdogzzz&quot;&lt;/tt&gt;.  &lt;/p&gt;
                  &lt;p&gt; Invoking this method changes this matcher&apos;s state.  If the matcher
                  is to be used in further matching operations then it should first be
                  reset.  &lt;/p&gt;                
                <param>
                    replacementThe replacement string                    
                </param>
                <return>
                    The string constructed by replacing the first matching
                      subsequence by the replacement string, substituting captured
                      subsequences as needed                    
                </return>
            </javadoc>
            <method name="replaceFirst" type="String" line="676">
                <params>
                    <param name="replacement" type="String"/>
                </params>
                <declaration name="sb" type="StringBuffer" line="680"/>
            </method>
            <javadoc line="685">
                Sets the limits of this matcher&apos;s region. The region is the part of the
                  input sequence that will be searched to find a match. Invoking this
                  method resets the matcher, and then sets the region to start at the
                  index specified by the &lt;code&gt;start&lt;/code&gt; parameter and end at the
                  index specified by the &lt;code&gt;end&lt;/code&gt; parameter.
                  &lt;p&gt;Depending on the transparency and anchoring being used (see{@link #useTransparentBounds useTransparentBounds} and{@link #useAnchoringBounds useAnchoringBounds}), certain constructs such
                  as anchors may behave differently at or around the boundaries of the
                  region.                
                <param>
                    startThe index to start searching at (inclusive)                    
                </param>
                <param>
                    endThe index to end searching at (exclusive)                    
                </param>
                <throws>
                    IndexOutOfBoundsExceptionIf start or end is less than zero, if
                      start is greater than the length of the input sequence, if
                      end is greater than the length of the input sequence, or if
                      start is greater than end.                    
                </throws>
                <return>
                    this matcher                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="region" type="Matcher" line="703">
                <params>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
            </method>
            <javadoc line="712">
                Reports the start index of this matcher&apos;s region. The
                  searches this matcher conducts are limited to finding matches
                  within {@link #regionStart regionStart} (inclusive) and{@link #regionEnd regionEnd} (exclusive).                
                <return>
                    The starting point of this matcher&apos;s region                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="regionStart" type="int" line="719"/>
            <javadoc line="722">
                Reports the end index (exclusive) of this matcher&apos;s region.
                  The searches this matcher conducts are limited to finding matches
                  within {@link #regionStart regionStart} (inclusive) and{@link #regionEnd regionEnd} (exclusive).                
                <return>
                    the ending point of this matcher&apos;s region                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="regionEnd" type="int" line="729"/>
            <javadoc line="732">
                Queries the transparency of region bounds for this matcher.
                  &lt;p&gt; This method returns &lt;tt&gt;true&lt;/tt&gt; if this matcher uses
                  &lt;i&gt;transparent&lt;/i&gt; bounds, &lt;tt&gt;false&lt;/tt&gt; if it uses &lt;i&gt;opaque&lt;/i&gt;
                  bounds.
                  &lt;p&gt; See {@link #useTransparentBounds useTransparentBounds} for a
                  description of transparent and opaque bounds.
                  &lt;p&gt; By default, a matcher uses opaque region boundaries.                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; iff this matcher is using transparent bounds,
                      &lt;tt&gt;false&lt;/tt&gt; otherwise.                    
                </return>
                <see>
                    java.util.regex.Matcher#useTransparentBounds(boolean)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hasTransparentBounds" type="boolean" line="745"/>
            <javadoc line="748">
                Sets the transparency of region bounds for this matcher.
                  &lt;p&gt; Invoking this method with an argument of &lt;tt&gt;true&lt;/tt&gt; will set this
                  matcher to use &lt;i&gt;transparent&lt;/i&gt; bounds. If the boolean
                  argument is &lt;tt&gt;false&lt;/tt&gt;, then &lt;i&gt;opaque&lt;/i&gt; bounds will be used.
                  &lt;p&gt; Using transparent bounds, the boundaries of this
                  matcher&apos;s region are transparent to lookahead, lookbehind,
                  and boundary matching constructs. Those constructs can see beyond the
                  boundaries of the region to see if a match is appropriate.
                  &lt;p&gt; Using opaque bounds, the boundaries of this matcher&apos;s
                  region are opaque to lookahead, lookbehind, and boundary matching
                  constructs that may try to see beyond them. Those constructs cannot
                  look past the boundaries so they will fail to match anything outside
                  of the region.
                  &lt;p&gt; By default, a matcher uses opaque bounds.                
                <param>
                    b a boolean indicating whether to use opaque or transparent
                      regions                    
                </param>
                <return>
                    this matcher                    
                </return>
                <see>
                    java.util.regex.Matcher#hasTransparentBounds                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="useTransparentBounds" type="Matcher" line="769">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <javadoc line="773">
                Queries the anchoring of region bounds for this matcher.
                  &lt;p&gt; This method returns &lt;tt&gt;true&lt;/tt&gt; if this matcher uses
                  &lt;i&gt;anchoring&lt;/i&gt; bounds, &lt;tt&gt;false&lt;/tt&gt; otherwise.
                  &lt;p&gt; See {@link #useAnchoringBounds useAnchoringBounds} for a
                  description of anchoring bounds.
                  &lt;p&gt; By default, a matcher uses anchoring region boundaries.                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; iff this matcher is using anchoring bounds,
                      &lt;tt&gt;false&lt;/tt&gt; otherwise.                    
                </return>
                <see>
                    java.util.regex.Matcher#useAnchoringBounds(boolean)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hasAnchoringBounds" type="boolean" line="785"/>
            <javadoc line="788">
                Sets the anchoring of region bounds for this matcher.
                  &lt;p&gt; Invoking this method with an argument of &lt;tt&gt;true&lt;/tt&gt; will set this
                  matcher to use &lt;i&gt;anchoring&lt;/i&gt; bounds. If the boolean
                  argument is &lt;tt&gt;false&lt;/tt&gt;, then &lt;i&gt;non-anchoring&lt;/i&gt; bounds will be
                  used.
                  &lt;p&gt; Using anchoring bounds, the boundaries of this
                  matcher&apos;s region match anchors such as ^ and $.
                  &lt;p&gt; Without anchoring bounds, the boundaries of this
                  matcher&apos;s region will not match anchors such as ^ and $.
                  &lt;p&gt; By default, a matcher uses anchoring region boundaries.                
                <param>
                    b a boolean indicating whether or not to use anchoring bounds.                    
                </param>
                <return>
                    this matcher                    
                </return>
                <see>
                    java.util.regex.Matcher#hasAnchoringBounds                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="useAnchoringBounds" type="Matcher" line="804">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <javadoc line="808">
                &lt;p&gt;Returns the string representation of this matcher. The
                  string representation of a &lt;code&gt;Matcher&lt;/code&gt; contains information
                  that may be useful for debugging. The exact format is unspecified.                
                <return>
                    The string representation of this matcher                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="815">
                <declaration name="sb" type="StringBuilder" line="816"/>
                <scope line="822"/>
            </method>
            <javadoc line="828">
                &lt;p&gt;Returns true if the end of input was hit by the search engine in
                  the last match operation performed by this matcher.
                  &lt;p&gt;When this method returns true, then it is possible that more input
                  would have changed the result of the last search.                
                <return>
                    true iff the end of input was hit in the last match; false
                      otherwise                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hitEnd" type="boolean" line="837"/>
            <javadoc line="840">
                &lt;p&gt;Returns true if more input could change a positive match into a
                  negative one.
                  &lt;p&gt;If this method returns true, and a match was found, then more
                  input could cause the match to be lost. If this method returns false
                  and a match was found, then more input might change the match but the
                  match won&apos;t be lost. If a match was not found, then requireEnd has no
                  meaning.                
                <return>
                    true iff more input could change a positive match into a
                      negative one.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="requireEnd" type="boolean" line="852"/>
            <javadoc line="855">
                Initiates a search to find a Pattern within the given bounds.
                  The groups are filled with default values and the match of the root
                  of the state machine is called. The state machine will hold the state
                  of the match as it proceeds in this matcher.
                  Matcher.from is not set here, because it is the &quot;hard&quot; boundary
                  of the start of the search which anchors will set to. The from param
                  is the &quot;soft&quot; boundary of the start of the search, meaning that the
                  regex tries to match at that index but ^ won&apos;t match there. Subsequent
                  calls to the search methods start at a new &quot;soft&quot; boundary which is
                  the end of the previous match.                
            </javadoc>
            <method name="search" type="boolean" line="867">
                <params>
                    <param name="from" type="int"/>
                </params>
                <declaration name="result" type="boolean" line="875"/>
            </method>
            <javadoc line="880">
                Initiates a search for an anchored match to a Pattern within the given
                  bounds. The groups are filled with default values and the match of the
                  root of the state machine is called. The state machine will hold the
                  state of the match as it proceeds in this matcher.                
            </javadoc>
            <method name="match" type="boolean" line="886">
                <params>
                    <param name="from" type="int"/>
                    <param name="anchor" type="int"/>
                </params>
                <declaration name="result" type="boolean" line="894"/>
            </method>
            <javadoc line="899">
                Returns the end index of the text.                
                <return>
                    the index after the last character in the text                    
                </return>
            </javadoc>
            <method name="getTextLength" type="int" line="903"/>
            <javadoc line="906">
                Generates a String from this Matcher&apos;s input in the specified range.                
                <param>
                    beginIndex   the beginning index, inclusive                    
                </param>
                <param>
                    endIndex     the ending index, exclusive                    
                </param>
                <return>
                    A String generated from this Matcher&apos;s input                    
                </return>
            </javadoc>
            <method name="getSubSequence" type="CharSequence" line="912">
                <params>
                    <param name="beginIndex" type="int"/>
                    <param name="endIndex" type="int"/>
                </params>
            </method>
            <javadoc line="915">
                Returns this Matcher&apos;s input character at index i.                
                <return>
                    A char from the specified index                    
                </return>
            </javadoc>
            <method name="charAt" type="char" line="919">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
        </class>
    </source>