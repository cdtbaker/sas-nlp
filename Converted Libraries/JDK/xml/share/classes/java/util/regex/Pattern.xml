<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.regex">
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.text.CharacterIterator"/>
        <import package="java.text.Normalizer"/>
        <import package="java.util.Locale"/>
        <import package="java.util.Map"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.Arrays"/>
        <class name="Pattern" line="39">
            <comment line="768">
                Regular expression modifier values.  Instead of being passed as
                 arguments, they can also be passed as inline modifiers.
                 For example, the following statements have the same effect.
                 &lt;pre&gt;
                 RegExp r1 = RegExp.compile(&quot;abc&quot;, Pattern.I|Pattern.M);
                 RegExp r2 = RegExp.compile(&quot;(?im)abc&quot;, 0);
                 &lt;pre&gt;
                
                 The flags are duplicated so that the familiar Perl match flag
                 names are available.                
            </comment>
            <comment line="915">
                Pattern has only two serialized components: The pattern string
                 and the flags, which are all that is needed to recompile the pattern
                 when it is deserialized.                
            </comment>
            <comment line="1762">
                The following private methods are mainly used to improve the
                 readability of the code. In order to let the Java compiler easily
                 inline them, we should not put many assertions or error checks in them.                
            </comment>
            <comment line="1949">
                The following methods handle the main parsing. They are sorted
                  according to their precedence order, the lowest one first.                
            </comment>
            <comment line="3204">
                Utility methods for code point support                
            </comment>
            <comment line="3333">
                The following classes are the building components of the object
                 tree that represents a compiled regular expression. The object tree
                 is made of individual elements that handle constructs in the Pattern.
                 Each type of object knows how to match its equivalent construct with
                 the match() method.                
            </comment>
            <comment line="3427">
                StartS supports supplementary characters, including unpaired surrogates.                
            </comment>
            <comment line="5441">
                /////////////////////////////////////////////////////////////////////////////
                /                
            </comment>
            <implements interface="java.io.Serializable"/>
            <javadoc line="39">
                A compiled representation of a regular expression.
                  &lt;p&gt; A regular expression, specified as a string, must first be compiled into
                  an instance of this class.  The resulting pattern can then be used to create
                  a {@link Matcher} object that can match arbitrary {@link java.lang.CharSequence &lt;/code&gt;character sequences&lt;code&gt;} against the regular
                  expression.  All of the state involved in performing a match resides in the
                  matcher, so many matchers can share the same pattern.
                  &lt;p&gt; A typical invocation sequence is thus
                  &lt;blockquote&gt;&lt;pre&gt;
                  Pattern p = Pattern.{@link #compile compile}(&quot;ab&quot;);
                  Matcher m = p.{@link #matcher matcher}(&quot;aaaaab&quot;);
                  boolean b = m.{@link Matcher#matches matches}();&lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; A {@link #matches matches} method is defined by this class as a
                  convenience for when a regular expression is used just once.  This method
                  compiles an expression and matches an input sequence against it in a single
                  invocation.  The statement
                  &lt;blockquote&gt;&lt;pre&gt;
                  boolean b = Pattern.matches(&quot;ab&quot;, &quot;aaaaab&quot;);&lt;/pre&gt;&lt;/blockquote&gt;
                  is equivalent to the three statements above, though for repeated matches it
                  is less efficient since it does not allow the compiled pattern to be reused.
                  &lt;p&gt; Instances of this class are immutable and are safe for use by multiple
                  concurrent threads.  Instances of the {@link Matcher} class are not safe for
                  such use.
                  &lt;a name=&quot;sum&quot;&gt;
                  &lt;h4&gt; Summary of regular-expression constructs &lt;/h4&gt;
                  &lt;table border=&quot;0&quot; cellpadding=&quot;1&quot; cellspacing=&quot;0&quot;
                  summary=&quot;Regular expression constructs, and what they match&quot;&gt;
                  &lt;tr align=&quot;left&quot;&gt;
                  &lt;th bgcolor=&quot;#CCCCFF&quot; align=&quot;left&quot; id=&quot;construct&quot;&gt;Construct&lt;/th&gt;
                  &lt;th bgcolor=&quot;#CCCCFF&quot; align=&quot;left&quot; id=&quot;matches&quot;&gt;Matches&lt;/th&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;characters&quot;&gt;Characters&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;i&gt;x&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The character &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\\&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The backslash character&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\0&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The character with octal value &lt;tt&gt;0&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;
                  (0&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\0&lt;/tt&gt;&lt;i&gt;nn&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The character with octal value &lt;tt&gt;0&lt;/tt&gt;&lt;i&gt;nn&lt;/i&gt;
                  (0&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\0&lt;/tt&gt;&lt;i&gt;mnn&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The character with octal value &lt;tt&gt;0&lt;/tt&gt;&lt;i&gt;mnn&lt;/i&gt;
                  (0&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;&lt;i&gt;m&lt;/i&gt;&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;3,
                  0&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\x&lt;/tt&gt;&lt;i&gt;hh&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The character with hexadecimal&amp;nbsp;value&amp;nbsp;&lt;tt&gt;0x&lt;/tt&gt;&lt;i&gt;hh&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;&amp;#92;u&lt;/tt&gt;&lt;i&gt;hhhh&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The character with hexadecimal&amp;nbsp;value&amp;nbsp;&lt;tt&gt;0x&lt;/tt&gt;&lt;i&gt;hhhh&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;&amp;#92;x&lt;/tt&gt;&lt;i&gt;{h...h}&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The character with hexadecimal&amp;nbsp;value&amp;nbsp;&lt;tt&gt;0x&lt;/tt&gt;&lt;i&gt;h...h&lt;/i&gt;
                  ({@link java.lang.Character#MIN_CODE_POINT Character.MIN_CODE_POINT}&amp;nbsp;&amp;lt;=&amp;nbsp;&lt;tt&gt;0x&lt;/tt&gt;&lt;i&gt;h...h&lt;/i&gt;&amp;nbsp;&amp;lt;=&amp;nbsp{@link java.lang.Character#MAX_CODE_POINT Character.MAX_CODE_POINT})&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;matches&quot;&gt;&lt;tt&gt;\t&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The tab character (&lt;tt&gt;&apos;&amp;#92;u0009&apos;&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\n&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The newline (line feed) character (&lt;tt&gt;&apos;&amp;#92;u000A&apos;&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\r&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The carriage-return character (&lt;tt&gt;&apos;&amp;#92;u000D&apos;&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\f&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The form-feed character (&lt;tt&gt;&apos;&amp;#92;u000C&apos;&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\a&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The alert (bell) character (&lt;tt&gt;&apos;&amp;#92;u0007&apos;&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\e&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The escape character (&lt;tt&gt;&apos;&amp;#92;u001B&apos;&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\c&lt;/tt&gt;&lt;i&gt;x&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The control character corresponding to &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;classes&quot;&gt;Character classes&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;&lt;tt&gt;[abc]&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;tt&gt;a&lt;/tt&gt;, &lt;tt&gt;b&lt;/tt&gt;, or &lt;tt&gt;c&lt;/tt&gt; (simple class)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;&lt;tt&gt;[^abc]&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Any character except &lt;tt&gt;a&lt;/tt&gt;, &lt;tt&gt;b&lt;/tt&gt;, or &lt;tt&gt;c&lt;/tt&gt; (negation)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;&lt;tt&gt;[a-zA-Z]&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;tt&gt;a&lt;/tt&gt; through &lt;tt&gt;z&lt;/tt&gt;
                  or &lt;tt&gt;A&lt;/tt&gt; through &lt;tt&gt;Z&lt;/tt&gt;, inclusive (range)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;&lt;tt&gt;[a-d[m-p]]&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;tt&gt;a&lt;/tt&gt; through &lt;tt&gt;d&lt;/tt&gt;,
                  or &lt;tt&gt;m&lt;/tt&gt; through &lt;tt&gt;p&lt;/tt&gt;: &lt;tt&gt;[a-dm-p]&lt;/tt&gt; (union)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;&lt;tt&gt;[a-z&amp;&amp;[def]]&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;e&lt;/tt&gt;, or &lt;tt&gt;f&lt;/tt&gt; (intersection)&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;&lt;tt&gt;[a-z&amp;&amp;[^bc]]&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;tt&gt;a&lt;/tt&gt; through &lt;tt&gt;z&lt;/tt&gt;,
                  except for &lt;tt&gt;b&lt;/tt&gt; and &lt;tt&gt;c&lt;/tt&gt;: &lt;tt&gt;[ad-z]&lt;/tt&gt; (subtraction)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;&lt;tt&gt;[a-z&amp;&amp;[^m-p]]&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;tt&gt;a&lt;/tt&gt; through &lt;tt&gt;z&lt;/tt&gt;,
                  and not &lt;tt&gt;m&lt;/tt&gt; through &lt;tt&gt;p&lt;/tt&gt;: &lt;tt&gt;[a-lq-z]&lt;/tt&gt;(subtraction)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;predef&quot;&gt;Predefined character classes&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;.&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Any character (may or may not match &lt;a href=&quot;#lt&quot;&gt;line terminators&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\d&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A digit: &lt;tt&gt;[0-9]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\D&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A non-digit: &lt;tt&gt;[^0-9]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\s&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A whitespace character: &lt;tt&gt;[ \t\n\x0B\f\r]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\S&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A non-whitespace character: &lt;tt&gt;[^\s]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\w&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A word character: &lt;tt&gt;[a-zA-Z_0-9]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\W&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A non-word character: &lt;tt&gt;[^\w]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;posix&quot;&gt;POSIX character classes&lt;/b&gt; (US-ASCII only)&lt;b&gt;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Lower}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A lower-case alphabetic character: &lt;tt&gt;[a-z]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Upper}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;An upper-case alphabetic character:&lt;tt&gt;[A-Z]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{ASCII}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;All ASCII:&lt;tt&gt;[\x00-\x7F]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Alpha}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;An alphabetic character:&lt;tt&gt;[\p{Lower}\p{Upper}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Digit}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A decimal digit: &lt;tt&gt;[0-9]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Alnum}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;An alphanumeric character:&lt;tt&gt;[\p{Alpha}\p{Digit}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Punct}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Punctuation: One of &lt;tt&gt;!&quot;#$%&amp;&apos;()+,-./:;&lt;=&gt;?@[\]^_`{|}~&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;!-- &lt;tt&gt;[\!&quot;#\$%&amp;&apos;\(\)\\+,\-\./:;\&lt;=\&gt;\?@\[\\\]\^_`\{\|\}~]&lt;/tt&gt;
                  &lt;tt&gt;[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]&lt;/tt&gt; --&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Graph}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A visible character: &lt;tt&gt;[\p{Alnum}\p{Punct}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Print}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A printable character: &lt;tt&gt;[\p{Graph}\x20]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Blank}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A space or a tab: &lt;tt&gt;[ \t]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Cntrl}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A control character: &lt;tt&gt;[\x00-\x1F\x7F]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{XDigit}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A hexadecimal digit: &lt;tt&gt;[0-9a-fA-F]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;&lt;tt&gt;\p{Space}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A whitespace character: &lt;tt&gt;[ \t\n\x0B\f\r]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot;&gt;java.lang.Character classes (simple &lt;a href=&quot;#jcc&quot;&gt;java character type&lt;/a&gt;)&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;\p{javaLowerCase}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;Equivalent to java.lang.Character.isLowerCase()&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;\p{javaUpperCase}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;Equivalent to java.lang.Character.isUpperCase()&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;\p{javaWhitespace}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;Equivalent to java.lang.Character.isWhitespace()&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;\p{javaMirrored}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;Equivalent to java.lang.Character.isMirrored()&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;unicode&quot;&gt;Classes for Unicode scripts, blocks, categories and binary properties&lt;/th&gt;&lt;/tr&gt;
                   &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;&lt;tt&gt;\p{IsLatin}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A Latin&amp;nbsp;script character (&lt;a href=&quot;#usc&quot;&gt;script&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;&lt;tt&gt;\p{InGreek}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A character in the Greek&amp;nbsp;block (&lt;a href=&quot;#ubc&quot;&gt;block&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;&lt;tt&gt;\p{Lu}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;An uppercase letter (&lt;a href=&quot;#ucc&quot;&gt;category&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;&lt;tt&gt;\p{IsAlphabetic}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;An alphabetic character (&lt;a href=&quot;#ubpc&quot;&gt;binary property&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;&lt;tt&gt;\p{Sc}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A currency symbol&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;&lt;tt&gt;\P{InGreek}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Any character except one in the Greek block (negation)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;&lt;tt&gt;[\p{L}&amp;&amp;[^\p{Lu}]]&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Any letter except an uppercase letter (subtraction)&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;bounds&quot;&gt;Boundary matchers&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;^&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The beginning of a line&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;$&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The end of a line&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\b&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A word boundary&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\B&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;A non-word boundary&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\A&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The beginning of the input&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\G&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The end of the previous match&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\Z&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The end of the input but for the final
                  &lt;a href=&quot;#lt&quot;&gt;terminator&lt;/a&gt;, if&amp;nbsp;any&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\z&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;The end of the input&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;greedy&quot;&gt;Greedy quantifiers&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;?&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;+&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,&lt;/tt&gt;&lt;i&gt;m&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;reluc&quot;&gt;Reluctant quantifiers&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;??&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;?&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;+?&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;}?&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,}?&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,&lt;/tt&gt;&lt;i&gt;m&lt;/i&gt;&lt;tt&gt;}?&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;poss&quot;&gt;Possessive quantifiers&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;?+&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;+&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;++&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;}+&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,}+&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,&lt;/tt&gt;&lt;i&gt;m&lt;/i&gt;&lt;tt&gt;}+&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;logical&quot;&gt;Logical operators&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct logical&quot;&gt;&lt;i&gt;XY&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt; followed by &lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct logical&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;|&lt;/tt&gt;&lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Either &lt;i&gt;X&lt;/i&gt; or &lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct logical&quot;&gt;&lt;tt&gt;(&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;X, as a &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;backref&quot;&gt;Back references&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;bottom&quot; headers=&quot;construct backref&quot;&gt;&lt;tt&gt;\&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;/td&gt;
                  &lt;td valign=&quot;bottom&quot; headers=&quot;matches&quot;&gt;Whatever the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;
                  &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; matched&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;bottom&quot; headers=&quot;construct backref&quot;&gt;&lt;tt&gt;\&lt;/tt&gt;&lt;i&gt;k&lt;/i&gt;&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/td&gt;
                  &lt;td valign=&quot;bottom&quot; headers=&quot;matches&quot;&gt;Whatever the
                  &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt; &quot;name&quot; matched&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;quot&quot;&gt;Quotation&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct quot&quot;&gt;&lt;tt&gt;\&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Nothing, but quotes the following character&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct quot&quot;&gt;&lt;tt&gt;\Q&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Nothing, but quotes all characters until &lt;tt&gt;\E&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct quot&quot;&gt;&lt;tt&gt;\E&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Nothing, but ends quoting started by &lt;tt&gt;\Q&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;!-- Metachars: !$()+.&lt;&gt;?[\]^{|} --&gt;
                  &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;special&quot;&gt;Special constructs (named-capturing and non-capturing)&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?&amp;lt;&lt;a href=&quot;#groupname&quot;&gt;name&lt;/a&gt;&amp;gt;&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a named-capturing group&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?:&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a non-capturing group&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?idmsuxU-idmsuxU)&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;Nothing, but turns match flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt;
                  &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt; &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt;
                  &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a&gt; &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt;
                  on - off&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?idmsux-idmsux:&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a &lt;a href=&quot;#cg&quot;&gt;non-capturing group&lt;/a&gt; with the
                  given flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt; &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt;
                  &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt; &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a &gt;
                  &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; on - off&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?=&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookahead&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?!&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookahead&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?&amp;lt;=&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookbehind&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?&amp;lt;!&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookbehind&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?&amp;gt;&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
                  &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as an independent, non-capturing group&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;hr&gt;
                  &lt;a name=&quot;bs&quot;&gt;
                  &lt;h4&gt; Backslashes, escapes, and quoting &lt;/h4&gt;
                  &lt;p&gt; The backslash character (&lt;tt&gt;&apos;\&apos;&lt;/tt&gt;) serves to introduce escaped
                  constructs, as defined in the table above, as well as to quote characters
                  that otherwise would be interpreted as unescaped constructs.  Thus the
                  expression &lt;tt&gt;\\&lt;/tt&gt; matches a single backslash and &lt;tt&gt;\{&lt;/tt&gt; matches a
                  left brace.
                  &lt;p&gt; It is an error to use a backslash prior to any alphabetic character that
                  does not denote an escaped construct; these are reserved for future
                  extensions to the regular-expression language.  A backslash may be used
                  prior to a non-alphabetic character regardless of whether that character is
                  part of an unescaped construct.
                  &lt;p&gt; Backslashes within string literals in Java source code are interpreted
                  as required by
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
                  as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)
                  It is therefore necessary to double backslashes in string
                  literals that represent regular expressions to protect them from
                  interpretation by the Java bytecode compiler.  The string literal
                  &lt;tt&gt;&quot;&amp;#92;b&quot;&lt;/tt&gt;, for example, matches a single backspace character when
                  interpreted as a regular expression, while &lt;tt&gt;&quot;&amp;#92;&amp;#92;b&quot;&lt;/tt&gt; matches a
                  word boundary.  The string literal &lt;tt&gt;&quot;&amp;#92;(hello&amp;#92;)&quot;&lt;/tt&gt; is illegal
                  and leads to a compile-time error; in order to match the string
                  &lt;tt&gt;(hello)&lt;/tt&gt; the string literal &lt;tt&gt;&quot;&amp;#92;&amp;#92;(hello&amp;#92;&amp;#92;)&quot;&lt;/tt&gt;
                  must be used.
                  &lt;a name=&quot;cc&quot;&gt;
                  &lt;h4&gt; Character Classes &lt;/h4&gt;
                  &lt;p&gt; Character classes may appear within other character classes, and
                  may be composed by the union operator (implicit) and the intersection
                  operator (&lt;tt&gt;&amp;amp;&amp;amp;&lt;/tt&gt;).
                  The union operator denotes a class that contains every character that is
                  in at least one of its operand classes.  The intersection operator
                  denotes a class that contains every character that is in both of its
                  operand classes.
                  &lt;p&gt; The precedence of character-class operators is as follows, from
                  highest to lowest:
                  &lt;blockquote&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;1&quot; cellspacing=&quot;0&quot;
                  summary=&quot;Precedence of character class operators.&quot;&gt;
                  &lt;tr&gt;&lt;th&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;Literal escape&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;\x&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;Grouping&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;[...]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;Range&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;a-z&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;Union&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;[a-e][i-u]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;Intersection&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;[a-z&amp;&amp;[aeiou]]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;
                  &lt;p&gt; Note that a different set of metacharacters are in effect inside
                  a character class than outside a character class. For instance, the
                  regular expression &lt;tt&gt;.&lt;/tt&gt; loses its special meaning inside a
                  character class, while the expression &lt;tt&gt;-&lt;/tt&gt; becomes a range
                  forming metacharacter.
                  &lt;a name=&quot;lt&quot;&gt;
                  &lt;h4&gt; Line terminators &lt;/h4&gt;
                  &lt;p&gt; A &lt;i&gt;line terminator&lt;/i&gt; is a one- or two-character sequence that marks
                  the end of a line of the input character sequence.  The following are
                  recognized as line terminators:
                  &lt;ul&gt;
                  &lt;li&gt; A newline (line feed) character&amp;nbsp;(&lt;tt&gt;&apos;\n&apos;&lt;/tt&gt;),
                  &lt;li&gt; A carriage-return character followed immediately by a newline
                  character&amp;nbsp;(&lt;tt&gt;&quot;\r\n&quot;&lt;/tt&gt;),
                  &lt;li&gt; A standalone carriage-return character&amp;nbsp;(&lt;tt&gt;&apos;\r&apos;&lt;/tt&gt;),
                  &lt;li&gt; A next-line character&amp;nbsp;(&lt;tt&gt;&apos;&amp;#92;u0085&apos;&lt;/tt&gt;),
                  &lt;li&gt; A line-separator character&amp;nbsp;(&lt;tt&gt;&apos;&amp;#92;u2028&apos;&lt;/tt&gt;), or
                  &lt;li&gt; A paragraph-separator character&amp;nbsp;(&lt;tt&gt;&apos;&amp;#92;u2029&lt;/tt&gt;).
                  &lt;/ul&gt;
                  &lt;p&gt;If {@link #UNIX_LINES} mode is activated, then the only line terminators
                  recognized are newline characters.
                  &lt;p&gt; The regular expression &lt;tt&gt;.&lt;/tt&gt; matches any character except a line
                  terminator unless the {@link #DOTALL} flag is specified.
                  &lt;p&gt; By default, the regular expressions &lt;tt&gt;^&lt;/tt&gt; and &lt;tt&gt;$&lt;/tt&gt; ignore
                  line terminators and only match at the beginning and the end, respectively,
                  of the entire input sequence. If {@link #MULTILINE} mode is activated then
                  &lt;tt&gt;^&lt;/tt&gt; matches at the beginning of input and after any line terminator
                  except at the end of input. When in {@link #MULTILINE} mode &lt;tt&gt;$&lt;/tt&gt;
                  matches just before a line terminator or the end of the input sequence.
                  &lt;a name=&quot;cg&quot;&gt;
                  &lt;h4&gt; Groups and capturing &lt;/h4&gt;
                  &lt;a name=&quot;gnumber&quot;&gt;
                  &lt;h5&gt; Group number &lt;/h5&gt;
                  &lt;p&gt; Capturing groups are numbered by counting their opening parentheses from
                  left to right.  In the expression &lt;tt&gt;((A)(B(C)))&lt;/tt&gt;, for example, there
                  are four such groups: &lt;/p&gt;
                  &lt;blockquote&gt;&lt;table cellpadding=1 cellspacing=0 summary=&quot;Capturing group numberings&quot;&gt;
                  &lt;tr&gt;&lt;th&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;&lt;tt&gt;((A)(B(C)))&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;&lt;tt&gt;(A)&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;&lt;tt&gt;(B(C))&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;th&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
                  &lt;td&gt;&lt;tt&gt;(C)&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;
                  &lt;p&gt; Group zero always stands for the entire expression.
                  &lt;p&gt; Capturing groups are so named because, during a match, each subsequence
                  of the input sequence that matches such a group is saved.  The captured
                  subsequence may be used later in the expression, via a back reference, and
                  may also be retrieved from the matcher once the match operation is complete.
                  &lt;a name=&quot;groupname&quot;&gt;
                  &lt;h5&gt; Group name &lt;/h5&gt;
                  &lt;p&gt;A capturing group can also be assigned a &quot;name&quot;, a &lt;tt&gt;named-capturing group&lt;/tt&gt;,
                  and then be back-referenced later by the &quot;name&quot;. Group names are composed of
                  the following characters. The first character must be a &lt;tt&gt;letter&lt;/tt&gt;.
                  &lt;ul&gt;
                  &lt;li&gt; The uppercase letters &lt;tt&gt;&apos;A&apos;&lt;/tt&gt; through &lt;tt&gt;&apos;Z&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u0041&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;&amp;#92;u005a&apos;&lt;/tt&gt;),
                  &lt;li&gt; The lowercase letters &lt;tt&gt;&apos;a&apos;&lt;/tt&gt; through &lt;tt&gt;&apos;z&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u0061&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;&amp;#92;u007a&apos;&lt;/tt&gt;),
                  &lt;li&gt; The digits &lt;tt&gt;&apos;0&apos;&lt;/tt&gt; through &lt;tt&gt;&apos;9&apos;&lt;/tt&gt;
                  (&lt;tt&gt;&apos;&amp;#92;u0030&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;&amp;#92;u0039&apos;&lt;/tt&gt;),
                  &lt;/ul&gt;
                  &lt;p&gt; A &lt;tt&gt;named-capturing group&lt;/tt&gt; is still numbered as described in
                  &lt;a href=&quot;#gnumber&quot;&gt;Group number&lt;/a&gt;.
                  &lt;p&gt; The captured input associated with a group is always the subsequence
                  that the group most recently matched.  If a group is evaluated a second time
                  because of quantification then its previously-captured value, if any, will
                  be retained if the second evaluation fails.  Matching the string
                  &lt;tt&gt;&quot;aba&quot;&lt;/tt&gt; against the expression &lt;tt&gt;(a(b)?)+&lt;/tt&gt;, for example, leaves
                  group two set to &lt;tt&gt;&quot;b&quot;&lt;/tt&gt;.  All captured input is discarded at the
                  beginning of each match.
                  &lt;p&gt; Groups beginning with &lt;tt&gt;(?&lt;/tt&gt; are either pure, &lt;i&gt;non-capturing&lt;/i&gt; groups
                  that do not capture text and do not count towards the group total, or
                  &lt;i&gt;named-capturing&lt;/i&gt; group.
                  &lt;h4&gt; Unicode support &lt;/h4&gt;
                  &lt;p&gt; This class is in conformance with Level 1 of &lt;a
                  href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
                  Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;, plus RL2.1
                  Canonical Equivalents.
                  &lt;p&gt;
                  &lt;b&gt;Unicode escape sequences&lt;/b&gt; such as &lt;tt&gt;&amp;#92;u2014&lt;/tt&gt; in Java source code
                  are processed as described in section 3.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
                  Such escape sequences are also implemented directly by the regular-expression
                  parser so that Unicode escapes can be used in expressions that are read from
                  files or from the keyboard.  Thus the strings &lt;tt&gt;&quot;&amp;#92;u2014&quot;&lt;/tt&gt; and
                  &lt;tt&gt;&quot;\\u2014&quot;&lt;/tt&gt;, while not equal, compile into the same pattern, which
                  matches the character with hexadecimal value &lt;tt&gt;0x2014&lt;/tt&gt;.
                  &lt;p&gt;
                  A Unicode character can also be represented in a regular-expression by
                  using its &lt;b&gt;Hex notation&lt;/b&gt;(hexadecimal code point value) directly as described in construct
                  &lt;tt&gt;&amp;#92;x{...}&lt;/tt&gt;, for example a supplementary character U+2011F
                  can be specified as &lt;tt&gt;&amp;#92;x{2011F}&lt;/tt&gt;, instead of two consecutive
                  Unicode escape sequences of the surrogate pair
                  &lt;tt&gt;&amp;#92;uD840&lt;/tt&gt;&lt;tt&gt;&amp;#92;uDD1F&lt;/tt&gt;.
                  &lt;p&gt;
                  Unicode scripts, blocks, categories and binary properties are written with
                  the &lt;tt&gt;\p&lt;/tt&gt; and &lt;tt&gt;\P&lt;/tt&gt; constructs as in Perl.
                  &lt;tt&gt;\p{&lt;/tt&gt;&lt;i&gt;prop&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; matches if
                  the input has the property &lt;i&gt;prop&lt;/i&gt;, while &lt;tt&gt;\P{&lt;/tt&gt;&lt;i&gt;prop&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt;
                  does not match if the input has that property.
                  &lt;p&gt;
                  Scripts, blocks, categories and binary properties can be used both inside
                  and outside of a character class.
                  &lt;a name=&quot;usc&quot;&gt;
                  &lt;p&gt;
                  &lt;b&gt;Scripts&lt;/b&gt; are specified either with the prefix {@code Is}, as in{@code IsHiragana}, or by using  the {@code script} keyword (or its short
                  form {@code sc})as in {@code script=Hiragana} or {@code sc=Hiragana}.
                  &lt;p&gt;
                  The script names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid script names
                  accepted and defined by{@link java.lang.Character.UnicodeScript#forName(String) UnicodeScript.forName}.
                  &lt;a name=&quot;ubc&quot;&gt;
                  &lt;p&gt;
                  &lt;b&gt;Blocks&lt;/b&gt; are specified with the prefix {@code In}, as in{@code InMongolian}, or by using the keyword {@code block} (or its short
                  form {@code blk}) as in {@code block=Mongolian} or {@code blk=Mongolian}.
                  &lt;p&gt;
                  The block names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid block names
                  accepted and defined by{@link java.lang.Character.UnicodeBlock#forName(String) UnicodeBlock.forName}.
                  &lt;p&gt;
                  &lt;a name=&quot;ucc&quot;&gt;
                  &lt;b&gt;Categories&lt;/b&gt; may be specified with the optional prefix {@code Is}:
                  Both {@code} \p
                  L}} and {@code} \p
                  IsL}} denote the category of Unicode
                  letters. Same as scripts and blocks, categories can also be specified
                  by using the keyword {@code general_category} (or its short form{@code gc}) as in {@code general_category=Lu} or {@code gc=Lu}.
                  &lt;p&gt;
                  The supported categories are those of
                  &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;
                  &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the{@link java.lang.Character Character} class. The category names are those
                  defined in the Standard, both normative and informative.
                  &lt;p&gt;
                  &lt;a name=&quot;ubpc&quot;&gt;
                  &lt;b&gt;Binary properties&lt;/b&gt; are specified with the prefix {@code Is}, as in{@code IsAlphabetic}. The supported binary properties by &lt;code&gt;Pattern&lt;/code&gt;
                  are
                  &lt;ul&gt;
                  &lt;li&gt; Alphabetic
                  &lt;li&gt; Ideographic
                  &lt;li&gt; Letter
                  &lt;li&gt; Lowercase
                  &lt;li&gt; Uppercase
                  &lt;li&gt; Titlecase
                  &lt;li&gt; Punctuation
                  &lt;Li&gt; Control
                  &lt;li&gt; White_Space
                  &lt;li&gt; Digit
                  &lt;li&gt; Hex_Digit
                  &lt;li&gt; Noncharacter_Code_Point
                  &lt;li&gt; Assigned
                  &lt;/ul&gt;
                  &lt;p&gt;
                  &lt;b&gt;Predefined Character classes&lt;/b&gt; and &lt;b&gt;POSIX character classes&lt;/b&gt; are in
                  conformance with the recommendation of &lt;i&gt;Annex C: Compatibility Properties&lt;/i&gt;
                  of &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Regular Expression
                  &lt;/i&gt;&lt;/a&gt;, when {@link #UNICODE_CHARACTER_CLASS} flag is specified.
                  &lt;p&gt;
                  &lt;table border=&quot;0&quot; cellpadding=&quot;1&quot; cellspacing=&quot;0&quot;
                  summary=&quot;predefined and posix character classes in Unicode mode&quot;&gt;
                  &lt;tr align=&quot;left&quot;&gt;
                  &lt;th bgcolor=&quot;#CCCCFF&quot; align=&quot;left&quot; id=&quot;classes&quot;&gt;Classes&lt;/th&gt;
                  &lt;th bgcolor=&quot;#CCCCFF&quot; align=&quot;left&quot; id=&quot;matches&quot;&gt;Matches&lt;/th&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Lower}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A lowercase character:&lt;tt&gt;\p{IsLowercase}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Upper}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;An uppercase character:&lt;tt&gt;\p{IsUppercase}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{ASCII}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;All ASCII:&lt;tt&gt;[\x00-\x7F]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Alpha}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;An alphabetic character:&lt;tt&gt;\p{IsAlphabetic}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Digit}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A decimal digit character:&lt;tt&gt;p{IsDigit}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Alnum}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;An alphanumeric character:&lt;tt&gt;[\p{IsAlphabetic}\p{IsDigit}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Punct}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A punctuation character:&lt;tt&gt;p{IsPunctuation}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Graph}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A visible character: &lt;tt&gt;[^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Print}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A printable character: &lt;tt&gt;[\p{Graph}\p{Blank}&amp;&amp;[^\p{Cntrl}]]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Blank}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A space or a tab: &lt;tt&gt;[\p{IsWhite_Space}&amp;&amp;[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Cntrl}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A control character: &lt;tt&gt;\p{gc=Cc}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{XDigit}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A hexadecimal digit: &lt;tt&gt;[\p{gc=Nd}\p{IsHex_Digit}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Space}&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A whitespace character:&lt;tt&gt;\p{IsWhite_Space}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\d&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A digit: &lt;tt&gt;\p{IsDigit}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\D&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A non-digit: &lt;tt&gt;[^\d]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\s&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A whitespace character: &lt;tt&gt;\p{IsWhite_Space}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\S&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A non-whitespace character: &lt;tt&gt;[^\s]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\w&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A word character: &lt;tt&gt;[\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\W&lt;/tt&gt;&lt;/td&gt;
                  &lt;td&gt;A non-word character: &lt;tt&gt;[^\w]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;p&gt;
                  &lt;a name=&quot;jcc&quot;&gt;
                  Categories that behave like the java.lang.Character
                  boolean is&lt;i&gt;methodname&lt;/i&gt; methods (except for the deprecated ones) are
                  available through the same &lt;tt&gt;\p{&lt;/tt&gt;&lt;i&gt;prop&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; syntax where
                  the specified property has the name &lt;tt&gt;java&lt;i&gt;methodname&lt;/i&gt;&lt;/tt&gt;.
                  &lt;h4&gt; Comparison to Perl 5 &lt;/h4&gt;
                  &lt;p&gt;The &lt;code&gt;Pattern&lt;/code&gt; engine performs traditional NFA-based matching
                  with ordered alternation as occurs in Perl 5.
                  &lt;p&gt; Perl constructs not supported by this class: &lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt; Predefined character classes (Unicode character)
                  &lt;p&gt;&lt;tt&gt;\h&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;A horizontal whitespace
                  &lt;p&gt;&lt;tt&gt;\H&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;A non horizontal whitespace
                  &lt;p&gt;&lt;tt&gt;\v&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;A vertical whitespace
                  &lt;p&gt;&lt;tt&gt;\V&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;A non vertical whitespace
                  &lt;p&gt;&lt;tt&gt;\R&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;Any Unicode linebreak sequence
                  &lt;tt&gt;\u005cu000D\u005cu000A|[\u005cu000A\u005cu000B\u005cu000C\u005cu000D\u005cu0085\u005cu2028\u005cu2029]&lt;/tt&gt;
                  &lt;p&gt;&lt;tt&gt;\X&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;Match Unicode
                  &lt;a href=&quot;http://www.unicode.org/reports/tr18/#Default_Grapheme_Clusters&quot;&gt;
                  &lt;i&gt;extended grapheme cluster&lt;/i&gt;&lt;/a&gt;
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The backreference constructs, &lt;tt&gt;\g{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; for
                  the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;&lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; and
                  &lt;tt&gt;\g{&lt;/tt&gt;&lt;i&gt;name&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; for
                  &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt;.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The named character construct, &lt;tt&gt;\N{&lt;/tt&gt;&lt;i&gt;name&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt;
                  for a Unicode character by its name.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The conditional constructs
                  &lt;tt&gt;(?(&lt;/tt&gt;&lt;i&gt;condition&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; and
                  &lt;tt&gt;(?(&lt;/tt&gt;&lt;i&gt;condition&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;|&lt;/tt&gt;&lt;i&gt;Y&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;,
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The embedded code constructs &lt;tt&gt;(?{&lt;/tt&gt;&lt;i&gt;code&lt;/i&gt;&lt;tt&gt;})&lt;/tt&gt;
                  and &lt;tt&gt;(??{&lt;/tt&gt;&lt;i&gt;code&lt;/i&gt;&lt;tt&gt;})&lt;/tt&gt;,&lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The embedded comment syntax &lt;tt&gt;(?#comment)&lt;/tt&gt;, and &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; The preprocessing operations &lt;tt&gt;\l&lt;/tt&gt; &lt;tt&gt;&amp;#92;u&lt;/tt&gt;,
                  &lt;tt&gt;\L&lt;/tt&gt;, and &lt;tt&gt;\U&lt;/tt&gt;.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt; Constructs supported by this class but not by Perl: &lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt; Character-class union and intersection as described
                  &lt;a href=&quot;#cc&quot;&gt;above&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt; Notable differences from Perl: &lt;/p&gt;
                  &lt;ul&gt;
                  &lt;li&gt;&lt;p&gt; In Perl, &lt;tt&gt;\1&lt;/tt&gt; through &lt;tt&gt;\9&lt;/tt&gt; are always interpreted
                  as back references; a backslash-escaped number greater than &lt;tt&gt;9&lt;/tt&gt; is
                  treated as a back reference if at least that many subexpressions exist,
                  otherwise it is interpreted, if possible, as an octal escape.  In this
                  class octal escapes must always begin with a zero. In this class,
                  &lt;tt&gt;\1&lt;/tt&gt; through &lt;tt&gt;\9&lt;/tt&gt; are always interpreted as back
                  references, and a larger number is accepted as a back reference if at
                  least that many subexpressions exist at that point in the regular
                  expression, otherwise the parser will drop digits until the number is
                  smaller or equal to the existing number of groups or it is one digit.
                  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; Perl uses the &lt;tt&gt;g&lt;/tt&gt; flag to request a match that resumes
                  where the last match left off.  This functionality is provided implicitly
                  by the {@link Matcher} class: Repeated invocations of the {@link Matcher#find find} method will resume where the last match left off,
                  unless the matcher is reset.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; In Perl, embedded flags at the top level of an expression affect
                  the whole expression.  In this class, embedded flags always take effect
                  at the point at which they appear, whether they are at the top level or
                  within a group; in the latter case, flags are restored at the end of the
                  group just as in Perl.  &lt;/p&gt;&lt;/li&gt;
                  &lt;/ul&gt;
                  &lt;p&gt; For a more precise description of the behavior of regular expression
                  constructs, please see &lt;a href=&quot;http://www.oreilly.com/catalog/regex3/&quot;&gt;
                  &lt;i&gt;Mastering Regular Expressions, 3nd Edition&lt;/i&gt;, Jeffrey E. F. Friedl,
                  O&apos;Reilly and Associates, 2006.&lt;/a&gt;
                  &lt;/p&gt;                
                <see>
                    java.lang.String#split(String,int)                    
                </see>
                <see>
                    java.lang.String#split(String)                    
                </see>
                <author>
                    Mike McCloskey                    
                </author>
                <author>
                    Mark Reinhold                    
                </author>
                <author>
                    JSR-51 Expert Group                    
                </author>
                <since>
                    1.4                    
                </since>
                <spec>
                    JSR-51                    
                </spec>
            </javadoc>
            <declaration name="UNIX_LINES" type="int" line="780"/>
            <javadoc line="780">
                Enables Unix lines mode.
                  &lt;p&gt; In this mode, only the &lt;tt&gt;&apos;\n&apos;&lt;/tt&gt; line terminator is recognized
                  in the behavior of &lt;tt&gt;.&lt;/tt&gt;, &lt;tt&gt;^&lt;/tt&gt;, and &lt;tt&gt;$&lt;/tt&gt;.
                  &lt;p&gt; Unix lines mode can also be enabled via the embedded flag
                  expression&amp;nbsp;&lt;tt&gt;(?d)&lt;/tt&gt;.                
            </javadoc>
            <declaration name="CASE_INSENSITIVE" type="int" line="791"/>
            <javadoc line="791">
                Enables case-insensitive matching.
                  &lt;p&gt; By default, case-insensitive matching assumes that only characters
                  in the US-ASCII charset are being matched.  Unicode-aware
                  case-insensitive matching can be enabled by specifying the {@link #UNICODE_CASE} flag in conjunction with this flag.
                  &lt;p&gt; Case-insensitive matching can also be enabled via the embedded flag
                  expression&amp;nbsp;&lt;tt&gt;(?i)&lt;/tt&gt;.
                  &lt;p&gt; Specifying this flag may impose a slight performance penalty.  &lt;/p&gt;                
            </javadoc>
            <declaration name="COMMENTS" type="int" line="806"/>
            <javadoc line="806">
                Permits whitespace and comments in pattern.
                  &lt;p&gt; In this mode, whitespace is ignored, and embedded comments starting
                  with &lt;tt&gt;#&lt;/tt&gt; are ignored until the end of a line.
                  &lt;p&gt; Comments mode can also be enabled via the embedded flag
                  expression&amp;nbsp;&lt;tt&gt;(?x)&lt;/tt&gt;.                
            </javadoc>
            <declaration name="MULTILINE" type="int" line="817"/>
            <javadoc line="817">
                Enables multiline mode.
                  &lt;p&gt; In multiline mode the expressions &lt;tt&gt;^&lt;/tt&gt; and &lt;tt&gt;$&lt;/tt&gt; match
                  just after or just before, respectively, a line terminator or the end of
                  the input sequence.  By default these expressions only match at the
                  beginning and the end of the entire input sequence.
                  &lt;p&gt; Multiline mode can also be enabled via the embedded flag
                  expression&amp;nbsp;&lt;tt&gt;(?m)&lt;/tt&gt;.  &lt;/p&gt;                
            </javadoc>
            <declaration name="LITERAL" type="int" line="830"/>
            <javadoc line="830">
                Enables literal parsing of the pattern.
                  &lt;p&gt; When this flag is specified then the input string that specifies
                  the pattern is treated as a sequence of literal characters.
                  Metacharacters or escape sequences in the input sequence will be
                  given no special meaning.
                  &lt;p&gt;The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on
                  matching when used in conjunction with this flag. The other flags
                  become superfluous.
                  &lt;p&gt; There is no embedded flag character for enabling literal parsing.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="DOTALL" type="int" line="847"/>
            <javadoc line="847">
                Enables dotall mode.
                  &lt;p&gt; In dotall mode, the expression &lt;tt&gt;.&lt;/tt&gt; matches any character,
                  including a line terminator.  By default this expression does not match
                  line terminators.
                  &lt;p&gt; Dotall mode can also be enabled via the embedded flag
                  expression&amp;nbsp;&lt;tt&gt;(?s)&lt;/tt&gt;.  (The &lt;tt&gt;s&lt;/tt&gt; is a mnemonic for
                  &quot;single-line&quot; mode, which is what this is called in Perl.)  &lt;/p&gt;                
            </javadoc>
            <declaration name="UNICODE_CASE" type="int" line="860"/>
            <javadoc line="860">
                Enables Unicode-aware case folding.
                  &lt;p&gt; When this flag is specified then case-insensitive matching, when
                  enabled by the {@link #CASE_INSENSITIVE} flag, is done in a manner
                  consistent with the Unicode Standard.  By default, case-insensitive
                  matching assumes that only characters in the US-ASCII charset are being
                  matched.
                  &lt;p&gt; Unicode-aware case folding can also be enabled via the embedded flag
                  expression&amp;nbsp;&lt;tt&gt;(?u)&lt;/tt&gt;.
                  &lt;p&gt; Specifying this flag may impose a performance penalty.  &lt;/p&gt;                
            </javadoc>
            <declaration name="CANON_EQ" type="int" line="876"/>
            <javadoc line="876">
                Enables canonical equivalence.
                  &lt;p&gt; When this flag is specified then two characters will be considered
                  to match if, and only if, their full canonical decompositions match.
                  The expression &lt;tt&gt;&quot;a&amp;#92;u030A&quot;&lt;/tt&gt;, for example, will match the
                  string &lt;tt&gt;&quot;&amp;#92;u00E5&quot;&lt;/tt&gt; when this flag is specified.  By default,
                  matching does not take canonical equivalence into account.
                  &lt;p&gt; There is no embedded flag character for enabling canonical
                  equivalence.
                  &lt;p&gt; Specifying this flag may impose a performance penalty.  &lt;/p&gt;                
            </javadoc>
            <declaration name="UNICODE_CHARACTER_CLASS" type="int" line="892"/>
            <javadoc line="892">
                Enables the Unicode version of &lt;i&gt;Predefined character classes&lt;/i&gt; and
                  &lt;i&gt;POSIX character classes&lt;/i&gt;.
                  &lt;p&gt; When this flag is specified then the (US-ASCII only)
                  &lt;i&gt;Predefined character classes&lt;/i&gt; and &lt;i&gt;POSIX character classes&lt;/i&gt;
                  are in conformance with
                  &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
                  Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;
                  &lt;i&gt;Annex C: Compatibility Properties&lt;/i&gt;.
                  &lt;p&gt;
                  The UNICODE_CHARACTER_CLASS mode can also be enabled via the embedded
                  flag expression&amp;nbsp;&lt;tt&gt;(?U)&lt;/tt&gt;.
                  &lt;p&gt;
                  The flag implies UNICODE_CASE, that is, it enables Unicode-aware case
                  folding.
                  &lt;p&gt;
                  Specifying this flag may impose a performance penalty.  &lt;/p&gt;                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="919"/>
            <javadoc line="919">
                use serialVersionUID from Merlin b59 for interoperability                
            </javadoc>
            <declaration name="pattern" type="String" line="922"/>
            <javadoc line="922">
                The original regular-expression pattern string.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="flags" type="int" line="929"/>
            <javadoc line="929">
                The original pattern flags.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="compiled" type="boolean" line="936"/>
            <javadoc line="936">
                Boolean indicating this Pattern is compiled; this is necessary in order
                  to lazily compile deserialized Patterns.                
            </javadoc>
            <declaration name="normalizedPattern" type="String" line="942"/>
            <javadoc line="942">
                The normalized pattern string.                
            </javadoc>
            <declaration name="root" type="Node" line="947"/>
            <javadoc line="947">
                The starting point of state machine for the find operation.  This allows
                  a match to start anywhere in the input.                
            </javadoc>
            <declaration name="matchRoot" type="Node" line="953"/>
            <javadoc line="953">
                The root of object tree for a match operation.  The pattern is matched
                  at the beginning.  This may include a find that uses BnM or a First
                  node.                
            </javadoc>
            <declaration name="buffer" type="int[]" line="960"/>
            <javadoc line="960">
                Temporary storage used by parsing pattern slice.                
            </javadoc>
            <declaration name="namedGroups" type="Map&lt;String,Integer&gt;" line="965"/>
            <javadoc line="965">
                Map the &quot;name&quot; of the &quot;named capturing group&quot; to its group id
                  node.                
            </javadoc>
            <declaration name="groupNodes" type="GroupHead[]" line="971"/>
            <javadoc line="971">
                Temporary storage used while parsing group references.                
            </javadoc>
            <declaration name="temp" type="int[]" line="976"/>
            <javadoc line="976">
                Temporary null terminated code point array used by pattern compiling.                
            </javadoc>
            <declaration name="capturingGroupCount" type="int" line="981"/>
            <javadoc line="981">
                The number of capturing groups in this Pattern. Used by matchers to
                  allocate storage needed to perform a match.                
            </javadoc>
            <declaration name="localCount" type="int" line="987"/>
            <javadoc line="987">
                The local variable count used by parsing tree. Used by matchers to
                  allocate storage needed to perform a match.                
            </javadoc>
            <declaration name="cursor" type="int" line="993"/>
            <javadoc line="993">
                Index into the pattern string that keeps track of how much has been
                  parsed.                
            </javadoc>
            <declaration name="patternLength" type="int" line="999"/>
            <javadoc line="999">
                Holds the length of the pattern string.                
            </javadoc>
            <declaration name="hasSupplementary" type="boolean" line="1004"/>
            <javadoc line="1004">
                If the Start node might possibly match supplementary characters.
                  It is set to true during compiling if
                  (1) There is supplementary char in pattern, or
                  (2) There is complement node of Category or Block                
            </javadoc>
            <javadoc line="1012">
                Compiles the given regular expression into a pattern.  &lt;/p&gt;                
                <param>
                    regexThe expression to be compiled                    
                </param>
                <throws>
                    PatternSyntaxExceptionIf the expression's syntax is invalid                    
                </throws>
            </javadoc>
            <method name="compile" type="Pattern" line="1021">
                <params>
                    <param name="regex" type="String"/>
                </params>
            </method>
            <javadoc line="1025">
                Compiles the given regular expression into a pattern with the given
                  flags.  &lt;/p&gt;                
                <param>
                    regexThe expression to be compiled                    
                </param>
                <param>
                    flagsMatch flags, a bit mask that may include{@link #CASE_INSENSITIVE}, {@link #MULTILINE}, {@link #DOTALL},{@link #UNICODE_CASE}, {@link #CANON_EQ}, {@link #UNIX_LINES},{@link #LITERAL}, {@link #UNICODE_CHARACTER_CLASS}and {@link #COMMENTS}                    
                </param>
                <throws>
                    IllegalArgumentExceptionIf bit values other than those corresponding to the defined
                      match flags are set in <tt>flags</tt>                    
                </throws>
                <throws>
                    PatternSyntaxExceptionIf the expression's syntax is invalid                    
                </throws>
            </javadoc>
            <method name="compile" type="Pattern" line="1046">
                <params>
                    <param name="regex" type="String"/>
                    <param name="flags" type="int"/>
                </params>
            </method>
            <javadoc line="1050">
                Returns the regular expression from which this pattern was compiled.
                  &lt;/p&gt;                
                <return>
                    The source of this pattern                    
                </return>
            </javadoc>
            <method name="pattern" type="String" line="1056"/>
            <javadoc line="1060">
                &lt;p&gt;Returns the string representation of this pattern. This
                  is the regular expression from which this pattern was
                  compiled.&lt;/p&gt;                
                <return>
                    The string representation of this pattern                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="1068"/>
            <javadoc line="1072">
                Creates a matcher that will match the given input against this pattern.
                  &lt;/p&gt;                
                <param>
                    inputThe character sequence to be matched                    
                </param>
                <return>
                    A new matcher for this pattern                    
                </return>
            </javadoc>
            <method name="matcher" type="Matcher" line="1081">
                <params>
                    <param name="input" type="CharSequence"/>
                </params>
                <scope line="1082">
                    <scope line="1083"/>
                </scope>
                <declaration name="m" type="Matcher" line="1088"/>
            </method>
            <javadoc line="1092">
                Returns this pattern&apos;s match flags.  &lt;/p&gt;                
                <return>
                    The match flags specified when this pattern was compiled                    
                </return>
            </javadoc>
            <method name="flags" type="int" line="1097"/>
            <javadoc line="1101">
                Compiles the given regular expression and attempts to match the given
                  input against it.
                  &lt;p&gt; An invocation of this convenience method of the form
                  &lt;blockquote&gt;&lt;pre&gt;
                  Pattern.matches(regex, input);&lt;/pre&gt;&lt;/blockquote&gt;
                  behaves in exactly the same way as the expression
                  &lt;blockquote&gt;&lt;pre&gt;
                  Pattern.compile(regex).matcher(input).matches()&lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; If a pattern is to be used multiple times, compiling it once and reusing
                  it will be more efficient than invoking this method each time.  &lt;/p&gt;                
                <param>
                    regexThe expression to be compiled                    
                </param>
                <param>
                    inputThe character sequence to be matched                    
                </param>
                <throws>
                    PatternSyntaxExceptionIf the expression's syntax is invalid                    
                </throws>
            </javadoc>
            <method name="matches" type="boolean" line="1127">
                <params>
                    <param name="regex" type="String"/>
                    <param name="input" type="CharSequence"/>
                </params>
                <declaration name="p" type="Pattern" line="1128"/>
                <declaration name="m" type="Matcher" line="1129"/>
            </method>
            <javadoc line="1133">
                Splits the given input sequence around matches of this pattern.
                  &lt;p&gt; The array returned by this method contains each substring of the
                  input sequence that is terminated by another subsequence that matches
                  this pattern or is terminated by the end of the input sequence.  The
                  substrings in the array are in the order in which they occur in the
                  input.  If this pattern does not match any subsequence of the input then
                  the resulting array has just one element, namely the input sequence in
                  string form.
                  &lt;p&gt; The &lt;tt&gt;limit&lt;/tt&gt; parameter controls the number of times the
                  pattern is applied and therefore affects the length of the resulting
                  array.  If the limit &lt;i&gt;n&lt;/i&gt; is greater than zero then the pattern
                  will be applied at most &lt;i&gt;n&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1 times, the array&apos;s
                  length will be no greater than &lt;i&gt;n&lt;/i&gt;, and the array&apos;s last entry
                  will contain all input beyond the last matched delimiter.  If &lt;i&gt;n&lt;/i&gt;
                  is non-positive then the pattern will be applied as many times as
                  possible and the array can have any length.  If &lt;i&gt;n&lt;/i&gt; is zero then
                  the pattern will be applied as many times as possible, the array can
                  have any length, and trailing empty strings will be discarded.
                  &lt;p&gt; The input &lt;tt&gt;&quot;boo:and:foo&quot;&lt;/tt&gt;, for example, yields the following
                  results with these parameters:
                  &lt;blockquote&gt;&lt;table cellpadding=1 cellspacing=0
                  summary=&quot;Split examples showing regex, limit, and result&quot;&gt;
                  &lt;tr&gt;&lt;th&gt;&lt;P align=&quot;left&quot;&gt;&lt;i&gt;Regex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/th&gt;
                  &lt;th&gt;&lt;P align=&quot;left&quot;&gt;&lt;i&gt;Limit&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/th&gt;
                  &lt;th&gt;&lt;P align=&quot;left&quot;&gt;&lt;i&gt;Result&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;
                  &lt;td align=center&gt;2&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;{ &quot;boo&quot;, &quot;and:foo&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;
                  &lt;td align=center&gt;5&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;
                  &lt;td align=center&gt;-2&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;
                  &lt;td align=center&gt;5&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;
                  &lt;td align=center&gt;-2&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;
                  &lt;td align=center&gt;0&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;                
                <param>
                    inputThe character sequence to be split                    
                </param>
                <param>
                    limitThe result threshold, as described above                    
                </param>
                <return>
                    The array of strings computed by splitting the input
                      around matches of this pattern                    
                </return>
            </javadoc>
            <method name="split" type="String[]" line="1193">
                <params>
                    <param name="input" type="CharSequence"/>
                    <param name="limit" type="int"/>
                </params>
                <comment line="1200">
                    Add segments before each match found                    
                </comment>
                <comment line="1206">
                    last one                    
                </comment>
                <comment line="1214">
                    If no match was found, return this                    
                </comment>
                <comment line="1218">
                    Add remaining segment                    
                </comment>
                <comment line="1222">
                    Construct result                    
                </comment>
                <declaration name="index" type="int" line="1194"/>
                <declaration name="matchLimited" type="boolean" line="1195"/>
                <declaration name="matchList" type="ArrayList&lt;String&gt;" line="1196"/>
                <declaration name="m" type="Matcher" line="1197"/>
                <scope line="1200">
                    <scope line="1201">
                        <declaration name="match" type="String" line="1202"/>
                    </scope>
                    <scope line="1205">
                        <declaration name="match" type="String" line="1206"/>
                    </scope>
                </scope>
                <declaration name="resultSize" type="int" line="1222"/>
                <declaration name="result" type="String[]" line="1226"/>
            </method>
            <javadoc line="1230">
                Splits the given input sequence around matches of this pattern.
                  &lt;p&gt; This method works as if by invoking the two-argument {@link #split(java.lang.CharSequence,int) split} method with the given input
                  sequence and a limit argument of zero.  Trailing empty strings are
                  therefore not included in the resulting array. &lt;/p&gt;
                  &lt;p&gt; The input &lt;tt&gt;&quot;boo:and:foo&quot;&lt;/tt&gt;, for example, yields the following
                  results with these expressions:
                  &lt;blockquote&gt;&lt;table cellpadding=1 cellspacing=0
                  summary=&quot;Split examples showing regex and result&quot;&gt;
                  &lt;tr&gt;&lt;th&gt;&lt;P align=&quot;left&quot;&gt;&lt;i&gt;Regex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/th&gt;
                  &lt;th&gt;&lt;P align=&quot;left&quot;&gt;&lt;i&gt;Result&lt;/i&gt;&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;
                  &lt;td&gt;&lt;tt&gt;{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
                  &lt;/table&gt;&lt;/blockquote&gt;                
                <param>
                    inputThe character sequence to be split                    
                </param>
                <return>
                    The array of strings computed by splitting the input
                      around matches of this pattern                    
                </return>
            </javadoc>
            <method name="split" type="String[]" line="1258">
                <params>
                    <param name="input" type="CharSequence"/>
                </params>
            </method>
            <javadoc line="1262">
                Returns a literal pattern &lt;code&gt;String&lt;/code&gt; for the specified
                  &lt;code&gt;String&lt;/code&gt;.
                  &lt;p&gt;This method produces a &lt;code&gt;String&lt;/code&gt; that can be used to
                  create a &lt;code&gt;Pattern&lt;/code&gt; that would match the string
                  &lt;code&gt;s&lt;/code&gt; as if it were a literal pattern.&lt;/p&gt; Metacharacters
                  or escape sequences in the input sequence will be given no special
                  meaning.                
                <param>
                    s The string to be literalized                    
                </param>
                <return>
                    A literal string replacement                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="quote" type="String" line="1276">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="slashEIndex" type="int" line="1277"/>
                <declaration name="sb" type="StringBuilder" line="1281"/>
                <declaration name="current" type="int" line="1284"/>
                <scope line="1285"/>
            </method>
            <javadoc line="1295">
                Recompile the Pattern instance from a stream.  The original pattern
                  string is read in and the object tree is recompiled from it.                
            </javadoc>
            <method name="readObject" type="void" line="1300">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="1303">
                    Read in all fields                    
                </comment>
                <comment line="1306">
                    Initialize counts                    
                </comment>
                <comment line="1310">
                    if length &gt; 0, the Pattern is lazily compiled                    
                </comment>
                <scope line="1311"/>
            </method>
            <javadoc line="1318">
                This private constructor is used to create all Patterns. The pattern
                  string and match flags are all that is needed to completely describe
                  a Pattern. An empty pattern string results in an object tree with
                  only a Start node and a LastNode node.                
            </javadoc>
            <method name="Pattern" type="constructor" line="1324">
                <params>
                    <param name="p" type="String"/>
                    <param name="f" type="int"/>
                </params>
                <comment line="1329">
                    to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present                    
                </comment>
                <comment line="1333">
                    Reset group index count                    
                </comment>
                <scope line="1336"/>
                <scope line="1338"/>
            </method>
            <javadoc line="1344">
                The pattern is converted to normalizedD form and then a pure group
                  is constructed to match canonical equivalences of the characters.                
            </javadoc>
            <method name="normalize" type="void" line="1348">
                <comment line="1353">
                    Convert pattern into normalizedD form                    
                </comment>
                <comment line="1357">
                    Modify pattern to match canonical equivalences                    
                </comment>
                <declaration name="inCharClass" type="boolean" line="1349"/>
                <declaration name="lastCodePoint" type="int" line="1350"/>
                <declaration name="newPattern" type="StringBuilder" line="1357"/>
                <scope line="1358">
                    <declaration name="c" type="int" line="1359"/>
                    <declaration name="sequenceBuffer" type="StringBuilder" line="1360"/>
                    <scope line="1362">
                        <scope line="1366"/>
                        <declaration name="ea" type="String" line="1373"/>
                    </scope>
                    <scope line="1377"/>
                    <scope line="1379"/>
                </scope>
            </method>
            <javadoc line="1388">
                Complete the character class being parsed and add a set
                  of alternations to it that will match the canonical equivalences
                  of the characters within the class.                
            </javadoc>
            <method name="normalizeCharClass" type="int" line="1393">
                <params>
                    <param name="newPattern" type="StringBuilder"/>
                    <param name="i" type="int"/>
                </params>
                <declaration name="charClass" type="StringBuilder" line="1394"/>
                <declaration name="eq" type="StringBuilder" line="1395"/>
                <declaration name="lastCodePoint" type="int" line="1396"/>
                <declaration name="result" type="String" line="1397"/>
                <scope line="1401">
                    <declaration name="c" type="int" line="1402"/>
                    <declaration name="sequenceBuffer" type="StringBuilder" line="1403"/>
                    <scope line="1405"/>
                    <scope line="1408">
                        <scope line="1411"/>
                        <declaration name="ea" type="String" line="1418"/>
                    </scope>
                    <scope line="1426"/>
                </scope>
                <scope line="1435"/>
                <scope line="1437"/>
            </method>
            <javadoc line="1445">
                Given a specific sequence composed of a regular character and
                  combining marks that follow it, produce the alternation that will
                  match all canonical equivalences of that sequence.                
            </javadoc>
            <method name="produceEquivalentAlternation" type="String" line="1450">
                <params>
                    <param name="source" type="String"/>
                </params>
                <comment line="1454">
                    source has one character.                    
                </comment>
                <comment line="1463">
                    Add combined permutations                    
                </comment>
                <declaration name="len" type="int" line="1451"/>
                <declaration name="base" type="String" line="1456"/>
                <declaration name="combiningMarks" type="String" line="1457"/>
                <declaration name="perms" type="String[]" line="1459"/>
                <declaration name="result" type="StringBuilder" line="1460"/>
                <scope line="1463">
                    <declaration name="next" type="String" line="1464"/>
                </scope>
            </method>
            <javadoc line="1474">
                Returns an array of strings that have all the possible
                  permutations of the characters in the input string.
                  This is used to get a list of all possible orderings
                  of a set of combining marks. Note that some of the permutations
                  are invalid because of combining class collisions, and these
                  possibilities must be removed because they are not canonically
                  equivalent.                
            </javadoc>
            <method name="producePermutations" type="String[]" line="1483">
                <params>
                    <param name="input" type="String"/>
                </params>
                <comment line="1517">
                    For each char, take it out and add the permutations
                     of the remaining chars                    
                </comment>
                <comment line="1521">
                    offset maintains the index in code units.                    
                </comment>
                <scope line="1487">
                    <declaration name="c0" type="int" line="1488"/>
                    <declaration name="c1" type="int" line="1489"/>
                    <scope line="1490"/>
                    <declaration name="result" type="String[]" line="1493"/>
                    <declaration name="sb" type="StringBuilder" line="1495"/>
                </scope>
                <declaration name="length" type="int" line="1502"/>
                <declaration name="nCodePoints" type="int" line="1503"/>
                <declaration name="temp" type="String[]" line="1507"/>
                <declaration name="combClass" type="int" line="1509"/>
                <scope line="1510">
                    <declaration name="c" type="int" line="1511"/>
                </scope>
                <declaration name="index" type="int" line="1518"/>
                <declaration name="len" type="int" line="1519"/>
                <scope line="1521">
                    <declaration name="skip" type="boolean" line="1523"/>
                    <scope line="1524">
                        <scope line="1525"/>
                    </scope>
                    <declaration name="sb" type="StringBuilder" line="1529"/>
                    <declaration name="otherChars" type="String" line="1530"/>
                    <declaration name="subResult" type="String[]" line="1531"/>
                    <declaration name="prefix" type="String" line="1533"/>
                </scope>
                <declaration name="result" type="String[]" line="1537"/>
            </method>
            <method name="getClass" type="int" line="1543">
                <params>
                    <param name="c" type="int"/>
                </params>
            </method>
            <javadoc line="1547">
                Attempts to compose input by combining the first character
                  with the first combining mark following it. Returns a String
                  that is the composition of the leading character with its first
                  combining mark followed by the remaining combining marks. Returns
                  null if the first two characters cannot be further composed.                
            </javadoc>
            <method name="composeOneStep" type="String" line="1554">
                <params>
                    <param name="input" type="String"/>
                </params>
                <declaration name="len" type="int" line="1555"/>
                <declaration name="firstTwoCharacters" type="String" line="1556"/>
                <declaration name="result" type="String" line="1557"/>
                <scope line="1561">
                    <declaration name="remainder" type="String" line="1562"/>
                </scope>
            </method>
            <javadoc line="1567">
                Preprocess any \Q...\E sequences in `temp&apos;, meta-quoting them.
                  See the description of `quotemeta&apos; in perlfunc(1).                
            </javadoc>
            <method name="RemoveQEQuoting" type="void" line="1571">
                <comment line="1583">
                    No \Q sequence found                    
                </comment>
                <comment line="1619">
                    double zero termination                    
                </comment>
                <declaration name="pLen" type="int" line="1572"/>
                <declaration name="i" type="int" line="1573"/>
                <scope line="1574"/>
                <declaration name="j" type="int" line="1584"/>
                <declaration name="newtemp" type="int[]" line="1586"/>
                <declaration name="inQuote" type="boolean" line="1589"/>
                <scope line="1590">
                    <declaration name="c" type="int" line="1591"/>
                    <scope line="1592"/>
                    <scope line="1594"/>
                    <scope line="1597">
                        <scope line="1598"/>
                        <scope line="1601"/>
                    </scope>
                    <scope line="1605">
                        <scope line="1606"/>
                        <scope line="1609"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1621">
                Copies regular expression to an int array and invokes the parsing
                  of the expression which will create the object tree.                
            </javadoc>
            <method name="compile" type="void" line="1625">
                <comment line="1627">
                    Handle canonical equivalences                    
                </comment>
                <comment line="1635">
                    Copy pattern to int array for convenience
                     Use double zero to terminate pattern                    
                </comment>
                <comment line="1641">
                    Convert all chars into code points                    
                </comment>
                <comment line="1650">
                    patternLength now in code points                    
                </comment>
                <comment line="1655">
                    Allocate all temporary objects here.                    
                </comment>
                <comment line="1661">
                    Literal pattern handling                    
                </comment>
                <comment line="1665">
                    Start recursive descent parsing                    
                </comment>
                <comment line="1667">
                    Check extra pattern characters                    
                </comment>
                <comment line="1677">
                    Peephole optimization                    
                </comment>
                <comment line="1689">
                    Release temporary storage                    
                </comment>
                <scope line="1627"/>
                <scope line="1629"/>
                <declaration name="c" type="int" line="1639"/>
                <scope line="1641">
                    <scope line="1643"/>
                </scope>
                <scope line="1659"/>
                <scope line="1663">
                    <scope line="1667">
                        <scope line="1668"/>
                        <scope line="1670"/>
                    </scope>
                </scope>
                <scope line="1677">
                    <scope line="1679"/>
                </scope>
                <scope line="1682"/>
                <scope line="1684"/>
            </method>
            <method name="namedGroups" type="Map<String,Integer>" line="1696"/>
            <javadoc line="1702">
                Used to print out a subtree of the Pattern to help with debugging.                
            </javadoc>
            <method name="printObjectTree" type="void" line="1705">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <scope line="1706">
                    <scope line="1707"/>
                    <scope line="1711"/>
                    <scope line="1715"/>
                    <scope line="1719"/>
                    <scope line="1723"/>
                    <scope line="1727"/>
                    <scope line="1733"/>
                </scope>
            </method>
            <class name="TreeInfo" line="1740">
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="1740">
                    Used to accumulate information about a subtree of the object graph
                      so that optimizations can be applied to the subtree.                    
                </javadoc>
                <declaration name="minLength" type="int" line="1745"/>
                <declaration name="maxLength" type="int" line="1746"/>
                <declaration name="maxValid" type="boolean" line="1747"/>
                <declaration name="deterministic" type="boolean" line="1748"/>
                <method name="TreeInfo" type="constructor" line="1750"/>
                <method name="reset" type="void" line="1753"/>
            </class>
            <javadoc line="1767">
                Indicates whether a particular flag is set or not.                
            </javadoc>
            <method name="has" type="boolean" line="1770">
                <params>
                    <param name="f" type="int"/>
                </params>
            </method>
            <javadoc line="1774">
                Match next character, signal error if failed.                
            </javadoc>
            <method name="accept" type="void" line="1777">
                <params>
                    <param name="ch" type="int"/>
                    <param name="s" type="String"/>
                </params>
                <declaration name="testChar" type="int" line="1778"/>
                <scope line="1781"/>
            </method>
            <javadoc line="1786">
                Mark the end of pattern with a specific character.                
            </javadoc>
            <method name="mark" type="void" line="1789">
                <params>
                    <param name="c" type="int"/>
                </params>
            </method>
            <javadoc line="1793">
                Peek the next character, and do not advance the cursor.                
            </javadoc>
            <method name="peek" type="int" line="1796">
                <declaration name="ch" type="int" line="1797"/>
            </method>
            <javadoc line="1803">
                Read the next character, and advance the cursor by one.                
            </javadoc>
            <method name="read" type="int" line="1806">
                <declaration name="ch" type="int" line="1807"/>
            </method>
            <javadoc line="1813">
                Read the next character, and advance the cursor by one,
                  ignoring the COMMENTS setting                
            </javadoc>
            <method name="readEscaped" type="int" line="1817">
                <declaration name="ch" type="int" line="1818"/>
            </method>
            <javadoc line="1822">
                Advance the cursor by one, and peek the next character.                
            </javadoc>
            <method name="next" type="int" line="1825">
                <declaration name="ch" type="int" line="1826"/>
            </method>
            <javadoc line="1832">
                Advance the cursor by one, and peek the next character,
                  ignoring the COMMENTS setting                
            </javadoc>
            <method name="nextEscaped" type="int" line="1836">
                <declaration name="ch" type="int" line="1837"/>
            </method>
            <javadoc line="1841">
                If in xmode peek past whitespace and comments.                
            </javadoc>
            <method name="peekPastWhitespace" type="int" line="1844">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <scope line="1845">
                    <scope line="1848"/>
                </scope>
            </method>
            <javadoc line="1855">
                If in xmode parse past whitespace and comments.                
            </javadoc>
            <method name="parsePastWhitespace" type="int" line="1858">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <scope line="1859"/>
            </method>
            <javadoc line="1868">
                xmode parse past comment to end of line.                
            </javadoc>
            <method name="parsePastLine" type="int" line="1871">
                <declaration name="ch" type="int" line="1872"/>
            </method>
            <javadoc line="1878">
                xmode peek past comment to end of line.                
            </javadoc>
            <method name="peekPastLine" type="int" line="1881">
                <declaration name="ch" type="int" line="1882"/>
            </method>
            <javadoc line="1888">
                Determines if character is a line separator in the current mode                
            </javadoc>
            <method name="isLineSeparator" type="boolean" line="1891">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <scope line="1892"/>
                <scope line="1894"/>
            </method>
            <javadoc line="1902">
                Read the character after the next one, and advance the cursor by two.                
            </javadoc>
            <method name="skip" type="int" line="1905">
                <declaration name="i" type="int" line="1906"/>
                <declaration name="ch" type="int" line="1907"/>
            </method>
            <javadoc line="1912">
                Unread one next character, and retreat cursor by one.                
            </javadoc>
            <method name="unread" type="void" line="1915"/>
            <javadoc line="1919">
                Internal method used for handling all syntax errors. The pattern is
                  displayed with a pointer to aid in locating the syntax error.                
            </javadoc>
            <method name="error" type="PatternSyntaxException" line="1923">
                <params>
                    <param name="s" type="String"/>
                </params>
            </method>
            <javadoc line="1927">
                Determines if there is any supplementary character or unpaired
                  surrogate in the specified range.                
            </javadoc>
            <method name="findSupplementary" type="boolean" line="1931">
                <params>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <scope line="1932"/>
            </method>
            <javadoc line="1939">
                Determines if the specified code point is a supplementary
                  character or unpaired surrogate.                
            </javadoc>
            <method name="isSupplementary" type="boolean" line="1943">
                <params>
                    <param name="ch" type="int"/>
                </params>
            </method>
            <javadoc line="1953">
                The expression is parsed with branch nodes added for alternations.
                  This may be called recursively to parse sub expressions that may
                  contain alternations.                
            </javadoc>
            <method name="expr" type="Node" line="1958">
                <params>
                    <param name="end" type="Node"/>
                </params>
                <comment line="1966">
                    double return                    
                </comment>
                <comment line="1971">
                    Branch                    
                </comment>
                <comment line="1977">
                    if the node returned from sequence() is &quot;end&quot;
                     we have an empty expr, set a null atom into
                     the branch to indicate to go &quot;next&quot; directly.                    
                </comment>
                <comment line="1982">
                    the &quot;tail.next&quot; of each atom goes to branchConn                    
                </comment>
                <comment line="1991">
                    replace the &quot;end&quot; with &quot;branchConn&quot; at its tail.next
                     when put the &quot;prev&quot; into the branch as the first atom.                    
                </comment>
                <declaration name="prev" type="Node" line="1959"/>
                <declaration name="firstTail" type="Node" line="1960"/>
                <declaration name="branchConn" type="Node" line="1961"/>
                <scope line="1963">
                    <declaration name="node" type="Node" line="1964"/>
                    <declaration name="nodeTail" type="Node" line="1965"/>
                    <scope line="1966"/>
                    <scope line="1969">
                        <scope line="1971"/>
                        <scope line="1975"/>
                        <scope line="1980"/>
                        <scope line="1984"/>
                        <scope line="1986">
                            <scope line="1987"/>
                            <scope line="1989"/>
                        </scope>
                    </scope>
                    <scope line="1997"/>
                </scope>
            </method>
            <javadoc line="2004">
                Parsing of sequences between alternations.                
            </javadoc>
            <method name="sequence" type="Node" line="2007">
                <params>
                    <param name="end" type="Node"/>
                </params>
                <comment line="2017">
                    Because group handles its own closure,
                     we need to treat it differently                    
                </comment>
                <comment line="2020">
                    Check for comment or flag group                    
                </comment>
                <comment line="2027">
                    Double return: Tail was returned in root                    
                </comment>
                <comment line="2038">
                    Consume { if present                    
                </comment>
                <comment line="2083">
                    Now interpreting dangling ] and } as literals                    
                </comment>
                <comment line="2096">
                    Fall through                    
                </comment>
                <comment line="2115">
                    double return                    
                </comment>
                <declaration name="head" type="Node" line="2008"/>
                <declaration name="tail" type="Node" line="2009"/>
                <declaration name="node" type="Node" line="2010"/>
                <scope line="2012">
                    <declaration name="ch" type="int" line="2013"/>
                    <scope line="2034">
                        <declaration name="oneLetter" type="boolean" line="2035"/>
                        <declaration name="comp" type="boolean" line="2036"/>
                        <scope line="2038"/>
                        <scope line="2040"/>
                    </scope>
                    <scope line="2044"/>
                    <scope line="2051"/>
                    <scope line="2056"/>
                    <scope line="2069"/>
                    <scope line="2071">
                        <scope line="2074"/>
                    </scope>
                    <scope line="2092"/>
                    <scope line="2103"/>
                    <scope line="2105"/>
                </scope>
                <scope line="2110"/>
            </method>
            <javadoc line="2118">
                Parse and add a new Single or Slice.                
            </javadoc>
            <method name="atom" type="Node" line="2121">
                <comment line="2134">
                    Unwind one character                    
                </comment>
                <comment line="2148">
                    Property                    
                </comment>
                <comment line="2149">
                    Slice is waiting; handle it first                    
                </comment>
                <comment line="2152">
                    No slice; just return the family node                    
                </comment>
                <comment line="2155">
                    Consume { if present                    
                </comment>
                <comment line="2177">
                    Unwind meta escape sequence                    
                </comment>
                <comment line="2184">
                    Fall through                    
                </comment>
                <declaration name="first" type="int" line="2122"/>
                <declaration name="prev" type="int" line="2123"/>
                <declaration name="hasSupplementary" type="boolean" line="2124"/>
                <declaration name="ch" type="int" line="2125"/>
                <scope line="2126">
                    <scope line="2132"/>
                    <scope line="2147">
                        <scope line="2148"/>
                        <scope line="2151">
                            <declaration name="comp" type="boolean" line="2152"/>
                            <declaration name="oneLetter" type="boolean" line="2153"/>
                        </scope>
                    </scope>
                    <scope line="2165">
                        <scope line="2168"/>
                    </scope>
                    <scope line="2173"/>
                    <scope line="2180"/>
                    <scope line="2188"/>
                </scope>
                <scope line="2196"/>
                <scope line="2198"/>
            </method>
            <method name="append" type="void" line="2203">
                <params>
                    <param name="ch" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="2204">
                    <declaration name="tmp" type="int[]" line="2205"/>
                </scope>
            </method>
            <javadoc line="2212">
                Parses a backref greedily, taking as many numbers as it
                  can. The first digit is always treated as a backref, but
                  multi digit numbers are only treated as a backref if at
                  least that many backrefs exist at this point in the regex.                
            </javadoc>
            <method name="ref" type="Node" line="2218">
                <params>
                    <param name="refNum" type="int"/>
                </params>
                <comment line="2235">
                    Add another number if it doesn&apos;t make a group
                     that doesn&apos;t exist                    
                </comment>
                <declaration name="done" type="boolean" line="2219"/>
                <scope line="2220">
                    <declaration name="ch" type="int" line="2221"/>
                    <declaration name="newRefNum" type="int" line="2233"/>
                    <scope line="2236"/>
                </scope>
            </method>
            <javadoc line="2254">
                Parses an escape sequence to determine the actual value that needs
                  to be matched.
                  If -1 is returned and create was true a new object was added to the tree
                  to handle the escape sequence.
                  If the returned value is greater than zero, it is the value that
                  matches the escape sequence.                
            </javadoc>
            <method name="escape" type="int" line="2262">
                <params>
                    <param name="inclass" type="boolean"/>
                    <param name="create" type="boolean"/>
                </params>
                <declaration name="ch" type="int" line="2263"/>
                <scope line="2277"/>
                <scope line="2334"/>
                <declaration name="name" type="String" line="2368"/>
                <scope line="2371"/>
            </method>
            <javadoc line="2419">
                Parse a character class, and return the node that matches it.
                  Consumes a ] on the way out if consume is true. Usually consume
                  is true except for the case of [abc&amp;&amp;def] where def is a separate
                  right hand node with &quot;understood&quot; brackets.                
            </javadoc>
            <method name="clazz" type="CharProperty" line="2426">
                <params>
                    <param name="consume" type="boolean"/>
                </params>
                <comment line="2437">
                    Negates if first char in a class, otherwise literal                    
                </comment>
                <comment line="2445">
                    ^ not first in class, treat as literal                    
                </comment>
                <comment line="2469">
                    abc&amp;&amp;def                    
                </comment>
                <comment line="2486">
                    treat as a literal &amp;                    
                </comment>
                <declaration name="prev" type="CharProperty" line="2427"/>
                <declaration name="node" type="CharProperty" line="2428"/>
                <declaration name="bits" type="BitClass" line="2429"/>
                <declaration name="include" type="boolean" line="2430"/>
                <declaration name="firstInClass" type="boolean" line="2431"/>
                <declaration name="ch" type="int" line="2432"/>
                <scope line="2433">
                    <scope line="2437"/>
                    <scope line="2443"/>
                    <scope line="2459">
                        <declaration name="rightNode" type="CharProperty" line="2461"/>
                        <scope line="2462">
                            <scope line="2463"/>
                            <scope line="2468"/>
                        </scope>
                        <scope line="2476"/>
                        <scope line="2481"/>
                    </scope>
                    <scope line="2484"/>
                    <scope line="2497"/>
                    <scope line="2508">
                        <scope line="2509"/>
                        <scope line="2511"/>
                    </scope>
                    <scope line="2515">
                        <scope line="2516"/>
                        <scope line="2518"/>
                    </scope>
                </scope>
            </method>
            <method name="bitsOrSingle" type="CharProperty" line="2527">
                <params>
                    <param name="bits" type="BitClass"/>
                    <param name="ch" type="int"/>
                </params>
                <comment line="2529">
                    Bits can only handle codepoints in [u+0000-u+00ff] range.
                    Use &quot;single&quot; node instead of bits when dealing with unicode
                    case folding for codepoints listed below.
                    (1)Uppercase out of range: u+00ff, u+00b5
                    toUpperCase(u+00ff) -&gt; u+0178
                    toUpperCase(u+00b5) -&gt; u+039c
                    (2)LatinSmallLetterLongS u+17f
                    toUpperCase(u+017f) -&gt; u+0053
                    (3)LatinSmallLetterDotlessI u+131
                    toUpperCase(u+0131) -&gt; u+0049
                    (4)LatinCapitalLetterIWithDotAbove u+0130
                    toLowerCase(u+0130) -&gt; u+0069
                    (5)KelvinSign u+212a
                    toLowerCase(u+212a) ==&gt; u+006B
                    (6)AngstromSign u+212b
                    toLowerCase(u+212b) ==&gt; u+00e5                    
                </comment>
                <comment line="2550">
                    I and i                    
                </comment>
                <comment line="2551">
                    S and s                    
                </comment>
                <comment line="2552">
                    K and k                    
                </comment>
                <comment line="2553">
                    A+ring                    
                </comment>
                <declaration name="d" type="int" line="2545"/>
            </method>
            <javadoc line="2557">
                Parse a single character or a character range in a character class
                  and return its representative node.                
            </javadoc>
            <method name="range" type="CharProperty" line="2561">
                <params>
                    <param name="bits" type="BitClass"/>
                </params>
                <comment line="2566">
                    A property                    
                </comment>
                <comment line="2569">
                    Consume { if present                    
                </comment>
                <comment line="2576">
                    ordinary escape                    
                </comment>
                <declaration name="ch" type="int" line="2562"/>
                <scope line="2563">
                    <scope line="2565">
                        <declaration name="comp" type="boolean" line="2566"/>
                        <declaration name="oneLetter" type="boolean" line="2567"/>
                    </scope>
                    <scope line="2575"/>
                </scope>
                <scope line="2581"/>
                <scope line="2584">
                    <scope line="2585">
                        <declaration name="endRange" type="int" line="2586"/>
                        <scope line="2587"/>
                        <scope line="2590">
                            <declaration name="m" type="int" line="2592"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="single" type="int" line="2606">
                <declaration name="ch" type="int" line="2607"/>
            </method>
            <javadoc line="2617">
                Parses a Unicode character family and returns its representative node.                
            </javadoc>
            <method name="family" type="CharProperty" line="2622">
                <params>
                    <param name="singleLetter" type="boolean"/>
                    <param name="maybeComplement" type="boolean"/>
                </params>
                <comment line="2652">
                    property construct \p{name=value}                    
                </comment>
                <comment line="2667">
                    \p{inBlockName}                    
                </comment>
                <comment line="2670">
                    \p{isGeneralCategory} and \p{isScriptName}                    
                </comment>
                <declaration name="name" type="String" line="2624"/>
                <declaration name="node" type="CharProperty" line="2625"/>
                <scope line="2627">
                    <declaration name="c" type="int" line="2628"/>
                    <scope line="2629"/>
                    <scope line="2631"/>
                </scope>
                <scope line="2635">
                    <declaration name="i" type="int" line="2636"/>
                    <scope line="2638"/>
                    <declaration name="j" type="int" line="2641"/>
                </scope>
                <declaration name="i" type="int" line="2649"/>
                <scope line="2650">
                    <declaration name="value" type="String" line="2652"/>
                    <scope line="2654"/>
                    <scope line="2656"/>
                    <scope line="2658"/>
                    <scope line="2660"/>
                </scope>
                <scope line="2664">
                    <scope line="2665"/>
                    <scope line="2668">
                        <declaration name="uprop" type="UnicodeProp" line="2671"/>
                    </scope>
                    <scope line="2678">
                        <scope line="2679">
                            <declaration name="uprop" type="UnicodeProp" line="2680"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2688"/>
            </method>
            <javadoc line="2697">
                Returns a CharProperty matching all characters belong to
                  a UnicodeScript.                
            </javadoc>
            <method name="unicodeScriptPropertyFor" type="CharProperty" line="2701">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="script" type="Character.UnicodeScript" line="2702"/>
                <scope line="2703"/>
                <scope line="2705"/>
            </method>
            <javadoc line="2711">
                Returns a CharProperty matching all characters in a UnicodeBlock.                
            </javadoc>
            <method name="unicodeBlockPropertyFor" type="CharProperty" line="2714">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="block" type="Character.UnicodeBlock" line="2715"/>
                <scope line="2716"/>
                <scope line="2718"/>
            </method>
            <javadoc line="2724">
                Returns a CharProperty matching all characters in a named property.                
            </javadoc>
            <method name="charPropertyNodeFor" type="CharProperty" line="2727">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="p" type="CharProperty" line="2728"/>
            </method>
            <javadoc line="2734">
                Parses and returns the name of a &quot;named capturing group&quot;, the trailing
                  &quot;&gt;&quot; is consumed after parsing.                
            </javadoc>
            <method name="groupname" type="String" line="2738">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <declaration name="sb" type="StringBuilder" line="2739"/>
                <scope line="2742"/>
            </method>
            <javadoc line="2752">
                Parses a group and returns the head node of a set of nodes that process
                  the group. Sometimes a double return system is used where the tail is
                  returned in root.                
            </javadoc>
            <method name="group0" type="Node" line="2757">
                <comment line="2768">
                    (?:xxx) pure group                    
                </comment>
                <comment line="2773">
                    (?=xxx) and (?!xxx) lookahead                    
                </comment>
                <comment line="2784">
                    (?&gt;xxx)  independent group                    
                </comment>
                <comment line="2790">
                    (?&lt;xxx)  look behind                    
                </comment>
                <comment line="2793">
                    named captured group                    
                </comment>
                <comment line="2836">
                    (?xxx:) inlined match flags                    
                </comment>
                <comment line="2841">
                    Inline modifier only                    
                </comment>
                <comment line="2851">
                    (xxx) a regular group                    
                </comment>
                <comment line="2861">
                    Check for quantifiers                    
                </comment>
                <comment line="2863">
                    No closure                    
                </comment>
                <comment line="2865">
                    Dual return                    
                </comment>
                <comment line="2867">
                    Zero length assertion                    
                </comment>
                <comment line="2869">
                    Dual return                    
                </comment>
                <comment line="2882">
                    Reluctant quantifier                    
                </comment>
                <comment line="2893">
                    Discover if the group is deterministic                    
                </comment>
                <comment line="2895">
                    Deterministic                    
                </comment>
                <comment line="2903">
                    Non-deterministic                    
                </comment>
                <comment line="2908">
                    Reluctant Curly                    
                </comment>
                <comment line="2917">
                    Dual return                    
                </comment>
                <declaration name="capturingGroup" type="boolean" line="2758"/>
                <declaration name="head" type="Node" line="2759"/>
                <declaration name="tail" type="Node" line="2760"/>
                <declaration name="save" type="int" line="2761"/>
                <declaration name="ch" type="int" line="2763"/>
                <scope line="2764">
                    <scope line="2777"/>
                    <scope line="2779"/>
                    <scope line="2791">
                        <declaration name="name" type="String" line="2793"/>
                    </scope>
                    <declaration name="start" type="int" line="2804"/>
                    <declaration name="info" type="TreeInfo" line="2809"/>
                    <scope line="2811"/>
                    <declaration name="hasSupplementary" type="boolean" line="2815"/>
                    <scope line="2816"/>
                    <scope line="2822"/>
                    <scope line="2828"/>
                    <scope line="2839"/>
                    <scope line="2842"/>
                </scope>
                <scope line="2850"/>
                <declaration name="node" type="Node" line="2861"/>
                <scope line="2862"/>
                <scope line="2866"/>
                <scope line="2871">
                    <declaration name="ques" type="Ques" line="2872"/>
                    <scope line="2873"/>
                    <scope line="2879"/>
                    <scope line="2881"/>
                </scope>
                <scope line="2886">
                    <declaration name="curly" type="Curly" line="2887"/>
                    <scope line="2888"/>
                    <declaration name="info" type="TreeInfo" line="2893"/>
                    <scope line="2894">
                        <declaration name="temp" type="GroupTail" line="2895"/>
                    </scope>
                    <scope line="2902">
                        <declaration name="temp" type="int" line="2903"/>
                        <declaration name="loop" type="Loop" line="2904"/>
                        <declaration name="prolog" type="Prolog" line="2909"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2922">
                Create group head and tail nodes using double return. If the group is
                  created with anonymous true then it is a pure group and should not
                  affect group counting.                
            </javadoc>
            <method name="createGroup" type="Node" line="2927">
                <params>
                    <param name="anonymous" type="boolean"/>
                </params>
                <declaration name="localIndex" type="int" line="2928"/>
                <declaration name="groupIndex" type="int" line="2929"/>
                <declaration name="head" type="GroupHead" line="2932"/>
            </method>
            <javadoc line="2939">
                Parses inlined match flags and set them appropriately.                
            </javadoc>
            <method name="addFlag" type="void" line="2942">
                <comment line="2971">
                    subFlag then fall through                    
                </comment>
                <declaration name="ch" type="int" line="2943"/>
                <scope line="2944"/>
            </method>
            <javadoc line="2980">
                Parses the second part of inlined match flags and turns off
                  flags appropriately.                
            </javadoc>
            <method name="subFlag" type="void" line="2984">
                <declaration name="ch" type="int" line="2985"/>
                <scope line="2986"/>
            </method>
            <declaration name="MAX_REPS" type="int" line="3018"/>
            <declaration name="GREEDY" type="int" line="3020"/>
            <declaration name="LAZY" type="int" line="3022"/>
            <declaration name="POSSESSIVE" type="int" line="3024"/>
            <declaration name="INDEPENDENT" type="int" line="3026"/>
            <javadoc line="3028">
                Processes repetition. If the next character peeked is a quantifier
                  then new nodes must be appended to handle the repetition.
                  Prev could be a single or a group, so it could be a chain of nodes.                
            </javadoc>
            <method name="closure" type="Node" line="3033">
                <params>
                    <param name="prev" type="Node"/>
                </params>
                <declaration name="atom" type="Node" line="3034"/>
                <declaration name="ch" type="int" line="3035"/>
                <scope line="3039"/>
                <scope line="3042"/>
                <scope line="3049"/>
                <scope line="3052"/>
                <scope line="3059"/>
                <scope line="3062"/>
                <scope line="3069">
                    <declaration name="cmin" type="int" line="3071"/>
                    <scope line="3072"/>
                    <declaration name="cmax" type="int" line="3075"/>
                    <scope line="3076">
                        <scope line="3079">
                            <scope line="3081"/>
                        </scope>
                    </scope>
                    <declaration name="curly" type="Curly" line="3091"/>
                    <scope line="3093"/>
                    <scope line="3096"/>
                    <scope line="3099"/>
                </scope>
                <scope line="3103"/>
            </method>
            <javadoc line="3111">
                Utility method for parsing control escape sequences.                
            </javadoc>
            <method name="c" type="int" line="3114">
                <scope line="3115"/>
            </method>
            <javadoc line="3121">
                Utility method for parsing octal escape sequences.                
            </javadoc>
            <method name="o" type="int" line="3124">
                <declaration name="n" type="int" line="3125"/>
                <scope line="3126">
                    <declaration name="m" type="int" line="3127"/>
                    <scope line="3128">
                        <declaration name="o" type="int" line="3129"/>
                        <scope line="3130"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="3142">
                Utility method for parsing hexadecimal escape sequences.                
            </javadoc>
            <method name="x" type="int" line="3145">
                <declaration name="n" type="int" line="3146"/>
                <scope line="3147">
                    <declaration name="m" type="int" line="3148"/>
                    <scope line="3149"/>
                </scope>
                <scope line="3152">
                    <declaration name="ch" type="int" line="3153"/>
                    <scope line="3154"/>
                </scope>
            </method>
            <javadoc line="3166">
                Utility method for parsing unicode escape sequences.                
            </javadoc>
            <method name="cursor" type="int" line="3169"/>
            <method name="setcursor" type="void" line="3173">
                <params>
                    <param name="pos" type="int"/>
                </params>
            </method>
            <method name="uxxxx" type="int" line="3177">
                <declaration name="n" type="int" line="3178"/>
                <scope line="3179">
                    <declaration name="ch" type="int" line="3180"/>
                    <scope line="3181"/>
                </scope>
            </method>
            <method name="u" type="int" line="3189">
                <declaration name="n" type="int" line="3190"/>
                <scope line="3191">
                    <declaration name="cur" type="int" line="3192"/>
                    <scope line="3193">
                        <declaration name="n2" type="int" line="3194"/>
                    </scope>
                </scope>
            </method>
            <method name="countChars" type="int" line="3208">
                <params>
                    <param name="seq" type="CharSequence"/>
                    <param name="index" type="int"/>
                    <param name="lengthInCodePoints" type="int"/>
                </params>
                <comment line="3210">
                    optimization                    
                </comment>
                <scope line="3210"/>
                <declaration name="length" type="int" line="3214"/>
                <declaration name="x" type="int" line="3215"/>
                <scope line="3216">
                    <scope line="3218">
                        <scope line="3219">
                            <scope line="3220"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="3229"/>
                <declaration name="len" type="int" line="3232"/>
                <scope line="3233">
                    <scope line="3234">
                        <scope line="3235"/>
                    </scope>
                </scope>
            </method>
            <method name="countCodePoints" type="int" line="3243">
                <params>
                    <param name="seq" type="CharSequence"/>
                </params>
                <declaration name="length" type="int" line="3244"/>
                <declaration name="n" type="int" line="3245"/>
                <scope line="3246">
                    <scope line="3248">
                        <scope line="3249"/>
                    </scope>
                </scope>
            </method>
            <class name="BitClass" line="3257">
                <extends class="BmpCharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3257">
                    Creates a bit vector for matching Latin-1 values. A normal BitClass
                      never matches values above Latin-1, and a complemented BitClass always
                      matches values above Latin-1.                    
                </javadoc>
                <declaration name="bits" type="boolean[]" line="3263"/>
                <method name="BitClass" type="constructor" line="3264"/>
                <method name="BitClass" type="constructor" line="3265">
                    <params>
                        <param name="bits" type="boolean[]"/>
                    </params>
                </method>
                <method name="add" type="BitClass" line="3266">
                    <params>
                        <param name="c" type="int"/>
                        <param name="flags" type="int"/>
                    </params>
                    <scope line="3268">
                        <scope line="3269"/>
                        <scope line="3272"/>
                    </scope>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3280">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <javadoc line="3285">
                Returns a suitably optimized, single character matcher.                
            </javadoc>
            <method name="newSingle" type="CharProperty" line="3288">
                <params>
                    <param name="ch" type="int"/>
                </params>
                <comment line="3305">
                    Match a given Unicode character                    
                </comment>
                <comment line="3306">
                    Match a given BMP character                    
                </comment>
                <scope line="3289">
                    <declaration name="lower" type="int" line="3290"/>
                    <scope line="3291"/>
                    <scope line="3296"/>
                </scope>
            </method>
            <javadoc line="3308">
                Utility method for creating a string slice matcher.                
            </javadoc>
            <method name="newSlice" type="Node" line="3311">
                <params>
                    <param name="buf" type="int[]"/>
                    <param name="count" type="int"/>
                    <param name="hasSupplementary" type="boolean"/>
                </params>
                <declaration name="tmp" type="int[]" line="3312"/>
                <scope line="3313">
                    <scope line="3314">
                        <scope line="3315"/>
                    </scope>
                    <scope line="3321"/>
                </scope>
                <scope line="3326"/>
            </method>
            <class name="Node" line="3340">
                <extends class="Object"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3340">
                    Base class for all node classes. Subclasses should override the match()
                      method as appropriate. This class is an accepting node, so its match()
                      always returns true.                    
                </javadoc>
                <declaration name="next" type="Node" line="3346"/>
                <method name="Node" type="constructor" line="3347"/>
                <javadoc line="3350">
                    This method implements the classic accept node.                    
                </javadoc>
                <method name="match" type="boolean" line="3353">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                </method>
                <javadoc line="3359">
                    This method is good for all zero length assertions.                    
                </javadoc>
                <method name="study" type="boolean" line="3362">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                    <scope line="3363"/>
                    <scope line="3365"/>
                </method>
            </class>
            <class name="LastNode" line="3371">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3372">
                    This method implements the classic accept node with
                      the addition of a check to see if the match occurred
                      using all of the input.                    
                </javadoc>
                <method name="match" type="boolean" line="3377">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                </method>
            </class>
            <class name="Start" line="3387">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3387">
                    Used for REs that can start anywhere within the input string.
                      This basically tries to match repeatedly at each spot in the
                      input string, moving forward after each try. An anchored search
                      or a BnM will bypass this node completely.                    
                </javadoc>
                <declaration name="minLength" type="int" line="3394"/>
                <method name="Start" type="constructor" line="3395">
                    <params>
                        <param name="node" type="Node"/>
                    </params>
                    <declaration name="info" type="TreeInfo" line="3397"/>
                </method>
                <method name="match" type="boolean" line="3401">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <scope line="3402"/>
                    <declaration name="guard" type="int" line="3406"/>
                    <scope line="3407">
                        <scope line="3408"/>
                    </scope>
                </method>
                <method name="study" type="boolean" line="3418">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="StartS" line="3429">
                <extends class="Start"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <method name="StartS" type="constructor" line="3430">
                    <params>
                        <param name="node" type="Node"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="3433">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="3441">
                        if ((ret = next.match(matcher, i, seq)) || i == guard)                        
                    </comment>
                    <comment line="3450">
                        Optimization to move to the next character. This is
                         faster than countChars(seq, i, 1).                        
                    </comment>
                    <scope line="3434"/>
                    <declaration name="guard" type="int" line="3438"/>
                    <scope line="3439">
                        <scope line="3441"/>
                        <scope line="3451">
                            <scope line="3453"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <class name="Begin" line="3463">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3463">
                    Node to anchor at the beginning of input. This object implements the
                      match for a \A sequence, and the caret anchor will use this if not in
                      multiline mode.                    
                </javadoc>
                <method name="match" type="boolean" line="3469">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="fromIndex" type="int" line="3470"/>
                    <scope line="3472"/>
                    <scope line="3477"/>
                </method>
            </class>
            <class name="End" line="3483">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3483">
                    Node to anchor at the end of input. This is the absolute end, so this
                      should not match at the last newline before the end as $ will.                    
                </javadoc>
                <method name="match" type="boolean" line="3488">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="endIndex" type="int" line="3489"/>
                    <scope line="3491"/>
                </method>
            </class>
            <class name="Caret" line="3499">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3499">
                    Node to anchor at the beginning of a line. This is essentially the
                      object to match for the multiline ^.                    
                </javadoc>
                <method name="match" type="boolean" line="3504">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="3512">
                        Perl does not match ^ at end of input even after newline                        
                    </comment>
                    <comment line="3524">
                        Should treat /r/n as one newline                        
                    </comment>
                    <declaration name="startIndex" type="int" line="3505"/>
                    <declaration name="endIndex" type="int" line="3506"/>
                    <scope line="3507"/>
                    <scope line="3512"/>
                    <scope line="3516">
                        <declaration name="ch" type="char" line="3517"/>
                        <scope line="3520"/>
                    </scope>
                </method>
            </class>
            <class name="UnixCaret" line="3531">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3531">
                    Node to anchor at the beginning of a line when in unixdot mode.                    
                </javadoc>
                <method name="match" type="boolean" line="3535">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="3543">
                        Perl does not match ^ at end of input even after newline                        
                    </comment>
                    <declaration name="startIndex" type="int" line="3536"/>
                    <declaration name="endIndex" type="int" line="3537"/>
                    <scope line="3538"/>
                    <scope line="3543"/>
                    <scope line="3547">
                        <declaration name="ch" type="char" line="3548"/>
                        <scope line="3549"/>
                    </scope>
                </method>
            </class>
            <class name="LastMatch" line="3557">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3557">
                    Node to match the location where the last match ended.
                      This is used for the \G construct.                    
                </javadoc>
                <method name="match" type="boolean" line="3562">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                </method>
            </class>
            <class name="Dollar" line="3569">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3569">
                    Node to anchor at the end of a line or the end of input based on the
                      multiline mode.
                      When not in multiline mode, the $ can only match at the very end
                      of the input, unless the input ends in a line terminator in which
                      it matches right before the last line terminator.
                      Note that \r\n is considered an atomic line terminator.
                      Like ^ the $ operator matches at a position, it does not match the
                      line terminators themselves.                    
                </javadoc>
                <declaration name="multiline" type="boolean" line="3583"/>
                <method name="Dollar" type="constructor" line="3584">
                    <params>
                        <param name="mul" type="boolean"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="3587">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="3603">
                        Matches before any line terminator; also matches at the
                         end of input
                         Before line terminator:
                         If multiline, we match here no matter what
                         If not multiline, fall through so that the end
                         is marked as hit; this must be a /r/n or a /n
                         at the very end so the end was hit; more input
                         could make this not match here                        
                    </comment>
                    <comment line="3614">
                        No match between \r\n                        
                    </comment>
                    <comment line="3623">
                        No line terminator, no match                        
                    </comment>
                    <comment line="3627">
                        Matched at current end so hit end                        
                    </comment>
                    <comment line="3629">
                        If a $ matches because of end of input, then more input
                         could cause it to fail!                        
                    </comment>
                    <declaration name="endIndex" type="int" line="3588"/>
                    <scope line="3590">
                        <scope line="3593">
                            <declaration name="ch" type="char" line="3594"/>
                        </scope>
                    </scope>
                    <scope line="3610">
                        <declaration name="ch" type="char" line="3611"/>
                        <scope line="3612"/>
                        <scope line="3619"/>
                        <scope line="3622"/>
                    </scope>
                </method>
                <method name="study" type="boolean" line="3633">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="UnixDollar" line="3639">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3639">
                    Node to anchor at the end of a line or the end of input based on the
                      multiline mode when in unix lines mode.                    
                </javadoc>
                <declaration name="multiline" type="boolean" line="3644"/>
                <method name="UnixDollar" type="constructor" line="3645">
                    <params>
                        <param name="mul" type="boolean"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="3648">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="3655">
                        If not multiline, then only possible to
                         match at very end or one before end                        
                    </comment>
                    <comment line="3659">
                        If multiline return next.match without setting
                         matcher.hitEnd                        
                    </comment>
                    <comment line="3667">
                        Matching because at the end or 1 before the end;
                         more input could change this so set hitEnd                        
                    </comment>
                    <comment line="3670">
                        If a $ matches because of end of input, then more input
                         could cause it to fail!                        
                    </comment>
                    <declaration name="endIndex" type="int" line="3649"/>
                    <scope line="3651">
                        <declaration name="ch" type="char" line="3652"/>
                        <scope line="3653"/>
                        <scope line="3662"/>
                    </scope>
                </method>
                <method name="study" type="boolean" line="3674">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="CharProperty" line="3680">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3680">
                    Abstract node class to match one character satisfying some
                      boolean property.                    
                </javadoc>
                <method name="isSatisfiedBy" type="boolean" line="3685"/>
                <method name="complement" type="CharProperty" line="3686">
                    <anonymous_class line="3687">
                        <method name="isSatisfiedBy" type="boolean" line="3688">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                </method>
                <method name="match" type="boolean" line="3691">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <scope line="3692">
                        <declaration name="ch" type="int" line="3693"/>
                    </scope>
                    <scope line="3696"/>
                </method>
                <method name="study" type="boolean" line="3701">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="BmpCharProperty" line="3708">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3708">
                    Optimized version of CharProperty that works only for
                      properties never satisfied by Supplementary characters.                    
                </javadoc>
                <method name="match" type="boolean" line="3713">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <scope line="3714"/>
                    <scope line="3717"/>
                </method>
            </class>
            <class name="SingleS" line="3724">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3724">
                    Node class that matches a Supplementary Unicode character                    
                </javadoc>
                <declaration name="c" type="int" line="3728"/>
                <method name="SingleS" type="constructor" line="3729">
                    <params>
                        <param name="c" type="int"/>
                    </params>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3730">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="Single" line="3735">
                <extends class="BmpCharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3735">
                    Optimization -- matches a given BMP character                    
                </javadoc>
                <declaration name="c" type="int" line="3739"/>
                <method name="Single" type="constructor" line="3740">
                    <params>
                        <param name="c" type="int"/>
                    </params>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3741">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="SingleI" line="3746">
                <extends class="BmpCharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3746">
                    Case insensitive matches a given BMP character                    
                </javadoc>
                <declaration name="lower" type="int" line="3750"/>
                <declaration name="upper" type="int" line="3751"/>
                <method name="SingleI" type="constructor" line="3752">
                    <params>
                        <param name="lower" type="int"/>
                        <param name="upper" type="int"/>
                    </params>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3756">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="SingleU" line="3761">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3761">
                    Unicode case insensitive matches a given Unicode character                    
                </javadoc>
                <declaration name="lower" type="int" line="3765"/>
                <method name="SingleU" type="constructor" line="3766">
                    <params>
                        <param name="lower" type="int"/>
                    </params>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3769">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="Block" line="3776">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3776">
                    Node class that matches a Unicode block.                    
                </javadoc>
                <declaration name="block" type="Character.UnicodeBlock" line="3780"/>
                <method name="Block" type="constructor" line="3781">
                    <params>
                        <param name="block" type="Character.UnicodeBlock"/>
                    </params>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3784">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="Script" line="3789">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3789">
                    Node class that matches a Unicode script                    
                </javadoc>
                <declaration name="script" type="Character.UnicodeScript" line="3793"/>
                <method name="Script" type="constructor" line="3794">
                    <params>
                        <param name="script" type="Character.UnicodeScript"/>
                    </params>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3797">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="Category" line="3802">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3802">
                    Node class that matches a Unicode category.                    
                </javadoc>
                <declaration name="typeMask" type="int" line="3806"/>
                <method name="Category" type="constructor" line="3807">
                    <params>
                        <param name="typeMask" type="int"/>
                    </params>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3808">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="Utype" line="3813">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3813">
                    Node class that matches a Unicode &quot;type&quot;                    
                </javadoc>
                <declaration name="uprop" type="UnicodeProp" line="3817"/>
                <method name="Utype" type="constructor" line="3818">
                    <params>
                        <param name="uprop" type="UnicodeProp"/>
                    </params>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3819">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="Ctype" line="3825">
                <extends class="BmpCharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3825">
                    Node class that matches a POSIX type.                    
                </javadoc>
                <declaration name="ctype" type="int" line="3829"/>
                <method name="Ctype" type="constructor" line="3830">
                    <params>
                        <param name="ctype" type="int"/>
                    </params>
                </method>
                <method name="isSatisfiedBy" type="boolean" line="3831">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="SliceNode" line="3836">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3836">
                    Base class for all Slice nodes                    
                </javadoc>
                <declaration name="buffer" type="int[]" line="3840"/>
                <method name="SliceNode" type="constructor" line="3841">
                    <params>
                        <param name="buf" type="int[]"/>
                    </params>
                </method>
                <method name="study" type="boolean" line="3844">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="Slice" line="3851">
                <extends class="SliceNode"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3851">
                    Node class for a case sensitive/BMP-only sequence of literal
                      characters.                    
                </javadoc>
                <method name="Slice" type="constructor" line="3856">
                    <params>
                        <param name="buf" type="int[]"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="3859">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="buf" type="int[]" line="3860"/>
                    <declaration name="len" type="int" line="3861"/>
                    <scope line="3862">
                        <scope line="3863"/>
                    </scope>
                </method>
            </class>
            <class name="SliceI" line="3874">
                <extends class="SliceNode"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3874">
                    Node class for a case_insensitive/BMP-only sequence of literal
                      characters.                    
                </javadoc>
                <method name="SliceI" type="constructor" line="3879">
                    <params>
                        <param name="buf" type="int[]"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="3882">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="buf" type="int[]" line="3883"/>
                    <declaration name="len" type="int" line="3884"/>
                    <scope line="3885">
                        <scope line="3886"/>
                        <declaration name="c" type="int" line="3890"/>
                    </scope>
                </method>
            </class>
            <class name="SliceU" line="3899">
                <extends class="SliceNode"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3899">
                    Node class for a unicode_case_insensitive/BMP-only sequence of
                      literal characters. Uses unicode case folding.                    
                </javadoc>
                <method name="SliceU" type="constructor" line="3904">
                    <params>
                        <param name="buf" type="int[]"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="3907">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="buf" type="int[]" line="3908"/>
                    <declaration name="len" type="int" line="3909"/>
                    <scope line="3910">
                        <scope line="3911"/>
                        <declaration name="c" type="int" line="3915"/>
                    </scope>
                </method>
            </class>
            <class name="SliceS" line="3924">
                <extends class="SliceNode"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3924">
                    Node class for a case sensitive sequence of literal characters
                      including supplementary characters.                    
                </javadoc>
                <method name="SliceS" type="constructor" line="3929">
                    <params>
                        <param name="buf" type="int[]"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="3932">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="buf" type="int[]" line="3933"/>
                    <declaration name="x" type="int" line="3934"/>
                    <scope line="3935">
                        <scope line="3936"/>
                        <declaration name="c" type="int" line="3940"/>
                        <scope line="3944"/>
                    </scope>
                </method>
            </class>
            <class name="SliceIS" line="3953">
                <extends class="SliceNode"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3953">
                    Node class for a case insensitive sequence of literal characters
                      including supplementary characters.                    
                </javadoc>
                <method name="SliceIS" type="constructor" line="3958">
                    <params>
                        <param name="buf" type="int[]"/>
                    </params>
                </method>
                <method name="toLower" type="int" line="3961">
                    <params>
                        <param name="c" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="3964">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="buf" type="int[]" line="3965"/>
                    <declaration name="x" type="int" line="3966"/>
                    <scope line="3967">
                        <scope line="3968"/>
                        <declaration name="c" type="int" line="3972"/>
                        <scope line="3976"/>
                    </scope>
                </method>
            </class>
            <class name="SliceUS" line="3985">
                <extends class="SliceIS"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="3985">
                    Node class for a case insensitive sequence of literal characters.
                      Uses unicode case folding.                    
                </javadoc>
                <method name="SliceUS" type="constructor" line="3990">
                    <params>
                        <param name="buf" type="int[]"/>
                    </params>
                </method>
                <method name="toLower" type="int" line="3993">
                    <params>
                        <param name="c" type="int"/>
                    </params>
                </method>
            </class>
            <method name="inRange" type="boolean" line="3998">
                <params>
                    <param name="lower" type="int"/>
                    <param name="ch" type="int"/>
                    <param name="upper" type="int"/>
                </params>
            </method>
            <javadoc line="4002">
                Returns node for matching characters within an explicit value range.                
            </javadoc>
            <method name="rangeFor" type="CharProperty" line="4006">
                <params>
                    <param name="lower" type="int"/>
                    <param name="upper" type="int"/>
                </params>
                <anonymous_class line="4007">
                    <method name="isSatisfiedBy" type="boolean" line="4008">
                        <params>
                            <param name="ch" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="4012">
                Returns node for matching characters within an explicit value
                  range in a case insensitive manner.                
            </javadoc>
            <method name="caseInsensitiveRangeFor" type="CharProperty" line="4017">
                <params>
                    <param name="lower" type="int"/>
                    <param name="upper" type="int"/>
                </params>
                <anonymous_class line="4019">
                    <method name="isSatisfiedBy" type="boolean" line="4020">
                        <params>
                            <param name="ch" type="int"/>
                        </params>
                        <declaration name="up" type="int" line="4023"/>
                    </method>
                </anonymous_class>
                <anonymous_class line="4026">
                    <method name="isSatisfiedBy" type="boolean" line="4027">
                        <params>
                            <param name="ch" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <class name="All" line="4035">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4035">
                    Implements the Unicode category ALL and the dot metacharacter when
                      in dotall mode.                    
                </javadoc>
                <method name="isSatisfiedBy" type="boolean" line="4040">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="Dot" line="4045">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4045">
                    Node class for the dot metacharacter when dotall is not enabled.                    
                </javadoc>
                <method name="isSatisfiedBy" type="boolean" line="4049">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="UnixDot" line="4056">
                <extends class="CharProperty"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4056">
                    Node class for the dot metacharacter when dotall is not enabled
                      but UNIX_LINES is enabled.                    
                </javadoc>
                <method name="isSatisfiedBy" type="boolean" line="4061">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
            </class>
            <class name="Ques" line="4066">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4066">
                    The 0 or 1 quantifier. This one class implements all three types.                    
                </javadoc>
                <declaration name="atom" type="Node" line="4070"/>
                <declaration name="type" type="int" line="4071"/>
                <method name="Ques" type="constructor" line="4072">
                    <params>
                        <param name="node" type="Node"/>
                        <param name="type" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4076">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                </method>
                <method name="study" type="boolean" line="4091">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                    <scope line="4092">
                        <declaration name="minL" type="int" line="4093"/>
                    </scope>
                    <scope line="4098"/>
                </method>
            </class>
            <class name="Curly" line="4105">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4105">
                    Handles the curly-brace style repetition with a specified minimum and
                      maximum occurrences. The  quantifier is handled as a special case.
                      This class handles the three types.                    
                </javadoc>
                <declaration name="atom" type="Node" line="4111"/>
                <declaration name="type" type="int" line="4112"/>
                <declaration name="cmin" type="int" line="4113"/>
                <declaration name="cmax" type="int" line="4114"/>
                <method name="Curly" type="constructor" line="4116">
                    <params>
                        <param name="node" type="Node"/>
                        <param name="cmin" type="int"/>
                        <param name="cmax" type="int"/>
                        <param name="type" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4122">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="j" type="int" line="4123"/>
                    <scope line="4124">
                        <scope line="4125"/>
                    </scope>
                </method>
                <method name="match0" type="boolean" line="4141">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="j" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4144">
                        We have matched the maximum... continue with the rest of
                         the regular expression                        
                    </comment>
                    <comment line="4150">
                        k is the length of this match                        
                    </comment>
                    <comment line="4152">
                        Zero length match                        
                    </comment>
                    <comment line="4154">
                        Move up index and number matched                        
                    </comment>
                    <comment line="4157">
                        We are greedy so match as many as we can                        
                    </comment>
                    <comment line="4169">
                        Handle backing off if match fails                        
                    </comment>
                    <scope line="4142"/>
                    <declaration name="backLimit" type="int" line="4147"/>
                    <scope line="4148">
                        <declaration name="k" type="int" line="4150"/>
                        <scope line="4157">
                            <scope line="4160"/>
                        </scope>
                        <scope line="4169"/>
                    </scope>
                </method>
                <method name="match1" type="boolean" line="4182">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="j" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4185">
                        Try finishing match without consuming any more                        
                    </comment>
                    <comment line="4188">
                        At the maximum, no match found                        
                    </comment>
                    <comment line="4191">
                        Okay, must try one more atom                        
                    </comment>
                    <comment line="4194">
                        If we haven&apos;t moved forward then must break out                        
                    </comment>
                    <comment line="4197">
                        Move up index and number matched                        
                    </comment>
                    <scope line="4183"/>
                </method>
                <method name="match2" type="boolean" line="4201">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="j" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <scope line="4202"/>
                </method>
                <method name="study" type="boolean" line="4211">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                    <comment line="4213">
                        Save original info                        
                    </comment>
                    <comment line="4224">
                        arbitrary large number                        
                    </comment>
                    <declaration name="minL" type="int" line="4213"/>
                    <declaration name="maxL" type="int" line="4214"/>
                    <declaration name="maxV" type="boolean" line="4215"/>
                    <declaration name="detm" type="boolean" line="4216"/>
                    <declaration name="temp" type="int" line="4221"/>
                    <scope line="4222"/>
                    <scope line="4227">
                        <scope line="4230"/>
                    </scope>
                    <scope line="4233"/>
                </method>
            </class>
            <class name="GroupCurly" line="4246">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4246">
                    Handles the curly-brace style repetition with a specified minimum and
                      maximum occurrences in deterministic cases. This is an iterative
                      optimization over the Prolog and Loop system which would handle this
                      in a recursive way. The  quantifier is handled as a special case.
                      If capture is true then this class saves group settings and ensures
                      that groups are unset when backing off of a group match.                    
                </javadoc>
                <declaration name="atom" type="Node" line="4255"/>
                <declaration name="type" type="int" line="4256"/>
                <declaration name="cmin" type="int" line="4257"/>
                <declaration name="cmax" type="int" line="4258"/>
                <declaration name="localIndex" type="int" line="4259"/>
                <declaration name="groupIndex" type="int" line="4260"/>
                <declaration name="capture" type="boolean" line="4261"/>
                <method name="GroupCurly" type="constructor" line="4264">
                    <params>
                        <param name="node" type="Node"/>
                        <param name="cmin" type="int"/>
                        <param name="cmax" type="int"/>
                        <param name="type" type="int"/>
                        <param name="local" type="int"/>
                        <param name="group" type="int"/>
                        <param name="capture" type="boolean"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4273">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4286">
                        Notify GroupTail there is no need to setup group info
                         because it will be set here                        
                    </comment>
                    <declaration name="groups" type="int[]" line="4274"/>
                    <declaration name="locals" type="int[]" line="4275"/>
                    <declaration name="save0" type="int" line="4276"/>
                    <declaration name="save1" type="int" line="4277"/>
                    <declaration name="save2" type="int" line="4278"/>
                    <scope line="4280"/>
                    <declaration name="ret" type="boolean" line="4289"/>
                    <scope line="4290">
                        <scope line="4291">
                            <scope line="4292"/>
                        </scope>
                        <scope line="4297"/>
                    </scope>
                    <scope line="4302">
                        <scope line="4303"/>
                        <scope line="4305"/>
                        <scope line="4307"/>
                    </scope>
                    <scope line="4311">
                        <scope line="4313"/>
                    </scope>
                </method>
                <method name="match0" type="boolean" line="4321">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="j" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4369">
                        backing off                        
                    </comment>
                    <declaration name="groups" type="int[]" line="4322"/>
                    <declaration name="save0" type="int" line="4323"/>
                    <declaration name="save1" type="int" line="4324"/>
                    <scope line="4325"/>
                    <scope line="4329">
                        <declaration name="k" type="int" line="4334"/>
                        <scope line="4335">
                            <scope line="4336"/>
                        </scope>
                        <scope line="4343">
                            <scope line="4344"/>
                            <scope line="4353"/>
                        </scope>
                        <scope line="4359">
                            <scope line="4360">
                                <scope line="4361"/>
                            </scope>
                            <scope line="4369"/>
                        </scope>
                    </scope>
                    <scope line="4378"/>
                </method>
                <method name="match1" type="boolean" line="4385">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="j" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <scope line="4386">
                        <scope line="4395"/>
                    </scope>
                </method>
                <method name="match2" type="boolean" line="4404">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="j" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <scope line="4405">
                        <scope line="4406"/>
                        <scope line="4409"/>
                        <scope line="4413"/>
                    </scope>
                </method>
                <method name="study" type="boolean" line="4420">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                    <comment line="4422">
                        Save original info                        
                    </comment>
                    <comment line="4433">
                        Arbitrary large number                        
                    </comment>
                    <declaration name="minL" type="int" line="4422"/>
                    <declaration name="maxL" type="int" line="4423"/>
                    <declaration name="maxV" type="boolean" line="4424"/>
                    <declaration name="detm" type="boolean" line="4425"/>
                    <declaration name="temp" type="int" line="4430"/>
                    <scope line="4431"/>
                    <scope line="4436">
                        <scope line="4439"/>
                    </scope>
                    <scope line="4442"/>
                    <scope line="4446"/>
                    <scope line="4448"/>
                </method>
            </class>
            <class name="BranchConn" line="4456">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4456">
                    A Guard node at the end of each atom node in a Branch. It
                      serves the purpose of chaining the &quot;match&quot; operation to
                      &quot;next&quot; but not the &quot;study&quot;, so we can collect the TreeInfo
                      of each atom node without including the TreeInfo of the
                      &quot;next&quot;.                    
                </javadoc>
                <method name="BranchConn" type="constructor" line="4464"/>
                <method name="match" type="boolean" line="4465">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                </method>
                <method name="study" type="boolean" line="4468">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="Branch" line="4473">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4473">
                    Handles the branching of alternations. Note this is also used for
                      the ? quantifier to branch between the case where it matches once
                      and where it does not occur.                    
                </javadoc>
                <declaration name="atoms" type="Node[]" line="4479"/>
                <declaration name="size" type="int" line="4480"/>
                <declaration name="conn" type="Node" line="4481"/>
                <method name="Branch" type="constructor" line="4482">
                    <params>
                        <param name="first" type="Node"/>
                        <param name="second" type="Node"/>
                        <param name="branchConn" type="Node"/>
                    </params>
                </method>
                <method name="add" type="void" line="4488">
                    <params>
                        <param name="node" type="Node"/>
                    </params>
                    <scope line="4489">
                        <declaration name="tmp" type="Node[]" line="4490"/>
                    </scope>
                </method>
                <method name="match" type="boolean" line="4497">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <scope line="4498">
                        <scope line="4499"/>
                        <scope line="4502"/>
                    </scope>
                </method>
                <method name="study" type="boolean" line="4509">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                    <comment line="4515">
                        arbitrary large enough num                        
                    </comment>
                    <declaration name="minL" type="int" line="4510"/>
                    <declaration name="maxL" type="int" line="4511"/>
                    <declaration name="maxV" type="boolean" line="4512"/>
                    <declaration name="minL2" type="int" line="4514"/>
                    <declaration name="maxL2" type="int" line="4515"/>
                    <scope line="4516"/>
                </method>
            </class>
            <class name="GroupHead" line="4539">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4539">
                    The GroupHead saves the location where the group begins in the locals
                      and restores them when the match is done.
                      The matchRef is used when a reference to this group is accessed later
                      in the expression. The locals will have a negative value in them to
                      indicate that we do not want to unset the group if the reference
                      doesn&apos;t match.                    
                </javadoc>
                <declaration name="localIndex" type="int" line="4549"/>
                <method name="GroupHead" type="constructor" line="4550">
                    <params>
                        <param name="localCount" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4553">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="save" type="int" line="4554"/>
                    <declaration name="ret" type="boolean" line="4556"/>
                </method>
                <method name="matchRef" type="boolean" line="4560">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4563">
                        HACK                        
                    </comment>
                    <declaration name="save" type="int" line="4561"/>
                    <declaration name="ret" type="boolean" line="4563"/>
                </method>
            </class>
            <class name="GroupRef" line="4569">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4569">
                    Recursive reference to a group in the regular expression. It calls
                      matchRef because if the reference fails to match we would not unset
                      the group.                    
                </javadoc>
                <declaration name="head" type="GroupHead" line="4575"/>
                <method name="GroupRef" type="constructor" line="4576">
                    <params>
                        <param name="head" type="GroupHead"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4579">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                </method>
                <method name="study" type="boolean" line="4583">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="GroupTail" line="4590">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4590">
                    The GroupTail handles the setting of group beginning and ending
                      locations when groups are successfully matched. It must also be able to
                      unset groups that have to be backed off of.
                      The GroupTail node is also used when a previous group is referenced,
                      and in that case no group information needs to be set.                    
                </javadoc>
                <declaration name="localIndex" type="int" line="4599"/>
                <declaration name="groupIndex" type="int" line="4600"/>
                <method name="GroupTail" type="constructor" line="4601">
                    <params>
                        <param name="localCount" type="int"/>
                        <param name="groupCount" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4605">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4608">
                        This is the normal group case.                        
                    </comment>
                    <comment line="4609">
                        Save the group so we can unset it if it
                         backs off of a match.                        
                    </comment>
                    <comment line="4623">
                        This is a group reference case. We don&apos;t need to save any
                         group info because it isn&apos;t really a group.                        
                    </comment>
                    <declaration name="tmp" type="int" line="4606"/>
                    <scope line="4607">
                        <declaration name="groupStart" type="int" line="4610"/>
                        <declaration name="groupEnd" type="int" line="4611"/>
                        <scope line="4615"/>
                    </scope>
                    <scope line="4621"/>
                </method>
            </class>
            <class name="Prolog" line="4630">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4630">
                    This sets up a loop to handle a recursive quantifier structure.                    
                </javadoc>
                <declaration name="loop" type="Loop" line="4634"/>
                <method name="Prolog" type="constructor" line="4635">
                    <params>
                        <param name="loop" type="Loop"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4638">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                </method>
                <method name="study" type="boolean" line="4641">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="Loop" line="4646">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4646">
                    Handles the repetition count for a greedy Curly. The matchInit
                      is called from the Prolog to save the index of where the group
                      beginning is stored. A zero length group check occurs in the
                      normal match but is skipped in the matchInit.                    
                </javadoc>
                <declaration name="body" type="Node" line="4653"/>
                <declaration name="countIndex" type="int" line="4654"/>
                <declaration name="beginIndex" type="int" line="4655"/>
                <declaration name="cmin" type="int" line="4656"/>
                <method name="Loop" type="constructor" line="4657">
                    <params>
                        <param name="countIndex" type="int"/>
                        <param name="beginIndex" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4661">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4663">
                        Avoid infinite loop in zero-length case.                        
                    </comment>
                    <comment line="4667">
                        This block is for before we reach the minimum
                         iterations required for the loop to match                        
                    </comment>
                    <comment line="4672">
                        If match failed we must backtrack, so
                         the loop count should NOT be incremented                        
                    </comment>
                    <comment line="4676">
                        Return success or failure since we are under
                         minimum                        
                    </comment>
                    <comment line="4680">
                        This block is for after we have the minimum
                         iterations required for the loop to match                        
                    </comment>
                    <comment line="4685">
                        If match failed we must backtrack, so
                         the loop count should NOT be incremented                        
                    </comment>
                    <scope line="4663">
                        <declaration name="count" type="int" line="4664"/>
                        <scope line="4668">
                            <declaration name="b" type="boolean" line="4670"/>
                        </scope>
                        <scope line="4681">
                            <declaration name="b" type="boolean" line="4683"/>
                        </scope>
                    </scope>
                </method>
                <method name="matchInit" type="boolean" line="4694">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="save" type="int" line="4695"/>
                    <declaration name="ret" type="boolean" line="4696"/>
                    <scope line="4697"/>
                    <scope line="4700"/>
                    <scope line="4705"/>
                </method>
                <method name="study" type="boolean" line="4711">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="LazyLoop" line="4718">
                <extends class="Loop"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4718">
                    Handles the repetition count for a reluctant Curly. The matchInit
                      is called from the Prolog to save the index of where the group
                      beginning is stored. A zero length group check occurs in the
                      normal match but is skipped in the matchInit.                    
                </javadoc>
                <method name="LazyLoop" type="constructor" line="4725">
                    <params>
                        <param name="countIndex" type="int"/>
                        <param name="beginIndex" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4728">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4730">
                        Check for zero length group                        
                    </comment>
                    <comment line="4736">
                        If match failed we must backtrack, so
                         the loop count should NOT be incremented                        
                    </comment>
                    <comment line="4747">
                        If match failed we must backtrack, so
                         the loop count should NOT be incremented                        
                    </comment>
                    <scope line="4730">
                        <declaration name="count" type="int" line="4731"/>
                        <scope line="4732">
                            <declaration name="result" type="boolean" line="4734"/>
                        </scope>
                        <scope line="4743">
                            <declaration name="result" type="boolean" line="4745"/>
                        </scope>
                    </scope>
                </method>
                <method name="matchInit" type="boolean" line="4756">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <declaration name="save" type="int" line="4757"/>
                    <declaration name="ret" type="boolean" line="4758"/>
                    <scope line="4759"/>
                    <scope line="4762"/>
                    <scope line="4764"/>
                </method>
                <method name="study" type="boolean" line="4771">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="BackRef" line="4778">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4778">
                    Refers to a group in the regular expression. Attempts to match
                      whatever the group referred to last matched.                    
                </javadoc>
                <declaration name="groupIndex" type="int" line="4783"/>
                <method name="BackRef" type="constructor" line="4784">
                    <params>
                        <param name="groupCount" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4788">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4795">
                        If the referenced group didn&apos;t match, neither can this                        
                    </comment>
                    <comment line="4799">
                        If there isn&apos;t enough input left no match                        
                    </comment>
                    <comment line="4805">
                        Check each new char to make sure it matches what the group
                         referenced matched last time around                        
                    </comment>
                    <declaration name="j" type="int" line="4789"/>
                    <declaration name="k" type="int" line="4790"/>
                    <declaration name="groupSize" type="int" line="4792"/>
                    <scope line="4799"/>
                </method>
                <method name="study" type="boolean" line="4812">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="CIBackRef" line="4818">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <declaration name="groupIndex" type="int" line="4819"/>
                <declaration name="doUnicodeCase" type="boolean" line="4820"/>
                <method name="CIBackRef" type="constructor" line="4821">
                    <params>
                        <param name="groupCount" type="int"/>
                        <param name="doUnicodeCase" type="boolean"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4826">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4833">
                        If the referenced group didn&apos;t match, neither can this                        
                    </comment>
                    <comment line="4837">
                        If there isn&apos;t enough input left no match                        
                    </comment>
                    <comment line="4843">
                        Check each new char to make sure it matches what the group
                         referenced matched last time around                        
                    </comment>
                    <declaration name="j" type="int" line="4827"/>
                    <declaration name="k" type="int" line="4828"/>
                    <declaration name="groupSize" type="int" line="4830"/>
                    <scope line="4837"/>
                    <declaration name="x" type="int" line="4844"/>
                    <scope line="4845">
                        <declaration name="c1" type="int" line="4846"/>
                        <declaration name="c2" type="int" line="4847"/>
                        <scope line="4848">
                            <scope line="4849">
                                <declaration name="cc1" type="int" line="4850"/>
                                <declaration name="cc2" type="int" line="4851"/>
                            </scope>
                            <scope line="4856"/>
                        </scope>
                    </scope>
                </method>
                <method name="study" type="boolean" line="4867">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="First" line="4873">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4873">
                    Searches until the next instance of its atom. This is useful for
                      finding the atom efficiently without passing an instance of it
                      (greedy problem) and without a lot of wasted search time (reluctant
                      problem).                    
                </javadoc>
                <declaration name="atom" type="Node" line="4880"/>
                <method name="First" type="constructor" line="4881">
                    <params>
                        <param name="node" type="Node"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4884">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <scope line="4885"/>
                    <scope line="4889">
                        <scope line="4890"/>
                        <scope line="4894"/>
                    </scope>
                </method>
                <method name="study" type="boolean" line="4901">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="Conditional" line="4909">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <declaration name="cond" type="Node" line="4910"/>
                <method name="Conditional" type="constructor" line="4911">
                    <params>
                        <param name="cond" type="Node"/>
                        <param name="yes" type="Node"/>
                        <param name="not" type="Node"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4916">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <scope line="4917"/>
                    <scope line="4919"/>
                </method>
                <method name="study" type="boolean" line="4923">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                    <declaration name="minL" type="int" line="4924"/>
                    <declaration name="maxL" type="int" line="4925"/>
                    <declaration name="maxV" type="boolean" line="4926"/>
                    <declaration name="minL2" type="int" line="4930"/>
                    <declaration name="maxL2" type="int" line="4931"/>
                    <declaration name="maxV2" type="boolean" line="4932"/>
                </method>
            </class>
            <class name="Pos" line="4944">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4944">
                    Zero width positive lookahead.                    
                </javadoc>
                <declaration name="cond" type="Node" line="4948"/>
                <method name="Pos" type="constructor" line="4949">
                    <params>
                        <param name="cond" type="Node"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4952">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4957">
                        Relax transparent region boundaries for lookahead                        
                    </comment>
                    <comment line="4963">
                        Reinstate region boundaries                        
                    </comment>
                    <declaration name="savedTo" type="int" line="4953"/>
                    <declaration name="conditionMatched" type="boolean" line="4954"/>
                    <scope line="4959"/>
                    <scope line="4961"/>
                </method>
            </class>
            <class name="Neg" line="4969">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="4969">
                    Zero width negative lookahead.                    
                </javadoc>
                <declaration name="cond" type="Node" line="4973"/>
                <method name="Neg" type="constructor" line="4974">
                    <params>
                        <param name="cond" type="Node"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="4977">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="4982">
                        Relax transparent region boundaries for lookahead                        
                    </comment>
                    <comment line="4989">
                        If a negative lookahead succeeds then more input
                         could cause it to fail!                        
                    </comment>
                    <comment line="4995">
                        Reinstate region boundaries                        
                    </comment>
                    <declaration name="savedTo" type="int" line="4978"/>
                    <declaration name="conditionMatched" type="boolean" line="4979"/>
                    <scope line="4984">
                        <scope line="4985"/>
                        <scope line="4987"/>
                    </scope>
                    <scope line="4993"/>
                </method>
            </class>
            <declaration name="lookbehindEnd" type="Node" line="5001"/>
            <javadoc line="5001">
                For use with lookbehinds; matches the position where the lookbehind
                  was encountered.                
            </javadoc>
            <anonymous_class line="5005">
                <method name="match" type="boolean" line="5006">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                </method>
            </anonymous_class>
            <class name="Behind" line="5011">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="5011">
                    Zero width positive lookbehind.                    
                </javadoc>
                <declaration name="cond" type="Node" line="5015"/>
                <declaration name="rmax" type="int" line="5016"/>
                <method name="Behind" type="constructor" line="5017">
                    <params>
                        <param name="cond" type="Node"/>
                        <param name="rmax" type="int"/>
                        <param name="rmin" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="5023">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="5030">
                        Set end boundary                        
                    </comment>
                    <comment line="5033">
                        Relax transparent region boundaries for lookbehind                        
                    </comment>
                    <declaration name="savedFrom" type="int" line="5024"/>
                    <declaration name="conditionMatched" type="boolean" line="5025"/>
                    <declaration name="startIndex" type="int" line="5026"/>
                    <declaration name="from" type="int" line="5028"/>
                    <declaration name="savedLBT" type="int" line="5030"/>
                    <scope line="5035"/>
                </method>
            </class>
            <class name="BehindS" line="5044">
                <extends class="Behind"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="5044">
                    Zero width positive lookbehind, including supplementary
                      characters or unpaired surrogates.                    
                </javadoc>
                <method name="BehindS" type="constructor" line="5049">
                    <params>
                        <param name="cond" type="Node"/>
                        <param name="rmax" type="int"/>
                        <param name="rmin" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="5052">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="5061">
                        Set end boundary                        
                    </comment>
                    <comment line="5064">
                        Relax transparent region boundaries for lookbehind                        
                    </comment>
                    <declaration name="rmaxChars" type="int" line="5053"/>
                    <declaration name="rminChars" type="int" line="5054"/>
                    <declaration name="savedFrom" type="int" line="5055"/>
                    <declaration name="startIndex" type="int" line="5056"/>
                    <declaration name="conditionMatched" type="boolean" line="5058"/>
                    <declaration name="from" type="int" line="5059"/>
                    <declaration name="savedLBT" type="int" line="5061"/>
                    <scope line="5069"/>
                </method>
            </class>
            <class name="NotBehind" line="5078">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="5078">
                    Zero width negative lookbehind.                    
                </javadoc>
                <declaration name="cond" type="Node" line="5082"/>
                <declaration name="rmax" type="int" line="5083"/>
                <method name="NotBehind" type="constructor" line="5084">
                    <params>
                        <param name="cond" type="Node"/>
                        <param name="rmax" type="int"/>
                        <param name="rmin" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="5090">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="5099">
                        Relax transparent region boundaries for lookbehind                        
                    </comment>
                    <comment line="5105">
                        Reinstate region boundaries                        
                    </comment>
                    <declaration name="savedLBT" type="int" line="5091"/>
                    <declaration name="savedFrom" type="int" line="5092"/>
                    <declaration name="conditionMatched" type="boolean" line="5093"/>
                    <declaration name="startIndex" type="int" line="5094"/>
                    <declaration name="from" type="int" line="5096"/>
                    <scope line="5101"/>
                </method>
            </class>
            <class name="NotBehindS" line="5111">
                <extends class="NotBehind"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="5111">
                    Zero width negative lookbehind, including supplementary
                      characters or unpaired surrogates.                    
                </javadoc>
                <method name="NotBehindS" type="constructor" line="5116">
                    <params>
                        <param name="cond" type="Node"/>
                        <param name="rmax" type="int"/>
                        <param name="rmin" type="int"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="5119">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="5130">
                        Relax transparent region boundaries for lookbehind                        
                    </comment>
                    <comment line="5138">
                        Reinstate region boundaries                        
                    </comment>
                    <declaration name="rmaxChars" type="int" line="5120"/>
                    <declaration name="rminChars" type="int" line="5121"/>
                    <declaration name="savedFrom" type="int" line="5122"/>
                    <declaration name="savedLBT" type="int" line="5123"/>
                    <declaration name="conditionMatched" type="boolean" line="5124"/>
                    <declaration name="startIndex" type="int" line="5125"/>
                    <declaration name="from" type="int" line="5127"/>
                    <scope line="5134"/>
                </method>
            </class>
            <javadoc line="5144">
                Returns the set union of two CharProperty nodes.                
            </javadoc>
            <method name="union" type="CharProperty" line="5148">
                <params>
                    <param name="lhs" type="CharProperty"/>
                    <param name="rhs" type="CharProperty"/>
                </params>
                <anonymous_class line="5149">
                    <method name="isSatisfiedBy" type="boolean" line="5150">
                        <params>
                            <param name="ch" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="5154">
                Returns the set intersection of two CharProperty nodes.                
            </javadoc>
            <method name="intersection" type="CharProperty" line="5158">
                <params>
                    <param name="lhs" type="CharProperty"/>
                    <param name="rhs" type="CharProperty"/>
                </params>
                <anonymous_class line="5159">
                    <method name="isSatisfiedBy" type="boolean" line="5160">
                        <params>
                            <param name="ch" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <javadoc line="5164">
                Returns the set difference of two CharProperty nodes.                
            </javadoc>
            <method name="setDifference" type="CharProperty" line="5168">
                <params>
                    <param name="lhs" type="CharProperty"/>
                    <param name="rhs" type="CharProperty"/>
                </params>
                <anonymous_class line="5169">
                    <method name="isSatisfiedBy" type="boolean" line="5170">
                        <params>
                            <param name="ch" type="int"/>
                        </params>
                    </method>
                </anonymous_class>
            </method>
            <class name="Bound" line="5174">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="5174">
                    Handles word boundaries. Includes a field to allow this one class to
                      deal with the different types of word boundaries we can match. The word
                      characters include underscores, letters, and digits. Non spacing marks
                      can are also part of a word if they have a base character, otherwise
                      they are ignored for purposes of finding word boundaries.                    
                </javadoc>
                <declaration name="LEFT" type="int" line="5182"/>
                <declaration name="RIGHT" type="int" line="5183"/>
                <declaration name="BOTH" type="int" line="5184"/>
                <declaration name="NONE" type="int" line="5185"/>
                <declaration name="type" type="int" line="5186"/>
                <declaration name="useUWORD" type="boolean" line="5187"/>
                <method name="Bound" type="constructor" line="5188">
                    <params>
                        <param name="n" type="int"/>
                        <param name="useUWORD" type="boolean"/>
                    </params>
                </method>
                <method name="isWord" type="boolean" line="5193">
                    <params>
                        <param name="ch" type="int"/>
                    </params>
                </method>
                <method name="check" type="int" line="5198">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="5221">
                        Tried to access char past the end                        
                    </comment>
                    <comment line="5223">
                        The addition of another char could wreck a boundary                        
                    </comment>
                    <declaration name="ch" type="int" line="5199"/>
                    <declaration name="left" type="boolean" line="5200"/>
                    <declaration name="startIndex" type="int" line="5201"/>
                    <declaration name="endIndex" type="int" line="5202"/>
                    <scope line="5203"/>
                    <scope line="5207"/>
                    <declaration name="right" type="boolean" line="5213"/>
                    <scope line="5214"/>
                    <scope line="5219"/>
                </method>
                <method name="match" type="boolean" line="5227">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                </method>
            </class>
            <javadoc line="5233">
                Non spacing marks only count as word characters in bounds calculations
                  if they have a base character.                
            </javadoc>
            <method name="hasBaseCharacter" type="boolean" line="5239">
                <params>
                    <param name="matcher" type="Matcher"/>
                    <param name="i" type="int"/>
                    <param name="seq" type="CharSequence"/>
                </params>
                <declaration name="start" type="int" line="5240"/>
                <scope line="5242">
                    <declaration name="ch" type="int" line="5243"/>
                </scope>
            </method>
            <class name="BnM" line="5253">
                <extends class="Node"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="5253">
                    Attempts to match a slice in the input using the Boyer-Moore string
                      matching algorithm. The algorithm is based on the idea that the
                      pattern can be shifted farther ahead in the search text if it is
                      matched right to left.
                      &lt;p&gt;
                      The pattern is compared to the input one character at a time, from
                      the rightmost character in the pattern to the left. If the characters
                      all match the pattern has been found. If a character does not match,
                      the pattern is shifted right a distance that is the maximum of two
                      functions, the bad character shift and the good suffix shift. This
                      shift moves the attempted match position through the input more
                      quickly than a naive one position at a time check.
                      &lt;p&gt;
                      The bad character shift is based on the character from the text that
                      did not match. If the character does not appear in the pattern, the
                      pattern can be shifted completely beyond the bad character. If the
                      character does occur in the pattern, the pattern can be shifted to
                      line the pattern up with the next occurrence of that character.
                      &lt;p&gt;
                      The good suffix shift is based on the idea that some subset on the right
                      side of the pattern has matched. When a bad character is found, the
                      pattern can be shifted right by the pattern length if the subset does
                      not occur again in pattern, or by the amount of distance to the
                      next occurrence of the subset in the pattern.
                      Boyer-Moore search methods adapted from code by Amy Yu.                    
                </javadoc>
                <declaration name="buffer" type="int[]" line="5282"/>
                <declaration name="lastOcc" type="int[]" line="5283"/>
                <declaration name="optoSft" type="int[]" line="5284"/>
                <javadoc line="5286">
                    Pre calculates arrays needed to generate the bad character
                      shift and the good suffix shift. Only the last seven bits
                      are used to see if chars match; This keeps the tables small
                      and covers the heavily used ASCII range, but occasionally
                      results in an aliased match for the bad character shift.                    
                </javadoc>
                <method name="optimize" type="Node" line="5293">
                    <params>
                        <param name="node" type="Node"/>
                    </params>
                    <comment line="5301">
                        The BM algorithm requires a bit of overhead;
                         If the pattern is short don&apos;t use it, since
                         a shift larger than the pattern length cannot
                         be used anyway.                        
                    </comment>
                    <comment line="5311">
                        Precalculate part of the bad character shift
                         It is a table for where in the pattern each
                         lower 7-bit value occurs                        
                    </comment>
                    <comment line="5317">
                        Precalculate the good suffix shift
                         i is the shift amount being considered                        
                    </comment>
                    <comment line="5320">
                        j is the beginning index of suffix being considered                        
                    </comment>
                    <comment line="5322">
                        Testing for good suffix                        
                    </comment>
                    <comment line="5324">
                        src[j..len] is a good suffix                        
                    </comment>
                    <comment line="5327">
                        No match. The array has already been
                         filled up with correct values before.                        
                    </comment>
                    <comment line="5332">
                        This fills up the remaining of optoSft
                         any suffix can not have larger shift amount
                         then its sub-suffix. Why???                        
                    </comment>
                    <comment line="5339">
                        Set the guard value because of unicode compression                        
                    </comment>
                    <scope line="5294"/>
                    <declaration name="src" type="int[]" line="5298"/>
                    <declaration name="patternLength" type="int" line="5299"/>
                    <scope line="5304"/>
                    <declaration name="i" type="int" line="5307"/>
                    <declaration name="lastOcc" type="int[]" line="5308"/>
                    <declaration name="optoSft" type="int[]" line="5309"/>
                    <scope line="5313"/>
                    <scope line="5318">
                        <scope line="5320">
                            <scope line="5322"/>
                            <scope line="5325"/>
                        </scope>
                        <scope line="5334"/>
                    </scope>
                </method>
                <method name="BnM" type="constructor" line="5344">
                    <params>
                        <param name="src" type="int[]"/>
                        <param name="lastOcc" type="int[]"/>
                        <param name="optoSft" type="int[]"/>
                        <param name="next" type="Node"/>
                    </params>
                </method>
                <method name="match" type="boolean" line="5350">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="5356">
                        Loop over all possible match positions in text                        
                    </comment>
                    <comment line="5358">
                        Loop over pattern from right to left                        
                    </comment>
                    <comment line="5362">
                        Shift search to the right by the maximum of the
                         bad character shift and the good suffix shift                        
                    </comment>
                    <comment line="5368">
                        Entire pattern matched starting at i                        
                    </comment>
                    <comment line="5379">
                        BnM is only used as the leading node in the unanchored case,
                         and it replaced its Start() which always searches to the end
                         if it doesn&apos;t find what it&apos;s looking for, so hitEnd is true.                        
                    </comment>
                    <declaration name="src" type="int[]" line="5351"/>
                    <declaration name="patternLength" type="int" line="5352"/>
                    <declaration name="last" type="int" line="5353"/>
                    <scope line="5356">
                        <scope line="5358">
                            <declaration name="ch" type="int" line="5359"/>
                            <scope line="5360"/>
                        </scope>
                        <declaration name="ret" type="boolean" line="5369"/>
                        <scope line="5370"/>
                    </scope>
                </method>
                <method name="study" type="boolean" line="5384">
                    <params>
                        <param name="info" type="TreeInfo"/>
                    </params>
                </method>
            </class>
            <class name="BnMS" line="5391">
                <extends class="BnM"/>
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <javadoc line="5391">
                    Supplementary support version of BnM(). Unpaired surrogates are
                      also handled by this class.                    
                </javadoc>
                <declaration name="lengthInChars" type="int" line="5396"/>
                <method name="BnMS" type="constructor" line="5398">
                    <params>
                        <param name="src" type="int[]"/>
                        <param name="lastOcc" type="int[]"/>
                        <param name="optoSft" type="int[]"/>
                        <param name="next" type="Node"/>
                    </params>
                    <scope line="5400"/>
                </method>
                <method name="match" type="boolean" line="5404">
                    <params>
                        <param name="matcher" type="Matcher"/>
                        <param name="i" type="int"/>
                        <param name="seq" type="CharSequence"/>
                    </params>
                    <comment line="5410">
                        Loop over all possible match positions in text                        
                    </comment>
                    <comment line="5412">
                        Loop over pattern from right to left                        
                    </comment>
                    <comment line="5418">
                        Shift search to the right by the maximum of the
                         bad character shift and the good suffix shift                        
                    </comment>
                    <comment line="5425">
                        Entire pattern matched starting at i                        
                    </comment>
                    <declaration name="src" type="int[]" line="5405"/>
                    <declaration name="patternLength" type="int" line="5406"/>
                    <declaration name="last" type="int" line="5407"/>
                    <scope line="5410">
                        <declaration name="ch" type="int" line="5412"/>
                        <scope line="5414">
                            <scope line="5416">
                                <declaration name="n" type="int" line="5419"/>
                            </scope>
                        </scope>
                        <declaration name="ret" type="boolean" line="5426"/>
                        <scope line="5427"/>
                    </scope>
                </method>
            </class>
            <declaration name="accept" type="Node" line="5443"/>
            <javadoc line="5443">
                This must be the very first initializer.                
            </javadoc>
            <declaration name="lastAccept" type="Node" line="5448"/>
            <class name="CharPropertyNames" line="5450">
                <comment line="4139">
                    Greedy match.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4180">
                    Reluctant match. At this point, the minimum has been satisfied.
                     i is the index to start matching at
                     j is the number of atoms that have matched                    
                </comment>
                <comment line="4321">
                    Aggressive group match                    
                </comment>
                <comment line="4385">
                    Reluctant matching                    
                </comment>
                <comment line="4404">
                    Possessive matching                    
                </comment>
                <comment line="4655">
                    local count index in matcher locals                    
                </comment>
                <comment line="4656">
                    group beginning index                    
                </comment>
                <method name="charPropertyFor" type="CharProperty" line="5452">
                    <params>
                        <param name="name" type="String"/>
                    </params>
                    <declaration name="m" type="CharPropertyFactory" line="5453"/>
                </method>
                <class name="CharPropertyFactory" line="5457">
                    <method name="make" type="CharProperty" line="5458"/>
                </class>
                <method name="defCategory" type="void" line="5462">
                    <params>
                        <param name="name" type="String"/>
                        <param name="typeMask" type="int"/>
                    </params>
                    <anonymous_class line="5463">
                        <method name="make" type="CharProperty" line="5464"/>
                    </anonymous_class>
                </method>
                <method name="defRange" type="void" line="5468">
                    <params>
                        <param name="name" type="String"/>
                        <param name="lower" type="int"/>
                        <param name="upper" type="int"/>
                    </params>
                    <anonymous_class line="5469">
                        <method name="make" type="CharProperty" line="5470"/>
                    </anonymous_class>
                </method>
                <method name="defCtype" type="void" line="5474">
                    <params>
                        <param name="name" type="String"/>
                        <param name="ctype" type="int"/>
                    </params>
                    <anonymous_class line="5475">
                        <method name="make" type="CharProperty" line="5476"/>
                    </anonymous_class>
                </method>
                <class name="CloneableProperty" line="5479">
                    <extends class="CharProperty"/>
                    <implements interface="Cloneable"/>
                    <method name="clone" type="CloneableProperty" line="5482">
                        <scope line="5483"/>
                        <scope line="5485"/>
                    </method>
                </class>
                <method name="defClone" type="void" line="5492">
                    <params>
                        <param name="name" type="String"/>
                        <param name="p" type="CloneableProperty"/>
                    </params>
                    <anonymous_class line="5493">
                        <method name="make" type="CharProperty" line="5494"/>
                    </anonymous_class>
                </method>
                <declaration name="map" type="HashMap&lt;String,CharPropertyFactory&gt;" line="5497"/>
                <scope line="5500">
                    <anonymous_class line="5572">
                        <method name="make" type="CharProperty" line="5573"/>
                    </anonymous_class>
                    <anonymous_class line="5592">
                        <method name="isSatisfiedBy" type="boolean" line="5593">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5595">
                        <method name="isSatisfiedBy" type="boolean" line="5596">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5598">
                        <method name="isSatisfiedBy" type="boolean" line="5599">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5601">
                        <method name="isSatisfiedBy" type="boolean" line="5602">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5604">
                        <method name="isSatisfiedBy" type="boolean" line="5605">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5607">
                        <method name="isSatisfiedBy" type="boolean" line="5608">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5610">
                        <method name="isSatisfiedBy" type="boolean" line="5611">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5613">
                        <method name="isSatisfiedBy" type="boolean" line="5614">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5616">
                        <method name="isSatisfiedBy" type="boolean" line="5617">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5619">
                        <method name="isSatisfiedBy" type="boolean" line="5620">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5622">
                        <method name="isSatisfiedBy" type="boolean" line="5623">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5625">
                        <method name="isSatisfiedBy" type="boolean" line="5626">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5628">
                        <method name="isSatisfiedBy" type="boolean" line="5629">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5631">
                        <method name="isSatisfiedBy" type="boolean" line="5632">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5634">
                        <method name="isSatisfiedBy" type="boolean" line="5635">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5637">
                        <method name="isSatisfiedBy" type="boolean" line="5638">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5640">
                        <method name="isSatisfiedBy" type="boolean" line="5641">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                    <anonymous_class line="5643">
                        <method name="isSatisfiedBy" type="boolean" line="5644">
                            <params>
                                <param name="ch" type="int"/>
                            </params>
                        </method>
                    </anonymous_class>
                </scope>
            </class>
        </class>
    </source>