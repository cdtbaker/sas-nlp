<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.zip">
        <class name="Deflater" line="28">
            <javadoc line="28">
                This class provides support for general purpose compression using the
                  popular ZLIB compression library. The ZLIB compression library was
                  initially developed as part of the PNG graphics standard and is not
                  protected by patents. It is fully described in the specifications at
                  the &lt;a href=&quot;package-summary.html#package_description&quot;&gt;java.util.zip
                  package description&lt;/a&gt;.
                  &lt;p&gt;The following code fragment demonstrates a trivial compression
                  and decompression of a string using &lt;tt&gt;Deflater&lt;/tt&gt; and
                  &lt;tt&gt;Inflater&lt;/tt&gt;.
                  &lt;blockquote&gt;&lt;pre&gt;
                  try {
                  // Encode a String into bytes
                  String inputString = &quot;blahblahblah&quot;;
                  byte[] input = inputString.getBytes(&quot;UTF-8&quot;);
                  // Compress the bytes
                  byte[] output = new byte[100];
                  Deflater compresser = new Deflater();
                  compresser.setInput(input);
                  compresser.finish();
                  int compressedDataLength = compresser.deflate(output);
                  compresser.end();
                  // Decompress the bytes
                  Inflater decompresser = new Inflater();
                  decompresser.setInput(output, 0, compressedDataLength);
                  byte[] result = new byte[100];
                  int resultLength = decompresser.inflate(result);
                  decompresser.end();
                  // Decode the bytes into a String
                  String outputString = new String(result, 0, resultLength, &quot;UTF-8&quot;);
                  } catch(java.io.UnsupportedEncodingException ex) {
                  // handle
                  } catch (java.util.zip.DataFormatException ex) {
                  // handle
                  }
                  &lt;/pre&gt;&lt;/blockquote&gt;                
                <see>
                    Inflater                    
                </see>
                <author>
                    David Connelly                    
                </author>
            </javadoc>
            <declaration name="zsRef" type="ZStreamRef" line="76"/>
            <declaration name="buf" type="byte[]" line="77"/>
            <declaration name="off" type="int" line="78"/>
            <declaration name="level" type="int" line="79"/>
            <declaration name="setParams" type="boolean" line="80"/>
            <declaration name="finish" type="boolean" line="81"/>
            <declaration name="DEFLATED" type="int" line="83"/>
            <javadoc line="83">
                Compression method for the deflate algorithm (the only one currently
                  supported).                
            </javadoc>
            <declaration name="NO_COMPRESSION" type="int" line="89"/>
            <javadoc line="89">
                Compression level for no compression.                
            </javadoc>
            <declaration name="BEST_SPEED" type="int" line="94"/>
            <javadoc line="94">
                Compression level for fastest compression.                
            </javadoc>
            <declaration name="BEST_COMPRESSION" type="int" line="99"/>
            <javadoc line="99">
                Compression level for best compression.                
            </javadoc>
            <declaration name="DEFAULT_COMPRESSION" type="int" line="104"/>
            <javadoc line="104">
                Default compression level.                
            </javadoc>
            <declaration name="FILTERED" type="int" line="109"/>
            <javadoc line="109">
                Compression strategy best used for data consisting mostly of small
                  values with a somewhat random distribution. Forces more Huffman coding
                  and less string matching.                
            </javadoc>
            <declaration name="HUFFMAN_ONLY" type="int" line="116"/>
            <javadoc line="116">
                Compression strategy for Huffman coding only.                
            </javadoc>
            <declaration name="DEFAULT_STRATEGY" type="int" line="121"/>
            <javadoc line="121">
                Default compression strategy.                
            </javadoc>
            <declaration name="NO_FLUSH" type="int" line="126"/>
            <javadoc line="126">
                Compression flush mode used to achieve best compression result.                
                <see>
                    Deflater#deflate(byte[],int,int,int)                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <declaration name="SYNC_FLUSH" type="int" line="134"/>
            <javadoc line="134">
                Compression flush mode used to flush out all pending output; may
                  degrade compression for some compression algorithms.                
                <see>
                    Deflater#deflate(byte[],int,int,int)                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <declaration name="FULL_FLUSH" type="int" line="143"/>
            <javadoc line="143">
                Compression flush mode used to flush out all pending output and
                  reset the deflater. Using this mode too often can seriously degrade
                  compression.                
                <see>
                    Deflater#deflate(byte[],int,int,int)                    
                </see>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <scope line="153"/>
            <javadoc line="158">
                Creates a new compressor using the specified compression level.
                  If &apos;nowrap&apos; is true then the ZLIB header and checksum fields will
                  not be used in order to support the compression format used in
                  both GZIP and PKZIP.                
                <param>
                    level the compression level (0-9)                    
                </param>
                <param>
                    nowrap if true then use GZIP compatible compression                    
                </param>
            </javadoc>
            <method name="Deflater" type="constructor" line="166">
                <params>
                    <param name="level" type="int"/>
                    <param name="nowrap" type="boolean"/>
                </params>
            </method>
            <javadoc line="172">
                Creates a new compressor using the specified compression level.
                  Compressed data will be generated in ZLIB format.                
                <param>
                    level the compression level (0-9)                    
                </param>
            </javadoc>
            <method name="Deflater" type="constructor" line="177">
                <params>
                    <param name="level" type="int"/>
                </params>
            </method>
            <javadoc line="181">
                Creates a new compressor with the default compression level.
                  Compressed data will be generated in ZLIB format.                
            </javadoc>
            <method name="Deflater" type="constructor" line="185"/>
            <javadoc line="189">
                Sets input data for compression. This should be called whenever
                  needsInput() returns true indicating that more input data is required.                
                <param>
                    b the input data bytes                    
                </param>
                <param>
                    off the start offset of the data                    
                </param>
                <param>
                    len the length of the data                    
                </param>
                <see>
                    Deflater#needsInput                    
                </see>
            </javadoc>
            <method name="setInput" type="void" line="197">
                <params>
                    <param name="b" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="198"/>
                <scope line="201"/>
                <scope line="204"/>
            </method>
            <javadoc line="211">
                Sets input data for compression. This should be called whenever
                  needsInput() returns true indicating that more input data is required.                
                <param>
                    b the input data bytes                    
                </param>
                <see>
                    Deflater#needsInput                    
                </see>
            </javadoc>
            <method name="setInput" type="void" line="217">
                <params>
                    <param name="b" type="byte[]"/>
                </params>
            </method>
            <javadoc line="221">
                Sets preset dictionary for compression. A preset dictionary is used
                  when the history buffer can be predetermined. When the data is later
                  uncompressed with Inflater.inflate(), Inflater.getAdler() can be called
                  in order to get the Adler-32 value of the dictionary required for
                  decompression.                
                <param>
                    b the dictionary data bytes                    
                </param>
                <param>
                    off the start offset of the data                    
                </param>
                <param>
                    len the length of the data                    
                </param>
                <see>
                    Inflater#inflate                    
                </see>
                <see>
                    Inflater#getAdler                    
                </see>
            </javadoc>
            <method name="setDictionary" type="void" line="233">
                <params>
                    <param name="b" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="234"/>
                <scope line="237"/>
                <scope line="240"/>
            </method>
            <javadoc line="246">
                Sets preset dictionary for compression. A preset dictionary is used
                  when the history buffer can be predetermined. When the data is later
                  uncompressed with Inflater.inflate(), Inflater.getAdler() can be called
                  in order to get the Adler-32 value of the dictionary required for
                  decompression.                
                <param>
                    b the dictionary data bytes                    
                </param>
                <see>
                    Inflater#inflate                    
                </see>
                <see>
                    Inflater#getAdler                    
                </see>
            </javadoc>
            <method name="setDictionary" type="void" line="256">
                <params>
                    <param name="b" type="byte[]"/>
                </params>
            </method>
            <javadoc line="260">
                Sets the compression strategy to the specified value.                
                <param>
                    strategy the new compression strategy                    
                </param>
                <exception>
                    IllegalArgumentException if the compression strategy is
                      invalid                    
                </exception>
            </javadoc>
            <method name="setStrategy" type="void" line="266">
                <params>
                    <param name="strategy" type="int"/>
                </params>
                <scope line="275">
                    <scope line="276"/>
                </scope>
            </method>
            <javadoc line="283">
                Sets the current compression level to the specified value.                
                <param>
                    level the new compression level (0-9)                    
                </param>
                <exception>
                    IllegalArgumentException if the compression level is invalid                    
                </exception>
            </javadoc>
            <method name="setLevel" type="void" line="288">
                <params>
                    <param name="level" type="int"/>
                </params>
                <scope line="289"/>
                <scope line="292">
                    <scope line="293"/>
                </scope>
            </method>
            <javadoc line="300">
                Returns true if the input data buffer is empty and setInput()
                  should be called in order to provide more input.                
                <return>
                    true if the input data buffer is empty and setInput()
                      should be called in order to provide more input                    
                </return>
            </javadoc>
            <method name="needsInput" type="boolean" line="306"/>
            <javadoc line="310">
                When called, indicates that compression should end with the current
                  contents of the input buffer.                
            </javadoc>
            <method name="finish" type="void" line="314">
                <scope line="315"/>
            </method>
            <javadoc line="320">
                Returns true if the end of the compressed data output stream has
                  been reached.                
                <return>
                    true if the end of the compressed data output stream has
                      been reached                    
                </return>
            </javadoc>
            <method name="finished" type="boolean" line="326">
                <scope line="327"/>
            </method>
            <javadoc line="332">
                Compresses the input data and fills specified buffer with compressed
                  data. Returns actual number of bytes of compressed data. A return value
                  of 0 indicates that {@link #needsInput() needsInput} should be called
                  in order to determine if more input data is required.
                  &lt;p&gt;This method uses {@link #NO_FLUSH} as its compression flush mode.
                  An invocation of this method of the form {@code deflater.deflate(b, off, len)}yields the same result as the invocation of{@code deflater.deflate(b, off, len, Deflater.NO_FLUSH)}.                
                <param>
                    b the buffer for the compressed data                    
                </param>
                <param>
                    off the start offset of the data                    
                </param>
                <param>
                    len the maximum number of bytes of compressed data                    
                </param>
                <return>
                    the actual number of bytes of compressed data written to the
                      output buffer                    
                </return>
            </javadoc>
            <method name="deflate" type="int" line="349">
                <params>
                    <param name="b" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                </params>
            </method>
            <javadoc line="353">
                Compresses the input data and fills specified buffer with compressed
                  data. Returns actual number of bytes of compressed data. A return value
                  of 0 indicates that {@link #needsInput() needsInput} should be called
                  in order to determine if more input data is required.
                  &lt;p&gt;This method uses {@link #NO_FLUSH} as its compression flush mode.
                  An invocation of this method of the form {@code deflater.deflate(b)}yields the same result as the invocation of{@code deflater.deflate(b, 0, b.length, Deflater.NO_FLUSH)}.                
                <param>
                    b the buffer for the compressed data                    
                </param>
                <return>
                    the actual number of bytes of compressed data written to the
                      output buffer                    
                </return>
            </javadoc>
            <method name="deflate" type="int" line="368">
                <params>
                    <param name="b" type="byte[]"/>
                </params>
            </method>
            <javadoc line="372">
                Compresses the input data and fills the specified buffer with compressed
                  data. Returns actual number of bytes of data compressed.
                  &lt;p&gt;Compression flush mode is one of the following three modes:
                  &lt;ul&gt;
                  &lt;li&gt;{@link #NO_FLUSH}: allows the deflater to decide how much data
                  to accumulate, before producing output, in order to achieve the best
                  compression (should be used in normal use scenario). A return value
                  of 0 in this flush mode indicates that {@link #needsInput()} should
                  be called in order to determine if more input data is required.
                  &lt;li&gt;{@link #SYNC_FLUSH}: all pending output in the deflater is flushed,
                  to the specified output buffer, so that an inflater that works on
                  compressed data can get all input data available so far (In particular
                  the {@link #needsInput()} returns {@code true} after this invocation
                  if enough output space is provided). Flushing with {@link #SYNC_FLUSH}may degrade compression for some compression algorithms and so it
                  should be used only when necessary.
                  &lt;li&gt;{@link #FULL_FLUSH}: all pending output is flushed out as with{@link #SYNC_FLUSH}. The compression state is reset so that the inflater
                  that works on the compressed output data can restart from this point
                  if previous compressed data has been damaged or if random access is
                  desired. Using {@link #FULL_FLUSH} too often can seriously degrade
                  compression.
                  &lt;/ul&gt;
                  &lt;p&gt;In the case of {@link #FULL_FLUSH} or {@link #SYNC_FLUSH}, if
                  the return value is {@code len}, the space available in output
                  buffer {@code b}, this method should be invoked again with the same{@code flush} parameter and more output space.                
                <param>
                    b the buffer for the compressed data                    
                </param>
                <param>
                    off the start offset of the data                    
                </param>
                <param>
                    len the maximum number of bytes of compressed data                    
                </param>
                <param>
                    flush the compression flush mode                    
                </param>
                <return>
                    the actual number of bytes of compressed data written to
                      the output buffer                    
                </return>
                <throws>
                    IllegalArgumentException if the flush mode is invalid                    
                </throws>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="deflate" type="int" line="416">
                <params>
                    <param name="b" type="byte[]"/>
                    <param name="off" type="int"/>
                    <param name="len" type="int"/>
                    <param name="flush" type="int"/>
                </params>
                <scope line="417"/>
                <scope line="420"/>
                <scope line="423"/>
            </method>
            <javadoc line="432">
                Returns the ADLER-32 value of the uncompressed data.                
                <return>
                    the ADLER-32 value of the uncompressed data                    
                </return>
            </javadoc>
            <method name="getAdler" type="int" line="436">
                <scope line="437"/>
            </method>
            <javadoc line="443">
                Returns the total number of uncompressed bytes input so far.
                  &lt;p&gt;Since the number of bytes may be greater than
                  Integer.MAX_VALUE, the {@link #getBytesRead()} method is now
                  the preferred means of obtaining this information.&lt;/p&gt;                
                <return>
                    the total number of uncompressed bytes input so far                    
                </return>
            </javadoc>
            <method name="getTotalIn" type="int" line="452"/>
            <javadoc line="456">
                Returns the total number of uncompressed bytes input so far.&lt;/p&gt;                
                <return>
                    the total (non-negative) number of uncompressed bytes input so far                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getBytesRead" type="long" line="462">
                <scope line="463"/>
            </method>
            <javadoc line="469">
                Returns the total number of compressed bytes output so far.
                  &lt;p&gt;Since the number of bytes may be greater than
                  Integer.MAX_VALUE, the {@link #getBytesWritten()} method is now
                  the preferred means of obtaining this information.&lt;/p&gt;                
                <return>
                    the total number of compressed bytes output so far                    
                </return>
            </javadoc>
            <method name="getTotalOut" type="int" line="478"/>
            <javadoc line="482">
                Returns the total number of compressed bytes output so far.&lt;/p&gt;                
                <return>
                    the total (non-negative) number of compressed bytes output so far                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getBytesWritten" type="long" line="488">
                <scope line="489"/>
            </method>
            <javadoc line="495">
                Resets deflater so that a new set of input data can be processed.
                  Keeps current compression level and strategy settings.                
            </javadoc>
            <method name="reset" type="void" line="499">
                <scope line="500"/>
            </method>
            <javadoc line="509">
                Closes the compressor and discards any unprocessed input.
                  This method should be called when the compressor is no longer
                  being used, but will also be called automatically by the
                  finalize() method. Once this method is called, the behavior
                  of the Deflater object is undefined.                
            </javadoc>
            <method name="end" type="void" line="516">
                <scope line="517">
                    <declaration name="addr" type="long" line="518"/>
                    <scope line="520"/>
                </scope>
            </method>
            <javadoc line="527">
                Closes the compressor when garbage is collected.                
            </javadoc>
            <method name="finalize" type="void" line="530"/>
            <method name="ensureOpen" type="void" line="534"/>
            <method name="initIDs" type="void" line="540"/>
            <method name="init" type="long" line="541"/>
            <method name="setDictionary" type="void" line="542"/>
            <method name="deflateBytes" type="int" line="543"/>
            <method name="getAdler" type="int" line="545"/>
            <method name="getBytesRead" type="long" line="546"/>
            <method name="getBytesWritten" type="long" line="547"/>
            <method name="reset" type="void" line="548"/>
            <method name="end" type="void" line="549"/>
        </class>
    </source>