<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <class name="TimSort" line="28">
            <type_params>
                <type_param name="T"/>
            </type_params>
            <comment line="117">
                Actual runtime type will be Object[], regardless of T                
            </comment>
            <comment line="129">
                Number of pending runs on stack                
            </comment>
            <comment line="167">
                The next two methods (which are package private and static) constitute
                 the entire API of this class.  Each of these methods obeys the contract
                 of the public method with the same signature in java.util.Arrays.                
            </comment>
            <javadoc line="28">
                A stable, adaptive, iterative mergesort that requires far fewer than
                  n lg(n) comparisons when running on partially sorted arrays, while
                  offering performance comparable to a traditional mergesort when run
                  on random arrays.  Like all proper mergesorts, this sort is stable and
                  runs O(n log n) time (worst case).  In the worst case, this sort requires
                  temporary storage space for n/2 object references; in the best case,
                  it requires only a small constant amount of space.
                  This implementation was adapted from Tim Peters&apos;s list sort for
                  Python, which is described in detail here:
                  http://svn.python.org/projects/python/trunk/Objects/listsort.txt
                  Tim&apos;s C code may be found here:
                  http://svn.python.org/projects/python/trunk/Objects/listobject.c
                  The underlying techniques are described in this paper (and may have
                  even earlier origins):
                  &quot;Optimistic Sorting and Information Theoretic Complexity&quot;
                  Peter McIlroy
                  SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
                  pp 467-474, Austin, Texas, 25-27 January 1993.
                  While the API to this class consists solely of static methods, it is
                  (privately) instantiable; a TimSort instance holds the state of an ongoing
                  sort, assuming the input array is large enough to warrant the full-blown
                  TimSort. Small arrays are sorted in place, using a binary insertion sort.                
                <author>
                    Josh Bloch                    
                </author>
            </javadoc>
            <declaration name="MIN_MERGE" type="int" line="62"/>
            <javadoc line="62">
                This is the minimum sized sequence that will be merged.  Shorter
                  sequences will be lengthened by calling binarySort.  If the entire
                  array is less than this length, no merges will be performed.
                  This constant should be a power of two.  It was 64 in Tim Peter&apos;s C
                  implementation, but 32 was empirically determined to work better in
                  this implementation.  In the unlikely event that you set this constant
                  to be a number that&apos;s not a power of two, you&apos;ll need to change the{@link #minRunLength} computation.
                  If you decrease this constant, you must change the stackLen
                  computation in the TimSort constructor, or you risk an
                  ArrayOutOfBounds exception.  See listsort.txt for a discussion
                  of the minimum stack length required as a function of the length
                  of the array being sorted and the minimum merge sequence length.                
            </javadoc>
            <declaration name="a" type="T[]" line="81"/>
            <javadoc line="81">
                The array being sorted.                
            </javadoc>
            <declaration name="c" type="Comparator&lt;? super T&gt;" line="86"/>
            <javadoc line="86">
                The comparator for this sort.                
            </javadoc>
            <declaration name="MIN_GALLOP" type="int" line="91"/>
            <javadoc line="91">
                When we get into galloping mode, we stay there until both runs win less
                  often than MIN_GALLOP consecutive times.                
            </javadoc>
            <declaration name="minGallop" type="int" line="97"/>
            <javadoc line="97">
                This controls when we get into galloping mode.  It is initialized
                  to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
                  random data, and lower for highly structured data.                
            </javadoc>
            <declaration name="INITIAL_TMP_STORAGE_LENGTH" type="int" line="104"/>
            <javadoc line="104">
                Maximum initial size of tmp array, which is used for merging.  The array
                  can grow to accommodate demand.
                  Unlike Tim&apos;s original C version, we do not allocate this much storage
                  when sorting smaller arrays.  This change was required for performance.                
            </javadoc>
            <declaration name="tmp" type="T[]" line="113"/>
            <javadoc line="113">
                Temp storage for merges.                
            </javadoc>
            <declaration name="stackSize" type="int" line="118"/>
            <javadoc line="118">
                A stack of pending runs yet to be merged.  Run i starts at
                  address base[i] and extends for len[i] elements.  It&apos;s always
                  true (so long as the indices are in bounds) that:
                  runBase[i] + runLen[i] == runBase[i + 1]
                  so we could cut the storage for this, but it&apos;s a minor amount,
                  and keeping all the info explicit simplifies the code.                
            </javadoc>
            <declaration name="runBase" type="int[]" line="129"/>
            <declaration name="runLen" type="int[]" line="130"/>
            <javadoc line="132">
                Creates a TimSort instance to maintain the state of an ongoing sort.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    c the comparator to determine the order of the sort                    
                </param>
            </javadoc>
            <method name="TimSort" type="constructor" line="138">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <comment line="142">
                    Allocate temp storage (which may be increased later if necessary)                    
                </comment>
                <comment line="149">
                    Allocate runs-to-be-merged stack (which cannot be expanded).  The
                     stack length requirements are described in listsort.txt.  The C
                     version always uses the same stack length (85), but this was
                     measured to be too expensive when sorting &quot;mid-sized&quot; arrays (e.g.,
                     100 elements) in Java.  Therefore, we use smaller (but sufficiently
                     large) stack lengths for smaller arrays.  The &quot;magic numbers&quot; in the
                     computation below must be changed if MIN_MERGE is decreased.  See
                     the MIN_MERGE declaration above for more information.                    
                </comment>
                <declaration name="len" type="int" line="143"/>
                <declaration name="newArray" type="T[]" line="144"/>
                <declaration name="stackLen" type="int" line="159"/>
            </method>
            <method name="sort" type="void" line="172">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
            </method>
            <method name="sort" type="void" line="176">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="lo" type="int"/>
                    <param name="hi" type="int"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <comment line="185">
                    Arrays of size 0 and 1 are always sorted                    
                </comment>
                <comment line="187">
                    If array is small, do a &quot;mini-TimSort&quot; with no merges                    
                </comment>
                <comment line="194">
                    March over the array once, left to right, finding natural runs,
                     extending short natural runs to minRun elements, and merging runs
                     to maintain stack invariant.                    
                </comment>
                <comment line="202">
                    Identify next run                    
                </comment>
                <comment line="205">
                    If run is short, extend to min(minRun, nRemaining)                    
                </comment>
                <comment line="212">
                    Push run onto pending-run stack, and maybe merge                    
                </comment>
                <comment line="216">
                    Advance to find next run                    
                </comment>
                <comment line="221">
                    Merge all remaining runs to complete sort                    
                </comment>
                <scope line="177"/>
                <declaration name="nRemaining" type="int" line="183"/>
                <scope line="188">
                    <declaration name="initRunLen" type="int" line="189"/>
                </scope>
                <declaration name="ts" type="TimSort&lt;T&gt;" line="199"/>
                <declaration name="minRun" type="int" line="200"/>
                <scope line="201">
                    <declaration name="runLen" type="int" line="203"/>
                    <scope line="206">
                        <declaration name="force" type="int" line="207"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="227">
                Sorts the specified portion of the specified array using a binary
                  insertion sort.  This is the best method for sorting small numbers
                  of elements.  It requires O(n log n) compares, but O(n^2) data
                  movement (worst case).
                  If the initial part of the specified range is already sorted,
                  this method can take advantage of it: the method assumes that the
                  elements from index {@code lo}, inclusive, to {@code start},
                  exclusive are already sorted.                
                <param>
                    a the array in which a range is to be sorted                    
                </param>
                <param>
                    lo the index of the first element in the range to be sorted                    
                </param>
                <param>
                    hi the index after the last element in the range to be sorted                    
                </param>
                <param>
                    start the index of the first element in the range that is
                      not already known to be sorted ({@code lo <= start <= hi})                    
                </param>
                <param>
                    c comparator to used for the sort                    
                </param>
            </javadoc>
            <method name="binarySort" type="void" line="247">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="lo" type="int"/>
                    <param name="hi" type="int"/>
                    <param name="start" type="int"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <comment line="254">
                    Set left (and right) to the index where a[start] (pivot) belongs                    
                </comment>
                <comment line="258">
                    Invariants:
                       pivot &gt;= all in [lo, left).
                       pivot &lt;  all in [right, start).                    
                </comment>
                <comment line="272">
                    The invariants still hold: pivot &gt;= all in [lo, left) and
                     pivot &lt; all in [left, start), so pivot belongs at left.  Note
                     that if there are elements equal to pivot, left points to the
                     first slot after them -- that&apos;s why this sort is stable.
                     Slide elements over to make room for pivot.                    
                </comment>
                <comment line="279">
                    The number of elements to move                    
                </comment>
                <comment line="280">
                    Switch is just an optimization for arraycopy in default case                    
                </comment>
                <scope line="251">
                    <declaration name="pivot" type="T" line="252"/>
                    <declaration name="left" type="int" line="255"/>
                    <declaration name="right" type="int" line="256"/>
                    <scope line="263">
                        <declaration name="mid" type="int" line="264"/>
                    </scope>
                    <declaration name="n" type="int" line="279"/>
                </scope>
            </method>
            <javadoc line="291">
                Returns the length of the run beginning at the specified position in
                  the specified array and reverses the run if it is descending (ensuring
                  that the run will always be ascending when the method returns).
                  A run is the longest ascending sequence with:
                  a[lo] &lt;= a[lo + 1] &lt;= a[lo + 2] &lt;= ...
                  or the longest descending sequence with:
                  a[lo] &gt;  a[lo + 1] &gt;  a[lo + 2] &gt;  ...
                  For its intended use in a stable mergesort, the strictness of the
                  definition of &quot;descending&quot; is needed so that the call can safely
                  reverse a descending sequence without violating stability.                
                <param>
                    a the array in which a run is to be counted and possibly reversed                    
                </param>
                <param>
                    lo index of the first element in the run                    
                </param>
                <param>
                    hi index after the last element that may be contained in the run.
                      It is required that {@code lo < hi}.                    
                </param>
                <param>
                    c the comparator to used for the sort                    
                </param>
                <return>
                    the length of the run beginning at the specified position in
                      the specified array                    
                </return>
            </javadoc>
            <method name="countRunAndMakeAscending" type="int" line="317">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="lo" type="int"/>
                    <param name="hi" type="int"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <comment line="323">
                    Find end of run, and reverse range if descending                    
                </comment>
                <comment line="324">
                    Descending                    
                </comment>
                <comment line="328">
                    Ascending                    
                </comment>
                <declaration name="runHi" type="int" line="319"/>
                <scope line="324"/>
                <scope line="328"/>
            </method>
            <javadoc line="336">
                Reverse the specified range of the specified array.                
                <param>
                    a the array in which a range is to be reversed                    
                </param>
                <param>
                    lo the index of the first element in the range to be reversed                    
                </param>
                <param>
                    hi the index after the last element in the range to be reversed                    
                </param>
            </javadoc>
            <method name="reverseRange" type="void" line="343">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="lo" type="int"/>
                    <param name="hi" type="int"/>
                </params>
                <scope line="345">
                    <declaration name="t" type="Object" line="346"/>
                </scope>
            </method>
            <javadoc line="352">
                Returns the minimum acceptable run length for an array of the specified
                  length. Natural runs shorter than this will be extended with{@link #binarySort}.
                  Roughly speaking, the computation is:
                  If n &lt; MIN_MERGE, return n (it&apos;s too small to bother with fancy stuff).
                  Else if n is an exact power of 2, return MIN_MERGE/2.
                  Else return an int k, MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE, such that n/k
                  is close to, but strictly less than, an exact power of 2.
                  For the rationale, see listsort.txt.                
                <param>
                    n the length of the array to be sorted                    
                </param>
                <return>
                    the length of the minimum run to be merged                    
                </return>
            </javadoc>
            <method name="minRunLength" type="int" line="369">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="371">
                    Becomes 1 if any 1 bits are shifted off                    
                </comment>
                <declaration name="r" type="int" line="371"/>
                <scope line="372"/>
            </method>
            <javadoc line="379">
                Pushes the specified run onto the pending-run stack.                
                <param>
                    runBase index of the first element in the run                    
                </param>
                <param>
                    runLen  the number of elements in the run                    
                </param>
            </javadoc>
            <method name="pushRun" type="void" line="385">
                <params>
                    <param name="runBase" type="int"/>
                    <param name="runLen" type="int"/>
                </params>
            </method>
            <javadoc line="391">
                Examines the stack of runs waiting to be merged and merges adjacent runs
                  until the stack invariants are reestablished:
                  1. runLen[i - 3] &gt; runLen[i - 2] + runLen[i - 1]
                  2. runLen[i - 2] &gt; runLen[i - 1]
                  This method is called each time a new run is pushed onto the stack,
                  so the invariants are guaranteed to hold for i &lt; stackSize upon
                  entry to the method.                
            </javadoc>
            <method name="mergeCollapse" type="void" line="402">
                <comment line="412">
                    Invariant is established                    
                </comment>
                <scope line="403">
                    <declaration name="n" type="int" line="404"/>
                    <scope line="405"/>
                    <scope line="409"/>
                    <scope line="411"/>
                </scope>
            </method>
            <javadoc line="417">
                Merges all runs on the stack until only one remains.  This method is
                  called once, to complete the sort.                
            </javadoc>
            <method name="mergeForceCollapse" type="void" line="421">
                <scope line="422">
                    <declaration name="n" type="int" line="423"/>
                </scope>
            </method>
            <javadoc line="430">
                Merges the two runs at stack indices i and i+1.  Run i must be
                  the penultimate or antepenultimate run on the stack.  In other words,
                  i must be equal to stackSize-2 or stackSize-3.                
                <param>
                    i stack index of the first of the two runs to merge                    
                </param>
            </javadoc>
            <method name="mergeAt" type="void" line="437">
                <params>
                    <param name="i" type="int"/>
                </params>
                <comment line="449">
                    Record the length of the combined runs; if i is the 3rd-last
                     run now, also slide over the last run (which isn&apos;t involved
                     in this merge).  The current run (i+1) goes away in any case.                    
                </comment>
                <comment line="461">
                    Find where the first element of run2 goes in run1. Prior elements
                     in run1 can be ignored (because they&apos;re already in place).                    
                </comment>
                <comment line="472">
                    Find where the last element of run1 goes in run2. Subsequent elements
                     in run2 can be ignored (because they&apos;re already in place).                    
                </comment>
                <comment line="481">
                    Merge remaining runs, using tmp array with min(len1, len2) elements                    
                </comment>
                <declaration name="base1" type="int" line="442"/>
                <declaration name="len1" type="int" line="443"/>
                <declaration name="base2" type="int" line="444"/>
                <declaration name="len2" type="int" line="445"/>
                <scope line="455"/>
                <declaration name="k" type="int" line="465"/>
            </method>
            <javadoc line="488">
                Locates the position at which to insert the specified key into the
                  specified sorted range; if the range contains an element equal to key,
                  returns the index of the leftmost equal element.                
                <param>
                    key the key whose insertion point to search for                    
                </param>
                <param>
                    a the array in which to search                    
                </param>
                <param>
                    base the index of the first element in the range                    
                </param>
                <param>
                    len the length of the range; must be > 0                    
                </param>
                <param>
                    hint the index at which to begin the search, 0 <= hint < n.
                      The closer hint is to the result, the faster this method will run.                    
                </param>
                <param>
                    c the comparator used to order the range, and to search                    
                </param>
                <return>
                    the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
                      pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
                      In other words, key belongs at index b + k; or in other words,
                      the first k elements of a should precede key, and the last n - k
                      should follow it.                    
                </return>
            </javadoc>
            <method name="gallopLeft" type="int" line="507">
                <params>
                    <param name="key" type="T"/>
                    <param name="a" type="T[]"/>
                    <param name="base" type="int"/>
                    <param name="len" type="int"/>
                    <param name="hint" type="int"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <comment line="512">
                    Gallop right until a[base+hint+lastOfs] &lt; key &lt;= a[base+hint+ofs]                    
                </comment>
                <comment line="517">
                    int overflow                    
                </comment>
                <comment line="523">
                    Make offsets relative to base                    
                </comment>
                <comment line="526">
                    key &lt;= a[base + hint]                    
                </comment>
                <comment line="527">
                    Gallop left until a[base+hint-ofs] &lt; key &lt;= a[base+hint-lastOfs]                    
                </comment>
                <comment line="532">
                    int overflow                    
                </comment>
                <comment line="538">
                    Make offsets relative to base                    
                </comment>
                <comment line="545">
                    Now a[base+lastOfs] &lt; key &lt;= a[base+ofs], so key belongs somewhere
                     to the right of lastOfs but no farther right than ofs.  Do a binary
                     search, with invariant a[base + lastOfs - 1] &lt; key &lt;= a[base + ofs].                    
                </comment>
                <comment line="555">
                    a[base + m] &lt; key                    
                </comment>
                <comment line="557">
                    key &lt;= a[base + m]                    
                </comment>
                <comment line="559">
                    so a[base + ofs - 1] &lt; key &lt;= a[base + ofs]                    
                </comment>
                <declaration name="lastOfs" type="int" line="509"/>
                <declaration name="ofs" type="int" line="510"/>
                <scope line="511">
                    <declaration name="maxOfs" type="int" line="513"/>
                    <scope line="514"/>
                </scope>
                <scope line="526">
                    <declaration name="maxOfs" type="int" line="528"/>
                    <scope line="529"/>
                    <declaration name="tmp" type="int" line="539"/>
                </scope>
                <scope line="551">
                    <declaration name="m" type="int" line="552"/>
                </scope>
            </method>
            <javadoc line="563">
                Like gallopLeft, except that if the range contains an element equal to
                  key, gallopRight returns the index after the rightmost equal element.                
                <param>
                    key the key whose insertion point to search for                    
                </param>
                <param>
                    a the array in which to search                    
                </param>
                <param>
                    base the index of the first element in the range                    
                </param>
                <param>
                    len the length of the range; must be > 0                    
                </param>
                <param>
                    hint the index at which to begin the search, 0 <= hint < n.
                      The closer hint is to the result, the faster this method will run.                    
                </param>
                <param>
                    c the comparator used to order the range, and to search                    
                </param>
                <return>
                    the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]                    
                </return>
            </javadoc>
            <method name="gallopRight" type="int" line="577">
                <params>
                    <param name="key" type="T"/>
                    <param name="a" type="T[]"/>
                    <param name="base" type="int"/>
                    <param name="len" type="int"/>
                    <param name="hint" type="int"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <comment line="583">
                    Gallop left until a[b+hint - ofs] &lt;= key &lt; a[b+hint - lastOfs]                    
                </comment>
                <comment line="588">
                    int overflow                    
                </comment>
                <comment line="594">
                    Make offsets relative to b                    
                </comment>
                <comment line="598">
                    a[b + hint] &lt;= key                    
                </comment>
                <comment line="599">
                    Gallop right until a[b+hint + lastOfs] &lt;= key &lt; a[b+hint + ofs]                    
                </comment>
                <comment line="604">
                    int overflow                    
                </comment>
                <comment line="610">
                    Make offsets relative to b                    
                </comment>
                <comment line="616">
                    Now a[b + lastOfs] &lt;= key &lt; a[b + ofs], so key belongs somewhere to
                     the right of lastOfs but no farther right than ofs.  Do a binary
                     search, with invariant a[b + lastOfs - 1] &lt;= key &lt; a[b + ofs].                    
                </comment>
                <comment line="626">
                    key &lt; a[b + m]                    
                </comment>
                <comment line="628">
                    a[b + m] &lt;= key                    
                </comment>
                <comment line="630">
                    so a[b + ofs - 1] &lt;= key &lt; a[b + ofs]                    
                </comment>
                <declaration name="ofs" type="int" line="580"/>
                <declaration name="lastOfs" type="int" line="581"/>
                <scope line="582">
                    <declaration name="maxOfs" type="int" line="584"/>
                    <scope line="585"/>
                    <declaration name="tmp" type="int" line="595"/>
                </scope>
                <scope line="598">
                    <declaration name="maxOfs" type="int" line="600"/>
                    <scope line="601"/>
                </scope>
                <scope line="622">
                    <declaration name="m" type="int" line="623"/>
                </scope>
            </method>
            <javadoc line="634">
                Merges two adjacent runs in place, in a stable fashion.  The first
                  element of the first run must be greater than the first element of the
                  second run (a[base1] &gt; a[base2]), and the last element of the first run
                  (a[base1 + len1-1]) must be greater than all elements of the second run.
                  For performance, this method should be called only when len1 &lt;= len2;
                  its twin, mergeHi should be called if len1 &gt;= len2.  (Either method
                  may be called if len1 == len2.)                
                <param>
                    base1 index of first element in first run to be merged                    
                </param>
                <param>
                    len1  length of first run to be merged (must be > 0)                    
                </param>
                <param>
                    base2 index of first element in second run to be merged
                      (must be aBase + aLen)                    
                </param>
                <param>
                    len2  length of second run to be merged (must be > 0)                    
                </param>
            </javadoc>
            <method name="mergeLo" type="void" line="650">
                <params>
                    <param name="base1" type="int"/>
                    <param name="len1" type="int"/>
                    <param name="base2" type="int"/>
                    <param name="len2" type="int"/>
                </params>
                <comment line="653">
                    Copy first run into temp array                    
                </comment>
                <comment line="654">
                    For performance                    
                </comment>
                <comment line="658">
                    Indexes into tmp array                    
                </comment>
                <comment line="659">
                    Indexes int a                    
                </comment>
                <comment line="660">
                    Indexes int a                    
                </comment>
                <comment line="662">
                    Move first element of second run and deal with degenerate cases                    
                </comment>
                <comment line="670">
                    Last elt of run 1 to end of merge                    
                </comment>
                <comment line="674">
                    Use local variable for performance                    
                </comment>
                <comment line="675">
                    &quot;    &quot;       &quot;     &quot;      &quot;                    
                </comment>
                <comment line="678">
                    Number of times in a row that first run won                    
                </comment>
                <comment line="679">
                    Number of times in a row that second run won                    
                </comment>
                <comment line="681">
                    Do the straightforward thing until (if ever) one run starts
                     winning consistently.                    
                </comment>
                <comment line="702">
                    One run is winning so consistently that galloping may be a
                     huge win. So try that, and continue galloping until (if ever)
                     neither run appears to be winning consistently anymore.                    
                </comment>
                <comment line="715">
                    len1 == 1 || len1 == 0                    
                </comment>
                <comment line="738">
                    Penalize for leaving gallop mode                    
                </comment>
                <comment line="739">
                    End of &quot;outer&quot; loop                    
                </comment>
                <comment line="740">
                    Write back to field                    
                </comment>
                <comment line="745">
                    Last elt of run 1 to end of merge                    
                </comment>
                <declaration name="a" type="T[]" line="654"/>
                <declaration name="tmp" type="T[]" line="655"/>
                <declaration name="cursor1" type="int" line="658"/>
                <declaration name="cursor2" type="int" line="659"/>
                <declaration name="dest" type="int" line="660"/>
                <scope line="664"/>
                <scope line="668"/>
                <declaration name="c" type="Comparator&lt;? super T&gt;" line="674"/>
                <declaration name="minGallop" type="int" line="675"/>
                <scope line="677">
                    <declaration name="count1" type="int" line="678"/>
                    <declaration name="count2" type="int" line="679"/>
                    <scope line="685">
                        <scope line="687"/>
                        <scope line="693"/>
                    </scope>
                    <scope line="707">
                        <scope line="710"/>
                        <scope line="723"/>
                    </scope>
                </scope>
                <scope line="742"/>
                <scope line="746"/>
                <scope line="749"/>
            </method>
            <javadoc line="756">
                Like mergeLo, except that this method should be called only if
                  len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2.  (Either method
                  may be called if len1 == len2.)                
                <param>
                    base1 index of first element in first run to be merged                    
                </param>
                <param>
                    len1  length of first run to be merged (must be > 0)                    
                </param>
                <param>
                    base2 index of first element in second run to be merged
                      (must be aBase + aLen)                    
                </param>
                <param>
                    len2  length of second run to be merged (must be > 0)                    
                </param>
            </javadoc>
            <method name="mergeHi" type="void" line="767">
                <params>
                    <param name="base1" type="int"/>
                    <param name="len1" type="int"/>
                    <param name="base2" type="int"/>
                    <param name="len2" type="int"/>
                </params>
                <comment line="770">
                    Copy second run into temp array                    
                </comment>
                <comment line="771">
                    For performance                    
                </comment>
                <comment line="775">
                    Indexes into a                    
                </comment>
                <comment line="776">
                    Indexes into tmp array                    
                </comment>
                <comment line="777">
                    Indexes into a                    
                </comment>
                <comment line="779">
                    Move last element of first run and deal with degenerate cases                    
                </comment>
                <comment line="793">
                    Use local variable for performance                    
                </comment>
                <comment line="794">
                    &quot;    &quot;       &quot;     &quot;      &quot;                    
                </comment>
                <comment line="797">
                    Number of times in a row that first run won                    
                </comment>
                <comment line="798">
                    Number of times in a row that second run won                    
                </comment>
                <comment line="800">
                    Do the straightforward thing until (if ever) one run
                     appears to win consistently.                    
                </comment>
                <comment line="821">
                    One run is winning so consistently that galloping may be a
                     huge win. So try that, and continue galloping until (if ever)
                     neither run appears to be winning consistently anymore.                    
                </comment>
                <comment line="847">
                    len2 == 1 || len2 == 0                    
                </comment>
                <comment line="857">
                    Penalize for leaving gallop mode                    
                </comment>
                <comment line="858">
                    End of &quot;outer&quot; loop                    
                </comment>
                <comment line="859">
                    Write back to field                    
                </comment>
                <comment line="866">
                    Move first elt of run2 to front of merge                    
                </comment>
                <declaration name="a" type="T[]" line="771"/>
                <declaration name="tmp" type="T[]" line="772"/>
                <declaration name="cursor1" type="int" line="775"/>
                <declaration name="cursor2" type="int" line="776"/>
                <declaration name="dest" type="int" line="777"/>
                <scope line="781"/>
                <scope line="785"/>
                <declaration name="c" type="Comparator&lt;? super T&gt;" line="793"/>
                <declaration name="minGallop" type="int" line="794"/>
                <scope line="796">
                    <declaration name="count1" type="int" line="797"/>
                    <declaration name="count2" type="int" line="798"/>
                    <scope line="804">
                        <scope line="806"/>
                        <scope line="812"/>
                    </scope>
                    <scope line="826">
                        <scope line="829"/>
                        <scope line="842"/>
                    </scope>
                </scope>
                <scope line="861"/>
                <scope line="867"/>
                <scope line="870"/>
            </method>
            <javadoc line="877">
                Ensures that the external array tmp has at least the specified
                  number of elements, increasing its size if necessary.  The size
                  increases exponentially to ensure amortized linear time complexity.                
                <param>
                    minCapacity the minimum required capacity of the tmp array                    
                </param>
                <return>
                    tmp, whether or not it grew                    
                </return>
            </javadoc>
            <method name="ensureCapacity" type="T[]" line="885">
                <params>
                    <param name="minCapacity" type="int"/>
                </params>
                <comment line="887">
                    Compute smallest power of 2 &gt; minCapacity                    
                </comment>
                <comment line="896">
                    Not bloody likely!                    
                </comment>
                <scope line="886">
                    <declaration name="newSize" type="int" line="888"/>
                    <declaration name="newArray" type="T[]" line="901"/>
                </scope>
            </method>
            <javadoc line="908">
                Checks that fromIndex and toIndex are in range, and throws an
                  appropriate exception if they aren&apos;t.                
                <param>
                    arrayLen the length of the array                    
                </param>
                <param>
                    fromIndex the index of the first element of the range                    
                </param>
                <param>
                    toIndex the index after the last element of the range                    
                </param>
                <throws>
                    IllegalArgumentException if fromIndex > toIndex                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if fromIndex < 0
                      or toIndex > arrayLen                    
                </throws>
            </javadoc>
            <method name="rangeCheck" type="void" line="919">
                <params>
                    <param name="arrayLen" type="int"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
        </class>
    </source>