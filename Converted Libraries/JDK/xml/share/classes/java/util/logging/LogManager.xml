<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.logging">
        <import package="java.io"/>
        <import package="java.util"/>
        <import package="java.security"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.beans.PropertyChangeSupport"/>
        <import package="java.net.URL"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="LogManager" line="39">
            <comment line="150">
                The global LogManager object                
            </comment>
            <comment line="159">
                Table of named Loggers that maps names to Loggers.                
            </comment>
            <comment line="161">
                Tree of named Loggers                
            </comment>
            <comment line="165">
                Have we done the primordial reading of the configuration file?
                 (Must be done after a suitable amount of java.lang.System
                 initialization has been done)                
            </comment>
            <comment line="169">
                Have we initialized global (root) handlers yet?
                 This gets set to false in readConfiguration                
            </comment>
            <comment line="172">
                True if JVM death is imminent and the exit hook has been called.                
            </comment>
            <comment line="216">
                This private class is used as a shutdown hook.
                 It does a &quot;reset&quot; to close all open handlers.                
            </comment>
            <comment line="341">
                Package-level method.
                 Find or create a specified logger instance. If a logger has
                 already been created with the given name it is returned.
                 Otherwise a new logger instance is created and registered
                 in the LogManager global namespace.                
            </comment>
            <comment line="347">
                This method will always return a non-null Logger object.
                 Synchronization is not required here. All synchronization for
                 adding a new Logger object is handled by addLogger().                
            </comment>
            <comment line="379">
                If logger.getUseParentHandlers() returns &apos;true&apos; and any of the logger&apos;s
                 parents have levels or handlers defined, make sure they are instantiated.                
            </comment>
            <comment line="400">
                Add new per logger handlers.
                 We need to raise privilege here. All our decisions will
                 be made based on the logging configuration, which can
                 only be modified by trusted code.                
            </comment>
            <comment line="445">
                loggerRefQueue holds LoggerWeakRef objects for Logger objects
                 that have been GC&apos;ed.                
            </comment>
            <comment line="450">
                Package-level inner class.
                 Helper class for managing WeakReferences to Logger objects.
                
                 LogManager.namedLoggers
                     - has weak references to all named Loggers
                     - namedLoggers keeps the LoggerWeakRef objects for the named
                       Loggers around until we can deal with the book keeping for
                       the named Logger that is being GC&apos;ed.
                 LogManager.LogNode.loggerRef
                     - has a weak reference to a named Logger
                     - the LogNode will also keep the LoggerWeakRef objects for
                       the named Loggers around; currently LogNodes never go away.
                 Logger.kids
                     - has a weak reference to each direct child Logger; this
                       includes anonymous and named Loggers
                     - anonymous Loggers are always children of the rootLogger
                       which is a strong reference; rootLogger.kids keeps the
                       LoggerWeakRef objects for the anonymous Loggers around
                       until we can deal with the book keeping.                
            </comment>
            <comment line="516">
                Package-level method.
                 Drain some Logger objects that have been GC&apos;ed.
                
                 drainLoggerRefQueueBounded() is called by addLogger() below
                 and by Logger.getAnonymousLogger(String) so we&apos;ll drain up to
                 MAX_ITERATIONS GC&apos;ed Loggers for every Logger we add.
                
                 On a WinXP VMware client, a MAX_ITERATIONS value of 400 gives
                 us about a 50/50 mix in increased weak ref counts versus
                 decreased weak ref counts in the AnonLoggerWeakRefLeak test.
                 Here are stats for cleaning up sets of 400 anonymous Loggers:
                   - test duration 1 minute
                   - sample size of 125 sets of 400
                   - average: 1.99 ms
                   - minimum: 0.57 ms
                   - maximum: 25.3 ms
                
                 The same config gives us a better decreased weak ref count
                 than increased weak ref count in the LoggerWeakRefLeak test.
                 Here are stats for cleaning up sets of 400 named Loggers:
                   - test duration 2 minutes
                   - sample size of 506 sets of 400
                   - average: 0.57 ms
                   - minimum: 0.02 ms
                   - maximum: 10.9 ms                
            </comment>
            <comment line="642">
                Private method to set a level on a logger.
                 If necessary, we raise privilege before doing the call.                
            </comment>
            <comment line="662">
                Private method to set a parent on a logger.
                 If necessary, we raise privilege before doing the setParent call.                
            </comment>
            <comment line="680">
                Find a node in our tree of logger nodes.
                 If necessary, create it.                
            </comment>
            <comment line="849">
                Private method to reset an individual target logger.                
            </comment>
            <comment line="874">
                get a list of whitespace separated classnames from a property.                
            </comment>
            <comment line="962">
                Package private method to get a String property.
                 If the property is not defined we return the given
                 default value.                
            </comment>
            <comment line="973">
                Package private method to get an integer property.
                 If the property is not defined or cannot be parsed
                 we return the given default value.                
            </comment>
            <comment line="988">
                Package private method to get a boolean property.
                 If the property is not defined or cannot be parsed
                 we return the given default value.                
            </comment>
            <comment line="1005">
                Package private method to get a Level property.
                 If the property is not defined or cannot be parsed
                 we return the given default value.                
            </comment>
            <comment line="1020">
                Package private method to get a filter property.
                 We return an instance of the class named by the &quot;name&quot;
                 property. If the property is not defined or has problems
                 we return the defaultValue.                
            </comment>
            <comment line="1041">
                Package private method to get a formatter property.
                 We return an instance of the class named by the &quot;name&quot;
                 property. If the property is not defined or has problems
                 we return the defaultValue.                
            </comment>
            <comment line="1061">
                Private method to load the global handlers.
                 We do the real work lazily, when the global handlers
                 are first used.                
            </comment>
            <comment line="1101">
                Nested class to represent a node in our tree of named loggers.                
            </comment>
            <comment line="1131">
                We use a subclass of Logger for the root logger, so
                 that we only instantiate the global handlers when they
                 are first needed.                
            </comment>
            <comment line="1164">
                Private method to be called when the configuration has
                 changed to apply any level settings to any pre-existing loggers.                
            </comment>
            <comment line="1189">
                Management Support                
            </comment>
            <javadoc line="39">
                There is a single global LogManager object that is used to
                  maintain a set of shared state about Loggers and log services.
                  &lt;p&gt;
                  This LogManager object:
                  &lt;ul&gt;
                  &lt;li&gt; Manages a hierarchical namespace of Logger objects.  All
                  named Loggers are stored in this namespace.
                  &lt;li&gt; Manages a set of logging control properties.  These are
                  simple key-value pairs that can be used by Handlers and
                  other logging objects to configure themselves.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  The global LogManager object can be retrieved using LogManager.getLogManager().
                  The LogManager object is created during class initialization and
                  cannot subsequently be changed.
                  &lt;p&gt;
                  At startup the LogManager class is located using the
                  java.util.logging.manager system property.
                  &lt;p&gt;
                  By default, the LogManager reads its initial configuration from
                  a properties file &quot;lib/logging.properties&quot; in the JRE directory.
                  If you edit that property file you can change the default logging
                  configuration for all uses of that JRE.
                  &lt;p&gt;
                  In addition, the LogManager uses two optional system properties that
                  allow more control over reading the initial configuration:
                  &lt;ul&gt;
                  &lt;li&gt;&quot;java.util.logging.config.class&quot;
                  &lt;li&gt;&quot;java.util.logging.config.file&quot;
                  &lt;/ul&gt;
                  These two properties may be set via the Preferences API, or as
                  command line property definitions to the &quot;java&quot; command, or as
                  system property definitions passed to JNI_CreateJavaVM.
                  &lt;p&gt;
                  If the &quot;java.util.logging.config.class&quot; property is set, then the
                  property value is treated as a class name.  The given class will be
                  loaded, an object will be instantiated, and that object&apos;s constructor
                  is responsible for reading in the initial configuration.  (That object
                  may use other system properties to control its configuration.)  The
                  alternate configuration class can use &lt;tt&gt;readConfiguration(InputStream)&lt;/tt&gt;
                  to define properties in the LogManager.
                  &lt;p&gt;
                  If &quot;java.util.logging.config.class&quot; property is &lt;b&gt;not&lt;/b&gt; set,
                  then the &quot;java.util.logging.config.file&quot; system property can be used
                  to specify a properties file (in java.util.Properties format). The
                  initial logging configuration will be read from this file.
                  &lt;p&gt;
                  If neither of these properties is defined then, as described
                  above, the LogManager will read its initial configuration from
                  a properties file &quot;lib/logging.properties&quot; in the JRE directory.
                  &lt;p&gt;
                  The properties for loggers and Handlers will have names starting
                  with the dot-separated name for the handler or logger.
                  &lt;p&gt;
                  The global logging properties may include:
                  &lt;ul&gt;
                  &lt;li&gt;A property &quot;handlers&quot;.  This defines a whitespace or comma separated
                  list of class names for handler classes to load and register as
                  handlers on the root Logger (the Logger named &quot;&quot;).  Each class
                  name must be for a Handler class which has a default constructor.
                  Note that these Handlers may be created lazily, when they are
                  first used.
                  &lt;li&gt;A property &quot;&amp;lt;logger&amp;gt;.handlers&quot;. This defines a whitespace or
                  comma separated list of class names for handlers classes to
                  load and register as handlers to the specified logger. Each class
                  name must be for a Handler class which has a default constructor.
                  Note that these Handlers may be created lazily, when they are
                  first used.
                  &lt;li&gt;A property &quot;&amp;lt;logger&amp;gt;.useParentHandlers&quot;. This defines a boolean
                  value. By default every logger calls its parent in addition to
                  handling the logging message itself, this often result in messages
                  being handled by the root logger as well. When setting this property
                  to false a Handler needs to be configured for this logger otherwise
                  no logging messages are delivered.
                  &lt;li&gt;A property &quot;config&quot;.  This property is intended to allow
                  arbitrary configuration code to be run.  The property defines a
                  whitespace or comma separated list of class names.  A new instance will be
                  created for each named class.  The default constructor of each class
                  may execute arbitrary code to update the logging configuration, such as
                  setting logger levels, adding handlers, adding filters, etc.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  Note that all classes loaded during LogManager configuration are
                  first searched on the system class path before any user class path.
                  That includes the LogManager class, any config classes, and any
                  handler classes.
                  &lt;p&gt;
                  Loggers are organized into a naming hierarchy based on their
                  dot separated names.  Thus &quot;a.b.c&quot; is a child of &quot;a.b&quot;, but
                  &quot;a.b1&quot; and a.b2&quot; are peers.
                  &lt;p&gt;
                  All properties whose names end with &quot;.level&quot; are assumed to define
                  log levels for Loggers.  Thus &quot;foo.level&quot; defines a log level for
                  the logger called &quot;foo&quot; and (recursively) for any of its children
                  in the naming hierarchy.  Log Levels are applied in the order they
                  are defined in the properties file.  Thus level settings for child
                  nodes in the tree should come after settings for their parents.
                  The property name &quot;.level&quot; can be used to set the level for the
                  root of the tree.
                  &lt;p&gt;
                  All methods on the LogManager object are multi-thread safe.                
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="manager" type="LogManager" line="150"/>
            <declaration name="emptyHandlers" type="Handler[]" line="152"/>
            <declaration name="props" type="Properties" line="153"/>
            <declaration name="changes" type="PropertyChangeSupport" line="154"/>
            <declaration name="defaultLevel" type="Level" line="156"/>
            <declaration name="namedLoggers" type="Hashtable&lt;String,LoggerWeakRef&gt;" line="159"/>
            <declaration name="root" type="LogNode" line="161"/>
            <declaration name="rootLogger" type="Logger" line="162"/>
            <declaration name="readPrimordialConfiguration" type="boolean" line="167"/>
            <declaration name="initializedGlobalHandlers" type="boolean" line="170"/>
            <declaration name="deathImminent" type="boolean" line="172"/>
            <scope line="174">
                <anonymous_class line="175">
                    <method name="run" type="Object" line="176">
                        <comment line="198">
                            Create and retain Logger for the root of the namespace.                            
                        </comment>
                        <comment line="202">
                            Adding the global Logger. Doing so in the Logger.&lt;clinit&gt;
                             would deadlock with the LogManager.&lt;clinit&gt;.                            
                        </comment>
                        <comment line="207">
                            We don&apos;t call readConfiguration() here, as we may be running
                             very early in the JVM startup sequence.  Instead readConfiguration
                             will be called lazily in getLogManager().                            
                        </comment>
                        <declaration name="cname" type="String" line="177"/>
                        <scope line="178">
                            <scope line="180">
                                <scope line="181">
                                    <declaration name="clz" type="Class" line="182"/>
                                </scope>
                                <scope line="184">
                                    <declaration name="clz" type="Class" line="185"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="189"/>
                        <scope line="193"/>
                    </method>
                </anonymous_class>
            </scope>
            <class name="Cleaner" line="217">
                <extends class="Thread"/>
                <comment line="471">
                    for namedLoggers cleanup                    
                </comment>
                <comment line="472">
                    for loggerRef cleanup                    
                </comment>
                <comment line="473">
                    for kids cleanup                    
                </comment>
                <comment line="481">
                    dispose of this LoggerWeakRef object                    
                </comment>
                <comment line="505">
                    set the node field to the specified value                    
                </comment>
                <comment line="510">
                    set the parentRef field to the specified value                    
                </comment>
                <comment line="1111">
                    Recursive method to walk the tree below a node and set
                     a new parent logger.                    
                </comment>
                <method name="Cleaner" type="constructor" line="219">
                    <comment line="221">
                        Set context class loader to null in order to avoid
                         keeping a strong reference to an application classloader.                        
                    </comment>
                </method>
                <method name="run" type="void" line="226">
                    <comment line="228">
                        This is to ensure the LogManager.&lt;clinit&gt; is completed
                         before synchronized block. Otherwise deadlocks are possible.                        
                    </comment>
                    <comment line="232">
                        If the global handlers haven&apos;t been initialized yet, we
                         don&apos;t want to initialize them just so we can close them!                        
                    </comment>
                    <comment line="235">
                        Note that death is imminent.                        
                    </comment>
                    <comment line="240">
                        Do a reset to close all active handlers.                        
                    </comment>
                    <declaration name="mgr" type="LogManager" line="229"/>
                    <scope line="233"/>
                </method>
            </class>
            <javadoc line="245">
                Protected constructor.  This is protected so that container applications
                  (such as J2EE containers) can subclass the object.  It is non-public as
                  it is intended that there only be one LogManager object, whose value is
                  retrieved by calling Logmanager.getLogManager.                
            </javadoc>
            <method name="LogManager" type="constructor" line="251">
                <comment line="253">
                    Add a shutdown hook to close the global handlers.                    
                </comment>
                <comment line="257">
                    If the VM is already shutting down,
                     We do not need to register shutdownHook.                    
                </comment>
                <scope line="253"/>
                <scope line="255"/>
            </method>
            <javadoc line="261">
                Return the global LogManager object.                
            </javadoc>
            <method name="getLogManager" type="LogManager" line="264">
                <scope line="265"/>
            </method>
            <method name="readPrimordialConfiguration" type="void" line="271">
                <comment line="276">
                    If System.in/out/err are null, it&apos;s a good
                     indication that we&apos;re still in the
                     bootstrapping phase                    
                </comment>
                <comment line="288">
                    Platform loggers begin to delegate to java.util.logging.Logger                    
                </comment>
                <comment line="295">
                    System.err.println(&quot;Can&apos;t read logging configuration:&quot;);
                     ex.printStackTrace();                    
                </comment>
                <scope line="272">
                    <scope line="273">
                        <scope line="274">
                            <scope line="278"/>
                            <scope line="282">
                                <anonymous_class line="283">
                                    <method name="run" type="Object" line="284">
                                        <comment line="288">
                                            Platform loggers begin to delegate to java.util.logging.Logger                                            
                                        </comment>
                                    </method>
                                </anonymous_class>
                            </scope>
                            <scope line="293"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="302">
                Adds an event listener to be invoked when the logging
                  properties are re-read. Adding multiple instances of
                  the same event Listener results in multiple entries
                  in the property event listener table.                
                <param>
                    l  event listener                    
                </param>
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission("control").                    
                </exception>
                <exception>
                    NullPointerException if the PropertyChangeListener is null.                    
                </exception>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="313">
                <params>
                    <param name="l" type="PropertyChangeListener"/>
                </params>
                <scope line="314"/>
            </method>
            <javadoc line="321">
                Removes an event listener for property change events.
                  If the same listener instance has been added to the listener table
                  through multiple invocations of &lt;CODE&gt;addPropertyChangeListener&lt;/CODE&gt;,
                  then an equivalent number of
                  &lt;CODE&gt;removePropertyChangeListener&lt;/CODE&gt; invocations are required to remove
                  all instances of that listener from the listener table.
                  &lt;P&gt;
                  Returns silently if the given listener is not found.                
                <param>
                    l  event listener (can be null)                    
                </param>
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission("control").                    
                </exception>
            </javadoc>
            <method name="removePropertyChangeListener" type="void" line="335">
                <params>
                    <param name="l" type="PropertyChangeListener"/>
                </params>
            </method>
            <method name="demandLogger" type="Logger" line="349">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="353">
                    only allocate the new logger once                    
                </comment>
                <comment line="357">
                    We successfully added the new Logger that we
                     created above so return it without refetching.                    
                </comment>
                <comment line="362">
                    We didn&apos;t add the new Logger that we created above
                     because another thread added a Logger with the same
                     name after our null check above and before our call
                     to addLogger(). We have to refetch the Logger because
                     addLogger() returns a boolean instead of the Logger
                     reference itself. However, if the thread that created
                     the other Logger is not holding a strong reference to
                     the other Logger, then it is possible for the other
                     Logger to be GC&apos;ed after we saw it in addLogger() and
                     before we can refetch it. If it has been GC&apos;ed then
                     we&apos;ll just loop around and try again.                    
                </comment>
                <declaration name="result" type="Logger" line="350"/>
                <scope line="351">
                    <declaration name="newLogger" type="Logger" line="353"/>
                    <scope line="354">
                        <scope line="355"/>
                    </scope>
                </scope>
            </method>
            <method name="processParentHandlers" type="void" line="380">
                <params>
                    <param name="logger" type="Logger"/>
                    <param name="name" type="String"/>
                </params>
                <comment line="392">
                    This pname has a level/handlers definition.
                     Make sure it exists.                    
                </comment>
                <declaration name="ix" type="int" line="381"/>
                <scope line="382">
                    <declaration name="ix2" type="int" line="383"/>
                    <scope line="384"/>
                    <declaration name="pname" type="String" line="387"/>
                    <scope line="390"/>
                </scope>
            </method>
            <method name="loadLoggerHandlers" type="void" line="404">
                <params>
                    <param name="logger" type="Logger"/>
                    <param name="name" type="String"/>
                    <param name="handlersPropertyName" type="String"/>
                </params>
                <comment line="422">
                    Check if there is a property defining the
                     this handler&apos;s level.                    
                </comment>
                <comment line="430">
                    Probably a bad level. Drop through.                    
                </comment>
                <comment line="432">
                    Add this Handler to the logger                    
                </comment>
                <anonymous_class line="405">
                    <method name="run" type="Object" line="406">
                        <comment line="422">
                            Check if there is a property defining the
                             this handler&apos;s level.                            
                        </comment>
                        <comment line="430">
                            Probably a bad level. Drop through.                            
                        </comment>
                        <comment line="432">
                            Add this Handler to the logger                            
                        </comment>
                        <scope line="407">
                            <declaration name="useParent" type="boolean" line="408"/>
                            <scope line="409"/>
                        </scope>
                        <declaration name="names" type="String" line="414"/>
                        <scope line="415">
                            <declaration name="word" type="String" line="416"/>
                            <scope line="417">
                                <declaration name="clz" type="Class" line="418"/>
                                <declaration name="hdl" type="Handler" line="419"/>
                                <scope line="420">
                                    <declaration name="levs" type="String" line="423"/>
                                    <scope line="424"/>
                                </scope>
                                <scope line="427"/>
                            </scope>
                            <scope line="433"/>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <declaration name="loggerRefQueue" type="ReferenceQueue&lt;Logger&gt;" line="446"/>
            <class name="LoggerWeakRef" line="469">
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="Logger"/>
                    </type_params>
                </extends>
                <comment line="471">
                    for namedLoggers cleanup                    
                </comment>
                <comment line="472">
                    for loggerRef cleanup                    
                </comment>
                <comment line="473">
                    for kids cleanup                    
                </comment>
                <comment line="481">
                    dispose of this LoggerWeakRef object                    
                </comment>
                <comment line="505">
                    set the node field to the specified value                    
                </comment>
                <comment line="510">
                    set the parentRef field to the specified value                    
                </comment>
                <comment line="1111">
                    Recursive method to walk the tree below a node and set
                     a new parent logger.                    
                </comment>
                <declaration name="name" type="String" line="470"/>
                <declaration name="node" type="LogNode" line="471"/>
                <declaration name="parentRef" type="WeakReference&lt;Logger&gt;" line="472"/>
                <method name="LoggerWeakRef" type="constructor" line="474">
                    <params>
                        <param name="logger" type="Logger"/>
                    </params>
                    <comment line="478">
                        save for namedLoggers cleanup                        
                    </comment>
                </method>
                <method name="dispose" type="void" line="481">
                    <comment line="484">
                        if we have a LogNode, then we were a named Logger
                         so clear namedLoggers weak ref to us                        
                    </comment>
                    <comment line="487">
                        clear our ref to the Logger&apos;s name                        
                    </comment>
                    <comment line="489">
                        clear LogNode&apos;s weak ref to us                        
                    </comment>
                    <comment line="490">
                        clear our ref to LogNode                        
                    </comment>
                    <comment line="494">
                        this LoggerWeakRef has or had a parent Logger                        
                    </comment>
                    <comment line="497">
                        the parent Logger is still there so clear the
                         parent Logger&apos;s weak ref to us                        
                    </comment>
                    <comment line="501">
                        clear our weak ref to the parent Logger                        
                    </comment>
                    <scope line="482"/>
                    <scope line="492">
                        <declaration name="parent" type="Logger" line="494"/>
                        <scope line="495"/>
                    </scope>
                </method>
                <method name="setNode" type="void" line="505">
                    <params>
                        <param name="node" type="LogNode"/>
                    </params>
                </method>
                <method name="setParentRef" type="void" line="510">
                    <params>
                        <param name="parentRef" type="WeakReference<Logger>"/>
                    </params>
                </method>
            </class>
            <declaration name="MAX_ITERATIONS" type="int" line="541"/>
            <method name="drainLoggerRefQueueBounded" type="void" line="542">
                <comment line="546">
                    haven&apos;t finished loading LogManager yet                    
                </comment>
                <comment line="554">
                    a Logger object has been GC&apos;ed so clean it up                    
                </comment>
                <scope line="543">
                    <scope line="544"/>
                    <declaration name="ref" type="LoggerWeakRef" line="549"/>
                    <scope line="550"/>
                </scope>
            </method>
            <javadoc line="558">
                Add a named logger.  This does nothing and returns false if a logger
                  with the same name is already registered.
                  &lt;p&gt;
                  The Logger factory methods call this method to register each
                  newly created Logger.
                  &lt;p&gt;
                  The application should retain its own reference to the Logger
                  object to avoid it being garbage collected.  The LogManager
                  may only retain a weak reference.                
                <param>
                    logger the new logger.                    
                </param>
                <return>
                    true if the argument logger was registered successfully,
                      false if a logger of that name already exists.                    
                </return>
                <exception>
                    NullPointerException if the logger name is null.                    
                </exception>
            </javadoc>
            <method name="addLogger" type="boolean" line="574">
                <params>
                    <param name="logger" type="Logger"/>
                </params>
                <comment line="581">
                    cleanup some Loggers that have been GC&apos;ed                    
                </comment>
                <comment line="587">
                    It&apos;s possible that the Logger was GC&apos;ed after the
                     drainLoggerRefQueueBounded() call above so allow
                     a new one to be registered.                    
                </comment>
                <comment line="592">
                    We already have a registered logger with the given name.                    
                </comment>
                <comment line="597">
                    We&apos;re adding a new logger.
                     Note that we are creating a weak reference here.                    
                </comment>
                <comment line="602">
                    Apply any initial level defined for the new logger.                    
                </comment>
                <comment line="608">
                    Do we have a per logger handler too?
                     Note: this will add a 200ms penalty                    
                </comment>
                <comment line="613">
                    Find the new node and its parent.                    
                </comment>
                <comment line="632">
                    Walk over the children and tell them we are their new parent.                    
                </comment>
                <comment line="635">
                    new LogNode is ready so tell the LoggerWeakRef about it                    
                </comment>
                <declaration name="name" type="String" line="575"/>
                <scope line="576"/>
                <declaration name="ref" type="LoggerWeakRef" line="583"/>
                <scope line="584">
                    <scope line="585"/>
                    <scope line="590"/>
                </scope>
                <declaration name="level" type="Level" line="602"/>
                <scope line="603"/>
                <declaration name="node" type="LogNode" line="613"/>
                <declaration name="parent" type="Logger" line="615"/>
                <declaration name="nodep" type="LogNode" line="616"/>
                <scope line="617">
                    <declaration name="nodeRef" type="LoggerWeakRef" line="618"/>
                    <scope line="619">
                        <scope line="621"/>
                    </scope>
                </scope>
                <scope line="628"/>
            </method>
            <method name="doSetLevel" type="void" line="643">
                <params>
                    <param name="logger" type="Logger"/>
                    <param name="level" type="Level"/>
                </params>
                <comment line="647">
                    There is no security manager, so things are easy.                    
                </comment>
                <comment line="651">
                    There is a security manager.  Raise privilege before
                     calling setLevel.                    
                </comment>
                <declaration name="sm" type="SecurityManager" line="644"/>
                <scope line="645"/>
                <anonymous_class line="652">
                    <method name="run" type="Object" line="653"/>
                </anonymous_class>
            </method>
            <method name="doSetParent" type="void" line="663">
                <params>
                    <param name="logger" type="Logger"/>
                    <param name="parent" type="Logger"/>
                </params>
                <comment line="667">
                    There is no security manager, so things are easy.                    
                </comment>
                <comment line="671">
                    There is a security manager.  Raise privilege before
                     calling setParent.                    
                </comment>
                <declaration name="sm" type="SecurityManager" line="664"/>
                <scope line="665"/>
                <anonymous_class line="672">
                    <method name="run" type="Object" line="673"/>
                </anonymous_class>
            </method>
            <method name="findNode" type="LogNode" line="681">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="682"/>
                <declaration name="node" type="LogNode" line="685"/>
                <scope line="686">
                    <declaration name="ix" type="int" line="687"/>
                    <declaration name="head" type="String" line="688"/>
                    <scope line="689"/>
                    <scope line="692"/>
                    <scope line="696"/>
                    <declaration name="child" type="LogNode" line="699"/>
                    <scope line="700"/>
                </scope>
            </method>
            <javadoc line="709">
                Method to find a named logger.
                  &lt;p&gt;
                  Note that since untrusted code may create loggers with
                  arbitrary names this method should not be relied on to
                  find Loggers for security sensitive logging.
                  It is also important to note that the Logger associated with the
                  String {@code name} may be garbage collected at any time if there
                  is no strong reference to the Logger. The caller of this method
                  must check the return value for null in order to properly handle
                  the case where the Logger has been garbage collected.
                  &lt;p&gt;                
                <param>
                    name name of the logger                    
                </param>
                <return>
                    matching logger or null if none is found                    
                </return>
            </javadoc>
            <method name="getLogger" type="Logger" line="724">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="732">
                    Hashtable holds stale weak reference
                     to a logger which has been GC-ed.                    
                </comment>
                <declaration name="ref" type="LoggerWeakRef" line="725"/>
                <scope line="726"/>
                <declaration name="logger" type="Logger" line="729"/>
                <scope line="730"/>
            </method>
            <javadoc line="738">
                Get an enumeration of known logger names.
                  &lt;p&gt;
                  Note:  Loggers may be added dynamically as new classes are loaded.
                  This method only reports on the loggers that are currently registered.
                  It is also important to note that this method only returns the name
                  of a Logger, not a strong reference to the Logger itself.
                  The returned String does nothing to prevent the Logger from being
                  garbage collected. In particular, if the returned name is passed
                  to {@code LogManager.getLogger()}, then the caller must check the
                  return value from {@code LogManager.getLogger()} for null to properly
                  handle the case where the Logger has been garbage collected in the
                  time since its name was returned by this method.
                  &lt;p&gt;                
                <return>
                    enumeration of logger name strings                    
                </return>
            </javadoc>
            <method name="getLoggerNames" type="Enumeration<String>" line="754"/>
            <javadoc line="758">
                Reinitialize the logging properties and reread the logging configuration.
                  &lt;p&gt;
                  The same rules are used for locating the configuration properties
                  as are used at startup.  So normally the logging properties will
                  be re-read from the same file that was used at startup.
                  &lt;P&gt;
                  Any log level definitions in the new configuration file will be
                  applied using Logger.setLevel(), if the target Logger exists.
                  &lt;p&gt;
                  A PropertyChangeEvent will be fired after the properties are read.                
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission("control").                    
                </exception>
                <exception>
                    IOException if there are IO problems reading the configuration.                    
                </exception>
            </javadoc>
            <method name="readConfiguration" type="void" line="774">
                <comment line="778">
                    if a configuration class is specified, load it and use it.                    
                </comment>
                <comment line="782">
                    Instantiate the named class.  It is its constructor&apos;s
                     responsibility to initialize the logging configuration, by
                     calling readConfiguration(InputStream) with a suitable stream.                    
                </comment>
                <comment line="797">
                    keep going and useful config file.                    
                </comment>
                <declaration name="cname" type="String" line="778"/>
                <scope line="779">
                    <scope line="780">
                        <scope line="784">
                            <declaration name="clz" type="Class" line="785"/>
                        </scope>
                        <scope line="788">
                            <declaration name="clz" type="Class" line="789"/>
                        </scope>
                    </scope>
                    <scope line="793"/>
                </scope>
                <declaration name="fname" type="String" line="800"/>
                <scope line="801">
                    <scope line="803"/>
                    <declaration name="f" type="File" line="806"/>
                </scope>
                <declaration name="in" type="InputStream" line="810"/>
                <declaration name="bin" type="BufferedInputStream" line="811"/>
                <scope line="812"/>
                <scope line="814">
                    <scope line="815"/>
                </scope>
            </method>
            <javadoc line="821">
                Reset the logging configuration.
                  &lt;p&gt;
                  For all named loggers, the reset operation removes and closes
                  all Handlers and (except for the root logger) sets the level
                  to null.  The root logger&apos;s level is set to Level.INFO.                
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission("control").                    
                </exception>
            </javadoc>
            <method name="reset" type="void" line="832">
                <comment line="837">
                    Since we are doing a reset we no longer want to initialize
                     the global handlers, if they haven&apos;t been initialized yet.                    
                </comment>
                <scope line="834"/>
                <declaration name="enum_" type="Enumeration" line="840"/>
                <scope line="841">
                    <declaration name="name" type="String" line="842"/>
                </scope>
            </method>
            <method name="resetLogger" type="void" line="849">
                <params>
                    <param name="name" type="String"/>
                </params>
                <comment line="855">
                    Close all the Logger&apos;s handlers.                    
                </comment>
                <comment line="863">
                    Problems closing a handler?  Keep going...                    
                </comment>
                <comment line="867">
                    This is the root logger.                    
                </comment>
                <declaration name="logger" type="Logger" line="850"/>
                <scope line="851"/>
                <declaration name="targets" type="Handler[]" line="855"/>
                <scope line="856">
                    <declaration name="h" type="Handler" line="857"/>
                    <scope line="859"/>
                    <scope line="861"/>
                </scope>
                <scope line="865"/>
                <scope line="868"/>
            </method>
            <method name="parseClassNames" type="String[]" line="874">
                <params>
                    <param name="propertyName" type="String"/>
                </params>
                <declaration name="hands" type="String" line="875"/>
                <scope line="876"/>
                <declaration name="ix" type="int" line="880"/>
                <declaration name="result" type="Vector&lt;String&gt;" line="881"/>
                <scope line="882">
                    <declaration name="end" type="int" line="883"/>
                    <scope line="884">
                        <scope line="885"/>
                        <scope line="888"/>
                    </scope>
                    <declaration name="word" type="String" line="893"/>
                    <scope line="896"/>
                </scope>
            </method>
            <javadoc line="904">
                Reinitialize the logging properties and reread the logging configuration
                  from the given stream, which should be in java.util.Properties format.
                  A PropertyChangeEvent will be fired after the properties are read.
                  &lt;p&gt;
                  Any log level definitions in the new configuration file will be
                  applied using Logger.setLevel(), if the target Logger exists.                
                <param>
                    ins       stream to read properties from                    
                </param>
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission("control").                    
                </exception>
                <exception>
                    IOException if there are problems reading from the stream.                    
                </exception>
            </javadoc>
            <method name="readConfiguration" type="void" line="917">
                <params>
                    <param name="ins" type="InputStream"/>
                </params>
                <comment line="922">
                    Load the properties                    
                </comment>
                <comment line="924">
                    Instantiate new configuration objects.                    
                </comment>
                <comment line="935">
                    ex.printStackTrace();                    
                </comment>
                <comment line="939">
                    Set levels on any pre-existing loggers, based on the new properties.                    
                </comment>
                <comment line="942">
                    Notify any interested parties that our properties have changed.                    
                </comment>
                <comment line="945">
                    Note that we need to reinitialize global handles when
                     they are first referenced.                    
                </comment>
                <declaration name="names" type="String" line="924"/>
                <scope line="926">
                    <declaration name="word" type="String" line="927"/>
                    <scope line="928">
                        <declaration name="clz" type="Class" line="929"/>
                    </scope>
                    <scope line="931"/>
                </scope>
                <scope line="946"/>
            </method>
            <javadoc line="951">
                Get the value of a logging property.
                  The method returns null if the property is not found.                
                <param>
                    name      property name                    
                </param>
                <return>
                    property value                    
                </return>
            </javadoc>
            <method name="getProperty" type="String" line="957">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="getStringProperty" type="String" line="964">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="String"/>
                </params>
                <declaration name="val" type="String" line="965"/>
                <scope line="966"/>
            </method>
            <method name="getIntProperty" type="int" line="975">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="int"/>
                </params>
                <declaration name="val" type="String" line="976"/>
                <scope line="977"/>
                <scope line="980"/>
                <scope line="982"/>
            </method>
            <method name="getBooleanProperty" type="boolean" line="990">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="boolean"/>
                </params>
                <declaration name="val" type="String" line="991"/>
                <scope line="992"/>
                <scope line="996"/>
                <scope line="998"/>
            </method>
            <method name="getLevelProperty" type="Level" line="1007">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="Level"/>
                </params>
                <declaration name="val" type="String" line="1008"/>
                <scope line="1009"/>
                <scope line="1012"/>
                <scope line="1014"/>
            </method>
            <method name="getFilterProperty" type="Filter" line="1023">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="Filter"/>
                </params>
                <comment line="1032">
                    We got one of a variety of exceptions in creating the
                     class or creating an instance.
                     Drop through.                    
                </comment>
                <comment line="1036">
                    We got an exception.  Return the defaultValue.                    
                </comment>
                <declaration name="val" type="String" line="1024"/>
                <scope line="1025">
                    <scope line="1026">
                        <declaration name="clz" type="Class" line="1027"/>
                    </scope>
                </scope>
                <scope line="1030"/>
            </method>
            <method name="getFormatterProperty" type="Formatter" line="1044">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="Formatter"/>
                </params>
                <comment line="1053">
                    We got one of a variety of exceptions in creating the
                     class or creating an instance.
                     Drop through.                    
                </comment>
                <comment line="1057">
                    We got an exception.  Return the defaultValue.                    
                </comment>
                <declaration name="val" type="String" line="1045"/>
                <scope line="1046">
                    <scope line="1047">
                        <declaration name="clz" type="Class" line="1048"/>
                    </scope>
                </scope>
                <scope line="1051"/>
            </method>
            <method name="initializeGlobalHandlers" type="void" line="1063">
                <comment line="1072">
                    Aaargh...
                     The VM is shutting down and our exit hook has been called.
                     Avoid allocating global handlers.                    
                </comment>
                <scope line="1064"/>
                <scope line="1070"/>
            </method>
            <declaration name="ourPermission" type="Permission" line="1080"/>
            <javadoc line="1082">
                Check that the current context is trusted to modify the logging
                  configuration.  This requires LoggingPermission(&quot;control&quot;).
                  &lt;p&gt;
                  If the check fails we throw a SecurityException, otherwise
                  we return normally.                
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission("control").                    
                </exception>
            </javadoc>
            <method name="checkAccess" type="void" line="1092">
                <declaration name="sm" type="SecurityManager" line="1093"/>
                <scope line="1094"/>
            </method>
            <class name="LogNode" line="1101">
                <comment line="471">
                    for namedLoggers cleanup                    
                </comment>
                <comment line="472">
                    for loggerRef cleanup                    
                </comment>
                <comment line="473">
                    for kids cleanup                    
                </comment>
                <comment line="481">
                    dispose of this LoggerWeakRef object                    
                </comment>
                <comment line="505">
                    set the node field to the specified value                    
                </comment>
                <comment line="510">
                    set the parentRef field to the specified value                    
                </comment>
                <comment line="1111">
                    Recursive method to walk the tree below a node and set
                     a new parent logger.                    
                </comment>
                <declaration name="children" type="HashMap&lt;String,LogNode&gt;" line="1102"/>
                <declaration name="loggerRef" type="LoggerWeakRef" line="1103"/>
                <declaration name="parent" type="LogNode" line="1104"/>
                <method name="LogNode" type="constructor" line="1106">
                    <params>
                        <param name="parent" type="LogNode"/>
                    </params>
                </method>
                <method name="walkAndSetParent" type="void" line="1112">
                    <params>
                        <param name="parent" type="Logger"/>
                    </params>
                    <scope line="1113"/>
                    <declaration name="values" type="Iterator&lt;LogNode&gt;" line="1116"/>
                    <scope line="1117">
                        <declaration name="node" type="LogNode" line="1118"/>
                        <declaration name="ref" type="LoggerWeakRef" line="1119"/>
                        <declaration name="logger" type="Logger" line="1120"/>
                        <scope line="1121"/>
                        <scope line="1123"/>
                    </scope>
                </method>
            </class>
            <class name="RootLogger" line="1133">
                <extends class="Logger"/>
                <comment line="471">
                    for namedLoggers cleanup                    
                </comment>
                <comment line="472">
                    for loggerRef cleanup                    
                </comment>
                <comment line="473">
                    for kids cleanup                    
                </comment>
                <comment line="481">
                    dispose of this LoggerWeakRef object                    
                </comment>
                <comment line="505">
                    set the node field to the specified value                    
                </comment>
                <comment line="510">
                    set the parentRef field to the specified value                    
                </comment>
                <comment line="1111">
                    Recursive method to walk the tree below a node and set
                     a new parent logger.                    
                </comment>
                <method name="RootLogger" type="constructor" line="1135"/>
                <method name="log" type="void" line="1140">
                    <params>
                        <param name="record" type="LogRecord"/>
                    </params>
                    <comment line="1142">
                        Make sure that the global handlers have been instantiated.                        
                    </comment>
                </method>
                <method name="addHandler" type="void" line="1146">
                    <params>
                        <param name="h" type="Handler"/>
                    </params>
                </method>
                <method name="removeHandler" type="void" line="1151">
                    <params>
                        <param name="h" type="Handler"/>
                    </params>
                </method>
                <method name="getHandlers" type="Handler[]" line="1156"/>
            </class>
            <method name="setLevelsOnExistingLoggers" type="void" line="1165">
                <comment line="1171">
                    Not a level definition.                    
                </comment>
                <declaration name="enum_" type="Enumeration" line="1166"/>
                <scope line="1167">
                    <declaration name="key" type="String" line="1168"/>
                    <scope line="1169"/>
                    <declaration name="ix" type="int" line="1173"/>
                    <declaration name="name" type="String" line="1174"/>
                    <declaration name="level" type="Level" line="1175"/>
                    <scope line="1176"/>
                    <declaration name="l" type="Logger" line="1180"/>
                    <scope line="1181"/>
                </scope>
            </method>
            <declaration name="loggingMXBean" type="LoggingMXBean" line="1189"/>
            <declaration name="LOGGING_MXBEAN_NAME" type="String" line="1190"/>
            <javadoc line="1190">
                String representation of the{@link javax.management.ObjectName} for the management interface
                  for the logging facility.                
                <see>
                    java.lang.management.PlatformLoggingMXBean                    
                </see>
                <see>
                    java.util.logging.LoggingMXBean                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <javadoc line="1203">
                Returns &lt;tt&gt;LoggingMXBean&lt;/tt&gt; for managing loggers.
                  An alternative way to manage loggers is through the{@link java.lang.management.PlatformLoggingMXBean} interface
                  that can be obtained by calling:
                  &lt;pre&gt;
                  PlatformLoggingMXBean logging = {@link java.lang.management.ManagementFactory#getPlatformMXBean(Class)ManagementFactory.getPlatformMXBean}(PlatformLoggingMXBean.class);
                  &lt;/pre&gt;                
                <return>
                    a {@link LoggingMXBean} object.                    
                </return>
                <see>
                    java.lang.management.PlatformLoggingMXBean                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getLoggingMXBean" type="LoggingMXBean" line="1218">
                <scope line="1219"/>
            </method>
        </class>
    </source>