<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.logging">
        <import package="java.io"/>
        <import package="java.util"/>
        <import package="java.security"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.beans.PropertyChangeSupport"/>
        <import package="java.net.URL"/>
        <import package="sun.security.action.GetPropertyAction"/>
        <class name="LogManager" line="11">
            <javadoc line="11">
                There is a single global LogManager object that is used to
                  maintain a set of shared state about Loggers and log services.
                  &lt;p&gt;
                  This LogManager object:
                  &lt;ul&gt;
                  &lt;li&gt; Manages a hierarchical namespace of Logger objects.  All
                  named Loggers are stored in this namespace.
                  &lt;li&gt; Manages a set of logging control properties.  These are
                  simple key-value pairs that can be used by Handlers and
                  other logging objects to configure themselves.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  The global LogManager object can be retrieved using LogManager.getLogManager().
                  The LogManager object is created during class initialization and
                  cannot subsequently be changed.
                  &lt;p&gt;
                  At startup the LogManager class is located using the
                  java.util.logging.manager system property.
                  &lt;p&gt;
                  By default, the LogManager reads its initial configuration from
                  a properties file &quot;lib/logging.properties&quot; in the JRE directory.
                  If you edit that property file you can change the default logging
                  configuration for all uses of that JRE.
                  &lt;p&gt;
                  In addition, the LogManager uses two optional system properties that
                  allow more control over reading the initial configuration:
                  &lt;ul&gt;
                  &lt;li&gt;&quot;java.util.logging.config.class&quot;
                  &lt;li&gt;&quot;java.util.logging.config.file&quot;
                  &lt;/ul&gt;
                  These two properties may be set via the Preferences API, or as
                  command line property definitions to the &quot;java&quot; command, or as
                  system property definitions passed to JNI_CreateJavaVM.
                  &lt;p&gt;
                  If the &quot;java.util.logging.config.class&quot; property is set, then the
                  property value is treated as a class name.  The given class will be
                  loaded, an object will be instantiated, and that object&apos;s constructor
                  is responsible for reading in the initial configuration.  (That object
                  may use other system properties to control its configuration.)  The
                  alternate configuration class can use &lt;tt&gt;readConfiguration(InputStream)&lt;/tt&gt;
                  to define properties in the LogManager.
                  &lt;p&gt;
                  If &quot;java.util.logging.config.class&quot; property is &lt;b&gt;not&lt;/b&gt; set,
                  then the &quot;java.util.logging.config.file&quot; system property can be used
                  to specify a properties file (in java.util.Properties format). The
                  initial logging configuration will be read from this file.
                  &lt;p&gt;
                  If neither of these properties is defined then, as described
                  above, the LogManager will read its initial configuration from
                  a properties file &quot;lib/logging.properties&quot; in the JRE directory.
                  &lt;p&gt;
                  The properties for loggers and Handlers will have names starting
                  with the dot-separated name for the handler or logger.
                  &lt;p&gt;
                  The global logging properties may include:
                  &lt;ul&gt;
                  &lt;li&gt;A property &quot;handlers&quot;.  This defines a whitespace or comma separated
                  list of class names for handler classes to load and register as
                  handlers on the root Logger (the Logger named &quot;&quot;).  Each class
                  name must be for a Handler class which has a default constructor.
                  Note that these Handlers may be created lazily, when they are
                  first used.
                  &lt;li&gt;A property &quot;&amp;lt;logger&amp;gt;.handlers&quot;. This defines a whitespace or
                  comma separated list of class names for handlers classes to
                  load and register as handlers to the specified logger. Each class
                  name must be for a Handler class which has a default constructor.
                  Note that these Handlers may be created lazily, when they are
                  first used.
                  &lt;li&gt;A property &quot;&amp;lt;logger&amp;gt;.useParentHandlers&quot;. This defines a boolean
                  value. By default every logger calls its parent in addition to
                  handling the logging message itself, this often result in messages
                  being handled by the root logger as well. When setting this property
                  to false a Handler needs to be configured for this logger otherwise
                  no logging messages are delivered.
                  &lt;li&gt;A property &quot;config&quot;.  This property is intended to allow
                  arbitrary configuration code to be run.  The property defines a
                  whitespace or comma separated list of class names.  A new instance will be
                  created for each named class.  The default constructor of each class
                  may execute arbitrary code to update the logging configuration, such as
                  setting logger levels, adding handlers, adding filters, etc.
                  &lt;/ul&gt;
                  &lt;p&gt;
                  Note that all classes loaded during LogManager configuration are
                  first searched on the system class path before any user class path.
                  That includes the LogManager class, any config classes, and any
                  handler classes.
                  &lt;p&gt;
                  Loggers are organized into a naming hierarchy based on their
                  dot separated names.  Thus &quot;a.b.c&quot; is a child of &quot;a.b&quot;, but
                  &quot;a.b1&quot; and a.b2&quot; are peers.
                  &lt;p&gt;
                  All properties whose names end with &quot;.level&quot; are assumed to define
                  log levels for Loggers.  Thus &quot;foo.level&quot; defines a log level for
                  the logger called &quot;foo&quot; and (recursively) for any of its children
                  in the naming hierarchy.  Log Levels are applied in the order they
                  are defined in the properties file.  Thus level settings for child
                  nodes in the tree should come after settings for their parents.
                  The property name &quot;.level&quot; can be used to set the level for the
                  root of the tree.
                  &lt;p&gt;
                  All methods on the LogManager object are multi-thread safe.                
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="manager" type="LogManager" line="116"/>
            <declaration name="emptyHandlers" type="Handler[]" line="117"/>
            <declaration name="props" type="Properties" line="118"/>
            <declaration name="changes" type="PropertyChangeSupport" line="119"/>
            <declaration name="defaultLevel" type="Level" line="120"/>
            <declaration name="namedLoggers" type="Hashtable&amp;lt;String,LoggerWeakRef&amp;gt;" line="121"/>
            <declaration name="root" type="LogNode" line="122"/>
            <declaration name="rootLogger" type="Logger" line="123"/>
            <declaration name="readPrimordialConfiguration" type="boolean" line="124"/>
            <declaration name="initializedGlobalHandlers" type="boolean" line="125"/>
            <declaration name="deathImminent" type="boolean" line="126"/>
            <scope line="127">
                <anonymous_class line="128">
                    <method name="run" type="Object" line="129">
                        <declaration name="cname" type="String" line="130"/>
                        <scope line="131">
                            <scope line="133">
                                <scope line="134">
                                    <declaration name="clz" type="Class" line="135"/>
                                </scope>
                                <scope line="138">
                                    <declaration name="clz" type="Class" line="139"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="144"/>
                        <scope line="148"/>
                    </method>
                </anonymous_class>
            </scope>
            <class name="Cleaner" line="160">
                <extends class="Thread"/>
                <method name="Cleaner" type="constructor" line="161"/>
                <method name="run" type="void" line="164">
                    <declaration name="mgr" type="LogManager" line="165"/>
                    <scope line="166"/>
                </method>
            </class>
            <javadoc line="173">
                Protected constructor.  This is protected so that container applications
                  (such as J2EE containers) can subclass the object.  It is non-public as
                  it is intended that there only be one LogManager object, whose value is
                  retrieved by calling Logmanager.getLogManager.                
            </javadoc>
            <method name="LogManager" type="constructor" line="179">
                <scope line="180"/>
                <scope line="183"/>
            </method>
            <javadoc line="186">
                Return the global LogManager object.                
            </javadoc>
            <method name="getLogManager" type="LogManager" line="189">
                <scope line="190"/>
            </method>
            <method name="readPrimordialConfiguration" type="void" line="195">
                <scope line="196">
                    <scope line="197">
                        <scope line="198">
                            <scope line="199"/>
                            <scope line="203">
                                <anonymous_class line="204">
                                    <method name="run" type="Object" line="205"/>
                                </anonymous_class>
                            </scope>
                            <scope line="213"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="219">
                Adds an event listener to be invoked when the logging
                  properties are re-read. Adding multiple instances of
                  the same event Listener results in multiple entries
                  in the property event listener table.                
                <param>
                    l  event listener                    
                </param>
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission(&quot;control&quot;).                    
                </exception>
                <exception>
                    NullPointerException if the PropertyChangeListener is null.                    
                </exception>
            </javadoc>
            <method name="addPropertyChangeListener" type="void" line="229">
                <params>
                    <param name="l" type="PropertyChangeListener"/>
                </params>
                <scope line="230"/>
            </method>
            <javadoc line="236">
                Removes an event listener for property change events.
                  If the same listener instance has been added to the listener table
                  through multiple invocations of &lt;CODE&gt;addPropertyChangeListener&lt;/CODE&gt;,
                  then an equivalent number of
                  &lt;CODE&gt;removePropertyChangeListener&lt;/CODE&gt; invocations are required to remove
                  all instances of that listener from the listener table.
                  &lt;P&gt;
                  Returns silently if the given listener is not found.                
                <param>
                    l  event listener (can be null)                    
                </param>
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission(&quot;control&quot;).                    
                </exception>
            </javadoc>
            <method name="removePropertyChangeListener" type="void" line="249">
                <params>
                    <param name="l" type="PropertyChangeListener"/>
                </params>
            </method>
            <method name="demandLogger" type="Logger" line="253">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="result" type="Logger" line="254"/>
                <scope line="255">
                    <declaration name="newLogger" type="Logger" line="256"/>
                    <scope line="257">
                        <scope line="258"/>
                    </scope>
                </scope>
            </method>
            <method name="processParentHandlers" type="void" line="267">
                <params>
                    <param name="logger" type="Logger"/>
                    <param name="name" type="String"/>
                </params>
                <declaration name="ix" type="int" line="268"/>
                <scope line="269">
                    <declaration name="ix2" type="int" line="270"/>
                    <scope line="271"/>
                    <declaration name="pname" type="String" line="274"/>
                    <scope line="275"/>
                </scope>
            </method>
            <method name="loadLoggerHandlers" type="void" line="281">
                <params>
                    <param name="logger" type="Logger"/>
                    <param name="name" type="String"/>
                    <param name="handlersPropertyName" type="String"/>
                </params>
                <anonymous_class line="282">
                    <method name="run" type="Object" line="283">
                        <scope line="284">
                            <declaration name="useParent" type="boolean" line="285"/>
                            <scope line="286"/>
                        </scope>
                        <declaration name="names" type="String" line="290"/>
                        <scope line="291">
                            <declaration name="word" type="String" line="292"/>
                            <scope line="293">
                                <declaration name="clz" type="Class" line="294"/>
                                <declaration name="hdl" type="Handler" line="295"/>
                                <scope line="296">
                                    <declaration name="levs" type="String" line="297"/>
                                    <scope line="298"/>
                                </scope>
                                <scope line="302"/>
                            </scope>
                            <scope line="307"/>
                        </scope>
                    </method>
                </anonymous_class>
            </method>
            <declaration name="loggerRefQueue" type="ReferenceQueue&amp;lt;Logger&amp;gt;" line="318"/>
            <class name="LoggerWeakRef" line="319">
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="Logger"/>
                    </type_params>
                </extends>
                <declaration name="name" type="String" line="320"/>
                <declaration name="node" type="LogNode" line="321"/>
                <declaration name="parentRef" type="WeakReference&amp;lt;Logger&amp;gt;" line="322"/>
                <method name="LoggerWeakRef" type="constructor" line="323">
                    <params>
                        <param name="logger" type="Logger"/>
                    </params>
                </method>
                <method name="dispose" type="void" line="327">
                    <scope line="328"/>
                    <scope line="334">
                        <declaration name="parent" type="Logger" line="335"/>
                        <scope line="336"/>
                    </scope>
                </method>
                <method name="setNode" type="void" line="342">
                    <params>
                        <param name="node" type="LogNode"/>
                    </params>
                </method>
                <method name="setParentRef" type="void" line="345">
                    <params>
                        <param name="parentRef" type="WeakReference&lt;Logger&gt;"/>
                    </params>
                </method>
            </class>
            <declaration name="MAX_ITERATIONS" type="int" line="349"/>
            <method name="drainLoggerRefQueueBounded" type="void" line="350">
                <scope line="351">
                    <scope line="352"/>
                    <declaration name="ref" type="LoggerWeakRef" line="355"/>
                    <scope line="356"/>
                </scope>
            </method>
            <javadoc line="362">
                Add a named logger.  This does nothing and returns false if a logger
                  with the same name is already registered.
                  &lt;p&gt;
                  The Logger factory methods call this method to register each
                  newly created Logger.
                  &lt;p&gt;
                  The application should retain its own reference to the Logger
                  object to avoid it being garbage collected.  The LogManager
                  may only retain a weak reference.                
                <param>
                    logger the new logger.                    
                </param>
                <return>
                    true if the argument logger was registered successfully,
                      false if a logger of that name already exists.                    
                </return>
                <exception>
                    NullPointerException if the logger name is null.                    
                </exception>
            </javadoc>
            <method name="addLogger" type="boolean" line="377">
                <params>
                    <param name="logger" type="Logger"/>
                </params>
                <declaration name="name" type="String" line="378"/>
                <scope line="379"/>
                <declaration name="ref" type="LoggerWeakRef" line="383"/>
                <scope line="384">
                    <scope line="385"/>
                    <scope line="388"/>
                </scope>
                <declaration name="level" type="Level" line="394"/>
                <scope line="395"/>
                <declaration name="node" type="LogNode" line="400"/>
                <declaration name="parent" type="Logger" line="402"/>
                <declaration name="nodep" type="LogNode" line="403"/>
                <scope line="404">
                    <declaration name="nodeRef" type="LoggerWeakRef" line="405"/>
                    <scope line="406">
                        <scope line="408"/>
                    </scope>
                </scope>
                <scope line="414"/>
            </method>
            <method name="doSetLevel" type="void" line="421">
                <params>
                    <param name="logger" type="Logger"/>
                    <param name="level" type="Level"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="422"/>
                <scope line="423"/>
                <anonymous_class line="427">
                    <method name="run" type="Object" line="428"/>
                </anonymous_class>
            </method>
            <method name="doSetParent" type="void" line="435">
                <params>
                    <param name="logger" type="Logger"/>
                    <param name="parent" type="Logger"/>
                </params>
                <declaration name="sm" type="SecurityManager" line="436"/>
                <scope line="437"/>
                <anonymous_class line="441">
                    <method name="run" type="Object" line="442"/>
                </anonymous_class>
            </method>
            <method name="findNode" type="LogNode" line="449">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="450"/>
                <declaration name="node" type="LogNode" line="453"/>
                <scope line="454">
                    <declaration name="ix" type="int" line="455"/>
                    <declaration name="head" type="String" line="456"/>
                    <scope line="457"/>
                    <scope line="461"/>
                    <scope line="465"/>
                    <declaration name="child" type="LogNode" line="468"/>
                    <scope line="469"/>
                </scope>
            </method>
            <javadoc line="477">
                Method to find a named logger.
                  &lt;p&gt;
                  Note that since untrusted code may create loggers with
                  arbitrary names this method should not be relied on to
                  find Loggers for security sensitive logging.
                  It is also important to note that the Logger associated with the
                  String {@code name} may be garbage collected at any time if there
                  is no strong reference to the Logger. The caller of this method
                  must check the return value for null in order to properly handle
                  the case where the Logger has been garbage collected.
                  &lt;p&gt;                
                <param>
                    name name of the logger                    
                </param>
                <return>
                    matching logger or null if none is found                    
                </return>
            </javadoc>
            <method name="getLogger" type="Logger" line="492">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="ref" type="LoggerWeakRef" line="493"/>
                <scope line="494"/>
                <declaration name="logger" type="Logger" line="497"/>
                <scope line="498"/>
            </method>
            <javadoc line="503">
                Get an enumeration of known logger names.
                  &lt;p&gt;
                  Note:  Loggers may be added dynamically as new classes are loaded.
                  This method only reports on the loggers that are currently registered.
                  It is also important to note that this method only returns the name
                  of a Logger, not a strong reference to the Logger itself.
                  The returned String does nothing to prevent the Logger from being
                  garbage collected. In particular, if the returned name is passed
                  to {@code LogManager.getLogger()}, then the caller must check the
                  return value from {@code LogManager.getLogger()} for null to properly
                  handle the case where the Logger has been garbage collected in the
                  time since its name was returned by this method.
                  &lt;p&gt;                
                <return>
                    enumeration of logger name strings                    
                </return>
            </javadoc>
            <method name="getLoggerNames" type="Enumeration&lt;String&gt;" line="519"/>
            <javadoc line="522">
                Reinitialize the logging properties and reread the logging configuration.
                  &lt;p&gt;
                  The same rules are used for locating the configuration properties
                  as are used at startup.  So normally the logging properties will
                  be re-read from the same file that was used at startup.
                  &lt;P&gt;
                  Any log level definitions in the new configuration file will be
                  applied using Logger.setLevel(), if the target Logger exists.
                  &lt;p&gt;
                  A PropertyChangeEvent will be fired after the properties are read.                
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission(&quot;control&quot;).                    
                </exception>
                <exception>
                    IOException if there are IO problems reading the configuration.                    
                </exception>
            </javadoc>
            <method name="readConfiguration" type="void" line="537">
                <declaration name="cname" type="String" line="539"/>
                <scope line="540">
                    <scope line="541">
                        <scope line="542">
                            <declaration name="clz" type="Class" line="543"/>
                        </scope>
                        <scope line="547">
                            <declaration name="clz" type="Class" line="548"/>
                        </scope>
                    </scope>
                    <scope line="553"/>
                </scope>
                <declaration name="fname" type="String" line="558"/>
                <scope line="559">
                    <scope line="561"/>
                    <declaration name="f" type="File" line="564"/>
                </scope>
                <declaration name="in" type="InputStream" line="568"/>
                <declaration name="bin" type="BufferedInputStream" line="569"/>
                <scope line="570"/>
                <scope line="573">
                    <scope line="574"/>
                </scope>
            </method>
            <javadoc line="579">
                Reset the logging configuration.
                  &lt;p&gt;
                  For all named loggers, the reset operation removes and closes
                  all Handlers and (except for the root logger) sets the level
                  to null.  The root logger&apos;s level is set to Level.INFO.                
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission(&quot;control&quot;).                    
                </exception>
            </javadoc>
            <method name="reset" type="void" line="588">
                <scope line="590"/>
                <declaration name="enum_" type="Enumeration" line="594"/>
                <scope line="595">
                    <declaration name="name" type="String" line="596"/>
                </scope>
            </method>
            <method name="resetLogger" type="void" line="600">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="logger" type="Logger" line="601"/>
                <scope line="602"/>
                <declaration name="targets" type="Handler[]" line="605"/>
                <scope line="606">
                    <declaration name="h" type="Handler" line="607"/>
                    <scope line="609"/>
                    <scope line="612"/>
                </scope>
                <scope line="615"/>
                <scope line="618"/>
            </method>
            <method name="parseClassNames" type="String[]" line="622">
                <params>
                    <param name="propertyName" type="String"/>
                </params>
                <declaration name="hands" type="String" line="623"/>
                <scope line="624"/>
                <declaration name="ix" type="int" line="628"/>
                <declaration name="result" type="Vector&amp;lt;String&amp;gt;" line="629"/>
                <scope line="630">
                    <declaration name="end" type="int" line="631"/>
                    <scope line="632">
                        <scope line="633"/>
                        <scope line="636"/>
                    </scope>
                    <declaration name="word" type="String" line="641"/>
                    <scope line="644"/>
                </scope>
            </method>
            <javadoc line="651">
                Reinitialize the logging properties and reread the logging configuration
                  from the given stream, which should be in java.util.Properties format.
                  A PropertyChangeEvent will be fired after the properties are read.
                  &lt;p&gt;
                  Any log level definitions in the new configuration file will be
                  applied using Logger.setLevel(), if the target Logger exists.                
                <param>
                    ins       stream to read properties from                    
                </param>
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission(&quot;control&quot;).                    
                </exception>
                <exception>
                    IOException if there are problems reading from the stream.                    
                </exception>
            </javadoc>
            <method name="readConfiguration" type="void" line="663">
                <params>
                    <param name="ins" type="InputStream"/>
                </params>
                <declaration name="names" type="String" line="667"/>
                <scope line="668">
                    <declaration name="word" type="String" line="669"/>
                    <scope line="670">
                        <declaration name="clz" type="Class" line="671"/>
                    </scope>
                    <scope line="674"/>
                </scope>
                <scope line="681"/>
            </method>
            <javadoc line="685">
                Get the value of a logging property.
                  The method returns null if the property is not found.                
                <param>
                    name      property name                    
                </param>
                <return>
                    property value                    
                </return>
            </javadoc>
            <method name="getProperty" type="String" line="691">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="getStringProperty" type="String" line="694">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="String"/>
                </params>
                <declaration name="val" type="String" line="695"/>
                <scope line="696"/>
            </method>
            <method name="getIntProperty" type="int" line="701">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="int"/>
                </params>
                <declaration name="val" type="String" line="702"/>
                <scope line="703"/>
                <scope line="706"/>
                <scope line="709"/>
            </method>
            <method name="getBooleanProperty" type="boolean" line="713">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="boolean"/>
                </params>
                <declaration name="val" type="String" line="714"/>
                <scope line="715"/>
                <scope line="719"/>
                <scope line="722"/>
            </method>
            <method name="getLevelProperty" type="Level" line="727">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="Level"/>
                </params>
                <declaration name="val" type="String" line="728"/>
                <scope line="729"/>
                <scope line="732"/>
                <scope line="735"/>
            </method>
            <method name="getFilterProperty" type="Filter" line="739">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="Filter"/>
                </params>
                <declaration name="val" type="String" line="740"/>
                <scope line="741">
                    <scope line="742">
                        <declaration name="clz" type="Class" line="743"/>
                    </scope>
                </scope>
                <scope line="747"/>
            </method>
            <method name="getFormatterProperty" type="Formatter" line="751">
                <params>
                    <param name="name" type="String"/>
                    <param name="defaultValue" type="Formatter"/>
                </params>
                <declaration name="val" type="String" line="752"/>
                <scope line="753">
                    <scope line="754">
                        <declaration name="clz" type="Class" line="755"/>
                    </scope>
                </scope>
                <scope line="759"/>
            </method>
            <method name="initializeGlobalHandlers" type="void" line="763">
                <scope line="764"/>
                <scope line="768"/>
            </method>
            <declaration name="ourPermission" type="Permission" line="773"/>
            <javadoc line="774">
                Check that the current context is trusted to modify the logging
                  configuration.  This requires LoggingPermission(&quot;control&quot;).
                  &lt;p&gt;
                  If the check fails we throw a SecurityException, otherwise
                  we return normally.                
                <exception>
                    SecurityException  if a security manager exists and if
                      the caller does not have LoggingPermission(&quot;control&quot;).                    
                </exception>
            </javadoc>
            <method name="checkAccess" type="void" line="783">
                <declaration name="sm" type="SecurityManager" line="784"/>
                <scope line="785"/>
            </method>
            <class name="LogNode" line="790">
                <declaration name="children" type="HashMap&amp;lt;String,LogNode&amp;gt;" line="791"/>
                <declaration name="loggerRef" type="LoggerWeakRef" line="792"/>
                <declaration name="parent" type="LogNode" line="793"/>
                <method name="LogNode" type="constructor" line="794">
                    <params>
                        <param name="parent" type="LogNode"/>
                    </params>
                </method>
                <method name="walkAndSetParent" type="void" line="797">
                    <params>
                        <param name="parent" type="Logger"/>
                    </params>
                    <scope line="798"/>
                    <declaration name="values" type="Iterator&amp;lt;LogNode&amp;gt;" line="801"/>
                    <scope line="802">
                        <declaration name="node" type="LogNode" line="803"/>
                        <declaration name="ref" type="LoggerWeakRef" line="804"/>
                        <declaration name="logger" type="Logger" line="805"/>
                        <scope line="806"/>
                        <scope line="809"/>
                    </scope>
                </method>
            </class>
            <class name="RootLogger" line="815">
                <extends class="Logger"/>
                <method name="RootLogger" type="constructor" line="816"/>
                <method name="log" type="void" line="820">
                    <params>
                        <param name="record" type="LogRecord"/>
                    </params>
                </method>
                <method name="addHandler" type="void" line="824">
                    <params>
                        <param name="h" type="Handler"/>
                    </params>
                </method>
                <method name="removeHandler" type="void" line="828">
                    <params>
                        <param name="h" type="Handler"/>
                    </params>
                </method>
                <method name="getHandlers" type="Handler[]" line="832"/>
            </class>
            <method name="setLevelsOnExistingLoggers" type="void" line="837">
                <declaration name="enum_" type="Enumeration" line="838"/>
                <scope line="839">
                    <declaration name="key" type="String" line="840"/>
                    <scope line="841"/>
                    <declaration name="ix" type="int" line="844"/>
                    <declaration name="name" type="String" line="845"/>
                    <declaration name="level" type="Level" line="846"/>
                    <scope line="847"/>
                    <declaration name="l" type="Logger" line="851"/>
                    <scope line="852"/>
                </scope>
            </method>
            <declaration name="loggingMXBean" type="LoggingMXBean" line="858"/>
            <declaration name="LOGGING_MXBEAN_NAME" type="String" line="859"/>
            <javadoc line="859">
                String representation of the{@link javax.management.ObjectName} for the management interface
                  for the logging facility.                
                <see>
                    java.lang.management.PlatformLoggingMXBean                    
                </see>
                <see>
                    java.util.logging.LoggingMXBean                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <javadoc line="867">
                Returns &lt;tt&gt;LoggingMXBean&lt;/tt&gt; for managing loggers.
                  An alternative way to manage loggers is through the{@link java.lang.management.PlatformLoggingMXBean} interface
                  that can be obtained by calling:
                  &lt;pre&gt;
                  PlatformLoggingMXBean logging = {@link java.lang.management.ManagementFactory#getPlatformMXBean(Class)ManagementFactory.getPlatformMXBean}(PlatformLoggingMXBean.class);
                  &lt;/pre&gt;                
                <return>
                    a {@link LoggingMXBean} object.                    
                </return>
                <see>
                    java.lang.management.PlatformLoggingMXBean                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="getLoggingMXBean" type="LoggingMXBean" line="878">
                <scope line="879"/>
            </method>
        </class>
    </source>