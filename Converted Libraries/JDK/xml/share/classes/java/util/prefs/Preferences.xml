<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.prefs">
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.OutputStream"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.Permission"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.ServiceLoader"/>
        <import package="java.util.ServiceConfigurationError"/>
        <import package="java.lang.RuntimePermission"/>
        <import package="java.lang.Integer"/>
        <import package="java.lang.Long"/>
        <import package="java.lang.Float"/>
        <import package="java.lang.Double"/>
        <class name="Preferences" line="45">
            <javadoc line="45">
                A node in a hierarchical collection of preference data.  This class
                  allows applications to store and retrieve user and system
                  preference and configuration data.  This data is stored
                  persistently in an implementation-dependent backing store.  Typical
                  implementations include flat files, OS-specific registries,
                  directory servers and SQL databases.  The user of this class needn&apos;t
                  be concerned with details of the backing store.
                  &lt;p&gt;There are two separate trees of preference nodes, one for user
                  preferences and one for system preferences.  Each user has a separate user
                  preference tree, and all users in a given system share the same system
                  preference tree.  The precise description of &quot;user&quot; and &quot;system&quot; will vary
                  from implementation to implementation.  Typical information stored in the
                  user preference tree might include font choice, color choice, or preferred
                  window location and size for a particular application.  Typical information
                  stored in the system preference tree might include installation
                  configuration data for an application.
                  &lt;p&gt;Nodes in a preference tree are named in a similar fashion to
                  directories in a hierarchical file system.   Every node in a preference
                  tree has a &lt;i&gt;node name&lt;/i&gt; (which is not necessarily unique),
                  a unique &lt;i&gt;absolute path name&lt;/i&gt;, and a path name &lt;i&gt;relative&lt;/i&gt; to each
                  ancestor including itself.
                  &lt;p&gt;The root node has a node name of the empty string (&quot;&quot;).  Every other
                  node has an arbitrary node name, specified at the time it is created.  The
                  only restrictions on this name are that it cannot be the empty string, and
                  it cannot contain the slash character (&apos;/&apos;).
                  &lt;p&gt;The root node has an absolute path name of &lt;tt&gt;&quot;/&quot;&lt;/tt&gt;.  Children of
                  the root node have absolute path names of &lt;tt&gt;&quot;/&quot; + &lt;/tt&gt;&lt;i&gt;&amp;lt;node
                  name&amp;gt;&lt;/i&gt;.  All other nodes have absolute path names of &lt;i&gt;&amp;lt;parent&apos;s
                  absolute path name&amp;gt;&lt;/i&gt;&lt;tt&gt; + &quot;/&quot; + &lt;/tt&gt;&lt;i&gt;&amp;lt;node name&amp;gt;&lt;/i&gt;.
                  Note that all absolute path names begin with the slash character.
                  &lt;p&gt;A node &lt;i&gt;n&lt;/i&gt;&apos;s path name relative to its ancestor &lt;i&gt;a&lt;/i&gt;
                  is simply the string that must be appended to &lt;i&gt;a&lt;/i&gt;&apos;s absolute path name
                  in order to form &lt;i&gt;n&lt;/i&gt;&apos;s absolute path name, with the initial slash
                  character (if present) removed.  Note that:
                  &lt;ul&gt;
                  &lt;li&gt;No relative path names begin with the slash character.
                  &lt;li&gt;Every node&apos;s path name relative to itself is the empty string.
                  &lt;li&gt;Every node&apos;s path name relative to its parent is its node name (except
                  for the root node, which does not have a parent).
                  &lt;li&gt;Every node&apos;s path name relative to the root is its absolute path name
                  with the initial slash character removed.
                  &lt;/ul&gt;
                  &lt;p&gt;Note finally that:
                  &lt;ul&gt;
                  &lt;li&gt;No path name contains multiple consecutive slash characters.
                  &lt;li&gt;No path name with the exception of the root&apos;s absolute path name
                  ends in the slash character.
                  &lt;li&gt;Any string that conforms to these two rules is a valid path name.
                  &lt;/ul&gt;
                  &lt;p&gt;All of the methods that modify preferences data are permitted to operate
                  asynchronously; they may return immediately, and changes will eventually
                  propagate to the persistent backing store with an implementation-dependent
                  delay.  The &lt;tt&gt;flush&lt;/tt&gt; method may be used to synchronously force
                  updates to the backing store.  Normal termination of the Java Virtual
                  Machine will &lt;i&gt;not&lt;/i&gt; result in the loss of pending updates -- an explicit
                  &lt;tt&gt;flush&lt;/tt&gt; invocation is &lt;i&gt;not&lt;/i&gt; required upon termination to ensure
                  that pending updates are made persistent.
                  &lt;p&gt;All of the methods that read preferences from a &lt;tt&gt;Preferences&lt;/tt&gt;
                  object require the invoker to provide a default value.  The default value is
                  returned if no value has been previously set &lt;i&gt;or if the backing store is
                  unavailable&lt;/i&gt;.  The intent is to allow applications to operate, albeit
                  with slightly degraded functionality, even if the backing store becomes
                  unavailable.  Several methods, like &lt;tt&gt;flush&lt;/tt&gt;, have semantics that
                  prevent them from operating if the backing store is unavailable.  Ordinary
                  applications should have no need to invoke any of these methods, which can
                  be identified by the fact that they are declared to throw {@link BackingStoreException}.
                  &lt;p&gt;The methods in this class may be invoked concurrently by multiple threads
                  in a single JVM without the need for external synchronization, and the
                  results will be equivalent to some serial execution.  If this class is used
                  concurrently &lt;i&gt;by multiple JVMs&lt;/i&gt; that store their preference data in
                  the same backing store, the data store will not be corrupted, but no
                  other guarantees are made concerning the consistency of the preference
                  data.
                  &lt;p&gt;This class contains an export/import facility, allowing preferences
                  to be &quot;exported&quot; to an XML document, and XML documents representing
                  preferences to be &quot;imported&quot; back into the system.  This facility
                  may be used to back up all or part of a preference tree, and
                  subsequently restore from the backup.
                  &lt;p&gt;The XML document has the following DOCTYPE declaration:
                  &lt;pre&gt;
                  &amp;lt;!DOCTYPE preferences SYSTEM &quot;http://java.sun.com/dtd/preferences.dtd&quot;&amp;gt;
                  &lt;/pre&gt;
                  Note that the system URI (http://java.sun.com/dtd/preferences.dtd) is
                  &lt;i&gt;not&lt;/i&gt; accessed when exporting or importing preferences; it merely
                  serves as a string to uniquely identify the DTD, which is:
                  &lt;pre&gt;
                  &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
                  &amp;lt;!-- DTD for a Preferences tree. --&amp;gt;
                  &amp;lt;!-- The preferences element is at the root of an XML document
                  representing a Preferences tree. --&amp;gt;
                  &amp;lt;!ELEMENT preferences (root)&amp;gt;
                  &amp;lt;!-- The preferences element contains an optional version attribute,
                  which specifies version of DTD. --&amp;gt;
                  &amp;lt;!ATTLIST preferences EXTERNAL_XML_VERSION CDATA &quot;0.0&quot; &amp;gt
                  &amp;lt;!-- The root element has a map representing the root&apos;s preferences
                  (if any), and one node for each child of the root (if any). --&amp;gt;
                  &amp;lt;!ELEMENT root (map, node) &amp;gt;
                  &amp;lt;!-- Additionally, the root contains a type attribute, which
                  specifies whether it&apos;s the system or user root. --&amp;gt;
                  &amp;lt;!ATTLIST root
                  type (system|user) #REQUIRED &amp;gt;
                  &amp;lt;!-- Each node has a map representing its preferences (if any),
                  and one node for each child (if any). --&amp;gt;
                  &amp;lt;!ELEMENT node (map, node) &amp;gt;
                  &amp;lt;!-- Additionally, each node has a name attribute --&amp;gt;
                  &amp;lt;!ATTLIST node
                  name CDATA #REQUIRED &amp;gt;
                  &amp;lt;!-- A map represents the preferences stored at a node (if any). --&amp;gt;
                  &amp;lt;!ELEMENT map (entry) &amp;gt;
                  &amp;lt;!-- An entry represents a single preference, which is simply
                  a key-value pair. --&amp;gt;
                  &amp;lt;!ELEMENT entry EMPTY &amp;gt;
                  &amp;lt;!ATTLIST entry
                  key   CDATA #REQUIRED
                  value CDATA #REQUIRED &amp;gt;
                  &lt;/pre&gt;
                  Every &lt;tt&gt;Preferences&lt;/tt&gt; implementation must have an associated {@link PreferencesFactory} implementation.  Every Java(TM) SE implementation must provide
                  some means of specifying which &lt;tt&gt;PreferencesFactory&lt;/tt&gt; implementation
                  is used to generate the root preferences nodes.  This allows the
                  administrator to replace the default preferences implementation with an
                  alternative implementation.
                  &lt;p&gt;Implementation note: In Sun&apos;s JRE, the &lt;tt&gt;PreferencesFactory&lt;/tt&gt;
                  implementation is located as follows:
                  &lt;ol&gt;
                  &lt;li&gt;&lt;p&gt;If the system property
                  &lt;tt&gt;java.util.prefs.PreferencesFactory&lt;/tt&gt; is defined, then it is
                  taken to be the fully-qualified name of a class implementing the
                  &lt;tt&gt;PreferencesFactory&lt;/tt&gt; interface.  The class is loaded and
                  instantiated; if this process fails then an unspecified error is
                  thrown.&lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt; If a &lt;tt&gt;PreferencesFactory&lt;/tt&gt; implementation class file
                  has been installed in a jar file that is visible to the{@link java.lang.ClassLoader#getSystemClassLoader system class loader},
                  and that jar file contains a provider-configuration file named
                  &lt;tt&gt;java.util.prefs.PreferencesFactory&lt;/tt&gt; in the resource
                  directory &lt;tt&gt;META-INF/services&lt;/tt&gt;, then the first class name
                  specified in that file is taken.  If more than one such jar file is
                  provided, the first one found will be used.  The class is loaded
                  and instantiated; if this process fails then an unspecified error
                  is thrown.  &lt;/p&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;p&gt;Finally, if neither the above-mentioned system property nor
                  an extension jar file is provided, then the system-wide default
                  &lt;tt&gt;PreferencesFactory&lt;/tt&gt; implementation for the underlying
                  platform is loaded and instantiated.&lt;/p&gt;&lt;/li&gt;
                  &lt;/ol&gt;                
                <author>
                    Josh Bloch                    
                </author>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <declaration name="factory" type="PreferencesFactory" line="226"/>
            <method name="factory" type="PreferencesFactory" line="228">
                <comment line="230">
                    1. Try user-specified system property                    
                </comment>
                <comment line="237">
                    FIXME: This code should be run in a doPrivileged and
                     not use the context classloader, to avoid being
                     dependent on the invoking thread.
                     Checking AllPermission also seems wrong.                    
                </comment>
                <comment line="248">
                    workaround for javaws, plugin,
                     load factory class using non-system classloader                    
                </comment>
                <anonymous_class line="231">
                    <method name="run" type="String" line="232"/>
                </anonymous_class>
                <declaration name="factoryName" type="String" line="230"/>
                <scope line="235">
                    <scope line="240"/>
                    <scope line="245">
                        <scope line="246">
                            <declaration name="sm" type="SecurityManager" line="249"/>
                            <scope line="250"/>
                        </scope>
                        <scope line="258">
                            <declaration name="error" type="InternalError" line="259"/>
                        </scope>
                    </scope>
                </scope>
                <anonymous_class line="269">
                    <method name="run" type="PreferencesFactory" line="270"/>
                </anonymous_class>
            </method>
            <method name="factory1" type="PreferencesFactory" line="274">
                <comment line="276">
                    2. Try service provider interface                    
                </comment>
                <comment line="281">
                    choose first provider instance                    
                </comment>
                <comment line="287">
                    Ignore the security exception, try the next provider                    
                </comment>
                <comment line="294">
                    3. Use platform-specific system-wide default                    
                </comment>
                <declaration name="itr" type="Iterator&lt;PreferencesFactory&gt;" line="276"/>
                <scope line="281">
                    <scope line="282"/>
                    <scope line="284">
                        <scope line="285"/>
                    </scope>
                </scope>
                <declaration name="platformFactory" type="String" line="294"/>
                <scope line="298"/>
                <scope line="301">
                    <declaration name="error" type="InternalError" line="302"/>
                </scope>
            </method>
            <declaration name="MAX_KEY_LENGTH" type="int" line="310"/>
            <javadoc line="310">
                Maximum length of string allowed as a key (80 characters).                
            </javadoc>
            <declaration name="MAX_VALUE_LENGTH" type="int" line="315"/>
            <javadoc line="315">
                Maximum length of string allowed as a value (8192 characters).                
            </javadoc>
            <declaration name="MAX_NAME_LENGTH" type="int" line="320"/>
            <javadoc line="320">
                Maximum length of a node name (80 characters).                
            </javadoc>
            <javadoc line="325">
                Returns the preference node from the calling user&apos;s preference tree
                  that is associated (by convention) with the specified class&apos;s package.
                  The convention is as follows: the absolute path name of the node is the
                  fully qualified package name, preceded by a slash (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;), and
                  with each period (&lt;tt&gt;&apos;.&apos;&lt;/tt&gt;) replaced by a slash.  For example the
                  absolute path name of the node associated with the class
                  &lt;tt&gt;com.acme.widget.Foo&lt;/tt&gt; is &lt;tt&gt;/com/acme/widget&lt;/tt&gt;.
                  &lt;p&gt;This convention does not apply to the unnamed package, whose
                  associated preference node is &lt;tt&gt;&amp;lt;unnamed&amp;gt;&lt;/tt&gt;.  This node
                  is not intended for long term use, but for convenience in the early
                  development of programs that do not yet belong to a package, and
                  for &quot;throwaway&quot; programs.  &lt;i&gt;Valuable data should not be stored
                  at this node as it is shared by all programs that use it.&lt;/i&gt;
                  &lt;p&gt;A class &lt;tt&gt;Foo&lt;/tt&gt; wishing to access preferences pertaining to its
                  package can obtain a preference node as follows: &lt;pre&gt;
                  static Preferences prefs = Preferences.userNodeForPackage(Foo.class);
                  &lt;/pre&gt;
                  This idiom obviates the need for using a string to describe the
                  preferences node and decreases the likelihood of a run-time failure.
                  (If the class name is misspelled, it will typically result in a
                  compile-time error.)
                  &lt;p&gt;Invoking this method will result in the creation of the returned
                  node and its ancestors if they do not already exist.  If the returned
                  node did not exist prior to this call, this node and any ancestors that
                  were created by this call are not guaranteed to become permanent until
                  the &lt;tt&gt;flush&lt;/tt&gt; method is called on the returned node (or one of its
                  ancestors or descendants).                
                <param>
                    c the class for whose package a user preference node is desired.                    
                </param>
                <return>
                    the user preference node associated with the package of which
                      <tt>c</tt> is a member.                    
                </return>
                <throws>
                    NullPointerException if <tt>c</tt> is <tt>null</tt>.                    
                </throws>
                <throws>
                    SecurityException if a security manager is present and
                      it denies <tt>RuntimePermission("preferences")</tt>.                    
                </throws>
                <see>
                    RuntimePermission                    
                </see>
            </javadoc>
            <method name="userNodeForPackage" type="Preferences" line="365">
                <params>
                    <param name="c" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="369">
                Returns the preference node from the system preference tree that is
                  associated (by convention) with the specified class&apos;s package.  The
                  convention is as follows: the absolute path name of the node is the
                  fully qualified package name, preceded by a slash (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;), and
                  with each period (&lt;tt&gt;&apos;.&apos;&lt;/tt&gt;) replaced by a slash.  For example the
                  absolute path name of the node associated with the class
                  &lt;tt&gt;com.acme.widget.Foo&lt;/tt&gt; is &lt;tt&gt;/com/acme/widget&lt;/tt&gt;.
                  &lt;p&gt;This convention does not apply to the unnamed package, whose
                  associated preference node is &lt;tt&gt;&amp;lt;unnamed&amp;gt;&lt;/tt&gt;.  This node
                  is not intended for long term use, but for convenience in the early
                  development of programs that do not yet belong to a package, and
                  for &quot;throwaway&quot; programs.  &lt;i&gt;Valuable data should not be stored
                  at this node as it is shared by all programs that use it.&lt;/i&gt;
                  &lt;p&gt;A class &lt;tt&gt;Foo&lt;/tt&gt; wishing to access preferences pertaining to its
                  package can obtain a preference node as follows: &lt;pre&gt;
                  static Preferences prefs = Preferences.systemNodeForPackage(Foo.class);
                  &lt;/pre&gt;
                  This idiom obviates the need for using a string to describe the
                  preferences node and decreases the likelihood of a run-time failure.
                  (If the class name is misspelled, it will typically result in a
                  compile-time error.)
                  &lt;p&gt;Invoking this method will result in the creation of the returned
                  node and its ancestors if they do not already exist.  If the returned
                  node did not exist prior to this call, this node and any ancestors that
                  were created by this call are not guaranteed to become permanent until
                  the &lt;tt&gt;flush&lt;/tt&gt; method is called on the returned node (or one of its
                  ancestors or descendants).                
                <param>
                    c the class for whose package a system preference node is desired.                    
                </param>
                <return>
                    the system preference node associated with the package of which
                      <tt>c</tt> is a member.                    
                </return>
                <throws>
                    NullPointerException if <tt>c</tt> is <tt>null</tt>.                    
                </throws>
                <throws>
                    SecurityException if a security manager is present and
                      it denies <tt>RuntimePermission("preferences")</tt>.                    
                </throws>
                <see>
                    RuntimePermission                    
                </see>
            </javadoc>
            <method name="systemNodeForPackage" type="Preferences" line="409">
                <params>
                    <param name="c" type="Class<?>"/>
                </params>
            </method>
            <javadoc line="413">
                Returns the absolute path name of the node corresponding to the package
                  of the specified object.                
                <throws>
                    IllegalArgumentException if the package has node preferences
                      node associated with it.                    
                </throws>
            </javadoc>
            <method name="nodeName" type="String" line="420">
                <params>
                    <param name="c" type="Class"/>
                </params>
                <declaration name="className" type="String" line="424"/>
                <declaration name="pkgEndIndex" type="int" line="425"/>
                <declaration name="packageName" type="String" line="428"/>
            </method>
            <declaration name="prefsPerm" type="Permission" line="432"/>
            <javadoc line="432">
                This permission object represents the permission required to get
                  access to the user or system root (which in turn allows for all
                  other operations).                
            </javadoc>
            <javadoc line="439">
                Returns the root preference node for the calling user.                
                <return>
                    the root preference node for the calling user.                    
                </return>
                <throws>
                    SecurityException If a security manager is present and
                      it denies <tt>RuntimePermission("preferences")</tt>.                    
                </throws>
                <see>
                    RuntimePermission                    
                </see>
            </javadoc>
            <method name="userRoot" type="Preferences" line="447">
                <declaration name="security" type="SecurityManager" line="448"/>
            </method>
            <javadoc line="455">
                Returns the root preference node for the system.                
                <return>
                    the root preference node for the system.                    
                </return>
                <throws>
                    SecurityException If a security manager is present and
                      it denies <tt>RuntimePermission("preferences")</tt>.                    
                </throws>
                <see>
                    RuntimePermission                    
                </see>
            </javadoc>
            <method name="systemRoot" type="Preferences" line="463">
                <declaration name="security" type="SecurityManager" line="464"/>
            </method>
            <javadoc line="471">
                Sole constructor. (For invocation by subclass constructors, typically
                  implicit.)                
            </javadoc>
            <method name="Preferences" type="constructor" line="475"/>
            <method name="put" type="void" line="478"/>
            <javadoc line="478">
                Associates the specified value with the specified key in this
                  preference node.                
                <param>
                    key key with which the specified value is to be associated.                    
                </param>
                <param>
                    value value to be associated with the specified key.                    
                </param>
                <throws>
                    NullPointerException if key or value is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>key.length()</tt> exceeds
                      <tt>MAX_KEY_LENGTH</tt> or if <tt>value.length</tt> exceeds
                      <tt>MAX_VALUE_LENGTH</tt>.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
            </javadoc>
            <method name="get" type="String" line="493"/>
            <javadoc line="493">
                Returns the value associated with the specified key in this preference
                  node.  Returns the specified default if there is no value associated
                  with the key, or the backing store is inaccessible.
                  &lt;p&gt;Some implementations may store default values in their backing
                  stores.  If there is no value associated with the specified key
                  but there is such a &lt;i&gt;stored default&lt;/i&gt;, it is returned in
                  preference to the specified default.                
                <param>
                    key key whose associated value is to be returned.                    
                </param>
                <param>
                    def the value to be returned in the event that this
                      preference node has no value associated with <tt>key</tt>.                    
                </param>
                <return>
                    the value associated with <tt>key</tt>, or <tt>def</tt>
                      if no value is associated with <tt>key</tt>, or the backing
                      store is inaccessible.                    
                </return>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.  (A
                      <tt>null</tt> value for <tt>def</tt> <i>is</i> permitted.)                    
                </throws>
            </javadoc>
            <method name="remove" type="void" line="516"/>
            <javadoc line="516">
                Removes the value associated with the specified key in this preference
                  node, if any.
                  &lt;p&gt;If this implementation supports &lt;i&gt;stored defaults&lt;/i&gt;, and there is
                  such a default for the specified preference, the stored default will be
                  &quot;exposed&quot; by this call, in the sense that it will be returned
                  by a succeeding call to &lt;tt&gt;get&lt;/tt&gt;.                
                <param>
                    key key whose mapping is to be removed from the preference node.                    
                </param>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
            </javadoc>
            <method name="clear" type="void" line="532"/>
            <javadoc line="532">
                Removes all of the preferences (key-value associations) in this
                  preference node.  This call has no effect on any descendants
                  of this node.
                  &lt;p&gt;If this implementation supports &lt;i&gt;stored defaults&lt;/i&gt;, and this
                  node in the preferences hierarchy contains any such defaults,
                  the stored defaults will be &quot;exposed&quot; by this call, in the sense that
                  they will be returned by succeeding calls to &lt;tt&gt;get&lt;/tt&gt;.                
                <throws>
                    BackingStoreException if this operation cannot be completed
                      due to a failure in the backing store, or inability to
                      communicate with it.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #removeNode()                    
                </see>
            </javadoc>
            <method name="putInt" type="void" line="551"/>
            <javadoc line="551">
                Associates a string representing the specified int value with the
                  specified key in this preference node.  The associated string is the
                  one that would be returned if the int value were passed to{@link Integer#toString(int)}.  This method is intended for use in
                  conjunction with {@link #getInt}.                
                <param>
                    key key with which the string form of value is to be associated.                    
                </param>
                <param>
                    value value whose string form is to be associated with key.                    
                </param>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>key.length()</tt> exceeds
                      <tt>MAX_KEY_LENGTH</tt>.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #getInt(String,int)                    
                </see>
            </javadoc>
            <method name="getInt" type="int" line="569"/>
            <javadoc line="569">
                Returns the int value represented by the string associated with the
                  specified key in this preference node.  The string is converted to
                  an integer as by {@link Integer#parseInt(String)}.  Returns the
                  specified default if there is no value associated with the key,
                  the backing store is inaccessible, or if
                  &lt;tt&gt;Integer.parseInt(String)&lt;/tt&gt; would throw a {@link NumberFormatException} if the associated value were passed.  This
                  method is intended for use in conjunction with {@link #putInt}.
                  &lt;p&gt;If the implementation supports &lt;i&gt;stored defaults&lt;/i&gt; and such a
                  default exists, is accessible, and could be converted to an int
                  with &lt;tt&gt;Integer.parseInt&lt;/tt&gt;, this int is returned in preference to
                  the specified default.                
                <param>
                    key key whose associated value is to be returned as an int.                    
                </param>
                <param>
                    def the value to be returned in the event that this
                      preference node has no value associated with <tt>key</tt>
                      or the associated value cannot be interpreted as an int,
                      or the backing store is inaccessible.                    
                </param>
                <return>
                    the int value represented by the string associated with
                      <tt>key</tt> in this preference node, or <tt>def</tt> if the
                      associated value does not exist or cannot be interpreted as
                      an int.                    
                </return>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <see>
                    #putInt(String,int)                    
                </see>
                <see>
                    #get(String,String)                    
                </see>
            </javadoc>
            <method name="putLong" type="void" line="601"/>
            <javadoc line="601">
                Associates a string representing the specified long value with the
                  specified key in this preference node.  The associated string is the
                  one that would be returned if the long value were passed to{@link Long#toString(long)}.  This method is intended for use in
                  conjunction with {@link #getLong}.                
                <param>
                    key key with which the string form of value is to be associated.                    
                </param>
                <param>
                    value value whose string form is to be associated with key.                    
                </param>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>key.length()</tt> exceeds
                      <tt>MAX_KEY_LENGTH</tt>.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #getLong(String,long)                    
                </see>
            </javadoc>
            <method name="getLong" type="long" line="619"/>
            <javadoc line="619">
                Returns the long value represented by the string associated with the
                  specified key in this preference node.  The string is converted to
                  a long as by {@link Long#parseLong(String)}.  Returns the
                  specified default if there is no value associated with the key,
                  the backing store is inaccessible, or if
                  &lt;tt&gt;Long.parseLong(String)&lt;/tt&gt; would throw a {@link NumberFormatException} if the associated value were passed.  This
                  method is intended for use in conjunction with {@link #putLong}.
                  &lt;p&gt;If the implementation supports &lt;i&gt;stored defaults&lt;/i&gt; and such a
                  default exists, is accessible, and could be converted to a long
                  with &lt;tt&gt;Long.parseLong&lt;/tt&gt;, this long is returned in preference to
                  the specified default.                
                <param>
                    key key whose associated value is to be returned as a long.                    
                </param>
                <param>
                    def the value to be returned in the event that this
                      preference node has no value associated with <tt>key</tt>
                      or the associated value cannot be interpreted as a long,
                      or the backing store is inaccessible.                    
                </param>
                <return>
                    the long value represented by the string associated with
                      <tt>key</tt> in this preference node, or <tt>def</tt> if the
                      associated value does not exist or cannot be interpreted as
                      a long.                    
                </return>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <see>
                    #putLong(String,long)                    
                </see>
                <see>
                    #get(String,String)                    
                </see>
            </javadoc>
            <method name="putBoolean" type="void" line="651"/>
            <javadoc line="651">
                Associates a string representing the specified boolean value with the
                  specified key in this preference node.  The associated string is
                  &lt;tt&gt;&quot;true&quot;&lt;/tt&gt; if the value is true, and &lt;tt&gt;&quot;false&quot;&lt;/tt&gt; if it is
                  false.  This method is intended for use in conjunction with{@link #getBoolean}.                
                <param>
                    key key with which the string form of value is to be associated.                    
                </param>
                <param>
                    value value whose string form is to be associated with key.                    
                </param>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>key.length()</tt> exceeds
                      <tt>MAX_KEY_LENGTH</tt>.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #getBoolean(String,boolean)                    
                </see>
                <see>
                    #get(String,String)                    
                </see>
            </javadoc>
            <method name="getBoolean" type="boolean" line="670"/>
            <javadoc line="670">
                Returns the boolean value represented by the string associated with the
                  specified key in this preference node.  Valid strings
                  are &lt;tt&gt;&quot;true&quot;&lt;/tt&gt;, which represents true, and &lt;tt&gt;&quot;false&quot;&lt;/tt&gt;, which
                  represents false.  Case is ignored, so, for example, &lt;tt&gt;&quot;TRUE&quot;&lt;/tt&gt;
                  and &lt;tt&gt;&quot;False&quot;&lt;/tt&gt; are also valid.  This method is intended for use in
                  conjunction with {@link #putBoolean}.
                  &lt;p&gt;Returns the specified default if there is no value
                  associated with the key, the backing store is inaccessible, or if the
                  associated value is something other than &lt;tt&gt;&quot;true&quot;&lt;/tt&gt; or
                  &lt;tt&gt;&quot;false&quot;&lt;/tt&gt;, ignoring case.
                  &lt;p&gt;If the implementation supports &lt;i&gt;stored defaults&lt;/i&gt; and such a
                  default exists and is accessible, it is used in preference to the
                  specified default, unless the stored default is something other than
                  &lt;tt&gt;&quot;true&quot;&lt;/tt&gt; or &lt;tt&gt;&quot;false&quot;&lt;/tt&gt;, ignoring case, in which case the
                  specified default is used.                
                <param>
                    key key whose associated value is to be returned as a boolean.                    
                </param>
                <param>
                    def the value to be returned in the event that this
                      preference node has no value associated with <tt>key</tt>
                      or the associated value cannot be interpreted as a boolean,
                      or the backing store is inaccessible.                    
                </param>
                <return>
                    the boolean value represented by the string associated with
                      <tt>key</tt> in this preference node, or <tt>def</tt> if the
                      associated value does not exist or cannot be interpreted as
                      a boolean.                    
                </return>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <see>
                    #get(String,String)                    
                </see>
                <see>
                    #putBoolean(String,boolean)                    
                </see>
            </javadoc>
            <method name="putFloat" type="void" line="706"/>
            <javadoc line="706">
                Associates a string representing the specified float value with the
                  specified key in this preference node.  The associated string is the
                  one that would be returned if the float value were passed to{@link Float#toString(float)}.  This method is intended for use in
                  conjunction with {@link #getFloat}.                
                <param>
                    key key with which the string form of value is to be associated.                    
                </param>
                <param>
                    value value whose string form is to be associated with key.                    
                </param>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>key.length()</tt> exceeds
                      <tt>MAX_KEY_LENGTH</tt>.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #getFloat(String,float)                    
                </see>
            </javadoc>
            <method name="getFloat" type="float" line="724"/>
            <javadoc line="724">
                Returns the float value represented by the string associated with the
                  specified key in this preference node.  The string is converted to an
                  integer as by {@link Float#parseFloat(String)}.  Returns the specified
                  default if there is no value associated with the key, the backing store
                  is inaccessible, or if &lt;tt&gt;Float.parseFloat(String)&lt;/tt&gt; would throw a{@link NumberFormatException} if the associated value were passed.
                  This method is intended for use in conjunction with {@link #putFloat}.
                  &lt;p&gt;If the implementation supports &lt;i&gt;stored defaults&lt;/i&gt; and such a
                  default exists, is accessible, and could be converted to a float
                  with &lt;tt&gt;Float.parseFloat&lt;/tt&gt;, this float is returned in preference to
                  the specified default.                
                <param>
                    key key whose associated value is to be returned as a float.                    
                </param>
                <param>
                    def the value to be returned in the event that this
                      preference node has no value associated with <tt>key</tt>
                      or the associated value cannot be interpreted as a float,
                      or the backing store is inaccessible.                    
                </param>
                <return>
                    the float value represented by the string associated with
                      <tt>key</tt> in this preference node, or <tt>def</tt> if the
                      associated value does not exist or cannot be interpreted as
                      a float.                    
                </return>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <see>
                    #putFloat(String,float)                    
                </see>
                <see>
                    #get(String,String)                    
                </see>
            </javadoc>
            <method name="putDouble" type="void" line="755"/>
            <javadoc line="755">
                Associates a string representing the specified double value with the
                  specified key in this preference node.  The associated string is the
                  one that would be returned if the double value were passed to{@link Double#toString(double)}.  This method is intended for use in
                  conjunction with {@link #getDouble}.                
                <param>
                    key key with which the string form of value is to be associated.                    
                </param>
                <param>
                    value value whose string form is to be associated with key.                    
                </param>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>key.length()</tt> exceeds
                      <tt>MAX_KEY_LENGTH</tt>.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #getDouble(String,double)                    
                </see>
            </javadoc>
            <method name="getDouble" type="double" line="773"/>
            <javadoc line="773">
                Returns the double value represented by the string associated with the
                  specified key in this preference node.  The string is converted to an
                  integer as by {@link Double#parseDouble(String)}.  Returns the specified
                  default if there is no value associated with the key, the backing store
                  is inaccessible, or if &lt;tt&gt;Double.parseDouble(String)&lt;/tt&gt; would throw a{@link NumberFormatException} if the associated value were passed.
                  This method is intended for use in conjunction with {@link #putDouble}.
                  &lt;p&gt;If the implementation supports &lt;i&gt;stored defaults&lt;/i&gt; and such a
                  default exists, is accessible, and could be converted to a double
                  with &lt;tt&gt;Double.parseDouble&lt;/tt&gt;, this double is returned in preference
                  to the specified default.                
                <param>
                    key key whose associated value is to be returned as a double.                    
                </param>
                <param>
                    def the value to be returned in the event that this
                      preference node has no value associated with <tt>key</tt>
                      or the associated value cannot be interpreted as a double,
                      or the backing store is inaccessible.                    
                </param>
                <return>
                    the double value represented by the string associated with
                      <tt>key</tt> in this preference node, or <tt>def</tt> if the
                      associated value does not exist or cannot be interpreted as
                      a double.                    
                </return>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.                    
                </throws>
                <see>
                    #putDouble(String,double)                    
                </see>
                <see>
                    #get(String,String)                    
                </see>
            </javadoc>
            <method name="putByteArray" type="void" line="804"/>
            <javadoc line="804">
                Associates a string representing the specified byte array with the
                  specified key in this preference node.  The associated string is
                  the &lt;i&gt;Base64&lt;/i&gt; encoding of the byte array, as defined in &lt;a
                  href=http://www.ietf.org/rfc/rfc2045.txt&gt;RFC 2045&lt;/a&gt;, Section 6.8,
                  with one minor change: the string will consist solely of characters
                  from the &lt;i&gt;Base64 Alphabet&lt;/i&gt;; it will not contain any newline
                  characters.  Note that the maximum length of the byte array is limited
                  to three quarters of &lt;tt&gt;MAX_VALUE_LENGTH&lt;/tt&gt; so that the length
                  of the Base64 encoded String does not exceed &lt;tt&gt;MAX_VALUE_LENGTH&lt;/tt&gt;.
                  This method is intended for use in conjunction with{@link #getByteArray}.                
                <param>
                    key key with which the string form of value is to be associated.                    
                </param>
                <param>
                    value value whose string form is to be associated with key.                    
                </param>
                <throws>
                    NullPointerException if key or value is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalArgumentException if key.length() exceeds MAX_KEY_LENGTH
                      or if value.length exceeds MAX_VALUE_LENGTH3/4.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #getByteArray(String,byte[])                    
                </see>
                <see>
                    #get(String,String)                    
                </see>
            </javadoc>
            <method name="getByteArray" type="byte[]" line="829"/>
            <javadoc line="829">
                Returns the byte array value represented by the string associated with
                  the specified key in this preference node.  Valid strings are
                  &lt;i&gt;Base64&lt;/i&gt; encoded binary data, as defined in &lt;a
                  href=http://www.ietf.org/rfc/rfc2045.txt&gt;RFC 2045&lt;/a&gt;, Section 6.8,
                  with one minor change: the string must consist solely of characters
                  from the &lt;i&gt;Base64 Alphabet&lt;/i&gt;; no newline characters or
                  extraneous characters are permitted.  This method is intended for use
                  in conjunction with {@link #putByteArray}.
                  &lt;p&gt;Returns the specified default if there is no value
                  associated with the key, the backing store is inaccessible, or if the
                  associated value is not a valid Base64 encoded byte array
                  (as defined above).
                  &lt;p&gt;If the implementation supports &lt;i&gt;stored defaults&lt;/i&gt; and such a
                  default exists and is accessible, it is used in preference to the
                  specified default, unless the stored default is not a valid Base64
                  encoded byte array (as defined above), in which case the
                  specified default is used.                
                <param>
                    key key whose associated value is to be returned as a byte array.                    
                </param>
                <param>
                    def the value to be returned in the event that this
                      preference node has no value associated with <tt>key</tt>
                      or the associated value cannot be interpreted as a byte array,
                      or the backing store is inaccessible.                    
                </param>
                <return>
                    the byte array value represented by the string associated with
                      <tt>key</tt> in this preference node, or <tt>def</tt> if the
                      associated value does not exist or cannot be interpreted as
                      a byte array.                    
                </return>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <throws>
                    NullPointerException if <tt>key</tt> is <tt>null</tt>.  (A
                      <tt>null</tt> value for <tt>def</tt> <i>is</i> permitted.)                    
                </throws>
                <see>
                    #get(String,String)                    
                </see>
                <see>
                    #putByteArray(String,byte[])                    
                </see>
            </javadoc>
            <method name="keys" type="String[]" line="868"/>
            <javadoc line="868">
                Returns all of the keys that have an associated value in this
                  preference node.  (The returned array will be of size zero if
                  this node has no preferences.)
                  &lt;p&gt;If the implementation supports &lt;i&gt;stored defaults&lt;/i&gt; and there
                  are any such defaults at this node that have not been overridden,
                  by explicit preferences, the defaults are returned in the array in
                  addition to any explicit preferences.                
                <return>
                    an array of the keys that have an associated value in this
                      preference node.                    
                </return>
                <throws>
                    BackingStoreException if this operation cannot be completed
                      due to a failure in the backing store, or inability to
                      communicate with it.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
            </javadoc>
            <method name="childrenNames" type="String[]" line="888"/>
            <javadoc line="888">
                Returns the names of the children of this preference node, relative to
                  this node.  (The returned array will be of size zero if this node has
                  no children.)                
                <return>
                    the names of the children of this preference node.                    
                </return>
                <throws>
                    BackingStoreException if this operation cannot be completed
                      due to a failure in the backing store, or inability to
                      communicate with it.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
            </javadoc>
            <method name="parent" type="Preferences" line="902"/>
            <javadoc line="902">
                Returns the parent of this preference node, or &lt;tt&gt;null&lt;/tt&gt; if this is
                  the root.                
                <return>
                    the parent of this preference node.                    
                </return>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
            </javadoc>
            <method name="node" type="Preferences" line="912"/>
            <javadoc line="912">
                Returns the named preference node in the same tree as this node,
                  creating it and any of its ancestors if they do not already exist.
                  Accepts a relative or absolute path name.  Relative path names
                  (which do not begin with the slash character &lt;tt&gt;(&apos;/&apos;)&lt;/tt&gt;) are
                  interpreted relative to this preference node.
                  &lt;p&gt;If the returned node did not exist prior to this call, this node and
                  any ancestors that were created by this call are not guaranteed
                  to become permanent until the &lt;tt&gt;flush&lt;/tt&gt; method is called on
                  the returned node (or one of its ancestors or descendants).                
                <param>
                    pathName the path name of the preference node to return.                    
                </param>
                <return>
                    the specified preference node.                    
                </return>
                <throws>
                    IllegalArgumentException if the path name is invalid (i.e.,
                      it contains multiple consecutive slash characters, or ends
                      with a slash character and is more than one character long).                    
                </throws>
                <throws>
                    NullPointerException if path name is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #flush()                    
                </see>
            </javadoc>
            <method name="nodeExists" type="boolean" line="936"/>
            <javadoc line="936">
                Returns true if the named preference node exists in the same tree
                  as this node.  Relative path names (which do not begin with the slash
                  character &lt;tt&gt;(&apos;/&apos;)&lt;/tt&gt;) are interpreted relative to this preference
                  node.
                  &lt;p&gt;If this node (or an ancestor) has already been removed with the{@link #removeNode()} method, it &lt;i&gt;is&lt;/i&gt; legal to invoke this method,
                  but only with the path name &lt;tt&gt;&quot;&quot;&lt;/tt&gt;; the invocation will return
                  &lt;tt&gt;false&lt;/tt&gt;.  Thus, the idiom &lt;tt&gt;p.nodeExists(&quot;&quot;)&lt;/tt&gt; may be
                  used to test whether &lt;tt&gt;p&lt;/tt&gt; has been removed.                
                <param>
                    pathName the path name of the node whose existence
                      is to be checked.                    
                </param>
                <return>
                    true if the specified node exists.                    
                </return>
                <throws>
                    BackingStoreException if this operation cannot be completed
                      due to a failure in the backing store, or inability to
                      communicate with it.                    
                </throws>
                <throws>
                    IllegalArgumentException if the path name is invalid (i.e.,
                      it contains multiple consecutive slash characters, or ends
                      with a slash character and is more than one character long).                    
                </throws>
                <throws>
                    NullPointerException if path name is <tt>null</tt>.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method and
                      <tt>pathName</tt> is not the empty string (<tt>""</tt>).                    
                </throws>
            </javadoc>
            <method name="removeNode" type="void" line="965"/>
            <javadoc line="965">
                Removes this preference node and all of its descendants, invalidating
                  any preferences contained in the removed nodes.  Once a node has been
                  removed, attempting any method other than {@link #name()},{@link #absolutePath()}, {@link #isUserNode()}, {@link #flush()} or{@link #node(String) nodeExists(&quot;&quot;)} on the corresponding
                  &lt;tt&gt;Preferences&lt;/tt&gt; instance will fail with an
                  &lt;tt&gt;IllegalStateException&lt;/tt&gt;.  (The methods defined on {@link Object}can still be invoked on a node after it has been removed; they will not
                  throw &lt;tt&gt;IllegalStateException&lt;/tt&gt;.)
                  &lt;p&gt;The removal is not guaranteed to be persistent until the
                  &lt;tt&gt;flush&lt;/tt&gt; method is called on this node (or an ancestor).
                  &lt;p&gt;If this implementation supports &lt;i&gt;stored defaults&lt;/i&gt;, removing a
                  node exposes any stored defaults at or below this node.  Thus, a
                  subsequent call to &lt;tt&gt;nodeExists&lt;/tt&gt; on this node&apos;s path name may
                  return &lt;tt&gt;true&lt;/tt&gt;, and a subsequent call to &lt;tt&gt;node&lt;/tt&gt; on this
                  path name may return a (different) &lt;tt&gt;Preferences&lt;/tt&gt; instance
                  representing a non-empty collection of preferences and/or children.                
                <throws>
                    BackingStoreException if this operation cannot be completed
                      due to a failure in the backing store, or inability to
                      communicate with it.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has already
                      been removed with the {@link #removeNode()} method.                    
                </throws>
                <throws>
                    UnsupportedOperationException if this method is invoked on
                      the root node.                    
                </throws>
                <see>
                    #flush()                    
                </see>
            </javadoc>
            <method name="name" type="String" line="997"/>
            <javadoc line="997">
                Returns this preference node&apos;s name, relative to its parent.                
                <return>
                    this preference node's name, relative to its parent.                    
                </return>
            </javadoc>
            <method name="absolutePath" type="String" line="1004"/>
            <javadoc line="1004">
                Returns this preference node&apos;s absolute path name.                
                <return>
                    this preference node's absolute path name.                    
                </return>
            </javadoc>
            <method name="isUserNode" type="boolean" line="1011"/>
            <javadoc line="1011">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this preference node is in the user
                  preference tree, &lt;tt&gt;false&lt;/tt&gt; if it&apos;s in the system preference tree.                
                <return>
                    <tt>true</tt> if this preference node is in the user
                      preference tree, <tt>false</tt> if it's in the system
                      preference tree.                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1021"/>
            <javadoc line="1021">
                Returns a string representation of this preferences node,
                  as if computed by the expression:&lt;tt&gt;(this.isUserNode() ? &quot;User&quot; :
                  &quot;System&quot;) + &quot; Preference Node: &quot; + this.absolutePath()&lt;/tt&gt;.                
            </javadoc>
            <method name="flush" type="void" line="1028"/>
            <javadoc line="1028">
                Forces any changes in the contents of this preference node and its
                  descendants to the persistent store.  Once this method returns
                  successfully, it is safe to assume that all changes made in the
                  subtree rooted at this node prior to the method invocation have become
                  permanent.
                  &lt;p&gt;Implementations are free to flush changes into the persistent store
                  at any time.  They do not need to wait for this method to be called.
                  &lt;p&gt;When a flush occurs on a newly created node, it is made persistent,
                  as are any ancestors (and descendants) that have yet to be made
                  persistent.  Note however that any preference value changes in
                  ancestors are &lt;i&gt;not&lt;/i&gt; guaranteed to be made persistent.
                  &lt;p&gt; If this method is invoked on a node that has been removed with
                  the {@link #removeNode()} method, flushSpi() is invoked on this node,
                  but not on others.                
                <throws>
                    BackingStoreException if this operation cannot be completed
                      due to a failure in the backing store, or inability to
                      communicate with it.                    
                </throws>
                <see>
                    #sync()                    
                </see>
            </javadoc>
            <method name="sync" type="void" line="1054"/>
            <javadoc line="1054">
                Ensures that future reads from this preference node and its
                  descendants reflect any changes that were committed to the persistent
                  store (from any VM) prior to the &lt;tt&gt;sync&lt;/tt&gt; invocation.  As a
                  side-effect, forces any changes in the contents of this preference node
                  and its descendants to the persistent store, as if the &lt;tt&gt;flush&lt;/tt&gt;
                  method had been invoked on this node.                
                <throws>
                    BackingStoreException if this operation cannot be completed
                      due to a failure in the backing store, or inability to
                      communicate with it.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #flush()                    
                </see>
            </javadoc>
            <method name="addPreferenceChangeListener" type="void" line="1071"/>
            <javadoc line="1071">
                Registers the specified listener to receive &lt;i&gt;preference change
                  events&lt;/i&gt; for this preference node.  A preference change event is
                  generated when a preference is added to this node, removed from this
                  node, or when the value associated with a preference is changed.
                  (Preference change events are &lt;i&gt;not&lt;/i&gt; generated by the {@link #removeNode()} method, which generates a &lt;i&gt;node change event&lt;/i&gt;.
                  Preference change events &lt;i&gt;are&lt;/i&gt; generated by the &lt;tt&gt;clear&lt;/tt&gt;
                  method.)
                  &lt;p&gt;Events are only guaranteed for changes made within the same JVM
                  as the registered listener, though some implementations may generate
                  events for changes made outside this JVM.  Events may be generated
                  before the changes have been made persistent.  Events are not generated
                  when preferences are modified in descendants of this node; a caller
                  desiring such events must register with each descendant.                
                <param>
                    pcl The preference change listener to add.                    
                </param>
                <throws>
                    NullPointerException if <tt>pcl</tt> is null.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #removePreferenceChangeListener(PreferenceChangeListener)                    
                </see>
                <see>
                    #addNodeChangeListener(NodeChangeListener)                    
                </see>
            </javadoc>
            <method name="removePreferenceChangeListener" type="void" line="1098"/>
            <javadoc line="1098">
                Removes the specified preference change listener, so it no longer
                  receives preference change events.                
                <param>
                    pcl The preference change listener to remove.                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>pcl</tt> was not a registered
                      preference change listener on this node.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #addPreferenceChangeListener(PreferenceChangeListener)                    
                </see>
            </javadoc>
            <method name="addNodeChangeListener" type="void" line="1112"/>
            <javadoc line="1112">
                Registers the specified listener to receive &lt;i&gt;node change events&lt;/i&gt;
                  for this node.  A node change event is generated when a child node is
                  added to or removed from this node.  (A single {@link #removeNode()}invocation results in multiple &lt;i&gt;node change events&lt;/i&gt;, one for every
                  node in the subtree rooted at the removed node.)
                  &lt;p&gt;Events are only guaranteed for changes made within the same JVM
                  as the registered listener, though some implementations may generate
                  events for changes made outside this JVM.  Events may be generated
                  before the changes have become permanent.  Events are not generated
                  when indirect descendants of this node are added or removed; a
                  caller desiring such events must register with each descendant.
                  &lt;p&gt;Few guarantees can be made regarding node creation.  Because nodes
                  are created implicitly upon access, it may not be feasible for an
                  implementation to determine whether a child node existed in the backing
                  store prior to access (for example, because the backing store is
                  unreachable or cached information is out of date).  Under these
                  circumstances, implementations are neither required to generate node
                  change events nor prohibited from doing so.                
                <param>
                    ncl The <tt>NodeChangeListener</tt> to add.                    
                </param>
                <throws>
                    NullPointerException if <tt>ncl</tt> is null.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #removeNodeChangeListener(NodeChangeListener)                    
                </see>
                <see>
                    #addPreferenceChangeListener(PreferenceChangeListener)                    
                </see>
            </javadoc>
            <method name="removeNodeChangeListener" type="void" line="1143"/>
            <javadoc line="1143">
                Removes the specified &lt;tt&gt;NodeChangeListener&lt;/tt&gt;, so it no longer
                  receives change events.                
                <param>
                    ncl The <tt>NodeChangeListener</tt> to remove.                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>ncl</tt> was not a registered
                      <tt>NodeChangeListener</tt> on this node.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #addNodeChangeListener(NodeChangeListener)                    
                </see>
            </javadoc>
            <method name="exportNode" type="void" line="1156"/>
            <javadoc line="1156">
                Emits on the specified output stream an XML document representing all
                  of the preferences contained in this node (but not its descendants).
                  This XML document is, in effect, an offline backup of the node.
                  &lt;p&gt;The XML document will have the following DOCTYPE declaration:
                  &lt;pre&gt;
                  &amp;lt;!DOCTYPE preferences SYSTEM &quot;http://java.sun.com/dtd/preferences.dtd&quot;&amp;gt;
                  &lt;/pre&gt;
                  The UTF-8 character encoding will be used.
                  &lt;p&gt;This method is an exception to the general rule that the results of
                  concurrently executing multiple methods in this class yields
                  results equivalent to some serial execution.  If the preferences
                  at this node are modified concurrently with an invocation of this
                  method, the exported preferences comprise a &quot;fuzzy snapshot&quot; of the
                  preferences contained in the node; some of the concurrent modifications
                  may be reflected in the exported data while others may not.                
                <param>
                    os the output stream on which to emit the XML document.                    
                </param>
                <throws>
                    IOException if writing to the specified output stream
                      results in an <tt>IOException</tt>.                    
                </throws>
                <throws>
                    BackingStoreException if preference data cannot be read from
                      backing store.                    
                </throws>
                <see>
                    #importPreferences(InputStream)                    
                </see>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
            </javadoc>
            <method name="exportSubtree" type="void" line="1187"/>
            <javadoc line="1187">
                Emits an XML document representing all of the preferences contained
                  in this node and all of its descendants.  This XML document is, in
                  effect, an offline backup of the subtree rooted at the node.
                  &lt;p&gt;The XML document will have the following DOCTYPE declaration:
                  &lt;pre&gt;
                  &amp;lt;!DOCTYPE preferences SYSTEM &quot;http://java.sun.com/dtd/preferences.dtd&quot;&amp;gt;
                  &lt;/pre&gt;
                  The UTF-8 character encoding will be used.
                  &lt;p&gt;This method is an exception to the general rule that the results of
                  concurrently executing multiple methods in this class yields
                  results equivalent to some serial execution.  If the preferences
                  or nodes in the subtree rooted at this node are modified concurrently
                  with an invocation of this method, the exported preferences comprise a
                  &quot;fuzzy snapshot&quot; of the subtree; some of the concurrent modifications
                  may be reflected in the exported data while others may not.                
                <param>
                    os the output stream on which to emit the XML document.                    
                </param>
                <throws>
                    IOException if writing to the specified output stream
                      results in an <tt>IOException</tt>.                    
                </throws>
                <throws>
                    BackingStoreException if preference data cannot be read from
                      backing store.                    
                </throws>
                <throws>
                    IllegalStateException if this node (or an ancestor) has been
                      removed with the {@link #removeNode()} method.                    
                </throws>
                <see>
                    #importPreferences(InputStream)                    
                </see>
                <see>
                    #exportNode(OutputStream)                    
                </see>
            </javadoc>
            <javadoc line="1219">
                Imports all of the preferences represented by the XML document on the
                  specified input stream.  The document may represent user preferences or
                  system preferences.  If it represents user preferences, the preferences
                  will be imported into the calling user&apos;s preference tree (even if they
                  originally came from a different user&apos;s preference tree).  If any of
                  the preferences described by the document inhabit preference nodes that
                  do not exist, the nodes will be created.
                  &lt;p&gt;The XML document must have the following DOCTYPE declaration:
                  &lt;pre&gt;
                  &amp;lt;!DOCTYPE preferences SYSTEM &quot;http://java.sun.com/dtd/preferences.dtd&quot;&amp;gt;
                  &lt;/pre&gt;
                  (This method is designed for use in conjunction with{@link #exportNode(OutputStream)} and{@link #exportSubtree(OutputStream)}.
                  &lt;p&gt;This method is an exception to the general rule that the results of
                  concurrently executing multiple methods in this class yields
                  results equivalent to some serial execution.  The method behaves
                  as if implemented on top of the other public methods in this class,
                  notably {@link #node(String)} and {@link #put(String,String)}.                
                <param>
                    is the input stream from which to read the XML document.                    
                </param>
                <throws>
                    IOException if reading from the specified input stream
                      results in an <tt>IOException</tt>.                    
                </throws>
                <throws>
                    InvalidPreferencesFormatException Data on input stream does not
                      constitute a valid XML document with the mandated document type.                    
                </throws>
                <throws>
                    SecurityException If a security manager is present and
                      it denies <tt>RuntimePermission("preferences")</tt>.                    
                </throws>
                <see>
                    RuntimePermission                    
                </see>
            </javadoc>
            <method name="importPreferences" type="void" line="1253">
                <params>
                    <param name="is" type="InputStream"/>
                </params>
            </method>
        </class>
    </source>