<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <class name="TreeMap" line="28">
            <type_params>
                <type_param name="K"/>
                <type_param name="V"/>
            </type_params>
            <extends class="AbstractMap">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </extends>
            <comment line="203">
                Query Operations                
            </comment>
            <comment line="647">
                NavigableMap API methods                
            </comment>
            <comment line="773">
                Views                
            </comment>
            <comment line="944">
                View class support                
            </comment>
            <comment line="1010">
                Unlike Values and EntrySet, the KeySet class is static,
                 delegating to a NavigableMap to allow use by SubMaps, which
                 outweighs the ugliness of needing type-tests for the following
                 Iterator methods that are defined appropriately in main versus
                 submap classes.                
            </comment>
            <comment line="1183">
                Little utilities                
            </comment>
            <comment line="1227">
                SubMaps                
            </comment>
            <comment line="1880">
                Red-black mechanics                
            </comment>
            <implements interface="NavigableMap">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </implements>
            <implements interface="Cloneable"/>
            <implements interface="java.io.Serializable"/>
            <javadoc line="28">
                A Red-Black tree based {@link NavigableMap} implementation.
                  The map is sorted according to the {@linkplain Comparable natural
                  ordering} of its keys, or by a {@link Comparator} provided at map
                  creation time, depending on which constructor is used.
                  &lt;p&gt;This implementation provides guaranteed log(n) time cost for the{@code containsKey}, {@code get}, {@code put} and {@code remove}operations.  Algorithms are adaptations of those in Cormen, Leiserson, and
                  Rivest&apos;s &lt;em&gt;Introduction to Algorithms&lt;/em&gt;.
                  &lt;p&gt;Note that the ordering maintained by a tree map, like any sorted map, and
                  whether or not an explicit comparator is provided, must be &lt;em&gt;consistent
                  with {@code equals}&lt;/em&gt; if this sorted map is to correctly implement the{@code Map} interface.  (See {@code Comparable} or {@code Comparator} for a
                  precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.)  This is so because
                  the {@code Map} interface is defined in terms of the {@code equals}operation, but a sorted map performs all key comparisons using its {@codecompareTo} (or {@code compare}) method, so two keys that are deemed equal by
                  this method are, from the standpoint of the sorted map, equal.  The behavior
                  of a sorted map &lt;em&gt;is&lt;/em&gt; well-defined even if its ordering is
                  inconsistent with {@code equals}; it just fails to obey the general contract
                  of the {@code Map} interface.
                  &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
                  If multiple threads access a map concurrently, and at least one of the
                  threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be synchronized
                  externally.  (A structural modification is any operation that adds or
                  deletes one or more mappings; merely changing the value associated
                  with an existing key is not a structural modification.)  This is
                  typically accomplished by synchronizing on some object that naturally
                  encapsulates the map.
                  If no such object exists, the map should be &quot;wrapped&quot; using the{@link Collections#synchronizedSortedMap Collections.synchronizedSortedMap}method.  This is best done at creation time, to prevent accidental
                  unsynchronized access to the map: &lt;pre&gt;
                  SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));&lt;/pre&gt;
                  &lt;p&gt;The iterators returned by the {@code iterator} method of the collections
                  returned by all of this class&apos;s &quot;collection view methods&quot; are
                  &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after
                  the iterator is created, in any way except through the iterator&apos;s own{@code remove} method, the iterator will throw a {@link ConcurrentModificationException}.  Thus, in the face of concurrent
                  modification, the iterator fails quickly and cleanly, rather than risking
                  arbitrary, non-deterministic behavior at an undetermined time in the future.
                  &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
                  as it is, generally speaking, impossible to make any hard guarantees in the
                  presence of unsynchronized concurrent modification.  Fail-fast iterators
                  throw {@code ConcurrentModificationException} on a best-effort basis.
                  Therefore, it would be wrong to write a program that depended on this
                  exception for its correctness:   &lt;em&gt;the fail-fast behavior of iterators
                  should be used only to detect bugs.&lt;/em&gt;
                  &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class
                  and its views represent snapshots of mappings at the time they were
                  produced. They do &lt;strong&gt;not&lt;/strong&gt; support the {@code Entry.setValue}method. (Note however that it is possible to change mappings in the
                  associated map using {@code put}.)
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <param>
                    <K>
                       the type of keys maintained by this map                    
                </param>
                <param>
                    <V>
                       the type of mapped values                    
                </param>
                <author>
                    Josh Bloch and Doug Lea                    
                </author>
                <see>
                    Map                    
                </see>
                <see>
                    HashMap                    
                </see>
                <see>
                    Hashtable                    
                </see>
                <see>
                    Comparable                    
                </see>
                <see>
                    Comparator                    
                </see>
                <see>
                    Collection                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="comparator" type="Comparator&lt;? super K&gt;" line="110"/>
            <javadoc line="110">
                The comparator used to maintain order in this tree map, or
                  null if it uses the natural ordering of its keys.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="root" type="Entry&lt;K,V&gt;" line="118"/>
            <declaration name="size" type="int" line="120"/>
            <javadoc line="120">
                The number of entries in the tree                
            </javadoc>
            <declaration name="modCount" type="int" line="125"/>
            <javadoc line="125">
                The number of structural modifications to the tree.                
            </javadoc>
            <javadoc line="130">
                Constructs a new, empty tree map, using the natural ordering of its
                  keys.  All keys inserted into the map must implement the {@link Comparable} interface.  Furthermore, all such keys must be
                  &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw
                  a {@code ClassCastException} for any keys {@code k1} and{@code k2} in the map.  If the user attempts to put a key into the
                  map that violates this constraint (for example, the user attempts to
                  put a string key into a map whose keys are integers), the{@code put(Object key, Object value)} call will throw a{@code ClassCastException}.                
            </javadoc>
            <method name="TreeMap" type="constructor" line="142"/>
            <javadoc line="146">
                Constructs a new, empty tree map, ordered according to the given
                  comparator.  All keys inserted into the map must be &lt;em&gt;mutually
                  comparable&lt;/em&gt; by the given comparator: {@code comparator.compare(k1,
                  k2)} must not throw a {@code ClassCastException} for any keys{@code k1} and {@code k2} in the map.  If the user attempts to put
                  a key into the map that violates this constraint, the {@code put(Object
                  key, Object value)} call will throw a{@code ClassCastException}.                
                <param>
                    comparator the comparator that will be used to order this map.
                      If {@code null}, the {@linkplain Comparable natural
                      ordering} of the keys will be used.                    
                </param>
            </javadoc>
            <method name="TreeMap" type="constructor" line="160">
                <params>
                    <param name="comparator" type="Comparator<? super K>"/>
                </params>
            </method>
            <javadoc line="164">
                Constructs a new tree map containing the same mappings as the given
                  map, ordered according to the &lt;em&gt;natural ordering&lt;/em&gt; of its keys.
                  All keys inserted into the new map must implement the {@link Comparable} interface.  Furthermore, all such keys must be
                  &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw
                  a {@code ClassCastException} for any keys {@code k1} and{@code k2} in the map.  This method runs in nlog(n) time.                
                <param>
                    m the map whose mappings are to be placed in this map                    
                </param>
                <throws>
                    ClassCastException if the keys in m are not {@link Comparable},
                      or are not mutually comparable                    
                </throws>
                <throws>
                    NullPointerException if the specified map is null                    
                </throws>
            </javadoc>
            <method name="TreeMap" type="constructor" line="178">
                <params>
                    <param name="m" type="Map<? extends K,? extends V>"/>
                </params>
            </method>
            <javadoc line="183">
                Constructs a new tree map containing the same mappings and
                  using the same ordering as the specified sorted map.  This
                  method runs in linear time.                
                <param>
                    m the sorted map whose mappings are to be placed in this map,
                      and whose comparator is to be used to sort this map                    
                </param>
                <throws>
                    NullPointerException if the specified map is null                    
                </throws>
            </javadoc>
            <method name="TreeMap" type="constructor" line="192">
                <params>
                    <param name="m" type="SortedMap<K,? extends V>"/>
                </params>
                <scope line="194"/>
                <scope line="196"/>
                <scope line="197"/>
            </method>
            <javadoc line="204">
                Returns the number of key-value mappings in this map.                
                <return>
                    the number of key-value mappings in this map                    
                </return>
            </javadoc>
            <method name="size" type="int" line="209"/>
            <javadoc line="213">
                Returns {@code true} if this map contains a mapping for the specified
                  key.                
                <param>
                    key key whose presence in this map is to be tested                    
                </param>
                <return>
                    {@code true} if this map contains a mapping for the
                      specified key                    
                </return>
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
            </javadoc>
            <method name="containsKey" type="boolean" line="226">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="230">
                Returns {@code true} if this map maps one or more keys to the
                  specified value.  More formally, returns {@code true} if and only if
                  this map contains at least one mapping to a value {@code v} such
                  that {@code (value==null ? v==null : value.equals(v))}.  This
                  operation will probably require time linear in the map size for
                  most implementations.                
                <param>
                    value value whose presence in this map is to be tested                    
                </param>
                <return>
                    {@code true} if a mapping to {@code value} exists;{@code false} otherwise                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="containsValue" type="boolean" line="243">
                <params>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="250">
                Returns the value to which the specified key is mapped,
                  or {@code null} if this map contains no mapping for the key.
                  &lt;p&gt;More formally, if this map contains a mapping from a key{@code k} to a value {@code v} such that {@code key} compares
                  equal to {@code k} according to the map&apos;s ordering, then this
                  method returns {@code v}; otherwise it returns {@code null}.
                  (There can be at most one such mapping.)
                  &lt;p&gt;A return value of {@code null} does not &lt;em&gt;necessarily&lt;/em&gt;
                  indicate that the map contains no mapping for the key; it&apos;s also
                  possible that the map explicitly maps the key to {@code null}.
                  The {@link #containsKey containsKey} operation may be used to
                  distinguish these two cases.                
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
            </javadoc>
            <method name="get" type="V" line="272">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="p" type="Entry&lt;K,V&gt;" line="273"/>
            </method>
            <method name="comparator" type="Comparator<? super K>" line="277"/>
            <javadoc line="281">
                @throws NoSuchElementException {@inheritDoc}                
            </javadoc>
            <method name="firstKey" type="K" line="284"/>
            <javadoc line="288">
                @throws NoSuchElementException {@inheritDoc}                
            </javadoc>
            <method name="lastKey" type="K" line="291"/>
            <javadoc line="295">
                Copies all of the mappings from the specified map to this map.
                  These mappings replace any mappings that this map had for any
                  of the keys currently in the specified map.                
                <param>
                    map mappings to be stored in this map                    
                </param>
                <throws>
                    ClassCastException if the class of a key or value in
                      the specified map prevents it from being stored in this map                    
                </throws>
                <throws>
                    NullPointerException if the specified map is null or
                      the specified map contains a null key and this map does not
                      permit null keys                    
                </throws>
            </javadoc>
            <method name="putAll" type="void" line="307">
                <params>
                    <param name="map" type="Map<? extends K,? extends V>"/>
                </params>
                <declaration name="mapSize" type="int" line="308"/>
                <scope line="309">
                    <declaration name="c" type="Comparator" line="310"/>
                    <scope line="311">
                        <scope line="313"/>
                        <scope line="316"/>
                        <scope line="317"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="325">
                Returns this map&apos;s entry for the given key, or {@code null} if the map
                  does not contain an entry for the key.                
                <return>
                    this map's entry for the given key, or {@code null} if the map
                      does not contain an entry for the key                    
                </return>
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
            </javadoc>
            <method name="getEntry" type="Entry<K,V>" line="337">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <comment line="338">
                    Offload comparator-based version for sake of performance                    
                </comment>
                <declaration name="k" type="Comparable&lt;? super K&gt;" line="343"/>
                <declaration name="p" type="Entry&lt;K,V&gt;" line="344"/>
                <scope line="345">
                    <declaration name="cmp" type="int" line="346"/>
                </scope>
            </method>
            <javadoc line="357">
                Version of getEntry using comparator. Split off from getEntry
                  for performance. (This is not worth doing for most methods,
                  that are less dependent on comparator performance, but is
                  worthwhile here.)                
            </javadoc>
            <method name="getEntryUsingComparator" type="Entry<K,V>" line="363">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="k" type="K" line="364"/>
                <declaration name="cpr" type="Comparator&lt;? super K&gt;" line="365"/>
                <scope line="366">
                    <declaration name="p" type="Entry&lt;K,V&gt;" line="367"/>
                    <scope line="368">
                        <declaration name="cmp" type="int" line="369"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="381">
                Gets the entry corresponding to the specified key; if no such entry
                  exists, returns the entry for the least key greater than the specified
                  key; if no such entry exists (i.e., the greatest key in the Tree is less
                  than the specified key), returns {@code null}.                
            </javadoc>
            <method name="getCeilingEntry" type="Entry<K,V>" line="387">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="p" type="Entry&lt;K,V&gt;" line="388"/>
                <scope line="389">
                    <declaration name="cmp" type="int" line="390"/>
                    <scope line="391"/>
                    <scope line="396">
                        <scope line="397"/>
                        <scope line="399">
                            <declaration name="parent" type="Entry&lt;K,V&gt;" line="400"/>
                            <declaration name="ch" type="Entry&lt;K,V&gt;" line="401"/>
                            <scope line="402"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="414">
                Gets the entry corresponding to the specified key; if no such entry
                  exists, returns the entry for the greatest key less than the specified
                  key; if no such entry exists, returns {@code null}.                
            </javadoc>
            <method name="getFloorEntry" type="Entry<K,V>" line="419">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="p" type="Entry&lt;K,V&gt;" line="420"/>
                <scope line="421">
                    <declaration name="cmp" type="int" line="422"/>
                    <scope line="423"/>
                    <scope line="428">
                        <scope line="429"/>
                        <scope line="431">
                            <declaration name="parent" type="Entry&lt;K,V&gt;" line="432"/>
                            <declaration name="ch" type="Entry&lt;K,V&gt;" line="433"/>
                            <scope line="434"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="447">
                Gets the entry for the least key greater than the specified
                  key; if no such entry exists, returns the entry for the least
                  key greater than the specified key; if no such entry exists
                  returns {@code null}.                
            </javadoc>
            <method name="getHigherEntry" type="Entry<K,V>" line="453">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="p" type="Entry&lt;K,V&gt;" line="454"/>
                <scope line="455">
                    <declaration name="cmp" type="int" line="456"/>
                    <scope line="457"/>
                    <scope line="462">
                        <scope line="463"/>
                        <scope line="465">
                            <declaration name="parent" type="Entry&lt;K,V&gt;" line="466"/>
                            <declaration name="ch" type="Entry&lt;K,V&gt;" line="467"/>
                            <scope line="468"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="479">
                Returns the entry for the greatest key less than the specified key; if
                  no such entry exists (i.e., the least key in the Tree is greater than
                  the specified key), returns {@code null}.                
            </javadoc>
            <method name="getLowerEntry" type="Entry<K,V>" line="484">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="p" type="Entry&lt;K,V&gt;" line="485"/>
                <scope line="486">
                    <declaration name="cmp" type="int" line="487"/>
                    <scope line="488"/>
                    <scope line="493">
                        <scope line="494"/>
                        <scope line="496">
                            <declaration name="parent" type="Entry&lt;K,V&gt;" line="497"/>
                            <declaration name="ch" type="Entry&lt;K,V&gt;" line="498"/>
                            <scope line="499"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="510">
                Associates the specified value with the specified key in this map.
                  If the map previously contained a mapping for the key, the old
                  value is replaced.                
                <param>
                    key key with which the specified value is to be associated                    
                </param>
                <param>
                    value value to be associated with the specified key                    
                </param>
                <return>
                    the previous value associated with {@code key}, or{@code null} if there was no mapping for {@code key}.
                      (A {@code null} return can also indicate that the map
                      previously associated {@code null} with {@code key}.)                    
                </return>
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
            </javadoc>
            <method name="put" type="V" line="528">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
                <comment line="531">
                    type (and possibly null) check                    
                </comment>
                <comment line="540">
                    split comparator and comparable paths                    
                </comment>
                <declaration name="t" type="Entry&lt;K,V&gt;" line="529"/>
                <scope line="530"/>
                <declaration name="cmp" type="int" line="538"/>
                <declaration name="parent" type="Entry&lt;K,V&gt;" line="539"/>
                <declaration name="cpr" type="Comparator&lt;? super K&gt;" line="541"/>
                <scope line="542">
                    <scope line="543"/>
                </scope>
                <scope line="554">
                    <declaration name="k" type="Comparable&lt;? super K&gt;" line="557"/>
                    <scope line="558"/>
                </scope>
                <declaration name="e" type="Entry&lt;K,V&gt;" line="569"/>
            </method>
            <javadoc line="580">
                Removes the mapping for this key from this TreeMap if present.                
                <param>
                    key key for which mapping should be removed                    
                </param>
                <return>
                    the previous value associated with {@code key}, or{@code null} if there was no mapping for {@code key}.
                      (A {@code null} return can also indicate that the map
                      previously associated {@code null} with {@code key}.)                    
                </return>
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
            </javadoc>
            <method name="remove" type="V" line="594">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="p" type="Entry&lt;K,V&gt;" line="595"/>
                <declaration name="oldValue" type="V" line="599"/>
            </method>
            <javadoc line="604">
                Removes all of the mappings from this map.
                  The map will be empty after this call returns.                
            </javadoc>
            <method name="clear" type="void" line="608"/>
            <javadoc line="614">
                Returns a shallow copy of this {@code TreeMap} instance. (The keys and
                  values themselves are not cloned.)                
                <return>
                    a shallow copy of this map                    
                </return>
            </javadoc>
            <method name="clone" type="Object" line="620">
                <comment line="628">
                    Put clone into &quot;virgin&quot; state (except for comparator)                    
                </comment>
                <comment line="636">
                    Initialize clone with our mappings                    
                </comment>
                <declaration name="clone" type="TreeMap&lt;K,V&gt;" line="621"/>
                <scope line="622"/>
                <scope line="624"/>
                <scope line="637"/>
                <scope line="639"/>
                <scope line="640"/>
            </method>
            <javadoc line="648">
                @since 1.6                
            </javadoc>
            <method name="firstEntry" type="Map.Entry<K,V>" line="651"/>
            <javadoc line="655">
                @since 1.6                
            </javadoc>
            <method name="lastEntry" type="Map.Entry<K,V>" line="658"/>
            <javadoc line="662">
                @since 1.6                
            </javadoc>
            <method name="pollFirstEntry" type="Map.Entry<K,V>" line="665">
                <declaration name="p" type="Entry&lt;K,V&gt;" line="666"/>
                <declaration name="result" type="Map.Entry&lt;K,V&gt;" line="667"/>
            </method>
            <javadoc line="673">
                @since 1.6                
            </javadoc>
            <method name="pollLastEntry" type="Map.Entry<K,V>" line="676">
                <declaration name="p" type="Entry&lt;K,V&gt;" line="677"/>
                <declaration name="result" type="Map.Entry&lt;K,V&gt;" line="678"/>
            </method>
            <javadoc line="684">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="lowerEntry" type="Map.Entry<K,V>" line="691">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="695">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="lowerKey" type="K" line="702">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="706">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="floorEntry" type="Map.Entry<K,V>" line="713">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="717">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="floorKey" type="K" line="724">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="728">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="ceilingEntry" type="Map.Entry<K,V>" line="735">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="739">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="ceilingKey" type="K" line="746">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="750">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="higherEntry" type="Map.Entry<K,V>" line="757">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="761">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="higherKey" type="K" line="768">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <declaration name="entrySet" type="EntrySet" line="774"/>
            <javadoc line="774">
                Fields initialized to contain an instance of the entry set view
                  the first time this view is requested.  Views are stateless, so
                  there&apos;s no reason to create more than one.                
            </javadoc>
            <declaration name="navigableKeySet" type="KeySet&lt;K&gt;" line="780"/>
            <declaration name="descendingMap" type="NavigableMap&lt;K,V&gt;" line="781"/>
            <javadoc line="783">
                Returns a {@link Set} view of the keys contained in this map.
                  The set&apos;s iterator returns the keys in ascending order.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  If the map is modified
                  while an iteration over the set is in progress (except through
                  the iterator&apos;s own {@code remove} operation), the results of
                  the iteration are undefined.  The set supports element removal,
                  which removes the corresponding mapping from the map, via the{@code Iterator.remove}, {@code Set.remove},{@code removeAll}, {@code retainAll}, and {@code clear}operations.  It does not support the {@code add} or {@code addAll}operations.                
            </javadoc>
            <method name="keySet" type="Set<K>" line="797"/>
            <javadoc line="801">
                @since 1.6                
            </javadoc>
            <method name="navigableKeySet" type="NavigableSet<K>" line="804">
                <declaration name="nks" type="KeySet&lt;K&gt;" line="805"/>
            </method>
            <javadoc line="809">
                @since 1.6                
            </javadoc>
            <method name="descendingKeySet" type="NavigableSet<K>" line="812"/>
            <javadoc line="816">
                Returns a {@link Collection} view of the values contained in this map.
                  The collection&apos;s iterator returns the values in ascending order
                  of the corresponding keys.
                  The collection is backed by the map, so changes to the map are
                  reflected in the collection, and vice-versa.  If the map is
                  modified while an iteration over the collection is in progress
                  (except through the iterator&apos;s own {@code remove} operation),
                  the results of the iteration are undefined.  The collection
                  supports element removal, which removes the corresponding
                  mapping from the map, via the {@code Iterator.remove},{@code Collection.remove}, {@code removeAll},{@code retainAll} and {@code clear} operations.  It does not
                  support the {@code add} or {@code addAll} operations.                
            </javadoc>
            <method name="values" type="Collection<V>" line="831">
                <declaration name="vs" type="Collection&lt;V&gt;" line="832"/>
            </method>
            <javadoc line="836">
                Returns a {@link Set} view of the mappings contained in this map.
                  The set&apos;s iterator returns the entries in ascending key order.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  If the map is modified
                  while an iteration over the set is in progress (except through
                  the iterator&apos;s own {@code remove} operation, or through the{@code setValue} operation on a map entry returned by the
                  iterator) the results of the iteration are undefined.  The set
                  supports element removal, which removes the corresponding
                  mapping from the map, via the {@code Iterator.remove},{@code Set.remove}, {@code removeAll}, {@code retainAll} and{@code clear} operations.  It does not support the{@code add} or {@code addAll} operations.                
            </javadoc>
            <method name="entrySet" type="Set<Map.Entry<K,V>>" line="851">
                <declaration name="es" type="EntrySet" line="852"/>
            </method>
            <javadoc line="856">
                @since 1.6                
            </javadoc>
            <method name="descendingMap" type="NavigableMap<K,V>" line="859">
                <declaration name="km" type="NavigableMap&lt;K,V&gt;" line="860"/>
            </method>
            <javadoc line="867">
                @throws ClassCastException       {@inheritDoc}                
                <throws>
                    NullPointerException if {@code fromKey} or {@code toKey} is
                      null and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="subMap" type="NavigableMap<K,V>" line="876">
                <params>
                    <param name="fromKey" type="K"/>
                    <param name="fromInclusive" type="boolean"/>
                    <param name="toKey" type="K"/>
                    <param name="toInclusive" type="boolean"/>
                </params>
            </method>
            <javadoc line="882">
                @throws ClassCastException       {@inheritDoc}                
                <throws>
                    NullPointerException if {@code toKey} is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="headMap" type="NavigableMap<K,V>" line="890">
                <params>
                    <param name="toKey" type="K"/>
                    <param name="inclusive" type="boolean"/>
                </params>
            </method>
            <javadoc line="896">
                @throws ClassCastException       {@inheritDoc}                
                <throws>
                    NullPointerException if {@code fromKey} is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="tailMap" type="NavigableMap<K,V>" line="904">
                <params>
                    <param name="fromKey" type="K"/>
                    <param name="inclusive" type="boolean"/>
                </params>
            </method>
            <javadoc line="910">
                @throws ClassCastException       {@inheritDoc}                
                <throws>
                    NullPointerException if {@code fromKey} or {@code toKey} is
                      null and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="subMap" type="SortedMap<K,V>" line="917">
                <params>
                    <param name="fromKey" type="K"/>
                    <param name="toKey" type="K"/>
                </params>
            </method>
            <javadoc line="921">
                @throws ClassCastException       {@inheritDoc}                
                <throws>
                    NullPointerException if {@code toKey} is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="headMap" type="SortedMap<K,V>" line="928">
                <params>
                    <param name="toKey" type="K"/>
                </params>
            </method>
            <javadoc line="932">
                @throws ClassCastException       {@inheritDoc}                
                <throws>
                    NullPointerException if {@code fromKey} is null
                      and this map uses natural ordering, or its comparator
                      does not permit null keys                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="tailMap" type="SortedMap<K,V>" line="939">
                <params>
                    <param name="fromKey" type="K"/>
                </params>
            </method>
            <class name="Values" line="945">
                <extends class="AbstractCollection">
                    <type_params>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <method name="iterator" type="Iterator<V>" line="946"/>
                <method name="size" type="int" line="950"/>
                <method name="contains" type="boolean" line="954">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="958">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="959">
                        <scope line="960"/>
                    </scope>
                </method>
                <method name="clear" type="void" line="968"/>
            </class>
            <class name="EntrySet" line="973">
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="Map.Entry<K,V>"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <method name="iterator" type="Iterator<Map.Entry<K,V>>" line="974"/>
                <method name="contains" type="boolean" line="978">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="entry" type="Map.Entry&lt;K,V&gt;" line="981"/>
                    <declaration name="value" type="V" line="982"/>
                    <declaration name="p" type="Entry&lt;K,V&gt;" line="983"/>
                </method>
                <method name="remove" type="boolean" line="987">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="entry" type="Map.Entry&lt;K,V&gt;" line="990"/>
                    <declaration name="value" type="V" line="991"/>
                    <declaration name="p" type="Entry&lt;K,V&gt;" line="992"/>
                    <scope line="993"/>
                </method>
                <method name="size" type="int" line="1000"/>
                <method name="clear" type="void" line="1004"/>
            </class>
            <method name="keyIterator" type="Iterator<K>" line="1017"/>
            <method name="descendingKeyIterator" type="Iterator<K>" line="1021"/>
            <class name="KeySet" line="1025">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <implements interface="NavigableSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="m" type="NavigableMap&lt;E,Object&gt;" line="1026"/>
                <method name="KeySet" type="constructor" line="1027">
                    <params>
                        <param name="map" type="NavigableMap<E,Object>"/>
                    </params>
                </method>
                <method name="iterator" type="Iterator<E>" line="1029"/>
                <method name="descendingIterator" type="Iterator<E>" line="1036"/>
                <method name="size" type="int" line="1043"/>
                <method name="isEmpty" type="boolean" line="1044"/>
                <method name="contains" type="boolean" line="1045">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="1046"/>
                <method name="lower" type="E" line="1047">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="floor" type="E" line="1048">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="ceiling" type="E" line="1049">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="higher" type="E" line="1050">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="first" type="E" line="1051"/>
                <method name="last" type="E" line="1052"/>
                <method name="comparator" type="Comparator<? super E>" line="1053"/>
                <method name="pollFirst" type="E" line="1054">
                    <declaration name="e" type="Map.Entry&lt;E,Object&gt;" line="1055"/>
                </method>
                <method name="pollLast" type="E" line="1058">
                    <declaration name="e" type="Map.Entry&lt;E,Object&gt;" line="1059"/>
                </method>
                <method name="remove" type="boolean" line="1062">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="oldSize" type="int" line="1063"/>
                </method>
                <method name="subSet" type="NavigableSet<E>" line="1068">
                    <params>
                        <param name="fromElement" type="E"/>
                        <param name="fromInclusive" type="boolean"/>
                        <param name="toElement" type="E"/>
                        <param name="toInclusive" type="boolean"/>
                    </params>
                </method>
                <method name="headSet" type="NavigableSet<E>" line="1072">
                    <params>
                        <param name="toElement" type="E"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="tailSet" type="NavigableSet<E>" line="1075">
                    <params>
                        <param name="fromElement" type="E"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="subSet" type="SortedSet<E>" line="1078">
                    <params>
                        <param name="fromElement" type="E"/>
                        <param name="toElement" type="E"/>
                    </params>
                </method>
                <method name="headSet" type="SortedSet<E>" line="1081">
                    <params>
                        <param name="toElement" type="E"/>
                    </params>
                </method>
                <method name="tailSet" type="SortedSet<E>" line="1084">
                    <params>
                        <param name="fromElement" type="E"/>
                    </params>
                </method>
                <method name="descendingSet" type="NavigableSet<E>" line="1087"/>
            </class>
            <class name="PrivateEntryIterator" line="1092">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <javadoc line="1092">
                    Base class for TreeMap Iterators                    
                </javadoc>
                <declaration name="next" type="Entry&lt;K,V&gt;" line="1096"/>
                <declaration name="lastReturned" type="Entry&lt;K,V&gt;" line="1097"/>
                <declaration name="expectedModCount" type="int" line="1098"/>
                <method name="PrivateEntryIterator" type="constructor" line="1100">
                    <params>
                        <param name="first" type="Entry<K,V>"/>
                    </params>
                </method>
                <method name="hasNext" type="boolean" line="1106"/>
                <method name="nextEntry" type="Entry<K,V>" line="1110">
                    <declaration name="e" type="Entry&lt;K,V&gt;" line="1111"/>
                </method>
                <method name="prevEntry" type="Entry<K,V>" line="1121">
                    <declaration name="e" type="Entry&lt;K,V&gt;" line="1122"/>
                </method>
                <method name="remove" type="void" line="1132">
                    <comment line="1137">
                        deleted entries are replaced by their successors                        
                    </comment>
                </method>
            </class>
            <class name="EntryIterator" line="1146">
                <extends class="PrivateEntryIterator">
                    <type_params>
                        <type_param name="Map.Entry<K,V>"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <method name="EntryIterator" type="constructor" line="1147">
                    <params>
                        <param name="first" type="Entry<K,V>"/>
                    </params>
                </method>
                <method name="next" type="Map.Entry<K,V>" line="1150"/>
            </class>
            <class name="ValueIterator" line="1155">
                <extends class="PrivateEntryIterator">
                    <type_params>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <method name="ValueIterator" type="constructor" line="1156">
                    <params>
                        <param name="first" type="Entry<K,V>"/>
                    </params>
                </method>
                <method name="next" type="V" line="1159"/>
            </class>
            <class name="KeyIterator" line="1164">
                <extends class="PrivateEntryIterator">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <method name="KeyIterator" type="constructor" line="1165">
                    <params>
                        <param name="first" type="Entry<K,V>"/>
                    </params>
                </method>
                <method name="next" type="K" line="1168"/>
            </class>
            <class name="DescendingKeyIterator" line="1173">
                <extends class="PrivateEntryIterator">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <method name="DescendingKeyIterator" type="constructor" line="1174">
                    <params>
                        <param name="first" type="Entry<K,V>"/>
                    </params>
                </method>
                <method name="next" type="K" line="1177"/>
            </class>
            <javadoc line="1184">
                Compares two keys using the correct comparison method for this TreeMap.                
            </javadoc>
            <method name="compare" type="int" line="1187">
                <params>
                    <param name="k1" type="Object"/>
                    <param name="k2" type="Object"/>
                </params>
            </method>
            <javadoc line="1192">
                Test two values for equality.  Differs from o1.equals(o2) only in
                  that it copes with {@code null} o1 properly.                
            </javadoc>
            <method name="valEquals" type="boolean" line="1196">
                <params>
                    <param name="o1" type="Object"/>
                    <param name="o2" type="Object"/>
                </params>
            </method>
            <javadoc line="1200">
                Return SimpleImmutableEntry for entry, or null if null                
            </javadoc>
            <method name="exportEntry" type="Map.Entry<K,V>" line="1203">
                <params>
                    <param name="e" type="TreeMap.Entry<K,V>"/>
                </params>
            </method>
            <javadoc line="1208">
                Return key for entry, or null if null                
            </javadoc>
            <method name="keyOrNull" type="K" line="1211">
                <params>
                    <param name="e" type="TreeMap.Entry<K,V>"/>
                </params>
            </method>
            <javadoc line="1215">
                Returns the key corresponding to the specified Entry.                
                <throws>
                    NoSuchElementException if the Entry is null                    
                </throws>
            </javadoc>
            <method name="key" type="K" line="1219">
                <params>
                    <param name="e" type="Entry<K,?>"/>
                </params>
            </method>
            <declaration name="UNBOUNDED" type="Object" line="1228"/>
            <javadoc line="1228">
                Dummy value serving as unmatchable fence key for unbounded
                  SubMapIterators                
            </javadoc>
            <class name="NavigableSubMap" line="1234">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="AbstractMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <implements interface="NavigableMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <implements interface="java.io.Serializable"/>
                <javadoc line="1234">
                    @serial include                    
                </javadoc>
                <declaration name="m" type="TreeMap&lt;K,V&gt;" line="1239"/>
                <javadoc line="1239">
                    The backing map.                    
                </javadoc>
                <declaration name="lo" type="K" line="1244"/>
                <javadoc line="1244">
                    Endpoints are represented as triples (fromStart, lo,
                      loInclusive) and (toEnd, hi, hiInclusive). If fromStart is
                      true, then the low (absolute) bound is the start of the
                      backing map, and the other values are ignored. Otherwise,
                      if loInclusive is true, lo is the inclusive bound, else lo
                      is the exclusive bound. Similarly for the upper bound.                    
                </javadoc>
                <declaration name="fromStart" type="boolean" line="1253"/>
                <declaration name="loInclusive" type="boolean" line="1254"/>
                <method name="NavigableSubMap" type="constructor" line="1258">
                    <params>
                        <param name="m" type="TreeMap<K,V>"/>
                        <param name="fromStart" type="boolean"/>
                        <param name="lo" type="K"/>
                        <param name="loInclusive" type="boolean"/>
                        <param name="toEnd" type="boolean"/>
                        <param name="hi" type="K"/>
                        <param name="hiInclusive" type="boolean"/>
                    </params>
                    <comment line="1263">
                        type check                        
                    </comment>
                    <scope line="1259"/>
                    <scope line="1262"/>
                </method>
                <method name="tooLow" type="boolean" line="1280">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                    <scope line="1281">
                        <declaration name="c" type="int" line="1282"/>
                    </scope>
                </method>
                <method name="tooHigh" type="boolean" line="1289">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                    <scope line="1290">
                        <declaration name="c" type="int" line="1291"/>
                    </scope>
                </method>
                <method name="inRange" type="boolean" line="1298">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="inClosedRange" type="boolean" line="1302">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="inRange" type="boolean" line="1307">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="absLowest" type="TreeMap.Entry<K,V>" line="1317">
                    <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1318"/>
                </method>
                <method name="absHighest" type="TreeMap.Entry<K,V>" line="1325">
                    <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1326"/>
                </method>
                <method name="absCeiling" type="TreeMap.Entry<K,V>" line="1333">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                    <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1336"/>
                </method>
                <method name="absHigher" type="TreeMap.Entry<K,V>" line="1340">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                    <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1343"/>
                </method>
                <method name="absFloor" type="TreeMap.Entry<K,V>" line="1347">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                    <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1350"/>
                </method>
                <method name="absLower" type="TreeMap.Entry<K,V>" line="1354">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                    <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1357"/>
                </method>
                <javadoc line="1361">
                    Returns the absolute high fence for ascending traversal                    
                </javadoc>
                <method name="absHighFence" type="TreeMap.Entry<K,V>" line="1362"/>
                <javadoc line="1368">
                    Return the absolute low fence for descending traversal                    
                </javadoc>
                <method name="absLowFence" type="TreeMap.Entry<K,V>" line="1369"/>
                <method name="subLowest" type="TreeMap.Entry<K,V>" line="1378"/>
                <method name="subHighest" type="TreeMap.Entry<K,V>" line="1379"/>
                <method name="subCeiling" type="TreeMap.Entry<K,V>" line="1380"/>
                <method name="subHigher" type="TreeMap.Entry<K,V>" line="1381"/>
                <method name="subFloor" type="TreeMap.Entry<K,V>" line="1382"/>
                <method name="subLower" type="TreeMap.Entry<K,V>" line="1383"/>
                <method name="keyIterator" type="Iterator<K>" line="1385"/>
                <javadoc line="1385">
                    Returns ascending iterator from the perspective of this submap                    
                </javadoc>
                <method name="descendingKeyIterator" type="Iterator<K>" line="1388"/>
                <javadoc line="1388">
                    Returns descending iterator from the perspective of this submap                    
                </javadoc>
                <method name="isEmpty" type="boolean" line="1393"/>
                <method name="size" type="int" line="1397"/>
                <method name="containsKey" type="boolean" line="1401">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="put" type="V" line="1405">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                    </params>
                </method>
                <method name="get" type="V" line="1411">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="V" line="1415">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="ceilingEntry" type="Map.Entry<K,V>" line="1419">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="ceilingKey" type="K" line="1423">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="higherEntry" type="Map.Entry<K,V>" line="1427">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="higherKey" type="K" line="1431">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="floorEntry" type="Map.Entry<K,V>" line="1435">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="floorKey" type="K" line="1439">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="lowerEntry" type="Map.Entry<K,V>" line="1443">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="lowerKey" type="K" line="1447">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="firstKey" type="K" line="1451"/>
                <method name="lastKey" type="K" line="1455"/>
                <method name="firstEntry" type="Map.Entry<K,V>" line="1459"/>
                <method name="lastEntry" type="Map.Entry<K,V>" line="1463"/>
                <method name="pollFirstEntry" type="Map.Entry<K,V>" line="1467">
                    <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1468"/>
                    <declaration name="result" type="Map.Entry&lt;K,V&gt;" line="1469"/>
                </method>
                <method name="pollLastEntry" type="Map.Entry<K,V>" line="1475">
                    <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1476"/>
                    <declaration name="result" type="Map.Entry&lt;K,V&gt;" line="1477"/>
                </method>
                <declaration name="descendingMapView" type="NavigableMap&lt;K,V&gt;" line="1484"/>
                <declaration name="entrySetView" type="EntrySetView" line="1485"/>
                <declaration name="navigableKeySetView" type="KeySet&lt;K&gt;" line="1486"/>
                <method name="navigableKeySet" type="NavigableSet<K>" line="1488">
                    <declaration name="nksv" type="KeySet&lt;K&gt;" line="1489"/>
                </method>
                <method name="keySet" type="Set<K>" line="1494"/>
                <method name="descendingKeySet" type="NavigableSet<K>" line="1498"/>
                <method name="subMap" type="SortedMap<K,V>" line="1502">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="headMap" type="SortedMap<K,V>" line="1506">
                    <params>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="tailMap" type="SortedMap<K,V>" line="1510">
                    <params>
                        <param name="fromKey" type="K"/>
                    </params>
                </method>
                <class name="EntrySetView" line="1516">
                    <extends class="AbstractSet">
                        <type_params>
                            <type_param name="Map.Entry<K,V>"/>
                        </type_params>
                    </extends>
                    <declaration name="size" type="int" line="1517"/>
                    <method name="size" type="int" line="1519">
                        <scope line="1522">
                            <declaration name="i" type="Iterator" line="1525"/>
                            <scope line="1526"/>
                        </scope>
                    </method>
                    <method name="isEmpty" type="boolean" line="1534">
                        <declaration name="n" type="TreeMap.Entry&lt;K,V&gt;" line="1535"/>
                    </method>
                    <method name="contains" type="boolean" line="1539">
                        <params>
                            <param name="o" type="Object"/>
                        </params>
                        <declaration name="entry" type="Map.Entry&lt;K,V&gt;" line="1542"/>
                        <declaration name="key" type="K" line="1543"/>
                        <declaration name="node" type="TreeMap.Entry" line="1546"/>
                    </method>
                    <method name="remove" type="boolean" line="1551">
                        <params>
                            <param name="o" type="Object"/>
                        </params>
                        <declaration name="entry" type="Map.Entry&lt;K,V&gt;" line="1554"/>
                        <declaration name="key" type="K" line="1555"/>
                        <declaration name="node" type="TreeMap.Entry&lt;K,V&gt;" line="1558"/>
                        <scope line="1560"/>
                    </method>
                </class>
                <class name="SubMapIterator" line="1568">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                    <implements interface="Iterator">
                        <type_params>
                            <type_param name="T"/>
                        </type_params>
                    </implements>
                    <javadoc line="1568">
                        Iterators for SubMaps                        
                    </javadoc>
                    <declaration name="lastReturned" type="TreeMap.Entry&lt;K,V&gt;" line="1572"/>
                    <declaration name="next" type="TreeMap.Entry&lt;K,V&gt;" line="1573"/>
                    <declaration name="fenceKey" type="Object" line="1574"/>
                    <declaration name="expectedModCount" type="int" line="1575"/>
                    <method name="SubMapIterator" type="constructor" line="1578">
                        <params>
                            <param name="first" type="TreeMap.Entry<K,V>"/>
                            <param name="fence" type="TreeMap.Entry<K,V>"/>
                        </params>
                    </method>
                    <method name="hasNext" type="boolean" line="1585"/>
                    <method name="nextEntry" type="TreeMap.Entry<K,V>" line="1589">
                        <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1590"/>
                    </method>
                    <method name="prevEntry" type="TreeMap.Entry<K,V>" line="1600">
                        <declaration name="e" type="TreeMap.Entry&lt;K,V&gt;" line="1601"/>
                    </method>
                    <method name="removeAscending" type="void" line="1611">
                        <comment line="1616">
                            deleted entries are replaced by their successors                            
                        </comment>
                    </method>
                    <method name="removeDescending" type="void" line="1624"/>
                </class>
                <class name="SubMapEntryIterator" line="1636">
                    <extends class="SubMapIterator">
                        <type_params>
                            <type_param name="Map.Entry<K,V>"/>
                        </type_params>
                    </extends>
                    <method name="SubMapEntryIterator" type="constructor" line="1638">
                        <params>
                            <param name="first" type="TreeMap.Entry<K,V>"/>
                            <param name="fence" type="TreeMap.Entry<K,V>"/>
                        </params>
                    </method>
                    <method name="next" type="Map.Entry<K,V>" line="1641"/>
                    <method name="remove" type="void" line="1644"/>
                </class>
                <class name="SubMapKeyIterator" line="1649">
                    <extends class="SubMapIterator">
                        <type_params>
                            <type_param name="K"/>
                        </type_params>
                    </extends>
                    <method name="SubMapKeyIterator" type="constructor" line="1651">
                        <params>
                            <param name="first" type="TreeMap.Entry<K,V>"/>
                            <param name="fence" type="TreeMap.Entry<K,V>"/>
                        </params>
                    </method>
                    <method name="next" type="K" line="1654"/>
                    <method name="remove" type="void" line="1657"/>
                </class>
                <class name="DescendingSubMapEntryIterator" line="1662">
                    <extends class="SubMapIterator">
                        <type_params>
                            <type_param name="Map.Entry<K,V>"/>
                        </type_params>
                    </extends>
                    <method name="DescendingSubMapEntryIterator" type="constructor" line="1664">
                        <params>
                            <param name="last" type="TreeMap.Entry<K,V>"/>
                            <param name="fence" type="TreeMap.Entry<K,V>"/>
                        </params>
                    </method>
                    <method name="next" type="Map.Entry<K,V>" line="1668"/>
                    <method name="remove" type="void" line="1671"/>
                </class>
                <class name="DescendingSubMapKeyIterator" line="1676">
                    <extends class="SubMapIterator">
                        <type_params>
                            <type_param name="K"/>
                        </type_params>
                    </extends>
                    <method name="DescendingSubMapKeyIterator" type="constructor" line="1678">
                        <params>
                            <param name="last" type="TreeMap.Entry<K,V>"/>
                            <param name="fence" type="TreeMap.Entry<K,V>"/>
                        </params>
                    </method>
                    <method name="next" type="K" line="1681"/>
                    <method name="remove" type="void" line="1684"/>
                </class>
            </class>
            <class name="AscendingSubMap" line="1690">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="NavigableSubMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <javadoc line="1690">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1694"/>
                <method name="AscendingSubMap" type="constructor" line="1698">
                    <params>
                        <param name="m" type="TreeMap<K,V>"/>
                        <param name="fromStart" type="boolean"/>
                        <param name="lo" type="K"/>
                        <param name="loInclusive" type="boolean"/>
                        <param name="toEnd" type="boolean"/>
                        <param name="hi" type="K"/>
                        <param name="hiInclusive" type="boolean"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super K>" line="1702"/>
                <method name="subMap" type="NavigableMap<K,V>" line="1707">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="fromInclusive" type="boolean"/>
                        <param name="toKey" type="K"/>
                        <param name="toInclusive" type="boolean"/>
                    </params>
                </method>
                <method name="headMap" type="NavigableMap<K,V>" line="1717">
                    <params>
                        <param name="toKey" type="K"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="tailMap" type="NavigableMap<K,V>" line="1725">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="descendingMap" type="NavigableMap<K,V>" line="1733">
                    <declaration name="mv" type="NavigableMap&lt;K,V&gt;" line="1734"/>
                </method>
                <method name="keyIterator" type="Iterator<K>" line="1742"/>
                <method name="descendingKeyIterator" type="Iterator<K>" line="1746"/>
                <class name="AscendingEntrySetView" line="1750">
                    <extends class="EntrySetView"/>
                    <method name="iterator" type="Iterator<Map.Entry<K,V>>" line="1751"/>
                </class>
                <method name="entrySet" type="Set<Map.Entry<K,V>>" line="1756">
                    <declaration name="es" type="EntrySetView" line="1757"/>
                </method>
                <method name="subLowest" type="TreeMap.Entry<K,V>" line="1761"/>
                <method name="subHighest" type="TreeMap.Entry<K,V>" line="1762"/>
                <method name="subCeiling" type="TreeMap.Entry<K,V>" line="1763">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="subHigher" type="TreeMap.Entry<K,V>" line="1764">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="subFloor" type="TreeMap.Entry<K,V>" line="1765">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="subLower" type="TreeMap.Entry<K,V>" line="1766">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
            </class>
            <class name="DescendingSubMap" line="1769">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="NavigableSubMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <javadoc line="1769">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1773"/>
                <method name="DescendingSubMap" type="constructor" line="1776">
                    <params>
                        <param name="m" type="TreeMap<K,V>"/>
                        <param name="fromStart" type="boolean"/>
                        <param name="lo" type="K"/>
                        <param name="loInclusive" type="boolean"/>
                        <param name="toEnd" type="boolean"/>
                        <param name="hi" type="K"/>
                        <param name="hiInclusive" type="boolean"/>
                    </params>
                </method>
                <declaration name="reverseComparator" type="Comparator&lt;? super K&gt;" line="1780"/>
                <method name="comparator" type="Comparator<? super K>" line="1783"/>
                <method name="subMap" type="NavigableMap<K,V>" line="1788">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="fromInclusive" type="boolean"/>
                        <param name="toKey" type="K"/>
                        <param name="toInclusive" type="boolean"/>
                    </params>
                </method>
                <method name="headMap" type="NavigableMap<K,V>" line="1798">
                    <params>
                        <param name="toKey" type="K"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="tailMap" type="NavigableMap<K,V>" line="1806">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="descendingMap" type="NavigableMap<K,V>" line="1814">
                    <declaration name="mv" type="NavigableMap&lt;K,V&gt;" line="1815"/>
                </method>
                <method name="keyIterator" type="Iterator<K>" line="1823"/>
                <method name="descendingKeyIterator" type="Iterator<K>" line="1827"/>
                <class name="DescendingEntrySetView" line="1831">
                    <extends class="EntrySetView"/>
                    <method name="iterator" type="Iterator<Map.Entry<K,V>>" line="1832"/>
                </class>
                <method name="entrySet" type="Set<Map.Entry<K,V>>" line="1837">
                    <declaration name="es" type="EntrySetView" line="1838"/>
                </method>
                <method name="subLowest" type="TreeMap.Entry<K,V>" line="1842"/>
                <method name="subHighest" type="TreeMap.Entry<K,V>" line="1843"/>
                <method name="subCeiling" type="TreeMap.Entry<K,V>" line="1844">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="subHigher" type="TreeMap.Entry<K,V>" line="1845">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="subFloor" type="TreeMap.Entry<K,V>" line="1846">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="subLower" type="TreeMap.Entry<K,V>" line="1847">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
            </class>
            <class name="SubMap" line="1850">
                <extends class="AbstractMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <implements interface="SortedMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <implements interface="java.io.Serializable"/>
                <javadoc line="1850">
                    This class exists solely for the sake of serialization
                      compatibility with previous releases of TreeMap that did not
                      support NavigableMap.  It translates an old-version SubMap into
                      a new-version AscendingSubMap. This class is never otherwise
                      used.                    
                    <serial>
                        include                        
                    </serial>
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1861"/>
                <declaration name="fromStart" type="boolean" line="1862"/>
                <declaration name="fromKey" type="K" line="1863"/>
                <method name="readResolve" type="Object" line="1864"/>
                <method name="entrySet" type="Set<Map.Entry<K,V>>" line="1869"/>
                <method name="lastKey" type="K" line="1870"/>
                <method name="firstKey" type="K" line="1871"/>
                <method name="subMap" type="SortedMap<K,V>" line="1872">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="headMap" type="SortedMap<K,V>" line="1873">
                    <params>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="tailMap" type="SortedMap<K,V>" line="1874">
                    <params>
                        <param name="fromKey" type="K"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super K>" line="1875"/>
            </class>
            <declaration name="RED" type="boolean" line="1881"/>
            <declaration name="BLACK" type="boolean" line="1882"/>
            <class name="Entry" line="1884">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <comment line="1279">
                    internal utilities                    
                </comment>
                <comment line="1312">
                    Absolute versions of relation operations.
                     Subclasses map to these using like-named &quot;sub&quot;
                     versions that invert senses for descending maps                    
                </comment>
                <comment line="1376">
                    Abstract methods defined in ascending vs descending classes                    
                </comment>
                <comment line="1377">
                    These relay to the appropriate absolute versions                    
                </comment>
                <comment line="1392">
                    public methods                    
                </comment>
                <comment line="1484">
                    Views                    
                </comment>
                <comment line="1515">
                    View classes                    
                </comment>
                <implements interface="Map.Entry">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <javadoc line="1884">
                    Node in the Tree.  Doubles as a means to pass key-value pairs back to
                      user (see Map.Entry).                    
                </javadoc>
                <declaration name="key" type="K" line="1890"/>
                <declaration name="value" type="V" line="1891"/>
                <declaration name="left" type="Entry&lt;K,V&gt;" line="1892"/>
                <declaration name="right" type="Entry&lt;K,V&gt;" line="1893"/>
                <declaration name="parent" type="Entry&lt;K,V&gt;" line="1894"/>
                <declaration name="color" type="boolean" line="1895"/>
                <javadoc line="1897">
                    Make a new cell with given key, value, and parent, and with{@code null} child links, and BLACK color.                    
                </javadoc>
                <method name="Entry" type="constructor" line="1901">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                        <param name="parent" type="Entry<K,V>"/>
                    </params>
                </method>
                <javadoc line="1907">
                    Returns the key.                    
                    <return>
                        the key                        
                    </return>
                </javadoc>
                <method name="getKey" type="K" line="1912"/>
                <javadoc line="1916">
                    Returns the value associated with the key.                    
                    <return>
                        the value associated with the key                        
                    </return>
                </javadoc>
                <method name="getValue" type="V" line="1921"/>
                <javadoc line="1925">
                    Replaces the value currently associated with the key with the given
                      value.                    
                    <return>
                        the value associated with the key before this method was
                          called                        
                    </return>
                </javadoc>
                <method name="setValue" type="V" line="1932">
                    <params>
                        <param name="value" type="V"/>
                    </params>
                    <declaration name="oldValue" type="V" line="1933"/>
                </method>
                <method name="equals" type="boolean" line="1938">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="e" type="Map.Entry&lt;?,?&gt;" line="1941"/>
                </method>
                <method name="hashCode" type="int" line="1946">
                    <declaration name="keyHash" type="int" line="1947"/>
                    <declaration name="valueHash" type="int" line="1948"/>
                </method>
                <method name="toString" type="String" line="1952"/>
            </class>
            <javadoc line="1957">
                Returns the first Entry in the TreeMap (according to the TreeMap&apos;s
                  key-sort function).  Returns null if the TreeMap is empty.                
            </javadoc>
            <method name="getFirstEntry" type="Entry<K,V>" line="1961">
                <declaration name="p" type="Entry&lt;K,V&gt;" line="1962"/>
            </method>
            <javadoc line="1969">
                Returns the last Entry in the TreeMap (according to the TreeMap&apos;s
                  key-sort function).  Returns null if the TreeMap is empty.                
            </javadoc>
            <method name="getLastEntry" type="Entry<K,V>" line="1973">
                <declaration name="p" type="Entry&lt;K,V&gt;" line="1974"/>
            </method>
            <javadoc line="1981">
                Returns the successor of the specified Entry, or null if no such.                
            </javadoc>
            <method name="successor" type="TreeMap.Entry<K,V>" line="1984">
                <params>
                    <param name="t" type="Entry<K,V>"/>
                </params>
                <scope line="1987">
                    <declaration name="p" type="Entry&lt;K,V&gt;" line="1988"/>
                </scope>
                <scope line="1992">
                    <declaration name="p" type="Entry&lt;K,V&gt;" line="1993"/>
                    <declaration name="ch" type="Entry&lt;K,V&gt;" line="1994"/>
                    <scope line="1995"/>
                </scope>
            </method>
            <javadoc line="2003">
                Returns the predecessor of the specified Entry, or null if no such.                
            </javadoc>
            <method name="predecessor" type="Entry<K,V>" line="2006">
                <params>
                    <param name="t" type="Entry<K,V>"/>
                </params>
                <scope line="2009">
                    <declaration name="p" type="Entry&lt;K,V&gt;" line="2010"/>
                </scope>
                <scope line="2014">
                    <declaration name="p" type="Entry&lt;K,V&gt;" line="2015"/>
                    <declaration name="ch" type="Entry&lt;K,V&gt;" line="2016"/>
                    <scope line="2017"/>
                </scope>
            </method>
            <javadoc line="2025">
                Balancing operations.
                  Implementations of rebalancings during insertion and deletion are
                  slightly different than the CLR version.  Rather than using dummy
                  nilnodes, we use a set of accessors that deal properly with null.  They
                  are used to avoid messiness surrounding nullness checks in the main
                  algorithms.                
            </javadoc>
            <method name="colorOf" type="boolean" line="2035">
                <params>
                    <param name="p" type="Entry<K,V>"/>
                </params>
            </method>
            <method name="parentOf" type="Entry<K,V>" line="2039">
                <params>
                    <param name="p" type="Entry<K,V>"/>
                </params>
            </method>
            <method name="setColor" type="void" line="2043">
                <params>
                    <param name="p" type="Entry<K,V>"/>
                    <param name="c" type="boolean"/>
                </params>
            </method>
            <method name="leftOf" type="Entry<K,V>" line="2048">
                <params>
                    <param name="p" type="Entry<K,V>"/>
                </params>
            </method>
            <method name="rightOf" type="Entry<K,V>" line="2052">
                <params>
                    <param name="p" type="Entry<K,V>"/>
                </params>
            </method>
            <javadoc line="2056">
                From CLR                
            </javadoc>
            <method name="rotateLeft" type="void" line="2057">
                <params>
                    <param name="p" type="Entry<K,V>"/>
                </params>
                <scope line="2058">
                    <declaration name="r" type="Entry&lt;K,V&gt;" line="2059"/>
                </scope>
            </method>
            <javadoc line="2075">
                From CLR                
            </javadoc>
            <method name="rotateRight" type="void" line="2076">
                <params>
                    <param name="p" type="Entry<K,V>"/>
                </params>
                <scope line="2077">
                    <declaration name="l" type="Entry&lt;K,V&gt;" line="2078"/>
                </scope>
            </method>
            <javadoc line="2092">
                From CLR                
            </javadoc>
            <method name="fixAfterInsertion" type="void" line="2093">
                <params>
                    <param name="x" type="Entry<K,V>"/>
                </params>
                <scope line="2096">
                    <scope line="2097">
                        <declaration name="y" type="Entry&lt;K,V&gt;" line="2098"/>
                        <scope line="2099"/>
                        <scope line="2104">
                            <scope line="2105"/>
                        </scope>
                    </scope>
                    <scope line="2113">
                        <declaration name="y" type="Entry&lt;K,V&gt;" line="2114"/>
                        <scope line="2115"/>
                        <scope line="2120">
                            <scope line="2121"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="2134">
                Delete node p, and then rebalance the tree.                
            </javadoc>
            <method name="deleteEntry" type="void" line="2137">
                <params>
                    <param name="p" type="Entry<K,V>"/>
                </params>
                <comment line="2141">
                    If strictly internal, copy successor&apos;s element to p and then make p                    
                </comment>
                <comment line="2142">
                    point to successor.                    
                </comment>
                <comment line="2148">
                    p has 2 children                    
                </comment>
                <comment line="2150">
                    Start fixup at replacement node, if it exists.                    
                </comment>
                <comment line="2154">
                    Link replacement to parent                    
                </comment>
                <comment line="2163">
                    Null out links so they are OK to use by fixAfterDeletion.                    
                </comment>
                <comment line="2166">
                    Fix replacement                    
                </comment>
                <comment line="2169">
                    return if we are the only node.                    
                </comment>
                <comment line="2171">
                    No children. Use self as phantom replacement and unlink.                    
                </comment>
                <scope line="2143">
                    <declaration name="s" type="Entry&lt;K,V&gt;" line="2144"/>
                </scope>
                <declaration name="replacement" type="Entry&lt;K,V&gt;" line="2151"/>
                <scope line="2153"/>
                <scope line="2169"/>
                <scope line="2171">
                    <scope line="2175"/>
                </scope>
            </method>
            <javadoc line="2185">
                From CLR                
            </javadoc>
            <method name="fixAfterDeletion" type="void" line="2186">
                <params>
                    <param name="x" type="Entry<K,V>"/>
                </params>
                <comment line="2215">
                    symmetric                    
                </comment>
                <scope line="2187">
                    <scope line="2188">
                        <declaration name="sib" type="Entry&lt;K,V&gt;" line="2189"/>
                        <scope line="2191"/>
                        <scope line="2199"/>
                        <scope line="2202">
                            <scope line="2203"/>
                        </scope>
                    </scope>
                    <scope line="2215">
                        <declaration name="sib" type="Entry&lt;K,V&gt;" line="2216"/>
                        <scope line="2218"/>
                        <scope line="2226"/>
                        <scope line="2229">
                            <scope line="2230"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <declaration name="serialVersionUID" type="long" line="2248"/>
            <javadoc line="2250">
                Save the state of the {@code TreeMap} instance to a stream (i.e.,
                  serialize it).                
                <serialData>
                    The <em>size</em> of the TreeMap (the number of key-value
                      mappings) is emitted (int), followed by the key (Object)
                      and value (Object) for each key-value mapping represented
                      by the TreeMap. The key-value mappings are emitted in
                      key-order (as determined by the TreeMap's Comparator,
                      or by the keys' natural ordering if the TreeMap has no
                      Comparator).                    
                </serialData>
            </javadoc>
            <method name="writeObject" type="void" line="2263">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <comment line="2264">
                    Write out the Comparator and any hidden stuff                    
                </comment>
                <comment line="2267">
                    Write out size (number of Mappings)                    
                </comment>
                <comment line="2270">
                    Write out keys and values (alternating)                    
                </comment>
                <scope line="2271">
                    <declaration name="e" type="Map.Entry&lt;K,V&gt;" line="2272"/>
                </scope>
            </method>
            <javadoc line="2278">
                Reconstitute the {@code TreeMap} instance from a stream (i.e.,
                  deserialize it).                
            </javadoc>
            <method name="readObject" type="void" line="2283">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="2284">
                    Read in the Comparator and any hidden stuff                    
                </comment>
                <comment line="2287">
                    Read in size                    
                </comment>
                <declaration name="size" type="int" line="2288"/>
            </method>
            <javadoc line="2293">
                Intended to be called only from TreeSet.readObject                
            </javadoc>
            <method name="readTreeSet" type="void" line="2295">
                <params>
                    <param name="size" type="int"/>
                    <param name="s" type="java.io.ObjectInputStream"/>
                    <param name="defaultVal" type="V"/>
                </params>
            </method>
            <javadoc line="2299">
                Intended to be called only from TreeSet.addAll                
            </javadoc>
            <method name="addAllForTreeSet" type="void" line="2300">
                <params>
                    <param name="set" type="SortedSet<? extends K>"/>
                    <param name="defaultVal" type="V"/>
                </params>
                <scope line="2301"/>
                <scope line="2303"/>
                <scope line="2304"/>
            </method>
            <javadoc line="2309">
                Linear time tree building algorithm from sorted data.  Can accept keys
                  and/or values from iterator or stream. This leads to too many
                  parameters, but seems better than alternatives.  The four formats
                  that this method accepts are:
                  1) An iterator of Map.Entries.  (it != null, defaultVal == null).
                  2) An iterator of keys.         (it != null, defaultVal != null).
                  3) A stream of alternating serialized keys and values.
                  (it == null, defaultVal == null).
                  4) A stream of serialized keys. (it == null, defaultVal != null).
                  It is assumed that the comparator of the TreeMap is already set prior
                  to calling this method.                
                <param>
                    size the number of keys (or key-value pairs) to be read from
                      the iterator or stream                    
                </param>
                <param>
                    it If non-null, new entries are created from entries
                      or keys read from this iterator.                    
                </param>
                <param>
                    str If non-null, new entries are created from keys and
                      possibly values read from this stream in serialized form.
                      Exactly one of it and str should be non-null.                    
                </param>
                <param>
                    defaultVal if non-null, this default value is used for
                      each value in the map.  If null, each value is read from
                      iterator or stream, as described above.                    
                </param>
                <throws>
                    IOException propagated from stream reads. This cannot
                      occur if str is null.                    
                </throws>
                <throws>
                    ClassNotFoundException propagated from readObject.
                      This cannot occur if str is null.                    
                </throws>
            </javadoc>
            <method name="buildFromSorted" type="void" line="2342">
                <params>
                    <param name="size" type="int"/>
                    <param name="it" type="Iterator"/>
                    <param name="str" type="java.io.ObjectInputStream"/>
                    <param name="defaultVal" type="V"/>
                </params>
            </method>
            <javadoc line="2348">
                Recursive &quot;helper method&quot; that does the real work of the
                  previous method.  Identically named parameters have
                  identical definitions.  Additional parameters are documented below.
                  It is assumed that the comparator and size fields of the TreeMap are
                  already set prior to calling this method.  (It ignores both fields.)                
                <param>
                    level the current level of tree. Initial call should be 0.                    
                </param>
                <param>
                    lo the first element index of this subtree. Initial should be 0.                    
                </param>
                <param>
                    hi the last element index of this subtree.  Initial should be
                      size-1.                    
                </param>
                <param>
                    redLevel the level at which nodes should be red.
                      Must be equal to computeRedLevel for tree of this size.                    
                </param>
            </javadoc>
            <method name="buildFromSorted" type="Entry<K,V>" line="2367">
                <params>
                    <param name="level" type="int"/>
                    <param name="lo" type="int"/>
                    <param name="hi" type="int"/>
                    <param name="redLevel" type="int"/>
                    <param name="it" type="Iterator"/>
                    <param name="str" type="java.io.ObjectInputStream"/>
                    <param name="defaultVal" type="V"/>
                </params>
                <comment line="2368">
                    Strategy: The root is the middlemost element. To get to it, we
                     have to first recursively construct the entire left subtree,
                     so as to grab all of its elements. We can then proceed with right
                     subtree.
                    
                     The lo and hi arguments are the minimum and maximum
                     indices to pull out of the iterator or stream for current subtree.
                     They are not actually indexed, we just proceed sequentially,
                     ensuring that items are extracted in corresponding order.                    
                </comment>
                <comment line="2389">
                    extract key and/or value from iterator or stream                    
                </comment>
                <comment line="2401">
                    use stream                    
                </comment>
                <comment line="2408">
                    color nodes in non-full bottommost level red                    
                </comment>
                <declaration name="mid" type="int" line="2382"/>
                <declaration name="left" type="Entry&lt;K,V&gt;" line="2384"/>
                <declaration name="key" type="K" line="2390"/>
                <declaration name="value" type="V" line="2391"/>
                <scope line="2392">
                    <scope line="2393">
                        <declaration name="entry" type="Map.Entry&lt;K,V&gt;" line="2394"/>
                    </scope>
                    <scope line="2397"/>
                </scope>
                <scope line="2401"/>
                <declaration name="middle" type="Entry&lt;K,V&gt;" line="2406"/>
                <scope line="2412"/>
                <scope line="2417">
                    <declaration name="right" type="Entry&lt;K,V&gt;" line="2418"/>
                </scope>
            </method>
            <javadoc line="2427">
                Find the level down to which to assign all nodes BLACK.  This is the
                  last `full&apos; level of the complete binary tree produced by
                  buildTree. The remaining nodes are colored RED. (This makes a `nice&apos;
                  set of color assignments wrt future insertions.) This level number is
                  computed by finding the number of splits needed to reach the zeroeth
                  node.  (The answer is ~lg(N), but in any case must be computed by same
                  quick O(lg(N)) loop.)                
            </javadoc>
            <method name="computeRedLevel" type="int" line="2436">
                <params>
                    <param name="sz" type="int"/>
                </params>
                <declaration name="level" type="int" line="2437"/>
            </method>
        </class>
    </source>