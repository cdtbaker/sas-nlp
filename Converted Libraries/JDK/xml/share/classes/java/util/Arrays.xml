<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <import package="java.lang.reflect"/>
        <class name="Arrays" line="30">
            <comment line="58">
                Suppresses default constructor, ensuring non-instantiability.                
            </comment>
            <comment line="61">
                Sorting of primitive type arrays.                
            </comment>
            <comment line="377">
                Sorting of complex type arrays.                
            </comment>
            <comment line="394">
                If this platform has an optimizing VM, check whether ComparableTimSort
                 offers any performance benefit over TimSort in conjunction with a
                 comparator that returns:
                    {@code ((Comparable)first).compareTo(Second)}.
                 If not, you are better off deleting ComparableTimSort to
                 eliminate the code duplication.  In other words, the commented
                 out code below is the preferable implementation for sorting
                 arrays of Comparables if it offers sufficient performance.                
            </comment>
            <comment line="405">
                /**
                     * A comparator that implements the natural ordering of a group of
                     * mutually comparable elements.  Using this comparator saves us
                     * from duplicating most of the code in this file (one version for
                     * Comparables, one for explicit Comparators).
                     */
                    private static final Comparator&lt;Object&gt; NATURAL_ORDER =
                            new Comparator&lt;Object&gt;() {
                        @SuppressWarnings(&quot;unchecked&quot;)
                        public int compare(Object first, Object second) {
                            return ((Comparable&lt;Object&gt;)first).compareTo(second);
                        }
                    };
                
                    public static void sort(Object[] a) {
                        sort(a, 0, a.length, NATURAL_ORDER);
                    }
                
                    public static void sort(Object[] a, int fromIndex, int toIndex) {
                        sort(a, fromIndex, toIndex, NATURAL_ORDER);
                    }                
            </comment>
            <comment line="806">
                Searching                
            </comment>
            <comment line="869">
                Like public version, but without range checks.                
            </comment>
            <comment line="950">
                Like public version, but without range checks.                
            </comment>
            <comment line="1031">
                Like public version, but without range checks.                
            </comment>
            <comment line="1112">
                Like public version, but without range checks.                
            </comment>
            <comment line="1193">
                Like public version, but without range checks.                
            </comment>
            <comment line="1276">
                Like public version, but without range checks.                
            </comment>
            <comment line="1367">
                Like public version, but without range checks.                
            </comment>
            <comment line="1473">
                Like public version, but without range checks.                
            </comment>
            <comment line="1574">
                Like public version, but without range checks.                
            </comment>
            <comment line="1597">
                Equality Testing                
            </comment>
            <comment line="1877">
                Filling                
            </comment>
            <comment line="2199">
                Cloning                
            </comment>
            <comment line="2809">
                Misc                
            </comment>
            <javadoc line="30">
                This class contains various methods for manipulating arrays (such as
                  sorting and searching). This class also contains a static factory
                  that allows arrays to be viewed as lists.
                  &lt;p&gt;The methods in this class all throw a {@code NullPointerException},
                  if the specified array reference is null, except where noted.
                  &lt;p&gt;The documentation for the methods contained in this class includes
                  briefs description of the &lt;i&gt;implementations&lt;/i&gt;. Such descriptions should
                  be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than parts of the
                  &lt;i&gt;specification&lt;/i&gt;. Implementors should feel free to substitute other
                  algorithms, so long as the specification itself is adhered to. (For
                  example, the algorithm used by {@code sort(Object[])} does not have to be
                  a MergeSort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <author>
                    Josh Bloch                    
                </author>
                <author>
                    Neal Gafter                    
                </author>
                <author>
                    John Rose                    
                </author>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="Arrays" type="constructor" line="58"/>
            <javadoc line="64">
                Sorts the specified array into ascending numerical order.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
            </javadoc>
            <method name="sort" type="void" line="75">
                <params>
                    <param name="a" type="int[]"/>
                </params>
            </method>
            <javadoc line="79">
                Sorts the specified range of the array into ascending order. The range
                  to be sorted extends from the index {@code fromIndex}, inclusive, to
                  the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
                  the range to be sorted is empty.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    fromIndex the index of the first element, inclusive, to be sorted                    
                </param>
                <param>
                    toIndex the index of the last element, exclusive, to be sorted                    
                </param>
                <throws>
                    IllegalArgumentException if {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0} or {@code toIndex > a.length}                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="99">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="104">
                Sorts the specified array into ascending numerical order.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
            </javadoc>
            <method name="sort" type="void" line="115">
                <params>
                    <param name="a" type="long[]"/>
                </params>
            </method>
            <javadoc line="119">
                Sorts the specified range of the array into ascending order. The range
                  to be sorted extends from the index {@code fromIndex}, inclusive, to
                  the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
                  the range to be sorted is empty.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    fromIndex the index of the first element, inclusive, to be sorted                    
                </param>
                <param>
                    toIndex the index of the last element, exclusive, to be sorted                    
                </param>
                <throws>
                    IllegalArgumentException if {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0} or {@code toIndex > a.length}                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="139">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="144">
                Sorts the specified array into ascending numerical order.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
            </javadoc>
            <method name="sort" type="void" line="155">
                <params>
                    <param name="a" type="short[]"/>
                </params>
            </method>
            <javadoc line="159">
                Sorts the specified range of the array into ascending order. The range
                  to be sorted extends from the index {@code fromIndex}, inclusive, to
                  the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
                  the range to be sorted is empty.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    fromIndex the index of the first element, inclusive, to be sorted                    
                </param>
                <param>
                    toIndex the index of the last element, exclusive, to be sorted                    
                </param>
                <throws>
                    IllegalArgumentException if {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0} or {@code toIndex > a.length}                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="179">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="184">
                Sorts the specified array into ascending numerical order.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
            </javadoc>
            <method name="sort" type="void" line="195">
                <params>
                    <param name="a" type="char[]"/>
                </params>
            </method>
            <javadoc line="199">
                Sorts the specified range of the array into ascending order. The range
                  to be sorted extends from the index {@code fromIndex}, inclusive, to
                  the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
                  the range to be sorted is empty.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    fromIndex the index of the first element, inclusive, to be sorted                    
                </param>
                <param>
                    toIndex the index of the last element, exclusive, to be sorted                    
                </param>
                <throws>
                    IllegalArgumentException if {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0} or {@code toIndex > a.length}                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="219">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="224">
                Sorts the specified array into ascending numerical order.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
            </javadoc>
            <method name="sort" type="void" line="235">
                <params>
                    <param name="a" type="byte[]"/>
                </params>
            </method>
            <javadoc line="239">
                Sorts the specified range of the array into ascending order. The range
                  to be sorted extends from the index {@code fromIndex}, inclusive, to
                  the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
                  the range to be sorted is empty.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    fromIndex the index of the first element, inclusive, to be sorted                    
                </param>
                <param>
                    toIndex the index of the last element, exclusive, to be sorted                    
                </param>
                <throws>
                    IllegalArgumentException if {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0} or {@code toIndex > a.length}                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="259">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="264">
                Sorts the specified array into ascending numerical order.
                  &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
                  values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}value compares neither less than, greater than, nor equal to any value,
                  even itself. This method uses the total order imposed by the method{@link Float#compareTo}: {@code -0.0f} is treated as less than value{@code 0.0f} and {@code Float.NaN} is considered greater than any
                  other value and all {@code Float.NaN} values are considered equal.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
            </javadoc>
            <method name="sort" type="void" line="283">
                <params>
                    <param name="a" type="float[]"/>
                </params>
            </method>
            <javadoc line="287">
                Sorts the specified range of the array into ascending order. The range
                  to be sorted extends from the index {@code fromIndex}, inclusive, to
                  the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
                  the range to be sorted is empty.
                  &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
                  values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}value compares neither less than, greater than, nor equal to any value,
                  even itself. This method uses the total order imposed by the method{@link Float#compareTo}: {@code -0.0f} is treated as less than value{@code 0.0f} and {@code Float.NaN} is considered greater than any
                  other value and all {@code Float.NaN} values are considered equal.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    fromIndex the index of the first element, inclusive, to be sorted                    
                </param>
                <param>
                    toIndex the index of the last element, exclusive, to be sorted                    
                </param>
                <throws>
                    IllegalArgumentException if {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0} or {@code toIndex > a.length}                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="315">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="320">
                Sorts the specified array into ascending numerical order.
                  &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
                  values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}value compares neither less than, greater than, nor equal to any value,
                  even itself. This method uses the total order imposed by the method{@link Double#compareTo}: {@code -0.0d} is treated as less than value{@code 0.0d} and {@code Double.NaN} is considered greater than any
                  other value and all {@code Double.NaN} values are considered equal.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
            </javadoc>
            <method name="sort" type="void" line="339">
                <params>
                    <param name="a" type="double[]"/>
                </params>
            </method>
            <javadoc line="343">
                Sorts the specified range of the array into ascending order. The range
                  to be sorted extends from the index {@code fromIndex}, inclusive, to
                  the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
                  the range to be sorted is empty.
                  &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
                  values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}value compares neither less than, greater than, nor equal to any value,
                  even itself. This method uses the total order imposed by the method{@link Double#compareTo}: {@code -0.0d} is treated as less than value{@code 0.0d} and {@code Double.NaN} is considered greater than any
                  other value and all {@code Double.NaN} values are considered equal.
                  &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
                  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
                  offers O(n log(n)) performance on many data sets that cause other
                  quicksorts to degrade to quadratic performance, and is typically
                  faster than traditional (one-pivot) Quicksort implementations.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    fromIndex the index of the first element, inclusive, to be sorted                    
                </param>
                <param>
                    toIndex the index of the last element, exclusive, to be sorted                    
                </param>
                <throws>
                    IllegalArgumentException if {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0} or {@code toIndex > a.length}                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="371">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <class name="LegacyMergeSort" line="380">
                <javadoc line="380">
                    Old merge sort implementation can be selected (for
                      compatibility with broken comparators) using a system property.
                      Cannot be a static boolean in the enclosing class due to
                      circular dependencies. To be removed in a future release.                    
                </javadoc>
                <declaration name="userRequested" type="boolean" line="387"/>
            </class>
            <javadoc line="426">
                Sorts the specified array of objects into ascending order, according
                  to the {@linkplain Comparable natural ordering} of its elements.
                  All elements in the array must implement the {@link Comparable}interface.  Furthermore, all elements in the array must be
                  &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must
                  not throw a {@code ClassCastException} for any elements {@code e1}and {@code e2} in the array).
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.
                  &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
                  iterative mergesort that requires far fewer than n lg(n) comparisons
                  when the input array is partially sorted, while offering the
                  performance of a traditional mergesort when the input array is
                  randomly ordered.  If the input array is nearly sorted, the
                  implementation requires approximately n comparisons.  Temporary
                  storage requirements vary from a small constant for nearly sorted
                  input arrays to n/2 object references for randomly ordered input
                  arrays.
                  &lt;p&gt;The implementation takes equal advantage of ascending and
                  descending order in its input array, and can take advantage of
                  ascending and descending order in different parts of the the same
                  input array.  It is well-suited to merging two or more sorted arrays:
                  simply concatenate the arrays and sort the resulting array.
                  &lt;p&gt;The implementation was adapted from Tim Peters&apos;s list sort for Python
                  (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
                  TimSort&lt;/a&gt;).  It uses techiques from Peter McIlroy&apos;s &quot;Optimistic
                  Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
                  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
                  January 1993.                
                <param>
                    a the array to be sorted                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      <i>mutually comparable</i> (for example, strings and integers)                    
                </throws>
                <throws>
                    IllegalArgumentException (optional) if the natural
                      ordering of the array elements is found to violate the{@link Comparable} contract                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="468">
                <params>
                    <param name="a" type="Object[]"/>
                </params>
            </method>
            <javadoc line="475">
                To be removed in a future release.                
            </javadoc>
            <method name="legacyMergeSort" type="void" line="476">
                <params>
                    <param name="a" type="Object[]"/>
                </params>
                <declaration name="aux" type="Object[]" line="477"/>
            </method>
            <javadoc line="481">
                Sorts the specified range of the specified array of objects into
                  ascending order, according to the{@linkplain Comparable natural ordering} of its
                  elements.  The range to be sorted extends from index{@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.
                  (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All
                  elements in this range must implement the {@link Comparable}interface.  Furthermore, all elements in this range must be &lt;i&gt;mutually
                  comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must not throw a{@code ClassCastException} for any elements {@code e1} and{@code e2} in the array).
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.
                  &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
                  iterative mergesort that requires far fewer than n lg(n) comparisons
                  when the input array is partially sorted, while offering the
                  performance of a traditional mergesort when the input array is
                  randomly ordered.  If the input array is nearly sorted, the
                  implementation requires approximately n comparisons.  Temporary
                  storage requirements vary from a small constant for nearly sorted
                  input arrays to n/2 object references for randomly ordered input
                  arrays.
                  &lt;p&gt;The implementation takes equal advantage of ascending and
                  descending order in its input array, and can take advantage of
                  ascending and descending order in different parts of the the same
                  input array.  It is well-suited to merging two or more sorted arrays:
                  simply concatenate the arrays and sort the resulting array.
                  &lt;p&gt;The implementation was adapted from Tim Peters&apos;s list sort for Python
                  (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
                  TimSort&lt;/a&gt;).  It uses techiques from Peter McIlroy&apos;s &quot;Optimistic
                  Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
                  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
                  January 1993.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted                    
                </param>
                <throws>
                    IllegalArgumentException if {@code fromIndex > toIndex} or
                      (optional) if the natural ordering of the array elements is
                      found to violate the {@link Comparable} contract                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or{@code toIndex > a.length}                    
                </throws>
                <throws>
                    ClassCastException if the array contains elements that are
                      not <i>mutually comparable</i> (for example, strings and
                      integers).                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="533">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
            </method>
            <javadoc line="540">
                To be removed in a future release.                
            </javadoc>
            <method name="legacyMergeSort" type="void" line="542">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <declaration name="aux" type="Object[]" line="544"/>
            </method>
            <declaration name="INSERTIONSORT_THRESHOLD" type="int" line="548"/>
            <javadoc line="548">
                Tuning parameter: list size at or below which insertion sort will be
                  used in preference to mergesort.
                  To be removed in a future release.                
            </javadoc>
            <javadoc line="555">
                Src is the source array that starts at index 0
                  Dest is the (possibly larger) array destination with a possible offset
                  low is the index in dest to start sorting
                  high is the end index in dest to end sorting
                  off is the offset to generate corresponding low, high in src
                  To be removed in a future release.                
            </javadoc>
            <method name="mergeSort" type="void" line="567">
                <params>
                    <param name="src" type="Object[]"/>
                    <param name="dest" type="Object[]"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                    <param name="off" type="int"/>
                </params>
                <comment line="571">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="580">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="589">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="596">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="568"/>
                <scope line="571"/>
                <declaration name="destLow" type="int" line="580"/>
                <declaration name="destHigh" type="int" line="581"/>
                <declaration name="mid" type="int" line="584"/>
                <scope line="590"/>
                <scope line="596"/>
            </method>
            <javadoc line="604">
                Swaps x[a] with x[b].                
            </javadoc>
            <method name="swap" type="void" line="607">
                <params>
                    <param name="x" type="Object[]"/>
                    <param name="a" type="int"/>
                    <param name="b" type="int"/>
                </params>
                <declaration name="t" type="Object" line="608"/>
            </method>
            <javadoc line="613">
                Sorts the specified array of objects according to the order induced by
                  the specified comparator.  All elements in the array must be
                  &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,{@code c.compare(e1, e2)} must not throw a {@code ClassCastException}for any elements {@code e1} and {@code e2} in the array).
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.
                  &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
                  iterative mergesort that requires far fewer than n lg(n) comparisons
                  when the input array is partially sorted, while offering the
                  performance of a traditional mergesort when the input array is
                  randomly ordered.  If the input array is nearly sorted, the
                  implementation requires approximately n comparisons.  Temporary
                  storage requirements vary from a small constant for nearly sorted
                  input arrays to n/2 object references for randomly ordered input
                  arrays.
                  &lt;p&gt;The implementation takes equal advantage of ascending and
                  descending order in its input array, and can take advantage of
                  ascending and descending order in different parts of the the same
                  input array.  It is well-suited to merging two or more sorted arrays:
                  simply concatenate the arrays and sort the resulting array.
                  &lt;p&gt;The implementation was adapted from Tim Peters&apos;s list sort for Python
                  (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
                  TimSort&lt;/a&gt;).  It uses techiques from Peter McIlroy&apos;s &quot;Optimistic
                  Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
                  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
                  January 1993.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    c the comparator to determine the order of the array.  A{@code null} value indicates that the elements'{@linkplain Comparable natural ordering} should be used.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are
                      not <i>mutually comparable</i> using the specified comparator                    
                </throws>
                <throws>
                    IllegalArgumentException (optional) if the comparator is
                      found to violate the {@link Comparator} contract                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="655">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
            </method>
            <javadoc line="662">
                To be removed in a future release.                
            </javadoc>
            <method name="legacyMergeSort" type="void" line="663">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <declaration name="aux" type="T[]" line="664"/>
            </method>
            <javadoc line="671">
                Sorts the specified range of the specified array of objects according
                  to the order induced by the specified comparator.  The range to be
                  sorted extends from index {@code fromIndex}, inclusive, to index{@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
                  range to be sorted is empty.)  All elements in the range must be
                  &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,{@code c.compare(e1, e2)} must not throw a {@code ClassCastException}for any elements {@code e1} and {@code e2} in the range).
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.
                  &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
                  iterative mergesort that requires far fewer than n lg(n) comparisons
                  when the input array is partially sorted, while offering the
                  performance of a traditional mergesort when the input array is
                  randomly ordered.  If the input array is nearly sorted, the
                  implementation requires approximately n comparisons.  Temporary
                  storage requirements vary from a small constant for nearly sorted
                  input arrays to n/2 object references for randomly ordered input
                  arrays.
                  &lt;p&gt;The implementation takes equal advantage of ascending and
                  descending order in its input array, and can take advantage of
                  ascending and descending order in different parts of the the same
                  input array.  It is well-suited to merging two or more sorted arrays:
                  simply concatenate the arrays and sort the resulting array.
                  &lt;p&gt;The implementation was adapted from Tim Peters&apos;s list sort for Python
                  (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
                  TimSort&lt;/a&gt;).  It uses techiques from Peter McIlroy&apos;s &quot;Optimistic
                  Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
                  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
                  January 1993.                
                <param>
                    a the array to be sorted                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      sorted                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be sorted                    
                </param>
                <param>
                    c the comparator to determine the order of the array.  A{@code null} value indicates that the elements'{@linkplain Comparable natural ordering} should be used.                    
                </param>
                <throws>
                    ClassCastException if the array contains elements that are not
                      <i>mutually comparable</i> using the specified comparator.                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code fromIndex > toIndex} or
                      (optional) if the comparator is found to violate the{@link Comparator} contract                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or{@code toIndex > a.length}                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="723">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
            </method>
            <javadoc line="730">
                To be removed in a future release.                
            </javadoc>
            <method name="legacyMergeSort" type="void" line="732">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <declaration name="aux" type="T[]" line="734"/>
            </method>
            <javadoc line="741">
                Src is the source array that starts at index 0
                  Dest is the (possibly larger) array destination with a possible offset
                  low is the index in dest to start sorting
                  high is the end index in dest to end sorting
                  off is the offset into src corresponding to low in dest
                  To be removed in a future release.                
            </javadoc>
            <method name="mergeSort" type="void" line="752">
                <params>
                    <param name="src" type="Object[]"/>
                    <param name="dest" type="Object[]"/>
                    <param name="low" type="int"/>
                    <param name="high" type="int"/>
                    <param name="off" type="int"/>
                    <param name="c" type="Comparator"/>
                </params>
                <comment line="756">
                    Insertion sort on smallest arrays                    
                </comment>
                <comment line="764">
                    Recursively sort halves of dest into src                    
                </comment>
                <comment line="773">
                    If list is already sorted, just copy from src to dest.  This is an
                     optimization that results in faster sorts for nearly ordered lists.                    
                </comment>
                <comment line="780">
                    Merge sorted halves (now in src) into dest                    
                </comment>
                <declaration name="length" type="int" line="753"/>
                <scope line="756"/>
                <declaration name="destLow" type="int" line="764"/>
                <declaration name="destHigh" type="int" line="765"/>
                <declaration name="mid" type="int" line="768"/>
                <scope line="774"/>
                <scope line="780"/>
            </method>
            <javadoc line="788">
                Checks that {@code fromIndex} and {@code toIndex} are in
                  the range and throws an appropriate exception, if they aren&apos;t.                
            </javadoc>
            <method name="rangeCheck" type="void" line="792">
                <params>
                    <param name="length" type="int"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                </params>
                <scope line="793"/>
                <scope line="797"/>
                <scope line="800"/>
            </method>
            <javadoc line="807">
                Searches the specified array of longs for the specified value using the
                  binary search algorithm.  The array must be sorted (as
                  by the {@link #sort(long[])} method) prior to making this call.  If it
                  is not sorted, the results are undefined.  If the array contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element greater than the key, or <tt>a.length</tt> if all
                      elements in the array are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
            </javadoc>
            <method name="binarySearch" type="int" line="826">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="key" type="long"/>
                </params>
            </method>
            <javadoc line="830">
                Searches a range of
                  the specified array of longs for the specified value using the
                  binary search algorithm.
                  The range must be sorted (as
                  by the {@link #sort(long[],int,int)} method)
                  prior to making this call.  If it
                  is not sorted, the results are undefined.  If the range contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      searched                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array
                      within the specified range;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element in the range greater than the key,
                      or <tt>toIndex</tt> if all
                      elements in the range are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0 or toIndex > a.length}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="binarySearch" type="int" line="863">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="long"/>
                </params>
            </method>
            <method name="binarySearch0" type="int" line="870">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="long"/>
                </params>
                <comment line="884">
                    key found                    
                </comment>
                <comment line="886">
                    key not found.                    
                </comment>
                <declaration name="low" type="int" line="871"/>
                <declaration name="high" type="int" line="872"/>
                <scope line="874">
                    <declaration name="mid" type="int" line="875"/>
                    <declaration name="midVal" type="long" line="876"/>
                </scope>
            </method>
            <javadoc line="888">
                Searches the specified array of ints for the specified value using the
                  binary search algorithm.  The array must be sorted (as
                  by the {@link #sort(int[])} method) prior to making this call.  If it
                  is not sorted, the results are undefined.  If the array contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element greater than the key, or <tt>a.length</tt> if all
                      elements in the array are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
            </javadoc>
            <method name="binarySearch" type="int" line="907">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="key" type="int"/>
                </params>
            </method>
            <javadoc line="911">
                Searches a range of
                  the specified array of ints for the specified value using the
                  binary search algorithm.
                  The range must be sorted (as
                  by the {@link #sort(int[],int,int)} method)
                  prior to making this call.  If it
                  is not sorted, the results are undefined.  If the range contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      searched                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array
                      within the specified range;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element in the range greater than the key,
                      or <tt>toIndex</tt> if all
                      elements in the range are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0 or toIndex > a.length}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="binarySearch" type="int" line="944">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="int"/>
                </params>
            </method>
            <method name="binarySearch0" type="int" line="951">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="int"/>
                </params>
                <comment line="965">
                    key found                    
                </comment>
                <comment line="967">
                    key not found.                    
                </comment>
                <declaration name="low" type="int" line="952"/>
                <declaration name="high" type="int" line="953"/>
                <scope line="955">
                    <declaration name="mid" type="int" line="956"/>
                    <declaration name="midVal" type="int" line="957"/>
                </scope>
            </method>
            <javadoc line="969">
                Searches the specified array of shorts for the specified value using
                  the binary search algorithm.  The array must be sorted
                  (as by the {@link #sort(short[])} method) prior to making this call.  If
                  it is not sorted, the results are undefined.  If the array contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element greater than the key, or <tt>a.length</tt> if all
                      elements in the array are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
            </javadoc>
            <method name="binarySearch" type="int" line="988">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="key" type="short"/>
                </params>
            </method>
            <javadoc line="992">
                Searches a range of
                  the specified array of shorts for the specified value using
                  the binary search algorithm.
                  The range must be sorted
                  (as by the {@link #sort(short[],int,int)} method)
                  prior to making this call.  If
                  it is not sorted, the results are undefined.  If the range contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      searched                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array
                      within the specified range;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element in the range greater than the key,
                      or <tt>toIndex</tt> if all
                      elements in the range are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0 or toIndex > a.length}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="binarySearch" type="int" line="1025">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="short"/>
                </params>
            </method>
            <method name="binarySearch0" type="int" line="1032">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="short"/>
                </params>
                <comment line="1046">
                    key found                    
                </comment>
                <comment line="1048">
                    key not found.                    
                </comment>
                <declaration name="low" type="int" line="1033"/>
                <declaration name="high" type="int" line="1034"/>
                <scope line="1036">
                    <declaration name="mid" type="int" line="1037"/>
                    <declaration name="midVal" type="short" line="1038"/>
                </scope>
            </method>
            <javadoc line="1050">
                Searches the specified array of chars for the specified value using the
                  binary search algorithm.  The array must be sorted (as
                  by the {@link #sort(char[])} method) prior to making this call.  If it
                  is not sorted, the results are undefined.  If the array contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element greater than the key, or <tt>a.length</tt> if all
                      elements in the array are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
            </javadoc>
            <method name="binarySearch" type="int" line="1069">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="key" type="char"/>
                </params>
            </method>
            <javadoc line="1073">
                Searches a range of
                  the specified array of chars for the specified value using the
                  binary search algorithm.
                  The range must be sorted (as
                  by the {@link #sort(char[],int,int)} method)
                  prior to making this call.  If it
                  is not sorted, the results are undefined.  If the range contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      searched                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array
                      within the specified range;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element in the range greater than the key,
                      or <tt>toIndex</tt> if all
                      elements in the range are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0 or toIndex > a.length}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="binarySearch" type="int" line="1106">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="char"/>
                </params>
            </method>
            <method name="binarySearch0" type="int" line="1113">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="char"/>
                </params>
                <comment line="1127">
                    key found                    
                </comment>
                <comment line="1129">
                    key not found.                    
                </comment>
                <declaration name="low" type="int" line="1114"/>
                <declaration name="high" type="int" line="1115"/>
                <scope line="1117">
                    <declaration name="mid" type="int" line="1118"/>
                    <declaration name="midVal" type="char" line="1119"/>
                </scope>
            </method>
            <javadoc line="1131">
                Searches the specified array of bytes for the specified value using the
                  binary search algorithm.  The array must be sorted (as
                  by the {@link #sort(byte[])} method) prior to making this call.  If it
                  is not sorted, the results are undefined.  If the array contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element greater than the key, or <tt>a.length</tt> if all
                      elements in the array are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
            </javadoc>
            <method name="binarySearch" type="int" line="1150">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="key" type="byte"/>
                </params>
            </method>
            <javadoc line="1154">
                Searches a range of
                  the specified array of bytes for the specified value using the
                  binary search algorithm.
                  The range must be sorted (as
                  by the {@link #sort(byte[],int,int)} method)
                  prior to making this call.  If it
                  is not sorted, the results are undefined.  If the range contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      searched                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array
                      within the specified range;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element in the range greater than the key,
                      or <tt>toIndex</tt> if all
                      elements in the range are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0 or toIndex > a.length}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="binarySearch" type="int" line="1187">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="byte"/>
                </params>
            </method>
            <method name="binarySearch0" type="int" line="1194">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="byte"/>
                </params>
                <comment line="1208">
                    key found                    
                </comment>
                <comment line="1210">
                    key not found.                    
                </comment>
                <declaration name="low" type="int" line="1195"/>
                <declaration name="high" type="int" line="1196"/>
                <scope line="1198">
                    <declaration name="mid" type="int" line="1199"/>
                    <declaration name="midVal" type="byte" line="1200"/>
                </scope>
            </method>
            <javadoc line="1212">
                Searches the specified array of doubles for the specified value using
                  the binary search algorithm.  The array must be sorted
                  (as by the {@link #sort(double[])} method) prior to making this call.
                  If it is not sorted, the results are undefined.  If the array contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.  This method considers all NaN values to be
                  equivalent and equal.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element greater than the key, or <tt>a.length</tt> if all
                      elements in the array are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
            </javadoc>
            <method name="binarySearch" type="int" line="1232">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="key" type="double"/>
                </params>
            </method>
            <javadoc line="1236">
                Searches a range of
                  the specified array of doubles for the specified value using
                  the binary search algorithm.
                  The range must be sorted
                  (as by the {@link #sort(double[],int,int)} method)
                  prior to making this call.
                  If it is not sorted, the results are undefined.  If the range contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found.  This method considers all NaN values to be
                  equivalent and equal.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      searched                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array
                      within the specified range;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element in the range greater than the key,
                      or <tt>toIndex</tt> if all
                      elements in the range are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0 or toIndex > a.length}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="binarySearch" type="int" line="1270">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="double"/>
                </params>
            </method>
            <method name="binarySearch0" type="int" line="1277">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="double"/>
                </params>
                <comment line="1287">
                    Neither val is NaN, thisVal is smaller                    
                </comment>
                <comment line="1289">
                    Neither val is NaN, thisVal is larger                    
                </comment>
                <comment line="1293">
                    Values are equal                    
                </comment>
                <comment line="1294">
                    Key found                    
                </comment>
                <comment line="1295">
                    (-0.0, 0.0) or (!NaN, NaN)                    
                </comment>
                <comment line="1297">
                    (0.0, -0.0) or (NaN, !NaN)                    
                </comment>
                <comment line="1301">
                    key not found.                    
                </comment>
                <declaration name="low" type="int" line="1278"/>
                <declaration name="high" type="int" line="1279"/>
                <scope line="1281">
                    <declaration name="mid" type="int" line="1282"/>
                    <declaration name="midVal" type="double" line="1283"/>
                    <scope line="1289">
                        <declaration name="midBits" type="long" line="1290"/>
                        <declaration name="keyBits" type="long" line="1291"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1303">
                Searches the specified array of floats for the specified value using
                  the binary search algorithm. The array must be sorted
                  (as by the {@link #sort(float[])} method) prior to making this call. If
                  it is not sorted, the results are undefined. If the array contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found. This method considers all NaN values to be
                  equivalent and equal.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>. The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element greater than the key, or <tt>a.length</tt> if all
                      elements in the array are less than the specified key. Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
            </javadoc>
            <method name="binarySearch" type="int" line="1323">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="key" type="float"/>
                </params>
            </method>
            <javadoc line="1327">
                Searches a range of
                  the specified array of floats for the specified value using
                  the binary search algorithm.
                  The range must be sorted
                  (as by the {@link #sort(float[],int,int)} method)
                  prior to making this call. If
                  it is not sorted, the results are undefined. If the range contains
                  multiple elements with the specified value, there is no guarantee which
                  one will be found. This method considers all NaN values to be
                  equivalent and equal.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      searched                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array
                      within the specified range;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>. The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element in the range greater than the key,
                      or <tt>toIndex</tt> if all
                      elements in the range are less than the specified key. Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    IllegalArgumentExceptionif {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0 or toIndex > a.length}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="binarySearch" type="int" line="1361">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="float"/>
                </params>
            </method>
            <method name="binarySearch0" type="int" line="1368">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="float"/>
                </params>
                <comment line="1378">
                    Neither val is NaN, thisVal is smaller                    
                </comment>
                <comment line="1380">
                    Neither val is NaN, thisVal is larger                    
                </comment>
                <comment line="1384">
                    Values are equal                    
                </comment>
                <comment line="1385">
                    Key found                    
                </comment>
                <comment line="1386">
                    (-0.0, 0.0) or (!NaN, NaN)                    
                </comment>
                <comment line="1388">
                    (0.0, -0.0) or (NaN, !NaN)                    
                </comment>
                <comment line="1392">
                    key not found.                    
                </comment>
                <declaration name="low" type="int" line="1369"/>
                <declaration name="high" type="int" line="1370"/>
                <scope line="1372">
                    <declaration name="mid" type="int" line="1373"/>
                    <declaration name="midVal" type="float" line="1374"/>
                    <scope line="1380">
                        <declaration name="midBits" type="int" line="1381"/>
                        <declaration name="keyBits" type="int" line="1382"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1394">
                Searches the specified array for the specified object using the binary
                  search algorithm. The array must be sorted into ascending order
                  according to the{@linkplain Comparable natural ordering}of its elements (as by the{@link #sort(Object[])} method) prior to making this call.
                  If it is not sorted, the results are undefined.
                  (If the array contains elements that are not mutually comparable (for
                  example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according
                  to the natural ordering of its elements, hence results are undefined.)
                  If the array contains multiple
                  elements equal to the specified object, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element greater than the key, or <tt>a.length</tt> if all
                      elements in the array are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    ClassCastException if the search key is not comparable to the
                      elements of the array.                    
                </throws>
            </javadoc>
            <method name="binarySearch" type="int" line="1422">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="1426">
                Searches a range of
                  the specified array for the specified object using the binary
                  search algorithm.
                  The range must be sorted into ascending order
                  according to the{@linkplain Comparable natural ordering}of its elements (as by the{@link #sort(Object[],int,int)} method) prior to making this
                  call.  If it is not sorted, the results are undefined.
                  (If the range contains elements that are not mutually comparable (for
                  example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according
                  to the natural ordering of its elements, hence results are undefined.)
                  If the range contains multiple
                  elements equal to the specified object, there is no guarantee which
                  one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      searched                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <return>
                    index of the search key, if it is contained in the array
                      within the specified range;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element in the range greater than the key,
                      or <tt>toIndex</tt> if all
                      elements in the range are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    ClassCastException if the search key is not comparable to the
                      elements of the array within the specified range.                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0 or toIndex > a.length}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="binarySearch" type="int" line="1467">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <method name="binarySearch0" type="int" line="1474">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="Object"/>
                </params>
                <comment line="1489">
                    key found                    
                </comment>
                <comment line="1491">
                    key not found.                    
                </comment>
                <declaration name="low" type="int" line="1475"/>
                <declaration name="high" type="int" line="1476"/>
                <scope line="1478">
                    <declaration name="mid" type="int" line="1479"/>
                    <declaration name="midVal" type="Comparable" line="1480"/>
                    <declaration name="cmp" type="int" line="1481"/>
                </scope>
            </method>
            <javadoc line="1493">
                Searches the specified array for the specified object using the binary
                  search algorithm.  The array must be sorted into ascending order
                  according to the specified comparator (as by the{@link #sort(Object[],Comparator) sort(T[], Comparator)}method) prior to making this call.  If it is
                  not sorted, the results are undefined.
                  If the array contains multiple
                  elements equal to the specified object, there is no guarantee which one
                  will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <param>
                    c the comparator by which the array is ordered.  A
                      <tt>null</tt> value indicates that the elements'{@linkplain Comparable natural ordering} should be used.                    
                </param>
                <return>
                    index of the search key, if it is contained in the array;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element greater than the key, or <tt>a.length</tt> if all
                      elements in the array are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    ClassCastException if the array contains elements that are not
                      <i>mutually comparable</i> using the specified comparator,
                      or the search key is not comparable to the
                      elements of the array using this comparator.                    
                </throws>
            </javadoc>
            <method name="binarySearch" type="int" line="1522">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="key" type="T"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
            </method>
            <javadoc line="1526">
                Searches a range of
                  the specified array for the specified object using the binary
                  search algorithm.
                  The range must be sorted into ascending order
                  according to the specified comparator (as by the{@link #sort(Object[],int,int,Comparator)sort(T[], int, int, Comparator)}method) prior to making this call.
                  If it is not sorted, the results are undefined.
                  If the range contains multiple elements equal to the specified object,
                  there is no guarantee which one will be found.                
                <param>
                    a the array to be searched                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      searched                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be searched                    
                </param>
                <param>
                    key the value to be searched for                    
                </param>
                <param>
                    c the comparator by which the array is ordered.  A
                      <tt>null</tt> value indicates that the elements'{@linkplain Comparable natural ordering} should be used.                    
                </param>
                <return>
                    index of the search key, if it is contained in the array
                      within the specified range;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the array: the index of the first
                      element in the range greater than the key,
                      or <tt>toIndex</tt> if all
                      elements in the range are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    ClassCastException if the range contains elements that are not
                      <i>mutually comparable</i> using the specified comparator,
                      or the search key is not comparable to the
                      elements in the range using this comparator.                    
                </throws>
                <throws>
                    IllegalArgumentExceptionif {@code fromIndex > toIndex}                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsExceptionif {@code fromIndex < 0 or toIndex > a.length}                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="binarySearch" type="int" line="1568">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="T"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
            </method>
            <method name="binarySearch0" type="int" line="1575">
                <params>
                    <param name="a" type="T[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="key" type="T"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <comment line="1592">
                    key found                    
                </comment>
                <comment line="1594">
                    key not found.                    
                </comment>
                <scope line="1576"/>
                <declaration name="low" type="int" line="1579"/>
                <declaration name="high" type="int" line="1580"/>
                <scope line="1582">
                    <declaration name="mid" type="int" line="1583"/>
                    <declaration name="midVal" type="T" line="1584"/>
                    <declaration name="cmp" type="int" line="1585"/>
                </scope>
            </method>
            <javadoc line="1598">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of longs are
                  &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
                  arrays contain the same number of elements, and all corresponding pairs
                  of elements in the two arrays are equal.  In other words, two arrays
                  are equal if they contain the same elements in the same order.  Also,
                  two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;                
                <param>
                    a one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1610">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="a2" type="long[]"/>
                </params>
                <declaration name="length" type="int" line="1616"/>
            </method>
            <javadoc line="1627">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of ints are
                  &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
                  arrays contain the same number of elements, and all corresponding pairs
                  of elements in the two arrays are equal.  In other words, two arrays
                  are equal if they contain the same elements in the same order.  Also,
                  two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;                
                <param>
                    a one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1639">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="a2" type="int[]"/>
                </params>
                <declaration name="length" type="int" line="1645"/>
            </method>
            <javadoc line="1656">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of shorts are
                  &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
                  arrays contain the same number of elements, and all corresponding pairs
                  of elements in the two arrays are equal.  In other words, two arrays
                  are equal if they contain the same elements in the same order.  Also,
                  two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;                
                <param>
                    a one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1668">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="a2" type="short"/>
                </params>
                <declaration name="length" type="int" line="1674"/>
            </method>
            <javadoc line="1685">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of chars are
                  &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
                  arrays contain the same number of elements, and all corresponding pairs
                  of elements in the two arrays are equal.  In other words, two arrays
                  are equal if they contain the same elements in the same order.  Also,
                  two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;                
                <param>
                    a one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1697">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="a2" type="char[]"/>
                </params>
                <declaration name="length" type="int" line="1703"/>
            </method>
            <javadoc line="1714">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of bytes are
                  &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
                  arrays contain the same number of elements, and all corresponding pairs
                  of elements in the two arrays are equal.  In other words, two arrays
                  are equal if they contain the same elements in the same order.  Also,
                  two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;                
                <param>
                    a one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1726">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="a2" type="byte[]"/>
                </params>
                <declaration name="length" type="int" line="1732"/>
            </method>
            <javadoc line="1743">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of booleans are
                  &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
                  arrays contain the same number of elements, and all corresponding pairs
                  of elements in the two arrays are equal.  In other words, two arrays
                  are equal if they contain the same elements in the same order.  Also,
                  two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;                
                <param>
                    a one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1755">
                <params>
                    <param name="a" type="boolean[]"/>
                    <param name="a2" type="boolean[]"/>
                </params>
                <declaration name="length" type="int" line="1761"/>
            </method>
            <javadoc line="1772">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of doubles are
                  &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
                  arrays contain the same number of elements, and all corresponding pairs
                  of elements in the two arrays are equal.  In other words, two arrays
                  are equal if they contain the same elements in the same order.  Also,
                  two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
                  Two doubles &lt;tt&gt;d1&lt;/tt&gt; and &lt;tt&gt;d2&lt;/tt&gt; are considered equal if:
                  &lt;pre&gt;    &lt;tt&gt;new Double(d1).equals(new Double(d2))&lt;/tt&gt;&lt;/pre&gt;
                  (Unlike the &lt;tt&gt;==&lt;/tt&gt; operator, this method considers
                  &lt;tt&gt;NaN&lt;/tt&gt; equals to itself, and 0.0d unequal to -0.0d.)                
                <param>
                    a one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
                <see>
                    Double#equals(Object)                    
                </see>
            </javadoc>
            <method name="equals" type="boolean" line="1790">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="a2" type="double[]"/>
                </params>
                <declaration name="length" type="int" line="1796"/>
            </method>
            <javadoc line="1807">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of floats are
                  &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
                  arrays contain the same number of elements, and all corresponding pairs
                  of elements in the two arrays are equal.  In other words, two arrays
                  are equal if they contain the same elements in the same order.  Also,
                  two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
                  Two floats &lt;tt&gt;f1&lt;/tt&gt; and &lt;tt&gt;f2&lt;/tt&gt; are considered equal if:
                  &lt;pre&gt;    &lt;tt&gt;new Float(f1).equals(new Float(f2))&lt;/tt&gt;&lt;/pre&gt;
                  (Unlike the &lt;tt&gt;==&lt;/tt&gt; operator, this method considers
                  &lt;tt&gt;NaN&lt;/tt&gt; equals to itself, and 0.0f unequal to -0.0f.)                
                <param>
                    a one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
                <see>
                    Float#equals(Object)                    
                </see>
            </javadoc>
            <method name="equals" type="boolean" line="1825">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="a2" type="float[]"/>
                </params>
                <declaration name="length" type="int" line="1831"/>
            </method>
            <javadoc line="1842">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of Objects are
                  &lt;i&gt;equal&lt;/i&gt; to one another.  The two arrays are considered equal if
                  both arrays contain the same number of elements, and all corresponding
                  pairs of elements in the two arrays are equal.  Two objects &lt;tt&gt;e1&lt;/tt&gt;
                  and &lt;tt&gt;e2&lt;/tt&gt; are considered &lt;i&gt;equal&lt;/i&gt; if &lt;tt&gt;(e1==null ? e2==null
                  : e1.equals(e2))&lt;/tt&gt;.  In other words, the two arrays are equal if
                  they contain the same elements in the same order.  Also, two array
                  references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;                
                <param>
                    a one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1856">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="a2" type="Object[]"/>
                </params>
                <declaration name="length" type="int" line="1862"/>
                <scope line="1866">
                    <declaration name="o1" type="Object" line="1867"/>
                    <declaration name="o2" type="Object" line="1868"/>
                </scope>
            </method>
            <javadoc line="1878">
                Assigns the specified long value to each element of the specified array
                  of longs.                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
            </javadoc>
            <method name="fill" type="void" line="1885">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="val" type="long"/>
                </params>
            </method>
            <javadoc line="1890">
                Assigns the specified long value to each element of the specified
                  range of the specified array of longs.  The range to be filled
                  extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
                  &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
                  range to be filled is empty.)                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                      <tt>toIndex &gt; a.length</tt>                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="1907">
                <params>
                    <param name="a" type="long[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="val" type="long"/>
                </params>
            </method>
            <javadoc line="1913">
                Assigns the specified int value to each element of the specified array
                  of ints.                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
            </javadoc>
            <method name="fill" type="void" line="1920">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="val" type="int"/>
                </params>
            </method>
            <javadoc line="1925">
                Assigns the specified int value to each element of the specified
                  range of the specified array of ints.  The range to be filled
                  extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
                  &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
                  range to be filled is empty.)                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                      <tt>toIndex &gt; a.length</tt>                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="1942">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="val" type="int"/>
                </params>
            </method>
            <javadoc line="1948">
                Assigns the specified short value to each element of the specified array
                  of shorts.                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
            </javadoc>
            <method name="fill" type="void" line="1955">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="val" type="short"/>
                </params>
            </method>
            <javadoc line="1960">
                Assigns the specified short value to each element of the specified
                  range of the specified array of shorts.  The range to be filled
                  extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
                  &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
                  range to be filled is empty.)                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                      <tt>toIndex &gt; a.length</tt>                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="1977">
                <params>
                    <param name="a" type="short[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="val" type="short"/>
                </params>
            </method>
            <javadoc line="1983">
                Assigns the specified char value to each element of the specified array
                  of chars.                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
            </javadoc>
            <method name="fill" type="void" line="1990">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="val" type="char"/>
                </params>
            </method>
            <javadoc line="1995">
                Assigns the specified char value to each element of the specified
                  range of the specified array of chars.  The range to be filled
                  extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
                  &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
                  range to be filled is empty.)                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                      <tt>toIndex &gt; a.length</tt>                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="2012">
                <params>
                    <param name="a" type="char[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="val" type="char"/>
                </params>
            </method>
            <javadoc line="2018">
                Assigns the specified byte value to each element of the specified array
                  of bytes.                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
            </javadoc>
            <method name="fill" type="void" line="2025">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="val" type="byte"/>
                </params>
            </method>
            <javadoc line="2030">
                Assigns the specified byte value to each element of the specified
                  range of the specified array of bytes.  The range to be filled
                  extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
                  &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
                  range to be filled is empty.)                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                      <tt>toIndex &gt; a.length</tt>                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="2047">
                <params>
                    <param name="a" type="byte[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="val" type="byte"/>
                </params>
            </method>
            <javadoc line="2053">
                Assigns the specified boolean value to each element of the specified
                  array of booleans.                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
            </javadoc>
            <method name="fill" type="void" line="2060">
                <params>
                    <param name="a" type="boolean[]"/>
                    <param name="val" type="boolean"/>
                </params>
            </method>
            <javadoc line="2065">
                Assigns the specified boolean value to each element of the specified
                  range of the specified array of booleans.  The range to be filled
                  extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
                  &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
                  range to be filled is empty.)                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                      <tt>toIndex &gt; a.length</tt>                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="2083">
                <params>
                    <param name="a" type="boolean[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="val" type="boolean"/>
                </params>
            </method>
            <javadoc line="2089">
                Assigns the specified double value to each element of the specified
                  array of doubles.                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
            </javadoc>
            <method name="fill" type="void" line="2096">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="val" type="double"/>
                </params>
            </method>
            <javadoc line="2101">
                Assigns the specified double value to each element of the specified
                  range of the specified array of doubles.  The range to be filled
                  extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
                  &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
                  range to be filled is empty.)                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                      <tt>toIndex &gt; a.length</tt>                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="2118">
                <params>
                    <param name="a" type="double[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="val" type="double"/>
                </params>
            </method>
            <javadoc line="2124">
                Assigns the specified float value to each element of the specified array
                  of floats.                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
            </javadoc>
            <method name="fill" type="void" line="2131">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="val" type="float"/>
                </params>
            </method>
            <javadoc line="2136">
                Assigns the specified float value to each element of the specified
                  range of the specified array of floats.  The range to be filled
                  extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
                  &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
                  range to be filled is empty.)                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                      <tt>toIndex &gt; a.length</tt>                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="2153">
                <params>
                    <param name="a" type="float[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="val" type="float"/>
                </params>
            </method>
            <javadoc line="2159">
                Assigns the specified Object reference to each element of the specified
                  array of Objects.                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    ArrayStoreException if the specified value is not of a
                      runtime type that can be stored in the specified array                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="2168">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="val" type="Object"/>
                </params>
            </method>
            <javadoc line="2173">
                Assigns the specified Object reference to each element of the specified
                  range of the specified array of Objects.  The range to be filled
                  extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
                  &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
                  range to be filled is empty.)                
                <param>
                    a the array to be filled                    
                </param>
                <param>
                    fromIndex the index of the first element (inclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    toIndex the index of the last element (exclusive) to be
                      filled with the specified value                    
                </param>
                <param>
                    val the value to be stored in all elements of the array                    
                </param>
                <throws>
                    IllegalArgumentException if <tt>fromIndex &gt; toIndex</tt>                    
                </throws>
                <throws>
                    ArrayIndexOutOfBoundsException if <tt>fromIndex &lt; 0</tt> or
                      <tt>toIndex &gt; a.length</tt>                    
                </throws>
                <throws>
                    ArrayStoreException if the specified value is not of a
                      runtime type that can be stored in the specified array                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="2192">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="fromIndex" type="int"/>
                    <param name="toIndex" type="int"/>
                    <param name="val" type="Object"/>
                </params>
            </method>
            <javadoc line="2200">
                Copies the specified array, truncating or padding with nulls (if necessary)
                  so the copy has the specified length.  For all indices that are
                  valid in both the original array and the copy, the two arrays will
                  contain identical values.  For any indices that are valid in the
                  copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;.
                  Such indices will exist if and only if the specified length
                  is greater than that of the original array.
                  The resulting array is of exactly the same class as the original array.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with nulls
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="T[]" line="2218">
                <params>
                    <param name="original" type="T[]"/>
                    <param name="newLength" type="int"/>
                </params>
            </method>
            <javadoc line="2222">
                Copies the specified array, truncating or padding with nulls (if necessary)
                  so the copy has the specified length.  For all indices that are
                  valid in both the original array and the copy, the two arrays will
                  contain identical values.  For any indices that are valid in the
                  copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;.
                  Such indices will exist if and only if the specified length
                  is greater than that of the original array.
                  The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <param>
                    newType the class of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with nulls
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <throws>
                    ArrayStoreException if an element copied from
                      <tt>original</tt> is not of a runtime type that can be stored in
                      an array of class <tt>newType</tt>                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="T[]" line="2244">
                <params>
                    <param name="original" type="U[]"/>
                    <param name="newLength" type="int"/>
                    <param name="newType" type="Class<? extends T[]>"/>
                </params>
                <declaration name="copy" type="T[]" line="2245"/>
            </method>
            <javadoc line="2253">
                Copies the specified array, truncating or padding with zeros (if necessary)
                  so the copy has the specified length.  For all indices that are
                  valid in both the original array and the copy, the two arrays will
                  contain identical values.  For any indices that are valid in the
                  copy but not the original, the copy will contain &lt;tt&gt;(byte)0&lt;/tt&gt;.
                  Such indices will exist if and only if the specified length
                  is greater than that of the original array.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with zeros
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="byte[]" line="2270">
                <params>
                    <param name="original" type="byte[]"/>
                    <param name="newLength" type="int"/>
                </params>
                <declaration name="copy" type="byte[]" line="2271"/>
            </method>
            <javadoc line="2277">
                Copies the specified array, truncating or padding with zeros (if necessary)
                  so the copy has the specified length.  For all indices that are
                  valid in both the original array and the copy, the two arrays will
                  contain identical values.  For any indices that are valid in the
                  copy but not the original, the copy will contain &lt;tt&gt;(short)0&lt;/tt&gt;.
                  Such indices will exist if and only if the specified length
                  is greater than that of the original array.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with zeros
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="short[]" line="2294">
                <params>
                    <param name="original" type="short[]"/>
                    <param name="newLength" type="int"/>
                </params>
                <declaration name="copy" type="short[]" line="2295"/>
            </method>
            <javadoc line="2301">
                Copies the specified array, truncating or padding with zeros (if necessary)
                  so the copy has the specified length.  For all indices that are
                  valid in both the original array and the copy, the two arrays will
                  contain identical values.  For any indices that are valid in the
                  copy but not the original, the copy will contain &lt;tt&gt;0&lt;/tt&gt;.
                  Such indices will exist if and only if the specified length
                  is greater than that of the original array.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with zeros
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="int[]" line="2318">
                <params>
                    <param name="original" type="int[]"/>
                    <param name="newLength" type="int"/>
                </params>
                <declaration name="copy" type="int[]" line="2319"/>
            </method>
            <javadoc line="2325">
                Copies the specified array, truncating or padding with zeros (if necessary)
                  so the copy has the specified length.  For all indices that are
                  valid in both the original array and the copy, the two arrays will
                  contain identical values.  For any indices that are valid in the
                  copy but not the original, the copy will contain &lt;tt&gt;0L&lt;/tt&gt;.
                  Such indices will exist if and only if the specified length
                  is greater than that of the original array.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with zeros
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="long[]" line="2342">
                <params>
                    <param name="original" type="long[]"/>
                    <param name="newLength" type="int"/>
                </params>
                <declaration name="copy" type="long[]" line="2343"/>
            </method>
            <javadoc line="2349">
                Copies the specified array, truncating or padding with null characters (if necessary)
                  so the copy has the specified length.  For all indices that are valid
                  in both the original array and the copy, the two arrays will contain
                  identical values.  For any indices that are valid in the copy but not
                  the original, the copy will contain &lt;tt&gt;&apos;\\u000&apos;&lt;/tt&gt;.  Such indices
                  will exist if and only if the specified length is greater than that of
                  the original array.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with null characters
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="char[]" line="2366">
                <params>
                    <param name="original" type="char[]"/>
                    <param name="newLength" type="int"/>
                </params>
                <declaration name="copy" type="char[]" line="2367"/>
            </method>
            <javadoc line="2373">
                Copies the specified array, truncating or padding with zeros (if necessary)
                  so the copy has the specified length.  For all indices that are
                  valid in both the original array and the copy, the two arrays will
                  contain identical values.  For any indices that are valid in the
                  copy but not the original, the copy will contain &lt;tt&gt;0f&lt;/tt&gt;.
                  Such indices will exist if and only if the specified length
                  is greater than that of the original array.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with zeros
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="float[]" line="2390">
                <params>
                    <param name="original" type="float[]"/>
                    <param name="newLength" type="int"/>
                </params>
                <declaration name="copy" type="float[]" line="2391"/>
            </method>
            <javadoc line="2397">
                Copies the specified array, truncating or padding with zeros (if necessary)
                  so the copy has the specified length.  For all indices that are
                  valid in both the original array and the copy, the two arrays will
                  contain identical values.  For any indices that are valid in the
                  copy but not the original, the copy will contain &lt;tt&gt;0d&lt;/tt&gt;.
                  Such indices will exist if and only if the specified length
                  is greater than that of the original array.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with zeros
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="double[]" line="2414">
                <params>
                    <param name="original" type="double[]"/>
                    <param name="newLength" type="int"/>
                </params>
                <declaration name="copy" type="double[]" line="2415"/>
            </method>
            <javadoc line="2421">
                Copies the specified array, truncating or padding with &lt;tt&gt;false&lt;/tt&gt; (if necessary)
                  so the copy has the specified length.  For all indices that are
                  valid in both the original array and the copy, the two arrays will
                  contain identical values.  For any indices that are valid in the
                  copy but not the original, the copy will contain &lt;tt&gt;false&lt;/tt&gt;.
                  Such indices will exist if and only if the specified length
                  is greater than that of the original array.                
                <param>
                    original the array to be copied                    
                </param>
                <param>
                    newLength the length of the copy to be returned                    
                </param>
                <return>
                    a copy of the original array, truncated or padded with false elements
                      to obtain the specified length                    
                </return>
                <throws>
                    NegativeArraySizeException if <tt>newLength</tt> is negative                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOf" type="boolean[]" line="2438">
                <params>
                    <param name="original" type="boolean[]"/>
                    <param name="newLength" type="int"/>
                </params>
                <declaration name="copy" type="boolean[]" line="2439"/>
            </method>
            <javadoc line="2445">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;null&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
                  &lt;p&gt;
                  The resulting array is of exactly the same class as the original array.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with nulls to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="T[]" line="2473">
                <params>
                    <param name="original" type="T[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
            </method>
            <javadoc line="2477">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;null&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
                  The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <param>
                    newType the class of the copy to be returned                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with nulls to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <throws>
                    ArrayStoreException if an element copied from
                      <tt>original</tt> is not of a runtime type that can be stored in
                      an array of class <tt>newType</tt>.                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="T[]" line="2508">
                <params>
                    <param name="original" type="U[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                    <param name="newType" type="Class<? extends T[]>"/>
                </params>
                <declaration name="newLength" type="int" line="2509"/>
                <declaration name="copy" type="T[]" line="2512"/>
            </method>
            <javadoc line="2520">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;(byte)0&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with zeros to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="byte[]" line="2546">
                <params>
                    <param name="original" type="byte[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="newLength" type="int" line="2547"/>
                <declaration name="copy" type="byte[]" line="2550"/>
            </method>
            <javadoc line="2556">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;(short)0&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with zeros to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="short[]" line="2582">
                <params>
                    <param name="original" type="short[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="newLength" type="int" line="2583"/>
                <declaration name="copy" type="short[]" line="2586"/>
            </method>
            <javadoc line="2592">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;0&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with zeros to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="int[]" line="2618">
                <params>
                    <param name="original" type="int[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="newLength" type="int" line="2619"/>
                <declaration name="copy" type="int[]" line="2622"/>
            </method>
            <javadoc line="2628">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;0L&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with zeros to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="long[]" line="2654">
                <params>
                    <param name="original" type="long[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="newLength" type="int" line="2655"/>
                <declaration name="copy" type="long[]" line="2658"/>
            </method>
            <javadoc line="2664">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;&apos;\\u000&apos;&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with null characters to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="char[]" line="2690">
                <params>
                    <param name="original" type="char[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="newLength" type="int" line="2691"/>
                <declaration name="copy" type="char[]" line="2694"/>
            </method>
            <javadoc line="2700">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;0f&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with zeros to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="float[]" line="2726">
                <params>
                    <param name="original" type="float[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="newLength" type="int" line="2727"/>
                <declaration name="copy" type="float[]" line="2730"/>
            </method>
            <javadoc line="2736">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;0d&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with zeros to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="double[]" line="2762">
                <params>
                    <param name="original" type="double[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="newLength" type="int" line="2763"/>
                <declaration name="copy" type="double[]" line="2766"/>
            </method>
            <javadoc line="2772">
                Copies the specified range of the specified array into a new array.
                  The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
                  and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
                  &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
                  (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
                  Values from subsequent elements in the original array are placed into
                  subsequent elements in the copy.  The final index of the range
                  (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
                  may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
                  &lt;tt&gt;false&lt;/tt&gt; is placed in all elements of the copy whose index is
                  greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
                  of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.                
                <param>
                    original the array from which a range is to be copied                    
                </param>
                <param>
                    from the initial index of the range to be copied, inclusive                    
                </param>
                <param>
                    to the final index of the range to be copied, exclusive.
                      (This index may lie outside the array.)                    
                </param>
                <return>
                    a new array containing the specified range from the original array,
                      truncated or padded with false elements to obtain the required length                    
                </return>
                <throws>
                    ArrayIndexOutOfBoundsException if {@code from < 0}or {@code from > original.length}                    
                </throws>
                <throws>
                    IllegalArgumentException if <tt>from &gt; to</tt>                    
                </throws>
                <throws>
                    NullPointerException if <tt>original</tt> is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="copyOfRange" type="boolean[]" line="2798">
                <params>
                    <param name="original" type="boolean[]"/>
                    <param name="from" type="int"/>
                    <param name="to" type="int"/>
                </params>
                <declaration name="newLength" type="int" line="2799"/>
                <declaration name="copy" type="boolean[]" line="2802"/>
            </method>
            <javadoc line="2810">
                Returns a fixed-size list backed by the specified array.  (Changes to
                  the returned list &quot;write through&quot; to the array.)  This method acts
                  as bridge between array-based and collection-based APIs, in
                  combination with {@link Collection#toArray}.  The returned list is
                  serializable and implements {@link RandomAccess}.
                  &lt;p&gt;This method also provides a convenient way to create a fixed-size
                  list initialized to contain several elements:
                  &lt;pre&gt;
                  List&amp;lt;String&amp;gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);
                  &lt;/pre&gt;                
                <param>
                    a the array by which the list will be backed                    
                </param>
                <return>
                    a list view of the specified array                    
                </return>
            </javadoc>
            <method name="asList" type="List<T>" line="2827">
                <params>
                    <param name="a" type="T"/>
                </params>
            </method>
            <class name="ArrayList" line="2831">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractList">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <implements interface="RandomAccess"/>
                <implements interface="java.io.Serializable"/>
                <javadoc line="2831">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2837"/>
                <declaration name="a" type="E[]" line="2838"/>
                <method name="ArrayList" type="constructor" line="2840">
                    <params>
                        <param name="array" type="E[]"/>
                    </params>
                </method>
                <method name="size" type="int" line="2846"/>
                <method name="toArray" type="Object[]" line="2850"/>
                <method name="toArray" type="T[]" line="2854">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                    <declaration name="size" type="int" line="2855"/>
                </method>
                <method name="get" type="E" line="2865">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="set" type="E" line="2869">
                    <params>
                        <param name="index" type="int"/>
                        <param name="element" type="E"/>
                    </params>
                    <declaration name="oldValue" type="E" line="2870"/>
                </method>
                <method name="indexOf" type="int" line="2875">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="2876"/>
                    <scope line="2880"/>
                </method>
                <method name="contains" type="boolean" line="2888">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
            </class>
            <javadoc line="2893">
                Returns a hash code based on the contents of the specified array.
                  For any two &lt;tt&gt;long&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
                  such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The value returned by this method is the same value that would be
                  obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}method on a {@link List} containing a sequence of {@link Long}instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
                  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.                
                <param>
                    a the array whose hash value to compute                    
                </param>
                <return>
                    a content-based hash code for <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="2909">
                <params>
                    <param name="a" type="long"/>
                </params>
                <declaration name="result" type="int" line="2913"/>
                <scope line="2914">
                    <declaration name="elementHash" type="int" line="2915"/>
                </scope>
            </method>
            <javadoc line="2922">
                Returns a hash code based on the contents of the specified array.
                  For any two non-null &lt;tt&gt;int&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
                  such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The value returned by this method is the same value that would be
                  obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}method on a {@link List} containing a sequence of {@link Integer}instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
                  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.                
                <param>
                    a the array whose hash value to compute                    
                </param>
                <return>
                    a content-based hash code for <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="2938">
                <params>
                    <param name="a" type="int"/>
                </params>
                <declaration name="result" type="int" line="2942"/>
            </method>
            <javadoc line="2949">
                Returns a hash code based on the contents of the specified array.
                  For any two &lt;tt&gt;short&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
                  such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The value returned by this method is the same value that would be
                  obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}method on a {@link List} containing a sequence of {@link Short}instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
                  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.                
                <param>
                    a the array whose hash value to compute                    
                </param>
                <return>
                    a content-based hash code for <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="2965">
                <params>
                    <param name="a" type="short"/>
                </params>
                <declaration name="result" type="int" line="2969"/>
            </method>
            <javadoc line="2976">
                Returns a hash code based on the contents of the specified array.
                  For any two &lt;tt&gt;char&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
                  such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The value returned by this method is the same value that would be
                  obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}method on a {@link List} containing a sequence of {@link Character}instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
                  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.                
                <param>
                    a the array whose hash value to compute                    
                </param>
                <return>
                    a content-based hash code for <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="2992">
                <params>
                    <param name="a" type="char"/>
                </params>
                <declaration name="result" type="int" line="2996"/>
            </method>
            <javadoc line="3003">
                Returns a hash code based on the contents of the specified array.
                  For any two &lt;tt&gt;byte&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
                  such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The value returned by this method is the same value that would be
                  obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}method on a {@link List} containing a sequence of {@link Byte}instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
                  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.                
                <param>
                    a the array whose hash value to compute                    
                </param>
                <return>
                    a content-based hash code for <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="3019">
                <params>
                    <param name="a" type="byte"/>
                </params>
                <declaration name="result" type="int" line="3023"/>
            </method>
            <javadoc line="3030">
                Returns a hash code based on the contents of the specified array.
                  For any two &lt;tt&gt;boolean&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
                  such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The value returned by this method is the same value that would be
                  obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}method on a {@link List} containing a sequence of {@link Boolean}instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
                  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.                
                <param>
                    a the array whose hash value to compute                    
                </param>
                <return>
                    a content-based hash code for <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="3046">
                <params>
                    <param name="a" type="boolean"/>
                </params>
                <declaration name="result" type="int" line="3050"/>
            </method>
            <javadoc line="3057">
                Returns a hash code based on the contents of the specified array.
                  For any two &lt;tt&gt;float&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
                  such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The value returned by this method is the same value that would be
                  obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}method on a {@link List} containing a sequence of {@link Float}instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
                  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.                
                <param>
                    a the array whose hash value to compute                    
                </param>
                <return>
                    a content-based hash code for <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="3073">
                <params>
                    <param name="a" type="float"/>
                </params>
                <declaration name="result" type="int" line="3077"/>
            </method>
            <javadoc line="3084">
                Returns a hash code based on the contents of the specified array.
                  For any two &lt;tt&gt;double&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
                  such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The value returned by this method is the same value that would be
                  obtained by invoking the {@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;}method on a {@link List} containing a sequence of {@link Double}instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
                  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.                
                <param>
                    a the array whose hash value to compute                    
                </param>
                <return>
                    a content-based hash code for <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="3100">
                <params>
                    <param name="a" type="double"/>
                </params>
                <declaration name="result" type="int" line="3104"/>
                <scope line="3105">
                    <declaration name="bits" type="long" line="3106"/>
                </scope>
            </method>
            <javadoc line="3112">
                Returns a hash code based on the contents of the specified array.  If
                  the array contains other arrays as elements, the hash code is based on
                  their identities rather than their contents.  It is therefore
                  acceptable to invoke this method on an array that contains itself as an
                  element,  either directly or indirectly through one or more levels of
                  arrays.
                  &lt;p&gt;For any two arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; such that
                  &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The value returned by this method is equal to the value that would
                  be returned by &lt;tt&gt;Arrays.asList(a).hashCode()&lt;/tt&gt;, unless &lt;tt&gt;a&lt;/tt&gt;
                  is &lt;tt&gt;null&lt;/tt&gt;, in which case &lt;tt&gt;0&lt;/tt&gt; is returned.                
                <param>
                    a the array whose content-based hash code to compute                    
                </param>
                <return>
                    a content-based hash code for <tt>a</tt>                    
                </return>
                <see>
                    #deepHashCode(Object[])                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="hashCode" type="int" line="3133">
                <params>
                    <param name="a" type="Object"/>
                </params>
                <declaration name="result" type="int" line="3137"/>
            </method>
            <javadoc line="3145">
                Returns a hash code based on the &quot;deep contents&quot; of the specified
                  array.  If the array contains other arrays as elements, the
                  hash code is based on their contents and so on, ad infinitum.
                  It is therefore unacceptable to invoke this method on an array that
                  contains itself as an element, either directly or indirectly through
                  one or more levels of arrays.  The behavior of such an invocation is
                  undefined.
                  &lt;p&gt;For any two arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; such that
                  &lt;tt&gt;Arrays.deepEquals(a, b)&lt;/tt&gt;, it is also the case that
                  &lt;tt&gt;Arrays.deepHashCode(a) == Arrays.deepHashCode(b)&lt;/tt&gt;.
                  &lt;p&gt;The computation of the value returned by this method is similar to
                  that of the value returned by {@link List#hashCode()} on a list
                  containing the same elements as &lt;tt&gt;a&lt;/tt&gt; in the same order, with one
                  difference: If an element &lt;tt&gt;e&lt;/tt&gt; of &lt;tt&gt;a&lt;/tt&gt; is itself an array,
                  its hash code is computed not by calling &lt;tt&gt;e.hashCode()&lt;/tt&gt;, but as
                  by calling the appropriate overloading of &lt;tt&gt;Arrays.hashCode(e)&lt;/tt&gt;
                  if &lt;tt&gt;e&lt;/tt&gt; is an array of a primitive type, or as by calling
                  &lt;tt&gt;Arrays.deepHashCode(e)&lt;/tt&gt; recursively if &lt;tt&gt;e&lt;/tt&gt; is an array
                  of a reference type.  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method
                  returns 0.                
                <param>
                    a the array whose deep-content-based hash code to compute                    
                </param>
                <return>
                    a deep-content-based hash code for <tt>a</tt>                    
                </return>
                <see>
                    #hashCode(Object[])                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="deepHashCode" type="int" line="3174">
                <params>
                    <param name="a" type="Object"/>
                </params>
                <declaration name="result" type="int" line="3178"/>
                <scope line="3180">
                    <declaration name="elementHash" type="int" line="3181"/>
                </scope>
            </method>
            <javadoc line="3209">
                Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays are &lt;i&gt;deeply
                  equal&lt;/i&gt; to one another.  Unlike the {@link #equals(Object[],Object[])}method, this method is appropriate for use with nested arrays of
                  arbitrary depth.
                  &lt;p&gt;Two array references are considered deeply equal if both
                  are &lt;tt&gt;null&lt;/tt&gt;, or if they refer to arrays that contain the same
                  number of elements and all corresponding pairs of elements in the two
                  arrays are deeply equal.
                  &lt;p&gt;Two possibly &lt;tt&gt;null&lt;/tt&gt; elements &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are
                  deeply equal if any of the following conditions hold:
                  &lt;ul&gt;
                  &lt;li&gt; &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are both arrays of object reference
                  types, and &lt;tt&gt;Arrays.deepEquals(e1, e2) would return true&lt;/tt&gt;
                  &lt;li&gt; &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are arrays of the same primitive
                  type, and the appropriate overloading of
                  &lt;tt&gt;Arrays.equals(e1, e2)&lt;/tt&gt; would return true.
                  &lt;li&gt; &lt;tt&gt;e1 == e2&lt;/tt&gt;
                  &lt;li&gt; &lt;tt&gt;e1.equals(e2)&lt;/tt&gt; would return true.
                  &lt;/ul&gt;
                  Note that this definition permits &lt;tt&gt;null&lt;/tt&gt; elements at any depth.
                  &lt;p&gt;If either of the specified arrays contain themselves as elements
                  either directly or indirectly through one or more levels of arrays,
                  the behavior of this method is undefined.                
                <param>
                    a1 one array to be tested for equality                    
                </param>
                <param>
                    a2 the other array to be tested for equality                    
                </param>
                <return>
                    <tt>true</tt> if the two arrays are equal                    
                </return>
                <see>
                    #equals(Object[],Object[])                    
                </see>
                <see>
                    Objects#deepEquals(Object,Object)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="deepEquals" type="boolean" line="3244">
                <params>
                    <param name="a1" type="Object[]"/>
                    <param name="a2" type="Object[]"/>
                </params>
                <comment line="3263">
                    Figure out whether the two elements are equal                    
                </comment>
                <declaration name="length" type="int" line="3249"/>
                <scope line="3253">
                    <declaration name="e1" type="Object" line="3254"/>
                    <declaration name="e2" type="Object" line="3255"/>
                    <declaration name="eq" type="boolean" line="3263"/>
                </scope>
            </method>
            <method name="deepEquals0" type="boolean" line="3271">
                <params>
                    <param name="e1" type="Object"/>
                    <param name="e2" type="Object"/>
                </params>
                <declaration name="eq" type="boolean" line="3273"/>
            </method>
            <javadoc line="3297">
                Returns a string representation of the contents of the specified array.
                  The string representation consists of a list of the array&apos;s elements,
                  enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
                  separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
                  space).  Elements are converted to strings as by
                  &lt;tt&gt;String.valueOf(long)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
                  is &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3310">
                <params>
                    <param name="a" type="long[]"/>
                </params>
                <declaration name="iMax" type="int" line="3313"/>
                <declaration name="b" type="StringBuilder" line="3317"/>
                <scope line="3319"/>
            </method>
            <javadoc line="3327">
                Returns a string representation of the contents of the specified array.
                  The string representation consists of a list of the array&apos;s elements,
                  enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
                  separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
                  space).  Elements are converted to strings as by
                  &lt;tt&gt;String.valueOf(int)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt; is
                  &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3340">
                <params>
                    <param name="a" type="int[]"/>
                </params>
                <declaration name="iMax" type="int" line="3343"/>
                <declaration name="b" type="StringBuilder" line="3347"/>
                <scope line="3349"/>
            </method>
            <javadoc line="3357">
                Returns a string representation of the contents of the specified array.
                  The string representation consists of a list of the array&apos;s elements,
                  enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
                  separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
                  space).  Elements are converted to strings as by
                  &lt;tt&gt;String.valueOf(short)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
                  is &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3370">
                <params>
                    <param name="a" type="short[]"/>
                </params>
                <declaration name="iMax" type="int" line="3373"/>
                <declaration name="b" type="StringBuilder" line="3377"/>
                <scope line="3379"/>
            </method>
            <javadoc line="3387">
                Returns a string representation of the contents of the specified array.
                  The string representation consists of a list of the array&apos;s elements,
                  enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
                  separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
                  space).  Elements are converted to strings as by
                  &lt;tt&gt;String.valueOf(char)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
                  is &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3400">
                <params>
                    <param name="a" type="char[]"/>
                </params>
                <declaration name="iMax" type="int" line="3403"/>
                <declaration name="b" type="StringBuilder" line="3407"/>
                <scope line="3409"/>
            </method>
            <javadoc line="3417">
                Returns a string representation of the contents of the specified array.
                  The string representation consists of a list of the array&apos;s elements,
                  enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements
                  are separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed
                  by a space).  Elements are converted to strings as by
                  &lt;tt&gt;String.valueOf(byte)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if
                  &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3430">
                <params>
                    <param name="a" type="byte[]"/>
                </params>
                <declaration name="iMax" type="int" line="3433"/>
                <declaration name="b" type="StringBuilder" line="3437"/>
                <scope line="3439"/>
            </method>
            <javadoc line="3447">
                Returns a string representation of the contents of the specified array.
                  The string representation consists of a list of the array&apos;s elements,
                  enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
                  separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
                  space).  Elements are converted to strings as by
                  &lt;tt&gt;String.valueOf(boolean)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if
                  &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3460">
                <params>
                    <param name="a" type="boolean[]"/>
                </params>
                <declaration name="iMax" type="int" line="3463"/>
                <declaration name="b" type="StringBuilder" line="3467"/>
                <scope line="3469"/>
            </method>
            <javadoc line="3477">
                Returns a string representation of the contents of the specified array.
                  The string representation consists of a list of the array&apos;s elements,
                  enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
                  separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
                  space).  Elements are converted to strings as by
                  &lt;tt&gt;String.valueOf(float)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
                  is &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3490">
                <params>
                    <param name="a" type="float[]"/>
                </params>
                <declaration name="iMax" type="int" line="3494"/>
                <declaration name="b" type="StringBuilder" line="3498"/>
                <scope line="3500"/>
            </method>
            <javadoc line="3508">
                Returns a string representation of the contents of the specified array.
                  The string representation consists of a list of the array&apos;s elements,
                  enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
                  separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
                  space).  Elements are converted to strings as by
                  &lt;tt&gt;String.valueOf(double)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
                  is &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3521">
                <params>
                    <param name="a" type="double[]"/>
                </params>
                <declaration name="iMax" type="int" line="3524"/>
                <declaration name="b" type="StringBuilder" line="3528"/>
                <scope line="3530"/>
            </method>
            <javadoc line="3538">
                Returns a string representation of the contents of the specified array.
                  If the array contains other arrays as elements, they are converted to
                  strings by the {@link Object#toString} method inherited from
                  &lt;tt&gt;Object&lt;/tt&gt;, which describes their &lt;i&gt;identities&lt;/i&gt; rather than
                  their contents.
                  &lt;p&gt;The value returned by this method is equal to the value that would
                  be returned by &lt;tt&gt;Arrays.asList(a).toString()&lt;/tt&gt;, unless &lt;tt&gt;a&lt;/tt&gt;
                  is &lt;tt&gt;null&lt;/tt&gt;, in which case &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; is returned.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <see>
                    #deepToString(Object[])                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toString" type="String" line="3554">
                <params>
                    <param name="a" type="Object[]"/>
                </params>
                <declaration name="iMax" type="int" line="3558"/>
                <declaration name="b" type="StringBuilder" line="3562"/>
                <scope line="3564"/>
            </method>
            <javadoc line="3572">
                Returns a string representation of the &quot;deep contents&quot; of the specified
                  array.  If the array contains other arrays as elements, the string
                  representation contains their contents and so on.  This method is
                  designed for converting multidimensional arrays to strings.
                  &lt;p&gt;The string representation consists of a list of the array&apos;s
                  elements, enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent
                  elements are separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma
                  followed by a space).  Elements are converted to strings as by
                  &lt;tt&gt;String.valueOf(Object)&lt;/tt&gt;, unless they are themselves
                  arrays.
                  &lt;p&gt;If an element &lt;tt&gt;e&lt;/tt&gt; is an array of a primitive type, it is
                  converted to a string as by invoking the appropriate overloading of
                  &lt;tt&gt;Arrays.toString(e)&lt;/tt&gt;.  If an element &lt;tt&gt;e&lt;/tt&gt; is an array of a
                  reference type, it is converted to a string as by invoking
                  this method recursively.
                  &lt;p&gt;To avoid infinite recursion, if the specified array contains itself
                  as an element, or contains an indirect reference to itself through one
                  or more levels of arrays, the self-reference is converted to the string
                  &lt;tt&gt;&quot;[...]&quot;&lt;/tt&gt;.  For example, an array containing only a reference
                  to itself would be rendered as &lt;tt&gt;&quot;[[...]]&quot;&lt;/tt&gt;.
                  &lt;p&gt;This method returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if the specified array
                  is &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    a the array whose string representation to return                    
                </param>
                <return>
                    a string representation of <tt>a</tt>                    
                </return>
                <see>
                    #toString(Object[])                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="deepToString" type="String" line="3605">
                <params>
                    <param name="a" type="Object[]"/>
                </params>
                <declaration name="bufLen" type="int" line="3609"/>
                <declaration name="buf" type="StringBuilder" line="3612"/>
            </method>
            <method name="deepToString" type="void" line="3618">
                <params>
                    <param name="a" type="Object[]"/>
                    <param name="buf" type="StringBuilder"/>
                    <param name="dejaVu" type="Set<Object[]>"/>
                </params>
                <comment line="3657">
                    element is an array of object references                    
                </comment>
                <comment line="3663">
                    element is non-null and not an array                    
                </comment>
                <scope line="3619"/>
                <declaration name="iMax" type="int" line="3623"/>
                <scope line="3624"/>
                <scope line="3631">
                    <declaration name="element" type="Object" line="3633"/>
                    <scope line="3634"/>
                    <scope line="3636">
                        <declaration name="eClass" type="Class" line="3637"/>
                        <scope line="3639">
                            <scope line="3656"/>
                        </scope>
                        <scope line="3662"/>
                    </scope>
                </scope>
            </method>
        </class>
    </source>