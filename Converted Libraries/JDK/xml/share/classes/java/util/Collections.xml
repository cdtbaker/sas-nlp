<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <import package="java.io.Serializable"/>
        <import package="java.io.ObjectOutputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.lang.reflect.Array"/>
        <class name="Collections" line="32">
            <comment line="73">
                Suppresses default constructor, ensuring non-instantiability.                
            </comment>
            <comment line="77">
                Algorithms                
            </comment>
            <comment line="79">
                Tuning parameters for algorithms - Many of the List algorithms have
                 two implementations, one of which is appropriate for RandomAccess
                 lists, the other for &quot;sequential.&quot;  Often, the random access variant
                 yields better performance on small sequential access lists.  The
                 tuning parameters below determine the cutoff point for what constitutes
                 a &quot;small&quot; sequential access list for each algorithm.  The values below
                 were empirically determined to work well for LinkedList. Hopefully
                 they should be reasonable for other sequential access List
                 implementations.  Those doing performance work on this code would
                 do well to validate the values of these parameters from time to time.
                 (The first word of each tuning parameter name is the algorithm to which
                 it applies.)                
            </comment>
            <comment line="1015">
                Unmodifiable Wrappers                
            </comment>
            <comment line="1553">
                Synch Wrappers                
            </comment>
            <comment line="2186">
                Dynamically typesafe collection wrappers                
            </comment>
            <comment line="2965">
                Empty collections                
            </comment>
            <comment line="3279">
                Singleton collections                
            </comment>
            <comment line="3438">
                Miscellaneous                
            </comment>
            <javadoc line="32">
                This class consists exclusively of static methods that operate on or return
                  collections.  It contains polymorphic algorithms that operate on
                  collections, &quot;wrappers&quot;, which return a new collection backed by a
                  specified collection, and a few other odds and ends.
                  &lt;p&gt;The methods of this class all throw a &lt;tt&gt;NullPointerException&lt;/tt&gt;
                  if the collections or class objects provided to them are null.
                  &lt;p&gt;The documentation for the polymorphic algorithms contained in this class
                  generally includes a brief description of the &lt;i&gt;implementation&lt;/i&gt;.  Such
                  descriptions should be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than
                  parts of the &lt;i&gt;specification&lt;/i&gt;.  Implementors should feel free to
                  substitute other algorithms, so long as the specification itself is adhered
                  to.  (For example, the algorithm used by &lt;tt&gt;sort&lt;/tt&gt; does not have to be
                  a mergesort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
                  &lt;p&gt;The &quot;destructive&quot; algorithms contained in this class, that is, the
                  algorithms that modify the collection on which they operate, are specified
                  to throw &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if the collection does not
                  support the appropriate mutation primitive(s), such as the &lt;tt&gt;set&lt;/tt&gt;
                  method.  These algorithms may, but are not required to, throw this
                  exception if an invocation would have no effect on the collection.  For
                  example, invoking the &lt;tt&gt;sort&lt;/tt&gt; method on an unmodifiable list that is
                  already sorted may or may not throw &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <author>
                    Josh Bloch                    
                </author>
                <author>
                    Neal Gafter                    
                </author>
                <see>
                    Collection                    
                </see>
                <see>
                    Set                    
                </see>
                <see>
                    List                    
                </see>
                <see>
                    Map                    
                </see>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="Collections" type="constructor" line="73"/>
            <declaration name="BINARYSEARCH_THRESHOLD" type="int" line="92"/>
            <declaration name="REVERSE_THRESHOLD" type="int" line="93"/>
            <declaration name="SHUFFLE_THRESHOLD" type="int" line="94"/>
            <declaration name="FILL_THRESHOLD" type="int" line="95"/>
            <declaration name="ROTATE_THRESHOLD" type="int" line="96"/>
            <declaration name="COPY_THRESHOLD" type="int" line="97"/>
            <declaration name="REPLACEALL_THRESHOLD" type="int" line="98"/>
            <declaration name="INDEXOFSUBLIST_THRESHOLD" type="int" line="99"/>
            <javadoc line="101">
                Sorts the specified list into ascending order, according to the{@linkplain Comparable natural ordering} of its elements.
                  All elements in the list must implement the {@link Comparable}interface.  Furthermore, all elements in the list must be
                  &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)}must not throw a {@code ClassCastException} for any elements{@code e1} and {@code e2} in the list).
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.
                  &lt;p&gt;The specified list must be modifiable, but need not be resizable.
                  &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
                  iterative mergesort that requires far fewer than n lg(n) comparisons
                  when the input array is partially sorted, while offering the
                  performance of a traditional mergesort when the input array is
                  randomly ordered.  If the input array is nearly sorted, the
                  implementation requires approximately n comparisons.  Temporary
                  storage requirements vary from a small constant for nearly sorted
                  input arrays to n/2 object references for randomly ordered input
                  arrays.
                  &lt;p&gt;The implementation takes equal advantage of ascending and
                  descending order in its input array, and can take advantage of
                  ascending and descending order in different parts of the same
                  input array.  It is well-suited to merging two or more sorted arrays:
                  simply concatenate the arrays and sort the resulting array.
                  &lt;p&gt;The implementation was adapted from Tim Peters&apos;s list sort for Python
                  (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
                  TimSort&lt;/a&gt;).  It uses techiques from Peter McIlroy&apos;s &quot;Optimistic
                  Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
                  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
                  January 1993.
                  &lt;p&gt;This implementation dumps the specified list into an array, sorts
                  the array, and iterates over the list resetting each element
                  from the corresponding position in the array.  This avoids the
                  n&lt;sup&gt;2&lt;/sup&gt; log(n) performance that would result from attempting
                  to sort a linked list in place.                
                <param>
                    list the list to be sorted.                    
                </param>
                <throws>
                    ClassCastException if the list contains elements that are not
                      <i>mutually comparable</i> (for example, strings and integers).                    
                </throws>
                <throws>
                    UnsupportedOperationException if the specified list's
                      list-iterator does not support the {@code set} operation.                    
                </throws>
                <throws>
                    IllegalArgumentException (optional) if the implementation
                      detects that the natural ordering of the list elements is
                      found to violate the {@link Comparable} contract                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="153">
                <params>
                    <param name="list" type="List<T>"/>
                </params>
                <declaration name="a" type="Object[]" line="154"/>
                <declaration name="i" type="ListIterator&lt;T&gt;" line="156"/>
                <scope line="157"/>
            </method>
            <javadoc line="163">
                Sorts the specified list according to the order induced by the
                  specified comparator.  All elements in the list must be &lt;i&gt;mutually
                  comparable&lt;/i&gt; using the specified comparator (that is,{@code c.compare(e1, e2)} must not throw a {@code ClassCastException}for any elements {@code e1} and {@code e2} in the list).
                  &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
                  not be reordered as a result of the sort.
                  &lt;p&gt;The specified list must be modifiable, but need not be resizable.
                  &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
                  iterative mergesort that requires far fewer than n lg(n) comparisons
                  when the input array is partially sorted, while offering the
                  performance of a traditional mergesort when the input array is
                  randomly ordered.  If the input array is nearly sorted, the
                  implementation requires approximately n comparisons.  Temporary
                  storage requirements vary from a small constant for nearly sorted
                  input arrays to n/2 object references for randomly ordered input
                  arrays.
                  &lt;p&gt;The implementation takes equal advantage of ascending and
                  descending order in its input array, and can take advantage of
                  ascending and descending order in different parts of the same
                  input array.  It is well-suited to merging two or more sorted arrays:
                  simply concatenate the arrays and sort the resulting array.
                  &lt;p&gt;The implementation was adapted from Tim Peters&apos;s list sort for Python
                  (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
                  TimSort&lt;/a&gt;).  It uses techiques from Peter McIlroy&apos;s &quot;Optimistic
                  Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
                  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
                  January 1993.
                  &lt;p&gt;This implementation dumps the specified list into an array, sorts
                  the array, and iterates over the list resetting each element
                  from the corresponding position in the array.  This avoids the
                  n&lt;sup&gt;2&lt;/sup&gt; log(n) performance that would result from attempting
                  to sort a linked list in place.                
                <param>
                    list the list to be sorted.                    
                </param>
                <param>
                    c the comparator to determine the order of the list.  A{@code null} value indicates that the elements' <i>natural
                      ordering</i> should be used.                    
                </param>
                <throws>
                    ClassCastException if the list contains elements that are not
                      <i>mutually comparable</i> using the specified comparator.                    
                </throws>
                <throws>
                    UnsupportedOperationException if the specified list's
                      list-iterator does not support the {@code set} operation.                    
                </throws>
                <throws>
                    IllegalArgumentException (optional) if the comparator is
                      found to violate the {@link Comparator} contract                    
                </throws>
            </javadoc>
            <method name="sort" type="void" line="215">
                <params>
                    <param name="list" type="List<T>"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <declaration name="a" type="Object[]" line="216"/>
                <declaration name="i" type="ListIterator" line="218"/>
                <scope line="219"/>
            </method>
            <javadoc line="226">
                Searches the specified list for the specified object using the binary
                  search algorithm.  The list must be sorted into ascending order
                  according to the {@linkplain Comparable natural ordering} of its
                  elements (as by the {@link #sort(List)} method) prior to making this
                  call.  If it is not sorted, the results are undefined.  If the list
                  contains multiple elements equal to the specified object, there is no
                  guarantee which one will be found.
                  &lt;p&gt;This method runs in log(n) time for a &quot;random access&quot; list (which
                  provides near-constant-time positional access).  If the specified list
                  does not implement the {@link RandomAccess} interface and is large,
                  this method will do an iterator-based binary search that performs
                  O(n) link traversals and O(log n) element comparisons.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the key to be searched for.                    
                </param>
                <return>
                    the index of the search key, if it is contained in the list;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the list: the index of the first
                      element greater than the key, or <tt>list.size()</tt> if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    ClassCastException if the list contains elements that are not
                      <i>mutually comparable</i> (for example, strings and
                      integers), or the search key is not mutually comparable
                      with the elements of the list.                    
                </throws>
            </javadoc>
            <method name="binarySearch" type="int" line="257">
                <params>
                    <param name="list" type="List<? extends Comparable<? super T>>"/>
                    <param name="key" type="T"/>
                </params>
            </method>
            <method name="indexedBinarySearch" type="int" line="266">
                <params>
                    <param name="list" type="List<? extends Comparable<? super T>>"/>
                    <param name="key" type="T"/>
                </params>
                <comment line="280">
                    key found                    
                </comment>
                <comment line="282">
                    key not found                    
                </comment>
                <declaration name="low" type="int" line="267"/>
                <declaration name="high" type="int" line="268"/>
                <scope line="270">
                    <declaration name="mid" type="int" line="271"/>
                    <declaration name="midVal" type="Comparable&lt;? super T&gt;" line="272"/>
                    <declaration name="cmp" type="int" line="273"/>
                </scope>
            </method>
            <method name="iteratorBinarySearch" type="int" line="287">
                <params>
                    <param name="list" type="List<? extends Comparable<? super T>>"/>
                    <param name="key" type="T"/>
                </params>
                <comment line="302">
                    key found                    
                </comment>
                <comment line="304">
                    key not found                    
                </comment>
                <declaration name="low" type="int" line="288"/>
                <declaration name="high" type="int" line="289"/>
                <declaration name="i" type="ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt;" line="290"/>
                <scope line="292">
                    <declaration name="mid" type="int" line="293"/>
                    <declaration name="midVal" type="Comparable&lt;? super T&gt;" line="294"/>
                    <declaration name="cmp" type="int" line="295"/>
                </scope>
            </method>
            <javadoc line="307">
                Gets the ith element from the given list by repositioning the specified
                  list listIterator.                
            </javadoc>
            <method name="get" type="T" line="311">
                <params>
                    <param name="i" type="ListIterator<? extends T>"/>
                    <param name="index" type="int"/>
                </params>
                <declaration name="obj" type="T" line="312"/>
                <declaration name="pos" type="int" line="313"/>
                <scope line="314">
                    <scope line="315"/>
                </scope>
                <scope line="318">
                    <scope line="319"/>
                </scope>
            </method>
            <javadoc line="326">
                Searches the specified list for the specified object using the binary
                  search algorithm.  The list must be sorted into ascending order
                  according to the specified comparator (as by the{@link #sort(List,Comparator) sort(List, Comparator)}method), prior to making this call.  If it is
                  not sorted, the results are undefined.  If the list contains multiple
                  elements equal to the specified object, there is no guarantee which one
                  will be found.
                  &lt;p&gt;This method runs in log(n) time for a &quot;random access&quot; list (which
                  provides near-constant-time positional access).  If the specified list
                  does not implement the {@link RandomAccess} interface and is large,
                  this method will do an iterator-based binary search that performs
                  O(n) link traversals and O(log n) element comparisons.                
                <param>
                    list the list to be searched.                    
                </param>
                <param>
                    key the key to be searched for.                    
                </param>
                <param>
                    c the comparator by which the list is ordered.
                      A <tt>null</tt> value indicates that the elements'{@linkplain Comparable natural ordering} should be used.                    
                </param>
                <return>
                    the index of the search key, if it is contained in the list;
                      otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
                      <i>insertion point</i> is defined as the point at which the
                      key would be inserted into the list: the index of the first
                      element greater than the key, or <tt>list.size()</tt> if all
                      elements in the list are less than the specified key.  Note
                      that this guarantees that the return value will be &gt;= 0 if
                      and only if the key is found.                    
                </return>
                <throws>
                    ClassCastException if the list contains elements that are not
                      <i>mutually comparable</i> using the specified comparator,
                      or the search key is not mutually comparable with the
                      elements of the list using this comparator.                    
                </throws>
            </javadoc>
            <method name="binarySearch" type="int" line="360">
                <params>
                    <param name="list" type="List<? extends T>"/>
                    <param name="key" type="T"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
            </method>
            <method name="indexedBinarySearch" type="int" line="370">
                <params>
                    <param name="l" type="List<? extends T>"/>
                    <param name="key" type="T"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <comment line="384">
                    key found                    
                </comment>
                <comment line="386">
                    key not found                    
                </comment>
                <declaration name="low" type="int" line="371"/>
                <declaration name="high" type="int" line="372"/>
                <scope line="374">
                    <declaration name="mid" type="int" line="375"/>
                    <declaration name="midVal" type="T" line="376"/>
                    <declaration name="cmp" type="int" line="377"/>
                </scope>
            </method>
            <method name="iteratorBinarySearch" type="int" line="389">
                <params>
                    <param name="l" type="List<? extends T>"/>
                    <param name="key" type="T"/>
                    <param name="c" type="Comparator<? super T>"/>
                </params>
                <comment line="404">
                    key found                    
                </comment>
                <comment line="406">
                    key not found                    
                </comment>
                <declaration name="low" type="int" line="390"/>
                <declaration name="high" type="int" line="391"/>
                <declaration name="i" type="ListIterator&lt;? extends T&gt;" line="392"/>
                <scope line="394">
                    <declaration name="mid" type="int" line="395"/>
                    <declaration name="midVal" type="T" line="396"/>
                    <declaration name="cmp" type="int" line="397"/>
                </scope>
            </method>
            <interface name="SelfComparable">
                <implements interface="Comparable">
                    <type_params>
                        <type_param name="SelfComparable"/>
                    </type_params>
                </implements>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
            </interface>
            <javadoc line="412">
                Reverses the order of the elements in the specified list.&lt;p&gt;
                  This method runs in linear time.                
                <param>
                    list the list whose elements are to be reversed.                    
                </param>
                <throws>
                    UnsupportedOperationException if the specified list or
                      its list-iterator does not support the <tt>set</tt> operation.                    
                </throws>
            </javadoc>
            <method name="reverse" type="void" line="421">
                <params>
                    <param name="list" type="List<?>"/>
                </params>
                <declaration name="size" type="int" line="422"/>
                <scope line="423"/>
                <scope line="426">
                    <declaration name="fwd" type="ListIterator" line="427"/>
                    <declaration name="rev" type="ListIterator" line="428"/>
                    <scope line="429">
                        <declaration name="tmp" type="Object" line="430"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="437">
                Randomly permutes the specified list using a default source of
                  randomness.  All permutations occur with approximately equal
                  likelihood.&lt;p&gt;
                  The hedge &quot;approximately&quot; is used in the foregoing description because
                  default source of randomness is only approximately an unbiased source
                  of independently chosen bits. If it were a perfect source of randomly
                  chosen bits, then the algorithm would choose permutations with perfect
                  uniformity.&lt;p&gt;
                  This implementation traverses the list backwards, from the last element
                  up to the second, repeatedly swapping a randomly selected element into
                  the &quot;current position&quot;.  Elements are randomly selected from the
                  portion of the list that runs from the first element to the current
                  position, inclusive.&lt;p&gt;
                  This method runs in linear time.  If the specified list does not
                  implement the {@link RandomAccess} interface and is large, this
                  implementation dumps the specified list into an array before shuffling
                  it, and dumps the shuffled array back into the list.  This avoids the
                  quadratic behavior that would result from shuffling a &quot;sequential
                  access&quot; list in place.                
                <param>
                    list the list to be shuffled.                    
                </param>
                <throws>
                    UnsupportedOperationException if the specified list or
                      its list-iterator does not support the <tt>set</tt> operation.                    
                </throws>
            </javadoc>
            <method name="shuffle" type="void" line="465">
                <params>
                    <param name="list" type="List<?>"/>
                </params>
                <declaration name="rnd" type="Random" line="466"/>
            </method>
            <declaration name="r" type="Random" line="471"/>
            <javadoc line="473">
                Randomly permute the specified list using the specified source of
                  randomness.  All permutations occur with equal likelihood
                  assuming that the source of randomness is fair.&lt;p&gt;
                  This implementation traverses the list backwards, from the last element
                  up to the second, repeatedly swapping a randomly selected element into
                  the &quot;current position&quot;.  Elements are randomly selected from the
                  portion of the list that runs from the first element to the current
                  position, inclusive.&lt;p&gt;
                  This method runs in linear time.  If the specified list does not
                  implement the {@link RandomAccess} interface and is large, this
                  implementation dumps the specified list into an array before shuffling
                  it, and dumps the shuffled array back into the list.  This avoids the
                  quadratic behavior that would result from shuffling a &quot;sequential
                  access&quot; list in place.                
                <param>
                    list the list to be shuffled.                    
                </param>
                <param>
                    rnd the source of randomness to use to shuffle the list.                    
                </param>
                <throws>
                    UnsupportedOperationException if the specified list or its
                      list-iterator does not support the <tt>set</tt> operation.                    
                </throws>
            </javadoc>
            <method name="shuffle" type="void" line="496">
                <params>
                    <param name="list" type="List<?>"/>
                    <param name="rnd" type="Random"/>
                </params>
                <comment line="504">
                    Shuffle array                    
                </comment>
                <comment line="508">
                    Dump array back into list                    
                </comment>
                <declaration name="size" type="int" line="497"/>
                <scope line="498"/>
                <scope line="501">
                    <declaration name="arr" type="Object" line="502"/>
                    <declaration name="it" type="ListIterator" line="509"/>
                    <scope line="510"/>
                </scope>
            </method>
            <javadoc line="517">
                Swaps the elements at the specified positions in the specified list.
                  (If the specified positions are equal, invoking this method leaves
                  the list unchanged.)                
                <param>
                    list The list in which to swap elements.                    
                </param>
                <param>
                    i the index of one element to be swapped.                    
                </param>
                <param>
                    j the index of the other element to be swapped.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if either <tt>i</tt> or <tt>j</tt>
                      is out of range (i &lt; 0 || i &gt;= list.size()
                      || j &lt; 0 || j &gt;= list.size()).                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="swap" type="void" line="530">
                <params>
                    <param name="list" type="List<?>"/>
                    <param name="i" type="int"/>
                    <param name="j" type="int"/>
                </params>
                <declaration name="l" type="List" line="531"/>
            </method>
            <javadoc line="535">
                Swaps the two specified elements in the specified array.                
            </javadoc>
            <method name="swap" type="void" line="538">
                <params>
                    <param name="arr" type="Object[]"/>
                    <param name="i" type="int"/>
                    <param name="j" type="int"/>
                </params>
                <declaration name="tmp" type="Object" line="539"/>
            </method>
            <javadoc line="544">
                Replaces all of the elements of the specified list with the specified
                  element. &lt;p&gt;
                  This method runs in linear time.                
                <param>
                    list the list to be filled with the specified element.                    
                </param>
                <param>
                    obj The element with which to fill the specified list.                    
                </param>
                <throws>
                    UnsupportedOperationException if the specified list or its
                      list-iterator does not support the <tt>set</tt> operation.                    
                </throws>
            </javadoc>
            <method name="fill" type="void" line="555">
                <params>
                    <param name="list" type="List<? super T>"/>
                    <param name="obj" type="T"/>
                </params>
                <declaration name="size" type="int" line="556"/>
                <scope line="558"/>
                <scope line="561">
                    <declaration name="itr" type="ListIterator&lt;? super T&gt;" line="562"/>
                    <scope line="563"/>
                </scope>
            </method>
            <javadoc line="570">
                Copies all of the elements from one list into another.  After the
                  operation, the index of each copied element in the destination list
                  will be identical to its index in the source list.  The destination
                  list must be at least as long as the source list.  If it is longer, the
                  remaining elements in the destination list are unaffected. &lt;p&gt;
                  This method runs in linear time.                
                <param>
                    dest The destination list.                    
                </param>
                <param>
                    src The source list.                    
                </param>
                <throws>
                    IndexOutOfBoundsException if the destination list is too small
                      to contain the entire source List.                    
                </throws>
                <throws>
                    UnsupportedOperationException if the destination list's
                      list-iterator does not support the <tt>set</tt> operation.                    
                </throws>
            </javadoc>
            <method name="copy" type="void" line="586">
                <params>
                    <param name="dest" type="List<? super T>"/>
                    <param name="src" type="List<? extends T>"/>
                </params>
                <declaration name="srcSize" type="int" line="587"/>
                <scope line="592"/>
                <scope line="595">
                    <declaration name="di" type="ListIterator&lt;? super T&gt;" line="596"/>
                    <declaration name="si" type="ListIterator&lt;? extends T&gt;" line="597"/>
                    <scope line="598"/>
                </scope>
            </method>
            <javadoc line="605">
                Returns the minimum element of the given collection, according to the
                  &lt;i&gt;natural ordering&lt;/i&gt; of its elements.  All elements in the
                  collection must implement the &lt;tt&gt;Comparable&lt;/tt&gt; interface.
                  Furthermore, all elements in the collection must be &lt;i&gt;mutually
                  comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the collection).&lt;p&gt;
                  This method iterates over the entire collection, hence it requires
                  time proportional to the size of the collection.                
                <param>
                    coll the collection whose minimum element is to be determined.                    
                </param>
                <return>
                    the minimum element of the given collection, according
                      to the <i>natural ordering</i> of its elements.                    
                </return>
                <throws>
                    ClassCastException if the collection contains elements that are
                      not <i>mutually comparable</i> (for example, strings and
                      integers).                    
                </throws>
                <throws>
                    NoSuchElementException if the collection is empty.                    
                </throws>
                <see>
                    Comparable                    
                </see>
            </javadoc>
            <method name="min" type="T" line="626">
                <params>
                    <param name="coll" type="Collection<? extends T>"/>
                </params>
                <declaration name="i" type="Iterator&lt;? extends T&gt;" line="627"/>
                <declaration name="candidate" type="T" line="628"/>
                <scope line="630">
                    <declaration name="next" type="T" line="631"/>
                </scope>
            </method>
            <javadoc line="638">
                Returns the minimum element of the given collection, according to the
                  order induced by the specified comparator.  All elements in the
                  collection must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified
                  comparator (that is, &lt;tt&gt;comp.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the collection).&lt;p&gt;
                  This method iterates over the entire collection, hence it requires
                  time proportional to the size of the collection.                
                <param>
                    coll the collection whose minimum element is to be determined.                    
                </param>
                <param>
                    comp the comparator with which to determine the minimum element.
                      A <tt>null</tt> value indicates that the elements' <i>natural
                      ordering</i> should be used.                    
                </param>
                <return>
                    the minimum element of the given collection, according
                      to the specified comparator.                    
                </return>
                <throws>
                    ClassCastException if the collection contains elements that are
                      not <i>mutually comparable</i> using the specified comparator.                    
                </throws>
                <throws>
                    NoSuchElementException if the collection is empty.                    
                </throws>
                <see>
                    Comparable                    
                </see>
            </javadoc>
            <method name="min" type="T" line="660">
                <params>
                    <param name="coll" type="Collection<? extends T>"/>
                    <param name="comp" type="Comparator<? super T>"/>
                </params>
                <declaration name="i" type="Iterator&lt;? extends T&gt;" line="664"/>
                <declaration name="candidate" type="T" line="665"/>
                <scope line="667">
                    <declaration name="next" type="T" line="668"/>
                </scope>
            </method>
            <javadoc line="675">
                Returns the maximum element of the given collection, according to the
                  &lt;i&gt;natural ordering&lt;/i&gt; of its elements.  All elements in the
                  collection must implement the &lt;tt&gt;Comparable&lt;/tt&gt; interface.
                  Furthermore, all elements in the collection must be &lt;i&gt;mutually
                  comparable&lt;/i&gt; (that is, &lt;tt&gt;e1.compareTo(e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the collection).&lt;p&gt;
                  This method iterates over the entire collection, hence it requires
                  time proportional to the size of the collection.                
                <param>
                    coll the collection whose maximum element is to be determined.                    
                </param>
                <return>
                    the maximum element of the given collection, according
                      to the <i>natural ordering</i> of its elements.                    
                </return>
                <throws>
                    ClassCastException if the collection contains elements that are
                      not <i>mutually comparable</i> (for example, strings and
                      integers).                    
                </throws>
                <throws>
                    NoSuchElementException if the collection is empty.                    
                </throws>
                <see>
                    Comparable                    
                </see>
            </javadoc>
            <method name="max" type="T" line="696">
                <params>
                    <param name="coll" type="Collection<? extends T>"/>
                </params>
                <declaration name="i" type="Iterator&lt;? extends T&gt;" line="697"/>
                <declaration name="candidate" type="T" line="698"/>
                <scope line="700">
                    <declaration name="next" type="T" line="701"/>
                </scope>
            </method>
            <javadoc line="708">
                Returns the maximum element of the given collection, according to the
                  order induced by the specified comparator.  All elements in the
                  collection must be &lt;i&gt;mutually comparable&lt;/i&gt; by the specified
                  comparator (that is, &lt;tt&gt;comp.compare(e1, e2)&lt;/tt&gt; must not throw a
                  &lt;tt&gt;ClassCastException&lt;/tt&gt; for any elements &lt;tt&gt;e1&lt;/tt&gt; and
                  &lt;tt&gt;e2&lt;/tt&gt; in the collection).&lt;p&gt;
                  This method iterates over the entire collection, hence it requires
                  time proportional to the size of the collection.                
                <param>
                    coll the collection whose maximum element is to be determined.                    
                </param>
                <param>
                    comp the comparator with which to determine the maximum element.
                      A <tt>null</tt> value indicates that the elements' <i>natural
                      ordering</i> should be used.                    
                </param>
                <return>
                    the maximum element of the given collection, according
                      to the specified comparator.                    
                </return>
                <throws>
                    ClassCastException if the collection contains elements that are
                      not <i>mutually comparable</i> using the specified comparator.                    
                </throws>
                <throws>
                    NoSuchElementException if the collection is empty.                    
                </throws>
                <see>
                    Comparable                    
                </see>
            </javadoc>
            <method name="max" type="T" line="730">
                <params>
                    <param name="coll" type="Collection<? extends T>"/>
                    <param name="comp" type="Comparator<? super T>"/>
                </params>
                <declaration name="i" type="Iterator&lt;? extends T&gt;" line="734"/>
                <declaration name="candidate" type="T" line="735"/>
                <scope line="737">
                    <declaration name="next" type="T" line="738"/>
                </scope>
            </method>
            <javadoc line="745">
                Rotates the elements in the specified list by the specified distance.
                  After calling this method, the element at index &lt;tt&gt;i&lt;/tt&gt; will be
                  the element previously at index &lt;tt&gt;(i - distance)&lt;/tt&gt; mod
                  &lt;tt&gt;list.size()&lt;/tt&gt;, for all values of &lt;tt&gt;i&lt;/tt&gt; between &lt;tt&gt;0&lt;/tt&gt;
                  and &lt;tt&gt;list.size()-1&lt;/tt&gt;, inclusive.  (This method has no effect on
                  the size of the list.)
                  &lt;p&gt;For example, suppose &lt;tt&gt;list&lt;/tt&gt; comprises&lt;tt&gt; [t, a, n, k, s]&lt;/tt&gt;.
                  After invoking &lt;tt&gt;Collections.rotate(list, 1)&lt;/tt&gt; (or
                  &lt;tt&gt;Collections.rotate(list, -4)&lt;/tt&gt;), &lt;tt&gt;list&lt;/tt&gt; will comprise
                  &lt;tt&gt;[s, t, a, n, k]&lt;/tt&gt;.
                  &lt;p&gt;Note that this method can usefully be applied to sublists to
                  move one or more elements within a list while preserving the
                  order of the remaining elements.  For example, the following idiom
                  moves the element at index &lt;tt&gt;j&lt;/tt&gt; forward to position
                  &lt;tt&gt;k&lt;/tt&gt; (which must be greater than or equal to &lt;tt&gt;j&lt;/tt&gt;):
                  &lt;pre&gt;
                  Collections.rotate(list.subList(j, k+1), -1);
                  &lt;/pre&gt;
                  To make this concrete, suppose &lt;tt&gt;list&lt;/tt&gt; comprises
                  &lt;tt&gt;[a, b, c, d, e]&lt;/tt&gt;.  To move the element at index &lt;tt&gt;1&lt;/tt&gt;
                  (&lt;tt&gt;b&lt;/tt&gt;) forward two positions, perform the following invocation:
                  &lt;pre&gt;
                  Collections.rotate(l.subList(1, 4), -1);
                  &lt;/pre&gt;
                  The resulting list is &lt;tt&gt;[a, c, d, b, e]&lt;/tt&gt;.
                  &lt;p&gt;To move more than one element forward, increase the absolute value
                  of the rotation distance.  To move elements backward, use a positive
                  shift distance.
                  &lt;p&gt;If the specified list is small or implements the {@link RandomAccess} interface, this implementation exchanges the first
                  element into the location it should go, and then repeatedly exchanges
                  the displaced element into the location it should go until a displaced
                  element is swapped into the first element.  If necessary, the process
                  is repeated on the second and successive elements, until the rotation
                  is complete.  If the specified list is large and doesn&apos;t implement the
                  &lt;tt&gt;RandomAccess&lt;/tt&gt; interface, this implementation breaks the
                  list into two sublist views around index &lt;tt&gt;-distance mod size&lt;/tt&gt;.
                  Then the {@link #reverse(List)} method is invoked on each sublist view,
                  and finally it is invoked on the entire list.  For a more complete
                  description of both algorithms, see Section 2.3 of Jon Bentley&apos;s
                  &lt;i&gt;Programming Pearls&lt;/i&gt; (Addison-Wesley, 1986).                
                <param>
                    list the list to be rotated.                    
                </param>
                <param>
                    distance the distance to rotate the list.  There are no
                      constraints on this value; it may be zero, negative, or
                      greater than <tt>list.size()</tt>.                    
                </param>
                <throws>
                    UnsupportedOperationException if the specified list or
                      its list-iterator does not support the <tt>set</tt> operation.                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="rotate" type="void" line="800">
                <params>
                    <param name="list" type="List<?>"/>
                    <param name="distance" type="int"/>
                </params>
            </method>
            <method name="rotate1" type="void" line="807">
                <params>
                    <param name="list" type="List<T>"/>
                    <param name="distance" type="int"/>
                </params>
                <declaration name="size" type="int" line="808"/>
                <scope line="817">
                    <declaration name="displaced" type="T" line="818"/>
                    <declaration name="i" type="int" line="819"/>
                    <scope line="820"/>
                </scope>
            </method>
            <method name="rotate2" type="void" line="830">
                <params>
                    <param name="list" type="List<?>"/>
                    <param name="distance" type="int"/>
                </params>
                <declaration name="size" type="int" line="831"/>
                <declaration name="mid" type="int" line="834"/>
            </method>
            <javadoc line="845">
                Replaces all occurrences of one specified value in a list with another.
                  More formally, replaces with &lt;tt&gt;newVal&lt;/tt&gt; each element &lt;tt&gt;e&lt;/tt&gt;
                  in &lt;tt&gt;list&lt;/tt&gt; such that
                  &lt;tt&gt;(oldVal==null ? e==null : oldVal.equals(e))&lt;/tt&gt;.
                  (This method has no effect on the size of the list.)                
                <param>
                    list the list in which replacement is to occur.                    
                </param>
                <param>
                    oldVal the old value to be replaced.                    
                </param>
                <param>
                    newVal the new value with which <tt>oldVal</tt> is to be
                      replaced.                    
                </param>
                <return>
                    <tt>true</tt> if <tt>list</tt> contained one or more elements
                      <tt>e</tt> such that
                      <tt>(oldVal==null ?  e==null : oldVal.equals(e))</tt>.                    
                </return>
                <throws>
                    UnsupportedOperationException if the specified list or
                      its list-iterator does not support the <tt>set</tt> operation.                    
                </throws>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="replaceAll" type="boolean" line="863">
                <params>
                    <param name="list" type="List<T>"/>
                    <param name="oldVal" type="T"/>
                    <param name="newVal" type="T"/>
                </params>
                <declaration name="result" type="boolean" line="864"/>
                <declaration name="size" type="int" line="865"/>
                <scope line="866">
                    <scope line="867">
                        <scope line="868">
                            <scope line="869"/>
                        </scope>
                    </scope>
                    <scope line="874">
                        <scope line="875">
                            <scope line="876"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="882">
                    <declaration name="itr" type="ListIterator&lt;T&gt;" line="883"/>
                    <scope line="884">
                        <scope line="885">
                            <scope line="886"/>
                        </scope>
                    </scope>
                    <scope line="891">
                        <scope line="892">
                            <scope line="893"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="903">
                Returns the starting position of the first occurrence of the specified
                  target list within the specified source list, or -1 if there is no
                  such occurrence.  More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt;
                  such that &lt;tt&gt;source.subList(i, i+target.size()).equals(target)&lt;/tt&gt;,
                  or -1 if there is no such index.  (Returns -1 if
                  &lt;tt&gt;target.size() &gt; source.size()&lt;/tt&gt;.)
                  &lt;p&gt;This implementation uses the &quot;brute force&quot; technique of scanning
                  over the source list, looking for a match with the target at each
                  location in turn.                
                <param>
                    source the list in which to search for the first occurrence
                      of <tt>target</tt>.                    
                </param>
                <param>
                    target the list to search for as a subList of <tt>source</tt>.                    
                </param>
                <return>
                    the starting position of the first occurrence of the specified
                      target list within the specified source list, or -1 if there
                      is no such occurrence.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="indexOfSubList" type="int" line="923">
                <params>
                    <param name="source" type="List<?>"/>
                    <param name="target" type="List<?>"/>
                </params>
                <comment line="934">
                    Element mismatch, try next cand                    
                </comment>
                <comment line="935">
                    All elements of candidate matched target                    
                </comment>
                <comment line="937">
                    Iterator version of above algorithm                    
                </comment>
                <comment line="944">
                    Back up source iterator to next candidate                    
                </comment>
                <comment line="953">
                    No candidate matched the target                    
                </comment>
                <declaration name="sourceSize" type="int" line="924"/>
                <declaration name="targetSize" type="int" line="925"/>
                <declaration name="maxCandidate" type="int" line="926"/>
                <scope line="929">
                    <scope line="931"/>
                </scope>
                <scope line="937">
                    <declaration name="si" type="ListIterator&lt;?&gt;" line="938"/>
                    <scope line="940">
                        <declaration name="ti" type="ListIterator&lt;?&gt;" line="941"/>
                        <scope line="942">
                            <scope line="943"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="956">
                Returns the starting position of the last occurrence of the specified
                  target list within the specified source list, or -1 if there is no such
                  occurrence.  More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt;
                  such that &lt;tt&gt;source.subList(i, i+target.size()).equals(target)&lt;/tt&gt;,
                  or -1 if there is no such index.  (Returns -1 if
                  &lt;tt&gt;target.size() &gt; source.size()&lt;/tt&gt;.)
                  &lt;p&gt;This implementation uses the &quot;brute force&quot; technique of iterating
                  over the source list, looking for a match with the target at each
                  location in turn.                
                <param>
                    source the list in which to search for the last occurrence
                      of <tt>target</tt>.                    
                </param>
                <param>
                    target the list to search for as a subList of <tt>source</tt>.                    
                </param>
                <return>
                    the starting position of the last occurrence of the specified
                      target list within the specified source list, or -1 if there
                      is no such occurrence.                    
                </return>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="lastIndexOfSubList" type="int" line="976">
                <params>
                    <param name="source" type="List<?>"/>
                    <param name="target" type="List<?>"/>
                </params>
                <comment line="982">
                    Index access version                    
                </comment>
                <comment line="987">
                    Element mismatch, try next cand                    
                </comment>
                <comment line="988">
                    All elements of candidate matched target                    
                </comment>
                <comment line="990">
                    Iterator version of above algorithm                    
                </comment>
                <comment line="1000">
                    Back up source iterator to next candidate                    
                </comment>
                <comment line="1010">
                    No candidate matched the target                    
                </comment>
                <declaration name="sourceSize" type="int" line="977"/>
                <declaration name="targetSize" type="int" line="978"/>
                <declaration name="maxCandidate" type="int" line="979"/>
                <scope line="982">
                    <scope line="984"/>
                </scope>
                <scope line="990">
                    <declaration name="si" type="ListIterator&lt;?&gt;" line="993"/>
                    <scope line="995">
                        <declaration name="ti" type="ListIterator&lt;?&gt;" line="996"/>
                        <scope line="997">
                            <scope line="998">
                                <scope line="999"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1016">
                Returns an unmodifiable view of the specified collection.  This method
                  allows modules to provide users with &quot;read-only&quot; access to internal
                  collections.  Query operations on the returned collection &quot;read through&quot;
                  to the specified collection, and attempts to modify the returned
                  collection, whether direct or via its iterator, result in an
                  &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
                  The returned collection does &lt;i&gt;not&lt;/i&gt; pass the hashCode and equals
                  operations through to the backing collection, but relies on
                  &lt;tt&gt;Object&lt;/tt&gt;&apos;s &lt;tt&gt;equals&lt;/tt&gt; and &lt;tt&gt;hashCode&lt;/tt&gt; methods.  This
                  is necessary to preserve the contracts of these operations in the case
                  that the backing collection is a set or a list.&lt;p&gt;
                  The returned collection will be serializable if the specified collection
                  is serializable.                
                <param>
                    c the collection for which an unmodifiable view is to be
                      returned.                    
                </param>
                <return>
                    an unmodifiable view of the specified collection.                    
                </return>
            </javadoc>
            <method name="unmodifiableCollection" type="Collection<T>" line="1037">
                <params>
                    <param name="c" type="Collection<? extends T>"/>
                </params>
            </method>
            <class name="UnmodifiableCollection" line="1041">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Collection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="1041">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1045"/>
                <declaration name="c" type="Collection&lt;? extends E&gt;" line="1047"/>
                <method name="UnmodifiableCollection" type="constructor" line="1049">
                    <params>
                        <param name="c" type="Collection<? extends E>"/>
                    </params>
                </method>
                <method name="size" type="int" line="1055"/>
                <method name="isEmpty" type="boolean" line="1056"/>
                <method name="contains" type="boolean" line="1057">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="toArray" type="Object[]" line="1058"/>
                <method name="toArray" type="T[]" line="1059">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
                <method name="toString" type="String" line="1060"/>
                <method name="iterator" type="Iterator<E>" line="1062">
                    <anonymous_class line="1063">
                        <declaration name="i" type="Iterator&lt;? extends E&gt;" line="1064"/>
                        <method name="hasNext" type="boolean" line="1066"/>
                        <method name="next" type="E" line="1067"/>
                        <method name="remove" type="void" line="1068"/>
                    </anonymous_class>
                </method>
                <method name="add" type="boolean" line="1074">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="1077">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="containsAll" type="boolean" line="1081">
                    <params>
                        <param name="coll" type="Collection<?>"/>
                    </params>
                </method>
                <method name="addAll" type="boolean" line="1084">
                    <params>
                        <param name="coll" type="Collection<? extends E>"/>
                    </params>
                </method>
                <method name="removeAll" type="boolean" line="1087">
                    <params>
                        <param name="coll" type="Collection<?>"/>
                    </params>
                </method>
                <method name="retainAll" type="boolean" line="1090">
                    <params>
                        <param name="coll" type="Collection<?>"/>
                    </params>
                </method>
                <method name="clear" type="void" line="1093"/>
            </class>
            <javadoc line="1098">
                Returns an unmodifiable view of the specified set.  This method allows
                  modules to provide users with &quot;read-only&quot; access to internal sets.
                  Query operations on the returned set &quot;read through&quot; to the specified
                  set, and attempts to modify the returned set, whether direct or via its
                  iterator, result in an &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
                  The returned set will be serializable if the specified set
                  is serializable.                
                <param>
                    s the set for which an unmodifiable view is to be returned.                    
                </param>
                <return>
                    an unmodifiable view of the specified set.                    
                </return>
            </javadoc>
            <method name="unmodifiableSet" type="Set<T>" line="1111">
                <params>
                    <param name="s" type="Set<? extends T>"/>
                </params>
            </method>
            <class name="UnmodifiableSet" line="1115">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="UnmodifiableCollection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Set">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="1115">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1120"/>
                <method name="UnmodifiableSet" type="constructor" line="1122">
                    <params>
                        <param name="s" type="Set<? extends E>"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="1123">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="1124"/>
            </class>
            <javadoc line="1127">
                Returns an unmodifiable view of the specified sorted set.  This method
                  allows modules to provide users with &quot;read-only&quot; access to internal
                  sorted sets.  Query operations on the returned sorted set &quot;read
                  through&quot; to the specified sorted set.  Attempts to modify the returned
                  sorted set, whether direct, via its iterator, or via its
                  &lt;tt&gt;subSet&lt;/tt&gt;, &lt;tt&gt;headSet&lt;/tt&gt;, or &lt;tt&gt;tailSet&lt;/tt&gt; views, result in
                  an &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
                  The returned sorted set will be serializable if the specified sorted set
                  is serializable.                
                <param>
                    s the sorted set for which an unmodifiable view is to be
                      returned.                    
                </param>
                <return>
                    an unmodifiable view of the specified sorted set.                    
                </return>
            </javadoc>
            <method name="unmodifiableSortedSet" type="SortedSet<T>" line="1143">
                <params>
                    <param name="s" type="SortedSet<T>"/>
                </params>
            </method>
            <class name="UnmodifiableSortedSet" line="1147">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="UnmodifiableSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="SortedSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="1147">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1153"/>
                <declaration name="ss" type="SortedSet&lt;E&gt;" line="1154"/>
                <method name="UnmodifiableSortedSet" type="constructor" line="1156">
                    <params>
                        <param name="s" type="SortedSet<E>"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super E>" line="1158"/>
                <method name="subSet" type="SortedSet<E>" line="1160">
                    <params>
                        <param name="fromElement" type="E"/>
                        <param name="toElement" type="E"/>
                    </params>
                </method>
                <method name="headSet" type="SortedSet<E>" line="1163">
                    <params>
                        <param name="toElement" type="E"/>
                    </params>
                </method>
                <method name="tailSet" type="SortedSet<E>" line="1166">
                    <params>
                        <param name="fromElement" type="E"/>
                    </params>
                </method>
                <method name="first" type="E" line="1170"/>
                <method name="last" type="E" line="1171"/>
            </class>
            <javadoc line="1174">
                Returns an unmodifiable view of the specified list.  This method allows
                  modules to provide users with &quot;read-only&quot; access to internal
                  lists.  Query operations on the returned list &quot;read through&quot; to the
                  specified list, and attempts to modify the returned list, whether
                  direct or via its iterator, result in an
                  &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
                  The returned list will be serializable if the specified list
                  is serializable. Similarly, the returned list will implement{@link RandomAccess} if the specified list does.                
                <param>
                    list the list for which an unmodifiable view is to be returned.                    
                </param>
                <return>
                    an unmodifiable view of the specified list.                    
                </return>
            </javadoc>
            <method name="unmodifiableList" type="List<T>" line="1189">
                <params>
                    <param name="list" type="List<? extends T>"/>
                </params>
            </method>
            <class name="UnmodifiableList" line="1195">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="UnmodifiableCollection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="List">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <javadoc line="1195">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1200"/>
                <declaration name="list" type="List&lt;? extends E&gt;" line="1201"/>
                <method name="UnmodifiableList" type="constructor" line="1203">
                    <params>
                        <param name="list" type="List<? extends E>"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="1208">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="1209"/>
                <method name="get" type="E" line="1211">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="set" type="E" line="1212">
                    <params>
                        <param name="index" type="int"/>
                        <param name="element" type="E"/>
                    </params>
                </method>
                <method name="add" type="void" line="1215">
                    <params>
                        <param name="index" type="int"/>
                        <param name="element" type="E"/>
                    </params>
                </method>
                <method name="remove" type="E" line="1218">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="indexOf" type="int" line="1221">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="lastIndexOf" type="int" line="1222">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="addAll" type="boolean" line="1223">
                    <params>
                        <param name="index" type="int"/>
                        <param name="c" type="Collection<? extends E>"/>
                    </params>
                </method>
                <method name="listIterator" type="ListIterator<E>" line="1226"/>
                <method name="listIterator" type="ListIterator<E>" line="1228">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                    <anonymous_class line="1229">
                        <declaration name="i" type="ListIterator&lt;? extends E&gt;" line="1230"/>
                        <method name="hasNext" type="boolean" line="1233"/>
                        <method name="next" type="E" line="1234"/>
                        <method name="hasPrevious" type="boolean" line="1235"/>
                        <method name="previous" type="E" line="1236"/>
                        <method name="nextIndex" type="int" line="1237"/>
                        <method name="previousIndex" type="int" line="1238"/>
                        <method name="remove" type="void" line="1240"/>
                        <method name="set" type="void" line="1243">
                            <params>
                                <param name="e" type="E"/>
                            </params>
                        </method>
                        <method name="add" type="void" line="1246">
                            <params>
                                <param name="e" type="E"/>
                            </params>
                        </method>
                    </anonymous_class>
                </method>
                <method name="subList" type="List<E>" line="1252">
                    <params>
                        <param name="fromIndex" type="int"/>
                        <param name="toIndex" type="int"/>
                    </params>
                </method>
                <javadoc line="1256">
                    UnmodifiableRandomAccessList instances are serialized as
                      UnmodifiableList instances to allow them to be deserialized
                      in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList).
                      This method inverts the transformation.  As a beneficial
                      side-effect, it also grafts the RandomAccess marker onto
                      UnmodifiableList instances that were serialized in pre-1.4 JREs.
                      Note: Unfortunately, UnmodifiableRandomAccessList instances
                      serialized in 1.4.1 and deserialized in 1.4 will become
                      UnmodifiableList instances, as this method was missing in 1.4.                    
                </javadoc>
                <method name="readResolve" type="Object" line="1268"/>
            </class>
            <class name="UnmodifiableRandomAccessList" line="1275">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="UnmodifiableList">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="RandomAccess"/>
                <javadoc line="1275">
                    @serial include                    
                </javadoc>
                <method name="UnmodifiableRandomAccessList" type="constructor" line="1281">
                    <params>
                        <param name="list" type="List<? extends E>"/>
                    </params>
                </method>
                <method name="subList" type="List<E>" line="1285">
                    <params>
                        <param name="fromIndex" type="int"/>
                        <param name="toIndex" type="int"/>
                    </params>
                </method>
                <declaration name="serialVersionUID" type="long" line="1290"/>
                <javadoc line="1292">
                    Allows instances to be deserialized in pre-1.4 JREs (which do
                      not have UnmodifiableRandomAccessList).  UnmodifiableList has
                      a readResolve method that inverts this transformation upon
                      deserialization.                    
                </javadoc>
                <method name="writeReplace" type="Object" line="1298"/>
            </class>
            <javadoc line="1303">
                Returns an unmodifiable view of the specified map.  This method
                  allows modules to provide users with &quot;read-only&quot; access to internal
                  maps.  Query operations on the returned map &quot;read through&quot;
                  to the specified map, and attempts to modify the returned
                  map, whether direct or via its collection views, result in an
                  &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
                  The returned map will be serializable if the specified map
                  is serializable.                
                <param>
                    m the map for which an unmodifiable view is to be returned.                    
                </param>
                <return>
                    an unmodifiable view of the specified map.                    
                </return>
            </javadoc>
            <method name="unmodifiableMap" type="Map<K,V>" line="1317">
                <params>
                    <param name="m" type="Map<? extends K,? extends V>"/>
                </params>
            </method>
            <class name="UnmodifiableMap" line="1321">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Map">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="1321">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1325"/>
                <declaration name="m" type="Map&lt;? extends K,? extends V&gt;" line="1327"/>
                <method name="UnmodifiableMap" type="constructor" line="1329">
                    <params>
                        <param name="m" type="Map<? extends K,? extends V>"/>
                    </params>
                </method>
                <method name="size" type="int" line="1335"/>
                <method name="isEmpty" type="boolean" line="1336"/>
                <method name="containsKey" type="boolean" line="1337">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="containsValue" type="boolean" line="1338">
                    <params>
                        <param name="val" type="Object"/>
                    </params>
                </method>
                <method name="get" type="V" line="1339">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="put" type="V" line="1341">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                    </params>
                </method>
                <method name="remove" type="V" line="1344">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="putAll" type="void" line="1347">
                    <params>
                        <param name="m" type="Map<? extends K,? extends V>"/>
                    </params>
                </method>
                <method name="clear" type="void" line="1350"/>
                <declaration name="keySet" type="Set&lt;K&gt;" line="1354"/>
                <declaration name="entrySet" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="1355"/>
                <declaration name="values" type="Collection&lt;V&gt;" line="1356"/>
                <method name="keySet" type="Set<K>" line="1358"/>
                <method name="entrySet" type="Set<Map.Entry<K,V>>" line="1364"/>
                <method name="values" type="Collection<V>" line="1370"/>
                <method name="equals" type="boolean" line="1376">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="1377"/>
                <method name="toString" type="String" line="1378"/>
                <class name="UnmodifiableEntrySet" line="1380">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                    <extends class="UnmodifiableSet">
                        <type_params>
                            <type_param name="Map.Entry<K,V>"/>
                        </type_params>
                    </extends>
                    <javadoc line="1380">
                        We need this class in addition to UnmodifiableSet as
                          Map.Entries themselves permit modification of the backing Map
                          via their setValue operation.  This class is subtle: there are
                          many possible attacks that must be thwarted.                        
                        <serial>
                            include                            
                        </serial>
                    </javadoc>
                    <declaration name="serialVersionUID" type="long" line="1390"/>
                    <method name="UnmodifiableEntrySet" type="constructor" line="1392">
                        <params>
                            <param name="s" type="Set<? extends Map.Entry<? extends K,? extends V>>"/>
                        </params>
                    </method>
                    <method name="iterator" type="Iterator<Map.Entry<K,V>>" line="1395">
                        <anonymous_class line="1396">
                            <declaration name="i" type="Iterator&lt;? extends Map.Entry&lt;? extends K,? extends V&gt;&gt;" line="1397"/>
                            <method name="hasNext" type="boolean" line="1399"/>
                            <method name="next" type="Map.Entry<K,V>" line="1402"/>
                            <method name="remove" type="void" line="1405"/>
                        </anonymous_class>
                    </method>
                    <method name="toArray" type="Object[]" line="1411">
                        <declaration name="a" type="Object[]" line="1412"/>
                    </method>
                    <method name="toArray" type="T[]" line="1418">
                        <params>
                            <param name="a" type="T[]"/>
                        </params>
                        <comment line="1419">
                            We don&apos;t pass a to c.toArray, to avoid window of                            
                        </comment>
                        <comment line="1420">
                            vulnerability wherein an unscrupulous multithreaded client                            
                        </comment>
                        <comment line="1421">
                            could get his hands on raw (unwrapped) Entries from c.                            
                        </comment>
                        <declaration name="arr" type="Object[]" line="1422"/>
                    </method>
                    <javadoc line="1436">
                        This method is overridden to protect the backing set against
                          an object with a nefarious equals function that senses
                          that the equality-candidate is Map.Entry and calls its
                          setValue method.                        
                    </javadoc>
                    <method name="contains" type="boolean" line="1442">
                        <params>
                            <param name="o" type="Object"/>
                        </params>
                    </method>
                    <javadoc line="1449">
                        The next two methods are overridden to protect against
                          an unscrupulous List whose contains(Object o) method senses
                          when o is a Map.Entry, and calls o.setValue.                        
                    </javadoc>
                    <method name="containsAll" type="boolean" line="1454">
                        <params>
                            <param name="coll" type="Collection<?>"/>
                        </params>
                        <comment line="1456">
                            Invokes safe contains() above                            
                        </comment>
                        <scope line="1455"/>
                    </method>
                    <method name="equals" type="boolean" line="1461">
                        <params>
                            <param name="o" type="Object"/>
                        </params>
                        <comment line="1470">
                            Invokes safe containsAll() above                            
                        </comment>
                        <declaration name="s" type="Set" line="1467"/>
                    </method>
                    <class name="UnmodifiableEntry" line="1473">
                        <type_params>
                            <type_param name="K"/>
                            <type_param name="V"/>
                        </type_params>
                        <implements interface="Map.Entry">
                            <type_params>
                                <type_param name="K"/>
                                <type_param name="V"/>
                            </type_params>
                        </implements>
                        <javadoc line="1473">
                            This &quot;wrapper class&quot; serves two purposes: it prevents
                              the client from modifying the backing Map, by short-circuiting
                              the setValue method, and it protects the backing Map against
                              an ill-behaved Map.Entry that attempts to modify another
                              Map Entry when asked to perform an equality check.                            
                        </javadoc>
                        <declaration name="e" type="Map.Entry&lt;? extends K,? extends V&gt;" line="1481"/>
                        <method name="UnmodifiableEntry" type="constructor" line="1483">
                            <params>
                                <param name="e" type="Map.Entry<? extends K,? extends V>"/>
                            </params>
                        </method>
                        <method name="getKey" type="K" line="1485"/>
                        <method name="getValue" type="V" line="1486"/>
                        <method name="setValue" type="V" line="1487">
                            <params>
                                <param name="value" type="V"/>
                            </params>
                        </method>
                        <method name="hashCode" type="int" line="1490"/>
                        <method name="equals" type="boolean" line="1491">
                            <params>
                                <param name="o" type="Object"/>
                            </params>
                            <declaration name="t" type="Map.Entry" line="1494"/>
                        </method>
                        <method name="toString" type="String" line="1498"/>
                    </class>
                </class>
            </class>
            <javadoc line="1503">
                Returns an unmodifiable view of the specified sorted map.  This method
                  allows modules to provide users with &quot;read-only&quot; access to internal
                  sorted maps.  Query operations on the returned sorted map &quot;read through&quot;
                  to the specified sorted map.  Attempts to modify the returned
                  sorted map, whether direct, via its collection views, or via its
                  &lt;tt&gt;subMap&lt;/tt&gt;, &lt;tt&gt;headMap&lt;/tt&gt;, or &lt;tt&gt;tailMap&lt;/tt&gt; views, result in
                  an &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;
                  The returned sorted map will be serializable if the specified sorted map
                  is serializable.                
                <param>
                    m the sorted map for which an unmodifiable view is to be
                      returned.                    
                </param>
                <return>
                    an unmodifiable view of the specified sorted map.                    
                </return>
            </javadoc>
            <method name="unmodifiableSortedMap" type="SortedMap<K,V>" line="1519">
                <params>
                    <param name="m" type="SortedMap<K,? extends V>"/>
                </params>
            </method>
            <class name="UnmodifiableSortedMap" line="1523">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="UnmodifiableMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="SortedMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="1523">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1529"/>
                <declaration name="sm" type="SortedMap&lt;K,? extends V&gt;" line="1531"/>
                <method name="UnmodifiableSortedMap" type="constructor" line="1533">
                    <params>
                        <param name="m" type="SortedMap<K,? extends V>"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super K>" line="1535"/>
                <method name="subMap" type="SortedMap<K,V>" line="1537">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="headMap" type="SortedMap<K,V>" line="1540">
                    <params>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="tailMap" type="SortedMap<K,V>" line="1543">
                    <params>
                        <param name="fromKey" type="K"/>
                    </params>
                </method>
                <method name="firstKey" type="K" line="1547"/>
                <method name="lastKey" type="K" line="1548"/>
            </class>
            <javadoc line="1554">
                Returns a synchronized (thread-safe) collection backed by the specified
                  collection.  In order to guarantee serial access, it is critical that
                  &lt;strong&gt;all&lt;/strong&gt; access to the backing collection is accomplished
                  through the returned collection.&lt;p&gt;
                  It is imperative that the user manually synchronize on the returned
                  collection when iterating over it:
                  &lt;pre&gt;
                  Collection c = Collections.synchronizedCollection(myCollection);
                  ...
                  synchronized (c) {
                  Iterator i = c.iterator(); // Must be in the synchronized block
                  while (i.hasNext())
                  foo(i.next());
                  }
                  &lt;/pre&gt;
                  Failure to follow this advice may result in non-deterministic behavior.
                  &lt;p&gt;The returned collection does &lt;i&gt;not&lt;/i&gt; pass the &lt;tt&gt;hashCode&lt;/tt&gt;
                  and &lt;tt&gt;equals&lt;/tt&gt; operations through to the backing collection, but
                  relies on &lt;tt&gt;Object&lt;/tt&gt;&apos;s equals and hashCode methods.  This is
                  necessary to preserve the contracts of these operations in the case
                  that the backing collection is a set or a list.&lt;p&gt;
                  The returned collection will be serializable if the specified collection
                  is serializable.                
                <param>
                    c the collection to be "wrapped" in a synchronized collection.                    
                </param>
                <return>
                    a synchronized view of the specified collection.                    
                </return>
            </javadoc>
            <method name="synchronizedCollection" type="Collection<T>" line="1585">
                <params>
                    <param name="c" type="Collection<T>"/>
                </params>
            </method>
            <method name="synchronizedCollection" type="Collection<T>" line="1589">
                <params>
                    <param name="c" type="Collection<T>"/>
                    <param name="mutex" type="Object"/>
                </params>
            </method>
            <class name="SynchronizedCollection" line="1593">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Collection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="1593">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1597"/>
                <declaration name="c" type="Collection&lt;E&gt;" line="1599"/>
                <declaration name="mutex" type="Object" line="1600"/>
                <method name="SynchronizedCollection" type="constructor" line="1602">
                    <params>
                        <param name="c" type="Collection<E>"/>
                    </params>
                </method>
                <method name="SynchronizedCollection" type="constructor" line="1608">
                    <params>
                        <param name="c" type="Collection<E>"/>
                        <param name="mutex" type="Object"/>
                    </params>
                </method>
                <method name="size" type="int" line="1613">
                    <scope line="1614"/>
                </method>
                <method name="isEmpty" type="boolean" line="1616">
                    <scope line="1617"/>
                </method>
                <method name="contains" type="boolean" line="1619">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="1620"/>
                </method>
                <method name="toArray" type="Object[]" line="1622">
                    <scope line="1623"/>
                </method>
                <method name="toArray" type="T[]" line="1625">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                    <scope line="1626"/>
                </method>
                <method name="iterator" type="Iterator<E>" line="1629">
                    <comment line="1630">
                        Must be manually synched by user!                        
                    </comment>
                </method>
                <method name="add" type="boolean" line="1633">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                    <scope line="1634"/>
                </method>
                <method name="remove" type="boolean" line="1636">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="1637"/>
                </method>
                <method name="containsAll" type="boolean" line="1640">
                    <params>
                        <param name="coll" type="Collection<?>"/>
                    </params>
                    <scope line="1641"/>
                </method>
                <method name="addAll" type="boolean" line="1643">
                    <params>
                        <param name="coll" type="Collection<? extends E>"/>
                    </params>
                    <scope line="1644"/>
                </method>
                <method name="removeAll" type="boolean" line="1646">
                    <params>
                        <param name="coll" type="Collection<?>"/>
                    </params>
                    <scope line="1647"/>
                </method>
                <method name="retainAll" type="boolean" line="1649">
                    <params>
                        <param name="coll" type="Collection<?>"/>
                    </params>
                    <scope line="1650"/>
                </method>
                <method name="clear" type="void" line="1652">
                    <scope line="1653"/>
                </method>
                <method name="toString" type="String" line="1655">
                    <scope line="1656"/>
                </method>
                <method name="writeObject" type="void" line="1658">
                    <params>
                        <param name="s" type="ObjectOutputStream"/>
                    </params>
                    <scope line="1659"/>
                </method>
            </class>
            <javadoc line="1663">
                Returns a synchronized (thread-safe) set backed by the specified
                  set.  In order to guarantee serial access, it is critical that
                  &lt;strong&gt;all&lt;/strong&gt; access to the backing set is accomplished
                  through the returned set.&lt;p&gt;
                  It is imperative that the user manually synchronize on the returned
                  set when iterating over it:
                  &lt;pre&gt;
                  Set s = Collections.synchronizedSet(new HashSet());
                  ...
                  synchronized (s) {
                  Iterator i = s.iterator(); // Must be in the synchronized block
                  while (i.hasNext())
                  foo(i.next());
                  }
                  &lt;/pre&gt;
                  Failure to follow this advice may result in non-deterministic behavior.
                  &lt;p&gt;The returned set will be serializable if the specified set is
                  serializable.                
                <param>
                    s the set to be "wrapped" in a synchronized set.                    
                </param>
                <return>
                    a synchronized view of the specified set.                    
                </return>
            </javadoc>
            <method name="synchronizedSet" type="Set<T>" line="1688">
                <params>
                    <param name="s" type="Set<T>"/>
                </params>
            </method>
            <method name="synchronizedSet" type="Set<T>" line="1692">
                <params>
                    <param name="s" type="Set<T>"/>
                    <param name="mutex" type="Object"/>
                </params>
            </method>
            <class name="SynchronizedSet" line="1696">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="SynchronizedCollection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Set">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <javadoc line="1696">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1702"/>
                <method name="SynchronizedSet" type="constructor" line="1704">
                    <params>
                        <param name="s" type="Set<E>"/>
                    </params>
                </method>
                <method name="SynchronizedSet" type="constructor" line="1707">
                    <params>
                        <param name="s" type="Set<E>"/>
                        <param name="mutex" type="Object"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="1711">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="1712"/>
                </method>
                <method name="hashCode" type="int" line="1714">
                    <scope line="1715"/>
                </method>
            </class>
            <javadoc line="1719">
                Returns a synchronized (thread-safe) sorted set backed by the specified
                  sorted set.  In order to guarantee serial access, it is critical that
                  &lt;strong&gt;all&lt;/strong&gt; access to the backing sorted set is accomplished
                  through the returned sorted set (or its views).&lt;p&gt;
                  It is imperative that the user manually synchronize on the returned
                  sorted set when iterating over it or any of its &lt;tt&gt;subSet&lt;/tt&gt;,
                  &lt;tt&gt;headSet&lt;/tt&gt;, or &lt;tt&gt;tailSet&lt;/tt&gt; views.
                  &lt;pre&gt;
                  SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
                  ...
                  synchronized (s) {
                  Iterator i = s.iterator(); // Must be in the synchronized block
                  while (i.hasNext())
                  foo(i.next());
                  }
                  &lt;/pre&gt;
                  or:
                  &lt;pre&gt;
                  SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
                  SortedSet s2 = s.headSet(foo);
                  ...
                  synchronized (s) {  // Note: s, not s2!!!
                  Iterator i = s2.iterator(); // Must be in the synchronized block
                  while (i.hasNext())
                  foo(i.next());
                  }
                  &lt;/pre&gt;
                  Failure to follow this advice may result in non-deterministic behavior.
                  &lt;p&gt;The returned sorted set will be serializable if the specified
                  sorted set is serializable.                
                <param>
                    s the sorted set to be "wrapped" in a synchronized sorted set.                    
                </param>
                <return>
                    a synchronized view of the specified sorted set.                    
                </return>
            </javadoc>
            <method name="synchronizedSortedSet" type="SortedSet<T>" line="1756">
                <params>
                    <param name="s" type="SortedSet<T>"/>
                </params>
            </method>
            <class name="SynchronizedSortedSet" line="1760">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="SynchronizedSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="SortedSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <javadoc line="1760">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1767"/>
                <declaration name="ss" type="SortedSet&lt;E&gt;" line="1769"/>
                <method name="SynchronizedSortedSet" type="constructor" line="1771">
                    <params>
                        <param name="s" type="SortedSet<E>"/>
                    </params>
                </method>
                <method name="SynchronizedSortedSet" type="constructor" line="1775">
                    <params>
                        <param name="s" type="SortedSet<E>"/>
                        <param name="mutex" type="Object"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super E>" line="1780">
                    <scope line="1781"/>
                </method>
                <method name="subSet" type="SortedSet<E>" line="1784">
                    <params>
                        <param name="fromElement" type="E"/>
                        <param name="toElement" type="E"/>
                    </params>
                    <scope line="1785"/>
                </method>
                <method name="headSet" type="SortedSet<E>" line="1790">
                    <params>
                        <param name="toElement" type="E"/>
                    </params>
                    <scope line="1791"/>
                </method>
                <method name="tailSet" type="SortedSet<E>" line="1795">
                    <params>
                        <param name="fromElement" type="E"/>
                    </params>
                    <scope line="1796"/>
                </method>
                <method name="first" type="E" line="1801">
                    <scope line="1802"/>
                </method>
                <method name="last" type="E" line="1804">
                    <scope line="1805"/>
                </method>
            </class>
            <javadoc line="1809">
                Returns a synchronized (thread-safe) list backed by the specified
                  list.  In order to guarantee serial access, it is critical that
                  &lt;strong&gt;all&lt;/strong&gt; access to the backing list is accomplished
                  through the returned list.&lt;p&gt;
                  It is imperative that the user manually synchronize on the returned
                  list when iterating over it:
                  &lt;pre&gt;
                  List list = Collections.synchronizedList(new ArrayList());
                  ...
                  synchronized (list) {
                  Iterator i = list.iterator(); // Must be in synchronized block
                  while (i.hasNext())
                  foo(i.next());
                  }
                  &lt;/pre&gt;
                  Failure to follow this advice may result in non-deterministic behavior.
                  &lt;p&gt;The returned list will be serializable if the specified list is
                  serializable.                
                <param>
                    list the list to be "wrapped" in a synchronized list.                    
                </param>
                <return>
                    a synchronized view of the specified list.                    
                </return>
            </javadoc>
            <method name="synchronizedList" type="List<T>" line="1834">
                <params>
                    <param name="list" type="List<T>"/>
                </params>
            </method>
            <method name="synchronizedList" type="List<T>" line="1840">
                <params>
                    <param name="list" type="List<T>"/>
                    <param name="mutex" type="Object"/>
                </params>
            </method>
            <class name="SynchronizedList" line="1846">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="SynchronizedCollection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="List">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <javadoc line="1846">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1852"/>
                <declaration name="list" type="List&lt;E&gt;" line="1854"/>
                <method name="SynchronizedList" type="constructor" line="1856">
                    <params>
                        <param name="list" type="List<E>"/>
                    </params>
                </method>
                <method name="SynchronizedList" type="constructor" line="1860">
                    <params>
                        <param name="list" type="List<E>"/>
                        <param name="mutex" type="Object"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="1865">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="1866"/>
                </method>
                <method name="hashCode" type="int" line="1868">
                    <scope line="1869"/>
                </method>
                <method name="get" type="E" line="1872">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                    <scope line="1873"/>
                </method>
                <method name="set" type="E" line="1875">
                    <params>
                        <param name="index" type="int"/>
                        <param name="element" type="E"/>
                    </params>
                    <scope line="1876"/>
                </method>
                <method name="add" type="void" line="1878">
                    <params>
                        <param name="index" type="int"/>
                        <param name="element" type="E"/>
                    </params>
                    <scope line="1879"/>
                </method>
                <method name="remove" type="E" line="1881">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                    <scope line="1882"/>
                </method>
                <method name="indexOf" type="int" line="1885">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="1886"/>
                </method>
                <method name="lastIndexOf" type="int" line="1888">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="1889"/>
                </method>
                <method name="addAll" type="boolean" line="1892">
                    <params>
                        <param name="index" type="int"/>
                        <param name="c" type="Collection<? extends E>"/>
                    </params>
                    <scope line="1893"/>
                </method>
                <method name="listIterator" type="ListIterator<E>" line="1896">
                    <comment line="1897">
                        Must be manually synched by user                        
                    </comment>
                </method>
                <method name="listIterator" type="ListIterator<E>" line="1900">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                    <comment line="1901">
                        Must be manually synched by user                        
                    </comment>
                </method>
                <method name="subList" type="List<E>" line="1904">
                    <params>
                        <param name="fromIndex" type="int"/>
                        <param name="toIndex" type="int"/>
                    </params>
                    <scope line="1905"/>
                </method>
                <javadoc line="1911">
                    SynchronizedRandomAccessList instances are serialized as
                      SynchronizedList instances to allow them to be deserialized
                      in pre-1.4 JREs (which do not have SynchronizedRandomAccessList).
                      This method inverts the transformation.  As a beneficial
                      side-effect, it also grafts the RandomAccess marker onto
                      SynchronizedList instances that were serialized in pre-1.4 JREs.
                      Note: Unfortunately, SynchronizedRandomAccessList instances
                      serialized in 1.4.1 and deserialized in 1.4 will become
                      SynchronizedList instances, as this method was missing in 1.4.                    
                </javadoc>
                <method name="readResolve" type="Object" line="1923"/>
            </class>
            <class name="SynchronizedRandomAccessList" line="1930">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="SynchronizedList">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="RandomAccess"/>
                <javadoc line="1930">
                    @serial include                    
                </javadoc>
                <method name="SynchronizedRandomAccessList" type="constructor" line="1937">
                    <params>
                        <param name="list" type="List<E>"/>
                    </params>
                </method>
                <method name="SynchronizedRandomAccessList" type="constructor" line="1941">
                    <params>
                        <param name="list" type="List<E>"/>
                        <param name="mutex" type="Object"/>
                    </params>
                </method>
                <method name="subList" type="List<E>" line="1945">
                    <params>
                        <param name="fromIndex" type="int"/>
                        <param name="toIndex" type="int"/>
                    </params>
                    <scope line="1946"/>
                </method>
                <declaration name="serialVersionUID" type="long" line="1952"/>
                <javadoc line="1954">
                    Allows instances to be deserialized in pre-1.4 JREs (which do
                      not have SynchronizedRandomAccessList).  SynchronizedList has
                      a readResolve method that inverts this transformation upon
                      deserialization.                    
                </javadoc>
                <method name="writeReplace" type="Object" line="1960"/>
            </class>
            <javadoc line="1965">
                Returns a synchronized (thread-safe) map backed by the specified
                  map.  In order to guarantee serial access, it is critical that
                  &lt;strong&gt;all&lt;/strong&gt; access to the backing map is accomplished
                  through the returned map.&lt;p&gt;
                  It is imperative that the user manually synchronize on the returned
                  map when iterating over any of its collection views:
                  &lt;pre&gt;
                  Map m = Collections.synchronizedMap(new HashMap());
                  ...
                  Set s = m.keySet();  // Needn&apos;t be in synchronized block
                  ...
                  synchronized (m) {  // Synchronizing on m, not s!
                  Iterator i = s.iterator(); // Must be in synchronized block
                  while (i.hasNext())
                  foo(i.next());
                  }
                  &lt;/pre&gt;
                  Failure to follow this advice may result in non-deterministic behavior.
                  &lt;p&gt;The returned map will be serializable if the specified map is
                  serializable.                
                <param>
                    m the map to be "wrapped" in a synchronized map.                    
                </param>
                <return>
                    a synchronized view of the specified map.                    
                </return>
            </javadoc>
            <method name="synchronizedMap" type="Map<K,V>" line="1992">
                <params>
                    <param name="m" type="Map<K,V>"/>
                </params>
            </method>
            <class name="SynchronizedMap" line="1996">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Map">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="1996">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2001"/>
                <declaration name="m" type="Map&lt;K,V&gt;" line="2003"/>
                <declaration name="mutex" type="Object" line="2004"/>
                <method name="SynchronizedMap" type="constructor" line="2006">
                    <params>
                        <param name="m" type="Map<K,V>"/>
                    </params>
                </method>
                <method name="SynchronizedMap" type="constructor" line="2013">
                    <params>
                        <param name="m" type="Map<K,V>"/>
                        <param name="mutex" type="Object"/>
                    </params>
                </method>
                <method name="size" type="int" line="2018">
                    <scope line="2019"/>
                </method>
                <method name="isEmpty" type="boolean" line="2021">
                    <scope line="2022"/>
                </method>
                <method name="containsKey" type="boolean" line="2024">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                    <scope line="2025"/>
                </method>
                <method name="containsValue" type="boolean" line="2027">
                    <params>
                        <param name="value" type="Object"/>
                    </params>
                    <scope line="2028"/>
                </method>
                <method name="get" type="V" line="2030">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                    <scope line="2031"/>
                </method>
                <method name="put" type="V" line="2034">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                    </params>
                    <scope line="2035"/>
                </method>
                <method name="remove" type="V" line="2037">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                    <scope line="2038"/>
                </method>
                <method name="putAll" type="void" line="2040">
                    <params>
                        <param name="map" type="Map<? extends K,? extends V>"/>
                    </params>
                    <scope line="2041"/>
                </method>
                <method name="clear" type="void" line="2043">
                    <scope line="2044"/>
                </method>
                <declaration name="keySet" type="Set&lt;K&gt;" line="2047"/>
                <declaration name="entrySet" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="2048"/>
                <declaration name="values" type="Collection&lt;V&gt;" line="2049"/>
                <method name="keySet" type="Set<K>" line="2051">
                    <scope line="2052"/>
                </method>
                <method name="entrySet" type="Set<Map.Entry<K,V>>" line="2059">
                    <scope line="2060"/>
                </method>
                <method name="values" type="Collection<V>" line="2067">
                    <scope line="2068"/>
                </method>
                <method name="equals" type="boolean" line="2075">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <scope line="2076"/>
                </method>
                <method name="hashCode" type="int" line="2078">
                    <scope line="2079"/>
                </method>
                <method name="toString" type="String" line="2081">
                    <scope line="2082"/>
                </method>
                <method name="writeObject" type="void" line="2084">
                    <params>
                        <param name="s" type="ObjectOutputStream"/>
                    </params>
                    <scope line="2085"/>
                </method>
            </class>
            <javadoc line="2089">
                Returns a synchronized (thread-safe) sorted map backed by the specified
                  sorted map.  In order to guarantee serial access, it is critical that
                  &lt;strong&gt;all&lt;/strong&gt; access to the backing sorted map is accomplished
                  through the returned sorted map (or its views).&lt;p&gt;
                  It is imperative that the user manually synchronize on the returned
                  sorted map when iterating over any of its collection views, or the
                  collections views of any of its &lt;tt&gt;subMap&lt;/tt&gt;, &lt;tt&gt;headMap&lt;/tt&gt; or
                  &lt;tt&gt;tailMap&lt;/tt&gt; views.
                  &lt;pre&gt;
                  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
                  ...
                  Set s = m.keySet();  // Needn&apos;t be in synchronized block
                  ...
                  synchronized (m) {  // Synchronizing on m, not s!
                  Iterator i = s.iterator(); // Must be in synchronized block
                  while (i.hasNext())
                  foo(i.next());
                  }
                  &lt;/pre&gt;
                  or:
                  &lt;pre&gt;
                  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
                  SortedMap m2 = m.subMap(foo, bar);
                  ...
                  Set s2 = m2.keySet();  // Needn&apos;t be in synchronized block
                  ...
                  synchronized (m) {  // Synchronizing on m, not m2 or s2!
                  Iterator i = s.iterator(); // Must be in synchronized block
                  while (i.hasNext())
                  foo(i.next());
                  }
                  &lt;/pre&gt;
                  Failure to follow this advice may result in non-deterministic behavior.
                  &lt;p&gt;The returned sorted map will be serializable if the specified
                  sorted map is serializable.                
                <param>
                    m the sorted map to be "wrapped" in a synchronized sorted map.                    
                </param>
                <return>
                    a synchronized view of the specified sorted map.                    
                </return>
            </javadoc>
            <method name="synchronizedSortedMap" type="SortedMap<K,V>" line="2131">
                <params>
                    <param name="m" type="SortedMap<K,V>"/>
                </params>
            </method>
            <class name="SynchronizedSortedMap" line="2136">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="SynchronizedMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="SortedMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <javadoc line="2136">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2143"/>
                <declaration name="sm" type="SortedMap&lt;K,V&gt;" line="2145"/>
                <method name="SynchronizedSortedMap" type="constructor" line="2147">
                    <params>
                        <param name="m" type="SortedMap<K,V>"/>
                    </params>
                </method>
                <method name="SynchronizedSortedMap" type="constructor" line="2151">
                    <params>
                        <param name="m" type="SortedMap<K,V>"/>
                        <param name="mutex" type="Object"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super K>" line="2156">
                    <scope line="2157"/>
                </method>
                <method name="subMap" type="SortedMap<K,V>" line="2160">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="toKey" type="K"/>
                    </params>
                    <scope line="2161"/>
                </method>
                <method name="headMap" type="SortedMap<K,V>" line="2166">
                    <params>
                        <param name="toKey" type="K"/>
                    </params>
                    <scope line="2167"/>
                </method>
                <method name="tailMap" type="SortedMap<K,V>" line="2171">
                    <params>
                        <param name="fromKey" type="K"/>
                    </params>
                    <scope line="2172"/>
                </method>
                <method name="firstKey" type="K" line="2177">
                    <scope line="2178"/>
                </method>
                <method name="lastKey" type="K" line="2180">
                    <scope line="2181"/>
                </method>
            </class>
            <javadoc line="2187">
                Returns a dynamically typesafe view of the specified collection.
                  Any attempt to insert an element of the wrong type will result in an
                  immediate {@link ClassCastException}.  Assuming a collection
                  contains no incorrectly typed elements prior to the time a
                  dynamically typesafe view is generated, and that all subsequent
                  access to the collection takes place through the view, it is
                  &lt;i&gt;guaranteed&lt;/i&gt; that the collection cannot contain an incorrectly
                  typed element.
                  &lt;p&gt;The generics mechanism in the language provides compile-time
                  (static) type checking, but it is possible to defeat this mechanism
                  with unchecked casts.  Usually this is not a problem, as the compiler
                  issues warnings on all such unchecked operations.  There are, however,
                  times when static type checking alone is not sufficient.  For example,
                  suppose a collection is passed to a third-party library and it is
                  imperative that the library code not corrupt the collection by
                  inserting an element of the wrong type.
                  &lt;p&gt;Another use of dynamically typesafe views is debugging.  Suppose a
                  program fails with a {@code ClassCastException}, indicating that an
                  incorrectly typed element was put into a parameterized collection.
                  Unfortunately, the exception can occur at any time after the erroneous
                  element is inserted, so it typically provides little or no information
                  as to the real source of the problem.  If the problem is reproducible,
                  one can quickly determine its source by temporarily modifying the
                  program to wrap the collection with a dynamically typesafe view.
                  For example, this declaration:
                  &lt;pre&gt; {@codeCollection&lt;String&gt; c = new HashSet&lt;String&gt;();}&lt;/pre&gt;
                  may be replaced temporarily by this one:
                  &lt;pre&gt; {@codeCollection&lt;String&gt; c = Collections.checkedCollection(
                  new HashSet&lt;String&gt;(), String.class);}&lt;/pre&gt;
                  Running the program again will cause it to fail at the point where
                  an incorrectly typed element is inserted into the collection, clearly
                  identifying the source of the problem.  Once the problem is fixed, the
                  modified declaration may be reverted back to the original.
                  &lt;p&gt;The returned collection does &lt;i&gt;not&lt;/i&gt; pass the hashCode and equals
                  operations through to the backing collection, but relies on{@code Object}&apos;s {@code equals} and {@code hashCode} methods.  This
                  is necessary to preserve the contracts of these operations in the case
                  that the backing collection is a set or a list.
                  &lt;p&gt;The returned collection will be serializable if the specified
                  collection is serializable.
                  &lt;p&gt;Since {@code null} is considered to be a value of any reference
                  type, the returned collection permits insertion of null elements
                  whenever the backing collection does.                
                <param>
                    c the collection for which a dynamically typesafe view is to be
                      returned                    
                </param>
                <param>
                    type the type of element that {@code c} is permitted to hold                    
                </param>
                <return>
                    a dynamically typesafe view of the specified collection                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="checkedCollection" type="Collection<E>" line="2248">
                <params>
                    <param name="c" type="Collection<E>"/>
                    <param name="type" type="Class<E>"/>
                </params>
            </method>
            <method name="zeroLengthArray" type="T[]" line="2253">
                <params>
                    <param name="type" type="Class<T>"/>
                </params>
            </method>
            <class name="CheckedCollection" line="2257">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Collection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="2257">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2261"/>
                <declaration name="c" type="Collection&lt;E&gt;" line="2263"/>
                <declaration name="type" type="Class&lt;E&gt;" line="2264"/>
                <method name="typeCheck" type="void" line="2266">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="badElementMsg" type="String" line="2271">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="CheckedCollection" type="constructor" line="2276">
                    <params>
                        <param name="c" type="Collection<E>"/>
                        <param name="type" type="Class<E>"/>
                    </params>
                </method>
                <method name="size" type="int" line="2283"/>
                <method name="isEmpty" type="boolean" line="2284"/>
                <method name="contains" type="boolean" line="2285">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="toArray" type="Object[]" line="2286"/>
                <method name="toArray" type="T[]" line="2287">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
                <method name="toString" type="String" line="2288"/>
                <method name="remove" type="boolean" line="2289">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="2290"/>
                <method name="containsAll" type="boolean" line="2292">
                    <params>
                        <param name="coll" type="Collection<?>"/>
                    </params>
                </method>
                <method name="removeAll" type="boolean" line="2295">
                    <params>
                        <param name="coll" type="Collection<?>"/>
                    </params>
                </method>
                <method name="retainAll" type="boolean" line="2298">
                    <params>
                        <param name="coll" type="Collection<?>"/>
                    </params>
                </method>
                <method name="iterator" type="Iterator<E>" line="2302">
                    <declaration name="it" type="Iterator&lt;E&gt;" line="2303"/>
                    <anonymous_class line="2304">
                        <method name="hasNext" type="boolean" line="2305"/>
                        <method name="next" type="E" line="2306"/>
                        <method name="remove" type="void" line="2307"/>
                    </anonymous_class>
                </method>
                <method name="add" type="boolean" line="2310">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <declaration name="zeroLengthElementArray" type="E[]" line="2315"/>
                <method name="zeroLengthElementArray" type="E[]" line="2317"/>
                <method name="checkedCopyOf" type="Collection<E>" line="2323">
                    <params>
                        <param name="coll" type="Collection<? extends E>"/>
                    </params>
                    <comment line="2328">
                        Defend against coll violating the toArray contract                        
                    </comment>
                    <comment line="2332">
                        To get better and consistent diagnostics,                        
                    </comment>
                    <comment line="2333">
                        we call typeCheck explicitly on each element.                        
                    </comment>
                    <comment line="2334">
                        We call clone() to defend against coll retaining a                        
                    </comment>
                    <comment line="2335">
                        reference to the returned array and storing a bad                        
                    </comment>
                    <comment line="2336">
                        element into it after it has been type checked.                        
                    </comment>
                    <comment line="2341">
                        A slight abuse of the type system, but safe here.                        
                    </comment>
                    <declaration name="a" type="Object[]" line="2324"/>
                    <scope line="2325">
                        <declaration name="z" type="E[]" line="2326"/>
                    </scope>
                    <scope line="2331"/>
                </method>
                <method name="addAll" type="boolean" line="2345">
                    <params>
                        <param name="coll" type="Collection<? extends E>"/>
                    </params>
                    <comment line="2346">
                        Doing things this way insulates us from concurrent changes                        
                    </comment>
                    <comment line="2347">
                        in the contents of coll and provides all-or-nothing                        
                    </comment>
                    <comment line="2348">
                        semantics (which we wouldn&apos;t get if we type-checked each                        
                    </comment>
                    <comment line="2349">
                        element as we added it)                        
                    </comment>
                </method>
            </class>
            <javadoc line="2354">
                Returns a dynamically typesafe view of the specified set.
                  Any attempt to insert an element of the wrong type will result in
                  an immediate {@link ClassCastException}.  Assuming a set contains
                  no incorrectly typed elements prior to the time a dynamically typesafe
                  view is generated, and that all subsequent access to the set
                  takes place through the view, it is &lt;i&gt;guaranteed&lt;/i&gt; that the
                  set cannot contain an incorrectly typed element.
                  &lt;p&gt;A discussion of the use of dynamically typesafe views may be
                  found in the documentation for the {@link #checkedCollectioncheckedCollection} method.
                  &lt;p&gt;The returned set will be serializable if the specified set is
                  serializable.
                  &lt;p&gt;Since {@code null} is considered to be a value of any reference
                  type, the returned set permits insertion of null elements whenever
                  the backing set does.                
                <param>
                    s the set for which a dynamically typesafe view is to be
                      returned                    
                </param>
                <param>
                    type the type of element that {@code s} is permitted to hold                    
                </param>
                <return>
                    a dynamically typesafe view of the specified set                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="checkedSet" type="Set<E>" line="2380">
                <params>
                    <param name="s" type="Set<E>"/>
                    <param name="type" type="Class<E>"/>
                </params>
            </method>
            <class name="CheckedSet" line="2384">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="CheckedCollection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Set">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="2384">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2390"/>
                <method name="CheckedSet" type="constructor" line="2392">
                    <params>
                        <param name="s" type="Set<E>"/>
                        <param name="elementType" type="Class<E>"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="2394">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="2395"/>
            </class>
            <javadoc line="2398">
                Returns a dynamically typesafe view of the specified sorted set.
                  Any attempt to insert an element of the wrong type will result in an
                  immediate {@link ClassCastException}.  Assuming a sorted set
                  contains no incorrectly typed elements prior to the time a
                  dynamically typesafe view is generated, and that all subsequent
                  access to the sorted set takes place through the view, it is
                  &lt;i&gt;guaranteed&lt;/i&gt; that the sorted set cannot contain an incorrectly
                  typed element.
                  &lt;p&gt;A discussion of the use of dynamically typesafe views may be
                  found in the documentation for the {@link #checkedCollectioncheckedCollection} method.
                  &lt;p&gt;The returned sorted set will be serializable if the specified sorted
                  set is serializable.
                  &lt;p&gt;Since {@code null} is considered to be a value of any reference
                  type, the returned sorted set permits insertion of null elements
                  whenever the backing sorted set does.                
                <param>
                    s the sorted set for which a dynamically typesafe view is to be
                      returned                    
                </param>
                <param>
                    type the type of element that {@code s} is permitted to hold                    
                </param>
                <return>
                    a dynamically typesafe view of the specified sorted set                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="checkedSortedSet" type="SortedSet<E>" line="2426">
                <params>
                    <param name="s" type="SortedSet<E>"/>
                    <param name="type" type="Class<E>"/>
                </params>
            </method>
            <class name="CheckedSortedSet" line="2430">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="CheckedSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="SortedSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="2430">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2436"/>
                <declaration name="ss" type="SortedSet&lt;E&gt;" line="2437"/>
                <method name="CheckedSortedSet" type="constructor" line="2439">
                    <params>
                        <param name="s" type="SortedSet<E>"/>
                        <param name="type" type="Class<E>"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super E>" line="2444"/>
                <method name="first" type="E" line="2445"/>
                <method name="last" type="E" line="2446"/>
                <method name="subSet" type="SortedSet<E>" line="2448">
                    <params>
                        <param name="fromElement" type="E"/>
                        <param name="toElement" type="E"/>
                    </params>
                </method>
                <method name="headSet" type="SortedSet<E>" line="2451">
                    <params>
                        <param name="toElement" type="E"/>
                    </params>
                </method>
                <method name="tailSet" type="SortedSet<E>" line="2454">
                    <params>
                        <param name="fromElement" type="E"/>
                    </params>
                </method>
            </class>
            <javadoc line="2459">
                Returns a dynamically typesafe view of the specified list.
                  Any attempt to insert an element of the wrong type will result in
                  an immediate {@link ClassCastException}.  Assuming a list contains
                  no incorrectly typed elements prior to the time a dynamically typesafe
                  view is generated, and that all subsequent access to the list
                  takes place through the view, it is &lt;i&gt;guaranteed&lt;/i&gt; that the
                  list cannot contain an incorrectly typed element.
                  &lt;p&gt;A discussion of the use of dynamically typesafe views may be
                  found in the documentation for the {@link #checkedCollectioncheckedCollection} method.
                  &lt;p&gt;The returned list will be serializable if the specified list
                  is serializable.
                  &lt;p&gt;Since {@code null} is considered to be a value of any reference
                  type, the returned list permits insertion of null elements whenever
                  the backing list does.                
                <param>
                    list the list for which a dynamically typesafe view is to be
                      returned                    
                </param>
                <param>
                    type the type of element that {@code list} is permitted to hold                    
                </param>
                <return>
                    a dynamically typesafe view of the specified list                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="checkedList" type="List<E>" line="2485">
                <params>
                    <param name="list" type="List<E>"/>
                    <param name="type" type="Class<E>"/>
                </params>
            </method>
            <class name="CheckedList" line="2491">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="CheckedCollection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="List">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <javadoc line="2491">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2498"/>
                <declaration name="list" type="List&lt;E&gt;" line="2499"/>
                <method name="CheckedList" type="constructor" line="2501">
                    <params>
                        <param name="list" type="List<E>"/>
                        <param name="type" type="Class<E>"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="2506">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="2507"/>
                <method name="get" type="E" line="2508">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="remove" type="E" line="2509">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="indexOf" type="int" line="2510">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="lastIndexOf" type="int" line="2511">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="set" type="E" line="2513">
                    <params>
                        <param name="index" type="int"/>
                        <param name="element" type="E"/>
                    </params>
                </method>
                <method name="add" type="void" line="2518">
                    <params>
                        <param name="index" type="int"/>
                        <param name="element" type="E"/>
                    </params>
                </method>
                <method name="addAll" type="boolean" line="2523">
                    <params>
                        <param name="index" type="int"/>
                        <param name="c" type="Collection<? extends E>"/>
                    </params>
                </method>
                <method name="listIterator" type="ListIterator<E>" line="2526"/>
                <method name="listIterator" type="ListIterator<E>" line="2528">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                    <declaration name="i" type="ListIterator&lt;E&gt;" line="2529"/>
                    <anonymous_class line="2531">
                        <method name="hasNext" type="boolean" line="2532"/>
                        <method name="next" type="E" line="2533"/>
                        <method name="hasPrevious" type="boolean" line="2534"/>
                        <method name="previous" type="E" line="2535"/>
                        <method name="nextIndex" type="int" line="2536"/>
                        <method name="previousIndex" type="int" line="2537"/>
                        <method name="remove" type="void" line="2538"/>
                        <method name="set" type="void" line="2540">
                            <params>
                                <param name="e" type="E"/>
                            </params>
                        </method>
                        <method name="add" type="void" line="2545">
                            <params>
                                <param name="e" type="E"/>
                            </params>
                        </method>
                    </anonymous_class>
                </method>
                <method name="subList" type="List<E>" line="2552">
                    <params>
                        <param name="fromIndex" type="int"/>
                        <param name="toIndex" type="int"/>
                    </params>
                </method>
            </class>
            <class name="CheckedRandomAccessList" line="2557">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="CheckedList">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="RandomAccess"/>
                <javadoc line="2557">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2563"/>
                <method name="CheckedRandomAccessList" type="constructor" line="2565">
                    <params>
                        <param name="list" type="List<E>"/>
                        <param name="type" type="Class<E>"/>
                    </params>
                </method>
                <method name="subList" type="List<E>" line="2569">
                    <params>
                        <param name="fromIndex" type="int"/>
                        <param name="toIndex" type="int"/>
                    </params>
                </method>
            </class>
            <javadoc line="2575">
                Returns a dynamically typesafe view of the specified map.
                  Any attempt to insert a mapping whose key or value have the wrong
                  type will result in an immediate {@link ClassCastException}.
                  Similarly, any attempt to modify the value currently associated with
                  a key will result in an immediate {@link ClassCastException},
                  whether the modification is attempted directly through the map
                  itself, or through a {@link Map.Entry} instance obtained from the
                  map&apos;s {@link Map#entrySet() entry set} view.
                  &lt;p&gt;Assuming a map contains no incorrectly typed keys or values
                  prior to the time a dynamically typesafe view is generated, and
                  that all subsequent access to the map takes place through the view
                  (or one of its collection views), it is &lt;i&gt;guaranteed&lt;/i&gt; that the
                  map cannot contain an incorrectly typed key or value.
                  &lt;p&gt;A discussion of the use of dynamically typesafe views may be
                  found in the documentation for the {@link #checkedCollectioncheckedCollection} method.
                  &lt;p&gt;The returned map will be serializable if the specified map is
                  serializable.
                  &lt;p&gt;Since {@code null} is considered to be a value of any reference
                  type, the returned map permits insertion of null keys or values
                  whenever the backing map does.                
                <param>
                    m the map for which a dynamically typesafe view is to be
                      returned                    
                </param>
                <param>
                    keyType the type of key that {@code m} is permitted to hold                    
                </param>
                <param>
                    valueType the type of value that {@code m} is permitted to hold                    
                </param>
                <return>
                    a dynamically typesafe view of the specified map                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="checkedMap" type="Map<K,V>" line="2611">
                <params>
                    <param name="m" type="Map<K,V>"/>
                    <param name="keyType" type="Class<K>"/>
                    <param name="valueType" type="Class<V>"/>
                </params>
            </method>
            <class name="CheckedMap" line="2616">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Map">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="2616">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2622"/>
                <declaration name="m" type="Map&lt;K,V&gt;" line="2624"/>
                <declaration name="keyType" type="Class&lt;K&gt;" line="2625"/>
                <declaration name="valueType" type="Class&lt;V&gt;" line="2626"/>
                <method name="typeCheck" type="void" line="2628">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="value" type="Object"/>
                    </params>
                </method>
                <method name="badKeyMsg" type="String" line="2636">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="badValueMsg" type="String" line="2641">
                    <params>
                        <param name="value" type="Object"/>
                    </params>
                </method>
                <method name="CheckedMap" type="constructor" line="2646">
                    <params>
                        <param name="m" type="Map<K,V>"/>
                        <param name="keyType" type="Class<K>"/>
                        <param name="valueType" type="Class<V>"/>
                    </params>
                </method>
                <method name="size" type="int" line="2654"/>
                <method name="isEmpty" type="boolean" line="2655"/>
                <method name="containsKey" type="boolean" line="2656">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="containsValue" type="boolean" line="2657">
                    <params>
                        <param name="v" type="Object"/>
                    </params>
                </method>
                <method name="get" type="V" line="2658">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="V" line="2659">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="2660"/>
                <method name="keySet" type="Set<K>" line="2661"/>
                <method name="values" type="Collection<V>" line="2662"/>
                <method name="equals" type="boolean" line="2663">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="2664"/>
                <method name="toString" type="String" line="2665"/>
                <method name="put" type="V" line="2667">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                    </params>
                </method>
                <method name="putAll" type="void" line="2673">
                    <params>
                        <param name="t" type="Map<? extends K,? extends V>"/>
                    </params>
                    <comment line="2674">
                        Satisfy the following goals:                        
                    </comment>
                    <comment line="2675">
                        - good diagnostics in case of type mismatch                        
                    </comment>
                    <comment line="2676">
                        - all-or-nothing semantics                        
                    </comment>
                    <comment line="2677">
                        - protection from malicious t                        
                    </comment>
                    <comment line="2678">
                        - correct behavior if t is a concurrent map                        
                    </comment>
                    <declaration name="entries" type="Object[]" line="2679"/>
                    <declaration name="checked" type="List&lt;Map.Entry&lt;K,V&gt;&gt;" line="2680"/>
                    <scope line="2681">
                        <declaration name="e" type="Map.Entry&lt;?,?&gt;" line="2682"/>
                        <declaration name="k" type="Object" line="2683"/>
                        <declaration name="v" type="Object" line="2684"/>
                    </scope>
                </method>
                <declaration name="entrySet" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="2693"/>
                <method name="entrySet" type="Set<Map.Entry<K,V>>" line="2695"/>
                <class name="CheckedEntrySet" line="2701">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                    <implements interface="Set">
                        <type_params>
                            <type_param name="Map.Entry<K,V>"/>
                        </type_params>
                    </implements>
                    <javadoc line="2701">
                        We need this class in addition to CheckedSet as Map.Entry permits
                          modification of the backing Map via the setValue operation.  This
                          class is subtle: there are many possible attacks that must be
                          thwarted.                        
                        <serial>
                            exclude                            
                        </serial>
                    </javadoc>
                    <declaration name="s" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="2710"/>
                    <declaration name="valueType" type="Class&lt;V&gt;" line="2711"/>
                    <method name="CheckedEntrySet" type="constructor" line="2713">
                        <params>
                            <param name="s" type="Set<Map.Entry<K,V>>"/>
                            <param name="valueType" type="Class<V>"/>
                        </params>
                    </method>
                    <method name="size" type="int" line="2718"/>
                    <method name="isEmpty" type="boolean" line="2719"/>
                    <method name="toString" type="String" line="2720"/>
                    <method name="hashCode" type="int" line="2721"/>
                    <method name="clear" type="void" line="2722"/>
                    <method name="add" type="boolean" line="2724">
                        <params>
                            <param name="e" type="Map.Entry<K,V>"/>
                        </params>
                    </method>
                    <method name="addAll" type="boolean" line="2727">
                        <params>
                            <param name="coll" type="Collection<? extends Map.Entry<K,V>>"/>
                        </params>
                    </method>
                    <method name="iterator" type="Iterator<Map.Entry<K,V>>" line="2731">
                        <declaration name="i" type="Iterator&lt;Map.Entry&lt;K,V&gt;&gt;" line="2732"/>
                        <declaration name="valueType" type="Class&lt;V&gt;" line="2733"/>
                        <anonymous_class line="2735">
                            <method name="hasNext" type="boolean" line="2736"/>
                            <method name="remove" type="void" line="2737"/>
                            <method name="next" type="Map.Entry<K,V>" line="2739"/>
                        </anonymous_class>
                    </method>
                    <method name="toArray" type="Object[]" line="2746">
                        <comment line="2749">
                            Ensure that we don&apos;t get an ArrayStoreException even if
                             s.toArray returns an array of something other than Object                            
                        </comment>
                        <declaration name="source" type="Object[]" line="2747"/>
                        <declaration name="dest" type="Object[]" line="2753"/>
                    </method>
                    <method name="toArray" type="T[]" line="2764">
                        <params>
                            <param name="a" type="T[]"/>
                        </params>
                        <comment line="2765">
                            We don&apos;t pass a to s.toArray, to avoid window of                            
                        </comment>
                        <comment line="2766">
                            vulnerability wherein an unscrupulous multithreaded client                            
                        </comment>
                        <comment line="2767">
                            could get his hands on raw (unwrapped) Entries from s.                            
                        </comment>
                        <declaration name="arr" type="T[]" line="2768"/>
                    </method>
                    <javadoc line="2782">
                        This method is overridden to protect the backing set against
                          an object with a nefarious equals function that senses
                          that the equality-candidate is Map.Entry and calls its
                          setValue method.                        
                    </javadoc>
                    <method name="contains" type="boolean" line="2788">
                        <params>
                            <param name="o" type="Object"/>
                        </params>
                        <declaration name="e" type="Map.Entry&lt;?,?&gt;" line="2791"/>
                    </method>
                    <javadoc line="2796">
                        The bulk collection methods are overridden to protect
                          against an unscrupulous collection whose contains(Object o)
                          method senses when o is a Map.Entry, and calls o.setValue.                        
                    </javadoc>
                    <method name="containsAll" type="boolean" line="2801">
                        <params>
                            <param name="c" type="Collection<?>"/>
                        </params>
                        <comment line="2803">
                            Invokes safe contains() above                            
                        </comment>
                    </method>
                    <method name="remove" type="boolean" line="2808">
                        <params>
                            <param name="o" type="Object"/>
                        </params>
                    </method>
                    <method name="removeAll" type="boolean" line="2815">
                        <params>
                            <param name="c" type="Collection<?>"/>
                        </params>
                    </method>
                    <method name="retainAll" type="boolean" line="2818">
                        <params>
                            <param name="c" type="Collection<?>"/>
                        </params>
                    </method>
                    <method name="batchRemove" type="boolean" line="2821">
                        <params>
                            <param name="c" type="Collection<?>"/>
                            <param name="complement" type="boolean"/>
                        </params>
                        <declaration name="modified" type="boolean" line="2822"/>
                        <declaration name="it" type="Iterator&lt;Map.Entry&lt;K,V&gt;&gt;" line="2823"/>
                        <scope line="2824">
                            <scope line="2825"/>
                        </scope>
                    </method>
                    <method name="equals" type="boolean" line="2833">
                        <params>
                            <param name="o" type="Object"/>
                        </params>
                        <comment line="2840">
                            Invokes safe containsAll() above                            
                        </comment>
                        <declaration name="that" type="Set&lt;?&gt;" line="2838"/>
                    </method>
                    <method name="checkedEntry" type="CheckedEntry<K,V,T>" line="2844">
                        <params>
                            <param name="e" type="Map.Entry<K,V>"/>
                            <param name="valueType" type="Class<T>"/>
                        </params>
                    </method>
                    <class name="CheckedEntry" line="2848">
                        <type_params>
                            <type_param name="K"/>
                            <type_param name="V"/>
                            <type_param name="T"/>
                        </type_params>
                        <implements interface="Map.Entry">
                            <type_params>
                                <type_param name="K"/>
                                <type_param name="V"/>
                            </type_params>
                        </implements>
                        <javadoc line="2848">
                            This &quot;wrapper class&quot; serves two purposes: it prevents
                              the client from modifying the backing Map, by short-circuiting
                              the setValue method, and it protects the backing Map against
                              an ill-behaved Map.Entry that attempts to modify another
                              Map.Entry when asked to perform an equality check.                            
                        </javadoc>
                        <declaration name="e" type="Map.Entry&lt;K,V&gt;" line="2856"/>
                        <declaration name="valueType" type="Class&lt;T&gt;" line="2857"/>
                        <method name="CheckedEntry" type="constructor" line="2859">
                            <params>
                                <param name="e" type="Map.Entry<K,V>"/>
                                <param name="valueType" type="Class<T>"/>
                            </params>
                        </method>
                        <method name="getKey" type="K" line="2864"/>
                        <method name="getValue" type="V" line="2865"/>
                        <method name="hashCode" type="int" line="2866"/>
                        <method name="toString" type="String" line="2867"/>
                        <method name="setValue" type="V" line="2869">
                            <params>
                                <param name="value" type="V"/>
                            </params>
                        </method>
                        <method name="badValueMsg" type="String" line="2875">
                            <params>
                                <param name="value" type="Object"/>
                            </params>
                        </method>
                        <method name="equals" type="boolean" line="2880">
                            <params>
                                <param name="o" type="Object"/>
                            </params>
                        </method>
                    </class>
                </class>
            </class>
            <javadoc line="2892">
                Returns a dynamically typesafe view of the specified sorted map.
                  Any attempt to insert a mapping whose key or value have the wrong
                  type will result in an immediate {@link ClassCastException}.
                  Similarly, any attempt to modify the value currently associated with
                  a key will result in an immediate {@link ClassCastException},
                  whether the modification is attempted directly through the map
                  itself, or through a {@link Map.Entry} instance obtained from the
                  map&apos;s {@link Map#entrySet() entry set} view.
                  &lt;p&gt;Assuming a map contains no incorrectly typed keys or values
                  prior to the time a dynamically typesafe view is generated, and
                  that all subsequent access to the map takes place through the view
                  (or one of its collection views), it is &lt;i&gt;guaranteed&lt;/i&gt; that the
                  map cannot contain an incorrectly typed key or value.
                  &lt;p&gt;A discussion of the use of dynamically typesafe views may be
                  found in the documentation for the {@link #checkedCollectioncheckedCollection} method.
                  &lt;p&gt;The returned map will be serializable if the specified map is
                  serializable.
                  &lt;p&gt;Since {@code null} is considered to be a value of any reference
                  type, the returned map permits insertion of null keys or values
                  whenever the backing map does.                
                <param>
                    m the map for which a dynamically typesafe view is to be
                      returned                    
                </param>
                <param>
                    keyType the type of key that {@code m} is permitted to hold                    
                </param>
                <param>
                    valueType the type of value that {@code m} is permitted to hold                    
                </param>
                <return>
                    a dynamically typesafe view of the specified map                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="checkedSortedMap" type="SortedMap<K,V>" line="2928">
                <params>
                    <param name="m" type="SortedMap<K,V>"/>
                    <param name="keyType" type="Class<K>"/>
                    <param name="valueType" type="Class<V>"/>
                </params>
            </method>
            <class name="CheckedSortedMap" line="2932">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="CheckedMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="SortedMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="2932">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="2938"/>
                <declaration name="sm" type="SortedMap&lt;K,V&gt;" line="2940"/>
                <method name="CheckedSortedMap" type="constructor" line="2943">
                    <params>
                        <param name="m" type="SortedMap<K,V>"/>
                        <param name="keyType" type="Class<K>"/>
                        <param name="valueType" type="Class<V>"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super K>" line="2948"/>
                <method name="firstKey" type="K" line="2949"/>
                <method name="lastKey" type="K" line="2950"/>
                <method name="subMap" type="SortedMap<K,V>" line="2952">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="headMap" type="SortedMap<K,V>" line="2956">
                    <params>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="tailMap" type="SortedMap<K,V>" line="2959">
                    <params>
                        <param name="fromKey" type="K"/>
                    </params>
                </method>
            </class>
            <javadoc line="2966">
                Returns an iterator that has no elements.  More precisely,
                  &lt;ul compact&gt;
                  &lt;li&gt;{@link Iterator#hasNext hasNext} always returns {@codefalse}.
                  &lt;li&gt;{@link Iterator#next next} always throws {@link NoSuchElementException}.
                  &lt;li&gt;{@link Iterator#remove remove} always throws {@link IllegalStateException}.
                  &lt;/ul&gt;
                  &lt;p&gt;Implementations of this method are permitted, but not
                  required, to return the same object from multiple invocations.                
                <return>
                    an empty iterator                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="emptyIterator" type="Iterator<T>" line="2989"/>
            <class name="EmptyIterator" line="2993">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="EMPTY_ITERATOR" type="EmptyIterator&lt;Object&gt;" line="2994"/>
                <method name="hasNext" type="boolean" line="2997"/>
                <method name="next" type="E" line="2998"/>
                <method name="remove" type="void" line="2999"/>
            </class>
            <javadoc line="3002">
                Returns a list iterator that has no elements.  More precisely,
                  &lt;ul compact&gt;
                  &lt;li&gt;{@link Iterator#hasNext hasNext} and {@link ListIterator#hasPrevious hasPrevious} always return {@codefalse}.
                  &lt;li&gt;{@link Iterator#next next} and {@link ListIterator#previousprevious} always throw {@link NoSuchElementException}.
                  &lt;li&gt;{@link Iterator#remove remove} and {@link ListIterator#setset} always throw {@link IllegalStateException}.
                  &lt;li&gt;{@link ListIterator#add add} always throws {@link UnsupportedOperationException}.
                  &lt;li&gt;{@link ListIterator#nextIndex nextIndex} always returns{@code 0} .
                  &lt;li&gt;{@link ListIterator#previousIndex previousIndex} always
                  returns {@code -1}.
                  &lt;/ul&gt;
                  &lt;p&gt;Implementations of this method are permitted, but not
                  required, to return the same object from multiple invocations.                
                <return>
                    an empty list iterator                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="emptyListIterator" type="ListIterator<T>" line="3035"/>
            <class name="EmptyListIterator" line="3039">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="EmptyIterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="ListIterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="EMPTY_ITERATOR" type="EmptyListIterator&lt;Object&gt;" line="3043"/>
                <method name="hasPrevious" type="boolean" line="3046"/>
                <method name="previous" type="E" line="3047"/>
                <method name="nextIndex" type="int" line="3048"/>
                <method name="previousIndex" type="int" line="3049"/>
                <method name="set" type="void" line="3050">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="add" type="void" line="3051">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
            </class>
            <javadoc line="3054">
                Returns an enumeration that has no elements.  More precisely,
                  &lt;ul compact&gt;
                  &lt;li&gt;{@link Enumeration#hasMoreElements hasMoreElements} always
                  returns {@code false}.
                  &lt;li&gt; {@link Enumeration#nextElement nextElement} always throws{@link NoSuchElementException}.
                  &lt;/ul&gt;
                  &lt;p&gt;Implementations of this method are permitted, but not
                  required, to return the same object from multiple invocations.                
                <return>
                    an empty enumeration                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="emptyEnumeration" type="Enumeration<T>" line="3074"/>
            <class name="EmptyEnumeration" line="3078">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Enumeration">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="EMPTY_ENUMERATION" type="EmptyEnumeration&lt;Object&gt;" line="3079"/>
                <method name="hasMoreElements" type="boolean" line="3082"/>
                <method name="nextElement" type="E" line="3083"/>
            </class>
            <declaration name="EMPTY_SET" type="Set" line="3086"/>
            <javadoc line="3086">
                The empty set (immutable).  This set is serializable.                
                <see>
                    #emptySet()                    
                </see>
            </javadoc>
            <javadoc line="3094">
                Returns the empty set (immutable).  This set is serializable.
                  Unlike the like-named field, this method is parameterized.
                  &lt;p&gt;This example illustrates the type-safe way to obtain an empty set:
                  &lt;pre&gt;
                  Set&amp;lt;String&amp;gt; s = Collections.emptySet();
                  &lt;/pre&gt;
                  Implementation note:  Implementations of this method need not
                  create a separate &lt;tt&gt;Set&lt;/tt&gt; object for each call.   Using this
                  method is likely to have comparable cost to using the like-named
                  field.  (Unlike this method, the field does not provide type safety.)                
                <see>
                    #EMPTY_SET                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="emptySet" type="Set<T>" line="3111"/>
            <class name="EmptySet" line="3115">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Serializable"/>
                <javadoc line="3115">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3122"/>
                <method name="iterator" type="Iterator<E>" line="3124"/>
                <method name="size" type="int" line="3126"/>
                <method name="isEmpty" type="boolean" line="3127"/>
                <method name="contains" type="boolean" line="3129">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                </method>
                <method name="containsAll" type="boolean" line="3130">
                    <params>
                        <param name="c" type="Collection<?>"/>
                    </params>
                </method>
                <method name="toArray" type="Object[]" line="3132"/>
                <method name="toArray" type="T[]" line="3134">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
                <method name="readResolve" type="Object" line="3141"/>
            </class>
            <declaration name="EMPTY_LIST" type="List" line="3146"/>
            <javadoc line="3146">
                The empty list (immutable).  This list is serializable.                
                <see>
                    #emptyList()                    
                </see>
            </javadoc>
            <javadoc line="3154">
                Returns the empty list (immutable).  This list is serializable.
                  &lt;p&gt;This example illustrates the type-safe way to obtain an empty list:
                  &lt;pre&gt;
                  List&amp;lt;String&amp;gt; s = Collections.emptyList();
                  &lt;/pre&gt;
                  Implementation note:  Implementations of this method need not
                  create a separate &lt;tt&gt;List&lt;/tt&gt; object for each call.   Using this
                  method is likely to have comparable cost to using the like-named
                  field.  (Unlike this method, the field does not provide type safety.)                
                <see>
                    #EMPTY_LIST                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="emptyList" type="List<T>" line="3170"/>
            <class name="EmptyList" line="3174">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractList">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="RandomAccess"/>
                <implements interface="Serializable"/>
                <javadoc line="3174">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3180"/>
                <method name="iterator" type="Iterator<E>" line="3182"/>
                <method name="listIterator" type="ListIterator<E>" line="3185"/>
                <method name="size" type="int" line="3189"/>
                <method name="isEmpty" type="boolean" line="3190"/>
                <method name="contains" type="boolean" line="3192">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                </method>
                <method name="containsAll" type="boolean" line="3193">
                    <params>
                        <param name="c" type="Collection<?>"/>
                    </params>
                </method>
                <method name="toArray" type="Object[]" line="3195"/>
                <method name="toArray" type="T[]" line="3197">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
                <method name="get" type="E" line="3203">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="3207">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="3211"/>
                <method name="readResolve" type="Object" line="3214"/>
            </class>
            <declaration name="EMPTY_MAP" type="Map" line="3219"/>
            <javadoc line="3219">
                The empty map (immutable).  This map is serializable.                
                <see>
                    #emptyMap()                    
                </see>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <javadoc line="3228">
                Returns the empty map (immutable).  This map is serializable.
                  &lt;p&gt;This example illustrates the type-safe way to obtain an empty set:
                  &lt;pre&gt;
                  Map&amp;lt;String, Date&amp;gt; s = Collections.emptyMap();
                  &lt;/pre&gt;
                  Implementation note:  Implementations of this method need not
                  create a separate &lt;tt&gt;Map&lt;/tt&gt; object for each call.   Using this
                  method is likely to have comparable cost to using the like-named
                  field.  (Unlike this method, the field does not provide type safety.)                
                <see>
                    #EMPTY_MAP                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="emptyMap" type="Map<K,V>" line="3244"/>
            <class name="EmptyMap" line="3248">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="AbstractMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Serializable"/>
                <javadoc line="3248">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3255"/>
                <method name="size" type="int" line="3257"/>
                <method name="isEmpty" type="boolean" line="3258"/>
                <method name="containsKey" type="boolean" line="3259">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="containsValue" type="boolean" line="3260">
                    <params>
                        <param name="value" type="Object"/>
                    </params>
                </method>
                <method name="get" type="V" line="3261">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="keySet" type="Set<K>" line="3262"/>
                <method name="values" type="Collection<V>" line="3263"/>
                <method name="entrySet" type="Set<Map.Entry<K,V>>" line="3264"/>
                <method name="equals" type="boolean" line="3266">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="3270"/>
                <method name="readResolve" type="Object" line="3273"/>
            </class>
            <javadoc line="3280">
                Returns an immutable set containing only the specified object.
                  The returned set is serializable.                
                <param>
                    o the sole object to be stored in the returned set.                    
                </param>
                <return>
                    an immutable set containing only the specified object.                    
                </return>
            </javadoc>
            <method name="singleton" type="Set<T>" line="3287">
                <params>
                    <param name="o" type="T"/>
                </params>
            </method>
            <method name="singletonIterator" type="Iterator<E>" line="3291">
                <params>
                    <param name="e" type="E"/>
                </params>
                <anonymous_class line="3292">
                    <declaration name="hasNext" type="boolean" line="3293"/>
                    <method name="hasNext" type="boolean" line="3294"/>
                    <method name="next" type="E" line="3297">
                        <scope line="3298"/>
                    </method>
                    <method name="remove" type="void" line="3304"/>
                </anonymous_class>
            </method>
            <class name="SingletonSet" line="3310">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Serializable"/>
                <javadoc line="3310">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3317"/>
                <declaration name="element" type="E" line="3319"/>
                <method name="SingletonSet" type="constructor" line="3321">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="iterator" type="Iterator<E>" line="3323"/>
                <method name="size" type="int" line="3327"/>
                <method name="contains" type="boolean" line="3329">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
            </class>
            <javadoc line="3332">
                Returns an immutable list containing only the specified object.
                  The returned list is serializable.                
                <param>
                    o the sole object to be stored in the returned list.                    
                </param>
                <return>
                    an immutable list containing only the specified object.                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="singletonList" type="List<T>" line="3340">
                <params>
                    <param name="o" type="T"/>
                </params>
            </method>
            <class name="SingletonList" line="3344">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractList">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="RandomAccess"/>
                <implements interface="Serializable"/>
                <javadoc line="3344">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3351"/>
                <declaration name="element" type="E" line="3353"/>
                <method name="SingletonList" type="constructor" line="3355">
                    <params>
                        <param name="obj" type="E"/>
                    </params>
                </method>
                <method name="iterator" type="Iterator<E>" line="3357"/>
                <method name="size" type="int" line="3361"/>
                <method name="contains" type="boolean" line="3363">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                </method>
                <method name="get" type="E" line="3365">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
            </class>
            <javadoc line="3372">
                Returns an immutable map, mapping only the specified key to the
                  specified value.  The returned map is serializable.                
                <param>
                    key the sole key to be stored in the returned map.                    
                </param>
                <param>
                    value the value to which the returned map maps <tt>key</tt>.                    
                </param>
                <return>
                    an immutable map containing only the specified key-value
                      mapping.                    
                </return>
                <since>
                    1.3                    
                </since>
            </javadoc>
            <method name="singletonMap" type="Map<K,V>" line="3382">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
            </method>
            <class name="SingletonMap" line="3386">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="AbstractMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Serializable"/>
                <javadoc line="3386">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3392"/>
                <declaration name="k" type="K" line="3394"/>
                <declaration name="v" type="V" line="3395"/>
                <method name="SingletonMap" type="constructor" line="3397">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                    </params>
                </method>
                <method name="size" type="int" line="3402"/>
                <method name="isEmpty" type="boolean" line="3404"/>
                <method name="containsKey" type="boolean" line="3406">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="containsValue" type="boolean" line="3408">
                    <params>
                        <param name="value" type="Object"/>
                    </params>
                </method>
                <method name="get" type="V" line="3410">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <declaration name="keySet" type="Set&lt;K&gt;" line="3412"/>
                <declaration name="entrySet" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="3413"/>
                <declaration name="values" type="Collection&lt;V&gt;" line="3414"/>
                <method name="keySet" type="Set<K>" line="3416"/>
                <method name="entrySet" type="Set<Map.Entry<K,V>>" line="3422"/>
                <method name="values" type="Collection<V>" line="3429"/>
            </class>
            <javadoc line="3439">
                Returns an immutable list consisting of &lt;tt&gt;n&lt;/tt&gt; copies of the
                  specified object.  The newly allocated data object is tiny (it contains
                  a single reference to the data object).  This method is useful in
                  combination with the &lt;tt&gt;List.addAll&lt;/tt&gt; method to grow lists.
                  The returned list is serializable.                
                <param>
                    n the number of elements in the returned list.                    
                </param>
                <param>
                    o the element to appear repeatedly in the returned list.                    
                </param>
                <return>
                    an immutable list consisting of <tt>n</tt> copies of the
                      specified object.                    
                </return>
                <throws>
                    IllegalArgumentException if {@code n < 0}                    
                </throws>
                <see>
                    List#addAll(Collection)                    
                </see>
                <see>
                    List#addAll(int,Collection)                    
                </see>
            </javadoc>
            <method name="nCopies" type="List<T>" line="3454">
                <params>
                    <param name="n" type="int"/>
                    <param name="o" type="T"/>
                </params>
            </method>
            <class name="CopiesList" line="3460">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractList">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="RandomAccess"/>
                <implements interface="Serializable"/>
                <javadoc line="3460">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3467"/>
                <declaration name="n" type="int" line="3469"/>
                <declaration name="element" type="E" line="3470"/>
                <method name="CopiesList" type="constructor" line="3472">
                    <params>
                        <param name="n" type="int"/>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="size" type="int" line="3478"/>
                <method name="contains" type="boolean" line="3482">
                    <params>
                        <param name="obj" type="Object"/>
                    </params>
                </method>
                <method name="indexOf" type="int" line="3486">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="lastIndexOf" type="int" line="3490">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="get" type="E" line="3494">
                    <params>
                        <param name="index" type="int"/>
                    </params>
                </method>
                <method name="toArray" type="Object[]" line="3501">
                    <declaration name="a" type="Object[]" line="3502"/>
                </method>
                <method name="toArray" type="T[]" line="3508">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                    <declaration name="n" type="int" line="3509"/>
                    <scope line="3510"/>
                    <scope line="3515"/>
                </method>
                <method name="subList" type="List<E>" line="3523">
                    <params>
                        <param name="fromIndex" type="int"/>
                        <param name="toIndex" type="int"/>
                    </params>
                </method>
            </class>
            <javadoc line="3535">
                Returns a comparator that imposes the reverse of the &lt;em&gt;natural
                  ordering&lt;/em&gt; on a collection of objects that implement the{@code Comparable} interface.  (The natural ordering is the ordering
                  imposed by the objects&apos; own {@code compareTo} method.)  This enables a
                  simple idiom for sorting (or maintaining) collections (or arrays) of
                  objects that implement the {@code Comparable} interface in
                  reverse-natural-order.  For example, suppose {@code a} is an array of
                  strings. Then: &lt;pre&gt;
                  Arrays.sort(a, Collections.reverseOrder());
                  &lt;/pre&gt; sorts the array in reverse-lexicographic (alphabetical) order.&lt;p&gt;
                  The returned comparator is serializable.                
                <return>
                    A comparator that imposes the reverse of the <i>natural
                      ordering</i> on a collection of objects that implement
                      the <tt>Comparable</tt> interface.                    
                </return>
                <see>
                    Comparable                    
                </see>
            </javadoc>
            <method name="reverseOrder" type="Comparator<T>" line="3554"/>
            <class name="ReverseComparator" line="3558">
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Comparator">
                    <type_params>
                        <type_param name="Comparable<Object>"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="3558">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3564"/>
                <declaration name="REVERSE_ORDER" type="ReverseComparator" line="3566"/>
                <method name="compare" type="int" line="3569">
                    <params>
                        <param name="c1" type="Comparable<Object>"/>
                        <param name="c2" type="Comparable<Object>"/>
                    </params>
                </method>
                <method name="readResolve" type="Object" line="3573"/>
            </class>
            <javadoc line="3576">
                Returns a comparator that imposes the reverse ordering of the specified
                  comparator.  If the specified comparator is {@code null}, this method is
                  equivalent to {@link #reverseOrder()} (in other words, it returns a
                  comparator that imposes the reverse of the &lt;em&gt;natural ordering&lt;/em&gt; on
                  a collection of objects that implement the Comparable interface).
                  &lt;p&gt;The returned comparator is serializable (assuming the specified
                  comparator is also serializable or {@code null}).                
                <param>
                    cmp a comparator who's ordering is to be reversed by the returned
                      comparator or {@code null}                    
                </param>
                <return>
                    A comparator that imposes the reverse ordering of the
                      specified comparator.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="reverseOrder" type="Comparator<T>" line="3592">
                <params>
                    <param name="cmp" type="Comparator<T>"/>
                </params>
            </method>
            <class name="ReverseComparator2" line="3602">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Comparator">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="3602">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3608"/>
                <declaration name="cmp" type="Comparator&lt;T&gt;" line="3610"/>
                <javadoc line="3610">
                    The comparator specified in the static factory.  This will never
                      be null, as the static factory returns a ReverseComparator
                      instance if its argument is null.                    
                    <serial>
                                                
                    </serial>
                </javadoc>
                <method name="ReverseComparator2" type="constructor" line="3619">
                    <params>
                        <param name="cmp" type="Comparator<T>"/>
                    </params>
                </method>
                <method name="compare" type="int" line="3624">
                    <params>
                        <param name="t1" type="T"/>
                        <param name="t2" type="T"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="3628">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="3634"/>
            </class>
            <javadoc line="3639">
                Returns an enumeration over the specified collection.  This provides
                  interoperability with legacy APIs that require an enumeration
                  as input.                
                <param>
                    c the collection for which an enumeration is to be returned.                    
                </param>
                <return>
                    an enumeration over the specified collection.                    
                </return>
                <see>
                    Enumeration                    
                </see>
            </javadoc>
            <method name="enumeration" type="Enumeration<T>" line="3648">
                <params>
                    <param name="c" type="Collection<T>"/>
                </params>
                <anonymous_class line="3649">
                    <declaration name="i" type="Iterator&lt;T&gt;" line="3650"/>
                    <method name="hasMoreElements" type="boolean" line="3652"/>
                    <method name="nextElement" type="T" line="3656"/>
                </anonymous_class>
            </method>
            <javadoc line="3662">
                Returns an array list containing the elements returned by the
                  specified enumeration in the order they are returned by the
                  enumeration.  This method provides interoperability between
                  legacy APIs that return enumerations and new APIs that require
                  collections.                
                <param>
                    e enumeration providing elements for the returned
                      array list                    
                </param>
                <return>
                    an array list containing the elements returned
                      by the specified enumeration.                    
                </return>
                <since>
                    1.4                    
                </since>
                <see>
                    Enumeration                    
                </see>
                <see>
                    ArrayList                    
                </see>
            </javadoc>
            <method name="list" type="ArrayList<T>" line="3677">
                <params>
                    <param name="e" type="Enumeration<T>"/>
                </params>
                <declaration name="l" type="ArrayList&lt;T&gt;" line="3678"/>
            </method>
            <javadoc line="3684">
                Returns true if the specified arguments are equal, or both null.                
            </javadoc>
            <method name="eq" type="boolean" line="3687">
                <params>
                    <param name="o1" type="Object"/>
                    <param name="o2" type="Object"/>
                </params>
            </method>
            <javadoc line="3691">
                Returns the number of elements in the specified collection equal to the
                  specified object.  More formally, returns the number of elements
                  &lt;tt&gt;e&lt;/tt&gt; in the collection such that
                  &lt;tt&gt;(o == null ? e == null : o.equals(e))&lt;/tt&gt;.                
                <param>
                    c the collection in which to determine the frequency
                      of <tt>o</tt>                    
                </param>
                <param>
                    o the object whose frequency is to be determined                    
                </param>
                <throws>
                    NullPointerException if <tt>c</tt> is null                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="frequency" type="int" line="3703">
                <params>
                    <param name="c" type="Collection<?>"/>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="result" type="int" line="3704"/>
                <scope line="3705"/>
                <scope line="3709"/>
            </method>
            <javadoc line="3717">
                Returns {@code true} if the two specified collections have no
                  elements in common.
                  &lt;p&gt;Care must be exercised if this method is used on collections that
                  do not comply with the general contract for {@code Collection}.
                  Implementations may elect to iterate over either collection and test
                  for containment in the other collection (or to perform any equivalent
                  computation).  If either collection uses a nonstandard equality test
                  (as does a {@link SortedSet} whose ordering is not &lt;em&gt;compatible with
                  equals&lt;/em&gt;, or the key set of an {@link IdentityHashMap}), both
                  collections must use the same nonstandard equality test, or the
                  result of this method is undefined.
                  &lt;p&gt;Care must also be exercised when using collections that have
                  restrictions on the elements that they may contain. Collection
                  implementations are allowed to throw exceptions for any operation
                  involving elements they deem ineligible. For absolute safety the
                  specified collections should contain only elements which are
                  eligible elements for both collections.
                  &lt;p&gt;Note that it is permissible to pass the same collection in both
                  parameters, in which case the method will return {@code true} if and
                  only if the collection is empty.                
                <param>
                    c1 a collection                    
                </param>
                <param>
                    c2 a collection                    
                </param>
                <return>
                    {@code true} if the two specified collections have no
                      elements in common.                    
                </return>
                <throws>
                    NullPointerException if either collection is {@code null}.                    
                </throws>
                <throws>
                    NullPointerException if one collection contains a {@code null}element and {@code null} is not an eligible element for the other collection.
                      (<a href="Collection.html#optional-restrictions">optional</a>)                    
                </throws>
                <throws>
                    ClassCastException if one collection contains an element that is
                      of a type which is ineligible for the other collection.
                      (<a href="Collection.html#optional-restrictions">optional</a>)                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="disjoint" type="boolean" line="3755">
                <params>
                    <param name="c1" type="Collection<?>"/>
                    <param name="c2" type="Collection<?>"/>
                </params>
                <comment line="3756">
                    The collection to be used for contains(). Preference is given to                    
                </comment>
                <comment line="3757">
                    the collection who&apos;s contains() has lower O() complexity.                    
                </comment>
                <comment line="3759">
                    The collection to be iterated. If the collections&apos; contains() impl                    
                </comment>
                <comment line="3760">
                    are of different O() complexity, the collection with slower                    
                </comment>
                <comment line="3761">
                    contains() will be used for iteration. For collections who&apos;s                    
                </comment>
                <comment line="3762">
                    contains() are of the same complexity then best performance is                    
                </comment>
                <comment line="3763">
                    achieved by iterating the smaller collection.                    
                </comment>
                <comment line="3766">
                    Performance optimization cases. The heuristics:                    
                </comment>
                <comment line="3767">
                    1. Generally iterate over c1.                    
                </comment>
                <comment line="3768">
                    2. If c1 is a Set then iterate over c2.                    
                </comment>
                <comment line="3769">
                    3. If either collection is empty then result is always true.                    
                </comment>
                <comment line="3770">
                    4. Iterate over the smaller Collection.                    
                </comment>
                <comment line="3772">
                    Use c1 for contains as a Set&apos;s contains() is expected to perform                    
                </comment>
                <comment line="3773">
                    better than O(N/2)                    
                </comment>
                <comment line="3777">
                    Both are mere Collections. Iterate over smaller collection.                    
                </comment>
                <comment line="3778">
                    Example: If c1 contains 3 elements and c2 contains 50 elements and                    
                </comment>
                <comment line="3779">
                    assuming contains() requires ceiling(N/2) comparisons then                    
                </comment>
                <comment line="3780">
                    checking for all c1 elements in c2 would require 75 comparisons                    
                </comment>
                <comment line="3781">
                    (3 * ceiling(50/2)) vs. checking all c2 elements in c1 requiring                    
                </comment>
                <comment line="3782">
                    100 comparisons (50 * ceiling(3/2)).                    
                </comment>
                <comment line="3786">
                    At least one collection is empty. Nothing will match.                    
                </comment>
                <comment line="3798">
                    Found a common element. Collections are not disjoint.                    
                </comment>
                <comment line="3803">
                    No common elements were found.                    
                </comment>
                <declaration name="contains" type="Collection&lt;?&gt;" line="3758"/>
                <declaration name="iterate" type="Collection&lt;?&gt;" line="3764"/>
                <scope line="3771"/>
                <scope line="3776">
                    <declaration name="c1size" type="int" line="3783"/>
                    <declaration name="c2size" type="int" line="3784"/>
                    <scope line="3785"/>
                    <scope line="3790"/>
                </scope>
                <scope line="3796">
                    <scope line="3797"/>
                </scope>
            </method>
            <javadoc line="3807">
                Adds all of the specified elements to the specified collection.
                  Elements to be added may be specified individually or as an array.
                  The behavior of this convenience method is identical to that of
                  &lt;tt&gt;c.addAll(Arrays.asList(elements))&lt;/tt&gt;, but this method is likely
                  to run significantly faster under most implementations.
                  &lt;p&gt;When elements are specified individually, this method provides a
                  convenient way to add a few elements to an existing collection:
                  &lt;pre&gt;
                  Collections.addAll(flavors, &quot;Peaches &apos;n Plutonium&quot;, &quot;Rocky Racoon&quot;);
                  &lt;/pre&gt;                
                <param>
                    c the collection into which <tt>elements</tt> are to be inserted                    
                </param>
                <param>
                    elements the elements to insert into <tt>c</tt>                    
                </param>
                <return>
                    <tt>true</tt> if the collection changed as a result of the call                    
                </return>
                <throws>
                    UnsupportedOperationException if <tt>c</tt> does not support
                      the <tt>add</tt> operation                    
                </throws>
                <throws>
                    NullPointerException if <tt>elements</tt> contains one or more
                      null values and <tt>c</tt> does not permit null elements, or
                      if <tt>c</tt> or <tt>elements</tt> are <tt>null</tt>                    
                </throws>
                <throws>
                    IllegalArgumentException if some property of a value in
                      <tt>elements</tt> prevents it from being added to <tt>c</tt>                    
                </throws>
                <see>
                    Collection#addAll(Collection)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="addAll" type="boolean" line="3834">
                <params>
                    <param name="c" type="Collection<? super T>"/>
                    <param name="elements" type="T"/>
                </params>
                <declaration name="result" type="boolean" line="3835"/>
            </method>
            <javadoc line="3841">
                Returns a set backed by the specified map.  The resulting set displays
                  the same ordering, concurrency, and performance characteristics as the
                  backing map.  In essence, this factory method provides a {@link Set}implementation corresponding to any {@link Map} implementation.  There
                  is no need to use this method on a {@link Map} implementation that
                  already has a corresponding {@link Set} implementation (such as {@link HashMap} or {@link TreeMap}).
                  &lt;p&gt;Each method invocation on the set returned by this method results in
                  exactly one method invocation on the backing map or its &lt;tt&gt;keySet&lt;/tt&gt;
                  view, with one exception.  The &lt;tt&gt;addAll&lt;/tt&gt; method is implemented
                  as a sequence of &lt;tt&gt;put&lt;/tt&gt; invocations on the backing map.
                  &lt;p&gt;The specified map must be empty at the time this method is invoked,
                  and should not be accessed directly after this method returns.  These
                  conditions are ensured if the map is created empty, passed directly
                  to this method, and no reference to the map is retained, as illustrated
                  in the following code fragment:
                  &lt;pre&gt;
                  Set&amp;lt;Object&amp;gt; weakHashSet = Collections.newSetFromMap(
                  new WeakHashMap&amp;lt;Object, Boolean&amp;gt;());
                  &lt;/pre&gt;                
                <param>
                    map the backing map                    
                </param>
                <return>
                    the set backed by the map                    
                </return>
                <throws>
                    IllegalArgumentException if <tt>map</tt> is not empty                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="newSetFromMap" type="Set<E>" line="3870">
                <params>
                    <param name="map" type="Map<E,Boolean>"/>
                </params>
            </method>
            <class name="SetFromMap" line="3874">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Set">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="3874">
                    @serial include                    
                </javadoc>
                <declaration name="m" type="Map&lt;E,Boolean&gt;" line="3880"/>
                <declaration name="s" type="Set&lt;E&gt;" line="3881"/>
                <method name="SetFromMap" type="constructor" line="3883">
                    <params>
                        <param name="map" type="Map<E,Boolean>"/>
                    </params>
                </method>
                <method name="clear" type="void" line="3890"/>
                <method name="size" type="int" line="3891"/>
                <method name="isEmpty" type="boolean" line="3892"/>
                <method name="contains" type="boolean" line="3893">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="3894">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="add" type="boolean" line="3895">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="iterator" type="Iterator<E>" line="3896"/>
                <method name="toArray" type="Object[]" line="3897"/>
                <method name="toArray" type="T[]" line="3898">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
                <method name="toString" type="String" line="3899"/>
                <method name="hashCode" type="int" line="3900"/>
                <method name="equals" type="boolean" line="3901">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="containsAll" type="boolean" line="3902">
                    <params>
                        <param name="c" type="Collection<?>"/>
                    </params>
                </method>
                <method name="removeAll" type="boolean" line="3903">
                    <params>
                        <param name="c" type="Collection<?>"/>
                    </params>
                </method>
                <method name="retainAll" type="boolean" line="3904">
                    <params>
                        <param name="c" type="Collection<?>"/>
                    </params>
                </method>
                <declaration name="serialVersionUID" type="long" line="3907"/>
                <method name="readObject" type="void" line="3911">
                    <params>
                        <param name="stream" type="java.io.ObjectInputStream"/>
                    </params>
                </method>
            </class>
            <javadoc line="3917">
                Returns a view of a {@link Deque} as a Last-in-first-out (Lifo){@link Queue}. Method &lt;tt&gt;add&lt;/tt&gt; is mapped to &lt;tt&gt;push&lt;/tt&gt;,
                  &lt;tt&gt;remove&lt;/tt&gt; is mapped to &lt;tt&gt;pop&lt;/tt&gt; and so on. This
                  view can be useful when you would like to use a method
                  requiring a &lt;tt&gt;Queue&lt;/tt&gt; but you need Lifo ordering.
                  &lt;p&gt;Each method invocation on the queue returned by this method
                  results in exactly one method invocation on the backing deque, with
                  one exception.  The {@link Queue#addAll addAll} method is
                  implemented as a sequence of {@link Deque#addFirst addFirst}invocations on the backing deque.                
                <param>
                    deque the deque                    
                </param>
                <return>
                    the queue                    
                </return>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="asLifoQueue" type="Queue<T>" line="3934">
                <params>
                    <param name="deque" type="Deque<T>"/>
                </params>
            </method>
            <class name="AsLIFOQueue" line="3938">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractQueue">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <comment line="1600">
                    Backing Collection                    
                </comment>
                <comment line="1601">
                    Object on which to synchronize                    
                </comment>
                <comment line="2004">
                    Backing Map                    
                </comment>
                <comment line="2005">
                    Object on which to synchronize                    
                </comment>
                <comment line="2316">
                    Lazily initialized                    
                </comment>
                <comment line="3141">
                    Preserves singleton property                    
                </comment>
                <comment line="3214">
                    Preserves singleton property                    
                </comment>
                <comment line="3273">
                    Preserves singleton property                    
                </comment>
                <comment line="3881">
                    The backing map                    
                </comment>
                <comment line="3882">
                    Its keySet                    
                </comment>
                <comment line="3906">
                    addAll is the only inherited implementation                    
                </comment>
                <comment line="3965">
                    We use inherited addAll; forwarding addAll would be wrong                    
                </comment>
                <implements interface="Queue">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <implements interface="Serializable"/>
                <javadoc line="3938">
                    @serial include                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="3943"/>
                <declaration name="q" type="Deque&lt;E&gt;" line="3944"/>
                <method name="AsLIFOQueue" type="constructor" line="3945">
                    <params>
                        <param name="q" type="Deque<E>"/>
                    </params>
                </method>
                <method name="add" type="boolean" line="3946">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="offer" type="boolean" line="3947">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="poll" type="E" line="3948"/>
                <method name="remove" type="E" line="3949"/>
                <method name="peek" type="E" line="3950"/>
                <method name="element" type="E" line="3951"/>
                <method name="clear" type="void" line="3952"/>
                <method name="size" type="int" line="3953"/>
                <method name="isEmpty" type="boolean" line="3954"/>
                <method name="contains" type="boolean" line="3955">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="3956">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="iterator" type="Iterator<E>" line="3957"/>
                <method name="toArray" type="Object[]" line="3958"/>
                <method name="toArray" type="T[]" line="3959">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
                <method name="toString" type="String" line="3960"/>
                <method name="containsAll" type="boolean" line="3961">
                    <params>
                        <param name="c" type="Collection<?>"/>
                    </params>
                </method>
                <method name="removeAll" type="boolean" line="3962">
                    <params>
                        <param name="c" type="Collection<?>"/>
                    </params>
                </method>
                <method name="retainAll" type="boolean" line="3963">
                    <params>
                        <param name="c" type="Collection<?>"/>
                    </params>
                </method>
            </class>
        </class>
    </source>