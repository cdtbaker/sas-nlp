<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util">
        <import package="java.io.BufferedWriter"/>
        <import package="java.io.Closeable"/>
        <import package="java.io.IOException"/>
        <import package="java.io.File"/>
        <import package="java.io.FileOutputStream"/>
        <import package="java.io.FileNotFoundException"/>
        <import package="java.io.Flushable"/>
        <import package="java.io.OutputStream"/>
        <import package="java.io.OutputStreamWriter"/>
        <import package="java.io.PrintStream"/>
        <import package="java.io.UnsupportedEncodingException"/>
        <import package="java.math.BigDecimal"/>
        <import package="java.math.BigInteger"/>
        <import package="java.math.MathContext"/>
        <import package="java.math.RoundingMode"/>
        <import package="java.nio.charset.Charset"/>
        <import package="java.nio.charset.IllegalCharsetNameException"/>
        <import package="java.nio.charset.UnsupportedCharsetException"/>
        <import package="java.text.DateFormatSymbols"/>
        <import package="java.text.DecimalFormat"/>
        <import package="java.text.DecimalFormatSymbols"/>
        <import package="java.text.NumberFormat"/>
        <import package="java.util.regex.Matcher"/>
        <import package="java.util.regex.Pattern"/>
        <import package="sun.misc.FpUtils"/>
        <import package="sun.misc.DoubleConsts"/>
        <import package="sun.misc.FormattedFloatingDecimal"/>
        <class name="Formatter" line="29">
            <implements interface="Closeable"/>
            <implements interface="Flushable"/>
            <javadoc line="29">
                An interpreter for printf-style format strings.  This class provides support
                  for layout justification and alignment, common formats for numeric, string,
                  and date/time data, and locale-specific output.  Common Java types such as{@code byte}, {@link java.math.BigDecimal BigDecimal}, and {@link Calendar}are supported.  Limited formatting customization for arbitrary user types is
                  provided through the {@link Formattable} interface.
                  &lt;p&gt; Formatters are not necessarily safe for multithreaded access.  Thread
                  safety is optional and is the responsibility of users of methods in this
                  class.
                  &lt;p&gt; Formatted printing for the Java language is heavily inspired by C&apos;s{@code printf}.  Although the format strings are similar to C, some
                  customizations have been made to accommodate the Java language and exploit
                  some of its features.  Also, Java formatting is more strict than C&apos;s; for
                  example, if a conversion is incompatible with a flag, an exception will be
                  thrown.  In C inapplicable flags are silently ignored.  The format strings
                  are thus intended to be recognizable to C programmers but not necessarily
                  completely compatible with those in C.
                  &lt;p&gt; Examples of expected usage:
                  &lt;blockquote&gt;&lt;pre&gt;
                  StringBuilder sb = new StringBuilder();
                  // Send all output to the Appendable object sb
                  Formatter formatter = new Formatter(sb, Locale.US);
                  // Explicit argument indices may be used to re-order output.
                  formatter.format(&quot;%4$2s %3$2s %2$2s %1$2s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
                  // -&amp;gt; &quot; d  c  b  a&quot;
                  // Optional locale as the first argument can be used to get
                  // locale-specific formatting of numbers.  The precision and width can be
                  // given to round and align the value.
                  formatter.format(Locale.FRANCE, &quot;e = %+10.4f&quot;, Math.E);
                  // -&amp;gt; &quot;e =    +2,7183&quot;
                  // The &apos;(&apos; numeric flag may be used to format negative numbers with
                  // parentheses rather than a minus sign.  Group separators are
                  // automatically inserted.
                  formatter.format(&quot;Amount gained or lost since last statement: $ %(,.2f&quot;,
                  balanceDelta);
                  // -&amp;gt; &quot;Amount gained or lost since last statement: $ (6,217.58)&quot;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; Convenience methods for common formatting requests exist as illustrated
                  by the following invocations:
                  &lt;blockquote&gt;&lt;pre&gt;
                  // Writes a formatted string to System.out.
                  System.out.format(&quot;Local time: %tT&quot;, Calendar.getInstance());
                  // -&amp;gt; &quot;Local time: 13:34:18&quot;
                  // Writes formatted output to System.err.
                  System.err.printf(&quot;Unable to open file &apos;%1$s&apos;: %2$s&quot;,
                  fileName, exception.getMessage());
                  // -&amp;gt; &quot;Unable to open file &apos;food&apos;: No such file or directory&quot;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; Like C&apos;s {@code sprintf(3)}, Strings may be formatted using the static
                  method {@link String#format(String,Object) String.format}:
                  &lt;blockquote&gt;&lt;pre&gt;
                  // Format a string containing a date.
                  import java.util.Calendar;
                  import java.util.GregorianCalendar;
                  import static java.util.Calendar.;
                  Calendar c = new GregorianCalendar(1995, MAY, 23);
                  String s = String.format(&quot;Duke&apos;s Birthday: %1$tm %1$te,%1$tY&quot;, c);
                  // -&amp;gt; s == &quot;Duke&apos;s Birthday: May 23, 1995&quot;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;h3&gt;&lt;a name=&quot;org&quot;&gt;Organization&lt;/a&gt;&lt;/h3&gt;
                  &lt;p&gt; This specification is divided into two sections.  The first section, &lt;a
                  href=&quot;#summary&quot;&gt;Summary&lt;/a&gt;, covers the basic formatting concepts.  This
                  section is intended for users who want to get started quickly and are
                  familiar with formatted printing in other programming languages.  The second
                  section, &lt;a href=&quot;#detail&quot;&gt;Details&lt;/a&gt;, covers the specific implementation
                  details.  It is intended for users who want more precise specification of
                  formatting behavior.
                  &lt;h3&gt;&lt;a name=&quot;summary&quot;&gt;Summary&lt;/a&gt;&lt;/h3&gt;
                  &lt;p&gt; This section is intended to provide a brief overview of formatting
                  concepts.  For precise behavioral details, refer to the &lt;a
                  href=&quot;#detail&quot;&gt;Details&lt;/a&gt; section.
                  &lt;h4&gt;&lt;a name=&quot;syntax&quot;&gt;Format String Syntax&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt; Every method which produces formatted output requires a &lt;i&gt;format
                  string&lt;/i&gt; and an &lt;i&gt;argument list&lt;/i&gt;.  The format string is a {@link String} which may contain fixed text and one or more embedded &lt;i&gt;format
                  specifiers&lt;/i&gt;.  Consider the following example:
                  &lt;blockquote&gt;&lt;pre&gt;
                  Calendar c = ...;
                  String s = String.format(&quot;Duke&apos;s Birthday: %1$tm %1$te,%1$tY&quot;, c);
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  This format string is the first argument to the {@code format} method.  It
                  contains three format specifiers &quot;{@code %1$tm}&quot;, &quot;{@code %1$te}&quot;, and
                  &quot;{@code %1$tY}&quot; which indicate how the arguments should be processed and
                  where they should be inserted in the text.  The remaining portions of the
                  format string are fixed text including {@code &quot;Dukes Birthday: &quot;} and any
                  other spaces or punctuation.
                  The argument list consists of all arguments passed to the method after the
                  format string.  In the above example, the argument list is of size one and
                  consists of the {@link java.util.Calendar Calendar} object {@code c}.
                  &lt;ul&gt;
                  &lt;li&gt; The format specifiers for general, character, and numeric types have
                  the following syntax:
                  &lt;blockquote&gt;&lt;pre&gt;
                  %[argument_index$][flags][width][.precision]conversion
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; The optional &lt;i&gt;argument_index&lt;/i&gt; is a decimal integer indicating the
                  position of the argument in the argument list.  The first argument is
                  referenced by &quot;{@code 1$}&quot;, the second by &quot;{@code 2$}&quot;, etc.
                  &lt;p&gt; The optional &lt;i&gt;flags&lt;/i&gt; is a set of characters that modify the output
                  format.  The set of valid flags depends on the conversion.
                  &lt;p&gt; The optional &lt;i&gt;width&lt;/i&gt; is a non-negative decimal integer indicating
                  the minimum number of characters to be written to the output.
                  &lt;p&gt; The optional &lt;i&gt;precision&lt;/i&gt; is a non-negative decimal integer usually
                  used to restrict the number of characters.  The specific behavior depends on
                  the conversion.
                  &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a character indicating how the
                  argument should be formatted.  The set of valid conversions for a given
                  argument depends on the argument&apos;s data type.
                  &lt;li&gt; The format specifiers for types which are used to represents dates and
                  times have the following syntax:
                  &lt;blockquote&gt;&lt;pre&gt;
                  %[argument_index$][flags][width]conversion
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; The optional &lt;i&gt;argument_index&lt;/i&gt;, &lt;i&gt;flags&lt;/i&gt; and &lt;i&gt;width&lt;/i&gt; are
                  defined as above.
                  &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a two character sequence.  The first
                  character is {@code &apos;t&apos;} or {@code &apos;T&apos;}.  The second character indicates
                  the format to be used.  These characters are similar to but not completely
                  identical to those defined by GNU {@code date} and POSIX{@code strftime(3c)}.
                  &lt;li&gt; The format specifiers which do not correspond to arguments have the
                  following syntax:
                  &lt;blockquote&gt;&lt;pre&gt;
                  %[flags][width]conversion
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; The optional &lt;i&gt;flags&lt;/i&gt; and &lt;i&gt;width&lt;/i&gt; is defined as above.
                  &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a character indicating content to be
                  inserted in the output.
                  &lt;/ul&gt;
                  &lt;h4&gt; Conversions &lt;/h4&gt;
                  &lt;p&gt; Conversions are divided into the following categories:
                  &lt;ol&gt;
                  &lt;li&gt; &lt;b&gt;General&lt;/b&gt; - may be applied to any argument
                  type
                  &lt;li&gt; &lt;b&gt;Character&lt;/b&gt; - may be applied to basic types which represent
                  Unicode characters: {@code char}, {@link Character}, {@code byte}, {@link Byte}, {@code short}, and {@link Short}. This conversion may also be
                  applied to the types {@code int} and {@link Integer} when {@link Character#isValidCodePoint} returns {@code true}&lt;li&gt; &lt;b&gt;Numeric&lt;/b&gt;
                  &lt;ol&gt;
                  &lt;li&gt; &lt;b&gt;Integral&lt;/b&gt; - may be applied to Java integral types: {@code byte},{@link Byte}, {@code short}, {@link Short}, {@code int} and {@link Integer}, {@code long}, {@link Long}, and {@link java.math.BigIntegerBigInteger}&lt;li&gt;&lt;b&gt;Floating Point&lt;/b&gt; - may be applied to Java floating-point types:{@code float}, {@link Float}, {@code double}, {@link Double}, and {@link java.math.BigDecimal BigDecimal}&lt;/ol&gt;
                  &lt;li&gt; &lt;b&gt;Date/Time&lt;/b&gt; - may be applied to Java types which are capable of
                  encoding a date or time: {@code long}, {@link Long}, {@link Calendar}, and{@link Date}.
                  &lt;li&gt; &lt;b&gt;Percent&lt;/b&gt; - produces a literal {@code &apos;%&apos;}(&lt;tt&gt;&apos;&amp;#92;u0025&apos;&lt;/tt&gt;)
                  &lt;li&gt; &lt;b&gt;Line Separator&lt;/b&gt; - produces the platform-specific line separator
                  &lt;/ol&gt;
                  &lt;p&gt; The following table summarizes the supported conversions.  Conversions
                  denoted by an upper-case character (i.e. {@code &apos;B&apos;}, {@code &apos;H&apos;},{@code &apos;S&apos;}, {@code &apos;C&apos;}, {@code &apos;X&apos;}, {@code &apos;E&apos;}, {@code &apos;G&apos;},{@code &apos;A&apos;}, and {@code &apos;T&apos;}) are the same as those for the corresponding
                  lower-case conversion characters except that the result is converted to
                  upper case according to the rules of the prevailing {@link java.util.LocaleLocale}.  The result is equivalent to the following invocation of {@link String#toUpperCase()}&lt;pre&gt;
                  out.toUpperCase() &lt;/pre&gt;
                  &lt;table cellpadding=5 summary=&quot;genConv&quot;&gt;
                  &lt;tr&gt;&lt;th valign=&quot;bottom&quot;&gt; Conversion
                  &lt;th valign=&quot;bottom&quot;&gt; Argument Category
                  &lt;th valign=&quot;bottom&quot;&gt; Description
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;b&apos;}, {@code &apos;B&apos;}&lt;td valign=&quot;top&quot;&gt; general
                  &lt;td&gt; If the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is
                  &quot;{@code false}&quot;.  If &lt;i&gt;arg&lt;/i&gt; is a {@code boolean} or {@link Boolean}, then the result is the string returned by {@link String#valueOf(boolean) String.valueOf(arg)}.  Otherwise, the result is
                  &quot;true&quot;.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;h&apos;}, {@code &apos;H&apos;}&lt;td valign=&quot;top&quot;&gt; general
                  &lt;td&gt; If the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is
                  &quot;{@code null}&quot;.  Otherwise, the result is obtained by invoking{@code Integer.toHexString(arg.hashCode())}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;s&apos;}, {@code &apos;S&apos;}&lt;td valign=&quot;top&quot;&gt; general
                  &lt;td&gt; If the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is
                  &quot;{@code null}&quot;.  If &lt;i&gt;arg&lt;/i&gt; implements {@link Formattable}, then{@link Formattable#formatTo arg.formatTo} is invoked. Otherwise, the
                  result is obtained by invoking {@code arg.toString()}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;c&apos;}, {@code &apos;C&apos;}&lt;td valign=&quot;top&quot;&gt; character
                  &lt;td&gt; The result is a Unicode character
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;d&apos;}&lt;td valign=&quot;top&quot;&gt; integral
                  &lt;td&gt; The result is formatted as a decimal integer
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;o&apos;}&lt;td valign=&quot;top&quot;&gt; integral
                  &lt;td&gt; The result is formatted as an octal integer
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;x&apos;}, {@code &apos;X&apos;}&lt;td valign=&quot;top&quot;&gt; integral
                  &lt;td&gt; The result is formatted as a hexadecimal integer
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;e&apos;}, {@code &apos;E&apos;}&lt;td valign=&quot;top&quot;&gt; floating point
                  &lt;td&gt; The result is formatted as a decimal number in computerized
                  scientific notation
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;f&apos;}&lt;td valign=&quot;top&quot;&gt; floating point
                  &lt;td&gt; The result is formatted as a decimal number
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;g&apos;}, {@code &apos;G&apos;}&lt;td valign=&quot;top&quot;&gt; floating point
                  &lt;td&gt; The result is formatted using computerized scientific notation or
                  decimal format, depending on the precision and the value after rounding.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;a&apos;}, {@code &apos;A&apos;}&lt;td valign=&quot;top&quot;&gt; floating point
                  &lt;td&gt; The result is formatted as a hexadecimal floating-point number with
                  a significand and an exponent
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;t&apos;}, {@code &apos;T&apos;}&lt;td valign=&quot;top&quot;&gt; date/time
                  &lt;td&gt; Prefix for date and time conversion characters.  See &lt;a
                  href=&quot;#dt&quot;&gt;Date/Time Conversions&lt;/a&gt;.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;%&apos;}&lt;td valign=&quot;top&quot;&gt; percent
                  &lt;td&gt; The result is a literal {@code &apos;%&apos;} (&lt;tt&gt;&apos;&amp;#92;u0025&apos;&lt;/tt&gt;)
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;n&apos;}&lt;td valign=&quot;top&quot;&gt; line separator
                  &lt;td&gt; The result is the platform-specific line separator
                  &lt;/table&gt;
                  &lt;p&gt; Any characters not explicitly defined as conversions are illegal and are
                  reserved for future extensions.
                  &lt;h4&gt;&lt;a name=&quot;dt&quot;&gt;Date/Time Conversions&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt; The following date and time conversion suffix characters are defined for
                  the {@code &apos;t&apos;} and {@code &apos;T&apos;} conversions.  The types are similar to but
                  not completely identical to those defined by GNU {@code date} and POSIX{@code strftime(3c)}.  Additional conversion types are provided to access
                  Java-specific functionality (e.g. {@code &apos;L&apos;} for milliseconds within the
                  second).
                  &lt;p&gt; The following conversion characters are used for formatting times:
                  &lt;table cellpadding=5 summary=&quot;time&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;H&apos;}&lt;td&gt; Hour of the day for the 24-hour clock, formatted as two digits with
                  a leading zero as necessary i.e. {@code 00 - 23}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;I&apos;}&lt;td&gt; Hour for the 12-hour clock, formatted as two digits with a leading
                  zero as necessary, i.e.  {@code 01 - 12}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;k&apos;}&lt;td&gt; Hour of the day for the 24-hour clock, i.e. {@code 0 - 23}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;l&apos;}&lt;td&gt; Hour for the 12-hour clock, i.e. {@code 1 - 12}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;M&apos;}&lt;td&gt; Minute within the hour formatted as two digits with a leading zero
                  as necessary, i.e.  {@code 00 - 59}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;S&apos;}&lt;td&gt; Seconds within the minute, formatted as two digits with a leading
                  zero as necessary, i.e. {@code 00 - 60} (&quot;{@code 60}&quot; is a special
                  value required to support leap seconds).
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;L&apos;}&lt;td&gt; Millisecond within the second formatted as three digits with
                  leading zeros as necessary, i.e. {@code 000 - 999}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;N&apos;}&lt;td&gt; Nanosecond within the second, formatted as nine digits with leading
                  zeros as necessary, i.e. {@code 000000000 - 999999999}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;p&apos;}&lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
                  in lower case, e.g.&quot;{@code am}&quot; or &quot;{@code pm}&quot;. Use of the conversion
                  prefix {@code &apos;T&apos;} forces this output to upper case.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;z&apos;}&lt;td&gt; &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC&amp;nbsp;822&lt;/a&gt;
                  style numeric time zone offset from GMT, e.g. {@code -0800}.  This
                  value will be adjusted as necessary for Daylight Saving Time.  For{@code long}, {@link Long}, and {@link Date} the time zone used is
                  the {@linkplain TimeZone#getDefault() default time zone} for this
                  instance of the Java virtual machine.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;Z&apos;}&lt;td&gt; A string representing the abbreviation for the time zone.  This
                  value will be adjusted as necessary for Daylight Saving Time.  For{@code long}, {@link Long}, and {@link Date} the  time zone used is
                  the {@linkplain TimeZone#getDefault() default time zone} for this
                  instance of the Java virtual machine.  The Formatter&apos;s locale will
                  supersede the locale of the argument (if any).
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;s&apos;}&lt;td&gt; Seconds since the beginning of the epoch starting at 1 January 1970{@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE/1000} to{@code Long.MAX_VALUE/1000}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;Q&apos;}&lt;td&gt; Milliseconds since the beginning of the epoch starting at 1 January
                  1970 {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE} to{@code Long.MAX_VALUE}.
                  &lt;/table&gt;
                  &lt;p&gt; The following conversion characters are used for formatting dates:
                  &lt;table cellpadding=5 summary=&quot;date&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;B&apos;}&lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getMonthsfull month name}, e.g. {@code &quot;January&quot;}, {@code &quot;February&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;b&apos;}&lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getShortMonths abbreviated month name},
                  e.g. {@code &quot;Jan&quot;}, {@code &quot;Feb&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;h&apos;}&lt;td&gt; Same as {@code &apos;b&apos;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;A&apos;}&lt;td&gt; Locale-specific full name of the {@linkplain java.text.DateFormatSymbols#getWeekdays day of the week},
                  e.g. {@code &quot;Sunday&quot;}, {@code &quot;Monday&quot;}&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;a&apos;}&lt;td&gt; Locale-specific short name of the {@linkplain java.text.DateFormatSymbols#getShortWeekdays day of the week},
                  e.g. {@code &quot;Sun&quot;}, {@code &quot;Mon&quot;}&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;C&apos;}&lt;td&gt; Four-digit year divided by {@code 100}, formatted as two digits
                  with leading zero as necessary, i.e. {@code 00 - 99}&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;Y&apos;}&lt;td&gt; Year, formatted as at least four digits with leading zeros as
                  necessary, e.g. {@code 0092} equals {@code 92} CE for the Gregorian
                  calendar.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;y&apos;}&lt;td&gt; Last two digits of the year, formatted with leading zeros as
                  necessary, i.e. {@code 00 - 99}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;j&apos;}&lt;td&gt; Day of year, formatted as three digits with leading zeros as
                  necessary, e.g. {@code 001 - 366} for the Gregorian calendar.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;m&apos;}&lt;td&gt; Month, formatted as two digits with leading zeros as necessary,
                  i.e. {@code 01 - 13}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;d&apos;}&lt;td&gt; Day of month, formatted as two digits with leading zeros as
                  necessary, i.e. {@code 01 - 31}&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;e&apos;}&lt;td&gt; Day of month, formatted as two digits, i.e. {@code 1 - 31}.
                  &lt;/table&gt;
                  &lt;p&gt; The following conversion characters are used for formatting common
                  date/time compositions.
                  &lt;table cellpadding=5 summary=&quot;composites&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;R&apos;}&lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM&quot;}&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;T&apos;}&lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM:%tS&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;r&apos;}&lt;td&gt; Time formatted for the 12-hour clock as {@code &quot;%tI:%tM:%tS %Tp&quot;}.
                  The location of the morning or afternoon marker ({@code &apos;%Tp&apos;}) may be
                  locale-dependent.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;D&apos;}&lt;td&gt; Date formatted as {@code &quot;%tm/%td/%ty&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;F&apos;}&lt;td&gt; &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO&amp;nbsp;8601&lt;/a&gt;
                  complete date formatted as {@code &quot;%tY-%tm-%td&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;c&apos;}&lt;td&gt; Date and time formatted as {@code &quot;%ta %tb %td %tT %tZ %tY&quot;},
                  e.g. {@code &quot;Sun Jul 20 16:17:00 EDT 1969&quot;}.
                  &lt;/table&gt;
                  &lt;p&gt; Any characters not explicitly defined as date/time conversion suffixes
                  are illegal and are reserved for future extensions.
                  &lt;h4&gt; Flags &lt;/h4&gt;
                  &lt;p&gt; The following table summarizes the supported flags.  &lt;i&gt;y&lt;/i&gt; means the
                  flag is supported for the indicated argument types.
                  &lt;table cellpadding=5 summary=&quot;genConv&quot;&gt;
                  &lt;tr&gt;&lt;th valign=&quot;bottom&quot;&gt; Flag &lt;th valign=&quot;bottom&quot;&gt; General
                  &lt;th valign=&quot;bottom&quot;&gt; Character &lt;th valign=&quot;bottom&quot;&gt; Integral
                  &lt;th valign=&quot;bottom&quot;&gt; Floating Point
                  &lt;th valign=&quot;bottom&quot;&gt; Date/Time
                  &lt;th valign=&quot;bottom&quot;&gt; Description
                  &lt;tr&gt;&lt;td&gt; &apos;-&apos; &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td&gt; The result will be left-justified.
                  &lt;tr&gt;&lt;td&gt; &apos;#&apos; &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;1&lt;/sup&gt;
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;3&lt;/sup&gt;
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td&gt; The result should use a conversion-dependent alternate form
                  &lt;tr&gt;&lt;td&gt; &apos;+&apos; &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;4&lt;/sup&gt;
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td&gt; The result will always include a sign
                  &lt;tr&gt;&lt;td&gt; &apos;&amp;nbsp;&amp;nbsp;&apos; &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;4&lt;/sup&gt;
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td&gt; The result will include a leading space for positive values
                  &lt;tr&gt;&lt;td&gt; &apos;0&apos; &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td&gt; The result will be zero-padded
                  &lt;tr&gt;&lt;td&gt; &apos;,&apos; &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;2&lt;/sup&gt;
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;5&lt;/sup&gt;
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td&gt; The result will include locale-specific {@linkplain java.text.DecimalFormatSymbols#getGroupingSeparator grouping separators}&lt;tr&gt;&lt;td&gt; &apos;(&apos; &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; -
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;4&lt;/sup&gt;
                  &lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt; y&lt;sup&gt;5&lt;/sup&gt;
                  &lt;td align=&quot;center&quot;&gt; -
                  &lt;td&gt; The result will enclose negative numbers in parentheses
                  &lt;/table&gt;
                  &lt;p&gt; &lt;sup&gt;1&lt;/sup&gt; Depends on the definition of {@link Formattable}.
                  &lt;p&gt; &lt;sup&gt;2&lt;/sup&gt; For {@code &apos;d&apos;} conversion only.
                  &lt;p&gt; &lt;sup&gt;3&lt;/sup&gt; For {@code &apos;o&apos;}, {@code &apos;x&apos;}, and {@code &apos;X&apos;}conversions only.
                  &lt;p&gt; &lt;sup&gt;4&lt;/sup&gt; For {@code &apos;d&apos;}, {@code &apos;o&apos;}, {@code &apos;x&apos;}, and{@code &apos;X&apos;} conversions applied to {@link java.math.BigInteger BigInteger}or {@code &apos;d&apos;} applied to {@code byte}, {@link Byte}, {@code short}, {@link Short}, {@code int} and {@link Integer}, {@code long}, and {@link Long}.
                  &lt;p&gt; &lt;sup&gt;5&lt;/sup&gt; For {@code &apos;e&apos;}, {@code &apos;E&apos;}, {@code &apos;f&apos;},{@code &apos;g&apos;}, and {@code &apos;G&apos;} conversions only.
                  &lt;p&gt; Any characters not explicitly defined as flags are illegal and are
                  reserved for future extensions.
                  &lt;h4&gt; Width &lt;/h4&gt;
                  &lt;p&gt; The width is the minimum number of characters to be written to the
                  output.  For the line separator conversion, width is not applicable; if it
                  is provided, an exception will be thrown.
                  &lt;h4&gt; Precision &lt;/h4&gt;
                  &lt;p&gt; For general argument types, the precision is the maximum number of
                  characters to be written to the output.
                  &lt;p&gt; For the floating-point conversions {@code &apos;e&apos;}, {@code &apos;E&apos;}, and{@code &apos;f&apos;} the precision is the number of digits after the decimal
                  separator.  If the conversion is {@code &apos;g&apos;} or {@code &apos;G&apos;}, then the
                  precision is the total number of digits in the resulting magnitude after
                  rounding.  If the conversion is {@code &apos;a&apos;} or {@code &apos;A&apos;}, then the
                  precision must not be specified.
                  &lt;p&gt; For character, integral, and date/time argument types and the percent
                  and line separator conversions, the precision is not applicable; if a
                  precision is provided, an exception will be thrown.
                  &lt;h4&gt; Argument Index &lt;/h4&gt;
                  &lt;p&gt; The argument index is a decimal integer indicating the position of the
                  argument in the argument list.  The first argument is referenced by
                  &quot;{@code 1$}&quot;, the second by &quot;{@code 2$}&quot;, etc.
                  &lt;p&gt; Another way to reference arguments by position is to use the{@code &apos;&lt;&apos;} (&lt;tt&gt;&apos;&amp;#92;u003c&apos;&lt;/tt&gt;) flag, which causes the argument for
                  the previous format specifier to be re-used.  For example, the following two
                  statements would produce identical strings:
                  &lt;blockquote&gt;&lt;pre&gt;
                  Calendar c = ...;
                  String s1 = String.format(&quot;Duke&apos;s Birthday: %1$tm %1$te,%1$tY&quot;, c);
                  String s2 = String.format(&quot;Duke&apos;s Birthday: %1$tm %&amp;lt;te,%&amp;lt;tY&quot;, c);
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;hr&gt;
                  &lt;h3&gt;&lt;a name=&quot;detail&quot;&gt;Details&lt;/a&gt;&lt;/h3&gt;
                  &lt;p&gt; This section is intended to provide behavioral details for formatting,
                  including conditions and exceptions, supported data types, localization, and
                  interactions between flags, conversions, and data types.  For an overview of
                  formatting concepts, refer to the &lt;a href=&quot;#summary&quot;&gt;Summary&lt;/a&gt;
                  &lt;p&gt; Any characters not explicitly defined as conversions, date/time
                  conversion suffixes, or flags are illegal and are reserved for
                  future extensions.  Use of such a character in a format string will
                  cause an {@link UnknownFormatConversionException} or {@link UnknownFormatFlagsException} to be thrown.
                  &lt;p&gt; If the format specifier contains a width or precision with an invalid
                  value or which is otherwise unsupported, then a {@link IllegalFormatWidthException} or {@link IllegalFormatPrecisionException}respectively will be thrown.
                  &lt;p&gt; If a format specifier contains a conversion character that is not
                  applicable to the corresponding argument, then an {@link IllegalFormatConversionException} will be thrown.
                  &lt;p&gt; All specified exceptions may be thrown by any of the {@code format}methods of {@code Formatter} as well as by any {@code format} convenience
                  methods such as {@link String#format(String,Object) String.format} and{@link java.io.PrintStream#printf(String,Object) PrintStream.printf}.
                  &lt;p&gt; Conversions denoted by an upper-case character (i.e. {@code &apos;B&apos;},{@code &apos;H&apos;}, {@code &apos;S&apos;}, {@code &apos;C&apos;}, {@code &apos;X&apos;}, {@code &apos;E&apos;},{@code &apos;G&apos;}, {@code &apos;A&apos;}, and {@code &apos;T&apos;}) are the same as those for the
                  corresponding lower-case conversion characters except that the result is
                  converted to upper case according to the rules of the prevailing {@link java.util.Locale Locale}.  The result is equivalent to the following
                  invocation of {@link String#toUpperCase()}&lt;pre&gt;
                  out.toUpperCase() &lt;/pre&gt;
                  &lt;h4&gt;&lt;a name=&quot;dgen&quot;&gt;General&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt; The following general conversions may be applied to any argument type:
                  &lt;table cellpadding=5 summary=&quot;dgConv&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;b&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0062&apos;&lt;/tt&gt;
                  &lt;td&gt; Produces either &quot;{@code true}&quot; or &quot;{@code false}&quot; as returned by{@link Boolean#toString(boolean)}.
                  &lt;p&gt; If the argument is {@code null}, then the result is
                  &quot;{@code false}&quot;.  If the argument is a {@code boolean} or {@link Boolean}, then the result is the string returned by {@link String#valueOf(boolean) String.valueOf()}.  Otherwise, the result is
                  &quot;{@code true}&quot;.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given, then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;B&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0042&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;b&apos;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;h&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0068&apos;&lt;/tt&gt;
                  &lt;td&gt; Produces a string representing the hash code value of the object.
                  &lt;p&gt; If the argument, &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the
                  result is &quot;{@code null}&quot;.  Otherwise, the result is obtained
                  by invoking {@code Integer.toHexString(arg.hashCode())}.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given, then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;H&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0048&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;h&apos;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;s&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0073&apos;&lt;/tt&gt;
                  &lt;td&gt; Produces a string.
                  &lt;p&gt; If the argument is {@code null}, then the result is
                  &quot;{@code null}&quot;.  If the argument implements {@link Formattable}, then
                  its {@link Formattable#formatTo formatTo} method is invoked.
                  Otherwise, the result is obtained by invoking the argument&apos;s{@code toString()} method.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given and the argument is not a {@link Formattable} , then a {@link FormatFlagsConversionMismatchException}will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;S&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0053&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;s&apos;}.
                  &lt;/table&gt;
                  &lt;p&gt; The following &lt;a name=&quot;dFlags&quot;&gt;flags&lt;/a&gt; apply to general conversions:
                  &lt;table cellpadding=5 summary=&quot;dFlags&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;-&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u002d&apos;&lt;/tt&gt;
                  &lt;td&gt; Left justifies the output.  Spaces (&lt;tt&gt;&apos;&amp;#92;u0020&apos;&lt;/tt&gt;) will be
                  added at the end of the converted value as required to fill the minimum
                  width of the field.  If the width is not provided, then a {@link MissingFormatWidthException} will be thrown.  If this flag is not given
                  then the output will be right-justified.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;#&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0023&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output use an alternate form.  The definition of the
                  form is specified by the conversion.
                  &lt;/table&gt;
                  &lt;p&gt; The &lt;a name=&quot;genWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters to
                  be written to the
                  output.  If the length of the converted value is less than the width then
                  the output will be padded by &lt;tt&gt;&apos;&amp;nbsp;&amp;nbsp;&apos;&lt;/tt&gt; (&lt;tt&gt;&apos;&amp;#92;u0020&apos;&lt;/tt&gt;)
                  until the total number of characters equals the width.  The padding is on
                  the left by default.  If the {@code &apos;-&apos;} flag is given, then the padding
                  will be on the right.  If the width is not specified then there is no
                  minimum.
                  &lt;p&gt; The precision is the maximum number of characters to be written to the
                  output.  The precision is applied before the width, thus the output will be
                  truncated to {@code precision} characters even if the width is greater than
                  the precision.  If the precision is not specified then there is no explicit
                  limit on the number of characters.
                  &lt;h4&gt;&lt;a name=&quot;dchar&quot;&gt;Character&lt;/a&gt;&lt;/h4&gt;
                  This conversion may be applied to {@code char} and {@link Character}.  It
                  may also be applied to the types {@code byte}, {@link Byte},{@code short}, and {@link Short}, {@code int} and {@link Integer} when{@link Character#isValidCodePoint} returns {@code true}.  If it returns{@code false} then an {@link IllegalFormatCodePointException} will be
                  thrown.
                  &lt;table cellpadding=5 summary=&quot;charConv&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;c&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0063&apos;&lt;/tt&gt;
                  &lt;td&gt; Formats the argument as a Unicode character as described in &lt;a
                  href=&quot;../lang/Character.html#unicode&quot;&gt;Unicode Character
                  Representation&lt;/a&gt;.  This may be more than one 16-bit {@code char} in
                  the case where the argument represents a supplementary character.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given, then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;C&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0043&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;c&apos;}.
                  &lt;/table&gt;
                  &lt;p&gt; The {@code &apos;-&apos;} flag defined for &lt;a href=&quot;#dFlags&quot;&gt;General
                  conversions&lt;/a&gt; applies.  If the {@code &apos;#&apos;} flag is given, then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;p&gt; The width is defined as for &lt;a href=&quot;#genWidth&quot;&gt;General conversions&lt;/a&gt;.
                  &lt;p&gt; The precision is not applicable.  If the precision is specified then an{@link IllegalFormatPrecisionException} will be thrown.
                  &lt;h4&gt;&lt;a name=&quot;dnum&quot;&gt;Numeric&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt; Numeric conversions are divided into the following categories:
                  &lt;ol&gt;
                  &lt;li&gt; &lt;a href=&quot;#dnint&quot;&gt;&lt;b&gt;Byte, Short, Integer, and Long&lt;/b&gt;&lt;/a&gt;
                  &lt;li&gt; &lt;a href=&quot;#dnbint&quot;&gt;&lt;b&gt;BigInteger&lt;/b&gt;&lt;/a&gt;
                  &lt;li&gt; &lt;a href=&quot;#dndec&quot;&gt;&lt;b&gt;Float and Double&lt;/b&gt;&lt;/a&gt;
                  &lt;li&gt; &lt;a href=&quot;#dnbdec&quot;&gt;&lt;b&gt;BigDecimal&lt;/b&gt;&lt;/a&gt;
                  &lt;/ol&gt;
                  &lt;p&gt; Numeric types will be formatted according to the following algorithm:
                  &lt;p&gt;&lt;b&gt;&lt;a name=&quot;l10n algorithm&quot;&gt; Number Localization Algorithm&lt;/a&gt;&lt;/b&gt;
                  &lt;p&gt; After digits are obtained for the integer part, fractional part, and
                  exponent (as appropriate for the data type), the following transformation
                  is applied:
                  &lt;ol&gt;
                  &lt;li&gt; Each digit character &lt;i&gt;d&lt;/i&gt; in the string is replaced by a
                  locale-specific digit computed relative to the current locale&apos;s{@linkplain java.text.DecimalFormatSymbols#getZeroDigit() zero digit}&lt;i&gt;z&lt;/i&gt;; that is &lt;i&gt;d&amp;nbsp;-&amp;nbsp;&lt;/i&gt; {@code &apos;0&apos;}&lt;i&gt;&amp;nbsp;+&amp;nbsp;z&lt;/i&gt;.
                  &lt;li&gt; If a decimal separator is present, a locale-specific {@linkplain java.text.DecimalFormatSymbols#getDecimalSeparator decimal separator} is
                  substituted.
                  &lt;li&gt; If the {@code &apos;,&apos;} (&lt;tt&gt;&apos;&amp;#92;u002c&apos;&lt;/tt&gt;)
                  &lt;a name=&quot;l10n group&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific {@linkplain java.text.DecimalFormatSymbols#getGroupingSeparator grouping separator} is
                  inserted by scanning the integer part of the string from least significant
                  to most significant digits and inserting a separator at intervals defined by
                  the locale&apos;s {@linkplain java.text.DecimalFormat#getGroupingSize() grouping
                  size}.
                  &lt;li&gt; If the {@code &apos;0&apos;} flag is given, then the locale-specific {@linkplain java.text.DecimalFormatSymbols#getZeroDigit() zero digits} are inserted
                  after the sign character, if any, and before the first non-zero digit, until
                  the length of the string is equal to the requested field width.
                  &lt;li&gt; If the value is negative and the {@code &apos;(&apos;} flag is given, then a{@code &apos;(&apos;} (&lt;tt&gt;&apos;&amp;#92;u0028&apos;&lt;/tt&gt;) is prepended and a {@code &apos;)&apos;}(&lt;tt&gt;&apos;&amp;#92;u0029&apos;&lt;/tt&gt;) is appended.
                  &lt;li&gt; If the value is negative (or floating-point negative zero) and{@code &apos;(&apos;} flag is not given, then a {@code &apos;-&apos;} (&lt;tt&gt;&apos;&amp;#92;u002d&apos;&lt;/tt&gt;)
                  is prepended.
                  &lt;li&gt; If the {@code &apos;+&apos;} flag is given and the value is positive or zero (or
                  floating-point positive zero), then a {@code &apos;+&apos;} (&lt;tt&gt;&apos;&amp;#92;u002b&apos;&lt;/tt&gt;)
                  will be prepended.
                  &lt;/ol&gt;
                  &lt;p&gt; If the value is NaN or positive infinity the literal strings &quot;NaN&quot; or
                  &quot;Infinity&quot; respectively, will be output.  If the value is negative infinity,
                  then the output will be &quot;(Infinity)&quot; if the {@code &apos;(&apos;} flag is given
                  otherwise the output will be &quot;-Infinity&quot;.  These values are not localized.
                  &lt;p&gt;&lt;a name=&quot;dnint&quot;&gt;&lt;b&gt; Byte, Short, Integer, and Long &lt;/b&gt;&lt;/a&gt;
                  &lt;p&gt; The following conversions may be applied to {@code byte}, {@link Byte},{@code short}, {@link Short}, {@code int} and {@link Integer},{@code long}, and {@link Long}.
                  &lt;table cellpadding=5 summary=&quot;IntConv&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;d&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0054&apos;&lt;/tt&gt;
                  &lt;td&gt; Formats the argument as a decimal integer. The &lt;a
                  href=&quot;#l10n algorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
                  &lt;p&gt; If the {@code &apos;0&apos;} flag is given and the value is negative, then
                  the zero padding will occur after the sign.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;o&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u006f&apos;&lt;/tt&gt;
                  &lt;td&gt; Formats the argument as an integer in base eight.  No localization
                  is applied.
                  &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be an unsigned value
                  generated by adding 2&lt;sup&gt;n&lt;/sup&gt; to the value where {@code n} is the
                  number of bits in the type as returned by the static {@code SIZE} field
                  in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},{@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}classes as appropriate.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given then the output will always begin
                  with the radix indicator {@code &apos;0&apos;}.
                  &lt;p&gt; If the {@code &apos;0&apos;} flag is given then the output will be padded
                  with leading zeros to the field width following any indication of sign.
                  &lt;p&gt; If {@code &apos;(&apos;}, {@code &apos;+&apos;}, &apos;&amp;nbsp&amp;nbsp;&apos;, or {@code &apos;,&apos;} flags
                  are given then a {@link FormatFlagsConversionMismatchException} will be
                  thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;x&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0078&apos;&lt;/tt&gt;
                  &lt;td&gt; Formats the argument as an integer in base sixteen. No
                  localization is applied.
                  &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be an unsigned value
                  generated by adding 2&lt;sup&gt;n&lt;/sup&gt; to the value where {@code n} is the
                  number of bits in the type as returned by the static {@code SIZE} field
                  in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},{@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}classes as appropriate.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given then the output will always begin
                  with the radix indicator {@code &quot;0x&quot;}.
                  &lt;p&gt; If the {@code &apos;0&apos;} flag is given then the output will be padded to
                  the field width with leading zeros after the radix indicator or sign (if
                  present).
                  &lt;p&gt; If {@code &apos;(&apos;}, &lt;tt&gt;&apos;&amp;nbsp;&amp;nbsp;&apos;&lt;/tt&gt;, {@code &apos;+&apos;}, or{@code &apos;,&apos;} flags are given then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;X&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0058&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;x&apos;}.  The entire string
                  representing the number will be converted to {@linkplain String#toUpperCase upper case} including the {@code &apos;x&apos;} (if any) and
                  all hexadecimal digits {@code &apos;a&apos;} - {@code &apos;f&apos;}(&lt;tt&gt;&apos;&amp;#92;u0061&apos;&lt;/tt&gt; -  &lt;tt&gt;&apos;&amp;#92;u0066&apos;&lt;/tt&gt;).
                  &lt;/table&gt;
                  &lt;p&gt; If the conversion is {@code &apos;o&apos;}, {@code &apos;x&apos;}, or {@code &apos;X&apos;} and
                  both the {@code &apos;#&apos;} and the {@code &apos;0&apos;} flags are given, then result will
                  contain the radix indicator ({@code &apos;0&apos;} for octal and {@code &quot;0x&quot;} or{@code &quot;0X&quot;} for hexadecimal), some number of zeros (based on the width),
                  and the value.
                  &lt;p&gt; If the {@code &apos;-&apos;} flag is not given, then the space padding will occur
                  before the sign.
                  &lt;p&gt; The following &lt;a name=&quot;intFlags&quot;&gt;flags&lt;/a&gt; apply to numeric integral
                  conversions:
                  &lt;table cellpadding=5 summary=&quot;intFlags&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;+&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u002b&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to include a positive sign for all positive
                  numbers.  If this flag is not given then only negative values will
                  include a sign.
                  &lt;p&gt; If both the {@code &apos;+&apos;} and &lt;tt&gt;&apos;&amp;nbsp;&amp;nbsp;&apos;&lt;/tt&gt; flags are given
                  then an {@link IllegalFormatFlagsException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;nbsp;&amp;nbsp;&apos;&lt;/tt&gt;
                  &lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0020&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to include a single extra space
                  (&lt;tt&gt;&apos;&amp;#92;u0020&apos;&lt;/tt&gt;) for non-negative values.
                  &lt;p&gt; If both the {@code &apos;+&apos;} and &lt;tt&gt;&apos;&amp;nbsp;&amp;nbsp;&apos;&lt;/tt&gt; flags are given
                  then an {@link IllegalFormatFlagsException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;0&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0030&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be padded with leading {@linkplain java.text.DecimalFormatSymbols#getZeroDigit zeros} to the minimum field
                  width following any sign or radix indicator except when converting NaN
                  or infinity.  If the width is not provided, then a {@link MissingFormatWidthException} will be thrown.
                  &lt;p&gt; If both the {@code &apos;-&apos;} and {@code &apos;0&apos;} flags are given then an{@link IllegalFormatFlagsException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;,&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u002c&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to include the locale-specific {@linkplain java.text.DecimalFormatSymbols#getGroupingSeparator group separators} as
                  described in the &lt;a href=&quot;#l10n group&quot;&gt;&quot;group&quot; section&lt;/a&gt; of the
                  localization algorithm.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;(&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0028&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to prepend a {@code &apos;(&apos;}(&lt;tt&gt;&apos;&amp;#92;u0028&apos;&lt;/tt&gt;) and append a {@code &apos;)&apos;}(&lt;tt&gt;&apos;&amp;#92;u0029&apos;&lt;/tt&gt;) to negative values.
                  &lt;/table&gt;
                  &lt;p&gt; If no &lt;a name=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is
                  as follows:
                  &lt;ul&gt;
                  &lt;li&gt; The output is right-justified within the {@code width}&lt;li&gt; Negative numbers begin with a {@code &apos;-&apos;} (&lt;tt&gt;&apos;&amp;#92;u002d&apos;&lt;/tt&gt;)
                  &lt;li&gt; Positive numbers and zero do not include a sign or extra leading
                  space
                  &lt;li&gt; No grouping separators are included
                  &lt;/ul&gt;
                  &lt;p&gt; The &lt;a name=&quot;intWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters to
                  be written to the output.  This includes any signs, digits, grouping
                  separators, radix indicator, and parentheses.  If the length of the
                  converted value is less than the width then the output will be padded by
                  spaces (&lt;tt&gt;&apos;&amp;#92;u0020&apos;&lt;/tt&gt;) until the total number of characters equals
                  width.  The padding is on the left by default.  If {@code &apos;-&apos;} flag is
                  given then the padding will be on the right.  If width is not specified then
                  there is no minimum.
                  &lt;p&gt; The precision is not applicable.  If precision is specified then an{@link IllegalFormatPrecisionException} will be thrown.
                  &lt;p&gt;&lt;a name=&quot;dnbint&quot;&gt;&lt;b&gt; BigInteger &lt;/b&gt;&lt;/a&gt;
                  &lt;p&gt; The following conversions may be applied to {@link java.math.BigInteger}.
                  &lt;table cellpadding=5 summary=&quot;BIntConv&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;d&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0054&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted as a decimal integer. The &lt;a
                  href=&quot;#l10n algorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;o&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u006f&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted as an integer in base eight.
                  No localization is applied.
                  &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be a signed value
                  beginning with {@code &apos;-&apos;} (&lt;tt&gt;&apos;&amp;#92;u002d&apos;&lt;/tt&gt;).  Signed output is
                  allowed for this type because unlike the primitive types it is not
                  possible to create an unsigned equivalent without assuming an explicit
                  data-type size.
                  &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or zero and the {@code &apos;+&apos;} flag is given
                  then the result will begin with {@code &apos;+&apos;} (&lt;tt&gt;&apos;&amp;#92;u002b&apos;&lt;/tt&gt;).
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given then the output will always begin
                  with {@code &apos;0&apos;} prefix.
                  &lt;p&gt; If the {@code &apos;0&apos;} flag is given then the output will be padded
                  with leading zeros to the field width following any indication of sign.
                  &lt;p&gt; If the {@code &apos;,&apos;} flag is given then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;x&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0078&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted as an integer in base
                  sixteen.  No localization is applied.
                  &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be a signed value
                  beginning with {@code &apos;-&apos;} (&lt;tt&gt;&apos;&amp;#92;u002d&apos;&lt;/tt&gt;).  Signed output is
                  allowed for this type because unlike the primitive types it is not
                  possible to create an unsigned equivalent without assuming an explicit
                  data-type size.
                  &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or zero and the {@code &apos;+&apos;} flag is given
                  then the result will begin with {@code &apos;+&apos;} (&lt;tt&gt;&apos;&amp;#92;u002b&apos;&lt;/tt&gt;).
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given then the output will always begin
                  with the radix indicator {@code &quot;0x&quot;}.
                  &lt;p&gt; If the {@code &apos;0&apos;} flag is given then the output will be padded to
                  the field width with leading zeros after the radix indicator or sign (if
                  present).
                  &lt;p&gt; If the {@code &apos;,&apos;} flag is given then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;X&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0058&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;x&apos;}.  The entire string
                  representing the number will be converted to {@linkplain String#toUpperCase upper case} including the {@code &apos;x&apos;} (if any) and
                  all hexadecimal digits {@code &apos;a&apos;} - {@code &apos;f&apos;}(&lt;tt&gt;&apos;&amp;#92;u0061&apos;&lt;/tt&gt; - &lt;tt&gt;&apos;&amp;#92;u0066&apos;&lt;/tt&gt;).
                  &lt;/table&gt;
                  &lt;p&gt; If the conversion is {@code &apos;o&apos;}, {@code &apos;x&apos;}, or {@code &apos;X&apos;} and
                  both the {@code &apos;#&apos;} and the {@code &apos;0&apos;} flags are given, then result will
                  contain the base indicator ({@code &apos;0&apos;} for octal and {@code &quot;0x&quot;} or{@code &quot;0X&quot;} for hexadecimal), some number of zeros (based on the width),
                  and the value.
                  &lt;p&gt; If the {@code &apos;0&apos;} flag is given and the value is negative, then the
                  zero padding will occur after the sign.
                  &lt;p&gt; If the {@code &apos;-&apos;} flag is not given, then the space padding will occur
                  before the sign.
                  &lt;p&gt; All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
                  Long apply.  The &lt;a href=&quot;#intdFlags&quot;&gt;default behavior&lt;/a&gt; when no flags are
                  given is the same as for Byte, Short, Integer, and Long.
                  &lt;p&gt; The specification of &lt;a href=&quot;#intWidth&quot;&gt;width&lt;/a&gt; is the same as
                  defined for Byte, Short, Integer, and Long.
                  &lt;p&gt; The precision is not applicable.  If precision is specified then an{@link IllegalFormatPrecisionException} will be thrown.
                  &lt;p&gt;&lt;a name=&quot;dndec&quot;&gt;&lt;b&gt; Float and Double&lt;/b&gt;&lt;/a&gt;
                  &lt;p&gt; The following conversions may be applied to {@code float}, {@link Float}, {@code double} and {@link Double}.
                  &lt;table cellpadding=5 summary=&quot;floatConv&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;e&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0065&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted using &lt;a
                  name=&quot;scientific&quot;&gt;computerized scientific notation&lt;/a&gt;.  The &lt;a
                  href=&quot;#l10n algorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
                  &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
                  &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is NaN or infinite, the literal strings &quot;NaN&quot; or
                  &quot;Infinity&quot;, respectively, will be output.  These values are not
                  localized.
                  &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is positive-zero or negative-zero, then the exponent
                  will be {@code &quot;+00&quot;}.
                  &lt;p&gt; Otherwise, the result is a string that represents the sign and
                  magnitude (absolute value) of the argument.  The formatting of the sign
                  is described in the &lt;a href=&quot;#l10n algorithm&quot;&gt;localization
                  algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
                  value.
                  &lt;p&gt; Let &lt;i&gt;n&lt;/i&gt; be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;
                  &amp;lt;= &lt;i&gt;m&lt;/i&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
                  mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so
                  that 1 &amp;lt;= &lt;i&gt;a&lt;/i&gt; &amp;lt; 10. The magnitude is then represented as the
                  integer part of &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by the
                  decimal separator followed by decimal digits representing the fractional
                  part of &lt;i&gt;a&lt;/i&gt;, followed by the exponent symbol {@code &apos;e&apos;}(&lt;tt&gt;&apos;&amp;#92;u0065&apos;&lt;/tt&gt;), followed by the sign of the exponent, followed
                  by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
                  method {@link Long#toString(long,int)}, and zero-padded to include at
                  least two digits.
                  &lt;p&gt; The number of digits in the result for the fractional part of
                  &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
                  specified then the default value is {@code 6}. If the precision is less
                  than the number of digits which would appear after the decimal point in
                  the string returned by {@link Float#toString(float)} or {@link Double#toString(double)} respectively, then the value will be rounded
                  using the {@linkplain java.math.BigDecimal#ROUND_HALF_UP round half up
                  algorithm}.  Otherwise, zeros may be appended to reach the precision.
                  For a canonical representation of the value, use {@link Float#toString(float)} or {@link Double#toString(double)} as
                  appropriate.
                  &lt;p&gt;If the {@code &apos;,&apos;} flag is given, then an {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;E&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0045&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;e&apos;}.  The exponent symbol
                  will be {@code &apos;E&apos;} (&lt;tt&gt;&apos;&amp;#92;u0045&apos;&lt;/tt&gt;).
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;g&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0067&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted in general scientific notation
                  as described below. The &lt;a href=&quot;#l10n algorithm&quot;&gt;localization
                  algorithm&lt;/a&gt; is applied.
                  &lt;p&gt; After rounding for the precision, the formatting of the resulting
                  magnitude &lt;i&gt;m&lt;/i&gt; depends on its value.
                  &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-4&lt;/sup&gt; but less
                  than 10&lt;sup&gt;precision&lt;/sup&gt; then it is represented in &lt;i&gt;&lt;a
                  href=&quot;#decimal&quot;&gt;decimal format&lt;/a&gt;&lt;/i&gt;.
                  &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-4&lt;/sup&gt; or greater than or equal to
                  10&lt;sup&gt;precision&lt;/sup&gt;, then it is represented in &lt;i&gt;&lt;a
                  href=&quot;#scientific&quot;&gt;computerized scientific notation&lt;/a&gt;&lt;/i&gt;.
                  &lt;p&gt; The total number of significant digits in &lt;i&gt;m&lt;/i&gt; is equal to the
                  precision.  If the precision is not specified, then the default value is{@code 6}.  If the precision is {@code 0}, then it is taken to be{@code 1}.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given then an {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;G&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0047&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;g&apos;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;f&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0066&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted using &lt;a name=&quot;decimal&quot;&gt;decimal
                  format&lt;/a&gt;.  The &lt;a href=&quot;#l10n algorithm&quot;&gt;localization algorithm&lt;/a&gt; is
                  applied.
                  &lt;p&gt; The result is a string that represents the sign and magnitude
                  (absolute value) of the argument.  The formatting of the sign is
                  described in the &lt;a href=&quot;#l10n algorithm&quot;&gt;localization
                  algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
                  value.
                  &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; NaN or infinite, the literal strings &quot;NaN&quot; or
                  &quot;Infinity&quot;, respectively, will be output.  These values are not
                  localized.
                  &lt;p&gt; The magnitude is formatted as the integer part of &lt;i&gt;m&lt;/i&gt;, with no
                  leading zeroes, followed by the decimal separator followed by one or
                  more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
                  &lt;p&gt; The number of digits in the result for the fractional part of
                  &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
                  specified then the default value is {@code 6}. If the precision is less
                  than the number of digits which would appear after the decimal point in
                  the string returned by {@link Float#toString(float)} or {@link Double#toString(double)} respectively, then the value will be rounded
                  using the {@linkplain java.math.BigDecimal#ROUND_HALF_UP round half up
                  algorithm}.  Otherwise, zeros may be appended to reach the precision.
                  For a canonical representation of the value, use {@link Float#toString(float)} or {@link Double#toString(double)} as
                  appropriate.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;a&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0061&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted in hexadecimal exponential
                  form.  No localization is applied.
                  &lt;p&gt; The result is a string that represents the sign and magnitude
                  (absolute value) of the argument &lt;i&gt;x&lt;/i&gt;.
                  &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative or a negative-zero value then the result
                  will begin with {@code &apos;-&apos;} (&lt;tt&gt;&apos;&amp;#92;u002d&apos;&lt;/tt&gt;).
                  &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or a positive-zero value and the{@code &apos;+&apos;} flag is given then the result will begin with {@code &apos;+&apos;}(&lt;tt&gt;&apos;&amp;#92;u002b&apos;&lt;/tt&gt;).
                  &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
                  &lt;ul&gt;
                  &lt;li&gt; If the value is NaN or infinite, the literal strings &quot;NaN&quot; or
                  &quot;Infinity&quot;, respectively, will be output.
                  &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is zero then it is represented by the string{@code &quot;0x0.0p0&quot;}.
                  &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a normalized
                  representation then substrings are used to represent the significand and
                  exponent fields.  The significand is represented by the characters{@code &quot;0x1.&quot;} followed by the hexadecimal representation of the rest
                  of the significand as a fraction.  The exponent is represented by{@code &apos;p&apos;} (&lt;tt&gt;&apos;&amp;#92;u0070&apos;&lt;/tt&gt;) followed by a decimal string of the
                  unbiased exponent as if produced by invoking {@link Integer#toString(int) Integer.toString} on the exponent value.
                  &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a subnormal
                  representation then the significand is represented by the characters{@code &apos;0x0.&apos;} followed by the hexadecimal representation of the rest
                  of the significand as a fraction.  The exponent is represented by{@code &apos;p-1022&apos;}.  Note that there must be at least one nonzero digit
                  in a subnormal significand.
                  &lt;/ul&gt;
                  &lt;p&gt; If the {@code &apos;(&apos;} or {@code &apos;,&apos;} flags are given, then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;A&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0041&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;a&apos;}.  The entire string
                  representing the number will be converted to upper case including the{@code &apos;x&apos;} (&lt;tt&gt;&apos;&amp;#92;u0078&apos;&lt;/tt&gt;) and {@code &apos;p&apos;}(&lt;tt&gt;&apos;&amp;#92;u0070&apos;&lt;/tt&gt; and all hexadecimal digits {@code &apos;a&apos;} -{@code &apos;f&apos;} (&lt;tt&gt;&apos;&amp;#92;u0061&apos;&lt;/tt&gt; - &lt;tt&gt;&apos;&amp;#92;u0066&apos;&lt;/tt&gt;).
                  &lt;/table&gt;
                  &lt;p&gt; All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
                  Long apply.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given, then the decimal separator will
                  always be present.
                  &lt;p&gt; If no &lt;a name=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting
                  is as follows:
                  &lt;ul&gt;
                  &lt;li&gt; The output is right-justified within the {@code width}&lt;li&gt; Negative numbers begin with a {@code &apos;-&apos;}&lt;li&gt; Positive numbers and positive zero do not include a sign or extra
                  leading space
                  &lt;li&gt; No grouping separators are included
                  &lt;li&gt; The decimal separator will only appear if a digit follows it
                  &lt;/ul&gt;
                  &lt;p&gt; The &lt;a name=&quot;floatDWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters
                  to be written to the output.  This includes any signs, digits, grouping
                  separators, decimal separators, exponential symbol, radix indicator,
                  parentheses, and strings representing infinity and NaN as applicable.  If
                  the length of the converted value is less than the width then the output
                  will be padded by spaces (&lt;tt&gt;&apos;&amp;#92;u0020&apos;&lt;/tt&gt;) until the total number of
                  characters equals width.  The padding is on the left by default.  If the{@code &apos;-&apos;} flag is given then the padding will be on the right.  If width
                  is not specified then there is no minimum.
                  &lt;p&gt; If the &lt;a name=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is {@code &apos;e&apos;},{@code &apos;E&apos;} or {@code &apos;f&apos;}, then the precision is the number of digits
                  after the decimal separator.  If the precision is not specified, then it is
                  assumed to be {@code 6}.
                  &lt;p&gt; If the conversion is {@code &apos;g&apos;} or {@code &apos;G&apos;}, then the precision is
                  the total number of significant digits in the resulting magnitude after
                  rounding.  If the precision is not specified, then the default value is{@code 6}.  If the precision is {@code 0}, then it is taken to be{@code 1}.
                  &lt;p&gt; If the conversion is {@code &apos;a&apos;} or {@code &apos;A&apos;}, then the precision
                  is the number of hexadecimal digits after the decimal separator.  If the
                  precision is not provided, then all of the digits as returned by {@link Double#toHexString(double)} will be output.
                  &lt;p&gt;&lt;a name=&quot;dnbdec&quot;&gt;&lt;b&gt; BigDecimal &lt;/b&gt;&lt;/a&gt;
                  &lt;p&gt; The following conversions may be applied {@link java.math.BigDecimalBigDecimal}.
                  &lt;table cellpadding=5 summary=&quot;floatConv&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;e&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0065&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted using &lt;a
                  name=&quot;bscientific&quot;&gt;computerized scientific notation&lt;/a&gt;.  The &lt;a
                  href=&quot;#l10n algorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
                  &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
                  &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is positive-zero or negative-zero, then the exponent
                  will be {@code &quot;+00&quot;}.
                  &lt;p&gt; Otherwise, the result is a string that represents the sign and
                  magnitude (absolute value) of the argument.  The formatting of the sign
                  is described in the &lt;a href=&quot;#l10n algorithm&quot;&gt;localization
                  algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
                  value.
                  &lt;p&gt; Let &lt;i&gt;n&lt;/i&gt; be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;
                  &amp;lt;= &lt;i&gt;m&lt;/i&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
                  mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so
                  that 1 &amp;lt;= &lt;i&gt;a&lt;/i&gt; &amp;lt; 10. The magnitude is then represented as the
                  integer part of &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by the
                  decimal separator followed by decimal digits representing the fractional
                  part of &lt;i&gt;a&lt;/i&gt;, followed by the exponent symbol {@code &apos;e&apos;}(&lt;tt&gt;&apos;&amp;#92;u0065&apos;&lt;/tt&gt;), followed by the sign of the exponent, followed
                  by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
                  method {@link Long#toString(long,int)}, and zero-padded to include at
                  least two digits.
                  &lt;p&gt; The number of digits in the result for the fractional part of
                  &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
                  specified then the default value is {@code 6}.  If the precision is
                  less than the number of digits to the right of the decimal point then
                  the value will be rounded using the{@linkplain java.math.BigDecimal#ROUND_HALF_UP round half up
                  algorithm}.  Otherwise, zeros may be appended to reach the precision.
                  For a canonical representation of the value, use {@link BigDecimal#toString()}.
                  &lt;p&gt; If the {@code &apos;,&apos;} flag is given, then an {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;E&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0045&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;e&apos;}.  The exponent symbol
                  will be {@code &apos;E&apos;} (&lt;tt&gt;&apos;&amp;#92;u0045&apos;&lt;/tt&gt;).
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;g&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0067&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted in general scientific notation
                  as described below. The &lt;a href=&quot;#l10n algorithm&quot;&gt;localization
                  algorithm&lt;/a&gt; is applied.
                  &lt;p&gt; After rounding for the precision, the formatting of the resulting
                  magnitude &lt;i&gt;m&lt;/i&gt; depends on its value.
                  &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-4&lt;/sup&gt; but less
                  than 10&lt;sup&gt;precision&lt;/sup&gt; then it is represented in &lt;i&gt;&lt;a
                  href=&quot;#bdecimal&quot;&gt;decimal format&lt;/a&gt;&lt;/i&gt;.
                  &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-4&lt;/sup&gt; or greater than or equal to
                  10&lt;sup&gt;precision&lt;/sup&gt;, then it is represented in &lt;i&gt;&lt;a
                  href=&quot;#bscientific&quot;&gt;computerized scientific notation&lt;/a&gt;&lt;/i&gt;.
                  &lt;p&gt; The total number of significant digits in &lt;i&gt;m&lt;/i&gt; is equal to the
                  precision.  If the precision is not specified, then the default value is{@code 6}.  If the precision is {@code 0}, then it is taken to be{@code 1}.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given then an {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;G&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0047&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;g&apos;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;f&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0066&apos;&lt;/tt&gt;
                  &lt;td&gt; Requires the output to be formatted using &lt;a name=&quot;bdecimal&quot;&gt;decimal
                  format&lt;/a&gt;.  The &lt;a href=&quot;#l10n algorithm&quot;&gt;localization algorithm&lt;/a&gt; is
                  applied.
                  &lt;p&gt; The result is a string that represents the sign and magnitude
                  (absolute value) of the argument.  The formatting of the sign is
                  described in the &lt;a href=&quot;#l10n algorithm&quot;&gt;localization
                  algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
                  value.
                  &lt;p&gt; The magnitude is formatted as the integer part of &lt;i&gt;m&lt;/i&gt;, with no
                  leading zeroes, followed by the decimal separator followed by one or
                  more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
                  &lt;p&gt; The number of digits in the result for the fractional part of
                  &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision. If the precision is not
                  specified then the default value is {@code 6}.  If the precision is
                  less than the number of digits to the right of the decimal point
                  then the value will be rounded using the{@linkplain java.math.BigDecimal#ROUND_HALF_UP round half up
                  algorithm}.  Otherwise, zeros may be appended to reach the precision.
                  For a canonical representation of the value, use {@link BigDecimal#toString()}.
                  &lt;/table&gt;
                  &lt;p&gt; All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
                  Long apply.
                  &lt;p&gt; If the {@code &apos;#&apos;} flag is given, then the decimal separator will
                  always be present.
                  &lt;p&gt; The &lt;a href=&quot;#floatdFlags&quot;&gt;default behavior&lt;/a&gt; when no flags are
                  given is the same as for Float and Double.
                  &lt;p&gt; The specification of &lt;a href=&quot;#floatDWidth&quot;&gt;width&lt;/a&gt; and &lt;a
                  href=&quot;#floatDPrec&quot;&gt;precision&lt;/a&gt; is the same as defined for Float and
                  Double.
                  &lt;h4&gt;&lt;a name=&quot;ddt&quot;&gt;Date/Time&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt; This conversion may be applied to {@code long}, {@link Long}, {@link Calendar}, and {@link Date}.
                  &lt;table cellpadding=5 summary=&quot;DTConv&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;t&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0074&apos;&lt;/tt&gt;
                  &lt;td&gt; Prefix for date and time conversion characters.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;T&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0054&apos;&lt;/tt&gt;
                  &lt;td&gt; The upper-case variant of {@code &apos;t&apos;}.
                  &lt;/table&gt;
                  &lt;p&gt; The following date and time conversion character suffixes are defined
                  for the {@code &apos;t&apos;} and {@code &apos;T&apos;} conversions.  The types are similar to
                  but not completely identical to those defined by GNU {@code date} and
                  POSIX {@code strftime(3c)}.  Additional conversion types are provided to
                  access Java-specific functionality (e.g. {@code &apos;L&apos;} for milliseconds
                  within the second).
                  &lt;p&gt; The following conversion characters are used for formatting times:
                  &lt;table cellpadding=5 summary=&quot;time&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt; {@code &apos;H&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0048&apos;&lt;/tt&gt;
                  &lt;td&gt; Hour of the day for the 24-hour clock, formatted as two digits with
                  a leading zero as necessary i.e. {@code 00 - 23}. {@code 00}corresponds to midnight.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;I&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0049&apos;&lt;/tt&gt;
                  &lt;td&gt; Hour for the 12-hour clock, formatted as two digits with a leading
                  zero as necessary, i.e.  {@code 01 - 12}.  {@code 01} corresponds to
                  one o&apos;clock (either morning or afternoon).
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;k&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u006b&apos;&lt;/tt&gt;
                  &lt;td&gt; Hour of the day for the 24-hour clock, i.e. {@code 0 - 23}.{@code 0} corresponds to midnight.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;l&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u006c&apos;&lt;/tt&gt;
                  &lt;td&gt; Hour for the 12-hour clock, i.e. {@code 1 - 12}.  {@code 1}corresponds to one o&apos;clock (either morning or afternoon).
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;M&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u004d&apos;&lt;/tt&gt;
                  &lt;td&gt; Minute within the hour formatted as two digits with a leading zero
                  as necessary, i.e.  {@code 00 - 59}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;S&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0053&apos;&lt;/tt&gt;
                  &lt;td&gt; Seconds within the minute, formatted as two digits with a leading
                  zero as necessary, i.e. {@code 00 - 60} (&quot;{@code 60}&quot; is a special
                  value required to support leap seconds).
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;L&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u004c&apos;&lt;/tt&gt;
                  &lt;td&gt; Millisecond within the second formatted as three digits with
                  leading zeros as necessary, i.e. {@code 000 - 999}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;N&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u004e&apos;&lt;/tt&gt;
                  &lt;td&gt; Nanosecond within the second, formatted as nine digits with leading
                  zeros as necessary, i.e. {@code 000000000 - 999999999}.  The precision
                  of this value is limited by the resolution of the underlying operating
                  system or hardware.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;p&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0070&apos;&lt;/tt&gt;
                  &lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
                  in lower case, e.g.&quot;{@code am}&quot; or &quot;{@code pm}&quot;.  Use of the
                  conversion prefix {@code &apos;T&apos;} forces this output to upper case.  (Note
                  that {@code &apos;p&apos;} produces lower-case output.  This is different from
                  GNU {@code date} and POSIX {@code strftime(3c)} which produce
                  upper-case output.)
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;z&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u007a&apos;&lt;/tt&gt;
                  &lt;td&gt; &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC&amp;nbsp;822&lt;/a&gt;
                  style numeric time zone offset from GMT, e.g. {@code -0800}.  This
                  value will be adjusted as necessary for Daylight Saving Time.  For{@code long}, {@link Long}, and {@link Date} the time zone used is
                  the {@linkplain TimeZone#getDefault() default time zone} for this
                  instance of the Java virtual machine.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;Z&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u005a&apos;&lt;/tt&gt;
                  &lt;td&gt; A string representing the abbreviation for the time zone.  This
                  value will be adjusted as necessary for Daylight Saving Time.  For{@code long}, {@link Long}, and {@link Date} the time zone used is
                  the {@linkplain TimeZone#getDefault() default time zone} for this
                  instance of the Java virtual machine.  The Formatter&apos;s locale will
                  supersede the locale of the argument (if any).
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;s&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0073&apos;&lt;/tt&gt;
                  &lt;td&gt; Seconds since the beginning of the epoch starting at 1 January 1970{@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE/1000} to{@code Long.MAX_VALUE/1000}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;Q&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u004f&apos;&lt;/tt&gt;
                  &lt;td&gt; Milliseconds since the beginning of the epoch starting at 1 January
                  1970 {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE} to{@code Long.MAX_VALUE}. The precision of this value is limited by
                  the resolution of the underlying operating system or hardware.
                  &lt;/table&gt;
                  &lt;p&gt; The following conversion characters are used for formatting dates:
                  &lt;table cellpadding=5 summary=&quot;date&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;B&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0042&apos;&lt;/tt&gt;
                  &lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getMonthsfull month name}, e.g. {@code &quot;January&quot;}, {@code &quot;February&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;b&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0062&apos;&lt;/tt&gt;
                  &lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getShortMonths abbreviated month name},
                  e.g. {@code &quot;Jan&quot;}, {@code &quot;Feb&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;h&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0068&apos;&lt;/tt&gt;
                  &lt;td&gt; Same as {@code &apos;b&apos;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;A&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0041&apos;&lt;/tt&gt;
                  &lt;td&gt; Locale-specific full name of the {@linkplain java.text.DateFormatSymbols#getWeekdays day of the week},
                  e.g. {@code &quot;Sunday&quot;}, {@code &quot;Monday&quot;}&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;a&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0061&apos;&lt;/tt&gt;
                  &lt;td&gt; Locale-specific short name of the {@linkplain java.text.DateFormatSymbols#getShortWeekdays day of the week},
                  e.g. {@code &quot;Sun&quot;}, {@code &quot;Mon&quot;}&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;C&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0043&apos;&lt;/tt&gt;
                  &lt;td&gt; Four-digit year divided by {@code 100}, formatted as two digits
                  with leading zero as necessary, i.e. {@code 00 - 99}&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;Y&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0059&apos;&lt;/tt&gt; &lt;td&gt; Year, formatted to at least
                  four digits with leading zeros as necessary, e.g. {@code 0092} equals{@code 92} CE for the Gregorian calendar.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;y&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0079&apos;&lt;/tt&gt;
                  &lt;td&gt; Last two digits of the year, formatted with leading zeros as
                  necessary, i.e. {@code 00 - 99}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;j&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u006a&apos;&lt;/tt&gt;
                  &lt;td&gt; Day of year, formatted as three digits with leading zeros as
                  necessary, e.g. {@code 001 - 366} for the Gregorian calendar.{@code 001} corresponds to the first day of the year.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;m&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u006d&apos;&lt;/tt&gt;
                  &lt;td&gt; Month, formatted as two digits with leading zeros as necessary,
                  i.e. {@code 01 - 13}, where &quot;{@code 01}&quot; is the first month of the
                  year and (&quot;{@code 13}&quot; is a special value required to support lunar
                  calendars).
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;d&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0064&apos;&lt;/tt&gt;
                  &lt;td&gt; Day of month, formatted as two digits with leading zeros as
                  necessary, i.e. {@code 01 - 31}, where &quot;{@code 01}&quot; is the first day
                  of the month.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;e&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0065&apos;&lt;/tt&gt;
                  &lt;td&gt; Day of month, formatted as two digits, i.e. {@code 1 - 31} where
                  &quot;{@code 1}&quot; is the first day of the month.
                  &lt;/table&gt;
                  &lt;p&gt; The following conversion characters are used for formatting common
                  date/time compositions.
                  &lt;table cellpadding=5 summary=&quot;composites&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;R&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0052&apos;&lt;/tt&gt;
                  &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM&quot;}&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;T&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0054&apos;&lt;/tt&gt;
                  &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM:%tS&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;r&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0072&apos;&lt;/tt&gt;
                  &lt;td&gt; Time formatted for the 12-hour clock as {@code &quot;%tI:%tM:%tS
                  %Tp&quot;}.  The location of the morning or afternoon marker
                  ({@code &apos;%Tp&apos;}) may be locale-dependent.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;D&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0044&apos;&lt;/tt&gt;
                  &lt;td&gt; Date formatted as {@code &quot;%tm/%td/%ty&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;F&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0046&apos;&lt;/tt&gt;
                  &lt;td&gt; &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO&amp;nbsp;8601&lt;/a&gt;
                  complete date formatted as {@code &quot;%tY-%tm-%td&quot;}.
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;c&apos;}&lt;td valign=&quot;top&quot;&gt; &lt;tt&gt;&apos;&amp;#92;u0063&apos;&lt;/tt&gt;
                  &lt;td&gt; Date and time formatted as {@code &quot;%ta %tb %td %tT %tZ %tY&quot;},
                  e.g. {@code &quot;Sun Jul 20 16:17:00 EDT 1969&quot;}.
                  &lt;/table&gt;
                  &lt;p&gt; The {@code &apos;-&apos;} flag defined for &lt;a href=&quot;#dFlags&quot;&gt;General
                  conversions&lt;/a&gt; applies.  If the {@code &apos;#&apos;} flag is given, then a {@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;p&gt; The &lt;a name=&quot;dtWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters to
                  be written to the output.  If the length of the converted value is less than
                  the {@code width} then the output will be padded by spaces
                  (&lt;tt&gt;&apos;&amp;#92;u0020&apos;&lt;/tt&gt;) until the total number of characters equals width.
                  The padding is on the left by default.  If the {@code &apos;-&apos;} flag is given
                  then the padding will be on the right.  If width is not specified then there
                  is no minimum.
                  &lt;p&gt; The precision is not applicable.  If the precision is specified then an{@link IllegalFormatPrecisionException} will be thrown.
                  &lt;h4&gt;&lt;a name=&quot;dper&quot;&gt;Percent&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt; The conversion does not correspond to any argument.
                  &lt;table cellpadding=5 summary=&quot;DTConv&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;%&apos;}&lt;td&gt; The result is a literal {@code &apos;%&apos;} (&lt;tt&gt;&apos;&amp;#92;u0025&apos;&lt;/tt&gt;)
                  &lt;p&gt; The &lt;a name=&quot;dtWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters to
                  be written to the output including the {@code &apos;%&apos;}.  If the length of the
                  converted value is less than the {@code width} then the output will be
                  padded by spaces (&lt;tt&gt;&apos;&amp;#92;u0020&apos;&lt;/tt&gt;) until the total number of
                  characters equals width.  The padding is on the left.  If width is not
                  specified then just the {@code &apos;%&apos;} is output.
                  &lt;p&gt; The {@code &apos;-&apos;} flag defined for &lt;a href=&quot;#dFlags&quot;&gt;General
                  conversions&lt;/a&gt; applies.  If any other flags are provided, then a{@link FormatFlagsConversionMismatchException} will be thrown.
                  &lt;p&gt; The precision is not applicable.  If the precision is specified an{@link IllegalFormatPrecisionException} will be thrown.
                  &lt;/table&gt;
                  &lt;h4&gt;&lt;a name=&quot;dls&quot;&gt;Line Separator&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt; The conversion does not correspond to any argument.
                  &lt;table cellpadding=5 summary=&quot;DTConv&quot;&gt;
                  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;{@code &apos;n&apos;}&lt;td&gt; the platform-specific line separator as returned by {@link System#getProperty System.getProperty(&quot;line.separator&quot;)}.
                  &lt;/table&gt;
                  &lt;p&gt; Flags, width, and precision are not applicable.  If any are provided an{@link IllegalFormatFlagsException}, {@link IllegalFormatWidthException},
                  and {@link IllegalFormatPrecisionException}, respectively will be thrown.
                  &lt;h4&gt;&lt;a name=&quot;dpos&quot;&gt;Argument Index&lt;/a&gt;&lt;/h4&gt;
                  &lt;p&gt; Format specifiers can reference arguments in three ways:
                  &lt;ul&gt;
                  &lt;li&gt; &lt;i&gt;Explicit indexing&lt;/i&gt; is used when the format specifier contains an
                  argument index.  The argument index is a decimal integer indicating the
                  position of the argument in the argument list.  The first argument is
                  referenced by &quot;{@code 1$}&quot;, the second by &quot;{@code 2$}&quot;, etc.  An argument
                  may be referenced more than once.
                  &lt;p&gt; For example:
                  &lt;blockquote&gt;&lt;pre&gt;
                  formatter.format(&quot;%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s&quot;,
                  &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
                  // -&amp;gt; &quot;d c b a d c b a&quot;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;li&gt; &lt;i&gt;Relative indexing&lt;/i&gt; is used when the format specifier contains a{@code &apos;&lt;&apos;} (&lt;tt&gt;&apos;&amp;#92;u003c&apos;&lt;/tt&gt;) flag which causes the argument for
                  the previous format specifier to be re-used.  If there is no previous
                  argument, then a {@link MissingFormatArgumentException} is thrown.
                  &lt;blockquote&gt;&lt;pre&gt;
                  formatter.format(&quot;%s %s %&amp;lt;s %&amp;lt;s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
                  // -&amp;gt; &quot;a b b b&quot;
                  // &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;li&gt; &lt;i&gt;Ordinary indexing&lt;/i&gt; is used when the format specifier contains
                  neither an argument index nor a {@code &apos;&lt;&apos;} flag.  Each format specifier
                  which uses ordinary indexing is assigned a sequential implicit index into
                  argument list which is independent of the indices used by explicit or
                  relative indexing.
                  &lt;blockquote&gt;&lt;pre&gt;
                  formatter.format(&quot;%s %s %s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
                  // -&amp;gt; &quot;a b c d&quot;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;/ul&gt;
                  &lt;p&gt; It is possible to have a format string which uses all forms of indexing,
                  for example:
                  &lt;blockquote&gt;&lt;pre&gt;
                  formatter.format(&quot;%2$s %s %&amp;lt;s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
                  // -&amp;gt; &quot;b a a b&quot;
                  // &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; The maximum number of arguments is limited by the maximum dimension of a
                  Java array as defined by
                  &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
                  If the argument index is does not correspond to an
                  available argument, then a {@link MissingFormatArgumentException} is thrown.
                  &lt;p&gt; If there are more arguments than format specifiers, the extra arguments
                  are ignored.
                  &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
                  method or constructor in this class will cause a {@link NullPointerException} to be thrown.                
                <author>
                    Iris Clark                    
                </author>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="a" type="Appendable" line="1084"/>
            <declaration name="l" type="Locale" line="1085"/>
            <declaration name="lastException" type="IOException" line="1086"/>
            <declaration name="zero" type="char" line="1087"/>
            <declaration name="scaleUp" type="double" line="1088"/>
            <declaration name="MAX_FD_CHARS" type="int" line="1089"/>
            <javadoc line="1090">
                Returns a charset object for the given charset name.                
                <throws>
                    NullPointerException          is csn is null                    
                </throws>
                <throws>
                    UnsupportedEncodingException  if the charset is not supported                    
                </throws>
            </javadoc>
            <method name="toCharset" type="Charset" line="1095">
                <params>
                    <param name="csn" type="String"/>
                </params>
                <scope line="1097"/>
                <scope line="1100"/>
            </method>
            <method name="nonNullAppendable" type="Appendable" line="1104">
                <params>
                    <param name="a" type="Appendable"/>
                </params>
            </method>
            <method name="Formatter" type="constructor" line="1108">
                <params>
                    <param name="l" type="Locale"/>
                    <param name="a" type="Appendable"/>
                </params>
            </method>
            <method name="Formatter" type="constructor" line="1113">
                <params>
                    <param name="charset" type="Charset"/>
                    <param name="l" type="Locale"/>
                    <param name="file" type="File"/>
                </params>
            </method>
            <javadoc line="1116">
                Constructs a new formatter.
                  &lt;p&gt; The destination of the formatted output is a {@link StringBuilder}which may be retrieved by invoking {@link #out out()} and whose
                  current content may be converted into a string by invoking {@link #toString toString()}.  The locale used is the {@linkplain Locale#getDefault() default locale} for this instance of the Java
                  virtual machine.                
            </javadoc>
            <method name="Formatter" type="constructor" line="1122"/>
            <javadoc line="1125">
                Constructs a new formatter with the specified destination.
                  &lt;p&gt; The locale used is the {@linkplain Locale#getDefault() default
                  locale} for this instance of the Java virtual machine.                
                <param>
                    aDestination for the formatted output.  If {@code a} is{@code null} then a {@link StringBuilder} will be created.                    
                </param>
            </javadoc>
            <method name="Formatter" type="constructor" line="1131">
                <params>
                    <param name="a" type="Appendable"/>
                </params>
            </method>
            <javadoc line="1134">
                Constructs a new formatter with the specified locale.
                  &lt;p&gt; The destination of the formatted output is a {@link StringBuilder}which may be retrieved by invoking {@link #out out()} and whose current
                  content may be converted into a string by invoking {@link #toStringtoString()}.                
                <param>
                    lThe {@linkplain java.util.Locale locale} to apply during
                      formatting.  If {@code l} is {@code null} then no localization
                      is applied.                    
                </param>
            </javadoc>
            <method name="Formatter" type="constructor" line="1142">
                <params>
                    <param name="l" type="Locale"/>
                </params>
            </method>
            <javadoc line="1145">
                Constructs a new formatter with the specified destination and locale.                
                <param>
                    aDestination for the formatted output.  If {@code a} is{@code null} then a {@link StringBuilder} will be created.                    
                </param>
                <param>
                    lThe {@linkplain java.util.Locale locale} to apply during
                      formatting.  If {@code l} is {@code null} then no localization
                      is applied.                    
                </param>
            </javadoc>
            <method name="Formatter" type="constructor" line="1152">
                <params>
                    <param name="a" type="Appendable"/>
                    <param name="l" type="Locale"/>
                </params>
            </method>
            <javadoc line="1155">
                Constructs a new formatter with the specified file name.
                  &lt;p&gt; The charset used is the {@linkplain java.nio.charset.Charset#defaultCharset() default charset} for this
                  instance of the Java virtual machine.
                  &lt;p&gt; The locale used is the {@linkplain Locale#getDefault() default
                  locale} for this instance of the Java virtual machine.                
                <param>
                    fileNameThe name of the file to use as the destination of this
                      formatter.  If the file exists then it will be truncated to
                      zero size; otherwise, a new file will be created.  The output
                      will be written to the file and is buffered.                    
                </param>
                <throws>
                    SecurityExceptionIf a security manager is present and {@link SecurityManager#checkWrite checkWrite(fileName)} denies write
                      access to the file                    
                </throws>
                <throws>
                    FileNotFoundExceptionIf the given file name does not denote an existing, writable
                      regular file and a new regular file of that name cannot be
                      created, or if some other error occurs while opening or
                      creating the file                    
                </throws>
            </javadoc>
            <method name="Formatter" type="constructor" line="1172">
                <params>
                    <param name="fileName" type="String"/>
                </params>
            </method>
            <javadoc line="1175">
                Constructs a new formatter with the specified file name and charset.
                  &lt;p&gt; The locale used is the {@linkplain Locale#getDefault default
                  locale} for this instance of the Java virtual machine.                
                <param>
                    fileNameThe name of the file to use as the destination of this
                      formatter.  If the file exists then it will be truncated to
                      zero size; otherwise, a new file will be created.  The output
                      will be written to the file and is buffered.                    
                </param>
                <param>
                    csnThe name of a supported {@linkplain java.nio.charset.Charsetcharset}                    
                </param>
                <throws>
                    FileNotFoundExceptionIf the given file name does not denote an existing, writable
                      regular file and a new regular file of that name cannot be
                      created, or if some other error occurs while opening or
                      creating the file                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager is present and {@link SecurityManager#checkWrite checkWrite(fileName)} denies write
                      access to the file                    
                </throws>
                <throws>
                    UnsupportedEncodingExceptionIf the named charset is not supported                    
                </throws>
            </javadoc>
            <method name="Formatter" type="constructor" line="1192">
                <params>
                    <param name="fileName" type="String"/>
                    <param name="csn" type="String"/>
                </params>
            </method>
            <javadoc line="1195">
                Constructs a new formatter with the specified file name, charset, and
                  locale.                
                <param>
                    fileNameThe name of the file to use as the destination of this
                      formatter.  If the file exists then it will be truncated to
                      zero size; otherwise, a new file will be created.  The output
                      will be written to the file and is buffered.                    
                </param>
                <param>
                    csnThe name of a supported {@linkplain java.nio.charset.Charsetcharset}                    
                </param>
                <param>
                    lThe {@linkplain java.util.Locale locale} to apply during
                      formatting.  If {@code l} is {@code null} then no localization
                      is applied.                    
                </param>
                <throws>
                    FileNotFoundExceptionIf the given file name does not denote an existing, writable
                      regular file and a new regular file of that name cannot be
                      created, or if some other error occurs while opening or
                      creating the file                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager is present and {@link SecurityManager#checkWrite checkWrite(fileName)} denies write
                      access to the file                    
                </throws>
                <throws>
                    UnsupportedEncodingExceptionIf the named charset is not supported                    
                </throws>
            </javadoc>
            <method name="Formatter" type="constructor" line="1214">
                <params>
                    <param name="fileName" type="String"/>
                    <param name="csn" type="String"/>
                    <param name="l" type="Locale"/>
                </params>
            </method>
            <javadoc line="1217">
                Constructs a new formatter with the specified file.
                  &lt;p&gt; The charset used is the {@linkplain java.nio.charset.Charset#defaultCharset() default charset} for this
                  instance of the Java virtual machine.
                  &lt;p&gt; The locale used is the {@linkplain Locale#getDefault() default
                  locale} for this instance of the Java virtual machine.                
                <param>
                    fileThe file to use as the destination of this formatter.  If the
                      file exists then it will be truncated to zero size; otherwise,
                      a new file will be created.  The output will be written to the
                      file and is buffered.                    
                </param>
                <throws>
                    SecurityExceptionIf a security manager is present and {@link SecurityManager#checkWrite checkWrite(file.getPath())} denies
                      write access to the file                    
                </throws>
                <throws>
                    FileNotFoundExceptionIf the given file object does not denote an existing, writable
                      regular file and a new regular file of that name cannot be
                      created, or if some other error occurs while opening or
                      creating the file                    
                </throws>
            </javadoc>
            <method name="Formatter" type="constructor" line="1234">
                <params>
                    <param name="file" type="File"/>
                </params>
            </method>
            <javadoc line="1237">
                Constructs a new formatter with the specified file and charset.
                  &lt;p&gt; The locale used is the {@linkplain Locale#getDefault default
                  locale} for this instance of the Java virtual machine.                
                <param>
                    fileThe file to use as the destination of this formatter.  If the
                      file exists then it will be truncated to zero size; otherwise,
                      a new file will be created.  The output will be written to the
                      file and is buffered.                    
                </param>
                <param>
                    csnThe name of a supported {@linkplain java.nio.charset.Charsetcharset}                    
                </param>
                <throws>
                    FileNotFoundExceptionIf the given file object does not denote an existing, writable
                      regular file and a new regular file of that name cannot be
                      created, or if some other error occurs while opening or
                      creating the file                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager is present and {@link SecurityManager#checkWrite checkWrite(file.getPath())} denies
                      write access to the file                    
                </throws>
                <throws>
                    UnsupportedEncodingExceptionIf the named charset is not supported                    
                </throws>
            </javadoc>
            <method name="Formatter" type="constructor" line="1254">
                <params>
                    <param name="file" type="File"/>
                    <param name="csn" type="String"/>
                </params>
            </method>
            <javadoc line="1257">
                Constructs a new formatter with the specified file, charset, and
                  locale.                
                <param>
                    fileThe file to use as the destination of this formatter.  If the
                      file exists then it will be truncated to zero size; otherwise,
                      a new file will be created.  The output will be written to the
                      file and is buffered.                    
                </param>
                <param>
                    csnThe name of a supported {@linkplain java.nio.charset.Charsetcharset}                    
                </param>
                <param>
                    lThe {@linkplain java.util.Locale locale} to apply during
                      formatting.  If {@code l} is {@code null} then no localization
                      is applied.                    
                </param>
                <throws>
                    FileNotFoundExceptionIf the given file object does not denote an existing, writable
                      regular file and a new regular file of that name cannot be
                      created, or if some other error occurs while opening or
                      creating the file                    
                </throws>
                <throws>
                    SecurityExceptionIf a security manager is present and {@link SecurityManager#checkWrite checkWrite(file.getPath())} denies
                      write access to the file                    
                </throws>
                <throws>
                    UnsupportedEncodingExceptionIf the named charset is not supported                    
                </throws>
            </javadoc>
            <method name="Formatter" type="constructor" line="1276">
                <params>
                    <param name="file" type="File"/>
                    <param name="csn" type="String"/>
                    <param name="l" type="Locale"/>
                </params>
            </method>
            <javadoc line="1279">
                Constructs a new formatter with the specified print stream.
                  &lt;p&gt; The locale used is the {@linkplain Locale#getDefault() default
                  locale} for this instance of the Java virtual machine.
                  &lt;p&gt; Characters are written to the given {@link java.io.PrintStreamPrintStream} object and are therefore encoded using that object&apos;s
                  charset.                
                <param>
                    psThe stream to use as the destination of this formatter.                    
                </param>
            </javadoc>
            <method name="Formatter" type="constructor" line="1287">
                <params>
                    <param name="ps" type="PrintStream"/>
                </params>
            </method>
            <javadoc line="1290">
                Constructs a new formatter with the specified output stream.
                  &lt;p&gt; The charset used is the {@linkplain java.nio.charset.Charset#defaultCharset() default charset} for this
                  instance of the Java virtual machine.
                  &lt;p&gt; The locale used is the {@linkplain Locale#getDefault() default
                  locale} for this instance of the Java virtual machine.                
                <param>
                    osThe output stream to use as the destination of this formatter.
                      The output will be buffered.                    
                </param>
            </javadoc>
            <method name="Formatter" type="constructor" line="1299">
                <params>
                    <param name="os" type="OutputStream"/>
                </params>
            </method>
            <javadoc line="1302">
                Constructs a new formatter with the specified output stream and
                  charset.
                  &lt;p&gt; The locale used is the {@linkplain Locale#getDefault default
                  locale} for this instance of the Java virtual machine.                
                <param>
                    osThe output stream to use as the destination of this formatter.
                      The output will be buffered.                    
                </param>
                <param>
                    csnThe name of a supported {@linkplain java.nio.charset.Charsetcharset}                    
                </param>
                <throws>
                    UnsupportedEncodingExceptionIf the named charset is not supported                    
                </throws>
            </javadoc>
            <method name="Formatter" type="constructor" line="1312">
                <params>
                    <param name="os" type="OutputStream"/>
                    <param name="csn" type="String"/>
                </params>
            </method>
            <javadoc line="1315">
                Constructs a new formatter with the specified output stream, charset,
                  and locale.                
                <param>
                    osThe output stream to use as the destination of this formatter.
                      The output will be buffered.                    
                </param>
                <param>
                    csnThe name of a supported {@linkplain java.nio.charset.Charsetcharset}                    
                </param>
                <param>
                    lThe {@linkplain java.util.Locale locale} to apply during
                      formatting.  If {@code l} is {@code null} then no localization
                      is applied.                    
                </param>
                <throws>
                    UnsupportedEncodingExceptionIf the named charset is not supported                    
                </throws>
            </javadoc>
            <method name="Formatter" type="constructor" line="1326">
                <params>
                    <param name="os" type="OutputStream"/>
                    <param name="csn" type="String"/>
                    <param name="l" type="Locale"/>
                </params>
            </method>
            <method name="getZero" type="char" line="1329">
                <params>
                    <param name="l" type="Locale"/>
                </params>
                <scope line="1330">
                    <declaration name="dfs" type="DecimalFormatSymbols" line="1331"/>
                </scope>
                <scope line="1334"/>
            </method>
            <javadoc line="1338">
                Returns the locale set by the construction of this formatter.
                  &lt;p&gt; The {@link #format(java.util.Locale,String,Object) format} method
                  for this object which has a locale argument does not change this value.                
                <return>
                    {@code null} if no localization is applied, otherwise a
                      locale                    
                </return>
                <throws>
                    FormatterClosedExceptionIf this formatter has been closed by invoking its {@link #close()} method                    
                </throws>
            </javadoc>
            <method name="locale" type="Locale" line="1346"/>
            <javadoc line="1350">
                Returns the destination for the output.                
                <return>
                    The destination for the output                    
                </return>
                <throws>
                    FormatterClosedExceptionIf this formatter has been closed by invoking its {@link #close()} method                    
                </throws>
            </javadoc>
            <method name="out" type="Appendable" line="1355"/>
            <javadoc line="1359">
                Returns the result of invoking {@code toString()} on the destination
                  for the output.  For example, the following code formats text into a{@link StringBuilder} then retrieves the resultant string:
                  &lt;blockquote&gt;&lt;pre&gt;
                  Formatter f = new Formatter();
                  f.format(&quot;Last reboot at %tc&quot;, lastRebootDate);
                  String s = f.toString();
                  // -&amp;gt; s == &quot;Last reboot at Sat Jan 01 00:00:00 PST 2000&quot;
                  &lt;/pre&gt;&lt;/blockquote&gt;
                  &lt;p&gt; An invocation of this method behaves in exactly the same way as the
                  invocation
                  &lt;pre&gt;
                  out().toString() &lt;/pre&gt;
                  &lt;p&gt; Depending on the specification of {@code toString} for the {@link Appendable}, the returned string may or may not contain the characters
                  written to the destination.  For instance, buffers typically return
                  their contents in {@code toString()}, but streams cannot since the
                  data is discarded.                
                <return>
                    The result of invoking {@code toString()} on the destination
                      for the output                    
                </return>
                <throws>
                    FormatterClosedExceptionIf this formatter has been closed by invoking its {@link #close()} method                    
                </throws>
            </javadoc>
            <method name="toString" type="String" line="1380"/>
            <javadoc line="1384">
                Flushes this formatter.  If the destination implements the {@link java.io.Flushable} interface, its {@code flush} method will be invoked.
                  &lt;p&gt; Flushing a formatter writes any buffered output in the destination
                  to the underlying stream.                
                <throws>
                    FormatterClosedExceptionIf this formatter has been closed by invoking its {@link #close()} method                    
                </throws>
            </javadoc>
            <method name="flush" type="void" line="1390">
                <scope line="1392">
                    <scope line="1393"/>
                    <scope line="1396"/>
                </scope>
            </method>
            <javadoc line="1401">
                Closes this formatter.  If the destination implements the {@link java.io.Closeable} interface, its {@code close} method will be invoked.
                  &lt;p&gt; Closing a formatter allows it to release resources it may be holding
                  (such as open files).  If the formatter is already closed, then invoking
                  this method has no effect.
                  &lt;p&gt; Attempting to invoke any methods except {@link #ioException()} in
                  this formatter after it has been closed will result in a {@link FormatterClosedException}.                
            </javadoc>
            <method name="close" type="void" line="1409">
                <scope line="1411"/>
                <scope line="1414"/>
                <scope line="1417"/>
            </method>
            <method name="ensureOpen" type="void" line="1421"/>
            <javadoc line="1424">
                Returns the {@code IOException} last thrown by this formatter&apos;s {@link Appendable}.
                  &lt;p&gt; If the destination&apos;s {@code append()} method never throws{@code IOException}, then this method will always return {@code null}.                
                <return>
                    The last exception thrown by the Appendable or {@code null} if
                      no such exception exists.                    
                </return>
            </javadoc>
            <method name="ioException" type="IOException" line="1430"/>
            <javadoc line="1433">
                Writes a formatted string to this object&apos;s destination using the
                  specified format string and arguments.  The locale used is the one
                  defined during the construction of this formatter.                
                <param>
                    formatA format string as described in <a href="#syntax">Format string
                      syntax</a>.                    
                </param>
                <param>
                    argsArguments referenced by the format specifiers in the format
                      string.  If there are more arguments than format specifiers, the
                      extra arguments are ignored.  The maximum number of arguments is
                      limited by the maximum dimension of a Java array as defined by
                      <cite>The Java&trade; Virtual Machine Specification</cite>.                    
                </param>
                <throws>
                    IllegalFormatExceptionIf a format string contains an illegal syntax, a format
                      specifier that is incompatible with the given arguments,
                      insufficient arguments given the format string, or other
                      illegal conditions.  For specification of all possible
                      formatting errors, see the <a href="#detail">Details</a>
                      section of the formatter class specification.                    
                </throws>
                <throws>
                    FormatterClosedExceptionIf this formatter has been closed by invoking its {@link #close()} method                    
                </throws>
                <return>
                    This formatter                    
                </return>
            </javadoc>
            <method name="format" type="Formatter" line="1453">
                <params>
                    <param name="format" type="String"/>
                    <param name="args" type="Object"/>
                </params>
            </method>
            <javadoc line="1456">
                Writes a formatted string to this object&apos;s destination using the
                  specified locale, format string, and arguments.                
                <param>
                    lThe {@linkplain java.util.Locale locale} to apply during
                      formatting.  If {@code l} is {@code null} then no localization
                      is applied.  This does not change this object's locale that was
                      set during construction.                    
                </param>
                <param>
                    formatA format string as described in <a href="#syntax">Format string
                      syntax</a>                    
                </param>
                <param>
                    argsArguments referenced by the format specifiers in the format
                      string.  If there are more arguments than format specifiers, the
                      extra arguments are ignored.  The maximum number of arguments is
                      limited by the maximum dimension of a Java array as defined by
                      <cite>The Java&trade; Virtual Machine Specification</cite>.                    
                </param>
                <throws>
                    IllegalFormatExceptionIf a format string contains an illegal syntax, a format
                      specifier that is incompatible with the given arguments,
                      insufficient arguments given the format string, or other
                      illegal conditions.  For specification of all possible
                      formatting errors, see the <a href="#detail">Details</a>
                      section of the formatter class specification.                    
                </throws>
                <throws>
                    FormatterClosedExceptionIf this formatter has been closed by invoking its {@link #close()} method                    
                </throws>
                <return>
                    This formatter                    
                </return>
            </javadoc>
            <method name="format" type="Formatter" line="1479">
                <params>
                    <param name="l" type="Locale"/>
                    <param name="format" type="String"/>
                    <param name="args" type="Object"/>
                </params>
                <declaration name="last" type="int" line="1481"/>
                <declaration name="lasto" type="int" line="1482"/>
                <declaration name="fsa" type="FormatString[]" line="1483"/>
                <scope line="1484">
                    <declaration name="fs" type="FormatString" line="1485"/>
                    <declaration name="index" type="int" line="1486"/>
                    <scope line="1487"/>
                    <scope line="1509"/>
                </scope>
            </method>
            <declaration name="formatSpecifier" type="String" line="1515"/>
            <declaration name="fsPattern" type="Pattern" line="1516"/>
            <javadoc line="1517">
                Finds format specifiers in the format string.                
            </javadoc>
            <method name="parse" type="FormatString[]" line="1520">
                <params>
                    <param name="s" type="String"/>
                </params>
                <declaration name="al" type="ArrayList&lt;FormatString&gt;" line="1521"/>
                <declaration name="m" type="Matcher" line="1522"/>
                <scope line="1523">
                    <scope line="1524">
                        <scope line="1525"/>
                    </scope>
                    <scope line="1532"/>
                </scope>
            </method>
            <method name="checkText" type="void" line="1540">
                <params>
                    <param name="s" type="String"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <scope line="1541">
                    <scope line="1542">
                        <declaration name="c" type="char" line="1543"/>
                    </scope>
                </scope>
            </method>
            <interface name="FormatString">
                <method name="index" type="int" line="1549"/>
                <method name="print" type="void" line="1550"/>
                <method name="toString" type="String" line="1551"/>
            </interface>
            <class name="FixedString" line="1553">
                <implements interface="FormatString"/>
                <declaration name="s" type="String" line="1554"/>
                <method name="FixedString" type="constructor" line="1555">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <method name="index" type="int" line="1558"/>
                <method name="print" type="void" line="1561">
                    <params>
                        <param name="arg" type="Object"/>
                        <param name="l" type="Locale"/>
                    </params>
                </method>
                <method name="toString" type="String" line="1564"/>
            </class>
            <declaration name="BigDecimalLayoutForm" type="enum" line="1568"/>
            <scope line="1568"/>
            <class name="FormatSpecifier" line="1569">
                <implements interface="FormatString"/>
                <declaration name="index" type="int" line="1570"/>
                <declaration name="f" type="Flags" line="1571"/>
                <declaration name="width" type="int" line="1572"/>
                <declaration name="precision" type="int" line="1573"/>
                <declaration name="dt" type="boolean" line="1574"/>
                <declaration name="c" type="char" line="1575"/>
                <method name="index" type="int" line="1576">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <scope line="1577">
                        <scope line="1578"/>
                        <scope line="1581"/>
                    </scope>
                    <scope line="1585"/>
                </method>
                <method name="index" type="int" line="1590"/>
                <method name="flags" type="Flags" line="1593">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <method name="flags" type="Flags" line="1598"/>
                <method name="width" type="int" line="1601">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <scope line="1603">
                        <scope line="1604"/>
                        <scope line="1608"/>
                    </scope>
                </method>
                <method name="width" type="int" line="1614"/>
                <method name="precision" type="int" line="1617">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <scope line="1619">
                        <scope line="1620"/>
                        <scope line="1624"/>
                    </scope>
                </method>
                <method name="precision" type="int" line="1630"/>
                <method name="conversion" type="char" line="1633">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <scope line="1635"/>
                </method>
                <method name="conversion" type="char" line="1643"/>
                <method name="FormatSpecifier" type="constructor" line="1646">
                    <params>
                        <param name="m" type="Matcher"/>
                    </params>
                    <declaration name="idx" type="int" line="1647"/>
                    <declaration name="tT" type="String" line="1652"/>
                    <scope line="1653"/>
                </method>
                <method name="print" type="void" line="1666">
                    <params>
                        <param name="arg" type="Object"/>
                        <param name="l" type="Locale"/>
                    </params>
                </method>
                <method name="printInteger" type="void" line="1706">
                    <params>
                        <param name="arg" type="Object"/>
                        <param name="l" type="Locale"/>
                    </params>
                </method>
                <method name="printFloat" type="void" line="1715">
                    <params>
                        <param name="arg" type="Object"/>
                        <param name="l" type="Locale"/>
                    </params>
                </method>
                <method name="printDateTime" type="void" line="1722">
                    <params>
                        <param name="arg" type="Object"/>
                        <param name="l" type="Locale"/>
                    </params>
                    <scope line="1723"/>
                    <declaration name="cal" type="Calendar" line="1727"/>
                    <scope line="1728"/>
                    <scope line="1732"/>
                    <scope line="1736"/>
                    <scope line="1740"/>
                </method>
                <method name="printCharacter" type="void" line="1745">
                    <params>
                        <param name="arg" type="Object"/>
                    </params>
                    <scope line="1746"/>
                    <declaration name="s" type="String" line="1750"/>
                    <scope line="1751"/>
                    <scope line="1754">
                        <declaration name="i" type="byte" line="1755"/>
                    </scope>
                    <scope line="1759">
                        <declaration name="i" type="short" line="1760"/>
                    </scope>
                    <scope line="1764">
                        <declaration name="i" type="int" line="1765"/>
                    </scope>
                    <scope line="1769"/>
                </method>
                <method name="printString" type="void" line="1774">
                    <params>
                        <param name="arg" type="Object"/>
                        <param name="l" type="Locale"/>
                    </params>
                    <scope line="1775">
                        <declaration name="fmt" type="Formatter" line="1776"/>
                    </scope>
                    <scope line="1780"/>
                </method>
                <method name="printBoolean" type="void" line="1786">
                    <params>
                        <param name="arg" type="Object"/>
                    </params>
                    <declaration name="s" type="String" line="1787"/>
                </method>
                <method name="printHashCode" type="void" line="1792">
                    <params>
                        <param name="arg" type="Object"/>
                    </params>
                    <declaration name="s" type="String" line="1793"/>
                </method>
                <method name="print" type="void" line="1796">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                </method>
                <method name="justify" type="String" line="1801">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <declaration name="sb" type="StringBuilder" line="1803"/>
                    <declaration name="pad" type="boolean" line="1804"/>
                    <declaration name="sp" type="int" line="1805"/>
                </method>
                <method name="toString" type="String" line="1811">
                    <declaration name="sb" type="StringBuilder" line="1812"/>
                    <declaration name="dupf" type="Flags" line="1813"/>
                </method>
                <method name="checkGeneral" type="void" line="1822"/>
                <method name="checkDateTime" type="void" line="1827"/>
                <method name="checkCharacter" type="void" line="1833"/>
                <method name="checkInteger" type="void" line="1838"/>
                <method name="checkBadFlags" type="void" line="1845">
                    <params>
                        <param name="badFlags" type="Flags"/>
                    </params>
                </method>
                <method name="checkFloat" type="void" line="1848">
                    <scope line="1850"/>
                    <scope line="1852"/>
                    <scope line="1855"/>
                    <scope line="1858"/>
                </method>
                <method name="checkNumeric" type="void" line="1862"/>
                <method name="checkText" type="void" line="1868"/>
                <method name="print" type="void" line="1883">
                    <params>
                        <param name="value" type="byte"/>
                        <param name="l" type="Locale"/>
                    </params>
                </method>
                <method name="print" type="void" line="1891">
                    <params>
                        <param name="value" type="short"/>
                        <param name="l" type="Locale"/>
                    </params>
                </method>
                <method name="print" type="void" line="1899">
                    <params>
                        <param name="value" type="int"/>
                        <param name="l" type="Locale"/>
                    </params>
                </method>
                <method name="print" type="void" line="1907">
                    <params>
                        <param name="value" type="long"/>
                        <param name="l" type="Locale"/>
                    </params>
                    <declaration name="sb" type="StringBuilder" line="1908"/>
                    <scope line="1909">
                        <declaration name="neg" type="boolean" line="1910"/>
                        <declaration name="va" type="char[]" line="1911"/>
                    </scope>
                    <scope line="1918">
                        <declaration name="s" type="String" line="1920"/>
                        <declaration name="len" type="int" line="1921"/>
                    </scope>
                    <scope line="1926">
                        <declaration name="s" type="String" line="1928"/>
                        <declaration name="len" type="int" line="1929"/>
                    </scope>
                </method>
                <method name="leadingSign" type="StringBuilder" line="1937">
                    <params>
                        <param name="sb" type="StringBuilder"/>
                        <param name="neg" type="boolean"/>
                    </params>
                    <scope line="1938">
                        <scope line="1939"/>
                        <scope line="1942"/>
                    </scope>
                    <scope line="1946"/>
                </method>
                <method name="trailingSign" type="StringBuilder" line="1952">
                    <params>
                        <param name="sb" type="StringBuilder"/>
                        <param name="neg" type="boolean"/>
                    </params>
                </method>
                <method name="print" type="void" line="1956">
                    <params>
                        <param name="value" type="BigInteger"/>
                        <param name="l" type="Locale"/>
                    </params>
                    <declaration name="sb" type="StringBuilder" line="1957"/>
                    <declaration name="neg" type="boolean" line="1958"/>
                    <declaration name="v" type="BigInteger" line="1959"/>
                    <scope line="1961">
                        <declaration name="va" type="char[]" line="1962"/>
                    </scope>
                    <scope line="1965">
                        <declaration name="s" type="String" line="1966"/>
                        <declaration name="len" type="int" line="1967"/>
                        <scope line="1969"/>
                        <scope line="1973"/>
                    </scope>
                    <scope line="1978">
                        <declaration name="s" type="String" line="1979"/>
                        <declaration name="len" type="int" line="1980"/>
                        <scope line="1982"/>
                    </scope>
                </method>
                <method name="print" type="void" line="1993">
                    <params>
                        <param name="value" type="float"/>
                        <param name="l" type="Locale"/>
                    </params>
                </method>
                <method name="print" type="void" line="1996">
                    <params>
                        <param name="value" type="double"/>
                        <param name="l" type="Locale"/>
                    </params>
                    <declaration name="sb" type="StringBuilder" line="1997"/>
                    <declaration name="neg" type="boolean" line="1998"/>
                    <scope line="1999">
                        <declaration name="v" type="double" line="2000"/>
                    </scope>
                    <scope line="2006"/>
                </method>
                <method name="print" type="void" line="2011">
                    <params>
                        <param name="sb" type="StringBuilder"/>
                        <param name="value" type="double"/>
                        <param name="l" type="Locale"/>
                        <param name="f" type="Flags"/>
                        <param name="c" type="char"/>
                        <param name="precision" type="int"/>
                        <param name="neg" type="boolean"/>
                    </params>
                    <scope line="2012">
                        <declaration name="prec" type="int" line="2013"/>
                        <declaration name="fd" type="FormattedFloatingDecimal" line="2014"/>
                        <declaration name="v" type="char[]" line="2015"/>
                        <declaration name="len" type="int" line="2016"/>
                        <declaration name="mant" type="char[]" line="2017"/>
                        <declaration name="exp" type="char[]" line="2019"/>
                        <declaration name="newW" type="int" line="2020"/>
                        <declaration name="flags" type="Flags" line="2024"/>
                        <declaration name="sign" type="char" line="2025"/>
                        <declaration name="tmp" type="char[]" line="2028"/>
                    </scope>
                    <scope line="2032">
                        <declaration name="prec" type="int" line="2033"/>
                        <declaration name="fd" type="FormattedFloatingDecimal" line="2034"/>
                        <declaration name="v" type="char[]" line="2035"/>
                        <declaration name="len" type="int" line="2036"/>
                        <declaration name="mant" type="char[]" line="2037"/>
                        <declaration name="newW" type="int" line="2039"/>
                    </scope>
                    <scope line="2043">
                        <declaration name="prec" type="int" line="2044"/>
                        <declaration name="fd" type="FormattedFloatingDecimal" line="2047"/>
                        <declaration name="v" type="char[]" line="2048"/>
                        <declaration name="len" type="int" line="2049"/>
                        <declaration name="exp" type="char[]" line="2050"/>
                        <scope line="2051"/>
                        <scope line="2054"/>
                        <declaration name="mant" type="char[]" line="2057"/>
                        <declaration name="newW" type="int" line="2059"/>
                        <scope line="2060"/>
                        <scope line="2065">
                            <declaration name="flags" type="Flags" line="2067"/>
                            <declaration name="sign" type="char" line="2068"/>
                            <declaration name="tmp" type="char[]" line="2071"/>
                        </scope>
                    </scope>
                    <scope line="2076">
                        <declaration name="prec" type="int" line="2077"/>
                        <declaration name="s" type="String" line="2080"/>
                        <declaration name="va" type="char[]" line="2081"/>
                        <declaration name="upper" type="boolean" line="2082"/>
                        <declaration name="idx" type="int" line="2085"/>
                        <scope line="2087">
                            <declaration name="tmp" type="String" line="2088"/>
                        </scope>
                    </scope>
                </method>
                <method name="mantissa" type="char[]" line="2097">
                    <params>
                        <param name="v" type="char[]"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="i" type="int" line="2098"/>
                    <scope line="2099"/>
                    <declaration name="tmp" type="char[]" line="2102"/>
                </method>
                <method name="exponent" type="char[]" line="2106">
                    <params>
                        <param name="v" type="char[]"/>
                        <param name="len" type="int"/>
                    </params>
                    <declaration name="i" type="int" line="2107"/>
                    <scope line="2108"/>
                    <declaration name="tmp" type="char[]" line="2112"/>
                </method>
                <method name="addZeros" type="char[]" line="2116">
                    <params>
                        <param name="v" type="char[]"/>
                        <param name="prec" type="int"/>
                    </params>
                    <declaration name="i" type="int" line="2117"/>
                    <scope line="2118"/>
                    <declaration name="needDot" type="boolean" line="2121"/>
                    <scope line="2122"/>
                    <declaration name="outPrec" type="int" line="2125"/>
                    <declaration name="tmp" type="char[]" line="2128"/>
                    <declaration name="start" type="int" line="2130"/>
                    <scope line="2131"/>
                </method>
                <method name="hexDouble" type="String" line="2138">
                    <params>
                        <param name="d" type="double"/>
                        <param name="prec" type="int"/>
                    </params>
                </method>
                <method name="print" type="void" line="2186">
                    <params>
                        <param name="value" type="BigDecimal"/>
                        <param name="l" type="Locale"/>
                    </params>
                    <declaration name="sb" type="StringBuilder" line="2188"/>
                    <declaration name="neg" type="boolean" line="2189"/>
                    <declaration name="v" type="BigDecimal" line="2190"/>
                </method>
                <method name="print" type="void" line="2196">
                    <params>
                        <param name="sb" type="StringBuilder"/>
                        <param name="value" type="BigDecimal"/>
                        <param name="l" type="Locale"/>
                        <param name="f" type="Flags"/>
                        <param name="c" type="char"/>
                        <param name="precision" type="int"/>
                        <param name="neg" type="boolean"/>
                    </params>
                </method>
                <class name="BigDecimalLayout" line="2268">
                    <declaration name="mant" type="StringBuilder" line="2269"/>
                    <declaration name="exp" type="StringBuilder" line="2270"/>
                    <declaration name="dot" type="boolean" line="2271"/>
                    <declaration name="scale" type="int" line="2272"/>
                    <method name="BigDecimalLayout" type="constructor" line="2273">
                        <params>
                            <param name="intVal" type="BigInteger"/>
                            <param name="scale" type="int"/>
                            <param name="form" type="BigDecimalLayoutForm"/>
                        </params>
                    </method>
                    <method name="hasDot" type="boolean" line="2276"/>
                    <method name="scale" type="int" line="2279"/>
                    <method name="layoutChars" type="char[]" line="2282">
                        <declaration name="sb" type="StringBuilder" line="2283"/>
                        <scope line="2284"/>
                    </method>
                    <method name="mantissa" type="char[]" line="2290"/>
                    <method name="exponent" type="char[]" line="2293"/>
                    <method name="toCharArray" type="char[]" line="2296">
                        <params>
                            <param name="sb" type="StringBuilder"/>
                        </params>
                        <declaration name="result" type="char[]" line="2298"/>
                    </method>
                    <method name="layout" type="void" line="2302">
                        <params>
                            <param name="intVal" type="BigInteger"/>
                            <param name="scale" type="int"/>
                            <param name="form" type="BigDecimalLayoutForm"/>
                        </params>
                        <declaration name="coeff" type="char" line="2303"/>
                        <scope line="2306">
                            <declaration name="len" type="int" line="2307"/>
                            <scope line="2308">
                                <scope line="2310"/>
                                <scope line="2318"/>
                            </scope>
                            <scope line="2322"/>
                        </scope>
                        <declaration name="adjusted" type="long" line="2328"/>
                        <scope line="2329">
                            <declaration name="pad" type="int" line="2330"/>
                            <scope line="2331"/>
                            <scope line="2337">
                                <scope line="2338"/>
                                <scope line="2344"/>
                            </scope>
                        </scope>
                        <scope line="2351">
                            <scope line="2353"/>
                            <scope line="2359">
                                <declaration name="abs" type="long" line="2360"/>
                            </scope>
                            <scope line="2365"/>
                        </scope>
                    </method>
                </class>
                <method name="adjustWidth" type="int" line="2371">
                    <params>
                        <param name="width" type="int"/>
                        <param name="f" type="Flags"/>
                        <param name="neg" type="boolean"/>
                    </params>
                    <declaration name="newW" type="int" line="2372"/>
                </method>
                <method name="addDot" type="char[]" line="2376">
                    <params>
                        <param name="mant" type="char[]"/>
                    </params>
                    <declaration name="tmp" type="char[]" line="2377"/>
                </method>
                <method name="trailingZeros" type="char[]" line="2383">
                    <params>
                        <param name="mant" type="char[]"/>
                        <param name="nzeros" type="int"/>
                    </params>
                    <declaration name="tmp" type="char[]" line="2384"/>
                    <scope line="2385"/>
                </method>
                <method name="print" type="void" line="2392">
                    <params>
                        <param name="t" type="Calendar"/>
                        <param name="c" type="char"/>
                        <param name="l" type="Locale"/>
                    </params>
                    <declaration name="sb" type="StringBuilder" line="2393"/>
                    <declaration name="s" type="String" line="2395"/>
                </method>
                <method name="print" type="Appendable" line="2399">
                    <params>
                        <param name="sb" type="StringBuilder"/>
                        <param name="t" type="Calendar"/>
                        <param name="c" type="char"/>
                        <param name="l" type="Locale"/>
                    </params>
                </method>
                <method name="failMismatch" type="void" line="2604">
                    <params>
                        <param name="f" type="Flags"/>
                        <param name="c" type="char"/>
                    </params>
                    <declaration name="fs" type="String" line="2605"/>
                </method>
                <method name="failConversion" type="void" line="2608">
                    <params>
                        <param name="c" type="char"/>
                        <param name="arg" type="Object"/>
                    </params>
                </method>
                <method name="getZero" type="char" line="2611">
                    <params>
                        <param name="l" type="Locale"/>
                    </params>
                    <scope line="2612">
                        <declaration name="dfs" type="DecimalFormatSymbols" line="2613"/>
                    </scope>
                </method>
                <method name="localizedMagnitude" type="StringBuilder" line="2618">
                    <params>
                        <param name="sb" type="StringBuilder"/>
                        <param name="value" type="long"/>
                        <param name="f" type="Flags"/>
                        <param name="width" type="int"/>
                        <param name="l" type="Locale"/>
                    </params>
                    <declaration name="va" type="char[]" line="2619"/>
                </method>
                <method name="localizedMagnitude" type="StringBuilder" line="2622">
                    <params>
                        <param name="sb" type="StringBuilder"/>
                        <param name="value" type="char[]"/>
                        <param name="f" type="Flags"/>
                        <param name="width" type="int"/>
                        <param name="l" type="Locale"/>
                    </params>
                    <declaration name="begin" type="int" line="2624"/>
                    <declaration name="zero" type="char" line="2625"/>
                    <declaration name="grpSep" type="char" line="2626"/>
                    <declaration name="grpSize" type="int" line="2627"/>
                    <declaration name="decSep" type="char" line="2628"/>
                    <declaration name="len" type="int" line="2629"/>
                    <declaration name="dot" type="int" line="2630"/>
                    <scope line="2631">
                        <scope line="2632"/>
                    </scope>
                    <scope line="2637">
                        <scope line="2638"/>
                        <scope line="2641">
                            <declaration name="dfs" type="DecimalFormatSymbols" line="2642"/>
                        </scope>
                    </scope>
                    <scope line="2646">
                        <scope line="2647"/>
                        <scope line="2651">
                            <declaration name="dfs" type="DecimalFormatSymbols" line="2652"/>
                            <declaration name="df" type="DecimalFormat" line="2654"/>
                        </scope>
                    </scope>
                    <scope line="2658">
                        <scope line="2659"/>
                        <declaration name="c" type="char" line="2664"/>
                    </scope>
                </method>
            </class>
            <class name="Flags" line="2673">
                <declaration name="flags" type="int" line="2674"/>
                <declaration name="NONE" type="Flags" line="2675"/>
                <declaration name="LEFT_JUSTIFY" type="Flags" line="2676"/>
                <declaration name="UPPERCASE" type="Flags" line="2677"/>
                <declaration name="ALTERNATE" type="Flags" line="2678"/>
                <declaration name="PLUS" type="Flags" line="2679"/>
                <declaration name="LEADING_SPACE" type="Flags" line="2680"/>
                <declaration name="ZERO_PAD" type="Flags" line="2681"/>
                <declaration name="GROUP" type="Flags" line="2682"/>
                <declaration name="PARENTHESES" type="Flags" line="2683"/>
                <declaration name="PREVIOUS" type="Flags" line="2684"/>
                <method name="Flags" type="constructor" line="2685">
                    <params>
                        <param name="f" type="int"/>
                    </params>
                </method>
                <method name="valueOf" type="int" line="2688"/>
                <method name="contains" type="boolean" line="2691">
                    <params>
                        <param name="f" type="Flags"/>
                    </params>
                </method>
                <method name="dup" type="Flags" line="2694"/>
                <method name="add" type="Flags" line="2697">
                    <params>
                        <param name="f" type="Flags"/>
                    </params>
                </method>
                <method name="remove" type="Flags" line="2701">
                    <params>
                        <param name="f" type="Flags"/>
                    </params>
                </method>
                <method name="parse" type="Flags" line="2705">
                    <params>
                        <param name="s" type="String"/>
                    </params>
                    <declaration name="ca" type="char[]" line="2706"/>
                    <declaration name="f" type="Flags" line="2707"/>
                    <scope line="2708">
                        <declaration name="v" type="Flags" line="2709"/>
                    </scope>
                </method>
                <method name="parse" type="Flags" line="2715">
                    <params>
                        <param name="c" type="char"/>
                    </params>
                </method>
                <method name="toString" type="String" line="2737">
                    <params>
                        <param name="f" type="Flags"/>
                    </params>
                </method>
                <method name="toString" type="String" line="2740">
                    <declaration name="sb" type="StringBuilder" line="2741"/>
                </method>
            </class>
            <class name="Conversion" line="2754">
                <declaration name="DECIMAL_INTEGER" type="char" line="2755"/>
                <declaration name="OCTAL_INTEGER" type="char" line="2756"/>
                <declaration name="HEXADECIMAL_INTEGER" type="char" line="2757"/>
                <declaration name="HEXADECIMAL_INTEGER_UPPER" type="char" line="2758"/>
                <declaration name="SCIENTIFIC" type="char" line="2759"/>
                <declaration name="SCIENTIFIC_UPPER" type="char" line="2760"/>
                <declaration name="GENERAL" type="char" line="2761"/>
                <declaration name="GENERAL_UPPER" type="char" line="2762"/>
                <declaration name="DECIMAL_FLOAT" type="char" line="2763"/>
                <declaration name="HEXADECIMAL_FLOAT" type="char" line="2764"/>
                <declaration name="HEXADECIMAL_FLOAT_UPPER" type="char" line="2765"/>
                <declaration name="CHARACTER" type="char" line="2766"/>
                <declaration name="CHARACTER_UPPER" type="char" line="2767"/>
                <declaration name="DATE_TIME" type="char" line="2768"/>
                <declaration name="DATE_TIME_UPPER" type="char" line="2769"/>
                <declaration name="BOOLEAN" type="char" line="2770"/>
                <declaration name="BOOLEAN_UPPER" type="char" line="2771"/>
                <declaration name="STRING" type="char" line="2772"/>
                <declaration name="STRING_UPPER" type="char" line="2773"/>
                <declaration name="HASHCODE" type="char" line="2774"/>
                <declaration name="HASHCODE_UPPER" type="char" line="2775"/>
                <declaration name="LINE_SEPARATOR" type="char" line="2776"/>
                <declaration name="PERCENT_SIGN" type="char" line="2777"/>
                <method name="isValid" type="boolean" line="2778">
                    <params>
                        <param name="c" type="char"/>
                    </params>
                </method>
                <method name="isGeneral" type="boolean" line="2781">
                    <params>
                        <param name="c" type="char"/>
                    </params>
                </method>
                <method name="isCharacter" type="boolean" line="2794">
                    <params>
                        <param name="c" type="char"/>
                    </params>
                </method>
                <method name="isInteger" type="boolean" line="2803">
                    <params>
                        <param name="c" type="char"/>
                    </params>
                </method>
                <method name="isFloat" type="boolean" line="2814">
                    <params>
                        <param name="c" type="char"/>
                    </params>
                </method>
                <method name="isText" type="boolean" line="2828">
                    <params>
                        <param name="c" type="char"/>
                    </params>
                </method>
            </class>
            <class name="DateTime" line="2838">
                <declaration name="HOUR_OF_DAY_0" type="char" line="2839"/>
                <declaration name="HOUR_0" type="char" line="2840"/>
                <declaration name="HOUR_OF_DAY" type="char" line="2841"/>
                <declaration name="HOUR" type="char" line="2842"/>
                <declaration name="MINUTE" type="char" line="2843"/>
                <declaration name="NANOSECOND" type="char" line="2844"/>
                <declaration name="MILLISECOND" type="char" line="2845"/>
                <declaration name="MILLISECOND_SINCE_EPOCH" type="char" line="2846"/>
                <declaration name="AM_PM" type="char" line="2847"/>
                <declaration name="SECONDS_SINCE_EPOCH" type="char" line="2848"/>
                <declaration name="SECOND" type="char" line="2849"/>
                <declaration name="TIME" type="char" line="2850"/>
                <declaration name="ZONE_NUMERIC" type="char" line="2851"/>
                <declaration name="ZONE" type="char" line="2852"/>
                <declaration name="NAME_OF_DAY_ABBREV" type="char" line="2853"/>
                <declaration name="NAME_OF_DAY" type="char" line="2854"/>
                <declaration name="NAME_OF_MONTH_ABBREV" type="char" line="2855"/>
                <declaration name="NAME_OF_MONTH" type="char" line="2856"/>
                <declaration name="CENTURY" type="char" line="2857"/>
                <declaration name="DAY_OF_MONTH_0" type="char" line="2858"/>
                <declaration name="DAY_OF_MONTH" type="char" line="2859"/>
                <declaration name="NAME_OF_MONTH_ABBREV_X" type="char" line="2860"/>
                <declaration name="DAY_OF_YEAR" type="char" line="2861"/>
                <declaration name="MONTH" type="char" line="2862"/>
                <declaration name="YEAR_2" type="char" line="2863"/>
                <declaration name="YEAR_4" type="char" line="2864"/>
                <declaration name="TIME_12_HOUR" type="char" line="2865"/>
                <declaration name="TIME_24_HOUR" type="char" line="2866"/>
                <declaration name="DATE_TIME" type="char" line="2867"/>
                <declaration name="DATE" type="char" line="2868"/>
                <declaration name="ISO_STANDARD_DATE" type="char" line="2869"/>
                <method name="isValid" type="boolean" line="2870">
                    <params>
                        <param name="c" type="char"/>
                    </params>
                </method>
            </class>
        </class>
    </source>