<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <class name="RecursiveAction" line="38">
            <extends class="ForkJoinTask">
                <type_params>
                    <type_param name="Void"/>
                </type_params>
            </extends>
            <javadoc line="38">
                A recursive resultless {@link ForkJoinTask}.  This class
                  establishes conventions to parameterize resultless actions as{@code Void} {@code ForkJoinTask}s. Because {@code null} is the
                  only valid value of type {@code Void}, methods such as join always
                  return {@code null} upon completion.
                  &lt;p&gt;&lt;b&gt;Sample Usages.&lt;/b&gt; Here is a sketch of a ForkJoin sort that
                  sorts a given {@code long[]} array:
                  &lt;pre&gt; {@code}class SortTask extends RecursiveAction 
                  final long[] array; final int lo; final int hi;
                  SortTask(long[] array, int lo, int hi) {
                  this.array = array; this.lo = lo; this.hi = hi;
                  }
                  protected void compute() {
                  if (hi - lo &lt; THRESHOLD)
                  sequentiallySort(array, lo, hi);
                  else {
                  int mid = (lo + hi) &gt;&gt;&gt; 1;
                  invokeAll(new SortTask(array, lo, mid),
                  new SortTask(array, mid, hi));
                  merge(array, lo, hi);
                  }
                  }
                  }}&lt;/pre&gt;
                  You could then sort {@code anArray} by creating {@code new
                  SortTask(anArray, 0, anArray.length-1) } and invoking it in a
                  ForkJoinPool.  As a more concrete simple example, the following
                  task increments each element of an array:
                  &lt;pre&gt; {@code}class IncrementTask extends RecursiveAction 
                  final long[] array; final int lo; final int hi;
                  IncrementTask(long[] array, int lo, int hi) {
                  this.array = array; this.lo = lo; this.hi = hi;
                  }
                  protected void compute() {
                  if (hi - lo &lt; THRESHOLD) {
                  for (int i = lo; i &lt; hi; ++i)
                  array[i]++;
                  }
                  else {
                  int mid = (lo + hi) &gt;&gt;&gt; 1;
                  invokeAll(new IncrementTask(array, lo, mid),
                  new IncrementTask(array, mid, hi));
                  }
                  }
                  }}&lt;/pre&gt;
                  &lt;p&gt;The following example illustrates some refinements and idioms
                  that may lead to better performance: RecursiveActions need not be
                  fully recursive, so long as they maintain the basic
                  divide-and-conquer approach. Here is a class that sums the squares
                  of each element of a double array, by subdividing out only the
                  right-hand-sides of repeated divisions by two, and keeping track of
                  them with a chain of {@code next} references. It uses a dynamic
                  threshold based on method {@code getSurplusQueuedTaskCount}, but
                  counterbalances potential excess partitioning by directly
                  performing leaf actions on unstolen tasks rather than further
                  subdividing.
                  &lt;pre&gt; {@code}double sumOfSquares(ForkJoinPool pool, double[] array) 
                  int n = array.length;
                  Applyer a = new Applyer(array, 0, n, null);
                  pool.invoke(a);
                  return a.result;
                  }
                  class Applyer extends RecursiveAction {
                  final double[] array;
                  final int lo, hi;
                  double result;
                  Applyer next; // keeps track of right-hand-side tasks
                  Applyer(double[] array, int lo, int hi, Applyer next) {
                  this.array = array; this.lo = lo; this.hi = hi;
                  this.next = next;
                  }
                  double atLeaf(int l, int h) {
                  double sum = 0;
                  for (int i = l; i &lt; h; ++i) // perform leftmost base step
                  sum += array[i]  array[i];
                  return sum;
                  }
                  protected void compute() {
                  int l = lo;
                  int h = hi;
                  Applyer right = null;
                  while (h - l &gt; 1 &amp;&amp; getSurplusQueuedTaskCount() &lt;= 3) {
                  int mid = (l + h) &gt;&gt;&gt; 1;
                  right = new Applyer(array, mid, h, right);
                  right.fork();
                  h = mid;
                  }
                  double sum = atLeaf(l, h);
                  while (right != null) {
                  if (right.tryUnfork()) // directly calculate if not stolen
                  sum += right.atLeaf(right.lo, right.hi);
                  else {
                  right.join();
                  sum += right.result;
                  }
                  right = right.next;
                  }
                  result = sum;
                  }
                  }}&lt;/pre&gt;                
                <since>
                    1.7                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="154"/>
            <method name="compute" type="void" line="156"/>
            <javadoc line="156">
                The main computation performed by this task.                
            </javadoc>
            <javadoc line="161">
                Always returns {@code null}.                
                <return>
                    {@code null} always                    
                </return>
            </javadoc>
            <method name="getRawResult" type="Void" line="166"/>
            <javadoc line="168">
                Requires null completion value.                
            </javadoc>
            <method name="setRawResult" type="void" line="171">
                <params>
                    <param name="mustBeNull" type="Void"/>
                </params>
            </method>
            <javadoc line="173">
                Implements execution conventions for RecursiveActions.                
            </javadoc>
            <method name="exec" type="boolean" line="176"/>
        </class>
    </source>