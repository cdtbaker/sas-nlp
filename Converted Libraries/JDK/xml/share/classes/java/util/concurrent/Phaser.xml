<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.TimeoutException"/>
        <import package="java.util.concurrent.atomic.AtomicReference"/>
        <import package="java.util.concurrent.locks.LockSupport"/>
        <class name="Phaser" line="6">
            <javadoc line="6">
                A reusable synchronization barrier, similar in functionality to{@link java.util.concurrent.CyclicBarrier CyclicBarrier} and{@link java.util.concurrent.CountDownLatch CountDownLatch}but supporting more flexible usage.
                  &lt;p&gt; &lt;b&gt;Registration.&lt;/b&gt; Unlike the case for other barriers, the
                  number of parties &lt;em&gt;registered&lt;/em&gt; to synchronize on a phaser
                  may vary over time.  Tasks may be registered at any time (using
                  methods {@link #register}, {@link #bulkRegister}, or forms of
                  constructors establishing initial numbers of parties), and
                  optionally deregistered upon any arrival (using {@link #arriveAndDeregister}).  As is the case with most basic
                  synchronization constructs, registration and deregistration affect
                  only internal counts; they do not establish any further internal
                  bookkeeping, so tasks cannot query whether they are registered.
                  (However, you can introduce such bookkeeping by subclassing this
                  class.)
                  &lt;p&gt; &lt;b&gt;Synchronization.&lt;/b&gt; Like a {@code CyclicBarrier}, a {@codePhaser} may be repeatedly awaited.  Method {@link #arriveAndAwaitAdvance} has effect analogous to {@link java.util.concurrent.CyclicBarrier#await CyclicBarrier.await}. Each
                  generation of a phaser has an associated phase number. The phase
                  number starts at zero, and advances when all parties arrive at the
                  phaser, wrapping around to zero after reaching {@codeInteger.MAX_VALUE}. The use of phase numbers enables independent
                  control of actions upon arrival at a phaser and upon awaiting
                  others, via two kinds of methods that may be invoked by any
                  registered party:
                  &lt;ul&gt;
                  &lt;li&gt; &lt;b&gt;Arrival.&lt;/b&gt; Methods {@link #arrive} and{@link #arriveAndDeregister} record arrival.  These methods
                  do not block, but return an associated &lt;em&gt;arrival phase
                  number&lt;/em&gt;; that is, the phase number of the phaser to which
                  the arrival applied. When the final party for a given phase
                  arrives, an optional action is performed and the phase
                  advances.  These actions are performed by the party
                  triggering a phase advance, and are arranged by overriding
                  method {@link #onAdvance(int,int)}, which also controls
                  termination. Overriding this method is similar to, but more
                  flexible than, providing a barrier action to a {@codeCyclicBarrier}.
                  &lt;li&gt; &lt;b&gt;Waiting.&lt;/b&gt; Method {@link #awaitAdvance} requires an
                  argument indicating an arrival phase number, and returns when
                  the phaser advances to (or is already at) a different phase.
                  Unlike similar constructions using {@code CyclicBarrier},
                  method {@code awaitAdvance} continues to wait even if the
                  waiting thread is interrupted. Interruptible and timeout
                  versions are also available, but exceptions encountered while
                  tasks wait interruptibly or with timeout do not change the
                  state of the phaser. If necessary, you can perform any
                  associated recovery within handlers of those exceptions,
                  often after invoking {@code forceTermination}.  Phasers may
                  also be used by tasks executing in a {@link ForkJoinPool},
                  which will ensure sufficient parallelism to execute tasks
                  when others are blocked waiting for a phase to advance.
                  &lt;/ul&gt;
                  &lt;p&gt; &lt;b&gt;Termination.&lt;/b&gt; A phaser may enter a &lt;em&gt;termination&lt;/em&gt;
                  state, that may be checked using method {@link #isTerminated}. Upon
                  termination, all synchronization methods immediately return without
                  waiting for advance, as indicated by a negative return value.
                  Similarly, attempts to register upon termination have no effect.
                  Termination is triggered when an invocation of {@code onAdvance}returns {@code true}. The default implementation returns {@codetrue} if a deregistration has caused the number of registered
                  parties to become zero.  As illustrated below, when phasers control
                  actions with a fixed number of iterations, it is often convenient
                  to override this method to cause termination when the current phase
                  number reaches a threshold. Method {@link #forceTermination} is
                  also available to abruptly release waiting threads and allow them
                  to terminate.
                  &lt;p&gt; &lt;b&gt;Tiering.&lt;/b&gt; Phasers may be &lt;em&gt;tiered&lt;/em&gt; (i.e.,
                  constructed in tree structures) to reduce contention. Phasers with
                  large numbers of parties that would otherwise experience heavy
                  synchronization contention costs may instead be set up so that
                  groups of sub-phasers share a common parent.  This may greatly
                  increase throughput even though it incurs greater per-operation
                  overhead.
                  &lt;p&gt;In a tree of tiered phasers, registration and deregistration of
                  child phasers with their parent are managed automatically.
                  Whenever the number of registered parties of a child phaser becomes
                  non-zero (as established in the {@link #Phaser(Phaser,int)}constructor, {@link #register}, or {@link #bulkRegister}), the
                  child phaser is registered with its parent.  Whenever the number of
                  registered parties becomes zero as the result of an invocation of{@link #arriveAndDeregister}, the child phaser is deregistered
                  from its parent.
                  &lt;p&gt;&lt;b&gt;Monitoring.&lt;/b&gt; While synchronization methods may be invoked
                  only by registered parties, the current state of a phaser may be
                  monitored by any caller.  At any given moment there are {@link #getRegisteredParties} parties in total, of which {@link #getArrivedParties} have arrived at the current phase ({@link #getPhase}).  When the remaining ({@link #getUnarrivedParties})
                  parties arrive, the phase advances.  The values returned by these
                  methods may reflect transient states and so are not in general
                  useful for synchronization control.  Method {@link #toString}returns snapshots of these state queries in a form convenient for
                  informal monitoring.
                  &lt;p&gt;&lt;b&gt;Sample usages:&lt;/b&gt;
                  &lt;p&gt;A {@code Phaser} may be used instead of a {@code CountDownLatch}to control a one-shot action serving a variable number of parties.
                  The typical idiom is for the method setting this up to first
                  register, then start the actions, then deregister, as in:
                  &lt;pre&gt; {@code}void runTasks(List&lt;Runnable&gt; tasks) 
                  final Phaser phaser = new Phaser(1); // &quot;1&quot; to register self
                  // create and start threads
                  for (final Runnable task : tasks) {
                  phaser.register();
                  new Thread() {
                  public void run() {
                  phaser.arriveAndAwaitAdvance(); // await all creation
                  task.run();
                  }
                  }.start();
                  }
                  // allow threads to start and deregister self
                  phaser.arriveAndDeregister();
                  }}&lt;/pre&gt;
                  &lt;p&gt;One way to cause a set of threads to repeatedly perform actions
                  for a given number of iterations is to override {@code onAdvance}:
                  &lt;pre&gt; {@code}void startTasks(List&lt;Runnable&gt; tasks, final int iterations) 
                  final Phaser phaser = new Phaser() {
                  protected boolean onAdvance(int phase, int registeredParties) {
                  return phase &gt;= iterations || registeredParties == 0;
                  }
                  };
                  phaser.register();
                  for (final Runnable task : tasks) {
                  phaser.register();
                  new Thread() {
                  public void run() {
                  do {
                  task.run();
                  phaser.arriveAndAwaitAdvance();
                  } while (!phaser.isTerminated());
                  }
                  }.start();
                  }
                  phaser.arriveAndDeregister(); // deregister self, don&apos;t wait
                  }}&lt;/pre&gt;
                  If the main task must later await termination, it
                  may re-register and then execute a similar loop:
                  &lt;pre&gt; 
                    phaser.register();
                  while (!phaser.isTerminated())
                  phaser.arriveAndAwaitAdvance();
                  &lt;/pre&gt;
                  &lt;p&gt;Related constructions may be used to await particular phase numbers
                  in contexts where you are sure that the phase will never wrap around{@code Integer.MAX_VALUE}. For example:
                  &lt;pre&gt; {@code}void awaitPhase(Phaser phaser, int phase) 
                  int p = phaser.register(); // assumes caller not already registered
                  while (p &lt; phase) {
                  if (phaser.isTerminated())
                  // ... deal with unexpected termination
                  else
                  p = phaser.arriveAndAwaitAdvance();
                  }
                  phaser.arriveAndDeregister();
                  }}&lt;/pre&gt;
                  &lt;p&gt;To create a set of {@code n} tasks using a tree of phasers, you
                  could use code of the following form, assuming a Task class with a
                  constructor accepting a {@code Phaser} that it registers with upon
                  construction. After invocation of {@code build(new Task[n], 0, n,
                  new Phaser())}, these tasks could then be started, for example by
                  submitting to a pool:
                  &lt;pre&gt; {@code}void build(Task[] tasks, int lo, int hi, Phaser ph) 
                  if (hi - lo &gt; TASKS_PER_PHASER) {
                  for (int i = lo; i &lt; hi; i += TASKS_PER_PHASER) {
                  int j = Math.min(i + TASKS_PER_PHASER, hi);
                  build(tasks, i, j, new Phaser(ph));
                  }
                  } else {
                  for (int i = lo; i &lt; hi; ++i)
                  tasks[i] = new Task(ph);
                  // assumes new Task(ph) performs ph.register()
                  }
                  }}&lt;/pre&gt;
                  The best value of {@code TASKS_PER_PHASER} depends mainly on
                  expected synchronization rates. A value as low as four may
                  be appropriate for extremely small per-phase task bodies (thus
                  high rates), or up to hundreds for extremely large ones.
                  &lt;p&gt;&lt;b&gt;Implementation notes&lt;/b&gt;: This implementation restricts the
                  maximum number of parties to 65535. Attempts to register additional
                  parties result in {@code IllegalStateException}. However, you can and
                  should create tiered phasers to accommodate arbitrarily large sets
                  of participants.                
                <since>
                    1.7                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <declaration name="state" type="long" line="175"/>
            <javadoc line="175">
                Primary state representation, holding four bit-fields:
                  unarrived  -- the number of parties yet to hit barrier (bits  0-15)
                  parties    -- the number of parties to wait            (bits 16-31)
                  phase      -- the generation of the barrier            (bits 32-62)
                  terminated -- set if barrier is terminated             (bit  63 / sign)
                  Except that a phaser with no registered parties is
                  distinguished by the otherwise illegal state of having zero
                  parties and one unarrived parties (encoded as EMPTY below).
                  To efficiently maintain atomicity, these values are packed into
                  a single (atomic) long. Good performance relies on keeping
                  state decoding and encoding simple, and keeping race windows
                  short.
                  All state updates are performed via CAS except initial
                  registration of a sub-phaser (i.e., one with a non-null
                  parent).  In this (relatively rare) case, we use built-in
                  synchronization to lock while first registering with its
                  parent.
                  The phase of a subphaser is allowed to lag that of its
                  ancestors until it is actually accessed -- see method
                  reconcileState.                
            </javadoc>
            <declaration name="MAX_PARTIES" type="int" line="198"/>
            <declaration name="MAX_PHASE" type="int" line="199"/>
            <declaration name="PARTIES_SHIFT" type="int" line="200"/>
            <declaration name="PHASE_SHIFT" type="int" line="201"/>
            <declaration name="UNARRIVED_MASK" type="int" line="202"/>
            <declaration name="PARTIES_MASK" type="long" line="203"/>
            <declaration name="TERMINATION_BIT" type="long" line="204"/>
            <declaration name="ONE_ARRIVAL" type="int" line="205"/>
            <declaration name="ONE_PARTY" type="int" line="206"/>
            <declaration name="EMPTY" type="int" line="207"/>
            <method name="unarrivedOf" type="int" line="208">
                <params>
                    <param name="s" type="long"/>
                </params>
                <declaration name="counts" type="int" line="209"/>
            </method>
            <method name="partiesOf" type="int" line="212">
                <params>
                    <param name="s" type="long"/>
                </params>
            </method>
            <method name="phaseOf" type="int" line="215">
                <params>
                    <param name="s" type="long"/>
                </params>
            </method>
            <method name="arrivedOf" type="int" line="218">
                <params>
                    <param name="s" type="long"/>
                </params>
                <declaration name="counts" type="int" line="219"/>
            </method>
            <declaration name="parent" type="Phaser" line="222"/>
            <javadoc line="222">
                The parent of this phaser, or null if none                
            </javadoc>
            <declaration name="root" type="Phaser" line="226"/>
            <javadoc line="226">
                The root of phaser tree. Equals this if not in a tree.                
            </javadoc>
            <declaration name="evenQ" type="AtomicReference&lt;QNode&gt;" line="230"/>
            <javadoc line="230">
                Heads of Treiber stacks for waiting threads. To eliminate
                  contention when releasing some threads while adding others, we
                  use two of them, alternating across even and odd phases.
                  Subphasers share queues with root to speed up releases.                
            </javadoc>
            <declaration name="oddQ" type="AtomicReference&lt;QNode&gt;" line="237"/>
            <method name="queueFor" type="AtomicReference<QNode>" line="238">
                <params>
                    <param name="phase" type="int"/>
                </params>
            </method>
            <javadoc line="241">
                Returns message string for bounds exceptions on arrival.                
            </javadoc>
            <method name="badArrive" type="String" line="244">
                <params>
                    <param name="s" type="long"/>
                </params>
            </method>
            <javadoc line="247">
                Returns message string for bounds exceptions on registration.                
            </javadoc>
            <method name="badRegister" type="String" line="250">
                <params>
                    <param name="s" type="long"/>
                </params>
            </method>
            <javadoc line="253">
                Main implementation for methods arrive and arriveAndDeregister.
                  Manually tuned to speed up and minimize race windows for the
                  common case of just decrementing unarrived field.                
                <param>
                    deregister false for arrive, true for arriveAndDeregister                    
                </param>
            </javadoc>
            <method name="doArrive" type="int" line="259">
                <params>
                    <param name="deregister" type="boolean"/>
                </params>
                <declaration name="adj" type="int" line="260"/>
                <declaration name="root" type="Phaser" line="261"/>
                <scope line="262">
                    <declaration name="s" type="long" line="263"/>
                    <declaration name="phase" type="int" line="264"/>
                    <declaration name="counts" type="int" line="265"/>
                    <declaration name="unarrived" type="int" line="266"/>
                    <scope line="268"/>
                    <scope line="271">
                        <scope line="272">
                            <declaration name="n" type="long" line="273"/>
                            <declaration name="nextUnarrived" type="int" line="274"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="287">
                Implementation of register, bulkRegister                
                <param>
                    registrations number to add to both parties and
                      unarrived fields. Must be greater than zero.                    
                </param>
            </javadoc>
            <method name="doRegister" type="int" line="292">
                <params>
                    <param name="registrations" type="int"/>
                </params>
                <declaration name="adj" type="long" line="293"/>
                <declaration name="parent" type="Phaser" line="294"/>
                <declaration name="phase" type="int" line="295"/>
                <scope line="296">
                    <declaration name="s" type="long" line="297"/>
                    <declaration name="counts" type="int" line="298"/>
                    <declaration name="parties" type="int" line="299"/>
                    <declaration name="unarrived" type="int" line="300"/>
                    <scope line="303">
                        <scope line="304"/>
                    </scope>
                    <scope line="309">
                        <declaration name="next" type="long" line="310"/>
                    </scope>
                    <scope line="313">
                        <scope line="314">
                            <scope line="315">
                                <scope line="317"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="328">
                Resolves lagged phase propagation from root if necessary.
                  Reconciliation normally occurs when root has advanced but
                  subphasers have not yet done so, in which case they must finish
                  their own advance by setting unarrived to parties (or if
                  parties is zero, resetting to unregistered EMPTY state).
                  However, this method may also be called when &quot;floating&quot;
                  subphasers with possibly some unarrived parties are merely
                  catching up to current phase, in which case counts are
                  unaffected.                
                <return>
                    reconciled state                    
                </return>
            </javadoc>
            <method name="reconcileState" type="long" line="340">
                <declaration name="root" type="Phaser" line="341"/>
                <declaration name="s" type="long" line="342"/>
                <scope line="343">
                    <declaration name="phase" type="int" line="344"/>
                </scope>
            </method>
            <javadoc line="349">
                Creates a new phaser with no initially registered parties, no
                  parent, and initial phase number 0. Any thread using this
                  phaser will need to first register for it.                
            </javadoc>
            <method name="Phaser" type="constructor" line="354"/>
            <javadoc line="357">
                Creates a new phaser with the given number of registered
                  unarrived parties, no parent, and initial phase number 0.                
                <param>
                    parties the number of parties required to advance to the
                      next phase                    
                </param>
                <throws>
                    IllegalArgumentException if parties less than zero
                      or greater than the maximum number of parties supported                    
                </throws>
            </javadoc>
            <method name="Phaser" type="constructor" line="365">
                <params>
                    <param name="parties" type="int"/>
                </params>
            </method>
            <javadoc line="368">
                Equivalent to {@link #Phaser(Phaser,int) Phaser(parent, 0)}.                
                <param>
                    parent the parent phaser                    
                </param>
            </javadoc>
            <method name="Phaser" type="constructor" line="372">
                <params>
                    <param name="parent" type="Phaser"/>
                </params>
            </method>
            <javadoc line="375">
                Creates a new phaser with the given parent and number of
                  registered unarrived parties.  When the given parent is non-null
                  and the given number of parties is greater than zero, this
                  child phaser is registered with its parent.                
                <param>
                    parent the parent phaser                    
                </param>
                <param>
                    parties the number of parties required to advance to the
                      next phase                    
                </param>
                <throws>
                    IllegalArgumentException if parties less than zero
                      or greater than the maximum number of parties supported                    
                </throws>
            </javadoc>
            <method name="Phaser" type="constructor" line="386">
                <params>
                    <param name="parent" type="Phaser"/>
                    <param name="parties" type="int"/>
                </params>
                <declaration name="phase" type="int" line="388"/>
                <scope line="390">
                    <declaration name="root" type="Phaser" line="391"/>
                </scope>
                <scope line="397"/>
            </method>
            <javadoc line="404">
                Adds a new unarrived party to this phaser.  If an ongoing
                  invocation of {@link #onAdvance} is in progress, this method
                  may await its completion before returning.  If this phaser has
                  a parent, and this phaser previously had no registered parties,
                  this child phaser is also registered with its parent. If
                  this phaser is terminated, the attempt to register has
                  no effect, and a negative value is returned.                
                <return>
                    the arrival phase number to which this registration
                      applied.  If this value is negative, then this phaser has
                      terminated, in which case registration has no effect.                    
                </return>
                <throws>
                    IllegalStateException if attempting to register more
                      than the maximum supported number of parties                    
                </throws>
            </javadoc>
            <method name="register" type="int" line="418"/>
            <javadoc line="421">
                Adds the given number of new unarrived parties to this phaser.
                  If an ongoing invocation of {@link #onAdvance} is in progress,
                  this method may await its completion before returning.  If this
                  phaser has a parent, and the given number of parties is greater
                  than zero, and this phaser previously had no registered
                  parties, this child phaser is also registered with its parent.
                  If this phaser is terminated, the attempt to register has no
                  effect, and a negative value is returned.                
                <param>
                    parties the number of additional parties required to
                      advance to the next phase                    
                </param>
                <return>
                    the arrival phase number to which this registration
                      applied.  If this value is negative, then this phaser has
                      terminated, in which case registration has no effect.                    
                </return>
                <throws>
                    IllegalStateException if attempting to register more
                      than the maximum supported number of parties                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code parties < 0}                    
                </throws>
            </javadoc>
            <method name="bulkRegister" type="int" line="439">
                <params>
                    <param name="parties" type="int"/>
                </params>
            </method>
            <javadoc line="444">
                Arrives at this phaser, without waiting for others to arrive.
                  &lt;p&gt;It is a usage error for an unregistered party to invoke this
                  method.  However, this error may result in an {@codeIllegalStateException} only upon some subsequent operation on
                  this phaser, if ever.                
                <return>
                    the arrival phase number, or a negative value if terminated                    
                </return>
                <throws>
                    IllegalStateException if not terminated and the number
                      of unarrived parties would become negative                    
                </throws>
            </javadoc>
            <method name="arrive" type="int" line="453"/>
            <javadoc line="456">
                Arrives at this phaser and deregisters from it without waiting
                  for others to arrive. Deregistration reduces the number of
                  parties required to advance in future phases.  If this phaser
                  has a parent, and deregistration causes this phaser to have
                  zero parties, this phaser is also deregistered from its parent.
                  &lt;p&gt;It is a usage error for an unregistered party to invoke this
                  method.  However, this error may result in an {@codeIllegalStateException} only upon some subsequent operation on
                  this phaser, if ever.                
                <return>
                    the arrival phase number, or a negative value if terminated                    
                </return>
                <throws>
                    IllegalStateException if not terminated and the number
                      of registered or unarrived parties would become negative                    
                </throws>
            </javadoc>
            <method name="arriveAndDeregister" type="int" line="469"/>
            <javadoc line="472">
                Arrives at this phaser and awaits others. Equivalent in effect
                  to {@code awaitAdvance(arrive())}.  If you need to await with
                  interruption or timeout, you can arrange this with an analogous
                  construction using one of the other forms of the {@codeawaitAdvance} method.  If instead you need to deregister upon
                  arrival, use {@code awaitAdvance(arriveAndDeregister())}.
                  &lt;p&gt;It is a usage error for an unregistered party to invoke this
                  method.  However, this error may result in an {@codeIllegalStateException} only upon some subsequent operation on
                  this phaser, if ever.                
                <return>
                    the arrival phase number, or the (negative){@linkplain #getPhase() current phase} if terminated                    
                </return>
                <throws>
                    IllegalStateException if not terminated and the number
                      of unarrived parties would become negative                    
                </throws>
            </javadoc>
            <method name="arriveAndAwaitAdvance" type="int" line="485">
                <declaration name="root" type="Phaser" line="486"/>
                <scope line="487">
                    <declaration name="s" type="long" line="488"/>
                    <declaration name="phase" type="int" line="489"/>
                    <declaration name="counts" type="int" line="490"/>
                    <declaration name="unarrived" type="int" line="491"/>
                    <scope line="493"/>
                    <scope line="496">
                        <declaration name="n" type="long" line="499"/>
                        <declaration name="nextUnarrived" type="int" line="500"/>
                        <declaration name="nextPhase" type="int" line="504"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="512">
                Awaits the phase of this phaser to advance from the given phase
                  value, returning immediately if the current phase is not equal
                  to the given phase value or this phaser is terminated.                
                <param>
                    phase an arrival phase number, or negative value if
                      terminated; this argument is normally the value returned by a
                      previous call to {@code arrive} or {@code arriveAndDeregister}.                    
                </param>
                <return>
                    the next arrival phase number, or the argument if it is
                      negative, or the (negative) {@linkplain #getPhase() current phase}if terminated                    
                </return>
            </javadoc>
            <method name="awaitAdvance" type="int" line="522">
                <params>
                    <param name="phase" type="int"/>
                </params>
                <declaration name="root" type="Phaser" line="523"/>
                <declaration name="s" type="long" line="524"/>
                <declaration name="p" type="int" line="525"/>
            </method>
            <javadoc line="530">
                Awaits the phase of this phaser to advance from the given phase
                  value, throwing {@code InterruptedException} if interrupted
                  while waiting, or returning immediately if the current phase is
                  not equal to the given phase value or this phaser is
                  terminated.                
                <param>
                    phase an arrival phase number, or negative value if
                      terminated; this argument is normally the value returned by a
                      previous call to {@code arrive} or {@code arriveAndDeregister}.                    
                </param>
                <return>
                    the next arrival phase number, or the argument if it is
                      negative, or the (negative) {@linkplain #getPhase() current phase}if terminated                    
                </return>
                <throws>
                    InterruptedException if thread interrupted while waiting                    
                </throws>
            </javadoc>
            <method name="awaitAdvanceInterruptibly" type="int" line="543">
                <params>
                    <param name="phase" type="int"/>
                </params>
                <declaration name="root" type="Phaser" line="544"/>
                <declaration name="s" type="long" line="545"/>
                <declaration name="p" type="int" line="546"/>
                <scope line="548">
                    <declaration name="node" type="QNode" line="549"/>
                </scope>
            </method>
            <javadoc line="555">
                Awaits the phase of this phaser to advance from the given phase
                  value or the given timeout to elapse, throwing {@codeInterruptedException} if interrupted while waiting, or
                  returning immediately if the current phase is not equal to the
                  given phase value or this phaser is terminated.                
                <param>
                    phase an arrival phase number, or negative value if
                      terminated; this argument is normally the value returned by a
                      previous call to {@code arrive} or {@code arriveAndDeregister}.                    
                </param>
                <param>
                    timeout how long to wait before giving up, in units of{@code unit}                    
                </param>
                <param>
                    unit a {@code TimeUnit} determining how to interpret the{@code timeout} parameter                    
                </param>
                <return>
                    the next arrival phase number, or the argument if it is
                      negative, or the (negative) {@linkplain #getPhase() current phase}if terminated                    
                </return>
                <throws>
                    InterruptedException if thread interrupted while waiting                    
                </throws>
                <throws>
                    TimeoutException if timed out while waiting                    
                </throws>
            </javadoc>
            <method name="awaitAdvanceInterruptibly" type="int" line="570">
                <params>
                    <param name="phase" type="int"/>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="nanos" type="long" line="571"/>
                <declaration name="root" type="Phaser" line="572"/>
                <declaration name="s" type="long" line="573"/>
                <declaration name="p" type="int" line="574"/>
                <scope line="576">
                    <declaration name="node" type="QNode" line="577"/>
                </scope>
            </method>
            <javadoc line="584">
                Forces this phaser to enter termination state.  Counts of
                  registered parties are unaffected.  If this phaser is a member
                  of a tiered set of phasers, then all of the phasers in the set
                  are terminated.  If this phaser is already terminated, this
                  method has no effect.  This method may be useful for
                  coordinating recovery after one or more tasks encounter
                  unexpected exceptions.                
            </javadoc>
            <method name="forceTermination" type="void" line="593">
                <declaration name="root" type="Phaser" line="594"/>
                <declaration name="s" type="long" line="595"/>
                <scope line="596">
                    <scope line="597"/>
                </scope>
            </method>
            <javadoc line="604">
                Returns the current phase number. The maximum phase number is{@code Integer.MAX_VALUE}, after which it restarts at
                  zero. Upon termination, the phase number is negative,
                  in which case the prevailing phase prior to termination
                  may be obtained via {@code getPhase() + Integer.MIN_VALUE}.                
                <return>
                    the phase number, or a negative value if terminated                    
                </return>
            </javadoc>
            <method name="getPhase" type="int" line="611"/>
            <javadoc line="614">
                Returns the number of parties registered at this phaser.                
                <return>
                    the number of parties                    
                </return>
            </javadoc>
            <method name="getRegisteredParties" type="int" line="618"/>
            <javadoc line="621">
                Returns the number of registered parties that have arrived at
                  the current phase of this phaser. If this phaser has terminated,
                  the returned value is meaningless and arbitrary.                
                <return>
                    the number of arrived parties                    
                </return>
            </javadoc>
            <method name="getArrivedParties" type="int" line="627"/>
            <javadoc line="630">
                Returns the number of registered parties that have not yet
                  arrived at the current phase of this phaser. If this phaser has
                  terminated, the returned value is meaningless and arbitrary.                
                <return>
                    the number of unarrived parties                    
                </return>
            </javadoc>
            <method name="getUnarrivedParties" type="int" line="636"/>
            <javadoc line="639">
                Returns the parent of this phaser, or {@code null} if none.                
                <return>
                    the parent of this phaser, or {@code null} if none                    
                </return>
            </javadoc>
            <method name="getParent" type="Phaser" line="643"/>
            <javadoc line="646">
                Returns the root ancestor of this phaser, which is the same as
                  this phaser if it has no parent.                
                <return>
                    the root ancestor of this phaser                    
                </return>
            </javadoc>
            <method name="getRoot" type="Phaser" line="651"/>
            <javadoc line="654">
                Returns {@code true} if this phaser has been terminated.                
                <return>
                    {@code true} if this phaser has been terminated                    
                </return>
            </javadoc>
            <method name="isTerminated" type="boolean" line="658"/>
            <javadoc line="661">
                Overridable method to perform an action upon impending phase
                  advance, and to control termination. This method is invoked
                  upon arrival of the party advancing this phaser (when all other
                  waiting parties are dormant).  If this method returns {@codetrue}, this phaser will be set to a final termination state
                  upon advance, and subsequent calls to {@link #isTerminated}will return true. Any (unchecked) Exception or Error thrown by
                  an invocation of this method is propagated to the party
                  attempting to advance this phaser, in which case no advance
                  occurs.
                  &lt;p&gt;The arguments to this method provide the state of the phaser
                  prevailing for the current transition.  The effects of invoking
                  arrival, registration, and waiting methods on this phaser from
                  within {@code onAdvance} are unspecified and should not be
                  relied on.
                  &lt;p&gt;If this phaser is a member of a tiered set of phasers, then{@code onAdvance} is invoked only for its root phaser on each
                  advance.
                  &lt;p&gt;To support the most common use cases, the default
                  implementation of this method returns {@code true} when the
                  number of registered parties has become zero as the result of a
                  party invoking {@code arriveAndDeregister}.  You can disable
                  this behavior, thus enabling continuation upon future
                  registrations, by overriding this method to always return{@code false}:
                  &lt;pre&gt; {@code}Phaser phaser = new Phaser() 
                  protected boolean onAdvance(int phase, int parties) { return false; }
                  }}&lt;/pre&gt;                
                <param>
                    phase the current phase number on entry to this method,
                      before this phaser is advanced                    
                </param>
                <param>
                    registeredParties the current number of registered parties                    
                </param>
                <return>
                    {@code true} if this phaser should terminate                    
                </return>
            </javadoc>
            <method name="onAdvance" type="boolean" line="691">
                <params>
                    <param name="phase" type="int"/>
                    <param name="registeredParties" type="int"/>
                </params>
            </method>
            <javadoc line="694">
                Returns a string identifying this phaser, as well as its
                  state.  The state, in brackets, includes the String {@code&quot;phase = &quot;} followed by the phase number, {@code &quot;parties = &quot;}followed by the number of registered parties, and {@code&quot;arrived = &quot;} followed by the number of arrived parties.                
                <return>
                    a string identifying this phaser, as well as its state                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="699"/>
            <javadoc line="702">
                Implementation of toString and string-based error messages                
            </javadoc>
            <method name="stateToString" type="String" line="705">
                <params>
                    <param name="s" type="long"/>
                </params>
            </method>
            <javadoc line="708">
                Removes and signals threads from queue for phase.                
            </javadoc>
            <method name="releaseWaiters" type="void" line="711">
                <params>
                    <param name="phase" type="int"/>
                </params>
                <declaration name="q" type="QNode" line="712"/>
                <declaration name="t" type="Thread" line="713"/>
                <declaration name="head" type="AtomicReference&lt;QNode&gt;" line="714"/>
                <scope line="715">
                    <scope line="716"/>
                </scope>
            </method>
            <javadoc line="722">
                Variant of releaseWaiters that additionally tries to remove any
                  nodes no longer waiting for advance due to timeout or
                  interrupt. Currently, nodes are removed only if they are at
                  head of queue, which suffices to reduce memory footprint in
                  most usages.                
                <return>
                    current phase on exit                    
                </return>
            </javadoc>
            <method name="abortWait" type="int" line="730">
                <params>
                    <param name="phase" type="int"/>
                </params>
                <declaration name="head" type="AtomicReference&lt;QNode&gt;" line="731"/>
                <scope line="732">
                    <declaration name="t" type="Thread" line="733"/>
                    <declaration name="q" type="QNode" line="734"/>
                    <declaration name="p" type="int" line="735"/>
                    <scope line="737"/>
                </scope>
            </method>
            <declaration name="NCPU" type="int" line="743"/>
            <javadoc line="743">
                The number of CPUs, for spin control                
            </javadoc>
            <declaration name="SPINS_PER_ARRIVAL" type="int" line="747"/>
            <javadoc line="747">
                The number of times to spin before blocking while waiting for
                  advance, per arrival while waiting. On multiprocessors, fully
                  blocking and waking up a large number of threads all at once is
                  usually a very slow process, so we use rechargeable spins to
                  avoid it when threads regularly arrive: When a thread in
                  internalAwaitAdvance notices another arrival before blocking,
                  and there appear to be enough CPUs available, it spins
                  SPINS_PER_ARRIVAL more times before blocking. The value trades
                  off good-citizenship vs big unnecessary slowdowns.                
            </javadoc>
            <javadoc line="759">
                Possibly blocks and waits for phase to advance unless aborted.
                  Call only from root node.                
                <param>
                    phase current phase                    
                </param>
                <param>
                    node if non-null, the wait node to track interrupt and timeout;
                      if null, denotes noninterruptible wait                    
                </param>
                <return>
                    current phase                    
                </return>
            </javadoc>
            <method name="internalAwaitAdvance" type="int" line="767">
                <params>
                    <param name="phase" type="int"/>
                    <param name="node" type="QNode"/>
                </params>
                <declaration name="queued" type="boolean" line="769"/>
                <declaration name="lastUnarrived" type="int" line="770"/>
                <declaration name="spins" type="int" line="771"/>
                <declaration name="s" type="long" line="772"/>
                <declaration name="p" type="int" line="773"/>
                <scope line="774">
                    <scope line="775">
                        <declaration name="unarrived" type="int" line="776"/>
                        <declaration name="interrupted" type="boolean" line="778"/>
                        <scope line="779"/>
                    </scope>
                    <scope line="785">
                        <declaration name="head" type="AtomicReference&lt;QNode&gt;" line="786"/>
                        <declaration name="q" type="QNode" line="787"/>
                    </scope>
                    <scope line="790">
                        <scope line="791"/>
                        <scope line="794"/>
                    </scope>
                </scope>
                <scope line="799"/>
            </method>
            <class name="QNode" line="807">
                <implements interface="ForkJoinPool.ManagedBlocker"/>
                <javadoc line="807">
                    Wait nodes for Treiber stack representing wait queue                    
                </javadoc>
                <declaration name="phaser" type="Phaser" line="811"/>
                <declaration name="phase" type="int" line="812"/>
                <declaration name="interruptible" type="boolean" line="813"/>
                <declaration name="timed" type="boolean" line="814"/>
                <declaration name="wasInterrupted" type="boolean" line="815"/>
                <declaration name="nanos" type="long" line="816"/>
                <declaration name="lastTime" type="long" line="817"/>
                <declaration name="thread" type="Thread" line="818"/>
                <declaration name="next" type="QNode" line="819"/>
                <method name="QNode" type="constructor" line="820">
                    <params>
                        <param name="phaser" type="Phaser"/>
                        <param name="phase" type="int"/>
                        <param name="interruptible" type="boolean"/>
                        <param name="timed" type="boolean"/>
                        <param name="nanos" type="long"/>
                    </params>
                </method>
                <method name="isReleasable" type="boolean" line="829">
                    <scope line="831"/>
                    <scope line="836"/>
                    <scope line="840">
                        <scope line="841">
                            <declaration name="now" type="long" line="842"/>
                        </scope>
                        <scope line="846"/>
                    </scope>
                </method>
                <method name="block" type="boolean" line="853"/>
            </class>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="860"/>
            <declaration name="stateOffset" type="long" line="861"/>
            <scope line="862">
                <scope line="863">
                    <declaration name="k" type="Class" line="865"/>
                </scope>
                <scope line="868"/>
            </scope>
        </class>
    </source>