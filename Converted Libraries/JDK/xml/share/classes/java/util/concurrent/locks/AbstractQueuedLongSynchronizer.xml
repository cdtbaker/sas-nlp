<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent.locks">
        <import package="java.util"/>
        <import package="java.util.concurrent"/>
        <import package="java.util.concurrent.atomic"/>
        <import package="sun.misc.Unsafe"/>
        <class name="AbstractQueuedLongSynchronizer" line="42">
            <extends class="AbstractOwnableSynchronizer"/>
            <comment line="66">
                To keep sources in sync, the remainder of this source file is
                exactly cloned from AbstractQueuedSynchronizer, replacing class
                name and changing ints related with sync state to longs. Please
                keep it that way.                
            </comment>
            <comment line="347">
                Queuing utilities                
            </comment>
            <comment line="511">
                Utilities for various versions of acquire                
            </comment>
            <comment line="616">
                Various flavors of acquire, varying in exclusiveshared and
                 control modes.  Each is mostly the same, but annoyingly
                 different.  Only a little bit of factoring is possible due to
                 interactions of exception mechanics (including ensuring that we
                 cancel if tryAcquire throws exception) and other control, at
                 least not without hurting performance too much.                
            </comment>
            <comment line="824">
                Main exported methods                
            </comment>
            <comment line="1125">
                Queue inspection methods                
            </comment>
            <comment line="1301">
                Instrumentation and monitoring methods                
            </comment>
            <comment line="1400">
                Internal support methods for Conditions                
            </comment>
            <comment line="1513">
                Instrumentation methods for conditions                
            </comment>
            <implements interface="java.io.Serializable"/>
            <javadoc line="42">
                A version of {@link AbstractQueuedSynchronizer} in
                  which synchronization state is maintained as a &lt;tt&gt;long&lt;/tt&gt;.
                  This class has exactly the same structure, properties, and methods
                  as &lt;tt&gt;AbstractQueuedSynchronizer&lt;/tt&gt; with the exception
                  that all state-related parameters and results are defined
                  as &lt;tt&gt;long&lt;/tt&gt; rather than &lt;tt&gt;int&lt;/tt&gt;. This class
                  may be useful when creating synchronizers such as
                  multilevel locks and barriers that require
                  64 bits of state.
                  &lt;p&gt;See {@link AbstractQueuedSynchronizer} for usage
                  notes and examples.                
                <since>
                    1.6                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="63"/>
            <javadoc line="72">
                Creates a new &lt;tt&gt;AbstractQueuedLongSynchronizer&lt;/tt&gt; instance
                  with initial synchronization state of zero.                
            </javadoc>
            <method name="AbstractQueuedLongSynchronizer" type="constructor" line="76"/>
            <class name="Node" line="78">
                <comment line="1624">
                    Internal methods                    
                </comment>
                <comment line="1709">
                    public methods                    
                </comment>
                <comment line="1767">
                    For interruptible waits, we need to track whether to throw
                     InterruptedException, if interrupted while blocked on
                     condition, versus reinterrupt current thread, if
                     interrupted while blocked waiting to re-acquire.                    
                </comment>
                <comment line="1972">
                    support for instrumentation                    
                </comment>
                <javadoc line="78">
                    Wait queue node class.
                      &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and
                      Hagersten) lock queue. CLH locks are normally used for
                      spinlocks.  We instead use them for blocking synchronizers, but
                      use the same basic tactic of holding some of the control
                      information about a thread in the predecessor of its node.  A
                      &quot;status&quot; field in each node keeps track of whether a thread
                      should block.  A node is signalled when its predecessor
                      releases.  Each node of the queue otherwise serves as a
                      specific-notification-style monitor holding a single waiting
                      thread. The status field does NOT control whether threads are
                      granted locks etc though.  A thread may try to acquire if it is
                      first in the queue. But being first does not guarantee success;
                      it only gives the right to contend.  So the currently released
                      contender thread may need to rewait.
                      &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new
                      tail. To dequeue, you just set the head field.
                      &lt;pre&gt;
                      +------+  prev +-----+       +-----+
                      head |      | &lt;---- |     | &lt;---- |     |  tail
                      +------+       +-----+       +-----+
                      &lt;/pre&gt;
                      &lt;p&gt;Insertion into a CLH queue requires only a single atomic
                      operation on &quot;tail&quot;, so there is a simple atomic point of
                      demarcation from unqueued to queued. Similarly, dequeing
                      involves only updating the &quot;head&quot;. However, it takes a bit
                      more work for nodes to determine who their successors are,
                      in part to deal with possible cancellation due to timeouts
                      and interrupts.
                      &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly
                      needed to handle cancellation. If a node is cancelled, its
                      successor is (normally) relinked to a non-cancelled
                      predecessor. For explanation of similar mechanics in the case
                      of spin locks, see the papers by Scott and Scherer at
                      http://www.cs.rochester.edu/u/scott/synchronization/
                      &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics.
                      The thread id for each node is kept in its own node, so a
                      predecessor signals the next node to wake up by traversing
                      next link to determine which thread it is.  Determination of
                      successor must avoid races with newly queued nodes to set
                      the &quot;next&quot; fields of their predecessors.  This is solved
                      when necessary by checking backwards from the atomically
                      updated &quot;tail&quot; when a node&apos;s successor appears to be null.
                      (Or, said differently, the next-links are an optimization
                      so that we don&apos;t usually need a backward scan.)
                      &lt;p&gt;Cancellation introduces some conservatism to the basic
                      algorithms.  Since we must poll for cancellation of other
                      nodes, we can miss noticing whether a cancelled node is
                      ahead or behind us. This is dealt with by always unparking
                      successors upon cancellation, allowing them to stabilize on
                      a new predecessor, unless we can identify an uncancelled
                      predecessor who will carry this responsibility.
                      &lt;p&gt;CLH queues need a dummy header node to get started. But
                      we don&apos;t create them on construction, because it would be wasted
                      effort if there is never contention. Instead, the node
                      is constructed and head and tail pointers are set upon first
                      contention.
                      &lt;p&gt;Threads waiting on Conditions use the same nodes, but
                      use an additional link. Conditions only need to link nodes
                      in simple (non-concurrent) linked queues because they are
                      only accessed when exclusively held.  Upon await, a node is
                      inserted into a condition queue.  Upon signal, the node is
                      transferred to the main queue.  A special value of status
                      field is used to mark which queue a node is on.
                      &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill
                      Scherer and Michael Scott, along with members of JSR-166
                      expert group, for helpful ideas, discussions, and critiques
                      on the design of this class.                    
                </javadoc>
                <declaration name="SHARED" type="Node" line="158"/>
                <javadoc line="158">
                    Marker to indicate a node is waiting in shared mode                    
                </javadoc>
                <declaration name="EXCLUSIVE" type="Node" line="160"/>
                <javadoc line="160">
                    Marker to indicate a node is waiting in exclusive mode                    
                </javadoc>
                <declaration name="CANCELLED" type="int" line="163"/>
                <javadoc line="163">
                    waitStatus value to indicate thread has cancelled                    
                </javadoc>
                <declaration name="SIGNAL" type="int" line="165"/>
                <javadoc line="165">
                    waitStatus value to indicate successor&apos;s thread needs unparking                    
                </javadoc>
                <declaration name="CONDITION" type="int" line="167"/>
                <javadoc line="167">
                    waitStatus value to indicate thread is waiting on condition                    
                </javadoc>
                <declaration name="PROPAGATE" type="int" line="169"/>
                <javadoc line="169">
                    waitStatus value to indicate the next acquireShared should
                      unconditionally propagate                    
                </javadoc>
                <declaration name="waitStatus" type="int" line="175"/>
                <javadoc line="175">
                    Status field, taking on only the values:
                      SIGNAL:     The successor of this node is (or will soon be)
                      blocked (via park), so the current node must
                      unpark its successor when it releases or
                      cancels. To avoid races, acquire methods must
                      first indicate they need a signal,
                      then retry the atomic acquire, and then,
                      on failure, block.
                      CANCELLED:  This node is cancelled due to timeout or interrupt.
                      Nodes never leave this state. In particular,
                      a thread with cancelled node never again blocks.
                      CONDITION:  This node is currently on a condition queue.
                      It will not be used as a sync queue node
                      until transferred, at which time the status
                      will be set to 0. (Use of this value here has
                      nothing to do with the other uses of the
                      field, but simplifies mechanics.)
                      PROPAGATE:  A releaseShared should be propagated to other
                      nodes. This is set (for head node only) in
                      doReleaseShared to ensure propagation
                      continues, even if other operations have
                      since intervened.
                      0:          None of the above
                      The values are arranged numerically to simplify use.
                      Non-negative values mean that a node doesn&apos;t need to
                      signal. So, most code doesn&apos;t need to check for particular
                      values, just for sign.
                      The field is initialized to 0 for normal sync nodes, and
                      CONDITION for condition nodes.  It is modified using CAS
                      (or when possible, unconditional volatile writes).                    
                </javadoc>
                <declaration name="prev" type="Node" line="211"/>
                <javadoc line="211">
                    Link to predecessor node that current node/thread relies on
                      for checking waitStatus. Assigned during enqueing, and nulled
                      out (for sake of GC) only upon dequeuing.  Also, upon
                      cancellation of a predecessor, we short-circuit while
                      finding a non-cancelled one, which will always exist
                      because the head node is never cancelled: A node becomes
                      head only as a result of successful acquire. A
                      cancelled thread never succeeds in acquiring, and a thread only
                      cancels itself, not any other node.                    
                </javadoc>
                <declaration name="next" type="Node" line="224"/>
                <javadoc line="224">
                    Link to the successor node that the current node/thread
                      unparks upon release. Assigned during enqueuing, adjusted
                      when bypassing cancelled predecessors, and nulled out (for
                      sake of GC) when dequeued.  The enq operation does not
                      assign next field of a predecessor until after attachment,
                      so seeing a null next field does not necessarily mean that
                      node is at end of queue. However, if a next field appears
                      to be null, we can scan prev&apos;s from the tail to
                      double-check.  The next field of cancelled nodes is set to
                      point to the node itself instead of null, to make life
                      easier for isOnSyncQueue.                    
                </javadoc>
                <declaration name="thread" type="Thread" line="239"/>
                <javadoc line="239">
                    The thread that enqueued this node.  Initialized on
                      construction and nulled out after use.                    
                </javadoc>
                <declaration name="nextWaiter" type="Node" line="245"/>
                <javadoc line="245">
                    Link to next node waiting on condition, or the special
                      value SHARED.  Because condition queues are accessed only
                      when holding in exclusive mode, we just need a simple
                      linked queue to hold nodes while they are waiting on
                      conditions. They are then transferred to the queue to
                      re-acquire. And because conditions can only be exclusive,
                      we save a field by using special value to indicate shared
                      mode.                    
                </javadoc>
                <javadoc line="257">
                    Returns true if node is waiting in shared mode                    
                </javadoc>
                <method name="isShared" type="boolean" line="260"/>
                <javadoc line="264">
                    Returns previous node, or throws NullPointerException if null.
                      Use when predecessor cannot be null.  The null check could
                      be elided, but is present to help the VM.                    
                    <return>
                        the predecessor of this node                        
                    </return>
                </javadoc>
                <method name="predecessor" type="Node" line="271">
                    <declaration name="p" type="Node" line="272"/>
                </method>
                <method name="Node" type="constructor" line="279"/>
                <method name="Node" type="constructor" line="282">
                    <params>
                        <param name="thread" type="Thread"/>
                        <param name="mode" type="Node"/>
                    </params>
                </method>
                <method name="Node" type="constructor" line="287">
                    <params>
                        <param name="thread" type="Thread"/>
                        <param name="waitStatus" type="int"/>
                    </params>
                </method>
            </class>
            <declaration name="head" type="Node" line="293"/>
            <javadoc line="293">
                Head of the wait queue, lazily initialized.  Except for
                  initialization, it is modified only via method setHead.  Note:
                  If head exists, its waitStatus is guaranteed not to be
                  CANCELLED.                
            </javadoc>
            <declaration name="tail" type="Node" line="301"/>
            <javadoc line="301">
                Tail of the wait queue, lazily initialized.  Modified only via
                  method enq to add new wait node.                
            </javadoc>
            <declaration name="state" type="long" line="307"/>
            <javadoc line="307">
                The synchronization state.                
            </javadoc>
            <javadoc line="312">
                Returns the current value of synchronization state.
                  This operation has memory semantics of a &lt;tt&gt;volatile&lt;/tt&gt; read.                
                <return>
                    current state value                    
                </return>
            </javadoc>
            <method name="getState" type="long" line="317"/>
            <javadoc line="321">
                Sets the value of synchronization state.
                  This operation has memory semantics of a &lt;tt&gt;volatile&lt;/tt&gt; write.                
                <param>
                    newState the new state value                    
                </param>
            </javadoc>
            <method name="setState" type="void" line="326">
                <params>
                    <param name="newState" type="long"/>
                </params>
            </method>
            <javadoc line="330">
                Atomically sets synchronization state to the given updated
                  value if the current state value equals the expected value.
                  This operation has memory semantics of a &lt;tt&gt;volatile&lt;/tt&gt; read
                  and write.                
                <param>
                    expect the expected value                    
                </param>
                <param>
                    update the new value                    
                </param>
                <return>
                    true if successful. False return indicates that the actual
                      value was not equal to the expected value.                    
                </return>
            </javadoc>
            <method name="compareAndSetState" type="boolean" line="341">
                <params>
                    <param name="expect" type="long"/>
                    <param name="update" type="long"/>
                </params>
                <comment line="343">
                    See below for intrinsics setup to support this                    
                </comment>
            </method>
            <declaration name="spinForTimeoutThreshold" type="long" line="348"/>
            <javadoc line="348">
                The number of nanoseconds for which it is faster to spin
                  rather than to use timed park. A rough estimate suffices
                  to improve responsiveness with very short timeouts.                
            </javadoc>
            <javadoc line="355">
                Inserts node into queue, initializing if necessary. See picture above.                
                <param>
                    node the node to insert                    
                </param>
                <return>
                    node&apos;s predecessor                    
                </return>
            </javadoc>
            <method name="enq" type="Node" line="360">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <comment line="364">
                    Must initialize                    
                </comment>
                <scope line="361">
                    <declaration name="t" type="Node" line="362"/>
                    <scope line="363"/>
                    <scope line="366">
                        <scope line="368"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="376">
                Creates and enqueues node for current thread and given mode.                
                <param>
                    mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared                    
                </param>
                <return>
                    the new node                    
                </return>
            </javadoc>
            <method name="addWaiter" type="Node" line="382">
                <params>
                    <param name="mode" type="Node"/>
                </params>
                <comment line="385">
                    Try the fast path of enq; backup to full enq on failure                    
                </comment>
                <declaration name="node" type="Node" line="383"/>
                <declaration name="pred" type="Node" line="385"/>
                <scope line="386">
                    <scope line="388"/>
                </scope>
            </method>
            <javadoc line="397">
                Sets head of queue to be node, thus dequeuing. Called only by
                  acquire methods.  Also nulls out unused fields for sake of GC
                  and to suppress unnecessary signals and traversals.                
                <param>
                    node the node                    
                </param>
            </javadoc>
            <method name="setHead" type="void" line="404">
                <params>
                    <param name="node" type="Node"/>
                </params>
            </method>
            <javadoc line="410">
                Wakes up node&apos;s successor, if one exists.                
                <param>
                    node the node                    
                </param>
            </javadoc>
            <method name="unparkSuccessor" type="void" line="415">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <comment line="417">
                    If status is negative (i.e., possibly needing signal) try
                     to clear in anticipation of signalling.  It is OK if this
                     fails or if status is changed by waiting thread.                    
                </comment>
                <comment line="426">
                    Thread to unpark is held in successor, which is normally
                     just the next node.  But if cancelled or apparently null,
                     traverse backwards from tail to find the actual
                     non-cancelled successor.                    
                </comment>
                <declaration name="ws" type="int" line="421"/>
                <declaration name="s" type="Node" line="431"/>
                <scope line="432"/>
            </method>
            <javadoc line="442">
                Release action for shared mode -- signal successor and ensure
                  propagation. (Note: For exclusive mode, release just amounts
                  to calling unparkSuccessor of head if it needs signal.)                
            </javadoc>
            <method name="doReleaseShared" type="void" line="447">
                <comment line="449">
                    Ensure that a release propagates, even if there are other
                     in-progress acquiresreleases.  This proceeds in the usual
                     way of trying to unparkSuccessor of head if it needs
                     signal. But if it does not, status is set to PROPAGATE to
                     ensure that upon release, propagation continues.
                     Additionally, we must loop in case a new node is added
                     while we are doing this. Also, unlike other uses of
                     unparkSuccessor, we need to know if CAS to reset status
                     fails, if so rechecking.                    
                </comment>
                <comment line="466">
                    loop to recheck cases                    
                </comment>
                <comment line="471">
                    loop on failed CAS                    
                </comment>
                <comment line="473">
                    loop if head changed                    
                </comment>
                <scope line="459">
                    <declaration name="h" type="Node" line="460"/>
                    <scope line="461">
                        <declaration name="ws" type="int" line="462"/>
                        <scope line="463"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="477">
                Sets head of queue, and checks if successor may be waiting
                  in shared mode, if so propagating if either propagate &gt; 0 or
                  PROPAGATE status was set.                
                <param>
                    node the node                    
                </param>
                <param>
                    propagate the return value from a tryAcquireShared                    
                </param>
            </javadoc>
            <method name="setHeadAndPropagate" type="void" line="485">
                <params>
                    <param name="node" type="Node"/>
                    <param name="propagate" type="long"/>
                </params>
                <comment line="487">
                    Record old head for check below                    
                </comment>
                <comment line="489">
                    Try to signal next queued node if:
                       Propagation was indicated by caller,
                         or was recorded (as h.waitStatus) by a previous operation
                         (note: this uses sign-check of waitStatus because
                          PROPAGATE status may transition to SIGNAL.)
                     and
                       The next node is waiting in shared mode,
                         or we don&apos;t know, because it appears null
                    
                     The conservatism in both of these checks may cause
                     unnecessary wake-ups, but only when there are multiple
                     racing acquiresreleases, so most need signals now or soon
                     anyway.                    
                </comment>
                <declaration name="h" type="Node" line="486"/>
                <scope line="503">
                    <declaration name="s" type="Node" line="504"/>
                </scope>
            </method>
            <javadoc line="512">
                Cancels an ongoing attempt to acquire.                
                <param>
                    node the node                    
                </param>
            </javadoc>
            <method name="cancelAcquire" type="void" line="517">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <comment line="519">
                    Ignore if node doesn&apos;t exist                    
                </comment>
                <comment line="525">
                    Skip cancelled predecessors                    
                </comment>
                <comment line="530">
                    predNext is the apparent node to unsplice. CASes below will
                     fail if not, in which case, we lost race vs another cancel
                     or signal, so no further action is necessary.                    
                </comment>
                <comment line="535">
                    Can use unconditional write instead of CAS here.
                     After this atomic step, other Nodes can skip past us.
                     Before, we are free of interference from other threads.                    
                </comment>
                <comment line="540">
                    If we are the tail, remove ourselves.                    
                </comment>
                <comment line="544">
                    If successor needs signal, try to set pred&apos;s next-link
                     so it will get one. Otherwise wake it up to propagate.                    
                </comment>
                <comment line="558">
                    help GC                    
                </comment>
                <declaration name="pred" type="Node" line="525"/>
                <declaration name="predNext" type="Node" line="532"/>
                <scope line="540"/>
                <scope line="542">
                    <declaration name="ws" type="int" line="545"/>
                    <scope line="549">
                        <declaration name="next" type="Node" line="550"/>
                    </scope>
                    <scope line="553"/>
                </scope>
            </method>
            <javadoc line="561">
                Checks and updates status for a node that failed to acquire.
                  Returns true if thread should block. This is the main signal
                  control in all acquire loops.  Requires that pred == node.prev                
                <param>
                    pred node&apos;s predecessor holding status                    
                </param>
                <param>
                    node the node                    
                </param>
                <return>
                    {@code true} if thread should block                    
                </return>
            </javadoc>
            <method name="shouldParkAfterFailedAcquire" type="boolean" line="570">
                <params>
                    <param name="pred" type="Node"/>
                    <param name="node" type="Node"/>
                </params>
                <comment line="574">
                    This node has already set status asking a release
                     to signal it, so it can safely park.                    
                </comment>
                <comment line="580">
                    Predecessor was cancelled. Skip over predecessors and
                     indicate retry.                    
                </comment>
                <comment line="589">
                    waitStatus must be 0 or PROPAGATE.  Indicate that we
                     need a signal, but don&apos;t park yet.  Caller will need to
                     retry to make sure it cannot acquire before parking.                    
                </comment>
                <declaration name="ws" type="int" line="571"/>
                <scope line="578">
                    <scope line="583"/>
                </scope>
                <scope line="587"/>
            </method>
            <javadoc line="598">
                Convenience method to interrupt current thread.                
            </javadoc>
            <method name="selfInterrupt" type="void" line="601"/>
            <javadoc line="605">
                Convenience method to park and then check if interrupted                
                <return>
                    {@code true} if interrupted                    
                </return>
            </javadoc>
            <method name="parkAndCheckInterrupt" type="boolean" line="610"/>
            <javadoc line="624">
                Acquires in exclusive uninterruptible mode for thread already in
                  queue. Used by condition wait methods as well as acquire.                
                <param>
                    node the node                    
                </param>
                <param>
                    arg the acquire argument                    
                </param>
                <return>
                    {@code true} if interrupted while waiting                    
                </return>
            </javadoc>
            <method name="acquireQueued" type="boolean" line="632">
                <params>
                    <param name="node" type="Node"/>
                    <param name="arg" type="long"/>
                </params>
                <comment line="641">
                    help GC                    
                </comment>
                <declaration name="failed" type="boolean" line="633"/>
                <scope line="634">
                    <declaration name="interrupted" type="boolean" line="635"/>
                    <scope line="636">
                        <declaration name="p" type="Node" line="637"/>
                        <scope line="638"/>
                    </scope>
                </scope>
                <scope line="648"/>
            </method>
            <javadoc line="654">
                Acquires in exclusive interruptible mode.                
                <param>
                    arg the acquire argument                    
                </param>
            </javadoc>
            <method name="doAcquireInterruptibly" type="void" line="659">
                <params>
                    <param name="arg" type="long"/>
                </params>
                <comment line="668">
                    help GC                    
                </comment>
                <declaration name="node" type="Node" line="660"/>
                <declaration name="failed" type="boolean" line="661"/>
                <scope line="662">
                    <scope line="663">
                        <declaration name="p" type="Node" line="664"/>
                        <scope line="665"/>
                    </scope>
                </scope>
                <scope line="675"/>
            </method>
            <javadoc line="681">
                Acquires in exclusive timed mode.                
                <param>
                    arg the acquire argument                    
                </param>
                <param>
                    nanosTimeout max wait time                    
                </param>
                <return>
                    {@code true} if acquired                    
                </return>
            </javadoc>
            <method name="doAcquireNanos" type="boolean" line="689">
                <params>
                    <param name="arg" type="long"/>
                    <param name="nanosTimeout" type="long"/>
                </params>
                <comment line="699">
                    help GC                    
                </comment>
                <declaration name="lastTime" type="long" line="690"/>
                <declaration name="node" type="Node" line="691"/>
                <declaration name="failed" type="boolean" line="692"/>
                <scope line="693">
                    <scope line="694">
                        <declaration name="p" type="Node" line="695"/>
                        <scope line="696"/>
                        <declaration name="now" type="long" line="707"/>
                    </scope>
                </scope>
                <scope line="713"/>
            </method>
            <javadoc line="719">
                Acquires in shared uninterruptible mode.                
                <param>
                    arg the acquire argument                    
                </param>
            </javadoc>
            <method name="doAcquireShared" type="void" line="723">
                <params>
                    <param name="arg" type="long"/>
                </params>
                <comment line="735">
                    help GC                    
                </comment>
                <declaration name="node" type="Node" line="724"/>
                <declaration name="failed" type="boolean" line="725"/>
                <scope line="726">
                    <declaration name="interrupted" type="boolean" line="727"/>
                    <scope line="728">
                        <declaration name="p" type="Node" line="729"/>
                        <scope line="730">
                            <declaration name="r" type="long" line="731"/>
                            <scope line="732"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="745"/>
            </method>
            <javadoc line="751">
                Acquires in shared interruptible mode.                
                <param>
                    arg the acquire argument                    
                </param>
            </javadoc>
            <method name="doAcquireSharedInterruptibly" type="void" line="756">
                <params>
                    <param name="arg" type="long"/>
                </params>
                <comment line="767">
                    help GC                    
                </comment>
                <declaration name="node" type="Node" line="757"/>
                <declaration name="failed" type="boolean" line="758"/>
                <scope line="759">
                    <scope line="760">
                        <declaration name="p" type="Node" line="761"/>
                        <scope line="762">
                            <declaration name="r" type="long" line="763"/>
                            <scope line="764"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="775"/>
            </method>
            <javadoc line="781">
                Acquires in shared timed mode.                
                <param>
                    arg the acquire argument                    
                </param>
                <param>
                    nanosTimeout max wait time                    
                </param>
                <return>
                    {@code true} if acquired                    
                </return>
            </javadoc>
            <method name="doAcquireSharedNanos" type="boolean" line="789">
                <params>
                    <param name="arg" type="long"/>
                    <param name="nanosTimeout" type="long"/>
                </params>
                <comment line="802">
                    help GC                    
                </comment>
                <declaration name="lastTime" type="long" line="791"/>
                <declaration name="node" type="Node" line="792"/>
                <declaration name="failed" type="boolean" line="793"/>
                <scope line="794">
                    <scope line="795">
                        <declaration name="p" type="Node" line="796"/>
                        <scope line="797">
                            <declaration name="r" type="long" line="798"/>
                            <scope line="799"/>
                        </scope>
                        <declaration name="now" type="long" line="811"/>
                    </scope>
                </scope>
                <scope line="817"/>
            </method>
            <javadoc line="825">
                Attempts to acquire in exclusive mode. This method should query
                  if the state of the object permits it to be acquired in the
                  exclusive mode, and if so to acquire it.
                  &lt;p&gt;This method is always invoked by the thread performing
                  acquire.  If this method reports failure, the acquire method
                  may queue the thread, if it is not already queued, until it is
                  signalled by a release from some other thread. This can be used
                  to implement method {@link Lock#tryLock()}.
                  &lt;p&gt;The default
                  implementation throws {@link UnsupportedOperationException}.                
                <param>
                    arg the acquire argument. This value is always the one
                      passed to an acquire method, or is the value saved on entry
                      to a condition wait.  The value is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
                <return>
                    {@code true} if successful. Upon success, this object has
                      been acquired.                    
                </return>
                <throws>
                    IllegalMonitorStateException if acquiring would place this
                      synchronizer in an illegal state. This exception must be
                      thrown in a consistent fashion for synchronization to work
                      correctly.                    
                </throws>
                <throws>
                    UnsupportedOperationException if exclusive mode is not supported                    
                </throws>
            </javadoc>
            <method name="tryAcquire" type="boolean" line="851">
                <params>
                    <param name="arg" type="long"/>
                </params>
            </method>
            <javadoc line="855">
                Attempts to set the state to reflect a release in exclusive
                  mode.
                  &lt;p&gt;This method is always invoked by the thread performing release.
                  &lt;p&gt;The default implementation throws{@link UnsupportedOperationException}.                
                <param>
                    arg the release argument. This value is always the one
                      passed to a release method, or the current state value upon
                      entry to a condition wait.  The value is otherwise
                      uninterpreted and can represent anything you like.                    
                </param>
                <return>
                    {@code true} if this object is now in a fully released
                      state, so that any waiting threads may attempt to acquire;
                      and {@code false} otherwise.                    
                </return>
                <throws>
                    IllegalMonitorStateException if releasing would place this
                      synchronizer in an illegal state. This exception must be
                      thrown in a consistent fashion for synchronization to work
                      correctly.                    
                </throws>
                <throws>
                    UnsupportedOperationException if exclusive mode is not supported                    
                </throws>
            </javadoc>
            <method name="tryRelease" type="boolean" line="877">
                <params>
                    <param name="arg" type="long"/>
                </params>
            </method>
            <javadoc line="881">
                Attempts to acquire in shared mode. This method should query if
                  the state of the object permits it to be acquired in the shared
                  mode, and if so to acquire it.
                  &lt;p&gt;This method is always invoked by the thread performing
                  acquire.  If this method reports failure, the acquire method
                  may queue the thread, if it is not already queued, until it is
                  signalled by a release from some other thread.
                  &lt;p&gt;The default implementation throws {@link UnsupportedOperationException}.                
                <param>
                    arg the acquire argument. This value is always the one
                      passed to an acquire method, or is the value saved on entry
                      to a condition wait.  The value is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
                <return>
                    a negative value on failure; zero if acquisition in shared
                      mode succeeded but no subsequent shared-mode acquire can
                      succeed; and a positive value if acquisition in shared
                      mode succeeded and subsequent shared-mode acquires might
                      also succeed, in which case a subsequent waiting thread
                      must check availability. (Support for three different
                      return values enables this method to be used in contexts
                      where acquires only sometimes act exclusively.)  Upon
                      success, this object has been acquired.                    
                </return>
                <throws>
                    IllegalMonitorStateException if acquiring would place this
                      synchronizer in an illegal state. This exception must be
                      thrown in a consistent fashion for synchronization to work
                      correctly.                    
                </throws>
                <throws>
                    UnsupportedOperationException if shared mode is not supported                    
                </throws>
            </javadoc>
            <method name="tryAcquireShared" type="long" line="913">
                <params>
                    <param name="arg" type="long"/>
                </params>
            </method>
            <javadoc line="917">
                Attempts to set the state to reflect a release in shared mode.
                  &lt;p&gt;This method is always invoked by the thread performing release.
                  &lt;p&gt;The default implementation throws{@link UnsupportedOperationException}.                
                <param>
                    arg the release argument. This value is always the one
                      passed to a release method, or the current state value upon
                      entry to a condition wait.  The value is otherwise
                      uninterpreted and can represent anything you like.                    
                </param>
                <return>
                    {@code true} if this release of shared mode may permit a
                      waiting acquire (shared or exclusive) to succeed; and{@code false} otherwise                    
                </return>
                <throws>
                    IllegalMonitorStateException if releasing would place this
                      synchronizer in an illegal state. This exception must be
                      thrown in a consistent fashion for synchronization to work
                      correctly.                    
                </throws>
                <throws>
                    UnsupportedOperationException if shared mode is not supported                    
                </throws>
            </javadoc>
            <method name="tryReleaseShared" type="boolean" line="938">
                <params>
                    <param name="arg" type="long"/>
                </params>
            </method>
            <javadoc line="942">
                Returns {@code true} if synchronization is held exclusively with
                  respect to the current (calling) thread.  This method is invoked
                  upon each call to a non-waiting {@link ConditionObject} method.
                  (Waiting methods instead invoke {@link #release}.)
                  &lt;p&gt;The default implementation throws {@link UnsupportedOperationException}. This method is invoked
                  internally only within {@link ConditionObject} methods, so need
                  not be defined if conditions are not used.                
                <return>
                    {@code true} if synchronization is held exclusively;{@code false} otherwise                    
                </return>
                <throws>
                    UnsupportedOperationException if conditions are not supported                    
                </throws>
            </javadoc>
            <method name="isHeldExclusively" type="boolean" line="957"/>
            <javadoc line="961">
                Acquires in exclusive mode, ignoring interrupts.  Implemented
                  by invoking at least once {@link #tryAcquire},
                  returning on success.  Otherwise the thread is queued, possibly
                  repeatedly blocking and unblocking, invoking {@link #tryAcquire} until success.  This method can be used
                  to implement method {@link Lock#lock}.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquire} but is otherwise uninterpreted and
                      can represent anything you like.                    
                </param>
            </javadoc>
            <method name="acquire" type="void" line="973">
                <params>
                    <param name="arg" type="long"/>
                </params>
            </method>
            <javadoc line="979">
                Acquires in exclusive mode, aborting if interrupted.
                  Implemented by first checking interrupt status, then invoking
                  at least once {@link #tryAcquire}, returning on
                  success.  Otherwise the thread is queued, possibly repeatedly
                  blocking and unblocking, invoking {@link #tryAcquire}until success or the thread is interrupted.  This method can be
                  used to implement method {@link Lock#lockInterruptibly}.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquire} but is otherwise uninterpreted and
                      can represent anything you like.                    
                </param>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="acquireInterruptibly" type="void" line="994">
                <params>
                    <param name="arg" type="long"/>
                </params>
            </method>
            <javadoc line="1001">
                Attempts to acquire in exclusive mode, aborting if interrupted,
                  and failing if the given timeout elapses.  Implemented by first
                  checking interrupt status, then invoking at least once {@link #tryAcquire}, returning on success.  Otherwise, the thread is
                  queued, possibly repeatedly blocking and unblocking, invoking{@link #tryAcquire} until success or the thread is interrupted
                  or the timeout elapses.  This method can be used to implement
                  method {@link Lock#tryLock(long,TimeUnit)}.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquire} but is otherwise uninterpreted and
                      can represent anything you like.                    
                </param>
                <param>
                    nanosTimeout the maximum number of nanoseconds to wait                    
                </param>
                <return>
                    {@code true} if acquired; {@code false} if timed out                    
                </return>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="tryAcquireNanos" type="boolean" line="1019">
                <params>
                    <param name="arg" type="long"/>
                    <param name="nanosTimeout" type="long"/>
                </params>
            </method>
            <javadoc line="1026">
                Releases in exclusive mode.  Implemented by unblocking one or
                  more threads if {@link #tryRelease} returns true.
                  This method can be used to implement method {@link Lock#unlock}.                
                <param>
                    arg the release argument.  This value is conveyed to{@link #tryRelease} but is otherwise uninterpreted and
                      can represent anything you like.                    
                </param>
                <return>
                    the value returned from {@link #tryRelease}                    
                </return>
            </javadoc>
            <method name="release" type="boolean" line="1036">
                <params>
                    <param name="arg" type="long"/>
                </params>
                <scope line="1037">
                    <declaration name="h" type="Node" line="1038"/>
                </scope>
            </method>
            <javadoc line="1046">
                Acquires in shared mode, ignoring interrupts.  Implemented by
                  first invoking at least once {@link #tryAcquireShared},
                  returning on success.  Otherwise the thread is queued, possibly
                  repeatedly blocking and unblocking, invoking {@link #tryAcquireShared} until success.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquireShared} but is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
            </javadoc>
            <method name="acquireShared" type="void" line="1057">
                <params>
                    <param name="arg" type="long"/>
                </params>
            </method>
            <javadoc line="1062">
                Acquires in shared mode, aborting if interrupted.  Implemented
                  by first checking interrupt status, then invoking at least once{@link #tryAcquireShared}, returning on success.  Otherwise the
                  thread is queued, possibly repeatedly blocking and unblocking,
                  invoking {@link #tryAcquireShared} until success or the thread
                  is interrupted.                
                <param>
                    arg the acquire argument
                      This value is conveyed to {@link #tryAcquireShared} but is
                      otherwise uninterpreted and can represent anything
                      you like.                    
                </param>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="acquireSharedInterruptibly" type="void" line="1076">
                <params>
                    <param name="arg" type="long"/>
                </params>
            </method>
            <javadoc line="1083">
                Attempts to acquire in shared mode, aborting if interrupted, and
                  failing if the given timeout elapses.  Implemented by first
                  checking interrupt status, then invoking at least once {@link #tryAcquireShared}, returning on success.  Otherwise, the
                  thread is queued, possibly repeatedly blocking and unblocking,
                  invoking {@link #tryAcquireShared} until success or the thread
                  is interrupted or the timeout elapses.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquireShared} but is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
                <param>
                    nanosTimeout the maximum number of nanoseconds to wait                    
                </param>
                <return>
                    {@code true} if acquired; {@code false} if timed out                    
                </return>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="tryAcquireSharedNanos" type="boolean" line="1100">
                <params>
                    <param name="arg" type="long"/>
                    <param name="nanosTimeout" type="long"/>
                </params>
            </method>
            <javadoc line="1107">
                Releases in shared mode.  Implemented by unblocking one or more
                  threads if {@link #tryReleaseShared} returns true.                
                <param>
                    arg the release argument.  This value is conveyed to{@link #tryReleaseShared} but is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
                <return>
                    the value returned from {@link #tryReleaseShared}                    
                </return>
            </javadoc>
            <method name="releaseShared" type="boolean" line="1116">
                <params>
                    <param name="arg" type="long"/>
                </params>
                <scope line="1117"/>
            </method>
            <javadoc line="1126">
                Queries whether any threads are waiting to acquire. Note that
                  because cancellations due to interrupts and timeouts may occur
                  at any time, a {@code true} return does not guarantee that any
                  other thread will ever acquire.
                  &lt;p&gt;In this implementation, this operation returns in
                  constant time.                
                <return>
                    {@code true} if there may be other threads waiting to acquire                    
                </return>
            </javadoc>
            <method name="hasQueuedThreads" type="boolean" line="1137"/>
            <javadoc line="1141">
                Queries whether any threads have ever contended to acquire this
                  synchronizer; that is if an acquire method has ever blocked.
                  &lt;p&gt;In this implementation, this operation returns in
                  constant time.                
                <return>
                    {@code true} if there has ever been contention                    
                </return>
            </javadoc>
            <method name="hasContended" type="boolean" line="1150"/>
            <javadoc line="1154">
                Returns the first (longest-waiting) thread in the queue, or{@code null} if no threads are currently queued.
                  &lt;p&gt;In this implementation, this operation normally returns in
                  constant time, but may iterate upon contention if other threads are
                  concurrently modifying the queue.                
                <return>
                    the first (longest-waiting) thread in the queue, or{@code null} if no threads are currently queued                    
                </return>
            </javadoc>
            <method name="getFirstQueuedThread" type="Thread" line="1165">
                <comment line="1167">
                    handle only fast path, else relay                    
                </comment>
            </method>
            <javadoc line="1170">
                Version of getFirstQueuedThread called when fastpath fails                
            </javadoc>
            <method name="fullGetFirstQueuedThread" type="Thread" line="1173">
                <comment line="1175">
                    The first node is normally head.next. Try to get its
                     thread field, ensuring consistent reads: If thread
                     field is nulled out or s.prev is no longer head, then
                     some other thread(s) concurrently performed setHead in
                     between some of our reads. We try this twice before
                     resorting to traversal.                    
                </comment>
                <comment line="1191">
                    Head&apos;s next field might not have been set yet, or may have
                     been unset after setHead. So we must check to see if tail
                     is actually first node. If not, we continue on, safely
                     traversing from tail back to head to find first,
                     guaranteeing termination.                    
                </comment>
                <declaration name="h" type="Node" line="1182"/>
                <declaration name="st" type="Thread" line="1183"/>
                <declaration name="t" type="Node" line="1198"/>
                <declaration name="firstThread" type="Thread" line="1199"/>
                <scope line="1200">
                    <declaration name="tt" type="Thread" line="1201"/>
                </scope>
            </method>
            <javadoc line="1209">
                Returns true if the given thread is currently queued.
                  &lt;p&gt;This implementation traverses the queue to determine
                  presence of the given thread.                
                <param>
                    thread the thread                    
                </param>
                <return>
                    {@code true} if the given thread is on the queue                    
                </return>
                <throws>
                    NullPointerException if the thread is null                    
                </throws>
            </javadoc>
            <method name="isQueued" type="boolean" line="1219">
                <params>
                    <param name="thread" type="Thread"/>
                </params>
            </method>
            <javadoc line="1228">
                Returns {@code true} if the apparent first queued thread, if one
                  exists, is waiting in exclusive mode.  If this method returns{@code true}, and the current thread is attempting to acquire in
                  shared mode (that is, this method is invoked from {@link #tryAcquireShared}) then it is guaranteed that the current thread
                  is not the first queued thread.  Used only as a heuristic in
                  ReentrantReadWriteLock.                
            </javadoc>
            <method name="apparentlyFirstQueuedIsExclusive" type="boolean" line="1237">
                <declaration name="h" type="Node" line="1238"/>
            </method>
            <javadoc line="1245">
                Queries whether any threads have been waiting to acquire longer
                  than the current thread.
                  &lt;p&gt;An invocation of this method is equivalent to (but may be
                  more efficient than):
                  &lt;pre&gt; {@codegetFirstQueuedThread() != Thread.currentThread() &amp;&amp;
                  hasQueuedThreads()}&lt;/pre&gt;
                  &lt;p&gt;Note that because cancellations due to interrupts and
                  timeouts may occur at any time, a {@code true} return does not
                  guarantee that some other thread will acquire before the current
                  thread.  Likewise, it is possible for another thread to win a
                  race to enqueue after this method has returned {@code false},
                  due to the queue being empty.
                  &lt;p&gt;This method is designed to be used by a fair synchronizer to
                  avoid &lt;a href=&quot;AbstractQueuedSynchronizer#barging&quot;&gt;barging&lt;/a&gt;.
                  Such a synchronizer&apos;s {@link #tryAcquire} method should return{@code false}, and its {@link #tryAcquireShared} method should
                  return a negative value, if this method returns {@code true}(unless this is a reentrant acquire).  For example, the {@codetryAcquire} method for a fair, reentrant, exclusive mode
                  synchronizer might look like this:
                  &lt;pre&gt; {@code}protected boolean tryAcquire(int arg) 
                  if (isHeldExclusively()) {
                  // A reentrant acquire; increment hold count
                  return true;
                  } else if (hasQueuedPredecessors()) {
                  return false;
                  } else {
                  // try to acquire normally
                  }
                  }}&lt;/pre&gt;                
                <return>
                    {@code true} if there is a queued thread preceding the
                      current thread, and {@code false} if the current thread
                      is at the head of the queue or the queue is empty                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="hasQueuedPredecessors" type="boolean" line="1288">
                <comment line="1290">
                    The correctness of this depends on head being initialized
                     before tail and on head.next being accurate if the current
                     thread is first in queue.                    
                </comment>
                <comment line="1293">
                    Read fields in reverse initialization order                    
                </comment>
                <declaration name="t" type="Node" line="1292"/>
                <declaration name="h" type="Node" line="1293"/>
                <declaration name="s" type="Node" line="1294"/>
            </method>
            <javadoc line="1302">
                Returns an estimate of the number of threads waiting to
                  acquire.  The value is only an estimate because the number of
                  threads may change dynamically while this method traverses
                  internal data structures.  This method is designed for use in
                  monitoring system state, not for synchronization
                  control.                
                <return>
                    the estimated number of threads waiting to acquire                    
                </return>
            </javadoc>
            <method name="getQueueLength" type="int" line="1312">
                <declaration name="n" type="int" line="1313"/>
                <scope line="1314"/>
            </method>
            <javadoc line="1321">
                Returns a collection containing threads that may be waiting to
                  acquire.  Because the actual set of threads may change
                  dynamically while constructing this result, the returned
                  collection is only a best-effort estimate.  The elements of the
                  returned collection are in no particular order.  This method is
                  designed to facilitate construction of subclasses that provide
                  more extensive monitoring facilities.                
                <return>
                    the collection of threads                    
                </return>
            </javadoc>
            <method name="getQueuedThreads" type="Collection<Thread>" line="1332">
                <declaration name="list" type="ArrayList&lt;Thread&gt;" line="1333"/>
                <scope line="1334">
                    <declaration name="t" type="Thread" line="1335"/>
                </scope>
            </method>
            <javadoc line="1342">
                Returns a collection containing threads that may be waiting to
                  acquire in exclusive mode. This has the same properties
                  as {@link #getQueuedThreads} except that it only returns
                  those threads waiting due to an exclusive acquire.                
                <return>
                    the collection of threads                    
                </return>
            </javadoc>
            <method name="getExclusiveQueuedThreads" type="Collection<Thread>" line="1350">
                <declaration name="list" type="ArrayList&lt;Thread&gt;" line="1351"/>
                <scope line="1352">
                    <scope line="1353">
                        <declaration name="t" type="Thread" line="1354"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1362">
                Returns a collection containing threads that may be waiting to
                  acquire in shared mode. This has the same properties
                  as {@link #getQueuedThreads} except that it only returns
                  those threads waiting due to a shared acquire.                
                <return>
                    the collection of threads                    
                </return>
            </javadoc>
            <method name="getSharedQueuedThreads" type="Collection<Thread>" line="1370">
                <declaration name="list" type="ArrayList&lt;Thread&gt;" line="1371"/>
                <scope line="1372">
                    <scope line="1373">
                        <declaration name="t" type="Thread" line="1374"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1382">
                Returns a string identifying this synchronizer, as well as its state.
                  The state, in brackets, includes the String {@code &quot;State =&quot;}followed by the current value of {@link #getState}, and either{@code &quot;nonempty&quot;} or {@code &quot;empty&quot;} depending on whether the
                  queue is empty.                
                <return>
                    a string identifying this synchronizer, as well as its state                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1391">
                <declaration name="s" type="long" line="1392"/>
                <declaration name="q" type="String" line="1393"/>
            </method>
            <javadoc line="1401">
                Returns true if a node, always one that was initially placed on
                  a condition queue, is now waiting to reacquire on sync queue.                
                <param>
                    node the node                    
                </param>
                <return>
                    true if is reacquiring                    
                </return>
            </javadoc>
            <method name="isOnSyncQueue" type="boolean" line="1407">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <comment line="1411">
                    If has successor, it must be on queue                    
                </comment>
                <comment line="1413">
                    node.prev can be non-null, but not yet on queue because
                     the CAS to place it on queue can fail. So we have to
                     traverse from tail to make sure it actually made it.  It
                     will always be near the tail in calls to this method, and
                     unless the CAS failed (which is unlikely), it will be
                     there, so we hardly ever traverse much.                    
                </comment>
            </method>
            <javadoc line="1423">
                Returns true if node is on sync queue by searching backwards from tail.
                  Called only when needed by isOnSyncQueue.                
                <return>
                    true if present                    
                </return>
            </javadoc>
            <method name="findNodeFromTail" type="boolean" line="1428">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="t" type="Node" line="1429"/>
                <scope line="1430"/>
            </method>
            <javadoc line="1439">
                Transfers a node from a condition queue onto sync queue.
                  Returns true if successful.                
                <param>
                    node the node                    
                </param>
                <return>
                    true if successfully transferred (else the node was
                      cancelled before signal).                    
                </return>
            </javadoc>
            <method name="transferForSignal" type="boolean" line="1446">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <comment line="1448">
                    If cannot change waitStatus, the node has been cancelled.                    
                </comment>
                <comment line="1454">
                    Splice onto queue and try to set waitStatus of predecessor to
                     indicate that thread is (probably) waiting. If cancelled or
                     attempt to set waitStatus fails, wake up to resync (in which
                     case the waitStatus can be transiently and harmlessly wrong).                    
                </comment>
                <declaration name="p" type="Node" line="1459"/>
                <declaration name="ws" type="int" line="1460"/>
            </method>
            <javadoc line="1466">
                Transfers node, if necessary, to sync queue after a cancelled
                  wait. Returns true if thread was cancelled before being
                  signalled.                
                <param>
                    current the waiting thread                    
                </param>
                <param>
                    node its node                    
                </param>
                <return>
                    true if cancelled before the node was signalled                    
                </return>
            </javadoc>
            <method name="transferAfterCancelledWait" type="boolean" line="1474">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <comment line="1480">
                    If we lost out to a signal(), then we can&apos;t proceed
                     until it finishes its enq().  Cancelling during an
                     incomplete transfer is both rare and transient, so just
                     spin.                    
                </comment>
                <scope line="1475"/>
            </method>
            <javadoc line="1490">
                Invokes release with current state value; returns saved state.
                  Cancels node and throws exception on failure.                
                <param>
                    node the condition node for this wait                    
                </param>
                <return>
                    previous sync state                    
                </return>
            </javadoc>
            <method name="fullyRelease" type="long" line="1496">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="failed" type="boolean" line="1497"/>
                <scope line="1498">
                    <declaration name="savedState" type="long" line="1499"/>
                    <scope line="1500"/>
                    <scope line="1503"/>
                </scope>
                <scope line="1506"/>
            </method>
            <javadoc line="1514">
                Queries whether the given ConditionObject
                  uses this synchronizer as its lock.                
                <param>
                    condition the condition                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if owned                    
                </return>
                <throws>
                    NullPointerException if the condition is null                    
                </throws>
            </javadoc>
            <method name="owns" type="boolean" line="1522">
                <params>
                    <param name="condition" type="ConditionObject"/>
                </params>
            </method>
            <javadoc line="1528">
                Queries whether any threads are waiting on the given condition
                  associated with this synchronizer. Note that because timeouts
                  and interrupts may occur at any time, a &lt;tt&gt;true&lt;/tt&gt; return
                  does not guarantee that a future &lt;tt&gt;signal&lt;/tt&gt; will awaken
                  any threads.  This method is designed primarily for use in
                  monitoring of the system state.                
                <param>
                    condition the condition                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if there are any waiting threads                    
                </return>
                <throws>
                    IllegalMonitorStateException if exclusive synchronization
                      is not held                    
                </throws>
                <throws>
                    IllegalArgumentException if the given condition is
                      not associated with this synchronizer                    
                </throws>
                <throws>
                    NullPointerException if the condition is null                    
                </throws>
            </javadoc>
            <method name="hasWaiters" type="boolean" line="1544">
                <params>
                    <param name="condition" type="ConditionObject"/>
                </params>
            </method>
            <javadoc line="1550">
                Returns an estimate of the number of threads waiting on the
                  given condition associated with this synchronizer. Note that
                  because timeouts and interrupts may occur at any time, the
                  estimate serves only as an upper bound on the actual number of
                  waiters.  This method is designed for use in monitoring of the
                  system state, not for synchronization control.                
                <param>
                    condition the condition                    
                </param>
                <return>
                    the estimated number of waiting threads                    
                </return>
                <throws>
                    IllegalMonitorStateException if exclusive synchronization
                      is not held                    
                </throws>
                <throws>
                    IllegalArgumentException if the given condition is
                      not associated with this synchronizer                    
                </throws>
                <throws>
                    NullPointerException if the condition is null                    
                </throws>
            </javadoc>
            <method name="getWaitQueueLength" type="int" line="1566">
                <params>
                    <param name="condition" type="ConditionObject"/>
                </params>
            </method>
            <javadoc line="1572">
                Returns a collection containing those threads that may be
                  waiting on the given condition associated with this
                  synchronizer.  Because the actual set of threads may change
                  dynamically while constructing this result, the returned
                  collection is only a best-effort estimate. The elements of the
                  returned collection are in no particular order.                
                <param>
                    condition the condition                    
                </param>
                <return>
                    the collection of threads                    
                </return>
                <throws>
                    IllegalMonitorStateException if exclusive synchronization
                      is not held                    
                </throws>
                <throws>
                    IllegalArgumentException if the given condition is
                      not associated with this synchronizer                    
                </throws>
                <throws>
                    NullPointerException if the condition is null                    
                </throws>
            </javadoc>
            <method name="getWaitingThreads" type="Collection<Thread>" line="1588">
                <params>
                    <param name="condition" type="ConditionObject"/>
                </params>
            </method>
            <class name="ConditionObject" line="1594">
                <comment line="1624">
                    Internal methods                    
                </comment>
                <comment line="1709">
                    public methods                    
                </comment>
                <comment line="1767">
                    For interruptible waits, we need to track whether to throw
                     InterruptedException, if interrupted while blocked on
                     condition, versus reinterrupt current thread, if
                     interrupted while blocked waiting to re-acquire.                    
                </comment>
                <comment line="1972">
                    support for instrumentation                    
                </comment>
                <implements interface="Condition"/>
                <implements interface="java.io.Serializable"/>
                <javadoc line="1594">
                    Condition implementation for a {@link AbstractQueuedLongSynchronizer} serving as the basis of a {@link Lock} implementation.
                      &lt;p&gt;Method documentation for this class describes mechanics,
                      not behavioral specifications from the point of view of Lock
                      and Condition users. Exported versions of this class will in
                      general need to be accompanied by documentation describing
                      condition semantics that rely on those of the associated
                      &lt;tt&gt;AbstractQueuedLongSynchronizer&lt;/tt&gt;.
                      &lt;p&gt;This class is Serializable, but all fields are transient,
                      so deserialized conditions have no waiters.                    
                    <since>
                        1.6                        
                    </since>
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1612"/>
                <declaration name="firstWaiter" type="Node" line="1613"/>
                <javadoc line="1613">
                    First node of condition queue.                    
                </javadoc>
                <declaration name="lastWaiter" type="Node" line="1615"/>
                <javadoc line="1615">
                    Last node of condition queue.                    
                </javadoc>
                <javadoc line="1618">
                    Creates a new &lt;tt&gt;ConditionObject&lt;/tt&gt; instance.                    
                </javadoc>
                <method name="ConditionObject" type="constructor" line="1621"/>
                <javadoc line="1625">
                    Adds a new waiter to wait queue.                    
                    <return>
                        its new wait node                        
                    </return>
                </javadoc>
                <method name="addConditionWaiter" type="Node" line="1629">
                    <comment line="1632">
                        If lastWaiter is cancelled, clean out.                        
                    </comment>
                    <declaration name="t" type="Node" line="1630"/>
                    <scope line="1632"/>
                    <declaration name="node" type="Node" line="1636"/>
                </method>
                <javadoc line="1645">
                    Removes and transfers nodes until hit non-cancelled one or
                      null. Split out from signal in part to encourage compilers
                      to inline the case of no waiters.                    
                    <param>
                        first (non-null) the first node on condition queue                        
                    </param>
                </javadoc>
                <method name="doSignal" type="void" line="1651">
                    <params>
                        <param name="first" type="Node"/>
                    </params>
                    <scope line="1652"/>
                </method>
                <javadoc line="1660">
                    Removes and transfers all nodes.                    
                    <param>
                        first (non-null) the first node on condition queue                        
                    </param>
                </javadoc>
                <method name="doSignalAll" type="void" line="1664">
                    <params>
                        <param name="first" type="Node"/>
                    </params>
                    <scope line="1666">
                        <declaration name="next" type="Node" line="1667"/>
                    </scope>
                </method>
                <javadoc line="1674">
                    Unlinks cancelled waiter nodes from condition queue.
                      Called only while holding lock. This is called when
                      cancellation occurred during condition wait, and upon
                      insertion of a new waiter when lastWaiter is seen to have
                      been cancelled. This method is needed to avoid garbage
                      retention in the absence of signals. So even though it may
                      require a full traversal, it comes into play only when
                      timeouts or cancellations occur in the absence of
                      signals. It traverses all nodes rather than stopping at a
                      particular target to unlink all pointers to garbage nodes
                      without requiring many re-traversals during cancellation
                      storms.                    
                </javadoc>
                <method name="unlinkCancelledWaiters" type="void" line="1688">
                    <declaration name="t" type="Node" line="1689"/>
                    <declaration name="trail" type="Node" line="1690"/>
                    <scope line="1691">
                        <declaration name="next" type="Node" line="1692"/>
                        <scope line="1693"/>
                    </scope>
                </method>
                <javadoc line="1710">
                    Moves the longest-waiting thread, if one exists, from the
                      wait queue for this condition to the wait queue for the
                      owning lock.                    
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="signal" type="void" line="1718">
                    <declaration name="first" type="Node" line="1721"/>
                </method>
                <javadoc line="1726">
                    Moves all threads from the wait queue for this condition to
                      the wait queue for the owning lock.                    
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="signalAll" type="void" line="1733">
                    <declaration name="first" type="Node" line="1736"/>
                </method>
                <javadoc line="1741">
                    Implements uninterruptible condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="awaitUninterruptibly" type="void" line="1753">
                    <declaration name="node" type="Node" line="1754"/>
                    <declaration name="savedState" type="long" line="1755"/>
                    <declaration name="interrupted" type="boolean" line="1756"/>
                    <scope line="1757"/>
                </method>
                <declaration name="REINTERRUPT" type="int" line="1773"/>
                <javadoc line="1773">
                    Mode meaning to reinterrupt on exit from wait                    
                </javadoc>
                <declaration name="THROW_IE" type="int" line="1775"/>
                <javadoc line="1775">
                    Mode meaning to throw InterruptedException on exit from wait                    
                </javadoc>
                <javadoc line="1778">
                    Checks for interrupt, returning THROW_IE if interrupted
                      before signalled, REINTERRUPT if after signalled, or
                      0 if not interrupted.                    
                </javadoc>
                <method name="checkInterruptWhileWaiting" type="int" line="1783">
                    <params>
                        <param name="node" type="Node"/>
                    </params>
                </method>
                <javadoc line="1789">
                    Throws InterruptedException, reinterrupts current thread, or
                      does nothing, depending on mode.                    
                </javadoc>
                <method name="reportInterruptAfterWait" type="void" line="1794">
                    <params>
                        <param name="interruptMode" type="int"/>
                    </params>
                </method>
                <javadoc line="1801">
                    Implements interruptible condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; If current thread is interrupted, throw InterruptedException.
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled or interrupted.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="await" type="void" line="1815">
                    <comment line="1829">
                        clean up if cancelled                        
                    </comment>
                    <declaration name="node" type="Node" line="1818"/>
                    <declaration name="savedState" type="long" line="1819"/>
                    <declaration name="interruptMode" type="int" line="1820"/>
                    <scope line="1821"/>
                </method>
                <javadoc line="1834">
                    Implements timed condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; If current thread is interrupted, throw InterruptedException.
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled, interrupted, or timed out.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="awaitNanos" type="long" line="1849">
                    <params>
                        <param name="nanosTimeout" type="long"/>
                    </params>
                    <declaration name="node" type="Node" line="1852"/>
                    <declaration name="savedState" type="long" line="1853"/>
                    <declaration name="lastTime" type="long" line="1854"/>
                    <declaration name="interruptMode" type="int" line="1855"/>
                    <scope line="1856">
                        <scope line="1857"/>
                        <declaration name="now" type="long" line="1865"/>
                    </scope>
                </method>
                <javadoc line="1878">
                    Implements absolute timed condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; If current thread is interrupted, throw InterruptedException.
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled, interrupted, or timed out.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
                      &lt;li&gt; If timed out while blocked in step 4, return false, else true.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="awaitUntil" type="boolean" line="1894">
                    <params>
                        <param name="deadline" type="Date"/>
                    </params>
                    <declaration name="abstime" type="long" line="1897"/>
                    <declaration name="node" type="Node" line="1900"/>
                    <declaration name="savedState" type="long" line="1901"/>
                    <declaration name="timedout" type="boolean" line="1902"/>
                    <declaration name="interruptMode" type="int" line="1903"/>
                    <scope line="1904">
                        <scope line="1905"/>
                    </scope>
                </method>
                <javadoc line="1922">
                    Implements timed condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; If current thread is interrupted, throw InterruptedException.
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled, interrupted, or timed out.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
                      &lt;li&gt; If timed out while blocked in step 4, return false, else true.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="await" type="boolean" line="1938">
                    <params>
                        <param name="time" type="long"/>
                        <param name="unit" type="TimeUnit"/>
                    </params>
                    <declaration name="nanosTimeout" type="long" line="1941"/>
                    <declaration name="node" type="Node" line="1944"/>
                    <declaration name="savedState" type="long" line="1945"/>
                    <declaration name="lastTime" type="long" line="1946"/>
                    <declaration name="timedout" type="boolean" line="1947"/>
                    <declaration name="interruptMode" type="int" line="1948"/>
                    <scope line="1949">
                        <scope line="1950"/>
                        <declaration name="now" type="long" line="1958"/>
                    </scope>
                </method>
                <javadoc line="1973">
                    Returns true if this condition was created by the given
                      synchronization object.                    
                    <return>
                        {@code true} if owned                        
                    </return>
                </javadoc>
                <method name="isOwnedBy" type="boolean" line="1979">
                    <params>
                        <param name="sync" type="AbstractQueuedLongSynchronizer"/>
                    </params>
                </method>
                <javadoc line="1983">
                    Queries whether any threads are waiting on this condition.
                      Implements {@link AbstractQueuedLongSynchronizer#hasWaiters}.                    
                    <return>
                        {@code true} if there are any waiting threads                        
                    </return>
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="hasWaiters" type="boolean" line="1991">
                    <scope line="1994"/>
                </method>
                <javadoc line="2001">
                    Returns an estimate of the number of threads waiting on
                      this condition.
                      Implements {@link AbstractQueuedLongSynchronizer#getWaitQueueLength}.                    
                    <return>
                        the estimated number of waiting threads                        
                    </return>
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="getWaitQueueLength" type="int" line="2010">
                    <declaration name="n" type="int" line="2013"/>
                    <scope line="2014"/>
                </method>
                <javadoc line="2021">
                    Returns a collection containing those threads that may be
                      waiting on this Condition.
                      Implements {@link AbstractQueuedLongSynchronizer#getWaitingThreads}.                    
                    <return>
                        the collection of threads                        
                    </return>
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="getWaitingThreads" type="Collection<Thread>" line="2030">
                    <declaration name="list" type="ArrayList&lt;Thread&gt;" line="2033"/>
                    <scope line="2034">
                        <scope line="2035">
                            <declaration name="t" type="Thread" line="2036"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <declaration name="unsafe" type="Unsafe" line="2045"/>
            <javadoc line="2045">
                Setup to support compareAndSet. We need to natively implement
                  this here: For the sake of permitting future enhancements, we
                  cannot explicitly subclass AtomicLong, which would be
                  efficient and useful otherwise. So, as the lesser of evils, we
                  natively implement using hotspot intrinsics API. And while we
                  are at it, we do the same for other CASable fields (which could
                  otherwise be done with atomic field updaters).                
            </javadoc>
            <declaration name="stateOffset" type="long" line="2055"/>
            <declaration name="headOffset" type="long" line="2056"/>
            <declaration name="tailOffset" type="long" line="2057"/>
            <declaration name="waitStatusOffset" type="long" line="2058"/>
            <declaration name="nextOffset" type="long" line="2059"/>
            <scope line="2061">
                <scope line="2062"/>
                <scope line="2074"/>
            </scope>
            <javadoc line="2077">
                CAS head field. Used only by enq.                
            </javadoc>
            <method name="compareAndSetHead" type="boolean" line="2080">
                <params>
                    <param name="update" type="Node"/>
                </params>
            </method>
            <javadoc line="2084">
                CAS tail field. Used only by enq.                
            </javadoc>
            <method name="compareAndSetTail" type="boolean" line="2087">
                <params>
                    <param name="expect" type="Node"/>
                    <param name="update" type="Node"/>
                </params>
            </method>
            <javadoc line="2091">
                CAS waitStatus field of a node.                
            </javadoc>
            <method name="compareAndSetWaitStatus" type="boolean" line="2096">
                <params>
                    <param name="node" type="Node"/>
                    <param name="expect" type="int"/>
                    <param name="update" type="int"/>
                </params>
            </method>
            <javadoc line="2101">
                CAS next field of a node.                
            </javadoc>
            <method name="compareAndSetNext" type="boolean" line="2106">
                <params>
                    <param name="node" type="Node"/>
                    <param name="expect" type="Node"/>
                    <param name="update" type="Node"/>
                </params>
            </method>
        </class>
    </source>