<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <class name="ExecutorCompletionService" line="38">
            <type_params>
                <type_param name="V"/>
            </type_params>
            <implements interface="CompletionService">
                <type_params>
                    <type_param name="V"/>
                </type_params>
            </implements>
            <javadoc line="38">
                A {@link CompletionService} that uses a supplied {@link Executor}to execute tasks.  This class arranges that submitted tasks are,
                  upon completion, placed on a queue accessible using {@code take}.
                  The class is lightweight enough to be suitable for transient use
                  when processing groups of tasks.
                  &lt;p&gt;
                  &lt;b&gt;Usage Examples.&lt;/b&gt;
                  Suppose you have a set of solvers for a certain problem, each
                  returning a value of some type {@code Result}, and would like to
                  run them concurrently, processing the results of each of them that
                  return a non-null value, in some method {@code use(Result r)}. You
                  could write this as:
                  &lt;pre&gt; {@codevoid solve(Executor e,
                  Collection&lt;Callable&lt;Result&gt;&gt; solvers)}throws InterruptedException, ExecutionException 
                  CompletionService&lt;Result&gt; ecs
                  = new ExecutorCompletionService&lt;Result&gt;(e);
                  for (Callable&lt;Result&gt; s : solvers)
                  ecs.submit(s);
                  int n = solvers.size();
                  for (int i = 0; i &lt; n; ++i) {
                  Result r = ecs.take().get();
                  if (r != null)
                  use(r);
                  }
                  }}&lt;/pre&gt;
                  Suppose instead that you would like to use the first non-null result
                  of the set of tasks, ignoring any that encounter exceptions,
                  and cancelling all other tasks when the first one is ready:
                  &lt;pre&gt; {@codevoid solve(Executor e,
                  Collection&lt;Callable&lt;Result&gt;&gt; solvers)}throws InterruptedException 
                  CompletionService&lt;Result&gt; ecs
                  = new ExecutorCompletionService&lt;Result&gt;(e);
                  int n = solvers.size();
                  List&lt;Future&lt;Result&gt;&gt; futures
                  = new ArrayList&lt;Future&lt;Result&gt;&gt;(n);
                  Result result = null;
                  try {
                  for (Callable&lt;Result&gt; s : solvers)
                  futures.add(ecs.submit(s));
                  for (int i = 0; i &lt; n; ++i) {
                  try {
                  Result r = ecs.take().get();
                  if (r != null) {
                  result = r;
                  break;
                  }
                  } catch (ExecutionException ignore) {}
                  }
                  }
                  finally {
                  for (Future&lt;Result&gt; f : futures)
                  f.cancel(true);
                  }
                  if (result != null)
                  use(result);
                  }}&lt;/pre&gt;                
            </javadoc>
            <declaration name="executor" type="Executor" line="108"/>
            <declaration name="aes" type="AbstractExecutorService" line="109"/>
            <declaration name="completionQueue" type="BlockingQueue&lt;Future&lt;V&gt;&gt;" line="110"/>
            <class name="QueueingFuture" line="112">
                <extends class="FutureTask">
                    <type_params>
                        <type_param name="Void"/>
                    </type_params>
                </extends>
                <javadoc line="112">
                    FutureTask extension to enqueue upon completion                    
                </javadoc>
                <method name="QueueingFuture" type="constructor" line="116">
                    <params>
                        <param name="task" type="RunnableFuture<V>"/>
                    </params>
                </method>
                <method name="done" type="void" line="120"/>
                <declaration name="task" type="Future&lt;V&gt;" line="121"/>
            </class>
            <method name="newTaskFor" type="RunnableFuture<V>" line="124">
                <params>
                    <param name="task" type="Callable<V>"/>
                </params>
            </method>
            <method name="newTaskFor" type="RunnableFuture<V>" line="131">
                <params>
                    <param name="task" type="Runnable"/>
                    <param name="result" type="V"/>
                </params>
            </method>
            <javadoc line="138">
                Creates an ExecutorCompletionService using the supplied
                  executor for base task execution and a{@link LinkedBlockingQueue} as a completion queue.                
                <param>
                    executor the executor to use                    
                </param>
                <throws>
                    NullPointerException if executor is {@code null}                    
                </throws>
            </javadoc>
            <method name="ExecutorCompletionService" type="constructor" line="146">
                <params>
                    <param name="executor" type="Executor"/>
                </params>
            </method>
            <javadoc line="155">
                Creates an ExecutorCompletionService using the supplied
                  executor for base task execution and the supplied queue as its
                  completion queue.                
                <param>
                    executor the executor to use                    
                </param>
                <param>
                    completionQueue the queue to use as the completion queue
                      normally one dedicated for use by this service. This
                      queue is treated as unbounded -- failed attempted{@code Queue.add} operations for completed taskes cause
                      them not to be retrievable.                    
                </param>
                <throws>
                    NullPointerException if executor or completionQueue are {@code null}                    
                </throws>
            </javadoc>
            <method name="ExecutorCompletionService" type="constructor" line="169">
                <params>
                    <param name="executor" type="Executor"/>
                    <param name="completionQueue" type="BlockingQueue<Future<V>>"/>
                </params>
            </method>
            <method name="submit" type="Future<V>" line="178">
                <params>
                    <param name="task" type="Callable<V>"/>
                </params>
                <declaration name="f" type="RunnableFuture&lt;V&gt;" line="180"/>
            </method>
            <method name="submit" type="Future<V>" line="185">
                <params>
                    <param name="task" type="Runnable"/>
                    <param name="result" type="V"/>
                </params>
                <declaration name="f" type="RunnableFuture&lt;V&gt;" line="187"/>
            </method>
            <method name="take" type="Future<V>" line="192"/>
            <method name="poll" type="Future<V>" line="196"/>
            <method name="poll" type="Future<V>" line="201">
                <params>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
            </method>
        </class>
    </source>