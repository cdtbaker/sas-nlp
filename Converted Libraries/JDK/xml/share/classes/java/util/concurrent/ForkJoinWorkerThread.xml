<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.Collection"/>
        <import package="java.util.concurrent.RejectedExecutionException"/>
        <class name="ForkJoinWorkerThread" line="4">
            <extends class="Thread"/>
            <javadoc line="4">
                A thread managed by a {@link ForkJoinPool}, which executes{@link ForkJoinTask}s.
                  This class is subclassable solely for the sake of adding
                  functionality -- there are no overridable methods dealing with
                  scheduling or execution.  However, you can override initialization
                  and termination methods surrounding the main task processing loop.
                  If you do create such a subclass, you will also need to supply a
                  custom {@link ForkJoinPool.ForkJoinWorkerThreadFactory} to use it
                  in a {@code ForkJoinPool}.                
                <since>
                    1.7                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <declaration name="SMASK" type="int" line="17"/>
            <javadoc line="17">
                Mask for pool indices encoded as shorts                
            </javadoc>
            <declaration name="INITIAL_QUEUE_CAPACITY" type="int" line="21"/>
            <javadoc line="21">
                Capacity of work-stealing queue array upon initialization.
                  Must be a power of two. Initial size must be at least 4, but is
                  padded to minimize cache effects.                
            </javadoc>
            <declaration name="MAXIMUM_QUEUE_CAPACITY" type="int" line="27"/>
            <javadoc line="27">
                Maximum size for queue array. Must be a power of two
                  less than or equal to 1 &lt;&lt; (31 - width of array entry) to
                  ensure lack of index wraparound, but is capped at a lower
                  value to help users trap runaway computations.                
            </javadoc>
            <declaration name="queue" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="34"/>
            <javadoc line="34">
                The work-stealing queue array. Size must be a power of two.
                  Initialized when started (as oposed to when constructed), to
                  improve memory locality.                
            </javadoc>
            <declaration name="pool" type="ForkJoinPool" line="40"/>
            <javadoc line="40">
                The pool this thread works in. Accessed directly by ForkJoinTask.                
            </javadoc>
            <declaration name="queueTop" type="int" line="44"/>
            <javadoc line="44">
                Index (mod queue.length) of next queue slot to push to or pop
                  from. It is written only by owner thread, and accessed by other
                  threads only after reading (volatile) queueBase.  Both queueTop
                  and queueBase are allowed to wrap around on overflow, but
                  (queueTop - queueBase) still estimates size.                
            </javadoc>
            <declaration name="queueBase" type="int" line="52"/>
            <javadoc line="52">
                Index (mod queue.length) of least valid queue slot, which is
                  always the next position to steal from if nonempty.                
            </javadoc>
            <declaration name="stealHint" type="int" line="57"/>
            <javadoc line="57">
                The index of most recent stealer, used as a hint to avoid
                  traversal in method helpJoinTask. This is only a hint because a
                  worker might have had multiple steals and this only holds one
                  of them (usually the most current). Declared non-volatile,
                  relying on other prevailing sync to keep reasonably current.                
            </javadoc>
            <declaration name="poolIndex" type="int" line="65"/>
            <javadoc line="65">
                Index of this worker in pool array. Set once by pool before
                  running, and accessed directly by pool to locate this worker in
                  its workers array.                
            </javadoc>
            <declaration name="nextWait" type="int" line="71"/>
            <javadoc line="71">
                Encoded record for pool task waits. Usages are always
                  surrounded by volatile reads/writes                
            </javadoc>
            <declaration name="eventCount" type="int" line="76"/>
            <javadoc line="76">
                Complement of poolIndex, offset by count of entries of task
                  waits. Accessed by ForkJoinPool to manage event waiters.                
            </javadoc>
            <declaration name="seed" type="int" line="81"/>
            <javadoc line="81">
                Seed for random number generator for choosing steal victims.
                  Uses Marsaglia xorshift. Must be initialized as nonzero.                
            </javadoc>
            <declaration name="stealCount" type="int" line="86"/>
            <javadoc line="86">
                Number of steals. Directly accessed (and reset) by pool when
                  idle.                
            </javadoc>
            <declaration name="terminate" type="boolean" line="91"/>
            <javadoc line="91">
                True if this worker should or did terminate                
            </javadoc>
            <declaration name="parked" type="boolean" line="95"/>
            <javadoc line="95">
                Set to true before LockSupport.park; false on return                
            </javadoc>
            <declaration name="locallyFifo" type="boolean" line="99"/>
            <javadoc line="99">
                True if use local fifo, not default lifo, for local polling.
                  Shadows value from ForkJoinPool.                
            </javadoc>
            <declaration name="currentSteal" type="ForkJoinTask&amp;lt;?&amp;gt;" line="104"/>
            <javadoc line="104">
                The task most recently stolen from another worker (or
                  submission queue).  All uses are surrounded by enough volatile
                  reads/writes to maintain as non-volatile.                
            </javadoc>
            <declaration name="currentJoin" type="ForkJoinTask&amp;lt;?&amp;gt;" line="110"/>
            <javadoc line="110">
                The task currently being joined, set only when actively trying
                  to help other stealers in helpJoinTask. All uses are surrounded
                  by enough volatile reads/writes to maintain as non-volatile.                
            </javadoc>
            <javadoc line="116">
                Creates a ForkJoinWorkerThread operating in the given pool.                
                <param>
                    pool the pool this thread works in                    
                </param>
                <throws>
                    NullPointerException if pool is null                    
                </throws>
            </javadoc>
            <method name="ForkJoinWorkerThread" type="constructor" line="121">
                <params>
                    <param name="pool" type="ForkJoinPool"/>
                </params>
                <declaration name="k" type="int" line="124"/>
                <declaration name="ueh" type="Thread.UncaughtExceptionHandler" line="128"/>
            </method>
            <javadoc line="132">
                Returns the pool hosting this thread.                
                <return>
                    the pool                    
                </return>
            </javadoc>
            <method name="getPool" type="ForkJoinPool" line="136"/>
            <javadoc line="139">
                Returns the index number of this thread in its pool.  The
                  returned value ranges from zero to the maximum number of
                  threads (minus one) that have ever been created in the pool.
                  This method may be useful for applications that track status or
                  collect results per-worker rather than per-task.                
                <return>
                    the index number                    
                </return>
            </javadoc>
            <method name="getPoolIndex" type="int" line="147"/>
            <javadoc line="150">
                Computes next value for random victim probes and backoffs.
                  Scans don&apos;t require a very high quality generator, but also not
                  a crummy one.  Marsaglia xor-shift is cheap and works well
                  enough.  Note: This is manually inlined in FJP.scan() to avoid
                  writes inside busy loops.                
            </javadoc>
            <method name="nextSeed" type="int" line="157">
                <declaration name="r" type="int" line="158"/>
            </method>
            <javadoc line="164">
                Initializes internal state after construction but before
                  processing any tasks. If you override this method, you must
                  invoke {@code super.onStart()} at the beginning of the method.
                  Initialization requires care: Most fields must have legal
                  default values, to ensure that attempted accesses from other
                  threads work correctly even before this thread starts
                  processing tasks.                
            </javadoc>
            <method name="onStart" type="void" line="173">
                <declaration name="r" type="int" line="175"/>
            </method>
            <javadoc line="178">
                Performs cleanup associated with termination of this worker
                  thread.  If you override this method, you must invoke{@code super.onTermination} at the end of the overridden method.                
                <param>
                    exception the exception causing this thread to abort due
                      to an unrecoverable error, or {@code null} if completed normally                    
                </param>
            </javadoc>
            <method name="onTermination" type="void" line="184">
                <params>
                    <param name="exception" type="Throwable"/>
                </params>
                <scope line="185"/>
                <scope line="190"/>
                <scope line="193"/>
            </method>
            <javadoc line="197">
                This method is required to be public, but should never be
                  called explicitly. It performs the main run loop to execute{@link ForkJoinTask}s.                
            </javadoc>
            <method name="run" type="void" line="201">
                <declaration name="exception" type="Throwable" line="202"/>
                <scope line="203"/>
                <scope line="207"/>
                <scope line="210"/>
            </method>
            <javadoc line="214">
                CASes slot i of array q from t to null. Caller must ensure q is
                  non-null and index is in range.                
            </javadoc>
            <method name="casSlotNull" type="boolean" line="218">
                <params>
                    <param name="q" type="ForkJoinTask&lt;?&gt;[]"/>
                    <param name="i" type="int"/>
                    <param name="t" type="ForkJoinTask&lt;?&gt;"/>
                </params>
            </method>
            <javadoc line="221">
                Performs a volatile write of the given task at given slot of
                  array q.  Caller must ensure q is non-null and index is in
                  range. This method is used only during resets and backouts.                
            </javadoc>
            <method name="writeSlot" type="void" line="226">
                <params>
                    <param name="q" type="ForkJoinTask&lt;?&gt;[]"/>
                    <param name="i" type="int"/>
                    <param name="t" type="ForkJoinTask&lt;?&gt;"/>
                </params>
            </method>
            <javadoc line="229">
                Pushes a task. Call only from this thread.                
                <param>
                    t the task. Caller must ensure non-null.                    
                </param>
            </javadoc>
            <method name="pushTask" type="void" line="233">
                <params>
                    <param name="t" type="ForkJoinTask&lt;?&gt;"/>
                </params>
                <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="234"/>
                <declaration name="s" type="int" line="235"/>
                <scope line="236">
                    <declaration name="u" type="long" line="237"/>
                </scope>
            </method>
            <javadoc line="244">
                Creates or doubles queue array.  Transfers elements by
                  emulating steals (deqs) from old array and placing, oldest
                  first, into new array.                
            </javadoc>
            <method name="growQueue" type="void" line="249">
                <declaration name="oldQ" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="250"/>
                <declaration name="size" type="int" line="251"/>
                <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="254"/>
                <declaration name="mask" type="int" line="255"/>
                <declaration name="top" type="int" line="256"/>
                <declaration name="oldMask" type="int" line="257"/>
                <scope line="258">
                    <scope line="259">
                        <declaration name="u" type="long" line="260"/>
                        <declaration name="x" type="Object" line="261"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="266">
                Tries to take a task from the base of the queue, failing if
                  empty or contended. Note: Specializations of this code appear
                  in locallyDeqTask and elsewhere.                
                <return>
                    a task, or null if none or contended                    
                </return>
            </javadoc>
            <method name="deqTask" type="ForkJoinTask&lt;?&gt;" line="272">
                <declaration name="t" type="ForkJoinTask&amp;lt;?&amp;gt;" line="273"/>
                <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="274"/>
                <declaration name="b" type="int" line="275"/>
                <scope line="276"/>
            </method>
            <javadoc line="282">
                Tries to take a task from the base of own queue.  Called only
                  by this thread.                
                <return>
                    a task, or null if none                    
                </return>
            </javadoc>
            <method name="locallyDeqTask" type="ForkJoinTask&lt;?&gt;" line="287">
                <declaration name="t" type="ForkJoinTask&amp;lt;?&amp;gt;" line="288"/>
                <declaration name="m" type="int" line="289"/>
                <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="290"/>
                <scope line="291">
                    <scope line="292">
                        <scope line="293"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="301">
                Returns a popped task, or null if empty.
                  Called only by this thread.                
            </javadoc>
            <method name="popTask" type="ForkJoinTask&lt;?&gt;" line="305">
                <declaration name="m" type="int" line="306"/>
                <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="307"/>
                <scope line="308">
                    <scope line="309">
                        <declaration name="i" type="int" line="310"/>
                        <declaration name="u" type="long" line="311"/>
                        <declaration name="t" type="ForkJoinTask&amp;lt;?&amp;gt;" line="312"/>
                        <scope line="314"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="322">
                Specialized version of popTask to pop only if topmost element
                  is the given task. Called only by this thread.                
                <param>
                    t the task. Caller must ensure non-null.                    
                </param>
            </javadoc>
            <method name="unpushTask" type="boolean" line="327">
                <params>
                    <param name="t" type="ForkJoinTask&lt;?&gt;"/>
                </params>
                <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="328"/>
                <declaration name="s" type="int" line="329"/>
                <scope line="330"/>
            </method>
            <javadoc line="336">
                Returns next task, or null if empty or contended.                
            </javadoc>
            <method name="peekTask" type="ForkJoinTask&lt;?&gt;" line="339">
                <declaration name="m" type="int" line="340"/>
                <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="341"/>
                <declaration name="i" type="int" line="343"/>
            </method>
            <javadoc line="346">
                Runs the given task, plus any local tasks until queue is empty                
            </javadoc>
            <method name="execTask" type="void" line="349">
                <params>
                    <param name="t" type="ForkJoinTask&lt;?&gt;"/>
                </params>
                <scope line="351"/>
            </method>
            <javadoc line="359">
                Removes and cancels all tasks in queue.  Can be called from any
                  thread.                
            </javadoc>
            <method name="cancelTasks" type="void" line="363">
                <declaration name="cj" type="ForkJoinTask&amp;lt;?&amp;gt;" line="364"/>
                <declaration name="cs" type="ForkJoinTask&amp;lt;?&amp;gt;" line="366"/>
                <scope line="368">
                    <declaration name="t" type="ForkJoinTask&amp;lt;?&amp;gt;" line="369"/>
                </scope>
            </method>
            <javadoc line="373">
                Drains tasks to given collection c.                
                <return>
                    the number of tasks drained                    
                </return>
            </javadoc>
            <method name="drainTasksTo" type="int" line="377">
                <params>
                    <param name="c" type="Collection&lt;? super ForkJoinTask&lt;?&gt;&gt;"/>
                </params>
                <declaration name="n" type="int" line="378"/>
                <scope line="379">
                    <declaration name="t" type="ForkJoinTask&amp;lt;?&amp;gt;" line="380"/>
                    <scope line="381"/>
                </scope>
            </method>
            <javadoc line="388">
                Returns an estimate of the number of tasks in the queue.                
            </javadoc>
            <method name="getQueueSize" type="int" line="391"/>
            <javadoc line="394">
                Gets and removes a local task.                
                <return>
                    a task, if available                    
                </return>
            </javadoc>
            <method name="pollLocalTask" type="ForkJoinTask&lt;?&gt;" line="398"/>
            <javadoc line="401">
                Gets and removes a local or stolen task.                
                <return>
                    a task, if available                    
                </return>
            </javadoc>
            <method name="pollTask" type="ForkJoinTask&lt;?&gt;" line="405">
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="406"/>
                <declaration name="t" type="ForkJoinTask&amp;lt;?&amp;gt;" line="407"/>
                <declaration name="n" type="int" line="409"/>
                <declaration name="steps" type="int" line="410"/>
                <declaration name="r" type="int" line="411"/>
                <declaration name="i" type="int" line="412"/>
                <scope line="413">
                    <declaration name="w" type="ForkJoinWorkerThread" line="414"/>
                    <scope line="415"/>
                </scope>
            </method>
            <declaration name="MAX_HELP" type="int" line="422"/>
            <javadoc line="422">
                The maximum stolen-&gt;joining link depth allowed in helpJoinTask,
                  as well as the maximum number of retries (allowing on average
                  one staleness retry per level) per attempt to instead try
                  compensation.  Depths for legitimate chains are unbounded, but
                  we use a fixed constant to avoid (otherwise unchecked) cycles
                  and bound staleness of traversal parameters at the expense of
                  sometimes blocking when we could be helping.                
            </javadoc>
            <javadoc line="432">
                Possibly runs some tasks and/or blocks, until joinMe is done.                
                <param>
                    joinMe the task to join                    
                </param>
                <return>
                    completion status on exit                    
                </return>
            </javadoc>
            <method name="joinTask" type="int" line="437">
                <params>
                    <param name="joinMe" type="ForkJoinTask&lt;?&gt;"/>
                </params>
                <declaration name="prevJoin" type="ForkJoinTask&amp;lt;?&amp;gt;" line="438"/>
                <scope line="440">
                    <scope line="441"/>
                    <scope line="445">
                        <scope line="446"/>
                        <scope line="449"/>
                    </scope>
                    <scope line="455"/>
                </scope>
            </method>
            <javadoc line="461">
                If present, pops and executes the given task, or any other
                  cancelled task                
                <return>
                    false if any other non-cancelled task exists in local queue                    
                </return>
            </javadoc>
            <method name="localHelpJoinTask" type="boolean" line="466">
                <params>
                    <param name="joinMe" type="ForkJoinTask&lt;?&gt;"/>
                </params>
                <declaration name="s" type="int" line="467"/>
                <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="468"/>
                <declaration name="t" type="ForkJoinTask&amp;lt;?&amp;gt;" line="469"/>
                <scope line="470">
                    <scope line="472"/>
                </scope>
            </method>
            <javadoc line="479">
                Tries to locate and execute tasks for a stealer of the given
                  task, or in turn one of its stealers, Traces
                  currentSteal-&gt;currentJoin links looking for a thread working on
                  a descendant of the given task and with a non-empty queue to
                  steal back and execute tasks from.  The implementation is very
                  branchy to cope with potential inconsistencies or loops
                  encountering chains that are stale, unknown, or of length
                  greater than MAX_HELP links.  All of these cases are dealt with
                  by just retrying by caller.                
                <param>
                    joinMe the task to join                    
                </param>
                <param>
                    canSteal true if local queue is empty                    
                </param>
                <return>
                    true if ran a task                    
                </return>
            </javadoc>
            <method name="helpJoinTask" type="boolean" line="493">
                <params>
                    <param name="joinMe" type="ForkJoinTask&lt;?&gt;"/>
                </params>
                <declaration name="helped" type="boolean" line="494"/>
                <declaration name="m" type="int" line="495"/>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="496"/>
                <scope line="497">
                    <declaration name="levels" type="int" line="498"/>
                    <declaration name="task" type="ForkJoinTask&amp;lt;?&amp;gt;" line="499"/>
                    <scope line="500">
                        <declaration name="v" type="ForkJoinWorkerThread" line="501"/>
                        <scope line="502">
                            <scope line="503">
                                <scope line="504"/>
                            </scope>
                        </scope>
                        <scope line="511">
                            <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="512"/>
                            <declaration name="b" type="int" line="513"/>
                            <declaration name="u" type="long" line="516"/>
                            <declaration name="t" type="ForkJoinTask&amp;lt;?&amp;gt;" line="517"/>
                            <scope line="519">
                                <declaration name="ps" type="ForkJoinTask&amp;lt;?&amp;gt;" line="522"/>
                            </scope>
                        </scope>
                        <declaration name="next" type="ForkJoinTask&amp;lt;?&amp;gt;" line="529"/>
                        <scope line="530"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="539">
                Performs an uncommon case for joinTask: If task t is at base of
                  some workers queue, steals and executes it.                
                <param>
                    t the task                    
                </param>
                <return>
                    t&apos;s status                    
                </return>
            </javadoc>
            <method name="tryDeqAndExec" type="int" line="545">
                <params>
                    <param name="t" type="ForkJoinTask&lt;?&gt;"/>
                </params>
                <declaration name="m" type="int" line="546"/>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="547"/>
                <scope line="548">
                    <scope line="549">
                        <declaration name="q" type="ForkJoinTask&amp;lt;?&amp;gt;[]" line="550"/>
                        <declaration name="b" type="int" line="551"/>
                        <declaration name="v" type="ForkJoinWorkerThread" line="552"/>
                        <scope line="553">
                            <declaration name="u" type="long" line="554"/>
                            <scope line="555">
                                <declaration name="ps" type="ForkJoinTask&amp;lt;?&amp;gt;" line="558"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="569">
                Implements ForkJoinTask.getSurplusQueuedTaskCount().  Returns
                  an estimate of the number of tasks, offset by a function of
                  number of idle workers.
                  This method provides a cheap heuristic guide for task
                  partitioning when programmers, frameworks, tools, or languages
                  have little or no idea about task granularity.  In essence by
                  offering this method, we ask users only about tradeoffs in
                  overhead vs expected throughput and its variance, rather than
                  how finely to partition tasks.
                  In a steady state strict (tree-structured) computation, each
                  thread makes available for stealing enough tasks for other
                  threads to remain active. Inductively, if all threads play by
                  the same rules, each thread should make available only a
                  constant number of tasks.
                  The minimum useful constant is just 1. But using a value of 1
                  would require immediate replenishment upon each steal to
                  maintain enough tasks, which is infeasible.  Further,
                  partitionings/granularities of offered tasks should minimize
                  steal rates, which in general means that threads nearer the top
                  of computation tree should generate more than those nearer the
                  bottom. In perfect steady state, each thread is at
                  approximately the same level of computation tree. However,
                  producing extra tasks amortizes the uncertainty of progress and
                  diffusion assumptions.
                  So, users will want to use values larger, but not much larger
                  than 1 to both smooth over transient shortages and hedge
                  against uneven progress; as traded off against the cost of
                  extra task overhead. We leave the user to pick a threshold
                  value to compare with the results of this call to guide
                  decisions, but recommend values such as 3.
                  When all threads are active, it is on average OK to estimate
                  surplus strictly locally. In steady-state, if one thread is
                  maintaining say 2 surplus tasks, then so are others. So we can
                  just use estimated queue length (although note that (queueTop -
                  queueBase) can be an overestimate because of stealers lagging
                  increments of queueBase).  However, this strategy alone leads
                  to serious mis-estimates in some non-steady-state conditions
                  (ramp-up, ramp-down, other stalls). We can detect many of these
                  by further considering the number of &quot;idle&quot; threads, that are
                  known to have zero queued tasks, so compensate by a factor of
                  (#idle/#active) threads.                
            </javadoc>
            <method name="getEstimatedSurplusTaskCount" type="int" line="612"/>
            <javadoc line="615">
                Runs tasks until {@code pool.isQuiescent()}. We piggyback on
                  pool&apos;s active count ctl maintenance, but rather than blocking
                  when tasks cannot be found, we rescan until all others cannot
                  find tasks either. The bracketing by pool quiescerCounts
                  updates suppresses pool auto-shutdown mechanics that could
                  otherwise prematurely terminate the pool because all threads
                  appear to be inactive.                
            </javadoc>
            <method name="helpQuiescePool" type="void" line="624">
                <declaration name="active" type="boolean" line="625"/>
                <declaration name="ps" type="ForkJoinTask&amp;lt;?&amp;gt;" line="626"/>
                <declaration name="p" type="ForkJoinPool" line="627"/>
                <scope line="629">
                    <declaration name="ws" type="ForkJoinWorkerThread[]" line="630"/>
                    <declaration name="v" type="ForkJoinWorkerThread" line="631"/>
                    <declaration name="n" type="int" line="632"/>
                    <scope line="634">
                        <declaration name="w" type="ForkJoinWorkerThread" line="635"/>
                        <declaration name="r" type="int" line="636"/>
                        <declaration name="steps" type="int" line="637"/>
                        <scope line="638">
                            <scope line="639"/>
                        </scope>
                    </scope>
                    <scope line="645">
                        <declaration name="t" type="ForkJoinTask&amp;lt;?&amp;gt;" line="646"/>
                        <scope line="647"/>
                        <scope line="651"/>
                    </scope>
                    <scope line="657">
                        <scope line="658"/>
                        <scope line="662"/>
                    </scope>
                </scope>
            </method>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="670"/>
            <declaration name="ABASE" type="long" line="671"/>
            <declaration name="ASHIFT" type="int" line="672"/>
            <scope line="673">
                <declaration name="s" type="int" line="674"/>
                <scope line="675">
                    <declaration name="a" type="Class" line="677"/>
                </scope>
                <scope line="681"/>
            </scope>
        </class>
    </source>