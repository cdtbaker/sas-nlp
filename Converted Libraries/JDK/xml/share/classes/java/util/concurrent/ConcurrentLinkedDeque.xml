<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.AbstractCollection"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Deque"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="java.util.Queue"/>
        <class name="ConcurrentLinkedDeque" line="9">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="AbstractCollection">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <implements interface="Deque">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </implements>
            <implements interface="java.io.Serializable"/>
            <javadoc line="9">
                An unbounded concurrent {@linkplain Deque deque} based on linked nodes.
                  Concurrent insertion, removal, and access operations execute safely
                  across multiple threads.
                  A {@code ConcurrentLinkedDeque} is an appropriate choice when
                  many threads will share access to a common collection.
                  Like most other concurrent collection implementations, this class
                  does not permit the use of {@code null} elements.
                  &lt;p&gt;Iterators are &lt;i&gt;weakly consistent&lt;/i&gt;, returning elements
                  reflecting the state of the deque at some point at or since the
                  creation of the iterator.  They do &lt;em&gt;not&lt;/em&gt; throw {@link java.util.ConcurrentModificationExceptionConcurrentModificationException}, and may proceed concurrently with
                  other operations.
                  &lt;p&gt;Beware that, unlike in most collections, the {@code size} method
                  is &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these deques, determining the current number
                  of elements requires a traversal of the elements, and so may report
                  inaccurate results if this collection is modified during traversal.
                  Additionally, the bulk operations {@code addAll},{@code removeAll}, {@code retainAll}, {@code containsAll},{@code equals}, and {@code toArray} are &lt;em&gt;not&lt;/em&gt; guaranteed
                  to be performed atomically. For example, an iterator operating
                  concurrently with an {@code addAll} operation might view only some
                  of the added elements.
                  &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                  methods of the {@link Deque} and {@link Iterator} interfaces.
                  &lt;p&gt;Memory consistency effects: As with other concurrent collections,
                  actions in a thread prior to placing an object into a{@code ConcurrentLinkedDeque}&lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                  actions subsequent to the access or removal of that element from
                  the {@code ConcurrentLinkedDeque} in another thread.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <since>
                    1.7                    
                </since>
                <author>
                    Doug Lea                    
                </author>
                <author>
                    Martin Buchholz                    
                </author>
                <param>
                    &lt;E&gt;
                      the type of elements held in this collection                    
                </param>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="46"/>
            <declaration name="head" type="Node&amp;lt;E&amp;gt;" line="47"/>
            <javadoc line="47">
                A node from which the first node on list (that is, the unique node p
                  with p.prev == null &amp;&amp; p.next != p) can be reached in O(1) time.
                  Invariants:
                  - the first node is always O(1) reachable from head via prev links
                  - all live nodes are reachable from the first node via succ()
                  - head != null
                  - (tmp = head).next != tmp || tmp != head
                  - head is never gc-unlinked (but may be unlinked)
                  Non-invariants:
                  - head.item may or may not be null
                  - head may not be reachable from the first or last node, or from tail                
            </javadoc>
            <declaration name="tail" type="Node&amp;lt;E&amp;gt;" line="61"/>
            <javadoc line="61">
                A node from which the last node on list (that is, the unique node p
                  with p.next == null &amp;&amp; p.prev != p) can be reached in O(1) time.
                  Invariants:
                  - the last node is always O(1) reachable from tail via next links
                  - all live nodes are reachable from the last node via pred()
                  - tail != null
                  - tail is never gc-unlinked (but may be unlinked)
                  Non-invariants:
                  - tail.item may or may not be null
                  - tail may not be reachable from the first or last node, or from head                
            </javadoc>
            <declaration name="PREV_TERMINATOR" type="Node&amp;lt;Object&amp;gt;" line="74"/>
            <method name="prevTerminator" type="Node&lt;E&gt;" line="75"/>
            <method name="nextTerminator" type="Node&lt;E&gt;" line="78"/>
            <class name="Node" line="81">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <declaration name="prev" type="Node&amp;lt;E&amp;gt;" line="82"/>
                <declaration name="item" type="E" line="83"/>
                <declaration name="next" type="Node&amp;lt;E&amp;gt;" line="84"/>
                <method name="Node" type="constructor" line="85"/>
                <javadoc line="87">
                    Constructs a new node.  Uses relaxed write because item can
                      only be seen after publication via casNext or casPrev.                    
                </javadoc>
                <method name="Node" type="constructor" line="91">
                    <params>
                        <param name="item" type="E"/>
                    </params>
                </method>
                <method name="casItem" type="boolean" line="94">
                    <params>
                        <param name="cmp" type="E"/>
                        <param name="val" type="E"/>
                    </params>
                </method>
                <method name="lazySetNext" type="void" line="97">
                    <params>
                        <param name="val" type="Node&lt;E&gt;"/>
                    </params>
                </method>
                <method name="casNext" type="boolean" line="100">
                    <params>
                        <param name="cmp" type="Node&lt;E&gt;"/>
                        <param name="val" type="Node&lt;E&gt;"/>
                    </params>
                </method>
                <method name="lazySetPrev" type="void" line="103">
                    <params>
                        <param name="val" type="Node&lt;E&gt;"/>
                    </params>
                </method>
                <method name="casPrev" type="boolean" line="106">
                    <params>
                        <param name="cmp" type="Node&lt;E&gt;"/>
                        <param name="val" type="Node&lt;E&gt;"/>
                    </params>
                </method>
                <declaration name="UNSAFE" type="sun.misc.Unsafe" line="109"/>
                <declaration name="prevOffset" type="long" line="110"/>
                <declaration name="itemOffset" type="long" line="111"/>
                <declaration name="nextOffset" type="long" line="112"/>
                <scope line="113">
                    <scope line="114">
                        <declaration name="k" type="Class" line="116"/>
                    </scope>
                    <scope line="121"/>
                </scope>
            </class>
            <javadoc line="126">
                Links e as first element.                
            </javadoc>
            <method name="linkFirst" type="void" line="129">
                <params>
                    <param name="e" type="E"/>
                </params>
                <declaration name="newNode" type="Node&amp;lt;E&amp;gt;" line="131"/>
                <scope line="132">
                    <scope line="135">
                        <scope line="137"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="144">
                Links e as last element.                
            </javadoc>
            <method name="linkLast" type="void" line="147">
                <params>
                    <param name="e" type="E"/>
                </params>
                <declaration name="newNode" type="Node&amp;lt;E&amp;gt;" line="149"/>
                <scope line="150">
                    <scope line="153">
                        <scope line="155"/>
                    </scope>
                </scope>
            </method>
            <declaration name="HOPS" type="int" line="162"/>
            <javadoc line="163">
                Unlinks non-null node x.                
            </javadoc>
            <method name="unlink" type="void" line="166">
                <params>
                    <param name="x" type="Node&lt;E&gt;"/>
                </params>
                <declaration name="prev" type="Node&amp;lt;E&amp;gt;" line="167"/>
                <declaration name="next" type="Node&amp;lt;E&amp;gt;" line="168"/>
                <scope line="169"/>
                <scope line="172"/>
                <scope line="175">
                    <declaration name="activePred" type="Node&amp;lt;E&amp;gt;" line="176"/>
                    <declaration name="isFirst" type="boolean" line="177"/>
                    <declaration name="hops" type="int" line="178"/>
                    <scope line="179">
                        <scope line="180"/>
                        <declaration name="q" type="Node&amp;lt;E&amp;gt;" line="185"/>
                        <scope line="186"/>
                    </scope>
                    <scope line="195">
                        <scope line="196"/>
                        <declaration name="q" type="Node&amp;lt;E&amp;gt;" line="201"/>
                        <scope line="202"/>
                    </scope>
                    <scope line="214"/>
                </scope>
            </method>
            <javadoc line="222">
                Unlinks non-null first node.                
            </javadoc>
            <method name="unlinkFirst" type="void" line="225">
                <params>
                    <param name="first" type="Node&lt;E&gt;"/>
                    <param name="next" type="Node&lt;E&gt;"/>
                </params>
                <scope line="226">
                    <scope line="227">
                        <scope line="228">
                            <scope line="230"/>
                        </scope>
                    </scope>
                    <scope line="240"/>
                </scope>
            </method>
            <javadoc line="246">
                Unlinks non-null last node.                
            </javadoc>
            <method name="unlinkLast" type="void" line="249">
                <params>
                    <param name="last" type="Node&lt;E&gt;"/>
                    <param name="prev" type="Node&lt;E&gt;"/>
                </params>
                <scope line="250">
                    <scope line="251">
                        <scope line="252">
                            <scope line="254"/>
                        </scope>
                    </scope>
                    <scope line="264"/>
                </scope>
            </method>
            <javadoc line="270">
                Guarantees that any node which was unlinked before a call to
                  this method will be unreachable from head after it returns.
                  Does not guarantee to eliminate slack, only that head will
                  point to a node that was active while this method was running.                
            </javadoc>
            <method name="updateHead" type="void" line="276">
                <declaration name="h" type="Node&amp;lt;E&amp;gt;" line="277"/>
                <scope line="278">
                    <scope line="279">
                        <scope line="280"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="289">
                Guarantees that any node which was unlinked before a call to
                  this method will be unreachable from tail after it returns.
                  Does not guarantee to eliminate slack, only that tail will
                  point to a node that was active while this method was running.                
            </javadoc>
            <method name="updateTail" type="void" line="295">
                <declaration name="t" type="Node&amp;lt;E&amp;gt;" line="296"/>
                <scope line="297">
                    <scope line="298">
                        <scope line="299"/>
                    </scope>
                </scope>
            </method>
            <method name="skipDeletedPredecessors" type="void" line="308">
                <params>
                    <param name="x" type="Node&lt;E&gt;"/>
                </params>
                <scope line="309">
                    <declaration name="prev" type="Node&amp;lt;E&amp;gt;" line="310"/>
                    <declaration name="p" type="Node&amp;lt;E&amp;gt;" line="311"/>
                    <scope line="312">
                        <declaration name="q" type="Node&amp;lt;E&amp;gt;" line="314"/>
                        <scope line="315"/>
                    </scope>
                </scope>
            </method>
            <method name="skipDeletedSuccessors" type="void" line="326">
                <params>
                    <param name="x" type="Node&lt;E&gt;"/>
                </params>
                <scope line="327">
                    <declaration name="next" type="Node&amp;lt;E&amp;gt;" line="328"/>
                    <declaration name="p" type="Node&amp;lt;E&amp;gt;" line="329"/>
                    <scope line="330">
                        <declaration name="q" type="Node&amp;lt;E&amp;gt;" line="332"/>
                        <scope line="333"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="344">
                Returns the successor of p, or the first node if p.next has been
                  linked to self, which will only be true if traversing with a
                  stale pointer that is now off the list.                
            </javadoc>
            <method name="succ" type="Node&lt;E&gt;" line="349">
                <params>
                    <param name="p" type="Node&lt;E&gt;"/>
                </params>
                <declaration name="q" type="Node&amp;lt;E&amp;gt;" line="350"/>
            </method>
            <javadoc line="353">
                Returns the predecessor of p, or the last node if p.prev has been
                  linked to self, which will only be true if traversing with a
                  stale pointer that is now off the list.                
            </javadoc>
            <method name="pred" type="Node&lt;E&gt;" line="358">
                <params>
                    <param name="p" type="Node&lt;E&gt;"/>
                </params>
                <declaration name="q" type="Node&amp;lt;E&amp;gt;" line="359"/>
            </method>
            <javadoc line="362">
                Returns the first node, the unique node p for which:
                  p.prev == null &amp;&amp; p.next != p
                  The returned node may or may not be logically deleted.
                  Guarantees that head is set to the returned node.                
            </javadoc>
            <method name="first" type="Node&lt;E&gt;" line="368">
                <scope line="369"/>
            </method>
            <javadoc line="375">
                Returns the last node, the unique node p for which:
                  p.next == null &amp;&amp; p.prev != p
                  The returned node may or may not be logically deleted.
                  Guarantees that tail is set to the returned node.                
            </javadoc>
            <method name="last" type="Node&lt;E&gt;" line="381">
                <scope line="382"/>
            </method>
            <javadoc line="388">
                Throws NullPointerException if argument is null.                
                <param>
                    v the element                    
                </param>
            </javadoc>
            <method name="checkNotNull" type="void" line="392">
                <params>
                    <param name="v" type="Object"/>
                </params>
            </method>
            <javadoc line="395">
                Returns element unless it is null, in which case throws
                  NoSuchElementException.                
                <param>
                    v the element                    
                </param>
                <return>
                    the element                    
                </return>
            </javadoc>
            <method name="screenNullResult" type="E" line="401">
                <params>
                    <param name="v" type="E"/>
                </params>
            </method>
            <javadoc line="405">
                Creates an array list and fills it with elements of this list.
                  Used by toArray.                
                <return>
                    the arrayList                    
                </return>
            </javadoc>
            <method name="toArrayList" type="ArrayList&lt;E&gt;" line="410">
                <declaration name="list" type="ArrayList&amp;lt;E&amp;gt;" line="411"/>
                <scope line="412">
                    <declaration name="item" type="E" line="413"/>
                </scope>
            </method>
            <javadoc line="418">
                Constructs an empty deque.                
            </javadoc>
            <method name="ConcurrentLinkedDeque" type="constructor" line="421"/>
            <javadoc line="424">
                Constructs a deque initially containing the elements of
                  the given collection, added in traversal order of the
                  collection&apos;s iterator.                
                <param>
                    c the collection of elements to initially contain                    
                </param>
                <throws>
                    NullPointerException if the specified collection or any
                      of its elements are null                    
                </throws>
            </javadoc>
            <method name="ConcurrentLinkedDeque" type="constructor" line="432">
                <params>
                    <param name="c" type="Collection&lt;? extends E&gt;"/>
                </params>
                <declaration name="h" type="Node&amp;lt;E&amp;gt;" line="433"/>
                <scope line="434">
                    <declaration name="newNode" type="Node&amp;lt;E&amp;gt;" line="436"/>
                    <scope line="438"/>
                </scope>
            </method>
            <javadoc line="446">
                Initializes head and tail, ensuring invariants hold.                
            </javadoc>
            <method name="initHeadTail" type="void" line="449">
                <params>
                    <param name="h" type="Node&lt;E&gt;"/>
                    <param name="t" type="Node&lt;E&gt;"/>
                </params>
                <scope line="450">
                    <scope line="452">
                        <declaration name="newNode" type="Node&amp;lt;E&amp;gt;" line="453"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="462">
                Inserts the specified element at the front of this deque.
                  As the deque is unbounded, this method will never throw{@link IllegalStateException}.                
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="addFirst" type="void" line="467">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="470">
                Inserts the specified element at the end of this deque.
                  As the deque is unbounded, this method will never throw{@link IllegalStateException}.
                  &lt;p&gt;This method is equivalent to {@link #add}.                
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="addLast" type="void" line="476">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="479">
                Inserts the specified element at the front of this deque.
                  As the deque is unbounded, this method will never return {@code false}.                
                <return>
                    {@code true} (as specified by {@link Deque#offerFirst})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offerFirst" type="boolean" line="485">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="489">
                Inserts the specified element at the end of this deque.
                  As the deque is unbounded, this method will never return {@code false}.
                  &lt;p&gt;This method is equivalent to {@link #add}.                
                <return>
                    {@code true} (as specified by {@link Deque#offerLast})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offerLast" type="boolean" line="496">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <method name="peekFirst" type="E" line="500">
                <scope line="501">
                    <declaration name="item" type="E" line="502"/>
                </scope>
            </method>
            <method name="peekLast" type="E" line="507">
                <scope line="508">
                    <declaration name="item" type="E" line="509"/>
                </scope>
            </method>
            <javadoc line="514">
                @throws NoSuchElementException {@inheritDoc}                
            </javadoc>
            <method name="getFirst" type="E" line="517"/>
            <javadoc line="520">
                @throws NoSuchElementException {@inheritDoc}                
            </javadoc>
            <method name="getLast" type="E" line="523"/>
            <method name="pollFirst" type="E" line="526">
                <scope line="527">
                    <declaration name="item" type="E" line="528"/>
                    <scope line="529"/>
                </scope>
            </method>
            <method name="pollLast" type="E" line="536">
                <scope line="537">
                    <declaration name="item" type="E" line="538"/>
                    <scope line="539"/>
                </scope>
            </method>
            <javadoc line="546">
                @throws NoSuchElementException {@inheritDoc}                
            </javadoc>
            <method name="removeFirst" type="E" line="549"/>
            <javadoc line="552">
                @throws NoSuchElementException {@inheritDoc}                
            </javadoc>
            <method name="removeLast" type="E" line="555"/>
            <javadoc line="558">
                Inserts the specified element at the tail of this deque.
                  As the deque is unbounded, this method will never return {@code false}.                
                <return>
                    {@code true} (as specified by {@link Queue#offer})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="564">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="567">
                Inserts the specified element at the tail of this deque.
                  As the deque is unbounded, this method will never throw{@link IllegalStateException} or return {@code false}.                
                <return>
                    {@code true} (as specified by {@link Collection#add})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="add" type="boolean" line="573">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <method name="poll" type="E" line="576"/>
            <method name="remove" type="E" line="579"/>
            <method name="peek" type="E" line="582"/>
            <method name="element" type="E" line="585"/>
            <method name="push" type="void" line="588">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <method name="pop" type="E" line="591"/>
            <javadoc line="594">
                Removes the first element {@code e} such that{@code o.equals(e)}, if such an element exists in this deque.
                  If the deque does not contain the element, it is unchanged.                
                <param>
                    o element to be removed from this deque, if present                    
                </param>
                <return>
                    {@code true} if the deque contained the specified element                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="removeFirstOccurrence" type="boolean" line="601">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="603">
                    <declaration name="item" type="E" line="604"/>
                    <scope line="605"/>
                </scope>
            </method>
            <javadoc line="612">
                Removes the last element {@code e} such that{@code o.equals(e)}, if such an element exists in this deque.
                  If the deque does not contain the element, it is unchanged.                
                <param>
                    o element to be removed from this deque, if present                    
                </param>
                <return>
                    {@code true} if the deque contained the specified element                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="removeLastOccurrence" type="boolean" line="619">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="621">
                    <declaration name="item" type="E" line="622"/>
                    <scope line="623"/>
                </scope>
            </method>
            <javadoc line="630">
                Returns {@code true} if this deque contains at least one
                  element {@code e} such that {@code o.equals(e)}.                
                <param>
                    o element whose presence in this deque is to be tested                    
                </param>
                <return>
                    {@code true} if this deque contains the specified element                    
                </return>
            </javadoc>
            <method name="contains" type="boolean" line="636">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="638">
                    <declaration name="item" type="E" line="639"/>
                </scope>
            </method>
            <javadoc line="644">
                Returns {@code true} if this collection contains no elements.                
                <return>
                    {@code true} if this collection contains no elements                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="648"/>
            <javadoc line="651">
                Returns the number of elements in this deque.  If this deque
                  contains more than {@code Integer.MAX_VALUE} elements, it
                  returns {@code Integer.MAX_VALUE}.
                  &lt;p&gt;Beware that, unlike in most collections, this method is
                  &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these deques, determining the current
                  number of elements requires traversing them all to count them.
                  Additionally, it is possible for the size to change during
                  execution of this method, in which case the returned result
                  will be inaccurate. Thus, this method is typically not very
                  useful in concurrent applications.                
                <return>
                    the number of elements in this deque                    
                </return>
            </javadoc>
            <method name="size" type="int" line="665">
                <declaration name="count" type="int" line="666"/>
            </method>
            <javadoc line="670">
                Removes the first element {@code e} such that{@code o.equals(e)}, if such an element exists in this deque.
                  If the deque does not contain the element, it is unchanged.                
                <param>
                    o element to be removed from this deque, if present                    
                </param>
                <return>
                    {@code true} if the deque contained the specified element                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="remove" type="boolean" line="677">
                <params>
                    <param name="o" type="Object"/>
                </params>
            </method>
            <javadoc line="680">
                Appends all of the elements in the specified collection to the end of
                  this deque, in the order that they are returned by the specified
                  collection&apos;s iterator.  Attempts to {@code addAll} of a deque to
                  itself result in {@code IllegalArgumentException}.                
                <param>
                    c the elements to be inserted into this deque                    
                </param>
                <return>
                    {@code true} if this deque changed as a result of the call                    
                </return>
                <throws>
                    NullPointerException if the specified collection or any
                      of its elements are null                    
                </throws>
                <throws>
                    IllegalArgumentException if the collection is this deque                    
                </throws>
            </javadoc>
            <method name="addAll" type="boolean" line="691">
                <params>
                    <param name="c" type="Collection&lt;? extends E&gt;"/>
                </params>
                <declaration name="beginningOfTheEnd" type="Node&amp;lt;E&amp;gt;" line="693"/>
                <scope line="694">
                    <declaration name="newNode" type="Node&amp;lt;E&amp;gt;" line="696"/>
                    <scope line="698"/>
                </scope>
                <scope line="705">
                    <scope line="708">
                        <scope line="710">
                            <scope line="711"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="720">
                Removes all of the elements from this deque.                
            </javadoc>
            <method name="clear" type="void" line="723"/>
            <javadoc line="726">
                Returns an array containing all of the elements in this deque, in
                  proper sequence (from first to last element).
                  &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
                  maintained by this deque.  (In other words, this method must allocate
                  a new array).  The caller is thus free to modify the returned array.
                  &lt;p&gt;This method acts as bridge between array-based and collection-based
                  APIs.                
                <return>
                    an array containing all of the elements in this deque                    
                </return>
            </javadoc>
            <method name="toArray" type="Object[]" line="736"/>
            <javadoc line="739">
                Returns an array containing all of the elements in this deque,
                  in proper sequence (from first to last element); the runtime
                  type of the returned array is that of the specified array.  If
                  the deque fits in the specified array, it is returned therein.
                  Otherwise, a new array is allocated with the runtime type of
                  the specified array and the size of this deque.
                  &lt;p&gt;If this deque fits in the specified array with room to spare
                  (i.e., the array has more elements than this deque), the element in
                  the array immediately following the end of the deque is set to{@code null}.
                  &lt;p&gt;Like the {@link #toArray()} method, this method acts as
                  bridge between array-based and collection-based APIs.  Further,
                  this method allows precise control over the runtime type of the
                  output array, and may, under certain circumstances, be used to
                  save allocation costs.
                  &lt;p&gt;Suppose {@code x} is a deque known to contain only strings.
                  The following code can be used to dump the deque into a newly
                  allocated array of {@code String}:
                  &lt;pre&gt;
                  String[] y = x.toArray(new String[0]);&lt;/pre&gt;
                  Note that {@code toArray(new Object[0])} is identical in function to{@code toArray()}.                
                <param>
                    a the array into which the elements of the deque are to
                      be stored, if it is big enough; otherwise, a new array of the
                      same runtime type is allocated for this purpose                    
                </param>
                <return>
                    an array containing all of the elements in this deque                    
                </return>
                <throws>
                    ArrayStoreException if the runtime type of the specified array
                      is not a supertype of the runtime type of every element in
                      this deque                    
                </throws>
                <throws>
                    NullPointerException if the specified array is null                    
                </throws>
            </javadoc>
            <method name="toArray" type="T[]" line="769">
                <params>
                    <param name="a" type="T[]"/>
                </params>
            </method>
            <javadoc line="772">
                Returns an iterator over the elements in this deque in proper sequence.
                  The elements will be returned in order from first (head) to last (tail).
                  &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that
                  will never throw {@link java.util.ConcurrentModificationExceptionConcurrentModificationException}, and guarantees to traverse
                  elements as they existed upon construction of the iterator, and
                  may (but is not guaranteed to) reflect any modifications
                  subsequent to construction.                
                <return>
                    an iterator over the elements in this deque in proper sequence                    
                </return>
            </javadoc>
            <method name="iterator" type="Iterator&lt;E&gt;" line="782"/>
            <javadoc line="785">
                Returns an iterator over the elements in this deque in reverse
                  sequential order.  The elements will be returned in order from
                  last (tail) to first (head).
                  &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that
                  will never throw {@link java.util.ConcurrentModificationExceptionConcurrentModificationException}, and guarantees to traverse
                  elements as they existed upon construction of the iterator, and
                  may (but is not guaranteed to) reflect any modifications
                  subsequent to construction.                
                <return>
                    an iterator over the elements in this deque in reverse order                    
                </return>
            </javadoc>
            <method name="descendingIterator" type="Iterator&lt;E&gt;" line="796"/>
            <class name="AbstractItr" line="799">
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="nextNode" type="Node&amp;lt;E&amp;gt;" line="800"/>
                <javadoc line="800">
                    Next node to return item for.                    
                </javadoc>
                <declaration name="nextItem" type="E" line="804"/>
                <javadoc line="804">
                    nextItem holds on to item fields because once we claim
                      that an element exists in hasNext(), we must return it in
                      the following next() call even if it was in the process of
                      being removed when hasNext() was called.                    
                </javadoc>
                <declaration name="lastRet" type="Node&amp;lt;E&amp;gt;" line="811"/>
                <javadoc line="811">
                    Node returned by most recent call to next. Needed by remove.
                      Reset to null if this element is deleted by a call to remove.                    
                </javadoc>
                <method name="startNode" type="Node&lt;E&gt;" line="816"/>
                <method name="nextNode" type="Node&lt;E&gt;" line="817"/>
                <method name="AbstractItr" type="constructor" line="818"/>
                <javadoc line="821">
                    Sets nextNode and nextItem to next valid node, or to null
                      if no such.                    
                </javadoc>
                <method name="advance" type="void" line="825">
                    <declaration name="p" type="Node&amp;lt;E&amp;gt;" line="827"/>
                    <scope line="828">
                        <scope line="829"/>
                        <declaration name="item" type="E" line="834"/>
                        <scope line="835"/>
                    </scope>
                </method>
                <method name="hasNext" type="boolean" line="842"/>
                <method name="next" type="E" line="845">
                    <declaration name="item" type="E" line="846"/>
                </method>
                <method name="remove" type="void" line="851">
                    <declaration name="l" type="Node&amp;lt;E&amp;gt;" line="852"/>
                </method>
            </class>
            <class name="Itr" line="859">
                <extends class="AbstractItr"/>
                <javadoc line="859">
                    Forward iterator                    
                </javadoc>
                <method name="startNode" type="Node&lt;E&gt;" line="863"/>
                <method name="nextNode" type="Node&lt;E&gt;" line="866">
                    <params>
                        <param name="p" type="Node&lt;E&gt;"/>
                    </params>
                </method>
            </class>
            <class name="DescendingItr" line="870">
                <extends class="AbstractItr"/>
                <javadoc line="870">
                    Descending iterator                    
                </javadoc>
                <method name="startNode" type="Node&lt;E&gt;" line="874"/>
                <method name="nextNode" type="Node&lt;E&gt;" line="877">
                    <params>
                        <param name="p" type="Node&lt;E&gt;"/>
                    </params>
                </method>
            </class>
            <javadoc line="881">
                Saves the state to a stream (that is, serializes it).                
                <serialData>
                    All of the elements (each an {@code E}) in
                      the proper order, followed by a null                    
                </serialData>
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="887">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <scope line="889">
                    <declaration name="item" type="E" line="890"/>
                </scope>
            </method>
            <javadoc line="895">
                Reconstitutes the instance from a stream (that is, deserializes it).                
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="899">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <declaration name="h" type="Node&amp;lt;E&amp;gt;" line="901"/>
                <declaration name="item" type="Object" line="902"/>
                <scope line="903">
                    <declaration name="newNode" type="Node&amp;lt;E&amp;gt;" line="904"/>
                    <scope line="906"/>
                </scope>
            </method>
            <method name="casHead" type="boolean" line="914">
                <params>
                    <param name="cmp" type="Node&lt;E&gt;"/>
                    <param name="val" type="Node&lt;E&gt;"/>
                </params>
            </method>
            <method name="casTail" type="boolean" line="917">
                <params>
                    <param name="cmp" type="Node&lt;E&gt;"/>
                    <param name="val" type="Node&lt;E&gt;"/>
                </params>
            </method>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="920"/>
            <declaration name="headOffset" type="long" line="921"/>
            <declaration name="tailOffset" type="long" line="922"/>
            <scope line="923">
                <scope line="928">
                    <declaration name="k" type="Class" line="930"/>
                </scope>
                <scope line="934"/>
            </scope>
        </class>
    </source>