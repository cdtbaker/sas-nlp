<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.concurrent.atomic"/>
        <import package="java.util.concurrent.locks.LockSupport"/>
        <class name="Exchanger" line="4">
            <type_params>
                <type_param name="V"/>
            </type_params>
            <javadoc line="4">
                A synchronization point at which threads can pair and swap elements
                  within pairs.  Each thread presents some object on entry to the{@link #exchange exchange} method, matches with a partner thread,
                  and receives its partner&apos;s object on return.  An Exchanger may be
                  viewed as a bidirectional form of a {@link SynchronousQueue}.
                  Exchangers may be useful in applications such as genetic algorithms
                  and pipeline designs.
                  &lt;p&gt;&lt;b&gt;Sample Usage:&lt;/b&gt;
                  Here are the highlights of a class that uses an {@code Exchanger}to swap buffers between threads so that the thread filling the
                  buffer gets a freshly emptied one when it needs it, handing off the
                  filled one to the thread emptying the buffer.
                  &lt;pre&gt;{@code}class FillAndEmpty 
                  Exchanger&lt;DataBuffer&gt; exchanger = new Exchanger&lt;DataBuffer&gt;();
                  DataBuffer initialEmptyBuffer = ... a made-up type
                  DataBuffer initialFullBuffer = ...
                  class FillingLoop implements Runnable {
                  public void run() {
                  DataBuffer currentBuffer = initialEmptyBuffer;
                  try {
                  while (currentBuffer != null) {
                  addToBuffer(currentBuffer);
                  if (currentBuffer.isFull())
                  currentBuffer = exchanger.exchange(currentBuffer);
                  }
                  } catch (InterruptedException ex) { ... handle ... }
                  }
                  }
                  class EmptyingLoop implements Runnable {
                  public void run() {
                  DataBuffer currentBuffer = initialFullBuffer;
                  try {
                  while (currentBuffer != null) {
                  takeFromBuffer(currentBuffer);
                  if (currentBuffer.isEmpty())
                  currentBuffer = exchanger.exchange(currentBuffer);
                  }
                  } catch (InterruptedException ex) { ... handle ...}
                  }
                  }
                  void start() {
                  new Thread(new FillingLoop()).start();
                  new Thread(new EmptyingLoop()).start();
                  }
                  }
                  }&lt;/pre&gt;
                  &lt;p&gt;Memory consistency effects: For each pair of threads that
                  successfully exchange objects via an {@code Exchanger}, actions
                  prior to the {@code exchange()} in each thread
                  &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                  those subsequent to a return from the corresponding {@code exchange()}in the other thread.                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea and Bill Scherer and Michael Scott                    
                </author>
                <param>
                    <V>
                      The type of objects that may be exchanged                    
                </param>
            </javadoc>
            <declaration name="NCPU" type="int" line="60"/>
            <javadoc line="60">
                The number of CPUs, for sizing and spin control                
            </javadoc>
            <declaration name="CAPACITY" type="int" line="64"/>
            <javadoc line="64">
                The capacity of the arena.  Set to a value that provides more
                  than enough space to handle contention.  On small machines
                  most slots won&apos;t be used, but it is still not wasted because
                  the extra space provides some machine-level address padding
                  to minimize interference with heavily CAS&apos;ed Slot locations.
                  And on very large machines, performance eventually becomes
                  bounded by memory bandwidth, not numbers of threads/CPUs.
                  This constant cannot be changed without also modifying
                  indexing and hashing algorithms.                
            </javadoc>
            <declaration name="FULL" type="int" line="76"/>
            <javadoc line="76">
                The value of &quot;max&quot; that will hold all threads without
                  contention.  When this value is less than CAPACITY, some
                  otherwise wasted expansion can be avoided.                
            </javadoc>
            <declaration name="SPINS" type="int" line="82"/>
            <javadoc line="82">
                The number of times to spin (doing nothing except polling a
                  memory location) before blocking or giving up while waiting to
                  be fulfilled.  Should be zero on uniprocessors.  On
                  multiprocessors, this value should be large enough so that two
                  threads exchanging items as fast as possible block only when
                  one of them is stalled (due to GC or preemption), but not much
                  longer, to avoid wasting CPU resources.  Seen differently, this
                  value is a little over half the number of cycles of an average
                  context switch time on most systems.  The value here is
                  approximately the average of those across a range of tested
                  systems.                
            </javadoc>
            <declaration name="TIMED_SPINS" type="int" line="96"/>
            <javadoc line="96">
                The number of times to spin before blocking in timed waits.
                  Timed waits spin more slowly because checking the time takes
                  time.  The best value relies mainly on the relative rate of
                  System.nanoTime vs memory accesses.  The value is empirically
                  derived to work well across a variety of systems.                
            </javadoc>
            <declaration name="CANCEL" type="Object" line="104"/>
            <javadoc line="104">
                Sentinel item representing cancellation of a wait due to
                  interruption, timeout, or elapsed spin-waits.  This value is
                  placed in holes on cancellation, and used as a return value
                  from waiting methods to indicate failure to set or get hole.                
            </javadoc>
            <declaration name="NULL_ITEM" type="Object" line="111"/>
            <javadoc line="111">
                Value representing null arguments/returns from public
                  methods.  This disambiguates from internal requirement that
                  holes start out as null to mean they are not yet set.                
            </javadoc>
            <class name="Node" line="117">
                <extends class="AtomicReference">
                    <type_params>
                        <type_param name="Object"/>
                    </type_params>
                </extends>
                <javadoc line="117">
                    Nodes hold partially exchanged data.  This class
                      opportunistically subclasses AtomicReference to represent the
                      hole.  So get() returns hole, and compareAndSet CAS&apos;es value
                      into hole.  This class cannot be parameterized as &quot;V&quot; because
                      of the use of non-V CANCEL sentinels.                    
                </javadoc>
                <declaration name="item" type="Object" line="125"/>
                <javadoc line="125">
                    The element offered by the Thread creating this node.                    
                </javadoc>
                <declaration name="waiter" type="Thread" line="129"/>
                <javadoc line="129">
                    The Thread waiting to be signalled; null until waiting.                    
                </javadoc>
                <javadoc line="133">
                    Creates node with given item and empty hole.                    
                    <param>
                        item the item                        
                    </param>
                </javadoc>
                <method name="Node" type="constructor" line="137">
                    <params>
                        <param name="item" type="Object"/>
                    </params>
                </method>
            </class>
            <class name="Slot" line="141">
                <extends class="AtomicReference">
                    <type_params>
                        <type_param name="Object"/>
                    </type_params>
                </extends>
                <javadoc line="141">
                    A Slot is an AtomicReference with heuristic padding to lessen
                      cache effects of this heavily CAS&apos;ed location.  While the
                      padding adds noticeable space, all slots are created only on
                      demand, and there will be more than one of them only when it
                      would improve throughput more than enough to outweigh using
                      extra space.                    
                </javadoc>
                <declaration name="q0" type="long" line="150"/>
            </class>
            <declaration name="arena" type="Slot[]" line="152"/>
            <javadoc line="152">
                Slot array.  Elements are lazily initialized when needed.
                  Declared volatile to enable double-checked lazy construction.                
            </javadoc>
            <declaration name="max" type="AtomicInteger" line="157"/>
            <javadoc line="157">
                The maximum slot index being used.  The value sometimes
                  increases when a thread experiences too many CAS contentions,
                  and sometimes decreases when a spin-wait elapses.  Changes
                  are performed only via compareAndSet, to avoid stale values
                  when a thread happens to stall right before setting.                
            </javadoc>
            <javadoc line="165">
                Main exchange function, handling the different policy variants.
                  Uses Object, not &quot;V&quot; as argument and return value to simplify
                  handling of sentinel values.  Callers from public methods decode
                  and cast accordingly.                
                <param>
                    item the (non-null) item to exchange                    
                </param>
                <param>
                    timed true if the wait is timed                    
                </param>
                <param>
                    nanos if timed, the maximum wait time                    
                </param>
                <return>
                    the other thread's item, or CANCEL if interrupted or timed out                    
                </return>
            </javadoc>
            <method name="doExchange" type="Object" line="175">
                <params>
                    <param name="item" type="Object"/>
                    <param name="timed" type="boolean"/>
                    <param name="nanos" type="long"/>
                </params>
                <declaration name="me" type="Node" line="176"/>
                <declaration name="index" type="int" line="177"/>
                <declaration name="fails" type="int" line="178"/>
                <scope line="179">
                    <declaration name="y" type="Object" line="180"/>
                    <declaration name="slot" type="Slot" line="181"/>
                    <scope line="183">
                        <declaration name="you" type="Node" line="184"/>
                        <scope line="185"/>
                    </scope>
                    <scope line="190">
                        <declaration name="v" type="Object" line="192"/>
                        <declaration name="m" type="int" line="195"/>
                    </scope>
                    <scope line="198">
                        <declaration name="m" type="int" line="199"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="205">
                Returns a hash index for the current thread.  Uses a one-step
                  FNV-1a hash code (http://www.isthe.com/chongo/tech/comp/fnv/)
                  based on the current thread&apos;s Thread.getId().  These hash codes
                  have more uniform distribution properties with respect to small
                  moduli (here 1-31) than do other simple hashing functions.
                  &lt;p&gt;To return an index between 0 and max, we use a cheap
                  approximation to a mod operation, that also corrects for bias
                  due to non-power-of-2 remaindering (see {@link java.util.Random#nextInt}).  Bits of the hashcode are masked
                  with &quot;nbits&quot;, the ceiling power of two of table size (looked up
                  in a table packed into three ints).  If too large, this is
                  retried after rotating the hash by nbits bits, while forcing new
                  top bit to 0, which guarantees eventual termination (although
                  with a non-random-bias).  This requires an average of less than
                  2 tries for all table sizes, and has a maximum 2% difference
                  from perfectly uniform slot probabilities when applied to all
                  possible hash codes for sizes less than 32.                
                <return>
                    a per-thread-random index, 0 <= index < max                    
                </return>
            </javadoc>
            <method name="hashIndex" type="int" line="224">
                <declaration name="id" type="long" line="225"/>
                <declaration name="hash" type="int" line="226"/>
                <declaration name="m" type="int" line="227"/>
                <declaration name="nbits" type="int" line="228"/>
                <declaration name="index" type="int" line="229"/>
            </method>
            <javadoc line="233">
                Creates a new slot at given index.  Called only when the slot
                  appears to be null.  Relies on double-check using builtin
                  locks, since they rarely contend.  This in turn relies on the
                  arena array being declared volatile.                
                <param>
                    index the index to add slot at                    
                </param>
            </javadoc>
            <method name="createSlot" type="void" line="240">
                <params>
                    <param name="index" type="int"/>
                </params>
                <declaration name="newSlot" type="Slot" line="241"/>
                <declaration name="a" type="Slot[]" line="242"/>
                <scope line="243"/>
            </method>
            <javadoc line="247">
                Tries to cancel a wait for the given node waiting in the given
                  slot, if so, helping clear the node from its slot to avoid
                  garbage retention.                
                <param>
                    node the waiting node                    
                </param>
                <param>
                    the slot it is waiting in                    
                </param>
                <return>
                    true if successfully cancelled                    
                </return>
            </javadoc>
            <method name="tryCancel" type="boolean" line="255">
                <params>
                    <param name="node" type="Node"/>
                    <param name="slot" type="Slot"/>
                </params>
            </method>
            <javadoc line="260">
                Spin-waits for hole for a non-0 slot.  Fails if spin elapses
                  before hole filled.  Does not check interrupt, relying on check
                  in public exchange method to abort if interrupted on entry.                
                <param>
                    node the waiting node                    
                </param>
                <return>
                    on success, the hole; on failure, CANCEL                    
                </return>
            </javadoc>
            <method name="spinWait" type="Object" line="267">
                <params>
                    <param name="node" type="Node"/>
                    <param name="slot" type="Slot"/>
                </params>
                <declaration name="spins" type="int" line="268"/>
                <scope line="269">
                    <declaration name="v" type="Object" line="270"/>
                </scope>
            </method>
            <javadoc line="276">
                Waits for (by spinning and/or blocking) and gets the hole
                  filled in by another thread.  Fails if interrupted before
                  hole filled.
                  When a node/thread is about to block, it sets its waiter field
                  and then rechecks state at least one more time before actually
                  parking, thus covering race vs fulfiller noticing that waiter
                  is non-null so should be woken.
                  Thread interruption status is checked only surrounding calls to
                  park.  The caller is assumed to have checked interrupt status
                  on entry.                
                <param>
                    node the waiting node                    
                </param>
                <return>
                    on success, the hole; on failure, CANCEL                    
                </return>
            </javadoc>
            <method name="await" type="Object" line="290">
                <params>
                    <param name="node" type="Node"/>
                    <param name="slot" type="Slot"/>
                </params>
                <declaration name="w" type="Thread" line="291"/>
                <declaration name="spins" type="int" line="292"/>
                <scope line="293">
                    <declaration name="v" type="Object" line="294"/>
                </scope>
            </method>
            <javadoc line="302">
                Waits for (at index 0) and gets the hole filled in by another
                  thread.  Fails if timed out or interrupted before hole filled.
                  Same basic logic as untimed version, but a bit messier.                
                <param>
                    node the waiting node                    
                </param>
                <param>
                    nanos the wait time                    
                </param>
                <return>
                    on success, the hole; on failure, CANCEL                    
                </return>
            </javadoc>
            <method name="awaitNanos" type="Object" line="310">
                <params>
                    <param name="node" type="Node"/>
                    <param name="slot" type="Slot"/>
                    <param name="nanos" type="long"/>
                </params>
                <declaration name="spins" type="int" line="311"/>
                <declaration name="lastTime" type="long" line="312"/>
                <declaration name="w" type="Thread" line="313"/>
                <scope line="314">
                    <declaration name="v" type="Object" line="315"/>
                    <declaration name="now" type="long" line="317"/>
                    <scope line="321"/>
                </scope>
            </method>
            <javadoc line="330">
                Sweeps through arena checking for any waiting threads.  Called
                  only upon return from timeout while waiting in slot 0.  When a
                  thread gives up on a timed wait, it is possible that a
                  previously-entered thread is still waiting in some other
                  slot.  So we scan to check for any.  This is almost always
                  overkill, but decreases the likelihood of timeouts when there
                  are other threads present to far less than that in lock-based
                  exchangers in which earlier-arriving threads may still be
                  waiting on entry locks.                
                <param>
                    node the waiting node                    
                </param>
                <return>
                    another thread's item, or CANCEL                    
                </return>
            </javadoc>
            <method name="scanOnTimeout" type="Object" line="343">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="y" type="Object" line="344"/>
                <scope line="345">
                    <declaration name="slot" type="Slot" line="346"/>
                    <scope line="347">
                        <scope line="348">
                            <scope line="349">
                                <declaration name="you" type="Node" line="350"/>
                                <scope line="351"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="361">
                Creates a new Exchanger.                
            </javadoc>
            <method name="Exchanger" type="constructor" line="364"/>
            <javadoc line="366">
                Waits for another thread to arrive at this exchange point (unless
                  the current thread is {@linkplain Thread#interrupt interrupted}),
                  and then transfers the given object to it, receiving its object
                  in return.
                  &lt;p&gt;If another thread is already waiting at the exchange point then
                  it is resumed for thread scheduling purposes and receives the object
                  passed in by the current thread.  The current thread returns immediately,
                  receiving the object passed to the exchange by that other thread.
                  &lt;p&gt;If no other thread is already waiting at the exchange then the
                  current thread is disabled for thread scheduling purposes and lies
                  dormant until one of two things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread enters the exchange; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread.
                  &lt;/ul&gt;
                  &lt;p&gt;If the current thread:
                  &lt;ul&gt;
                  &lt;li&gt;has its interrupted status set on entry to this method; or
                  &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
                  for the exchange,
                  &lt;/ul&gt;
                  then {@link InterruptedException} is thrown and the current thread&apos;s
                  interrupted status is cleared.                
                <param>
                    x the object to exchange                    
                </param>
                <return>
                    the object provided by the other thread                    
                </return>
                <throws>
                    InterruptedException if the current thread was
                      interrupted while waiting                    
                </throws>
            </javadoc>
            <method name="exchange" type="V" line="395">
                <params>
                    <param name="x" type="V"/>
                </params>
                <scope line="396">
                    <declaration name="v" type="Object" line="397"/>
                </scope>
            </method>
            <javadoc line="404">
                Waits for another thread to arrive at this exchange point (unless
                  the current thread is {@linkplain Thread#interrupt interrupted} or
                  the specified waiting time elapses), and then transfers the given
                  object to it, receiving its object in return.
                  &lt;p&gt;If another thread is already waiting at the exchange point then
                  it is resumed for thread scheduling purposes and receives the object
                  passed in by the current thread.  The current thread returns immediately,
                  receiving the object passed to the exchange by that other thread.
                  &lt;p&gt;If no other thread is already waiting at the exchange then the
                  current thread is disabled for thread scheduling purposes and lies
                  dormant until one of three things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread enters the exchange; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread; or
                  &lt;li&gt;The specified waiting time elapses.
                  &lt;/ul&gt;
                  &lt;p&gt;If the current thread:
                  &lt;ul&gt;
                  &lt;li&gt;has its interrupted status set on entry to this method; or
                  &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
                  for the exchange,
                  &lt;/ul&gt;
                  then {@link InterruptedException} is thrown and the current thread&apos;s
                  interrupted status is cleared.
                  &lt;p&gt;If the specified waiting time elapses then {@link TimeoutException} is thrown.  If the time is less than or equal
                  to zero, the method will not wait at all.                
                <param>
                    x the object to exchange                    
                </param>
                <param>
                    timeout the maximum time to wait                    
                </param>
                <param>
                    unit the time unit of the <tt>timeout</tt> argument                    
                </param>
                <return>
                    the object provided by the other thread                    
                </return>
                <throws>
                    InterruptedException if the current thread was
                      interrupted while waiting                    
                </throws>
                <throws>
                    TimeoutException if the specified waiting time elapses
                      before another thread enters the exchange                    
                </throws>
            </javadoc>
            <method name="exchange" type="V" line="440">
                <params>
                    <param name="x" type="V"/>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <scope line="441">
                    <declaration name="v" type="Object" line="442"/>
                </scope>
            </method>
        </class>
    </source>