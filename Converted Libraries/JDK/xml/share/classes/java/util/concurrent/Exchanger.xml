<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.concurrent.atomic"/>
        <import package="java.util.concurrent.locks.LockSupport"/>
        <class name="Exchanger" line="41">
            <type_params>
                <type_param name="V"/>
            </type_params>
            <comment line="107">
                Algorithm Description:
                
                 The basic idea is to maintain a &quot;slot&quot;, which is a reference to
                 a Node containing both an Item to offer and a &quot;hole&quot; waiting to
                 get filled in.  If an incoming &quot;occupying&quot; thread sees that the
                 slot is null, it CAS&apos;es (compareAndSets) a Node there and waits
                 for another to invoke exchange.  That second &quot;fulfilling&quot; thread
                 sees that the slot is non-null, and so CASes it back to null,
                 also exchanging items by CASing the hole, plus waking up the
                 occupying thread if it is blocked.  In each case CAS&apos;es may
                 fail because a slot at first appears non-null but is null upon
                 CAS, or vice-versa.  So threads may need to retry these
                 actions.
                
                 This simple approach works great when there are only a few
                 threads using an Exchanger, but performance rapidly
                 deteriorates due to CAS contention on the single slot when
                 there are lots of threads using an exchanger.  So instead we use
                 an &quot;arena&quot;; basically a kind of hash table with a dynamically
                 varying number of slots, any one of which can be used by
                 threads performing an exchange.  Incoming threads pick slots
                 based on a hash of their Thread ids.  If an incoming thread
                 fails to CAS in its chosen slot, it picks an alternative slot
                 instead.  And similarly from there.  If a thread successfully
                 CASes into a slot but no other thread arrives, it tries
                 another, heading toward the zero slot, which always exists even
                 if the table shrinks.  The particular mechanics controlling this
                 are as follows:
                
                 Waiting: Slot zero is special in that it is the only slot that
                 exists when there is no contention.  A thread occupying slot
                 zero will block if no thread fulfills it after a short spin.
                 In other cases, occupying threads eventually give up and try
                 another slot.  Waiting threads spin for a while (a period that
                 should be a little less than a typical context-switch time)
                 before either blocking (if slot zero) or giving up (if other
                 slots) and restarting.  There is no reason for threads to block
                 unless there are unlikely to be any other threads present.
                 Occupants are mainly avoiding memory contention so sit there
                 quietly polling for a shorter period than it would take to
                 block and then unblock them.  Non-slot-zero waits that elapse
                 because of lack of other threads waste around one extra
                 context-switch time per try, which is still on average much
                 faster than alternative approaches.
                
                 Sizing: Usually, using only a few slots suffices to reduce
                 contention.  Especially with small numbers of threads, using
                 too many slots can lead to just as poor performance as using
                 too few of them, and there&apos;s not much room for error.  The
                 variable &quot;max&quot; maintains the number of slots actually in
                 use.  It is increased when a thread sees too many CAS
                 failures.  (This is analogous to resizing a regular hash table
                 based on a target load factor, except here, growth steps are
                 just one-by-one rather than proportional.)  Growth requires
                 contention failures in each of three tried slots.  Requiring
                 multiple failures for expansion copes with the fact that some
                 failed CASes are not due to contention but instead to simple
                 races between two threads or thread pre-emptions occurring
                 between reading and CASing.  Also, very transient peak
                 contention can be much higher than the average sustainable
                 levels.  An attempt to decrease the max limit is usually made
                 when a non-slot-zero wait elapses without being fulfilled.
                 Threads experiencing elapsed waits move closer to zero, so
                 eventually find existing (or future) threads even if the table
                 has been shrunk due to inactivity.  The chosen mechanics and
                 thresholds for growing and shrinking are intrinsically
                 entangled with indexing and hashing inside the exchange code,
                 and can&apos;t be nicely abstracted out.
                
                 Hashing: Each thread picks its initial slot to use in accord
                 with a simple hashcode.  The sequence is the same on each
                 encounter by any given thread, but effectively random across
                 threads.  Using arenas encounters the classic cost vs quality
                 tradeoffs of all hash tables.  Here, we use a one-step FNV-1a
                 hash code based on the current thread&apos;s Thread.getId(), along
                 with a cheap approximation to a mod operation to select an
                 index.  The downside of optimizing index selection in this way
                 is that the code is hardwired to use a maximum table size of
                 32.  But this value more than suffices for known platforms and
                 applications.
                
                 Probing: On sensed contention of a selected slot, we probe
                 sequentially through the table, analogously to linear probing
                 after collision in a hash table.  (We move circularly, in
                 reverse order, to mesh best with table growth and shrinkage
                 rules.)  Except that to minimize the effects of false-alarms
                 and cache thrashing, we try the first selected slot twice
                 before moving.
                
                 Padding: Even with contention management, slots are heavily
                 contended, so use cache-padding to avoid poor memory
                 performance.  Because of this, slots are lazily constructed
                 only when used, to avoid wasting this space unnecessarily.
                 While isolation of locations is not much of an issue at first
                 in an application, as time goes on and garbage-collectors
                 perform compaction, slots are very likely to be moved adjacent
                 to each other, which can cause much thrashing of cache lines on
                 MPs unless padding is employed.
                
                 This is an improvement of the algorithm described in the paper
                 &quot;A Scalable Elimination-based Exchange Channel&quot; by William
                 Scherer, Doug Lea, and Michael Scott in Proceedings of SCOOL05
                 workshop.  Available at: http:hdl.handle.net18022104                
            </comment>
            <comment line="451">
                Three forms of waiting. Each just different enough not to merge
                 code with others.                
            </comment>
            <javadoc line="41">
                A synchronization point at which threads can pair and swap elements
                  within pairs.  Each thread presents some object on entry to the{@link #exchange exchange} method, matches with a partner thread,
                  and receives its partner&apos;s object on return.  An Exchanger may be
                  viewed as a bidirectional form of a {@link SynchronousQueue}.
                  Exchangers may be useful in applications such as genetic algorithms
                  and pipeline designs.
                  &lt;p&gt;&lt;b&gt;Sample Usage:&lt;/b&gt;
                  Here are the highlights of a class that uses an {@code Exchanger}to swap buffers between threads so that the thread filling the
                  buffer gets a freshly emptied one when it needs it, handing off the
                  filled one to the thread emptying the buffer.
                  &lt;pre&gt;{@code}class FillAndEmpty 
                  Exchanger&lt;DataBuffer&gt; exchanger = new Exchanger&lt;DataBuffer&gt;();
                  DataBuffer initialEmptyBuffer = ... a made-up type
                  DataBuffer initialFullBuffer = ...
                  class FillingLoop implements Runnable {
                  public void run() {
                  DataBuffer currentBuffer = initialEmptyBuffer;
                  try {
                  while (currentBuffer != null) {
                  addToBuffer(currentBuffer);
                  if (currentBuffer.isFull())
                  currentBuffer = exchanger.exchange(currentBuffer);
                  }
                  } catch (InterruptedException ex) { ... handle ... }
                  }
                  }
                  class EmptyingLoop implements Runnable {
                  public void run() {
                  DataBuffer currentBuffer = initialFullBuffer;
                  try {
                  while (currentBuffer != null) {
                  takeFromBuffer(currentBuffer);
                  if (currentBuffer.isEmpty())
                  currentBuffer = exchanger.exchange(currentBuffer);
                  }
                  } catch (InterruptedException ex) { ... handle ...}
                  }
                  }
                  void start() {
                  new Thread(new FillingLoop()).start();
                  new Thread(new EmptyingLoop()).start();
                  }
                  }
                  }&lt;/pre&gt;
                  &lt;p&gt;Memory consistency effects: For each pair of threads that
                  successfully exchange objects via an {@code Exchanger}, actions
                  prior to the {@code exchange()} in each thread
                  &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                  those subsequent to a return from the corresponding {@code exchange()}in the other thread.                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea and Bill Scherer and Michael Scott                    
                </author>
                <param>
                    &lt;V&gt;
                       The type of objects that may be exchanged                    
                </param>
            </javadoc>
            <declaration name="NCPU" type="int" line="212"/>
            <javadoc line="212">
                The number of CPUs, for sizing and spin control                
            </javadoc>
            <declaration name="CAPACITY" type="int" line="215"/>
            <javadoc line="215">
                The capacity of the arena.  Set to a value that provides more
                  than enough space to handle contention.  On small machines
                  most slots won&apos;t be used, but it is still not wasted because
                  the extra space provides some machine-level address padding
                  to minimize interference with heavily CAS&apos;ed Slot locations.
                  And on very large machines, performance eventually becomes
                  bounded by memory bandwidth, not numbers of threads/CPUs.
                  This constant cannot be changed without also modifying
                  indexing and hashing algorithms.                
            </javadoc>
            <declaration name="FULL" type="int" line="228"/>
            <javadoc line="228">
                The value of &quot;max&quot; that will hold all threads without
                  contention.  When this value is less than CAPACITY, some
                  otherwise wasted expansion can be avoided.                
            </javadoc>
            <declaration name="SPINS" type="int" line="236"/>
            <javadoc line="236">
                The number of times to spin (doing nothing except polling a
                  memory location) before blocking or giving up while waiting to
                  be fulfilled.  Should be zero on uniprocessors.  On
                  multiprocessors, this value should be large enough so that two
                  threads exchanging items as fast as possible block only when
                  one of them is stalled (due to GC or preemption), but not much
                  longer, to avoid wasting CPU resources.  Seen differently, this
                  value is a little over half the number of cycles of an average
                  context switch time on most systems.  The value here is
                  approximately the average of those across a range of tested
                  systems.                
            </javadoc>
            <declaration name="TIMED_SPINS" type="int" line="251"/>
            <javadoc line="251">
                The number of times to spin before blocking in timed waits.
                  Timed waits spin more slowly because checking the time takes
                  time.  The best value relies mainly on the relative rate of
                  System.nanoTime vs memory accesses.  The value is empirically
                  derived to work well across a variety of systems.                
            </javadoc>
            <declaration name="CANCEL" type="Object" line="260"/>
            <javadoc line="260">
                Sentinel item representing cancellation of a wait due to
                  interruption, timeout, or elapsed spin-waits.  This value is
                  placed in holes on cancellation, and used as a return value
                  from waiting methods to indicate failure to set or get hole.                
            </javadoc>
            <declaration name="NULL_ITEM" type="Object" line="268"/>
            <javadoc line="268">
                Value representing null arguments/returns from public
                  methods.  This disambiguates from internal requirement that
                  holes start out as null to mean they are not yet set.                
            </javadoc>
            <class name="Node" line="275">
                <extends class="AtomicReference">
                    <type_params>
                        <type_param name="Object"/>
                    </type_params>
                </extends>
                <comment line="308">
                    Improve likelihood of isolation on &lt;= 64 byte cache lines                    
                </comment>
                <javadoc line="275">
                    Nodes hold partially exchanged data.  This class
                      opportunistically subclasses AtomicReference to represent the
                      hole.  So get() returns hole, and compareAndSet CAS&apos;es value
                      into hole.  This class cannot be parameterized as &quot;V&quot; because
                      of the use of non-V CANCEL sentinels.                    
                </javadoc>
                <declaration name="item" type="Object" line="283"/>
                <javadoc line="283">
                    The element offered by the Thread creating this node.                    
                </javadoc>
                <declaration name="waiter" type="Thread" line="286"/>
                <javadoc line="286">
                    The Thread waiting to be signalled; null until waiting.                    
                </javadoc>
                <javadoc line="289">
                    Creates node with given item and empty hole.                    
                    <param>
                        item the item                        
                    </param>
                </javadoc>
                <method name="Node" type="constructor" line="293">
                    <params>
                        <param name="item" type="Object"/>
                    </params>
                </method>
            </class>
            <class name="Slot" line="298">
                <extends class="AtomicReference">
                    <type_params>
                        <type_param name="Object"/>
                    </type_params>
                </extends>
                <comment line="308">
                    Improve likelihood of isolation on &lt;= 64 byte cache lines                    
                </comment>
                <javadoc line="298">
                    A Slot is an AtomicReference with heuristic padding to lessen
                      cache effects of this heavily CAS&apos;ed location.  While the
                      padding adds noticeable space, all slots are created only on
                      demand, and there will be more than one of them only when it
                      would improve throughput more than enough to outweigh using
                      extra space.                    
                </javadoc>
                <declaration name="q0" type="long" line="308"/>
            </class>
            <declaration name="arena" type="Slot[]" line="311"/>
            <javadoc line="311">
                Slot array.  Elements are lazily initialized when needed.
                  Declared volatile to enable double-checked lazy construction.                
            </javadoc>
            <declaration name="max" type="AtomicInteger" line="317"/>
            <javadoc line="317">
                The maximum slot index being used.  The value sometimes
                  increases when a thread experiences too many CAS contentions,
                  and sometimes decreases when a spin-wait elapses.  Changes
                  are performed only via compareAndSet, to avoid stale values
                  when a thread happens to stall right before setting.                
            </javadoc>
            <javadoc line="326">
                Main exchange function, handling the different policy variants.
                  Uses Object, not &quot;V&quot; as argument and return value to simplify
                  handling of sentinel values.  Callers from public methods decode
                  and cast accordingly.                
                <param>
                    item the (non-null) item to exchange                    
                </param>
                <param>
                    timed true if the wait is timed                    
                </param>
                <param>
                    nanos if timed, the maximum wait time                    
                </param>
                <return>
                    the other thread&apos;s item, or CANCEL if interrupted or timed out                    
                </return>
            </javadoc>
            <method name="doExchange" type="Object" line="337">
                <params>
                    <param name="item" type="Object"/>
                    <param name="timed" type="boolean"/>
                    <param name="nanos" type="long"/>
                </params>
                <comment line="339">
                    Create in case occupying                    
                </comment>
                <comment line="340">
                    Index of current slot                    
                </comment>
                <comment line="341">
                    Number of CAS failures                    
                </comment>
                <comment line="344">
                    Contents of current slot                    
                </comment>
                <comment line="346">
                    Lazily initialize slots                    
                </comment>
                <comment line="347">
                    Continue loop to reread                    
                </comment>
                <comment line="348">
                    Try to fulfill                    
                </comment>
                <comment line="350">
                    Transfer item                    
                </comment>
                <comment line="354">
                    Else cancelled; continue                    
                </comment>
                <comment line="356">
                    Try to occupy                    
                </comment>
                <comment line="358">
                    Blocking wait for slot 0                    
                </comment>
                <comment line="362">
                    Spin wait for non-0                    
                </comment>
                <comment line="365">
                    Throw away cancelled node                    
                </comment>
                <comment line="367">
                    Decrease index                    
                </comment>
                <comment line="368">
                    Maybe shrink table                    
                </comment>
                <comment line="370">
                    Allow 2 fails on 1st slot                    
                </comment>
                <comment line="373">
                    Grow on 3rd failed slot                    
                </comment>
                <comment line="375">
                    Circularly traverse                    
                </comment>
                <declaration name="me" type="Node" line="338"/>
                <declaration name="index" type="int" line="339"/>
                <declaration name="fails" type="int" line="340"/>
                <scope line="342">
                    <declaration name="y" type="Object" line="343"/>
                    <declaration name="slot" type="Slot" line="344"/>
                    <scope line="348">
                        <declaration name="you" type="Node" line="349"/>
                        <scope line="350"/>
                    </scope>
                    <scope line="356">
                        <declaration name="v" type="Object" line="361"/>
                        <declaration name="m" type="int" line="365"/>
                    </scope>
                    <scope line="369">
                        <declaration name="m" type="int" line="370"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="379">
                Returns a hash index for the current thread.  Uses a one-step
                  FNV-1a hash code (http://www.isthe.com/chongo/tech/comp/fnv/)
                  based on the current thread&apos;s Thread.getId().  These hash codes
                  have more uniform distribution properties with respect to small
                  moduli (here 1-31) than do other simple hashing functions.
                  &lt;p&gt;To return an index between 0 and max, we use a cheap
                  approximation to a mod operation, that also corrects for bias
                  due to non-power-of-2 remaindering (see {@link java.util.Random#nextInt}).  Bits of the hashcode are masked
                  with &quot;nbits&quot;, the ceiling power of two of table size (looked up
                  in a table packed into three ints).  If too large, this is
                  retried after rotating the hash by nbits bits, while forcing new
                  top bit to 0, which guarantees eventual termination (although
                  with a non-random-bias).  This requires an average of less than
                  2 tries for all table sizes, and has a maximum 2% difference
                  from perfectly uniform slot probabilities when applied to all
                  possible hash codes for sizes less than 32.                
                <return>
                    a per-thread-random index, 0 &lt;= index &lt; max                    
                </return>
            </javadoc>
            <method name="hashIndex" type="int" line="401">
                <comment line="407">
                    Compute ceil(log2(m+1))                    
                </comment>
                <comment line="408">
                    The constants hold                    
                </comment>
                <comment line="409">
                    a lookup table                    
                </comment>
                <comment line="411">
                    May retry on                    
                </comment>
                <comment line="412">
                    non-power-2 m                    
                </comment>
                <declaration name="id" type="long" line="402"/>
                <declaration name="hash" type="int" line="403"/>
                <declaration name="m" type="int" line="405"/>
                <declaration name="nbits" type="int" line="406"/>
                <declaration name="index" type="int" line="409"/>
            </method>
            <javadoc line="415">
                Creates a new slot at given index.  Called only when the slot
                  appears to be null.  Relies on double-check using builtin
                  locks, since they rarely contend.  This in turn relies on the
                  arena array being declared volatile.                
                <param>
                    index the index to add slot at                    
                </param>
            </javadoc>
            <method name="createSlot" type="void" line="423">
                <params>
                    <param name="index" type="int"/>
                </params>
                <comment line="425">
                    Create slot outside of lock to narrow sync region                    
                </comment>
                <declaration name="newSlot" type="Slot" line="425"/>
                <declaration name="a" type="Slot[]" line="426"/>
                <scope line="427"/>
            </method>
            <javadoc line="433">
                Tries to cancel a wait for the given node waiting in the given
                  slot, if so, helping clear the node from its slot to avoid
                  garbage retention.                
                <param>
                    node the waiting node                    
                </param>
                <param>
                    the slot it is waiting in                    
                </param>
                <return>
                    true if successfully cancelled                    
                </return>
            </javadoc>
            <method name="tryCancel" type="boolean" line="442">
                <params>
                    <param name="node" type="Node"/>
                    <param name="slot" type="Slot"/>
                </params>
                <comment line="446">
                    pre-check to minimize contention                    
                </comment>
            </method>
            <javadoc line="453">
                Spin-waits for hole for a non-0 slot.  Fails if spin elapses
                  before hole filled.  Does not check interrupt, relying on check
                  in public exchange method to abort if interrupted on entry.                
                <param>
                    node the waiting node                    
                </param>
                <return>
                    on success, the hole; on failure, CANCEL                    
                </return>
            </javadoc>
            <method name="spinWait" type="Object" line="461">
                <params>
                    <param name="node" type="Node"/>
                    <param name="slot" type="Slot"/>
                </params>
                <declaration name="spins" type="int" line="462"/>
                <scope line="463">
                    <declaration name="v" type="Object" line="464"/>
                </scope>
            </method>
            <javadoc line="474">
                Waits for (by spinning and/or blocking) and gets the hole
                  filled in by another thread.  Fails if interrupted before
                  hole filled.
                  When a node/thread is about to block, it sets its waiter field
                  and then rechecks state at least one more time before actually
                  parking, thus covering race vs fulfiller noticing that waiter
                  is non-null so should be woken.
                  Thread interruption status is checked only surrounding calls to
                  park.  The caller is assumed to have checked interrupt status
                  on entry.                
                <param>
                    node the waiting node                    
                </param>
                <return>
                    on success, the hole; on failure, CANCEL                    
                </return>
            </javadoc>
            <method name="await" type="Object" line="491">
                <params>
                    <param name="node" type="Node"/>
                    <param name="slot" type="Slot"/>
                </params>
                <comment line="499">
                    Spin-wait phase                    
                </comment>
                <comment line="501">
                    Set up to block next                    
                </comment>
                <comment line="503">
                    Abort on interrupt                    
                </comment>
                <comment line="505">
                    Block                    
                </comment>
                <declaration name="w" type="Thread" line="492"/>
                <declaration name="spins" type="int" line="493"/>
                <scope line="494">
                    <declaration name="v" type="Object" line="495"/>
                </scope>
            </method>
            <javadoc line="509">
                Waits for (at index 0) and gets the hole filled in by another
                  thread.  Fails if timed out or interrupted before hole filled.
                  Same basic logic as untimed version, but a bit messier.                
                <param>
                    node the waiting node                    
                </param>
                <param>
                    nanos the wait time                    
                </param>
                <return>
                    on success, the hole; on failure, CANCEL                    
                </return>
            </javadoc>
            <method name="awaitNanos" type="Object" line="518">
                <params>
                    <param name="node" type="Node"/>
                    <param name="slot" type="Slot"/>
                    <param name="nanos" type="long"/>
                </params>
                <declaration name="spins" type="int" line="519"/>
                <declaration name="lastTime" type="long" line="520"/>
                <declaration name="w" type="Thread" line="521"/>
                <scope line="522">
                    <declaration name="v" type="Object" line="523"/>
                    <declaration name="now" type="long" line="526"/>
                    <scope line="532"/>
                </scope>
            </method>
            <javadoc line="547">
                Sweeps through arena checking for any waiting threads.  Called
                  only upon return from timeout while waiting in slot 0.  When a
                  thread gives up on a timed wait, it is possible that a
                  previously-entered thread is still waiting in some other
                  slot.  So we scan to check for any.  This is almost always
                  overkill, but decreases the likelihood of timeouts when there
                  are other threads present to far less than that in lock-based
                  exchangers in which earlier-arriving threads may still be
                  waiting on entry locks.                
                <param>
                    node the waiting node                    
                </param>
                <return>
                    another thread&apos;s item, or CANCEL                    
                </return>
            </javadoc>
            <method name="scanOnTimeout" type="Object" line="561">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="y" type="Object" line="562"/>
                <scope line="563">
                    <declaration name="slot" type="Slot" line="564"/>
                    <scope line="565">
                        <scope line="566">
                            <scope line="567">
                                <declaration name="you" type="Node" line="568"/>
                                <scope line="569"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="580">
                Creates a new Exchanger.                
            </javadoc>
            <method name="Exchanger" type="constructor" line="583"/>
            <javadoc line="586">
                Waits for another thread to arrive at this exchange point (unless
                  the current thread is {@linkplain Thread#interrupt interrupted}),
                  and then transfers the given object to it, receiving its object
                  in return.
                  &lt;p&gt;If another thread is already waiting at the exchange point then
                  it is resumed for thread scheduling purposes and receives the object
                  passed in by the current thread.  The current thread returns immediately,
                  receiving the object passed to the exchange by that other thread.
                  &lt;p&gt;If no other thread is already waiting at the exchange then the
                  current thread is disabled for thread scheduling purposes and lies
                  dormant until one of two things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread enters the exchange; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread.
                  &lt;/ul&gt;
                  &lt;p&gt;If the current thread:
                  &lt;ul&gt;
                  &lt;li&gt;has its interrupted status set on entry to this method; or
                  &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
                  for the exchange,
                  &lt;/ul&gt;
                  then {@link InterruptedException} is thrown and the current thread&apos;s
                  interrupted status is cleared.                
                <param>
                    x the object to exchange                    
                </param>
                <return>
                    the object provided by the other thread                    
                </return>
                <throws>
                    InterruptedException if the current thread was
                      interrupted while waiting                    
                </throws>
            </javadoc>
            <method name="exchange" type="V" line="619">
                <params>
                    <param name="x" type="V"/>
                </params>
                <comment line="627">
                    Clear interrupt status on IE throw                    
                </comment>
                <scope line="620">
                    <declaration name="v" type="Object" line="621"/>
                </scope>
            </method>
            <javadoc line="631">
                Waits for another thread to arrive at this exchange point (unless
                  the current thread is {@linkplain Thread#interrupt interrupted} or
                  the specified waiting time elapses), and then transfers the given
                  object to it, receiving its object in return.
                  &lt;p&gt;If another thread is already waiting at the exchange point then
                  it is resumed for thread scheduling purposes and receives the object
                  passed in by the current thread.  The current thread returns immediately,
                  receiving the object passed to the exchange by that other thread.
                  &lt;p&gt;If no other thread is already waiting at the exchange then the
                  current thread is disabled for thread scheduling purposes and lies
                  dormant until one of three things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread enters the exchange; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread; or
                  &lt;li&gt;The specified waiting time elapses.
                  &lt;/ul&gt;
                  &lt;p&gt;If the current thread:
                  &lt;ul&gt;
                  &lt;li&gt;has its interrupted status set on entry to this method; or
                  &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
                  for the exchange,
                  &lt;/ul&gt;
                  then {@link InterruptedException} is thrown and the current thread&apos;s
                  interrupted status is cleared.
                  &lt;p&gt;If the specified waiting time elapses then {@link TimeoutException} is thrown.  If the time is less than or equal
                  to zero, the method will not wait at all.                
                <param>
                    x the object to exchange                    
                </param>
                <param>
                    timeout the maximum time to wait                    
                </param>
                <param>
                    unit the time unit of the &lt;tt&gt;timeout&lt;/tt&gt; argument                    
                </param>
                <return>
                    the object provided by the other thread                    
                </return>
                <throws>
                    InterruptedException if the current thread was
                      interrupted while waiting                    
                </throws>
                <throws>
                    TimeoutException if the specified waiting time elapses
                      before another thread enters the exchange                    
                </throws>
            </javadoc>
            <method name="exchange" type="V" line="674">
                <params>
                    <param name="x" type="V"/>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <scope line="675">
                    <declaration name="v" type="Object" line="676"/>
                </scope>
            </method>
        </class>
    </source>