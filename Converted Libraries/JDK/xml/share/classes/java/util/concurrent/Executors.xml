<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util"/>
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.AccessControlException"/>
        <import package="sun.security.util.SecurityConstants"/>
        <class name="Executors" line="47">
            <comment line="459">
                Non-public classes supporting the public methods                
            </comment>
            <javadoc line="47">
                Factory and utility methods for {@link Executor}, {@link ExecutorService}, {@link ScheduledExecutorService}, {@link ThreadFactory}, and {@link Callable} classes defined in this
                  package. This class supports the following kinds of methods:
                  &lt;ul&gt;
                  &lt;li&gt; Methods that create and return an {@link ExecutorService}set up with commonly useful configuration settings.
                  &lt;li&gt; Methods that create and return a {@link ScheduledExecutorService}set up with commonly useful configuration settings.
                  &lt;li&gt; Methods that create and return a &quot;wrapped&quot; ExecutorService, that
                  disables reconfiguration by making implementation-specific methods
                  inaccessible.
                  &lt;li&gt; Methods that create and return a {@link ThreadFactory}that sets newly created threads to a known state.
                  &lt;li&gt; Methods that create and return a {@link Callable}out of other closure-like forms, so they can be used
                  in execution methods requiring &lt;tt&gt;Callable&lt;/tt&gt;.
                  &lt;/ul&gt;                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <javadoc line="73">
                Creates a thread pool that reuses a fixed number of threads
                  operating off a shared unbounded queue.  At any point, at most
                  &lt;tt&gt;nThreads&lt;/tt&gt; threads will be active processing tasks.
                  If additional tasks are submitted when all threads are active,
                  they will wait in the queue until a thread is available.
                  If any thread terminates due to a failure during execution
                  prior to shutdown, a new one will take its place if needed to
                  execute subsequent tasks.  The threads in the pool will exist
                  until it is explicitly {@link ExecutorService#shutdown shutdown}.                
                <param>
                    nThreads the number of threads in the pool                    
                </param>
                <return>
                    the newly created thread pool                    
                </return>
                <throws>
                    IllegalArgumentException if {@code nThreads &lt;= 0}                    
                </throws>
            </javadoc>
            <method name="newFixedThreadPool" type="ExecutorService" line="88">
                <params>
                    <param name="nThreads" type="int"/>
                </params>
            </method>
            <javadoc line="94">
                Creates a thread pool that reuses a fixed number of threads
                  operating off a shared unbounded queue, using the provided
                  ThreadFactory to create new threads when needed.  At any point,
                  at most &lt;tt&gt;nThreads&lt;/tt&gt; threads will be active processing
                  tasks.  If additional tasks are submitted when all threads are
                  active, they will wait in the queue until a thread is
                  available.  If any thread terminates due to a failure during
                  execution prior to shutdown, a new one will take its place if
                  needed to execute subsequent tasks.  The threads in the pool will
                  exist until it is explicitly {@link ExecutorService#shutdownshutdown}.                
                <param>
                    nThreads the number of threads in the pool                    
                </param>
                <param>
                    threadFactory the factory to use when creating new threads                    
                </param>
                <return>
                    the newly created thread pool                    
                </return>
                <throws>
                    NullPointerException if threadFactory is null                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code nThreads &lt;= 0}                    
                </throws>
            </javadoc>
            <method name="newFixedThreadPool" type="ExecutorService" line="113">
                <params>
                    <param name="nThreads" type="int"/>
                    <param name="threadFactory" type="ThreadFactory"/>
                </params>
            </method>
            <javadoc line="120">
                Creates an Executor that uses a single worker thread operating
                  off an unbounded queue. (Note however that if this single
                  thread terminates due to a failure during execution prior to
                  shutdown, a new one will take its place if needed to execute
                  subsequent tasks.)  Tasks are guaranteed to execute
                  sequentially, and no more than one task will be active at any
                  given time. Unlike the otherwise equivalent
                  &lt;tt&gt;newFixedThreadPool(1)&lt;/tt&gt; the returned executor is
                  guaranteed not to be reconfigurable to use additional threads.                
                <return>
                    the newly created single-threaded Executor                    
                </return>
            </javadoc>
            <method name="newSingleThreadExecutor" type="ExecutorService" line="133"/>
            <javadoc line="140">
                Creates an Executor that uses a single worker thread operating
                  off an unbounded queue, and uses the provided ThreadFactory to
                  create a new thread when needed. Unlike the otherwise
                  equivalent &lt;tt&gt;newFixedThreadPool(1, threadFactory)&lt;/tt&gt; the
                  returned executor is guaranteed not to be reconfigurable to use
                  additional threads.                
                <param>
                    threadFactory the factory to use when creating new
                      threads                    
                </param>
                <return>
                    the newly created single-threaded Executor                    
                </return>
                <throws>
                    NullPointerException if threadFactory is null                    
                </throws>
            </javadoc>
            <method name="newSingleThreadExecutor" type="ExecutorService" line="154">
                <params>
                    <param name="threadFactory" type="ThreadFactory"/>
                </params>
            </method>
            <javadoc line="162">
                Creates a thread pool that creates new threads as needed, but
                  will reuse previously constructed threads when they are
                  available.  These pools will typically improve the performance
                  of programs that execute many short-lived asynchronous tasks.
                  Calls to &lt;tt&gt;execute&lt;/tt&gt; will reuse previously constructed
                  threads if available. If no existing thread is available, a new
                  thread will be created and added to the pool. Threads that have
                  not been used for sixty seconds are terminated and removed from
                  the cache. Thus, a pool that remains idle for long enough will
                  not consume any resources. Note that pools with similar
                  properties but different details (for example, timeout parameters)
                  may be created using {@link ThreadPoolExecutor} constructors.                
                <return>
                    the newly created thread pool                    
                </return>
            </javadoc>
            <method name="newCachedThreadPool" type="ExecutorService" line="178"/>
            <javadoc line="184">
                Creates a thread pool that creates new threads as needed, but
                  will reuse previously constructed threads when they are
                  available, and uses the provided
                  ThreadFactory to create new threads when needed.                
                <param>
                    threadFactory the factory to use when creating new threads                    
                </param>
                <return>
                    the newly created thread pool                    
                </return>
                <throws>
                    NullPointerException if threadFactory is null                    
                </throws>
            </javadoc>
            <method name="newCachedThreadPool" type="ExecutorService" line="193">
                <params>
                    <param name="threadFactory" type="ThreadFactory"/>
                </params>
            </method>
            <javadoc line="200">
                Creates a single-threaded executor that can schedule commands
                  to run after a given delay, or to execute periodically.
                  (Note however that if this single
                  thread terminates due to a failure during execution prior to
                  shutdown, a new one will take its place if needed to execute
                  subsequent tasks.)  Tasks are guaranteed to execute
                  sequentially, and no more than one task will be active at any
                  given time. Unlike the otherwise equivalent
                  &lt;tt&gt;newScheduledThreadPool(1)&lt;/tt&gt; the returned executor is
                  guaranteed not to be reconfigurable to use additional threads.                
                <return>
                    the newly created scheduled executor                    
                </return>
            </javadoc>
            <method name="newSingleThreadScheduledExecutor" type="ScheduledExecutorService" line="213"/>
            <javadoc line="218">
                Creates a single-threaded executor that can schedule commands
                  to run after a given delay, or to execute periodically.  (Note
                  however that if this single thread terminates due to a failure
                  during execution prior to shutdown, a new one will take its
                  place if needed to execute subsequent tasks.)  Tasks are
                  guaranteed to execute sequentially, and no more than one task
                  will be active at any given time. Unlike the otherwise
                  equivalent &lt;tt&gt;newScheduledThreadPool(1, threadFactory)&lt;/tt&gt;
                  the returned executor is guaranteed not to be reconfigurable to
                  use additional threads.                
                <param>
                    threadFactory the factory to use when creating new
                      threads                    
                </param>
                <return>
                    a newly created scheduled executor                    
                </return>
                <throws>
                    NullPointerException if threadFactory is null                    
                </throws>
            </javadoc>
            <method name="newSingleThreadScheduledExecutor" type="ScheduledExecutorService" line="234">
                <params>
                    <param name="threadFactory" type="ThreadFactory"/>
                </params>
            </method>
            <javadoc line="239">
                Creates a thread pool that can schedule commands to run after a
                  given delay, or to execute periodically.                
                <param>
                    corePoolSize the number of threads to keep in the pool,
                      even if they are idle.                    
                </param>
                <return>
                    a newly created scheduled thread pool                    
                </return>
                <throws>
                    IllegalArgumentException if {@code corePoolSize &lt; 0}                    
                </throws>
            </javadoc>
            <method name="newScheduledThreadPool" type="ScheduledExecutorService" line="247">
                <params>
                    <param name="corePoolSize" type="int"/>
                </params>
            </method>
            <javadoc line="251">
                Creates a thread pool that can schedule commands to run after a
                  given delay, or to execute periodically.                
                <param>
                    corePoolSize the number of threads to keep in the pool,
                      even if they are idle.                    
                </param>
                <param>
                    threadFactory the factory to use when the executor
                      creates a new thread.                    
                </param>
                <return>
                    a newly created scheduled thread pool                    
                </return>
                <throws>
                    IllegalArgumentException if {@code corePoolSize &lt; 0}                    
                </throws>
                <throws>
                    NullPointerException if threadFactory is null                    
                </throws>
            </javadoc>
            <method name="newScheduledThreadPool" type="ScheduledExecutorService" line="263">
                <params>
                    <param name="corePoolSize" type="int"/>
                    <param name="threadFactory" type="ThreadFactory"/>
                </params>
            </method>
            <javadoc line="268">
                Returns an object that delegates all defined {@link ExecutorService} methods to the given executor, but not any
                  other methods that might otherwise be accessible using
                  casts. This provides a way to safely &quot;freeze&quot; configuration and
                  disallow tuning of a given concrete implementation.                
                <param>
                    executor the underlying implementation                    
                </param>
                <return>
                    an &lt;tt&gt;ExecutorService&lt;/tt&gt; instance                    
                </return>
                <throws>
                    NullPointerException if executor null                    
                </throws>
            </javadoc>
            <method name="unconfigurableExecutorService" type="ExecutorService" line="278">
                <params>
                    <param name="executor" type="ExecutorService"/>
                </params>
            </method>
            <javadoc line="284">
                Returns an object that delegates all defined {@link ScheduledExecutorService} methods to the given executor, but
                  not any other methods that might otherwise be accessible using
                  casts. This provides a way to safely &quot;freeze&quot; configuration and
                  disallow tuning of a given concrete implementation.                
                <param>
                    executor the underlying implementation                    
                </param>
                <return>
                    a &lt;tt&gt;ScheduledExecutorService&lt;/tt&gt; instance                    
                </return>
                <throws>
                    NullPointerException if executor null                    
                </throws>
            </javadoc>
            <method name="unconfigurableScheduledExecutorService" type="ScheduledExecutorService" line="294">
                <params>
                    <param name="executor" type="ScheduledExecutorService"/>
                </params>
            </method>
            <javadoc line="300">
                Returns a default thread factory used to create new threads.
                  This factory creates all new threads used by an Executor in the
                  same {@link ThreadGroup}. If there is a {@link java.lang.SecurityManager}, it uses the group of {@link System#getSecurityManager}, else the group of the thread
                  invoking this &lt;tt&gt;defaultThreadFactory&lt;/tt&gt; method. Each new
                  thread is created as a non-daemon thread with priority set to
                  the smaller of &lt;tt&gt;Thread.NORM_PRIORITY&lt;/tt&gt; and the maximum
                  priority permitted in the thread group.  New threads have names
                  accessible via {@link Thread#getName} of
                  &lt;em&gt;pool-N-thread-M&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is the sequence
                  number of this factory, and &lt;em&gt;M&lt;/em&gt; is the sequence number
                  of the thread created by this factory.                
                <return>
                    a thread factory                    
                </return>
            </javadoc>
            <method name="defaultThreadFactory" type="ThreadFactory" line="316"/>
            <javadoc line="320">
                Returns a thread factory used to create new threads that
                  have the same permissions as the current thread.
                  This factory creates threads with the same settings as {@link Executors#defaultThreadFactory}, additionally setting the
                  AccessControlContext and contextClassLoader of new threads to
                  be the same as the thread invoking this
                  &lt;tt&gt;privilegedThreadFactory&lt;/tt&gt; method.  A new
                  &lt;tt&gt;privilegedThreadFactory&lt;/tt&gt; can be created within an{@link AccessController#doPrivileged} action setting the
                  current thread&apos;s access control context to create threads with
                  the selected permission settings holding within that action.
                  &lt;p&gt; Note that while tasks running within such threads will have
                  the same access control and class loader settings as the
                  current thread, they need not have the same {@link java.lang.ThreadLocal} or {@link java.lang.InheritableThreadLocal} values. If necessary,
                  particular values of thread locals can be set or reset before
                  any task runs in {@link ThreadPoolExecutor} subclasses using{@link ThreadPoolExecutor#beforeExecute}. Also, if it is
                  necessary to initialize worker threads to have the same
                  InheritableThreadLocal settings as some other designated
                  thread, you can create a custom ThreadFactory in which that
                  thread waits for and services requests to create others that
                  will inherit its values.                
                <return>
                    a thread factory                    
                </return>
                <throws>
                    AccessControlException if the current access control
                      context does not have permission to both get and set context
                      class loader.                    
                </throws>
            </javadoc>
            <method name="privilegedThreadFactory" type="ThreadFactory" line="352"/>
            <javadoc line="356">
                Returns a {@link Callable} object that, when
                  called, runs the given task and returns the given result.  This
                  can be useful when applying methods requiring a
                  &lt;tt&gt;Callable&lt;/tt&gt; to an otherwise resultless action.                
                <param>
                    task the task to run                    
                </param>
                <param>
                    result the result to return                    
                </param>
                <return>
                    a callable object                    
                </return>
                <throws>
                    NullPointerException if task null                    
                </throws>
            </javadoc>
            <method name="callable" type="Callable<T>" line="366">
                <params>
                    <param name="task" type="Runnable"/>
                    <param name="result" type="T"/>
                </params>
            </method>
            <javadoc line="372">
                Returns a {@link Callable} object that, when
                  called, runs the given task and returns &lt;tt&gt;null&lt;/tt&gt;.                
                <param>
                    task the task to run                    
                </param>
                <return>
                    a callable object                    
                </return>
                <throws>
                    NullPointerException if task null                    
                </throws>
            </javadoc>
            <method name="callable" type="Callable<Object>" line="379">
                <params>
                    <param name="task" type="Runnable"/>
                </params>
            </method>
            <javadoc line="385">
                Returns a {@link Callable} object that, when
                  called, runs the given privileged action and returns its result.                
                <param>
                    action the privileged action to run                    
                </param>
                <return>
                    a callable object                    
                </return>
                <throws>
                    NullPointerException if action null                    
                </throws>
            </javadoc>
            <method name="callable" type="Callable<Object>" line="392">
                <params>
                    <param name="action" type="PrivilegedAction<?>"/>
                </params>
                <anonymous_class line="395">
                    <method name="call" type="Object" line="396"/>
                </anonymous_class>
            </method>
            <javadoc line="399">
                Returns a {@link Callable} object that, when
                  called, runs the given privileged exception action and returns
                  its result.                
                <param>
                    action the privileged exception action to run                    
                </param>
                <return>
                    a callable object                    
                </return>
                <throws>
                    NullPointerException if action null                    
                </throws>
            </javadoc>
            <method name="callable" type="Callable<Object>" line="407">
                <params>
                    <param name="action" type="PrivilegedExceptionAction<?>"/>
                </params>
                <anonymous_class line="410">
                    <method name="call" type="Object" line="411"/>
                </anonymous_class>
            </method>
            <javadoc line="414">
                Returns a {@link Callable} object that will, when
                  called, execute the given &lt;tt&gt;callable&lt;/tt&gt; under the current
                  access control context. This method should normally be
                  invoked within an {@link AccessController#doPrivileged} action
                  to create callables that will, if possible, execute under the
                  selected permission settings holding within that action; or if
                  not possible, throw an associated {@link AccessControlException}.                
                <param>
                    callable the underlying task                    
                </param>
                <return>
                    a callable object                    
                </return>
                <throws>
                    NullPointerException if callable null                    
                </throws>
            </javadoc>
            <method name="privilegedCallable" type="Callable<T>" line="428">
                <params>
                    <param name="callable" type="Callable<T>"/>
                </params>
            </method>
            <javadoc line="434">
                Returns a {@link Callable} object that will, when
                  called, execute the given &lt;tt&gt;callable&lt;/tt&gt; under the current
                  access control context, with the current context class loader
                  as the context class loader. This method should normally be
                  invoked within an {@link AccessController#doPrivileged} action
                  to create callables that will, if possible, execute under the
                  selected permission settings holding within that action; or if
                  not possible, throw an associated {@link AccessControlException}.                
                <param>
                    callable the underlying task                    
                </param>
                <return>
                    a callable object                    
                </return>
                <throws>
                    NullPointerException if callable null                    
                </throws>
                <throws>
                    AccessControlException if the current access control
                      context does not have permission to both set and get context
                      class loader.                    
                </throws>
            </javadoc>
            <method name="privilegedCallableUsingCurrentClassLoader" type="Callable<T>" line="452">
                <params>
                    <param name="callable" type="Callable<T>"/>
                </params>
            </method>
            <class name="RunnableAdapter" line="460">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <implements interface="Callable">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <javadoc line="460">
                    A callable that runs given task and returns given result                    
                </javadoc>
                <declaration name="task" type="Runnable" line="464"/>
                <declaration name="result" type="T" line="465"/>
                <method name="RunnableAdapter" type="constructor" line="466">
                    <params>
                        <param name="task" type="Runnable"/>
                        <param name="result" type="T"/>
                    </params>
                </method>
                <method name="call" type="T" line="470"/>
            </class>
            <class name="PrivilegedCallable" line="476">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <implements interface="Callable">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <javadoc line="476">
                    A callable that runs under established access control settings                    
                </javadoc>
                <declaration name="task" type="Callable&lt;T&gt;" line="480"/>
                <declaration name="acc" type="AccessControlContext" line="481"/>
                <method name="PrivilegedCallable" type="constructor" line="483">
                    <params>
                        <param name="task" type="Callable<T>"/>
                    </params>
                </method>
                <method name="call" type="T" line="488">
                    <scope line="489">
                        <anonymous_class line="491">
                            <method name="run" type="T" line="492"/>
                        </anonymous_class>
                    </scope>
                    <scope line="496"/>
                </method>
            </class>
            <class name="PrivilegedCallableUsingCurrentClassLoader" line="502">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <implements interface="Callable">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <javadoc line="502">
                    A callable that runs under established access control settings and
                      current ClassLoader                    
                </javadoc>
                <declaration name="task" type="Callable&lt;T&gt;" line="507"/>
                <declaration name="acc" type="AccessControlContext" line="508"/>
                <declaration name="ccl" type="ClassLoader" line="509"/>
                <method name="PrivilegedCallableUsingCurrentClassLoader" type="constructor" line="511">
                    <params>
                        <param name="task" type="Callable<T>"/>
                    </params>
                    <comment line="515">
                        Calls to getContextClassLoader from this class
                         never trigger a security check, but we check
                         whether our callers have this permission anyways.                        
                    </comment>
                    <comment line="520">
                        Whether setContextClassLoader turns out to be necessary
                         or not, we fail fast if permission is not available.                        
                    </comment>
                    <declaration name="sm" type="SecurityManager" line="512"/>
                    <scope line="513"/>
                </method>
                <method name="call" type="T" line="528">
                    <scope line="529">
                        <anonymous_class line="531">
                            <method name="run" type="T" line="532">
                                <declaration name="savedcl" type="ClassLoader" line="533"/>
                                <declaration name="t" type="Thread" line="534"/>
                                <scope line="535">
                                    <declaration name="cl" type="ClassLoader" line="536"/>
                                    <scope line="537"/>
                                </scope>
                                <scope line="542"/>
                            </method>
                        </anonymous_class>
                    </scope>
                    <scope line="548"/>
                </method>
            </class>
            <class name="DefaultThreadFactory" line="554">
                <implements interface="ThreadFactory"/>
                <javadoc line="554">
                    The default thread factory                    
                </javadoc>
                <declaration name="poolNumber" type="AtomicInteger" line="558"/>
                <declaration name="group" type="ThreadGroup" line="559"/>
                <declaration name="threadNumber" type="AtomicInteger" line="560"/>
                <declaration name="namePrefix" type="String" line="561"/>
                <method name="DefaultThreadFactory" type="constructor" line="563">
                    <declaration name="s" type="SecurityManager" line="564"/>
                </method>
                <method name="newThread" type="Thread" line="572">
                    <params>
                        <param name="r" type="Runnable"/>
                    </params>
                    <declaration name="t" type="Thread" line="573"/>
                </method>
            </class>
            <class name="PrivilegedThreadFactory" line="584">
                <extends class="DefaultThreadFactory"/>
                <javadoc line="584">
                    Thread factory capturing access control context and class loader                    
                </javadoc>
                <declaration name="acc" type="AccessControlContext" line="588"/>
                <declaration name="ccl" type="ClassLoader" line="589"/>
                <method name="PrivilegedThreadFactory" type="constructor" line="591">
                    <comment line="596">
                        Calls to getContextClassLoader from this class
                         never trigger a security check, but we check
                         whether our callers have this permission anyways.                        
                    </comment>
                    <comment line="601">
                        Fail fast                        
                    </comment>
                    <declaration name="sm" type="SecurityManager" line="593"/>
                    <scope line="594"/>
                </method>
                <method name="newThread" type="Thread" line="607">
                    <params>
                        <param name="r" type="Runnable"/>
                    </params>
                    <anonymous_class line="608">
                        <method name="run" type="void" line="609">
                            <anonymous_class line="610">
                                <method name="run" type="Void" line="611"/>
                            </anonymous_class>
                        </method>
                    </anonymous_class>
                </method>
            </class>
            <class name="DelegatedExecutorService" line="622">
                <extends class="AbstractExecutorService"/>
                <javadoc line="622">
                    A wrapper class that exposes only the ExecutorService methods
                      of an ExecutorService implementation.                    
                </javadoc>
                <declaration name="e" type="ExecutorService" line="627"/>
                <method name="DelegatedExecutorService" type="constructor" line="628">
                    <params>
                        <param name="executor" type="ExecutorService"/>
                    </params>
                </method>
                <method name="execute" type="void" line="629">
                    <params>
                        <param name="command" type="Runnable"/>
                    </params>
                </method>
                <method name="shutdown" type="void" line="630"/>
                <method name="shutdownNow" type="List<Runnable>" line="631"/>
                <method name="isShutdown" type="boolean" line="632"/>
                <method name="isTerminated" type="boolean" line="633"/>
                <method name="awaitTermination" type="boolean" line="635">
                    <params>
                        <param name="timeout" type="long"/>
                        <param name="unit" type="TimeUnit"/>
                    </params>
                </method>
                <method name="submit" type="Future<?>" line="638">
                    <params>
                        <param name="task" type="Runnable"/>
                    </params>
                </method>
                <method name="submit" type="Future<T>" line="641">
                    <params>
                        <param name="task" type="Callable<T>"/>
                    </params>
                </method>
                <method name="submit" type="Future<T>" line="644">
                    <params>
                        <param name="task" type="Runnable"/>
                        <param name="result" type="T"/>
                    </params>
                </method>
                <method name="invokeAll" type="List<Future<T>>" line="648">
                    <params>
                        <param name="tasks" type="Collection<? extends Callable<T>>"/>
                    </params>
                </method>
                <method name="invokeAll" type="List<Future<T>>" line="653">
                    <params>
                        <param name="tasks" type="Collection<? extends Callable<T>>"/>
                        <param name="timeout" type="long"/>
                        <param name="unit" type="TimeUnit"/>
                    </params>
                </method>
                <method name="invokeAny" type="T" line="657">
                    <params>
                        <param name="tasks" type="Collection<? extends Callable<T>>"/>
                    </params>
                </method>
                <method name="invokeAny" type="T" line="662">
                    <params>
                        <param name="tasks" type="Collection<? extends Callable<T>>"/>
                        <param name="timeout" type="long"/>
                        <param name="unit" type="TimeUnit"/>
                    </params>
                </method>
            </class>
            <class name="FinalizableDelegatedExecutorService" line="667">
                <extends class="DelegatedExecutorService"/>
                <method name="FinalizableDelegatedExecutorService" type="constructor" line="669">
                    <params>
                        <param name="executor" type="ExecutorService"/>
                    </params>
                </method>
                <method name="finalize" type="void" line="672"/>
            </class>
            <class name="DelegatedScheduledExecutorService" line="677">
                <extends class="DelegatedExecutorService"/>
                <implements interface="ScheduledExecutorService"/>
                <javadoc line="677">
                    A wrapper class that exposes only the ScheduledExecutorService
                      methods of a ScheduledExecutorService implementation.                    
                </javadoc>
                <declaration name="e" type="ScheduledExecutorService" line="684"/>
                <method name="DelegatedScheduledExecutorService" type="constructor" line="685">
                    <params>
                        <param name="executor" type="ScheduledExecutorService"/>
                    </params>
                </method>
                <method name="schedule" type="ScheduledFuture<?>" line="689">
                    <params>
                        <param name="command" type="Runnable"/>
                        <param name="delay" type="long"/>
                        <param name="unit" type="TimeUnit"/>
                    </params>
                </method>
                <method name="schedule" type="ScheduledFuture<V>" line="692">
                    <params>
                        <param name="callable" type="Callable<V>"/>
                        <param name="delay" type="long"/>
                        <param name="unit" type="TimeUnit"/>
                    </params>
                </method>
                <method name="scheduleAtFixedRate" type="ScheduledFuture<?>" line="695">
                    <params>
                        <param name="command" type="Runnable"/>
                        <param name="initialDelay" type="long"/>
                        <param name="period" type="long"/>
                        <param name="unit" type="TimeUnit"/>
                    </params>
                </method>
                <method name="scheduleWithFixedDelay" type="ScheduledFuture<?>" line="698">
                    <params>
                        <param name="command" type="Runnable"/>
                        <param name="initialDelay" type="long"/>
                        <param name="delay" type="long"/>
                        <param name="unit" type="TimeUnit"/>
                    </params>
                </method>
            </class>
            <javadoc line="704">
                Cannot instantiate.                
            </javadoc>
            <method name="Executors" type="constructor" line="705"/>
        </class>
    </source>