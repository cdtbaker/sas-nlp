<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.io.Serializable"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Collections"/>
        <import package="java.util.List"/>
        <import package="java.util.RandomAccess"/>
        <import package="java.util.Map"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.ref.ReferenceQueue"/>
        <import package="java.util.concurrent.Callable"/>
        <import package="java.util.concurrent.CancellationException"/>
        <import package="java.util.concurrent.ExecutionException"/>
        <import package="java.util.concurrent.Executor"/>
        <import package="java.util.concurrent.ExecutorService"/>
        <import package="java.util.concurrent.Future"/>
        <import package="java.util.concurrent.RejectedExecutionException"/>
        <import package="java.util.concurrent.RunnableFuture"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.TimeoutException"/>
        <import package="java.util.concurrent.locks.ReentrantLock"/>
        <import package="java.lang.reflect.Constructor"/>
        <class name="ForkJoinTask" line="59">
            <type_params>
                <type_param name="V"/>
            </type_params>
            <comment line="194">
                See the internal documentation of class ForkJoinPool for a
                 general implementation overview.  ForkJoinTasks are mainly
                 responsible for maintaining their &quot;status&quot; field amidst relays
                 to methods in ForkJoinWorkerThread and ForkJoinPool. The
                 methods of this class are more-or-less layered into (1) basic
                 status maintenance (2) execution and awaiting completion (3)
                 user-level methods that additionally report results. This is
                 sometimes hard to see because this file orders exported methods
                 in a way that flows well in javadocs.                
            </comment>
            <comment line="206">
                The status field holds run control status bits packed into a
                 single int to minimize footprint and to ensure atomicity (via
                 CAS).  Status is initially zero, and takes on nonnegative
                 values until completed, upon which status holds value
                 NORMAL, CANCELLED, or EXCEPTIONAL. Tasks undergoing blocking
                 waits by other threads have the SIGNAL bit set.  Completion of
                 a stolen task with SIGNAL set awakens any waiters via
                 notifyAll. Even though suboptimal for some purposes, we use
                 basic builtin waitnotify to take advantage of &quot;monitor
                 inflation&quot; in JVMs that we would otherwise need to emulate to
                 avoid adding further per-task bookkeeping overhead.  We want
                 these monitors to be &quot;fat&quot;, i.e., not use biasing or thin-lock
                 techniques, so use some odd coding idioms that tend to avoid
                 them.                
            </comment>
            <comment line="224">
                accessed directly by pool and workers                
            </comment>
            <comment line="388">
                Exception table support                
            </comment>
            <comment line="602">
                public methods                
            </comment>
            <comment line="1148">
                Extension methods                
            </comment>
            <comment line="1341">
                Serialization support                
            </comment>
            <comment line="1371">
                Unsafe mechanics                
            </comment>
            <implements interface="Future">
                <type_params>
                    <type_param name="V"/>
                </type_params>
            </implements>
            <implements interface="Serializable"/>
            <javadoc line="59">
                Abstract base class for tasks that run within a {@link ForkJoinPool}.
                  A {@code ForkJoinTask} is a thread-like entity that is much
                  lighter weight than a normal thread.  Huge numbers of tasks and
                  subtasks may be hosted by a small number of actual threads in a
                  ForkJoinPool, at the price of some usage limitations.
                  &lt;p&gt;A &quot;main&quot; {@code ForkJoinTask} begins execution when submitted
                  to a {@link ForkJoinPool}.  Once started, it will usually in turn
                  start other subtasks.  As indicated by the name of this class,
                  many programs using {@code ForkJoinTask} employ only methods{@link #fork} and {@link #join}, or derivatives such as {@link #invokeAll(ForkJoinTask...) invokeAll}.  However, this class also
                  provides a number of other methods that can come into play in
                  advanced usages, as well as extension mechanics that allow
                  support of new forms of fork/join processing.
                  &lt;p&gt;A {@code ForkJoinTask} is a lightweight form of {@link Future}.
                  The efficiency of {@code ForkJoinTask}s stems from a set of
                  restrictions (that are only partially statically enforceable)
                  reflecting their intended use as computational tasks calculating
                  pure functions or operating on purely isolated objects.  The
                  primary coordination mechanisms are {@link #fork}, that arranges
                  asynchronous execution, and {@link #join}, that doesn&apos;t proceed
                  until the task&apos;s result has been computed.  Computations should
                  avoid {@code synchronized} methods or blocks, and should minimize
                  other blocking synchronization apart from joining other tasks or
                  using synchronizers such as Phasers that are advertised to
                  cooperate with fork/join scheduling. Tasks should also not perform
                  blocking IO, and should ideally access variables that are
                  completely independent of those accessed by other running
                  tasks. Minor breaches of these restrictions, for example using
                  shared output streams, may be tolerable in practice, but frequent
                  use may result in poor performance, and the potential to
                  indefinitely stall if the number of threads not waiting for IO or
                  other external synchronization becomes exhausted. This usage
                  restriction is in part enforced by not permitting checked
                  exceptions such as {@code IOExceptions} to be thrown. However,
                  computations may still encounter unchecked exceptions, that are
                  rethrown to callers attempting to join them. These exceptions may
                  additionally include {@link RejectedExecutionException} stemming
                  from internal resource exhaustion, such as failure to allocate
                  internal task queues. Rethrown exceptions behave in the same way as
                  regular exceptions, but, when possible, contain stack traces (as
                  displayed for example using {@code ex.printStackTrace()}) of both
                  the thread that initiated the computation as well as the thread
                  actually encountering the exception; minimally only the latter.
                  &lt;p&gt;The primary method for awaiting completion and extracting
                  results of a task is {@link #join}, but there are several variants:
                  The {@link Future#get} methods support interruptible and/or timed
                  waits for completion and report results using {@code Future}conventions. Method {@link #invoke} is semantically
                  equivalent to {@code fork(); join()} but always attempts to begin
                  execution in the current thread. The &quot;&lt;em&gt;quiet&lt;/em&gt;&quot; forms of
                  these methods do not extract results or report exceptions. These
                  may be useful when a set of tasks are being executed, and you need
                  to delay processing of results or exceptions until all complete.
                  Method {@code invokeAll} (available in multiple versions)
                  performs the most common form of parallel invocation: forking a set
                  of tasks and joining them all.
                  &lt;p&gt;The execution status of tasks may be queried at several levels
                  of detail: {@link #isDone} is true if a task completed in any way
                  (including the case where a task was cancelled without executing);{@link #isCompletedNormally} is true if a task completed without
                  cancellation or encountering an exception; {@link #isCancelled} is
                  true if the task was cancelled (in which case {@link #getException}returns a {@link java.util.concurrent.CancellationException}); and{@link #isCompletedAbnormally} is true if a task was either
                  cancelled or encountered an exception, in which case {@link #getException} will return either the encountered exception or{@link java.util.concurrent.CancellationException}.
                  &lt;p&gt;The ForkJoinTask class is not usually directly subclassed.
                  Instead, you subclass one of the abstract classes that support a
                  particular style of fork/join processing, typically {@link RecursiveAction} for computations that do not return results, or{@link RecursiveTask} for those that do.  Normally, a concrete
                  ForkJoinTask subclass declares fields comprising its parameters,
                  established in a constructor, and then defines a {@code compute}method that somehow uses the control methods supplied by this base
                  class. While these methods have {@code public} access (to allow
                  instances of different task subclasses to call each other&apos;s
                  methods), some of them may only be called from within other
                  ForkJoinTasks (as may be determined using method {@link #inForkJoinPool}).  Attempts to invoke them in other contexts
                  result in exceptions or errors, possibly including{@code ClassCastException}.
                  &lt;p&gt;Method {@link #join} and its variants are appropriate for use
                  only when completion dependencies are acyclic; that is, the
                  parallel computation can be described as a directed acyclic graph
                  (DAG). Otherwise, executions may encounter a form of deadlock as
                  tasks cyclically wait for each other.  However, this framework
                  supports other methods and techniques (for example the use of{@link Phaser}, {@link #helpQuiesce}, and {@link #complete}) that
                  may be of use in constructing custom subclasses for problems that
                  are not statically structured as DAGs.
                  &lt;p&gt;Most base support methods are {@code final}, to prevent
                  overriding of implementations that are intrinsically tied to the
                  underlying lightweight task scheduling framework.  Developers
                  creating new basic styles of fork/join processing should minimally
                  implement {@code protected} methods {@link #exec}, {@link #setRawResult}, and {@link #getRawResult}, while also introducing
                  an abstract computational method that can be implemented in its
                  subclasses, possibly relying on other {@code protected} methods
                  provided by this class.
                  &lt;p&gt;ForkJoinTasks should perform relatively small amounts of
                  computation. Large tasks should be split into smaller subtasks,
                  usually via recursive decomposition. As a very rough rule of thumb,
                  a task should perform more than 100 and less than 10000 basic
                  computational steps, and should avoid indefinite looping. If tasks
                  are too big, then parallelism cannot improve throughput. If too
                  small, then memory and internal task maintenance overhead may
                  overwhelm processing.
                  &lt;p&gt;This class provides {@code adapt} methods for {@link Runnable}and {@link Callable}, that may be of use when mixing execution of{@code ForkJoinTasks} with other kinds of tasks. When all tasks are
                  of this form, consider using a pool constructed in &lt;em&gt;asyncMode&lt;/em&gt;.
                  &lt;p&gt;ForkJoinTasks are {@code Serializable}, which enables them to be
                  used in extensions such as remote execution frameworks. It is
                  sensible to serialize tasks only before or after, but not during,
                  execution. Serialization is not relied on during execution itself.                
                <since>
                    1.7                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <declaration name="status" type="int" line="222"/>
            <javadoc line="222">
                The run status of this task                
            </javadoc>
            <declaration name="NORMAL" type="int" line="224"/>
            <declaration name="CANCELLED" type="int" line="225"/>
            <declaration name="EXCEPTIONAL" type="int" line="226"/>
            <declaration name="SIGNAL" type="int" line="227"/>
            <javadoc line="229">
                Marks completion and wakes up threads waiting to join this task,
                  also clearing signal request bits.                
                <param>
                    completion one of NORMAL, CANCELLED, EXCEPTIONAL                    
                </param>
                <return>
                    completion status on exit                    
                </return>
            </javadoc>
            <method name="setCompletion" type="int" line="236">
                <params>
                    <param name="completion" type="int"/>
                </params>
                <scope line="237">
                    <scope line="240">
                        <scope line="242"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="248">
                Tries to block a worker thread until completed or timed out.
                  Uses Object.wait time argument conventions.
                  May fail on contention or interrupt.                
                <param>
                    millis if > 0, wait time.                    
                </param>
            </javadoc>
            <method name="tryAwaitDone" type="void" line="255">
                <params>
                    <param name="millis" type="long"/>
                </params>
                <comment line="268">
                    caller must check termination                    
                </comment>
                <declaration name="s" type="int" line="256"/>
                <scope line="257">
                    <scope line="261">
                        <scope line="262"/>
                    </scope>
                </scope>
                <scope line="267"/>
            </method>
            <javadoc line="272">
                Blocks a non-worker-thread until completion.                
                <return>
                    status upon completion                    
                </return>
            </javadoc>
            <method name="externalAwaitDone" type="int" line="276">
                <declaration name="s" type="int" line="277"/>
                <scope line="278">
                    <declaration name="interrupted" type="boolean" line="279"/>
                    <scope line="280">
                        <scope line="281">
                            <scope line="285">
                                <scope line="286"/>
                                <scope line="288"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="300">
                Blocks a non-worker-thread until completion or interruption or timeout.                
            </javadoc>
            <method name="externalInterruptibleAwaitDone" type="int" line="304">
                <params>
                    <param name="millis" type="long"/>
                </params>
                <declaration name="s" type="int" line="305"/>
                <scope line="308">
                    <scope line="309">
                        <scope line="310">
                            <scope line="314"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="325">
                Primary execution method for stolen tasks. Unless done, calls
                  exec and records status if completed, but doesn&apos;t wait for
                  completion otherwise.                
            </javadoc>
            <method name="doExec" type="void" line="330">
                <comment line="340">
                    must be outside try block                    
                </comment>
                <scope line="331">
                    <declaration name="completed" type="boolean" line="332"/>
                    <scope line="333"/>
                    <scope line="335"/>
                </scope>
            </method>
            <javadoc line="344">
                Primary mechanics for join, get, quietlyJoin.                
                <return>
                    status upon completion                    
                </return>
            </javadoc>
            <method name="doJoin" type="int" line="348">
                <declaration name="t" type="Thread" line="349"/>
                <declaration name="w" type="ForkJoinWorkerThread" line="349"/>
                <declaration name="s" type="int" line="349"/>
                <declaration name="completed" type="boolean" line="349"/>
                <scope line="350">
                    <scope line="353">
                        <scope line="354"/>
                        <scope line="356"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="368">
                Primary mechanics for invoke, quietlyInvoke.                
                <return>
                    status upon completion                    
                </return>
            </javadoc>
            <method name="doInvoke" type="int" line="372">
                <declaration name="s" type="int" line="373"/>
                <declaration name="completed" type="boolean" line="373"/>
                <scope line="376"/>
                <scope line="378"/>
            </method>
            <declaration name="exceptionTable" type="ExceptionNode[]" line="389"/>
            <javadoc line="389">
                Table of exceptions thrown by tasks, to enable reporting by
                  callers. Because exceptions are rare, we don&apos;t directly keep
                  them with task objects, but instead use a weak ref table.  Note
                  that cancellation exceptions don&apos;t appear in the table, but are
                  instead recorded as status values.
                  Note: These statics are initialized below in static block.                
            </javadoc>
            <declaration name="exceptionTableLock" type="ReentrantLock" line="399"/>
            <declaration name="exceptionTableRefQueue" type="ReferenceQueue&lt;Object&gt;" line="400"/>
            <declaration name="EXCEPTION_MAP_CAPACITY" type="int" line="402"/>
            <javadoc line="402">
                Fixed capacity for exceptionTable.                
            </javadoc>
            <class name="ExceptionNode" line="407">
                <extends class="WeakReference">
                    <type_params>
                        <type_param name="ForkJoinTask<?>"/>
                    </type_params>
                </extends>
                <comment line="423">
                    use id not ref to avoid weak cycles                    
                </comment>
                <javadoc line="407">
                    Key-value nodes for exception table.  The chained hash table
                      uses identity comparisons, full locking, and weak references
                      for keys. The table has a fixed capacity because it only
                      maintains task exceptions long enough for joiners to access
                      them, so should never become very large for sustained
                      periods. However, since we do not know when the last joiner
                      completes, we must use weak references and expunge them. We do
                      so on each operation (hence full locking). Also, some thread in
                      any ForkJoinPool will call helpExpungeStaleExceptions when its
                      pool becomes isQuiescent.                    
                </javadoc>
                <declaration name="ex" type="Throwable" line="420"/>
                <declaration name="next" type="ExceptionNode" line="421"/>
                <declaration name="thrower" type="long" line="422"/>
                <method name="ExceptionNode" type="constructor" line="423">
                    <params>
                        <param name="task" type="ForkJoinTask<?>"/>
                        <param name="ex" type="Throwable"/>
                        <param name="next" type="ExceptionNode"/>
                    </params>
                </method>
            </class>
            <javadoc line="431">
                Records exception and sets exceptional completion.                
                <return>
                    status on exit                    
                </return>
            </javadoc>
            <method name="setExceptionalCompletion" type="int" line="436">
                <params>
                    <param name="ex" type="Throwable"/>
                </params>
                <comment line="449">
                    already present                    
                </comment>
                <declaration name="h" type="int" line="437"/>
                <declaration name="lock" type="ReentrantLock" line="438"/>
                <scope line="440">
                    <declaration name="t" type="ExceptionNode[]" line="442"/>
                    <declaration name="i" type="int" line="443"/>
                    <scope line="444">
                        <scope line="445"/>
                    </scope>
                </scope>
                <scope line="452"/>
            </method>
            <javadoc line="458">
                Removes exception node and clears status                
            </javadoc>
            <method name="clearExceptionalCompletion" type="void" line="461">
                <declaration name="h" type="int" line="462"/>
                <declaration name="lock" type="ReentrantLock" line="463"/>
                <scope line="465">
                    <declaration name="t" type="ExceptionNode[]" line="466"/>
                    <declaration name="i" type="int" line="467"/>
                    <declaration name="e" type="ExceptionNode" line="468"/>
                    <declaration name="pred" type="ExceptionNode" line="469"/>
                    <scope line="470">
                        <declaration name="next" type="ExceptionNode" line="471"/>
                        <scope line="472"/>
                    </scope>
                </scope>
                <scope line="484"/>
            </method>
            <javadoc line="489">
                Returns a rethrowable exception for the given task, if
                  available. To provide accurate stack traces, if the exception
                  was not thrown by the current thread, we try to create a new
                  exception of the same type as the one thrown, but with the
                  recorded exception as its cause. If there is no such
                  constructor, we instead try to use a no-arg constructor,
                  followed by initCause, to the same effect. If none of these
                  apply, or any fail due to other exceptions, we return the
                  recorded exception, which is still correct, although it may
                  contain a misleading stack trace.                
                <return>
                    the exception, or null if none                    
                </return>
            </javadoc>
            <method name="getThrowableException" type="Throwable" line="503">
                <comment line="526">
                    public ctors only                    
                </comment>
                <declaration name="h" type="int" line="506"/>
                <declaration name="e" type="ExceptionNode" line="507"/>
                <declaration name="lock" type="ReentrantLock" line="508"/>
                <scope line="510">
                    <declaration name="t" type="ExceptionNode[]" line="512"/>
                </scope>
                <scope line="516"/>
                <declaration name="ex" type="Throwable" line="519"/>
                <scope line="522">
                    <declaration name="ec" type="Class" line="523"/>
                    <scope line="524">
                        <declaration name="noArgCtor" type="Constructor&lt;?&gt;" line="525"/>
                        <declaration name="cs" type="Constructor&lt;?&gt;[]" line="526"/>
                        <scope line="527">
                            <declaration name="c" type="Constructor&lt;?&gt;" line="528"/>
                            <declaration name="ps" type="Class&lt;?&gt;[]" line="529"/>
                        </scope>
                        <scope line="535">
                            <declaration name="wx" type="Throwable" line="536"/>
                        </scope>
                    </scope>
                    <scope line="540"/>
                </scope>
            </method>
            <javadoc line="546">
                Poll stale refs and remove them. Call only while holding lock.                
            </javadoc>
            <method name="expungeStaleExceptions" type="void" line="549">
                <scope line="550">
                    <scope line="551">
                        <declaration name="key" type="ForkJoinTask&lt;?&gt;" line="552"/>
                        <declaration name="t" type="ExceptionNode[]" line="553"/>
                        <declaration name="i" type="int" line="554"/>
                        <declaration name="e" type="ExceptionNode" line="555"/>
                        <declaration name="pred" type="ExceptionNode" line="556"/>
                        <scope line="557">
                            <declaration name="next" type="ExceptionNode" line="558"/>
                            <scope line="559"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="573">
                If lock is available, poll stale refs and remove them.
                  Called from ForkJoinPool when pools become quiescent.                
            </javadoc>
            <method name="helpExpungeStaleExceptions" type="void" line="577">
                <declaration name="lock" type="ReentrantLock" line="578"/>
                <scope line="579">
                    <scope line="580"/>
                    <scope line="582"/>
                </scope>
            </method>
            <javadoc line="588">
                Report the result of invoke or join; called only upon
                  non-normal return of internal versions.                
            </javadoc>
            <method name="reportResult" type="V" line="592">
                <declaration name="s" type="int" line="593"/>
                <declaration name="ex" type="Throwable" line="593"/>
            </method>
            <javadoc line="603">
                Arranges to asynchronously execute this task.  While it is not
                  necessarily enforced, it is a usage error to fork a task more
                  than once unless it has completed and been reinitialized.
                  Subsequent modifications to the state of this task or any data
                  it operates on are not necessarily consistently observable by
                  any thread other than the one executing it unless preceded by a
                  call to {@link #join} or related methods, or a call to {@link #isDone} returning {@code true}.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <return>
                    {@code this}, to simplify usage                    
                </return>
            </javadoc>
            <method name="fork" type="ForkJoinTask<V>" line="621"/>
            <javadoc line="627">
                Returns the result of the computation when it {@link #isDone is
                  done}.  This method differs from {@link #get()} in that
                  abnormal completion results in {@code RuntimeException} or{@code Error}, not {@code ExecutionException}, and that
                  interrupts of the calling thread do &lt;em&gt;not&lt;/em&gt; cause the
                  method to abruptly return by throwing {@codeInterruptedException}.                
                <return>
                    the computed result                    
                </return>
            </javadoc>
            <method name="join" type="V" line="638"/>
            <javadoc line="645">
                Commences performing this task, awaits its completion if
                  necessary, and returns its result, or throws an (unchecked){@code RuntimeException} or {@code Error} if the underlying
                  computation did so.                
                <return>
                    the computed result                    
                </return>
            </javadoc>
            <method name="invoke" type="V" line="653"/>
            <javadoc line="660">
                Forks the given tasks, returning when {@code isDone} holds for
                  each task or an (unchecked) exception is encountered, in which
                  case the exception is rethrown. If more than one task
                  encounters an exception, then this method throws any one of
                  these exceptions. If any task encounters an exception, the
                  other may be cancelled. However, the execution status of
                  individual tasks is not guaranteed upon exceptional return. The
                  status of each task may be obtained using {@link #getException()} and related methods to check if they have been
                  cancelled, completed normally or exceptionally, or left
                  unprocessed.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <param>
                    t1 the first task                    
                </param>
                <param>
                    t2 the second task                    
                </param>
                <throws>
                    NullPointerException if any task is null                    
                </throws>
            </javadoc>
            <method name="invokeAll" type="void" line="683">
                <params>
                    <param name="t1" type="ForkJoinTask<?>"/>
                    <param name="t2" type="ForkJoinTask<?>"/>
                </params>
            </method>
            <javadoc line="689">
                Forks the given tasks, returning when {@code isDone} holds for
                  each task or an (unchecked) exception is encountered, in which
                  case the exception is rethrown. If more than one task
                  encounters an exception, then this method throws any one of
                  these exceptions. If any task encounters an exception, others
                  may be cancelled. However, the execution status of individual
                  tasks is not guaranteed upon exceptional return. The status of
                  each task may be obtained using {@link #getException()} and
                  related methods to check if they have been cancelled, completed
                  normally or exceptionally, or left unprocessed.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <param>
                    tasks the tasks                    
                </param>
                <throws>
                    NullPointerException if any task is null                    
                </throws>
            </javadoc>
            <method name="invokeAll" type="void" line="710">
                <params>
                    <param name="tasks" type="ForkJoinTask<?>"/>
                </params>
                <declaration name="ex" type="Throwable" line="711"/>
                <declaration name="last" type="int" line="712"/>
                <scope line="713">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="714"/>
                    <scope line="715"/>
                </scope>
                <scope line="724">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="725"/>
                    <scope line="726"/>
                </scope>
            </method>
            <javadoc line="737">
                Forks all tasks in the specified collection, returning when{@code isDone} holds for each task or an (unchecked) exception
                  is encountered, in which case the exception is rethrown. If
                  more than one task encounters an exception, then this method
                  throws any one of these exceptions. If any task encounters an
                  exception, others may be cancelled. However, the execution
                  status of individual tasks is not guaranteed upon exceptional
                  return. The status of each task may be obtained using {@link #getException()} and related methods to check if they have been
                  cancelled, completed normally or exceptionally, or left
                  unprocessed.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <param>
                    tasks the collection of tasks                    
                </param>
                <return>
                    the tasks argument, to simplify usage                    
                </return>
                <throws>
                    NullPointerException if tasks or any element are null                    
                </throws>
            </javadoc>
            <method name="invokeAll" type="Collection<T>" line="760">
                <params>
                    <param name="tasks" type="Collection<T>"/>
                </params>
                <scope line="761"/>
                <declaration name="ts" type="List&lt;? extends ForkJoinTask&lt;?&gt;&gt;" line="765"/>
                <declaration name="ex" type="Throwable" line="768"/>
                <declaration name="last" type="int" line="769"/>
                <scope line="770">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="771"/>
                    <scope line="772"/>
                </scope>
                <scope line="781">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="782"/>
                    <scope line="783"/>
                </scope>
            </method>
            <javadoc line="795">
                Attempts to cancel execution of this task. This attempt will
                  fail if the task has already completed or could not be
                  cancelled for some other reason. If successful, and this task
                  has not started when {@code cancel} is called, execution of
                  this task is suppressed. After this method returns
                  successfully, unless there is an intervening call to {@link #reinitialize}, subsequent calls to {@link #isCancelled},{@link #isDone}, and {@code cancel} will return {@code true}and calls to {@link #join} and related methods will result in{@code CancellationException}.
                  &lt;p&gt;This method may be overridden in subclasses, but if so, must
                  still ensure that these properties hold. In particular, the{@code cancel} method itself must not throw exceptions.
                  &lt;p&gt;This method is designed to be invoked by &lt;em&gt;other&lt;/em&gt;
                  tasks. To terminate the current task, you can just return or
                  throw an unchecked exception from its computation method, or
                  invoke {@link #completeExceptionally}.                
                <param>
                    mayInterruptIfRunning this value has no effect in the
                      default implementation because interrupts are not used to
                      control cancellation.                    
                </param>
                <return>
                    {@code true} if this task is now cancelled                    
                </return>
            </javadoc>
            <method name="cancel" type="boolean" line="822">
                <params>
                    <param name="mayInterruptIfRunning" type="boolean"/>
                </params>
            </method>
            <javadoc line="826">
                Cancels, ignoring any exceptions thrown by cancel. Used during
                  worker and pool shutdown. Cancel is spec&apos;ed not to throw any
                  exceptions, but if it does anyway, we have no recourse during
                  shutdown, so guard against this case.                
            </javadoc>
            <method name="cancelIgnoringExceptions" type="void" line="832">
                <scope line="833"/>
                <scope line="835"/>
            </method>
            <method name="isDone" type="boolean" line="839"/>
            <method name="isCancelled" type="boolean" line="843"/>
            <javadoc line="847">
                Returns {@code true} if this task threw an exception or was cancelled.                
                <return>
                    {@code true} if this task threw an exception or was cancelled                    
                </return>
            </javadoc>
            <method name="isCompletedAbnormally" type="boolean" line="852"/>
            <javadoc line="856">
                Returns {@code true} if this task completed without throwing an
                  exception and was not cancelled.                
                <return>
                    {@code true} if this task completed without throwing an
                      exception and was not cancelled                    
                </return>
            </javadoc>
            <method name="isCompletedNormally" type="boolean" line="863"/>
            <javadoc line="867">
                Returns the exception thrown by the base computation, or a{@code CancellationException} if cancelled, or {@code null} if
                  none or if the method has not yet completed.                
                <return>
                    the exception, or {@code null} if none                    
                </return>
            </javadoc>
            <method name="getException" type="Throwable" line="874">
                <declaration name="s" type="int" line="875"/>
            </method>
            <javadoc line="881">
                Completes this task abnormally, and if not already aborted or
                  cancelled, causes it to throw the given exception upon{@code join} and related operations. This method may be used
                  to induce exceptions in asynchronous tasks, or to force
                  completion of tasks that would not otherwise complete.  Its use
                  in other situations is discouraged.  This method is
                  overridable, but overridden versions must invoke {@code super}implementation to maintain guarantees.                
                <param>
                    ex the exception to throw. If this exception is not a{@code RuntimeException} or {@code Error}, the actual exception
                      thrown will be a {@code RuntimeException} with cause {@code ex}.                    
                </param>
            </javadoc>
            <method name="completeExceptionally" type="void" line="895">
                <params>
                    <param name="ex" type="Throwable"/>
                </params>
            </method>
            <javadoc line="901">
                Completes this task, and if not already aborted or cancelled,
                  returning the given value as the result of subsequent
                  invocations of {@code join} and related operations. This method
                  may be used to provide results for asynchronous tasks, or to
                  provide alternative handling for tasks that would not otherwise
                  complete normally. Its use in other situations is
                  discouraged. This method is overridable, but overridden
                  versions must invoke {@code super} implementation to maintain
                  guarantees.                
                <param>
                    value the result value for this task                    
                </param>
            </javadoc>
            <method name="complete" type="void" line="914">
                <params>
                    <param name="value" type="V"/>
                </params>
                <scope line="915"/>
                <scope line="917"/>
            </method>
            <javadoc line="924">
                Waits if necessary for the computation to complete, and then
                  retrieves its result.                
                <return>
                    the computed result                    
                </return>
                <throws>
                    CancellationException if the computation was cancelled                    
                </throws>
                <throws>
                    ExecutionException if the computation threw an
                      exception                    
                </throws>
                <throws>
                    InterruptedException if the current thread is not a
                      member of a ForkJoinPool and was interrupted while waiting                    
                </throws>
            </javadoc>
            <method name="get" type="V" line="935">
                <declaration name="s" type="int" line="936"/>
                <declaration name="ex" type="Throwable" line="938"/>
            </method>
            <javadoc line="946">
                Waits if necessary for at most the given time for the computation
                  to complete, and then retrieves its result, if available.                
                <param>
                    timeout the maximum time to wait                    
                </param>
                <param>
                    unit the time unit of the timeout argument                    
                </param>
                <return>
                    the computed result                    
                </return>
                <throws>
                    CancellationException if the computation was cancelled                    
                </throws>
                <throws>
                    ExecutionException if the computation threw an
                      exception                    
                </throws>
                <throws>
                    InterruptedException if the current thread is not a
                      member of a ForkJoinPool and was interrupted while waiting                    
                </throws>
                <throws>
                    TimeoutException if the wait timed out                    
                </throws>
            </javadoc>
            <method name="get" type="V" line="961">
                <params>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="t" type="Thread" line="962"/>
                <scope line="963">
                    <declaration name="w" type="ForkJoinWorkerThread" line="964"/>
                    <declaration name="nanos" type="long" line="965"/>
                    <scope line="966">
                        <declaration name="completed" type="boolean" line="967"/>
                        <scope line="968">
                            <scope line="969"/>
                            <scope line="971"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="981">
                    <declaration name="millis" type="long" line="982"/>
                </scope>
                <declaration name="s" type="int" line="986"/>
                <scope line="987">
                    <declaration name="ex" type="Throwable" line="988"/>
                </scope>
            </method>
            <javadoc line="999">
                Joins this task, without returning its result or throwing its
                  exception. This method may be useful when processing
                  collections of tasks when some have been cancelled or otherwise
                  known to have aborted.                
            </javadoc>
            <method name="quietlyJoin" type="void" line="1005"/>
            <javadoc line="1009">
                Commences performing this task and awaits its completion if
                  necessary, without returning its result or throwing its
                  exception.                
            </javadoc>
            <method name="quietlyInvoke" type="void" line="1014"/>
            <javadoc line="1018">
                Possibly executes tasks until the pool hosting the current task{@link ForkJoinPool#isQuiescent is quiescent}. This method may
                  be of use in designs in which many tasks are forked, but none
                  are explicitly joined, instead executing them until all are
                  processed.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
            </javadoc>
            <method name="helpQuiesce" type="void" line="1031"/>
            <javadoc line="1036">
                Resets the internal bookkeeping state of this task, allowing a
                  subsequent {@code fork}. This method allows repeated reuse of
                  this task, but only if reuse occurs when this task has either
                  never been forked, or has been forked, then completed and all
                  outstanding joins of this task have also completed. Effects
                  under any other usage conditions are not guaranteed.
                  This method may be useful when executing
                  pre-constructed trees of subtasks in loops.
                  &lt;p&gt;Upon completion of this method, {@code isDone()} reports{@code false}, and {@code getException()} reports {@codenull}. However, the value returned by {@code getRawResult} is
                  unaffected. To clear this value, you can invoke {@codesetRawResult(null)}.                
            </javadoc>
            <method name="reinitialize" type="void" line="1052"/>
            <javadoc line="1059">
                Returns the pool hosting the current task execution, or null
                  if this task is executing outside of any ForkJoinPool.                
                <see>
                    #inForkJoinPool                    
                </see>
                <return>
                    the pool, or {@code null} if none                    
                </return>
            </javadoc>
            <method name="getPool" type="ForkJoinPool" line="1066">
                <declaration name="t" type="Thread" line="1067"/>
            </method>
            <javadoc line="1072">
                Returns {@code true} if the current thread is a {@link ForkJoinWorkerThread} executing as a ForkJoinPool computation.                
                <return>
                    {@code true} if the current thread is a {@link ForkJoinWorkerThread} executing as a ForkJoinPool computation,
                      or {@code false} otherwise                    
                </return>
            </javadoc>
            <method name="inForkJoinPool" type="boolean" line="1080"/>
            <javadoc line="1084">
                Tries to unschedule this task for execution. This method will
                  typically succeed if this task is the most recently forked task
                  by the current thread, and has not commenced executing in
                  another thread.  This method may be useful when arranging
                  alternative local processing of tasks that could have been, but
                  were not, stolen.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <return>
                    {@code true} if unforked                    
                </return>
            </javadoc>
            <method name="tryUnfork" type="boolean" line="1100"/>
            <javadoc line="1105">
                Returns an estimate of the number of tasks that have been
                  forked by the current worker thread but not yet executed. This
                  value may be useful for heuristic decisions about whether to
                  fork other tasks.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <return>
                    the number of tasks                    
                </return>
            </javadoc>
            <method name="getQueuedTaskCount" type="int" line="1119"/>
            <javadoc line="1124">
                Returns an estimate of how many more locally queued tasks are
                  held by the current worker thread than there are other worker
                  threads that might steal them.  This value may be useful for
                  heuristic decisions about whether to fork other tasks. In many
                  usages of ForkJoinTasks, at steady state, each worker should
                  aim to maintain a small constant surplus (for example, 3) of
                  tasks, and to process computations locally if this threshold is
                  exceeded.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <return>
                    the surplus number of tasks, which may be negative                    
                </return>
            </javadoc>
            <method name="getSurplusQueuedTaskCount" type="int" line="1142"/>
            <method name="getRawResult" type="V" line="1149"/>
            <javadoc line="1149">
                Returns the result that would be returned by {@link #join}, even
                  if this task completed abnormally, or {@code null} if this task
                  is not known to have been completed.  This method is designed
                  to aid debugging, as well as to support extensions. Its use in
                  any other context is discouraged.                
                <return>
                    the result, or {@code null} if not completed                    
                </return>
            </javadoc>
            <method name="setRawResult" type="void" line="1160"/>
            <javadoc line="1160">
                Forces the given value to be returned as a result.  This method
                  is designed to support extensions, and should not in general be
                  called otherwise.                
                <param>
                    value the value                    
                </param>
            </javadoc>
            <method name="exec" type="boolean" line="1169"/>
            <javadoc line="1169">
                Immediately performs the base action of this task.  This method
                  is designed to support extensions, and should not in general be
                  called otherwise. The return value controls whether this task
                  is considered to be done normally. It may return false in
                  asynchronous actions that require explicit invocations of{@link #complete} to become joinable. It may also throw an
                  (unchecked) exception to indicate abnormal exit.                
                <return>
                    {@code true} if completed normally                    
                </return>
            </javadoc>
            <javadoc line="1182">
                Returns, but does not unschedule or execute, a task queued by
                  the current thread but not yet executed, if one is immediately
                  available. There is no guarantee that this task will actually
                  be polled or executed next. Conversely, this method may return
                  null even if a task exists but cannot be accessed without
                  contention with other threads.  This method is designed
                  primarily to support extensions, and is unlikely to be useful
                  otherwise.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <return>
                    the next task, or {@code null} if none are available                    
                </return>
            </javadoc>
            <method name="peekNextLocalTask" type="ForkJoinTask<?>" line="1200"/>
            <javadoc line="1205">
                Unschedules and returns, without executing, the next task
                  queued by the current thread but not yet executed.  This method
                  is designed primarily to support extensions, and is unlikely to
                  be useful otherwise.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <return>
                    the next task, or {@code null} if none are available                    
                </return>
            </javadoc>
            <method name="pollNextLocalTask" type="ForkJoinTask<?>" line="1219"/>
            <javadoc line="1224">
                Unschedules and returns, without executing, the next task
                  queued by the current thread but not yet executed, if one is
                  available, or if not available, a task that was forked by some
                  other thread, if available. Availability may be transient, so a{@code null} result does not necessarily imply quiescence
                  of the pool this task is operating in.  This method is designed
                  primarily to support extensions, and is unlikely to be useful
                  otherwise.
                  &lt;p&gt;This method may be invoked only from within {@codeForkJoinPool} computations (as may be determined using method{@link #inForkJoinPool}).  Attempts to invoke in other contexts
                  result in exceptions or errors, possibly including {@codeClassCastException}.                
                <return>
                    a task, or {@code null} if none are available                    
                </return>
            </javadoc>
            <method name="pollTask" type="ForkJoinTask<?>" line="1242"/>
            <class name="AdaptedRunnable" line="1247">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <extends class="ForkJoinTask">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </extends>
                <comment line="423">
                    use id not ref to avoid weak cycles                    
                </comment>
                <implements interface="RunnableFuture">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <javadoc line="1247">
                    Adaptor for Runnables. This implements RunnableFuture
                      to be compliant with AbstractExecutorService constraints
                      when used in ForkJoinPool.                    
                </javadoc>
                <declaration name="runnable" type="Runnable" line="1254"/>
                <declaration name="resultOnCompletion" type="T" line="1255"/>
                <declaration name="result" type="T" line="1256"/>
                <method name="AdaptedRunnable" type="constructor" line="1257">
                    <params>
                        <param name="runnable" type="Runnable"/>
                        <param name="result" type="T"/>
                    </params>
                </method>
                <method name="getRawResult" type="T" line="1262"/>
                <method name="setRawResult" type="void" line="1263">
                    <params>
                        <param name="v" type="T"/>
                    </params>
                </method>
                <method name="exec" type="boolean" line="1264"/>
                <method name="run" type="void" line="1269"/>
                <declaration name="serialVersionUID" type="long" line="1270"/>
            </class>
            <class name="AdaptedCallable" line="1273">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <extends class="ForkJoinTask">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </extends>
                <comment line="423">
                    use id not ref to avoid weak cycles                    
                </comment>
                <implements interface="RunnableFuture">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <javadoc line="1273">
                    Adaptor for Callables                    
                </javadoc>
                <declaration name="callable" type="Callable&lt;? extends T&gt;" line="1278"/>
                <declaration name="result" type="T" line="1279"/>
                <method name="AdaptedCallable" type="constructor" line="1280">
                    <params>
                        <param name="callable" type="Callable<? extends T>"/>
                    </params>
                </method>
                <method name="getRawResult" type="T" line="1284"/>
                <method name="setRawResult" type="void" line="1285">
                    <params>
                        <param name="v" type="T"/>
                    </params>
                </method>
                <method name="exec" type="boolean" line="1286">
                    <scope line="1287"/>
                    <scope line="1290"/>
                    <scope line="1292"/>
                    <scope line="1294"/>
                </method>
                <method name="run" type="void" line="1298"/>
                <declaration name="serialVersionUID" type="long" line="1299"/>
            </class>
            <javadoc line="1302">
                Returns a new {@code ForkJoinTask} that performs the {@code run}method of the given {@code Runnable} as its action, and returns
                  a null result upon {@link #join}.                
                <param>
                    runnable the runnable action                    
                </param>
                <return>
                    the task                    
                </return>
            </javadoc>
            <method name="adapt" type="ForkJoinTask<?>" line="1310">
                <params>
                    <param name="runnable" type="Runnable"/>
                </params>
            </method>
            <javadoc line="1314">
                Returns a new {@code ForkJoinTask} that performs the {@code run}method of the given {@code Runnable} as its action, and returns
                  the given result upon {@link #join}.                
                <param>
                    runnable the runnable action                    
                </param>
                <param>
                    result the result upon completion                    
                </param>
                <return>
                    the task                    
                </return>
            </javadoc>
            <method name="adapt" type="ForkJoinTask<T>" line="1323">
                <params>
                    <param name="runnable" type="Runnable"/>
                    <param name="result" type="T"/>
                </params>
            </method>
            <javadoc line="1327">
                Returns a new {@code ForkJoinTask} that performs the {@code call}method of the given {@code Callable} as its action, and returns
                  its result upon {@link #join}, translating any checked exceptions
                  encountered into {@code RuntimeException}.                
                <param>
                    callable the callable action                    
                </param>
                <return>
                    the task                    
                </return>
            </javadoc>
            <method name="adapt" type="ForkJoinTask<T>" line="1336">
                <params>
                    <param name="callable" type="Callable<? extends T>"/>
                </params>
            </method>
            <declaration name="serialVersionUID" type="long" line="1342"/>
            <javadoc line="1344">
                Saves the state to a stream (that is, serializes it).                
                <serialData>
                    the current run status and the exception thrown
                      during execution, or {@code null} if none                    
                </serialData>
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="1352">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
            </method>
            <javadoc line="1357">
                Reconstitutes the instance from a stream (that is, deserializes it).                
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="1363">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <declaration name="ex" type="Object" line="1365"/>
            </method>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="1371"/>
            <declaration name="statusOffset" type="long" line="1372"/>
            <scope line="1373">
                <scope line="1377"/>
                <scope line="1381"/>
            </scope>
        </class>
    </source>