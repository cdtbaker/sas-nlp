<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.concurrent.locks"/>
        <import package="java.util.concurrent.atomic"/>
        <import package="java.util"/>
        <class name="SynchronousQueue" line="42">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="AbstractQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <comment line="87">
                This class implements extensions of the dual stack and dual
                 queue algorithms described in &quot;Nonblocking Concurrent Objects
                 with Condition Synchronization&quot;, by W. N. Scherer III and
                 M. L. Scott.  18th Annual Conf. on Distributed Computing,
                 Oct. 2004 (see also
                 http:www.cs.rochester.eduuscottsynchronizationpseudocodeduals.html).
                 The (Lifo) stack is used for non-fair mode, and the (Fifo)
                 queue for fair mode. The performance of the two is generally
                 similar. Fifo usually supports higher throughput under
                 contention but Lifo maintains higher thread locality in common
                 applications.
                
                 A dual queue (and similarly stack) is one that at any given
                 time either holds &quot;data&quot; -- items provided by put operations,
                 or &quot;requests&quot; -- slots representing take operations, or is
                 empty. A call to &quot;fulfill&quot; (i.e., a call requesting an item
                 from a queue holding data or vice versa) dequeues a
                 complementary node.  The most interesting feature of these
                 queues is that any operation can figure out which mode the
                 queue is in, and act accordingly without needing locks.
                
                 Both the queue and stack extend abstract class Transferer
                 defining the single method transfer that does a put or a
                 take. These are unified into a single method because in dual
                 data structures, the put and take operations are symmetrical,
                 so nearly all code can be combined. The resulting transfer
                 methods are on the long side, but are easier to follow than
                 they would be if broken up into nearly-duplicated parts.
                
                 The queue and stack data structures share many conceptual
                 similarities but very few concrete details. For simplicity,
                 they are kept distinct so that they can later evolve
                 separately.
                
                 The algorithms here differ from the versions in the above paper
                 in extending them for use in synchronous queues, as well as
                 dealing with cancellation. The main differences include:
                
                  1. The original algorithms used bit-marked pointers, but
                     the ones here use mode bits in nodes, leading to a number
                     of further adaptations.
                  2. SynchronousQueues must block threads waiting to become
                     fulfilled.
                  3. Support for cancellation via timeout and interrupts,
                     including cleaning out cancelled nodesthreads
                     from lists to avoid garbage retention and memory depletion.
                
                 Blocking is mainly accomplished using LockSupport parkunpark,
                 except that nodes that appear to be the next ones to become
                 fulfilled first spin a bit (on multiprocessors only). On very
                 busy synchronous queues, spinning can dramatically improve
                 throughput. And on less busy ones, the amount of spinning is
                 small enough not to be noticeable.
                
                 Cleaning is done in different ways in queues vs stacks.  For
                 queues, we can almost always remove a node immediately in O(1)
                 time (modulo retries for consistency checks) when it is
                 cancelled. But if it may be pinned as the current tail, it must
                 wait until some subsequent cancellation. For stacks, we need a
                 potentially O(n) traversal to be sure that we can remove the
                 node, but this can run concurrently with other threads
                 accessing the stack.
                
                 While garbage collection takes care of most node reclamation
                 issues that otherwise complicate nonblocking algorithms, care
                 is taken to &quot;forget&quot; references to data, other nodes, and
                 threads that might be held on to long-term by blocked
                 threads. In cases where setting to null would otherwise
                 conflict with main algorithms, this is done by changing a
                 node&apos;s link to now point to the node itself. This doesn&apos;t arise
                 much for Stack nodes (because blocked threads do not hang on to
                 old head pointers), but references in Queue nodes must be
                 aggressively forgotten to avoid reachability of everything any
                 node has ever referred to since arrival.                
            </comment>
            <comment line="1135">
                To cope with serialization strategy in the 1.5 version of
                 SynchronousQueue, we declare some unused classes and fields
                 that exist solely to enable serializability across versions.
                 These fields are never used, so are initialized only if this
                 object is ever serialized or deserialized.                
            </comment>
            <comment line="1184">
                Unsafe mechanics                
            </comment>
            <implements interface="BlockingQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </implements>
            <implements interface="java.io.Serializable"/>
            <javadoc line="42">
                A {@linkplain BlockingQueue blocking queue} in which each insert
                  operation must wait for a corresponding remove operation by another
                  thread, and vice versa.  A synchronous queue does not have any
                  internal capacity, not even a capacity of one.  You cannot
                  &lt;tt&gt;peek&lt;/tt&gt; at a synchronous queue because an element is only
                  present when you try to remove it; you cannot insert an element
                  (using any method) unless another thread is trying to remove it;
                  you cannot iterate as there is nothing to iterate.  The
                  &lt;em&gt;head&lt;/em&gt; of the queue is the element that the first queued
                  inserting thread is trying to add to the queue; if there is no such
                  queued thread then no element is available for removal and
                  &lt;tt&gt;poll()&lt;/tt&gt; will return &lt;tt&gt;null&lt;/tt&gt;.  For purposes of other
                  &lt;tt&gt;Collection&lt;/tt&gt; methods (for example &lt;tt&gt;contains&lt;/tt&gt;), a
                  &lt;tt&gt;SynchronousQueue&lt;/tt&gt; acts as an empty collection.  This queue
                  does not permit &lt;tt&gt;null&lt;/tt&gt; elements.
                  &lt;p&gt;Synchronous queues are similar to rendezvous channels used in
                  CSP and Ada. They are well suited for handoff designs, in which an
                  object running in one thread must sync up with an object running
                  in another thread in order to hand it some information, event, or
                  task.
                  &lt;p&gt; This class supports an optional fairness policy for ordering
                  waiting producer and consumer threads.  By default, this ordering
                  is not guaranteed. However, a queue constructed with fairness set
                  to &lt;tt&gt;true&lt;/tt&gt; grants threads access in FIFO order.
                  &lt;p&gt;This class and its iterator implement all of the
                  &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link Iterator} interfaces.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea and Bill Scherer and Michael Scott                    
                </author>
                <param>
                    &lt;E&gt;
                       the type of elements held in this collection                    
                </param>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="84"/>
            <class name="Transferer" line="163">
                <comment line="211">
                    This extends Scherer-Scott dual stack algorithm, differing,
                     among other ways, by using &quot;covering&quot; nodes rather than
                     bit-marked pointers: Fulfilling operations push on marker
                     nodes (with FULFILLING bit set in mode) to reserve a spot
                     to match a waiting node.                    
                </comment>
                <comment line="219">
                                        
                </comment>
                <comment line="511">
                    Unsafe mechanics                    
                </comment>
                <comment line="528">
                    This extends Scherer-Scott dual queue algorithm, differing,
                     among other ways, by using modes within nodes rather than
                     marked pointers. The algorithm is a little simpler than
                     that for stacks because fulfillers do not need explicit
                     nodes, and matching is done by CAS&apos;ing QNode.item field
                     from non-null to null (for put) or vice versa (for take).                    
                </comment>
                <javadoc line="163">
                    Shared internal API for dual stacks and queues.                    
                </javadoc>
                <method name="transfer" type="Object" line="167"/>
                <javadoc line="167">
                    Performs a put or take.                    
                    <param>
                        e if non-null, the item to be handed to a consumer;
                          if null, requests that transfer return an item
                          offered by producer.                        
                    </param>
                    <param>
                        timed if this operation should timeout                        
                    </param>
                    <param>
                        nanos the timeout, in nanoseconds                        
                    </param>
                    <return>
                        if non-null, the item provided or received; if null,
                          the operation failed due to timeout or interrupt --
                          the caller can distinguish which of these occurred
                          by checking Thread.interrupted.                        
                    </return>
                </javadoc>
            </class>
            <declaration name="NCPUS" type="int" line="183"/>
            <javadoc line="183">
                The number of CPUs, for spin control                
            </javadoc>
            <declaration name="maxTimedSpins" type="int" line="186"/>
            <javadoc line="186">
                The number of times to spin before blocking in timed waits.
                  The value is empirically derived -- it works well across a
                  variety of processors and OSes. Empirically, the best value
                  seems not to vary with number of CPUs (beyond 2) so is just
                  a constant.                
            </javadoc>
            <declaration name="maxUntimedSpins" type="int" line="195"/>
            <javadoc line="195">
                The number of times to spin before blocking in untimed waits.
                  This is greater than timed value because untimed waits spin
                  faster since they don&apos;t need to check times on each spin.                
            </javadoc>
            <declaration name="spinForTimeoutThreshold" type="long" line="202"/>
            <javadoc line="202">
                The number of nanoseconds for which it is faster to spin
                  rather than to use timed park. A rough estimate suffices.                
            </javadoc>
            <class name="TransferStack" line="208">
                <extends class="Transferer"/>
                <comment line="211">
                    This extends Scherer-Scott dual stack algorithm, differing,
                     among other ways, by using &quot;covering&quot; nodes rather than
                     bit-marked pointers: Fulfilling operations push on marker
                     nodes (with FULFILLING bit set in mode) to reserve a spot
                     to match a waiting node.                    
                </comment>
                <comment line="219">
                                        
                </comment>
                <comment line="511">
                    Unsafe mechanics                    
                </comment>
                <comment line="528">
                    This extends Scherer-Scott dual queue algorithm, differing,
                     among other ways, by using modes within nodes rather than
                     marked pointers. The algorithm is a little simpler than
                     that for stacks because fulfillers do not need explicit
                     nodes, and matching is done by CAS&apos;ing QNode.item field
                     from non-null to null (for put) or vice versa (for take).                    
                </comment>
                <javadoc line="208">
                    Dual stack                    
                </javadoc>
                <declaration name="REQUEST" type="int" line="219"/>
                <javadoc line="219">
                    Node represents an unfulfilled consumer                    
                </javadoc>
                <declaration name="DATA" type="int" line="221"/>
                <javadoc line="221">
                    Node represents an unfulfilled producer                    
                </javadoc>
                <declaration name="FULFILLING" type="int" line="223"/>
                <javadoc line="223">
                    Node is fulfilling another unfulfilled DATA or REQUEST                    
                </javadoc>
                <javadoc line="226">
                    Return true if m has fulfilling bit set                    
                </javadoc>
                <method name="isFulfilling" type="boolean" line="227">
                    <params>
                        <param name="m" type="int"/>
                    </params>
                </method>
                <class name="SNode" line="229">
                    <comment line="232">
                        next node in stack                        
                    </comment>
                    <comment line="233">
                        the node matched to this                        
                    </comment>
                    <comment line="234">
                        to control park/unpark                        
                    </comment>
                    <comment line="235">
                        data; or null for REQUESTs                        
                    </comment>
                    <comment line="237">
                        Note: item and mode fields don&apos;t need to be volatile
                         since they are always written before, and read after,
                         other volatile/atomic operations.                        
                    </comment>
                    <comment line="282">
                        Unsafe mechanics                        
                    </comment>
                    <javadoc line="229">
                        Node class for TransferStacks.                        
                    </javadoc>
                    <declaration name="next" type="SNode" line="231"/>
                    <declaration name="match" type="SNode" line="232"/>
                    <declaration name="waiter" type="Thread" line="233"/>
                    <declaration name="item" type="Object" line="234"/>
                    <declaration name="mode" type="int" line="235"/>
                    <method name="SNode" type="constructor" line="240">
                        <params>
                            <param name="item" type="Object"/>
                        </params>
                    </method>
                    <method name="casNext" type="boolean" line="244">
                        <params>
                            <param name="cmp" type="SNode"/>
                            <param name="val" type="SNode"/>
                        </params>
                    </method>
                    <javadoc line="249">
                        Tries to match node s to this node, if so, waking up thread.
                          Fulfillers call tryMatch to identify their waiters.
                          Waiters block until they have been matched.                        
                        <param>
                            s the node to match                            
                        </param>
                        <return>
                            true if successfully matched to s                            
                        </return>
                    </javadoc>
                    <method name="tryMatch" type="boolean" line="257">
                        <params>
                            <param name="s" type="SNode"/>
                        </params>
                        <comment line="262">
                            waiters need at most one unpark                            
                        </comment>
                        <scope line="259">
                            <declaration name="w" type="Thread" line="260"/>
                            <scope line="261"/>
                        </scope>
                    </method>
                    <javadoc line="270">
                        Tries to cancel a wait by matching node to itself.                        
                    </javadoc>
                    <method name="tryCancel" type="void" line="273"/>
                    <method name="isCancelled" type="boolean" line="277"/>
                    <declaration name="UNSAFE" type="sun.misc.Unsafe" line="282"/>
                    <declaration name="matchOffset" type="long" line="283"/>
                    <declaration name="nextOffset" type="long" line="284"/>
                    <scope line="286">
                        <scope line="287">
                            <declaration name="k" type="Class" line="289"/>
                        </scope>
                        <scope line="294"/>
                    </scope>
                </class>
                <declaration name="head" type="SNode" line="300"/>
                <javadoc line="300">
                    The head (top) of the stack                    
                </javadoc>
                <method name="casHead" type="boolean" line="303">
                    <params>
                        <param name="h" type="SNode"/>
                        <param name="nh" type="SNode"/>
                    </params>
                </method>
                <javadoc line="308">
                    Creates or resets fields of a node. Called only from transfer
                      where the node to push on stack is lazily created and
                      reused when possible to help reduce intervals between reads
                      and CASes of head and to avoid surges of garbage when CASes
                      to push nodes fail due to contention.                    
                </javadoc>
                <method name="snode" type="SNode" line="315">
                    <params>
                        <param name="s" type="SNode"/>
                        <param name="e" type="Object"/>
                        <param name="next" type="SNode"/>
                        <param name="mode" type="int"/>
                    </params>
                </method>
                <javadoc line="322">
                    Puts or takes an item.                    
                </javadoc>
                <method name="transfer" type="Object" line="325">
                    <params>
                        <param name="e" type="Object"/>
                        <param name="timed" type="boolean"/>
                        <param name="nanos" type="long"/>
                    </params>
                    <comment line="327">
                        Basic algorithm is to loop trying one of three actions:
                        
                         1. If apparently empty or already containing nodes of same
                            mode, try to push node on stack and wait for a match,
                            returning it, or null if cancelled.
                        
                         2. If apparently containing node of complementary mode,
                            try to push a fulfilling node on to stack, match
                            with corresponding waiting node, pop both from
                            stack, and return matched item. The matching or
                            unlinking might not actually be necessary because of
                            other threads performing action 3:
                        
                         3. If top of stack already holds another fulfilling node,
                            help it out by doing its match andor pop
                            operations, and then continue. The code for helping
                            is essentially the same as for fulfilling, except
                            that it doesn&apos;t return the item.                        
                    </comment>
                    <comment line="348">
                        constructed/reused as needed                        
                    </comment>
                    <comment line="353">
                        empty or same-mode                        
                    </comment>
                    <comment line="354">
                        can&apos;t wait                        
                    </comment>
                    <comment line="356">
                        pop cancelled node                        
                    </comment>
                    <comment line="361">
                        wait was cancelled                        
                    </comment>
                    <comment line="366">
                        help s&apos;s fulfiller                        
                    </comment>
                    <comment line="369">
                        try to fulfill                        
                    </comment>
                    <comment line="370">
                        already cancelled                        
                    </comment>
                    <comment line="371">
                        pop and retry                        
                    </comment>
                    <comment line="373">
                        loop until matched or waiters disappear                        
                    </comment>
                    <comment line="374">
                        m is s&apos;s match                        
                    </comment>
                    <comment line="375">
                        all waiters are gone                        
                    </comment>
                    <comment line="376">
                        pop fulfill node                        
                    </comment>
                    <comment line="377">
                        use new node next time                        
                    </comment>
                    <comment line="378">
                        restart main loop                        
                    </comment>
                    <comment line="382">
                        pop both s and m                        
                    </comment>
                    <comment line="384">
                        lost match                        
                    </comment>
                    <comment line="385">
                        help unlink                        
                    </comment>
                    <comment line="388">
                        help a fulfiller                        
                    </comment>
                    <comment line="389">
                        m is h&apos;s match                        
                    </comment>
                    <comment line="390">
                        waiter is gone                        
                    </comment>
                    <comment line="391">
                        pop fulfilling node                        
                    </comment>
                    <comment line="394">
                        help match                        
                    </comment>
                    <comment line="395">
                        pop both h and m                        
                    </comment>
                    <comment line="396">
                        lost match                        
                    </comment>
                    <comment line="397">
                        help unlink                        
                    </comment>
                    <declaration name="s" type="SNode" line="347"/>
                    <declaration name="mode" type="int" line="348"/>
                    <scope line="350">
                        <declaration name="h" type="SNode" line="351"/>
                        <scope line="352">
                            <scope line="353"/>
                            <scope line="358">
                                <declaration name="m" type="SNode" line="359"/>
                                <scope line="360"/>
                            </scope>
                        </scope>
                        <scope line="368">
                            <scope line="371">
                                <scope line="372">
                                    <declaration name="m" type="SNode" line="373"/>
                                    <scope line="374"/>
                                    <declaration name="mn" type="SNode" line="379"/>
                                    <scope line="380"/>
                                </scope>
                            </scope>
                        </scope>
                        <scope line="387">
                            <declaration name="m" type="SNode" line="388"/>
                            <scope line="391">
                                <declaration name="mn" type="SNode" line="392"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
                <javadoc line="402">
                    Spins/blocks until node s is matched by a fulfill operation.                    
                    <param>
                        s the waiting node                        
                    </param>
                    <param>
                        timed true if timed wait                        
                    </param>
                    <param>
                        nanos timeout value                        
                    </param>
                    <return>
                        matched node, or s if cancelled                        
                    </return>
                </javadoc>
                <method name="awaitFulfill" type="SNode" line="410">
                    <params>
                        <param name="s" type="SNode"/>
                        <param name="timed" type="boolean"/>
                        <param name="nanos" type="long"/>
                    </params>
                    <comment line="412">
                        When a nodethread is about to block, it sets its waiter
                         field and then rechecks state at least one more time
                         before actually parking, thus covering race vs
                         fulfiller noticing that waiter is non-null so should be
                         woken.
                        
                         When invoked by nodes that appear at the point of call
                         to be at the head of the stack, calls to park are
                         preceded by spins to avoid blocking when producers and
                         consumers are arriving very close in time.  This can
                         happen enough to bother only on multiprocessors.
                        
                         The order of checks for returning out of main loop
                         reflects fact that interrupts have precedence over
                         normal returns, which have precedence over
                         timeouts. (So, on timeout, one last check for match is
                         done before giving up.) Except that calls from untimed
                         SynchronousQueue.{polloffer} don&apos;t check interrupts
                         and don&apos;t wait at all, so are trapped in transfer
                         method rather than calling awaitFulfill.                        
                    </comment>
                    <comment line="457">
                        establish waiter so can park next iter                        
                    </comment>
                    <declaration name="lastTime" type="long" line="433"/>
                    <declaration name="w" type="Thread" line="434"/>
                    <declaration name="h" type="SNode" line="435"/>
                    <declaration name="spins" type="int" line="436"/>
                    <scope line="438">
                        <declaration name="m" type="SNode" line="441"/>
                        <scope line="444">
                            <declaration name="now" type="long" line="445"/>
                            <scope line="448"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="464">
                    Returns true if node s is at head or there is an active
                      fulfiller.                    
                </javadoc>
                <method name="shouldSpin" type="boolean" line="468">
                    <params>
                        <param name="s" type="SNode"/>
                    </params>
                    <declaration name="h" type="SNode" line="469"/>
                </method>
                <javadoc line="473">
                    Unlinks s from the stack.                    
                </javadoc>
                <method name="clean" type="void" line="476">
                    <params>
                        <param name="s" type="SNode"/>
                    </params>
                    <comment line="478">
                        forget item                        
                    </comment>
                    <comment line="479">
                        forget thread                        
                    </comment>
                    <comment line="481">
                        At worst we may need to traverse entire stack to unlink
                         s. If there are multiple concurrent calls to clean, we
                         might not see s if another thread has already removed
                         it. But we can stop when we see any node known to
                         follow s. We use s.next unless it too is cancelled, in
                         which case we try the node one past. We don&apos;t check any
                         further because we don&apos;t want to doubly traverse just to
                         find sentinel.                        
                    </comment>
                    <comment line="496">
                        Absorb cancelled nodes at head                        
                    </comment>
                    <comment line="501">
                        Unsplice embedded nodes                        
                    </comment>
                    <declaration name="past" type="SNode" line="491"/>
                    <declaration name="p" type="SNode" line="496"/>
                    <scope line="501">
                        <declaration name="n" type="SNode" line="502"/>
                    </scope>
                </method>
                <declaration name="UNSAFE" type="sun.misc.Unsafe" line="511"/>
                <declaration name="headOffset" type="long" line="512"/>
                <scope line="513">
                    <scope line="514">
                        <declaration name="k" type="Class" line="516"/>
                    </scope>
                    <scope line="519"/>
                </scope>
            </class>
            <class name="TransferQueue" line="525">
                <extends class="Transferer"/>
                <comment line="211">
                    This extends Scherer-Scott dual stack algorithm, differing,
                     among other ways, by using &quot;covering&quot; nodes rather than
                     bit-marked pointers: Fulfilling operations push on marker
                     nodes (with FULFILLING bit set in mode) to reserve a spot
                     to match a waiting node.                    
                </comment>
                <comment line="219">
                                        
                </comment>
                <comment line="511">
                    Unsafe mechanics                    
                </comment>
                <comment line="528">
                    This extends Scherer-Scott dual queue algorithm, differing,
                     among other ways, by using modes within nodes rather than
                     marked pointers. The algorithm is a little simpler than
                     that for stacks because fulfillers do not need explicit
                     nodes, and matching is done by CAS&apos;ing QNode.item field
                     from non-null to null (for put) or vice versa (for take).                    
                </comment>
                <javadoc line="525">
                    Dual Queue                    
                </javadoc>
                <class name="QNode" line="536">
                    <comment line="539">
                        next node in queue                        
                    </comment>
                    <comment line="540">
                        CAS&apos;ed to or from null                        
                    </comment>
                    <comment line="541">
                        to control park/unpark                        
                    </comment>
                    <comment line="579">
                        Unsafe mechanics                        
                    </comment>
                    <javadoc line="536">
                        Node class for TransferQueue.                        
                    </javadoc>
                    <declaration name="next" type="QNode" line="538"/>
                    <declaration name="item" type="Object" line="539"/>
                    <declaration name="waiter" type="Thread" line="540"/>
                    <declaration name="isData" type="boolean" line="541"/>
                    <method name="QNode" type="constructor" line="543">
                        <params>
                            <param name="item" type="Object"/>
                            <param name="isData" type="boolean"/>
                        </params>
                    </method>
                    <method name="casNext" type="boolean" line="548">
                        <params>
                            <param name="cmp" type="QNode"/>
                            <param name="val" type="QNode"/>
                        </params>
                    </method>
                    <method name="casItem" type="boolean" line="553">
                        <params>
                            <param name="cmp" type="Object"/>
                            <param name="val" type="Object"/>
                        </params>
                    </method>
                    <javadoc line="558">
                        Tries to cancel by CAS&apos;ing ref to this as item.                        
                    </javadoc>
                    <method name="tryCancel" type="void" line="561">
                        <params>
                            <param name="cmp" type="Object"/>
                        </params>
                    </method>
                    <method name="isCancelled" type="boolean" line="565"/>
                    <javadoc line="569">
                        Returns true if this node is known to be off the queue
                          because its next pointer has been forgotten due to
                          an advanceHead operation.                        
                    </javadoc>
                    <method name="isOffList" type="boolean" line="574"/>
                    <declaration name="UNSAFE" type="sun.misc.Unsafe" line="579"/>
                    <declaration name="itemOffset" type="long" line="580"/>
                    <declaration name="nextOffset" type="long" line="581"/>
                    <scope line="583">
                        <scope line="584">
                            <declaration name="k" type="Class" line="586"/>
                        </scope>
                        <scope line="591"/>
                    </scope>
                </class>
                <declaration name="head" type="QNode" line="597"/>
                <javadoc line="597">
                    Head of queue                    
                </javadoc>
                <declaration name="tail" type="QNode" line="599"/>
                <javadoc line="599">
                    Tail of queue                    
                </javadoc>
                <declaration name="cleanMe" type="QNode" line="601"/>
                <javadoc line="601">
                    Reference to a cancelled node that might not yet have been
                      unlinked from queue because it was the last inserted node
                      when it cancelled.                    
                </javadoc>
                <method name="TransferQueue" type="constructor" line="608">
                    <comment line="610">
                        initialize to dummy node.                        
                    </comment>
                    <declaration name="h" type="QNode" line="609"/>
                </method>
                <javadoc line="614">
                    Tries to cas nh as new head; if successful, unlink
                      old head&apos;s next node to avoid garbage retention.                    
                </javadoc>
                <method name="advanceHead" type="void" line="618">
                    <params>
                        <param name="h" type="QNode"/>
                        <param name="nh" type="QNode"/>
                    </params>
                    <comment line="622">
                        forget old next                        
                    </comment>
                </method>
                <javadoc line="624">
                    Tries to cas nt as new tail.                    
                </javadoc>
                <method name="advanceTail" type="void" line="627">
                    <params>
                        <param name="t" type="QNode"/>
                        <param name="nt" type="QNode"/>
                    </params>
                </method>
                <javadoc line="632">
                    Tries to CAS cleanMe slot.                    
                </javadoc>
                <method name="casCleanMe" type="boolean" line="635">
                    <params>
                        <param name="cmp" type="QNode"/>
                        <param name="val" type="QNode"/>
                    </params>
                </method>
                <javadoc line="640">
                    Puts or takes an item.                    
                </javadoc>
                <method name="transfer" type="Object" line="643">
                    <params>
                        <param name="e" type="Object"/>
                        <param name="timed" type="boolean"/>
                        <param name="nanos" type="long"/>
                    </params>
                    <comment line="645">
                        Basic algorithm is to loop trying to take either of
                         two actions:
                        
                         1. If queue apparently empty or holding same-mode nodes,
                            try to add node to queue of waiters, wait to be
                            fulfilled (or cancelled) and return matching item.
                        
                         2. If queue apparently contains waiting items, and this
                            call is of complementary mode, try to fulfill by CAS&apos;ing
                            item field of waiting node and dequeuing it, and then
                            returning matching item.
                        
                         In each case, along the way, check for and try to help
                         advance head and tail on behalf of other stalledslow
                         threads.
                        
                         The loop starts off with a null check guarding against
                         seeing uninitialized head or tail values. This never
                         happens in current SynchronousQueue, but could if
                         callers held non-volatilefinal ref to the
                         transferer. The check is here anyway because it places
                         null checks at top of loop, which is usually faster
                         than having them implicitly interspersed.                        
                    </comment>
                    <comment line="670">
                        constructed/reused as needed                        
                    </comment>
                    <comment line="676">
                        saw uninitialized value                        
                    </comment>
                    <comment line="677">
                        spin                        
                    </comment>
                    <comment line="679">
                        empty or same-mode                        
                    </comment>
                    <comment line="681">
                        inconsistent read                        
                    </comment>
                    <comment line="683">
                        lagging tail                        
                    </comment>
                    <comment line="687">
                        can&apos;t wait                        
                    </comment>
                    <comment line="691">
                        failed to link in                        
                    </comment>
                    <comment line="694">
                        swing tail and wait                        
                    </comment>
                    <comment line="696">
                        wait was cancelled                        
                    </comment>
                    <comment line="701">
                        not already unlinked                        
                    </comment>
                    <comment line="702">
                        unlink if head                        
                    </comment>
                    <comment line="703">
                        and forget fields                        
                    </comment>
                    <comment line="709">
                        complementary-mode                        
                    </comment>
                    <comment line="710">
                        node to fulfill                        
                    </comment>
                    <comment line="712">
                        inconsistent read                        
                    </comment>
                    <comment line="715">
                        m already fulfilled                        
                    </comment>
                    <comment line="716">
                        m cancelled                        
                    </comment>
                    <comment line="717">
                        lost CAS                        
                    </comment>
                    <comment line="718">
                        dequeue and retry                        
                    </comment>
                    <comment line="722">
                        successfully fulfilled                        
                    </comment>
                    <declaration name="s" type="QNode" line="669"/>
                    <declaration name="isData" type="boolean" line="670"/>
                    <scope line="672">
                        <declaration name="t" type="QNode" line="673"/>
                        <declaration name="h" type="QNode" line="674"/>
                        <scope line="678">
                            <declaration name="tn" type="QNode" line="679"/>
                            <scope line="682"/>
                            <declaration name="x" type="Object" line="694"/>
                            <scope line="695"/>
                            <scope line="700"/>
                        </scope>
                        <scope line="708">
                            <declaration name="m" type="QNode" line="709"/>
                            <declaration name="x" type="Object" line="713"/>
                            <scope line="716"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="728">
                    Spins/blocks until node s is fulfilled.                    
                    <param>
                        s the waiting node                        
                    </param>
                    <param>
                        e the comparison value for checking match                        
                    </param>
                    <param>
                        timed true if timed wait                        
                    </param>
                    <param>
                        nanos timeout value                        
                    </param>
                    <return>
                        matched item, or s if cancelled                        
                    </return>
                </javadoc>
                <method name="awaitFulfill" type="Object" line="737">
                    <params>
                        <param name="s" type="QNode"/>
                        <param name="e" type="Object"/>
                        <param name="timed" type="boolean"/>
                        <param name="nanos" type="long"/>
                    </params>
                    <comment line="739">
                                                
                    </comment>
                    <declaration name="lastTime" type="long" line="739"/>
                    <declaration name="w" type="Thread" line="740"/>
                    <declaration name="spins" type="int" line="741"/>
                    <scope line="743">
                        <declaration name="x" type="Object" line="746"/>
                        <scope line="749">
                            <declaration name="now" type="long" line="750"/>
                            <scope line="753"/>
                        </scope>
                    </scope>
                </method>
                <javadoc line="769">
                    Gets rid of cancelled node s with original predecessor pred.                    
                </javadoc>
                <method name="clean" type="void" line="772">
                    <params>
                        <param name="pred" type="QNode"/>
                        <param name="s" type="QNode"/>
                    </params>
                    <comment line="774">
                        forget thread                        
                    </comment>
                    <comment line="775">
                        At any given time, exactly one node on list cannot be
                         deleted -- the last inserted node. To accommodate this,
                         if we cannot delete s, we save its predecessor as
                         &quot;cleanMe&quot;, deleting the previously saved version
                         first. At least one of node s or the node previously
                         saved can always be deleted, so this always terminates.                        
                    </comment>
                    <comment line="783">
                        Return early if already unlinked                        
                    </comment>
                    <comment line="785">
                        Absorb cancelled first node as head                        
                    </comment>
                    <comment line="790">
                        Ensure consistent read for tail                        
                    </comment>
                    <comment line="800">
                        If not tail, try to unsplice                        
                    </comment>
                    <comment line="806">
                        Try unlinking previous cancelled node                        
                    </comment>
                    <comment line="809">
                        d is gone or                        
                    </comment>
                    <comment line="810">
                        d is off list or                        
                    </comment>
                    <comment line="811">
                        d not cancelled or                        
                    </comment>
                    <comment line="812">
                        d not tail and                        
                    </comment>
                    <comment line="813">
                        has successor                        
                    </comment>
                    <comment line="814">
                        that is on list                        
                    </comment>
                    <comment line="815">
                        d unspliced                        
                    </comment>
                    <comment line="818">
                        s is already saved node                        
                    </comment>
                    <comment line="820">
                        Postpone cleaning s                        
                    </comment>
                    <scope line="782">
                        <declaration name="h" type="QNode" line="783"/>
                        <declaration name="hn" type="QNode" line="784"/>
                        <scope line="785"/>
                        <declaration name="t" type="QNode" line="789"/>
                        <declaration name="tn" type="QNode" line="792"/>
                        <scope line="795"/>
                        <scope line="799">
                            <declaration name="sn" type="QNode" line="800"/>
                        </scope>
                        <declaration name="dp" type="QNode" line="804"/>
                        <scope line="805">
                            <declaration name="d" type="QNode" line="806"/>
                            <declaration name="dn" type="QNode" line="807"/>
                        </scope>
                    </scope>
                </method>
                <declaration name="UNSAFE" type="sun.misc.Unsafe" line="823"/>
                <declaration name="headOffset" type="long" line="824"/>
                <declaration name="tailOffset" type="long" line="825"/>
                <declaration name="cleanMeOffset" type="long" line="826"/>
                <scope line="827">
                    <scope line="828">
                        <declaration name="k" type="Class" line="830"/>
                    </scope>
                    <scope line="837"/>
                </scope>
            </class>
            <declaration name="transferer" type="Transferer" line="843"/>
            <javadoc line="843">
                The transferer. Set only in constructor, but cannot be declared
                  as final without further complicating serialization.  Since
                  this is accessed only at most once per public method, there
                  isn&apos;t a noticeable performance penalty for using volatile
                  instead of final here.                
            </javadoc>
            <javadoc line="852">
                Creates a &lt;tt&gt;SynchronousQueue&lt;/tt&gt; with nonfair access policy.                
            </javadoc>
            <method name="SynchronousQueue" type="constructor" line="855"/>
            <javadoc line="859">
                Creates a &lt;tt&gt;SynchronousQueue&lt;/tt&gt; with the specified fairness policy.                
                <param>
                    fair if true, waiting threads contend in FIFO order for
                      access; otherwise the order is unspecified.                    
                </param>
            </javadoc>
            <method name="SynchronousQueue" type="constructor" line="865">
                <params>
                    <param name="fair" type="boolean"/>
                </params>
            </method>
            <javadoc line="869">
                Adds the specified element to this queue, waiting if necessary for
                  another thread to receive it.                
                <throws>
                    InterruptedException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="put" type="void" line="876">
                <params>
                    <param name="o" type="E"/>
                </params>
                <scope line="878"/>
            </method>
            <javadoc line="884">
                Inserts the specified element into this queue, waiting if necessary
                  up to the specified wait time for another thread to receive it.                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if successful, or &lt;tt&gt;false&lt;/tt&gt; if the
                      specified waiting time elapses before a consumer appears.                    
                </return>
                <throws>
                    InterruptedException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="894">
                <params>
                    <param name="o" type="E"/>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
            </method>
            <javadoc line="903">
                Inserts the specified element into this queue, if another thread is
                  waiting to receive it.                
                <param>
                    e the element to add                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if the element was added to this queue, else
                      &lt;tt&gt;false&lt;/tt&gt;                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="912">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="917">
                Retrieves and removes the head of this queue, waiting if necessary
                  for another thread to insert it.                
                <return>
                    the head of this queue                    
                </return>
                <throws>
                    InterruptedException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="take" type="E" line="924">
                <declaration name="e" type="Object" line="925"/>
            </method>
            <javadoc line="932">
                Retrieves and removes the head of this queue, waiting
                  if necessary up to the specified wait time, for another thread
                  to insert it.                
                <return>
                    the head of this queue, or &lt;tt&gt;null&lt;/tt&gt; if the
                      specified waiting time elapses before an element is present.                    
                </return>
                <throws>
                    InterruptedException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="poll" type="E" line="941">
                <params>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="e" type="Object" line="942"/>
            </method>
            <javadoc line="948">
                Retrieves and removes the head of this queue, if another thread
                  is currently making an element available.                
                <return>
                    the head of this queue, or &lt;tt&gt;null&lt;/tt&gt; if no
                      element is available.                    
                </return>
            </javadoc>
            <method name="poll" type="E" line="955"/>
            <javadoc line="959">
                Always returns &lt;tt&gt;true&lt;/tt&gt;.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt;                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="965"/>
            <javadoc line="969">
                Always returns zero.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.                
                <return>
                    zero.                    
                </return>
            </javadoc>
            <method name="size" type="int" line="975"/>
            <javadoc line="979">
                Always returns zero.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.                
                <return>
                    zero.                    
                </return>
            </javadoc>
            <method name="remainingCapacity" type="int" line="985"/>
            <javadoc line="989">
                Does nothing.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.                
            </javadoc>
            <method name="clear" type="void" line="993"/>
            <javadoc line="996">
                Always returns &lt;tt&gt;false&lt;/tt&gt;.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.                
                <param>
                    o the element                    
                </param>
                <return>
                    &lt;tt&gt;false&lt;/tt&gt;                    
                </return>
            </javadoc>
            <method name="contains" type="boolean" line="1003">
                <params>
                    <param name="o" type="Object"/>
                </params>
            </method>
            <javadoc line="1007">
                Always returns &lt;tt&gt;false&lt;/tt&gt;.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.                
                <param>
                    o the element to remove                    
                </param>
                <return>
                    &lt;tt&gt;false&lt;/tt&gt;                    
                </return>
            </javadoc>
            <method name="remove" type="boolean" line="1014">
                <params>
                    <param name="o" type="Object"/>
                </params>
            </method>
            <javadoc line="1018">
                Returns &lt;tt&gt;false&lt;/tt&gt; unless the given collection is empty.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.                
                <param>
                    c the collection                    
                </param>
                <return>
                    &lt;tt&gt;false&lt;/tt&gt; unless given collection is empty                    
                </return>
            </javadoc>
            <method name="containsAll" type="boolean" line="1025">
                <params>
                    <param name="c" type="Collection<?>"/>
                </params>
            </method>
            <javadoc line="1029">
                Always returns &lt;tt&gt;false&lt;/tt&gt;.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.                
                <param>
                    c the collection                    
                </param>
                <return>
                    &lt;tt&gt;false&lt;/tt&gt;                    
                </return>
            </javadoc>
            <method name="removeAll" type="boolean" line="1036">
                <params>
                    <param name="c" type="Collection<?>"/>
                </params>
            </method>
            <javadoc line="1040">
                Always returns &lt;tt&gt;false&lt;/tt&gt;.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.                
                <param>
                    c the collection                    
                </param>
                <return>
                    &lt;tt&gt;false&lt;/tt&gt;                    
                </return>
            </javadoc>
            <method name="retainAll" type="boolean" line="1047">
                <params>
                    <param name="c" type="Collection<?>"/>
                </params>
            </method>
            <javadoc line="1051">
                Always returns &lt;tt&gt;null&lt;/tt&gt;.
                  A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; does not return elements
                  unless actively waited on.                
                <return>
                    &lt;tt&gt;null&lt;/tt&gt;                    
                </return>
            </javadoc>
            <method name="peek" type="E" line="1058"/>
            <javadoc line="1062">
                Returns an empty iterator in which &lt;tt&gt;hasNext&lt;/tt&gt; always returns
                  &lt;tt&gt;false&lt;/tt&gt;.                
                <return>
                    an empty iterator                    
                </return>
            </javadoc>
            <method name="iterator" type="Iterator<E>" line="1068"/>
            <javadoc line="1072">
                Returns a zero-length array.                
                <return>
                    a zero-length array                    
                </return>
            </javadoc>
            <method name="toArray" type="Object[]" line="1076"/>
            <javadoc line="1080">
                Sets the zeroeth element of the specified array to &lt;tt&gt;null&lt;/tt&gt;
                  (if the array has non-zero length) and returns it.                
                <param>
                    a the array                    
                </param>
                <return>
                    the specified array                    
                </return>
                <throws>
                    NullPointerException if the specified array is null                    
                </throws>
            </javadoc>
            <method name="toArray" type="T[]" line="1088">
                <params>
                    <param name="a" type="T[]"/>
                </params>
            </method>
            <javadoc line="1094">
                @throws UnsupportedOperationException {@inheritDoc}                
                <throws>
                    ClassCastException            {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException          {@inheritDoc}                    
                </throws>
                <throws>
                    IllegalArgumentException      {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="drainTo" type="int" line="1100">
                <params>
                    <param name="c" type="Collection<? super E>"/>
                </params>
                <declaration name="n" type="int" line="1105"/>
                <declaration name="e" type="E" line="1106"/>
                <scope line="1107"/>
            </method>
            <javadoc line="1114">
                @throws UnsupportedOperationException {@inheritDoc}                
                <throws>
                    ClassCastException            {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException          {@inheritDoc}                    
                </throws>
                <throws>
                    IllegalArgumentException      {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="drainTo" type="int" line="1120">
                <params>
                    <param name="c" type="Collection<? super E>"/>
                    <param name="maxElements" type="int"/>
                </params>
                <declaration name="n" type="int" line="1125"/>
                <declaration name="e" type="E" line="1126"/>
                <scope line="1127"/>
            </method>
            <class name="WaitQueue" line="1142">
                <comment line="211">
                    This extends Scherer-Scott dual stack algorithm, differing,
                     among other ways, by using &quot;covering&quot; nodes rather than
                     bit-marked pointers: Fulfilling operations push on marker
                     nodes (with FULFILLING bit set in mode) to reserve a spot
                     to match a waiting node.                    
                </comment>
                <comment line="219">
                                        
                </comment>
                <comment line="511">
                    Unsafe mechanics                    
                </comment>
                <comment line="528">
                    This extends Scherer-Scott dual queue algorithm, differing,
                     among other ways, by using modes within nodes rather than
                     marked pointers. The algorithm is a little simpler than
                     that for stacks because fulfillers do not need explicit
                     nodes, and matching is done by CAS&apos;ing QNode.item field
                     from non-null to null (for put) or vice versa (for take).                    
                </comment>
                <implements interface="java.io.Serializable"/>
            </class>
            <class name="LifoWaitQueue" line="1143">
                <extends class="WaitQueue"/>
                <comment line="211">
                    This extends Scherer-Scott dual stack algorithm, differing,
                     among other ways, by using &quot;covering&quot; nodes rather than
                     bit-marked pointers: Fulfilling operations push on marker
                     nodes (with FULFILLING bit set in mode) to reserve a spot
                     to match a waiting node.                    
                </comment>
                <comment line="219">
                                        
                </comment>
                <comment line="511">
                    Unsafe mechanics                    
                </comment>
                <comment line="528">
                    This extends Scherer-Scott dual queue algorithm, differing,
                     among other ways, by using modes within nodes rather than
                     marked pointers. The algorithm is a little simpler than
                     that for stacks because fulfillers do not need explicit
                     nodes, and matching is done by CAS&apos;ing QNode.item field
                     from non-null to null (for put) or vice versa (for take).                    
                </comment>
                <declaration name="serialVersionUID" type="long" line="1144"/>
            </class>
            <class name="FifoWaitQueue" line="1146">
                <extends class="WaitQueue"/>
                <comment line="211">
                    This extends Scherer-Scott dual stack algorithm, differing,
                     among other ways, by using &quot;covering&quot; nodes rather than
                     bit-marked pointers: Fulfilling operations push on marker
                     nodes (with FULFILLING bit set in mode) to reserve a spot
                     to match a waiting node.                    
                </comment>
                <comment line="219">
                                        
                </comment>
                <comment line="511">
                    Unsafe mechanics                    
                </comment>
                <comment line="528">
                    This extends Scherer-Scott dual queue algorithm, differing,
                     among other ways, by using modes within nodes rather than
                     marked pointers. The algorithm is a little simpler than
                     that for stacks because fulfillers do not need explicit
                     nodes, and matching is done by CAS&apos;ing QNode.item field
                     from non-null to null (for put) or vice versa (for take).                    
                </comment>
                <declaration name="serialVersionUID" type="long" line="1147"/>
            </class>
            <declaration name="qlock" type="ReentrantLock" line="1149"/>
            <declaration name="waitingProducers" type="WaitQueue" line="1150"/>
            <declaration name="waitingConsumers" type="WaitQueue" line="1151"/>
            <javadoc line="1153">
                Save the state to a stream (that is, serialize it).                
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="1159">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <declaration name="fair" type="boolean" line="1160"/>
                <scope line="1161"/>
                <scope line="1166"/>
            </method>
            <method name="readObject" type="void" line="1175">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
            </method>
            <method name="objectFieldOffset" type="long" line="1185">
                <params>
                    <param name="UNSAFE" type="sun.misc.Unsafe"/>
                    <param name="field" type="String"/>
                    <param name="klazz" type="Class<?>"/>
                </params>
                <comment line="1190">
                    Convert Exception to corresponding Error                    
                </comment>
                <scope line="1186"/>
                <scope line="1188">
                    <declaration name="error" type="NoSuchFieldError" line="1190"/>
                </scope>
            </method>
        </class>
    </source>