<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <import package="java.util.concurrent.locks.Condition"/>
        <import package="java.util.concurrent.locks.ReentrantLock"/>
        <import package="java.util.AbstractQueue"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.NoSuchElementException"/>
        <class name="LinkedBlockingQueue" line="9">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="AbstractQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <implements interface="BlockingQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </implements>
            <implements interface="java.io.Serializable"/>
            <javadoc line="9">
                An optionally-bounded {@linkplain BlockingQueue blocking queue} based on
                  linked nodes.
                  This queue orders elements FIFO (first-in-first-out).
                  The &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the
                  queue the longest time.
                  The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has been on the
                  queue the shortest time. New elements
                  are inserted at the tail of the queue, and the queue retrieval
                  operations obtain elements at the head of the queue.
                  Linked queues typically have higher throughput than array-based queues but
                  less predictable performance in most concurrent applications.
                  &lt;p&gt; The optional capacity bound constructor argument serves as a
                  way to prevent excessive queue expansion. The capacity, if unspecified,
                  is equal to {@link Integer#MAX_VALUE}.  Linked nodes are
                  dynamically created upon each insertion unless this would bring the
                  queue above capacity.
                  &lt;p&gt;This class and its iterator implement all of the
                  &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link Iterator} interfaces.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea                    
                </author>
                <param>
                    <E>
                      the type of elements held in this collection                    
                </param>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="37"/>
            <class name="Node" line="38">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <javadoc line="38">
                    Linked list node class                    
                </javadoc>
                <declaration name="item" type="E" line="42"/>
                <declaration name="next" type="Node&lt;E&gt;" line="43"/>
                <javadoc line="43">
                    One of:
                      - the real successor Node
                      - this Node, meaning the successor is head.next
                      - null, meaning there is no successor (this is the last node)                    
                </javadoc>
                <method name="Node" type="constructor" line="50">
                    <params>
                        <param name="x" type="E"/>
                    </params>
                </method>
            </class>
            <declaration name="capacity" type="int" line="54"/>
            <javadoc line="54">
                The capacity bound, or Integer.MAX_VALUE if none                
            </javadoc>
            <declaration name="count" type="AtomicInteger" line="58"/>
            <javadoc line="58">
                Current number of elements                
            </javadoc>
            <declaration name="head" type="Node&lt;E&gt;" line="62"/>
            <javadoc line="62">
                Head of linked list.
                  Invariant: head.item == null                
            </javadoc>
            <declaration name="last" type="Node&lt;E&gt;" line="67"/>
            <javadoc line="67">
                Tail of linked list.
                  Invariant: last.next == null                
            </javadoc>
            <declaration name="takeLock" type="ReentrantLock" line="72"/>
            <javadoc line="72">
                Lock held by take, poll, etc                
            </javadoc>
            <declaration name="notEmpty" type="Condition" line="76"/>
            <javadoc line="76">
                Wait queue for waiting takes                
            </javadoc>
            <declaration name="putLock" type="ReentrantLock" line="80"/>
            <javadoc line="80">
                Lock held by put, offer, etc                
            </javadoc>
            <declaration name="notFull" type="Condition" line="84"/>
            <javadoc line="84">
                Wait queue for waiting puts                
            </javadoc>
            <javadoc line="88">
                Signals a waiting take. Called only from put/offer (which do not
                  otherwise ordinarily lock takeLock.)                
            </javadoc>
            <method name="signalNotEmpty" type="void" line="92">
                <declaration name="takeLock" type="ReentrantLock" line="93"/>
                <scope line="95"/>
                <scope line="98"/>
            </method>
            <javadoc line="102">
                Signals a waiting put. Called only from take/poll.                
            </javadoc>
            <method name="signalNotFull" type="void" line="105">
                <declaration name="putLock" type="ReentrantLock" line="106"/>
                <scope line="108"/>
                <scope line="111"/>
            </method>
            <javadoc line="115">
                Links node at end of queue.                
                <param>
                    node the node                    
                </param>
            </javadoc>
            <method name="enqueue" type="void" line="119">
                <params>
                    <param name="node" type="Node<E>"/>
                </params>
            </method>
            <javadoc line="122">
                Removes a node from head of queue.                
                <return>
                    the node                    
                </return>
            </javadoc>
            <method name="dequeue" type="E" line="126">
                <declaration name="h" type="Node&lt;E&gt;" line="127"/>
                <declaration name="first" type="Node&lt;E&gt;" line="128"/>
                <declaration name="x" type="E" line="131"/>
            </method>
            <javadoc line="135">
                Lock to prevent both puts and takes.                
            </javadoc>
            <method name="fullyLock" type="void" line="138"/>
            <javadoc line="142">
                Unlock to allow both puts and takes.                
            </javadoc>
            <method name="fullyUnlock" type="void" line="145"/>
            <javadoc line="149">
                Creates a {@code LinkedBlockingQueue} with a capacity of{@link Integer#MAX_VALUE}.                
            </javadoc>
            <method name="LinkedBlockingQueue" type="constructor" line="152"/>
            <javadoc line="155">
                Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.                
                <param>
                    capacity the capacity of this queue                    
                </param>
                <throws>
                    IllegalArgumentException if {@code capacity} is not greater
                      than zero                    
                </throws>
            </javadoc>
            <method name="LinkedBlockingQueue" type="constructor" line="161">
                <params>
                    <param name="capacity" type="int"/>
                </params>
            </method>
            <javadoc line="166">
                Creates a {@code LinkedBlockingQueue} with a capacity of{@link Integer#MAX_VALUE}, initially containing the elements of the
                  given collection,
                  added in traversal order of the collection&apos;s iterator.                
                <param>
                    c the collection of elements to initially contain                    
                </param>
                <throws>
                    NullPointerException if the specified collection or any
                      of its elements are null                    
                </throws>
            </javadoc>
            <method name="LinkedBlockingQueue" type="constructor" line="174">
                <params>
                    <param name="c" type="Collection<? extends E>"/>
                </params>
                <declaration name="putLock" type="ReentrantLock" line="176"/>
                <scope line="178">
                    <declaration name="n" type="int" line="179"/>
                    <scope line="180"/>
                </scope>
                <scope line="188"/>
            </method>
            <javadoc line="192">
                Returns the number of elements in this queue.                
                <return>
                    the number of elements in this queue                    
                </return>
            </javadoc>
            <method name="size" type="int" line="196"/>
            <javadoc line="199">
                Returns the number of additional elements that this queue can ideally
                  (in the absence of memory or resource constraints) accept without
                  blocking. This is always equal to the initial capacity of this queue
                  less the current {@code size} of this queue.
                  &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert
                  an element will succeed by inspecting {@code remainingCapacity}because it may be the case that another thread is about to
                  insert or remove an element.                
            </javadoc>
            <method name="remainingCapacity" type="int" line="208"/>
            <javadoc line="211">
                Inserts the specified element at the tail of this queue, waiting if
                  necessary for space to become available.                
                <throws>
                    InterruptedException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="put" type="void" line="217">
                <params>
                    <param name="e" type="E"/>
                </params>
                <declaration name="c" type="int" line="219"/>
                <declaration name="node" type="Node&lt;E&gt;" line="220"/>
                <declaration name="putLock" type="ReentrantLock" line="221"/>
                <declaration name="count" type="AtomicInteger" line="222"/>
                <scope line="224">
                    <scope line="225"/>
                </scope>
                <scope line="232"/>
            </method>
            <javadoc line="237">
                Inserts the specified element at the tail of this queue, waiting if
                  necessary up to the specified wait time for space to become available.                
                <return>
                    {@code true} if successful, or {@code false} if
                      the specified waiting time elapses before space is available.                    
                </return>
                <throws>
                    InterruptedException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="245">
                <params>
                    <param name="e" type="E"/>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="nanos" type="long" line="247"/>
                <declaration name="c" type="int" line="248"/>
                <declaration name="putLock" type="ReentrantLock" line="249"/>
                <declaration name="count" type="AtomicInteger" line="250"/>
                <scope line="252">
                    <scope line="253"/>
                </scope>
                <scope line="261"/>
            </method>
            <javadoc line="267">
                Inserts the specified element at the tail of this queue if it is
                  possible to do so immediately without exceeding the queue&apos;s capacity,
                  returning {@code true} upon success and {@code false} if this queue
                  is full.
                  When using a capacity-restricted queue, this method is generally
                  preferable to method {@link BlockingQueue#add add}, which can fail to
                  insert an element only by throwing an exception.                
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="277">
                <params>
                    <param name="e" type="E"/>
                </params>
                <declaration name="count" type="AtomicInteger" line="279"/>
                <declaration name="c" type="int" line="281"/>
                <declaration name="node" type="Node&lt;E&gt;" line="282"/>
                <declaration name="putLock" type="ReentrantLock" line="283"/>
                <scope line="285">
                    <scope line="286"/>
                </scope>
                <scope line="292"/>
            </method>
            <method name="take" type="E" line="298">
                <declaration name="x" type="E" line="299"/>
                <declaration name="c" type="int" line="300"/>
                <declaration name="count" type="AtomicInteger" line="301"/>
                <declaration name="takeLock" type="ReentrantLock" line="302"/>
                <scope line="304">
                    <scope line="305"/>
                </scope>
                <scope line="312"/>
            </method>
            <method name="poll" type="E" line="318">
                <params>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="x" type="E" line="319"/>
                <declaration name="c" type="int" line="320"/>
                <declaration name="nanos" type="long" line="321"/>
                <declaration name="count" type="AtomicInteger" line="322"/>
                <declaration name="takeLock" type="ReentrantLock" line="323"/>
                <scope line="325">
                    <scope line="326"/>
                </scope>
                <scope line="334"/>
            </method>
            <method name="poll" type="E" line="340">
                <declaration name="count" type="AtomicInteger" line="341"/>
                <declaration name="x" type="E" line="343"/>
                <declaration name="c" type="int" line="344"/>
                <declaration name="takeLock" type="ReentrantLock" line="345"/>
                <scope line="347">
                    <scope line="348"/>
                </scope>
                <scope line="354"/>
            </method>
            <method name="peek" type="E" line="360">
                <declaration name="takeLock" type="ReentrantLock" line="362"/>
                <scope line="364">
                    <declaration name="first" type="Node&lt;E&gt;" line="365"/>
                </scope>
                <scope line="369"/>
            </method>
            <javadoc line="373">
                Unlinks interior Node p with predecessor trail.                
            </javadoc>
            <method name="unlink" type="void" line="376">
                <params>
                    <param name="p" type="Node<E>"/>
                    <param name="trail" type="Node<E>"/>
                </params>
            </method>
            <javadoc line="382">
                Removes a single instance of the specified element from this queue,
                  if it is present.  More formally, removes an element {@code e} such
                  that {@code o.equals(e)}, if this queue contains one or more such
                  elements.
                  Returns {@code true} if this queue contained the specified element
                  (or equivalently, if this queue changed as a result of the call).                
                <param>
                    o element to be removed from this queue, if present                    
                </param>
                <return>
                    {@code true} if this queue changed as a result of the call                    
                </return>
            </javadoc>
            <method name="remove" type="boolean" line="392">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="395">
                    <scope line="396">
                        <scope line="397"/>
                    </scope>
                </scope>
                <scope line="404"/>
            </method>
            <javadoc line="408">
                Returns {@code true} if this queue contains the specified element.
                  More formally, returns {@code true} if and only if this queue contains
                  at least one element {@code e} such that {@code o.equals(e)}.                
                <param>
                    o object to be checked for containment in this queue                    
                </param>
                <return>
                    {@code true} if this queue contains the specified element                    
                </return>
            </javadoc>
            <method name="contains" type="boolean" line="415">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="418"/>
                <scope line="422"/>
            </method>
            <javadoc line="426">
                Returns an array containing all of the elements in this queue, in
                  proper sequence.
                  &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
                  maintained by this queue.  (In other words, this method must allocate
                  a new array).  The caller is thus free to modify the returned array.
                  &lt;p&gt;This method acts as bridge between array-based and collection-based
                  APIs.                
                <return>
                    an array containing all of the elements in this queue                    
                </return>
            </javadoc>
            <method name="toArray" type="Object[]" line="436">
                <scope line="438">
                    <declaration name="size" type="int" line="439"/>
                    <declaration name="a" type="Object[]" line="440"/>
                    <declaration name="k" type="int" line="441"/>
                </scope>
                <scope line="445"/>
            </method>
            <javadoc line="449">
                Returns an array containing all of the elements in this queue, in
                  proper sequence; the runtime type of the returned array is that of
                  the specified array.  If the queue fits in the specified array, it
                  is returned therein.  Otherwise, a new array is allocated with the
                  runtime type of the specified array and the size of this queue.
                  &lt;p&gt;If this queue fits in the specified array with room to spare
                  (i.e., the array has more elements than this queue), the element in
                  the array immediately following the end of the queue is set to{@code null}.
                  &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
                  array-based and collection-based APIs.  Further, this method allows
                  precise control over the runtime type of the output array, and may,
                  under certain circumstances, be used to save allocation costs.
                  &lt;p&gt;Suppose {@code x} is a queue known to contain only strings.
                  The following code can be used to dump the queue into a newly
                  allocated array of {@code String}:
                  &lt;pre&gt;
                  String[] y = x.toArray(new String[0]);&lt;/pre&gt;
                  Note that {@code toArray(new Object[0])} is identical in function to{@code toArray()}.                
                <param>
                    a the array into which the elements of the queue are to
                      be stored, if it is big enough; otherwise, a new array of the
                      same runtime type is allocated for this purpose                    
                </param>
                <return>
                    an array containing all of the elements in this queue                    
                </return>
                <throws>
                    ArrayStoreException if the runtime type of the specified array
                      is not a supertype of the runtime type of every element in
                      this queue                    
                </throws>
                <throws>
                    NullPointerException if the specified array is null                    
                </throws>
            </javadoc>
            <method name="toArray" type="T[]" line="477">
                <params>
                    <param name="a" type="T[]"/>
                </params>
                <scope line="479">
                    <declaration name="size" type="int" line="480"/>
                    <declaration name="k" type="int" line="482"/>
                </scope>
                <scope line="487"/>
            </method>
            <method name="toString" type="String" line="491">
                <scope line="493">
                    <declaration name="p" type="Node&lt;E&gt;" line="494"/>
                    <declaration name="sb" type="StringBuilder" line="496"/>
                    <scope line="498">
                        <declaration name="e" type="E" line="499"/>
                    </scope>
                </scope>
                <scope line="506"/>
            </method>
            <javadoc line="510">
                Atomically removes all of the elements from this queue.
                  The queue will be empty after this call returns.                
            </javadoc>
            <method name="clear" type="void" line="514">
                <scope line="516">
                    <scope line="517"/>
                </scope>
                <scope line="524"/>
            </method>
            <javadoc line="528">
                @throws UnsupportedOperationException {@inheritDoc}                
                <throws>
                    ClassCastException            {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException          {@inheritDoc}                    
                </throws>
                <throws>
                    IllegalArgumentException      {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="drainTo" type="int" line="534">
                <params>
                    <param name="c" type="Collection<? super E>"/>
                </params>
            </method>
            <javadoc line="537">
                @throws UnsupportedOperationException {@inheritDoc}                
                <throws>
                    ClassCastException            {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException          {@inheritDoc}                    
                </throws>
                <throws>
                    IllegalArgumentException      {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="drainTo" type="int" line="543">
                <params>
                    <param name="c" type="Collection<? super E>"/>
                    <param name="maxElements" type="int"/>
                </params>
                <declaration name="signalNotFull" type="boolean" line="546"/>
                <declaration name="takeLock" type="ReentrantLock" line="547"/>
                <scope line="549">
                    <declaration name="n" type="int" line="550"/>
                    <declaration name="h" type="Node&lt;E&gt;" line="551"/>
                    <declaration name="i" type="int" line="552"/>
                    <scope line="553">
                        <scope line="554">
                            <declaration name="p" type="Node&lt;E&gt;" line="555"/>
                        </scope>
                    </scope>
                    <scope line="564">
                        <scope line="565"/>
                    </scope>
                </scope>
                <scope line="571"/>
            </method>
            <javadoc line="576">
                Returns an iterator over the elements in this queue in proper sequence.
                  The elements will be returned in order from first (head) to last (tail).
                  &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that
                  will never throw {@link java.util.ConcurrentModificationExceptionConcurrentModificationException}, and guarantees to traverse
                  elements as they existed upon construction of the iterator, and
                  may (but is not guaranteed to) reflect any modifications
                  subsequent to construction.                
                <return>
                    an iterator over the elements in this queue in proper sequence                    
                </return>
            </javadoc>
            <method name="iterator" type="Iterator<E>" line="586"/>
            <class name="Itr" line="589">
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="current" type="Node&lt;E&gt;" line="590"/>
                <declaration name="lastRet" type="Node&lt;E&gt;" line="591"/>
                <declaration name="currentElement" type="E" line="592"/>
                <method name="Itr" type="constructor" line="593">
                    <scope line="595"/>
                    <scope line="599"/>
                </method>
                <method name="hasNext" type="boolean" line="603"/>
                <javadoc line="606">
                    Returns the next live successor of p, or null if no such.
                      Unlike other traversal methods, iterators need to handle both:
                      - dequeued nodes (p.next == p)
                      - (possibly multiple) interior removed nodes (p.item == null)                    
                </javadoc>
                <method name="nextNode" type="Node<E>" line="612">
                    <params>
                        <param name="p" type="Node<E>"/>
                    </params>
                    <scope line="613">
                        <declaration name="s" type="Node&lt;E&gt;" line="614"/>
                    </scope>
                </method>
                <method name="next" type="E" line="620">
                    <scope line="622">
                        <declaration name="x" type="E" line="624"/>
                    </scope>
                    <scope line="630"/>
                </method>
                <method name="remove" type="void" line="634">
                    <scope line="637">
                        <declaration name="node" type="Node&lt;E&gt;" line="638"/>
                        <scope line="640">
                            <scope line="641"/>
                        </scope>
                    </scope>
                    <scope line="647"/>
                </method>
            </class>
            <javadoc line="652">
                Save the state to a stream (that is, serialize it).                
                <serialData>
                    The capacity is emitted (int), followed by all of
                      its elements (each an {@code Object}) in the proper order,
                      followed by a null                    
                </serialData>
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="659">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <scope line="661"/>
                <scope line="666"/>
            </method>
            <javadoc line="670">
                Reconstitute this queue instance from a stream (that is,
                  deserialize it).                
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="675">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <scope line="679">
                    <declaration name="item" type="E" line="680"/>
                </scope>
            </method>
        </class>
    </source>