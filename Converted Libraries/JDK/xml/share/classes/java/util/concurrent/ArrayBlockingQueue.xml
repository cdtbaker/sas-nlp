<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.concurrent.locks"/>
        <import package="java.util"/>
        <class name="ArrayBlockingQueue" line="40">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="AbstractQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <comment line="99">
                Concurrency control uses the classic two-condition algorithm
                 found in any textbook.                
            </comment>
            <comment line="111">
                Internal helper methods                
            </comment>
            <comment line="408">
                this doc comment is overridden to remove the reference to collections                
            </comment>
            <comment line="409">
                greater in size than Integer.MAX_VALUE                
            </comment>
            <comment line="425">
                this doc comment is a modified copy of the inherited doc comment,                
            </comment>
            <comment line="426">
                without the reference to unlimited queues.                
            </comment>
            <implements interface="BlockingQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </implements>
            <implements interface="java.io.Serializable"/>
            <javadoc line="40">
                A bounded {@linkplain BlockingQueue blocking queue} backed by an
                  array.  This queue orders elements FIFO (first-in-first-out).  The
                  &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the
                  queue the longest time.  The &lt;em&gt;tail&lt;/em&gt; of the queue is that
                  element that has been on the queue the shortest time. New elements
                  are inserted at the tail of the queue, and the queue retrieval
                  operations obtain elements at the head of the queue.
                  &lt;p&gt;This is a classic &amp;quot;bounded buffer&amp;quot;, in which a
                  fixed-sized array holds elements inserted by producers and
                  extracted by consumers.  Once created, the capacity cannot be
                  changed.  Attempts to {@code put} an element into a full queue
                  will result in the operation blocking; attempts to {@code take} an
                  element from an empty queue will similarly block.
                  &lt;p&gt;This class supports an optional fairness policy for ordering
                  waiting producer and consumer threads.  By default, this ordering
                  is not guaranteed. However, a queue constructed with fairness set
                  to {@code true} grants threads access in FIFO order. Fairness
                  generally decreases throughput but reduces variability and avoids
                  starvation.
                  &lt;p&gt;This class and its iterator implement all of the
                  &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link Iterator} interfaces.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea                    
                </author>
                <param>
                    <E>
                       the type of elements held in this collection                    
                </param>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="78"/>
            <javadoc line="78">
                Serialization ID. This class relies on default serialization
                  even for the items array, which is default-serialized, even if
                  it is empty. Otherwise it could not be declared final, which is
                  necessary here.                
            </javadoc>
            <declaration name="items" type="Object[]" line="86"/>
            <javadoc line="86">
                The queued items                
            </javadoc>
            <declaration name="takeIndex" type="int" line="89"/>
            <javadoc line="89">
                items index for next take, poll, peek or remove                
            </javadoc>
            <declaration name="putIndex" type="int" line="92"/>
            <javadoc line="92">
                items index for next put, offer, or add                
            </javadoc>
            <declaration name="count" type="int" line="95"/>
            <javadoc line="95">
                Number of elements in the queue                
            </javadoc>
            <declaration name="lock" type="ReentrantLock" line="103"/>
            <javadoc line="103">
                Main lock guarding all access                
            </javadoc>
            <declaration name="notEmpty" type="Condition" line="105"/>
            <javadoc line="105">
                Condition for waiting takes                
            </javadoc>
            <declaration name="notFull" type="Condition" line="107"/>
            <javadoc line="107">
                Condition for waiting puts                
            </javadoc>
            <javadoc line="112">
                Circularly increment i.                
            </javadoc>
            <method name="inc" type="int" line="115">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
            <javadoc line="119">
                Circularly decrement i.                
            </javadoc>
            <method name="dec" type="int" line="122">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
            <method name="cast" type="E" line="127">
                <params>
                    <param name="item" type="Object"/>
                </params>
            </method>
            <javadoc line="131">
                Returns item at index i.                
            </javadoc>
            <method name="itemAt" type="E" line="134">
                <params>
                    <param name="i" type="int"/>
                </params>
            </method>
            <javadoc line="138">
                Throws NullPointerException if argument is null.                
                <param>
                    v the element                    
                </param>
            </javadoc>
            <method name="checkNotNull" type="void" line="143">
                <params>
                    <param name="v" type="Object"/>
                </params>
            </method>
            <javadoc line="148">
                Inserts element at current put position, advances, and signals.
                  Call only when holding lock.                
            </javadoc>
            <method name="insert" type="void" line="152">
                <params>
                    <param name="x" type="E"/>
                </params>
            </method>
            <javadoc line="159">
                Extracts element at current take position, advances, and signals.
                  Call only when holding lock.                
            </javadoc>
            <method name="extract" type="E" line="163">
                <declaration name="items" type="Object[]" line="164"/>
                <declaration name="x" type="E" line="165"/>
            </method>
            <javadoc line="173">
                Deletes item at position i.
                  Utility for remove and iterator.remove.
                  Call only when holding lock.                
            </javadoc>
            <method name="removeAt" type="void" line="178">
                <params>
                    <param name="i" type="int"/>
                </params>
                <comment line="180">
                    if removing front item, just advance                    
                </comment>
                <comment line="185">
                    slide over all others up through putIndex.                    
                </comment>
                <declaration name="items" type="Object[]" line="179"/>
                <scope line="181"/>
                <scope line="184">
                    <scope line="186">
                        <declaration name="nexti" type="int" line="187"/>
                        <scope line="188"/>
                        <scope line="191"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="202">
                Creates an {@code ArrayBlockingQueue} with the given (fixed)
                  capacity and default access policy.                
                <param>
                    capacity the capacity of this queue                    
                </param>
                <throws>
                    IllegalArgumentException if {@code capacity < 1}                    
                </throws>
            </javadoc>
            <method name="ArrayBlockingQueue" type="constructor" line="209">
                <params>
                    <param name="capacity" type="int"/>
                </params>
            </method>
            <javadoc line="213">
                Creates an {@code ArrayBlockingQueue} with the given (fixed)
                  capacity and the specified access policy.                
                <param>
                    capacity the capacity of this queue                    
                </param>
                <param>
                    fair if {@code true} then queue accesses for threads blocked
                      on insertion or removal, are processed in FIFO order;
                      if {@code false} the access order is unspecified.                    
                </param>
                <throws>
                    IllegalArgumentException if {@code capacity < 1}                    
                </throws>
            </javadoc>
            <method name="ArrayBlockingQueue" type="constructor" line="223">
                <params>
                    <param name="capacity" type="int"/>
                    <param name="fair" type="boolean"/>
                </params>
            </method>
            <javadoc line="232">
                Creates an {@code ArrayBlockingQueue} with the given (fixed)
                  capacity, the specified access policy and initially containing the
                  elements of the given collection,
                  added in traversal order of the collection&apos;s iterator.                
                <param>
                    capacity the capacity of this queue                    
                </param>
                <param>
                    fair if {@code true} then queue accesses for threads blocked
                      on insertion or removal, are processed in FIFO order;
                      if {@code false} the access order is unspecified.                    
                </param>
                <param>
                    c the collection of elements to initially contain                    
                </param>
                <throws>
                    IllegalArgumentException if {@code capacity} is less than{@code c.size()}, or less than 1.                    
                </throws>
                <throws>
                    NullPointerException if the specified collection or any
                      of its elements are null                    
                </throws>
            </javadoc>
            <method name="ArrayBlockingQueue" type="constructor" line="249">
                <params>
                    <param name="capacity" type="int"/>
                    <param name="fair" type="boolean"/>
                    <param name="c" type="Collection<? extends E>"/>
                </params>
                <comment line="253">
                    Lock only for visibility, not mutual exclusion                    
                </comment>
                <declaration name="lock" type="ReentrantLock" line="252"/>
                <scope line="254">
                    <declaration name="i" type="int" line="255"/>
                    <scope line="256">
                        <scope line="257"/>
                    </scope>
                    <scope line="261"/>
                </scope>
                <scope line="266"/>
            </method>
            <javadoc line="271">
                Inserts the specified element at the tail of this queue if it is
                  possible to do so immediately without exceeding the queue&apos;s capacity,
                  returning {@code true} upon success and throwing an{@code IllegalStateException} if this queue is full.                
                <param>
                    e the element to add                    
                </param>
                <return>
                    {@code true} (as specified by {@link Collection#add})                    
                </return>
                <throws>
                    IllegalStateException if this queue is full                    
                </throws>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="add" type="boolean" line="282">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="286">
                Inserts the specified element at the tail of this queue if it is
                  possible to do so immediately without exceeding the queue&apos;s capacity,
                  returning {@code true} upon success and {@code false} if this queue
                  is full.  This method is generally preferable to method {@link #add},
                  which can fail to insert an element only by throwing an exception.                
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="295">
                <params>
                    <param name="e" type="E"/>
                </params>
                <declaration name="lock" type="ReentrantLock" line="297"/>
                <scope line="299">
                    <scope line="302"/>
                </scope>
                <scope line="306"/>
            </method>
            <javadoc line="311">
                Inserts the specified element at the tail of this queue, waiting
                  for space to become available if the queue is full.                
                <throws>
                    InterruptedException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="put" type="void" line="318">
                <params>
                    <param name="e" type="E"/>
                </params>
                <declaration name="lock" type="ReentrantLock" line="320"/>
                <scope line="322"/>
                <scope line="326"/>
            </method>
            <javadoc line="331">
                Inserts the specified element at the tail of this queue, waiting
                  up to the specified wait time for space to become available if
                  the queue is full.                
                <throws>
                    InterruptedException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="340">
                <params>
                    <param name="e" type="E"/>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="nanos" type="long" line="343"/>
                <declaration name="lock" type="ReentrantLock" line="344"/>
                <scope line="346">
                    <scope line="347"/>
                </scope>
                <scope line="354"/>
            </method>
            <method name="poll" type="E" line="359">
                <declaration name="lock" type="ReentrantLock" line="360"/>
                <scope line="362"/>
                <scope line="364"/>
            </method>
            <method name="take" type="E" line="369">
                <declaration name="lock" type="ReentrantLock" line="370"/>
                <scope line="372"/>
                <scope line="376"/>
            </method>
            <method name="poll" type="E" line="381">
                <params>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="nanos" type="long" line="382"/>
                <declaration name="lock" type="ReentrantLock" line="383"/>
                <scope line="385">
                    <scope line="386"/>
                </scope>
                <scope line="392"/>
            </method>
            <method name="peek" type="E" line="397">
                <declaration name="lock" type="ReentrantLock" line="398"/>
                <scope line="400"/>
                <scope line="402"/>
            </method>
            <javadoc line="409">
                Returns the number of elements in this queue.                
                <return>
                    the number of elements in this queue                    
                </return>
            </javadoc>
            <method name="size" type="int" line="414">
                <declaration name="lock" type="ReentrantLock" line="415"/>
                <scope line="417"/>
                <scope line="419"/>
            </method>
            <javadoc line="426">
                Returns the number of additional elements that this queue can ideally
                  (in the absence of memory or resource constraints) accept without
                  blocking. This is always equal to the initial capacity of this queue
                  less the current {@code size} of this queue.
                  &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert
                  an element will succeed by inspecting {@code remainingCapacity}because it may be the case that another thread is about to
                  insert or remove an element.                
            </javadoc>
            <method name="remainingCapacity" type="int" line="437">
                <declaration name="lock" type="ReentrantLock" line="438"/>
                <scope line="440"/>
                <scope line="442"/>
            </method>
            <javadoc line="447">
                Removes a single instance of the specified element from this queue,
                  if it is present.  More formally, removes an element {@code e} such
                  that {@code o.equals(e)}, if this queue contains one or more such
                  elements.
                  Returns {@code true} if this queue contained the specified element
                  (or equivalently, if this queue changed as a result of the call).
                  &lt;p&gt;Removal of interior elements in circular array based queues
                  is an intrinsically slow and disruptive operation, so should
                  be undertaken only in exceptional circumstances, ideally
                  only when the queue is known not to be accessible by other
                  threads.                
                <param>
                    o element to be removed from this queue, if present                    
                </param>
                <return>
                    {@code true} if this queue changed as a result of the call                    
                </return>
            </javadoc>
            <method name="remove" type="boolean" line="464">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="items" type="Object[]" line="466"/>
                <declaration name="lock" type="ReentrantLock" line="467"/>
                <scope line="469">
                    <scope line="470">
                        <scope line="471"/>
                    </scope>
                </scope>
                <scope line="477"/>
            </method>
            <javadoc line="482">
                Returns {@code true} if this queue contains the specified element.
                  More formally, returns {@code true} if and only if this queue contains
                  at least one element {@code e} such that {@code o.equals(e)}.                
                <param>
                    o object to be checked for containment in this queue                    
                </param>
                <return>
                    {@code true} if this queue contains the specified element                    
                </return>
            </javadoc>
            <method name="contains" type="boolean" line="490">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="items" type="Object[]" line="492"/>
                <declaration name="lock" type="ReentrantLock" line="493"/>
                <scope line="495"/>
                <scope line="500"/>
            </method>
            <javadoc line="505">
                Returns an array containing all of the elements in this queue, in
                  proper sequence.
                  &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
                  maintained by this queue.  (In other words, this method must allocate
                  a new array).  The caller is thus free to modify the returned array.
                  &lt;p&gt;This method acts as bridge between array-based and collection-based
                  APIs.                
                <return>
                    an array containing all of the elements in this queue                    
                </return>
            </javadoc>
            <method name="toArray" type="Object[]" line="518">
                <declaration name="items" type="Object[]" line="519"/>
                <declaration name="lock" type="ReentrantLock" line="520"/>
                <scope line="522">
                    <declaration name="count" type="int" line="523"/>
                    <declaration name="a" type="Object[]" line="524"/>
                </scope>
                <scope line="528"/>
            </method>
            <javadoc line="533">
                Returns an array containing all of the elements in this queue, in
                  proper sequence; the runtime type of the returned array is that of
                  the specified array.  If the queue fits in the specified array, it
                  is returned therein.  Otherwise, a new array is allocated with the
                  runtime type of the specified array and the size of this queue.
                  &lt;p&gt;If this queue fits in the specified array with room to spare
                  (i.e., the array has more elements than this queue), the element in
                  the array immediately following the end of the queue is set to{@code null}.
                  &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
                  array-based and collection-based APIs.  Further, this method allows
                  precise control over the runtime type of the output array, and may,
                  under certain circumstances, be used to save allocation costs.
                  &lt;p&gt;Suppose {@code x} is a queue known to contain only strings.
                  The following code can be used to dump the queue into a newly
                  allocated array of {@code String}:
                  &lt;pre&gt;
                  String[] y = x.toArray(new String[0]);&lt;/pre&gt;
                  Note that {@code toArray(new Object[0])} is identical in function to{@code toArray()}.                
                <param>
                    a the array into which the elements of the queue are to
                      be stored, if it is big enough; otherwise, a new array of the
                      same runtime type is allocated for this purpose                    
                </param>
                <return>
                    an array containing all of the elements in this queue                    
                </return>
                <throws>
                    ArrayStoreException if the runtime type of the specified array
                      is not a supertype of the runtime type of every element in
                      this queue                    
                </throws>
                <throws>
                    NullPointerException if the specified array is null                    
                </throws>
            </javadoc>
            <method name="toArray" type="T[]" line="570">
                <params>
                    <param name="a" type="T[]"/>
                </params>
                <declaration name="items" type="Object[]" line="571"/>
                <declaration name="lock" type="ReentrantLock" line="572"/>
                <scope line="574">
                    <declaration name="count" type="int" line="575"/>
                    <declaration name="len" type="int" line="576"/>
                </scope>
                <scope line="585"/>
            </method>
            <method name="toString" type="String" line="590">
                <declaration name="lock" type="ReentrantLock" line="591"/>
                <scope line="593">
                    <declaration name="k" type="int" line="594"/>
                    <declaration name="sb" type="StringBuilder" line="598"/>
                    <scope line="600">
                        <declaration name="e" type="Object" line="601"/>
                    </scope>
                </scope>
                <scope line="607"/>
            </method>
            <javadoc line="612">
                Atomically removes all of the elements from this queue.
                  The queue will be empty after this call returns.                
            </javadoc>
            <method name="clear" type="void" line="616">
                <declaration name="items" type="Object[]" line="617"/>
                <declaration name="lock" type="ReentrantLock" line="618"/>
                <scope line="620"/>
                <scope line="627"/>
            </method>
            <javadoc line="632">
                @throws UnsupportedOperationException {@inheritDoc}                
                <throws>
                    ClassCastException            {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException          {@inheritDoc}                    
                </throws>
                <throws>
                    IllegalArgumentException      {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="drainTo" type="int" line="638">
                <params>
                    <param name="c" type="Collection<? super E>"/>
                </params>
                <declaration name="items" type="Object[]" line="642"/>
                <declaration name="lock" type="ReentrantLock" line="643"/>
                <scope line="645">
                    <declaration name="i" type="int" line="646"/>
                    <declaration name="n" type="int" line="647"/>
                    <declaration name="max" type="int" line="648"/>
                    <scope line="649"/>
                    <scope line="655"/>
                </scope>
                <scope line="662"/>
            </method>
            <javadoc line="667">
                @throws UnsupportedOperationException {@inheritDoc}                
                <throws>
                    ClassCastException            {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException          {@inheritDoc}                    
                </throws>
                <throws>
                    IllegalArgumentException      {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="drainTo" type="int" line="673">
                <params>
                    <param name="c" type="Collection<? super E>"/>
                    <param name="maxElements" type="int"/>
                </params>
                <declaration name="items" type="Object[]" line="679"/>
                <declaration name="lock" type="ReentrantLock" line="680"/>
                <scope line="682">
                    <declaration name="i" type="int" line="683"/>
                    <declaration name="n" type="int" line="684"/>
                    <declaration name="max" type="int" line="685"/>
                    <scope line="686"/>
                    <scope line="692"/>
                </scope>
                <scope line="698"/>
            </method>
            <javadoc line="703">
                Returns an iterator over the elements in this queue in proper sequence.
                  The elements will be returned in order from first (head) to last (tail).
                  &lt;p&gt;The returned {@code Iterator} is a &quot;weakly consistent&quot; iterator that
                  will never throw {@link java.util.ConcurrentModificationExceptionConcurrentModificationException},
                  and guarantees to traverse elements as they existed upon
                  construction of the iterator, and may (but is not guaranteed to)
                  reflect any modifications subsequent to construction.                
                <return>
                    an iterator over the elements in this queue in proper sequence                    
                </return>
            </javadoc>
            <method name="iterator" type="Iterator<E>" line="716"/>
            <class name="Itr" line="720">
                <comment line="738">
                    Number of elements yet to be returned                    
                </comment>
                <comment line="739">
                    Index of element to be returned by next                    
                </comment>
                <comment line="740">
                    Element to be returned by next call to next                    
                </comment>
                <comment line="741">
                    Element returned by last call to next                    
                </comment>
                <comment line="742">
                    Index of last element returned, or -1 if none                    
                </comment>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <javadoc line="720">
                    Iterator for ArrayBlockingQueue. To maintain weak consistency
                      with respect to puts and takes, we (1) read ahead one slot, so
                      as to not report hasNext true but then not have an element to
                      return -- however we later recheck this slot to use the most
                      current value; (2) ensure that each array slot is traversed at
                      most once (by tracking &quot;remaining&quot; elements); (3) skip over
                      null slots, which can occur if takes race ahead of iterators.
                      However, for circular array-based queues, we cannot rely on any
                      well established definition of what it means to be weakly
                      consistent with respect to interior removes since these may
                      require slot overwrites in the process of sliding elements to
                      cover gaps. So we settle for resiliency, operating on
                      established apparent nexts, which may miss some elements that
                      have moved between calls to next.                    
                </javadoc>
                <declaration name="remaining" type="int" line="737"/>
                <declaration name="nextIndex" type="int" line="738"/>
                <declaration name="nextItem" type="E" line="739"/>
                <declaration name="lastItem" type="E" line="740"/>
                <declaration name="lastRet" type="int" line="741"/>
                <method name="Itr" type="constructor" line="743">
                    <declaration name="lock" type="ReentrantLock" line="744"/>
                    <scope line="746"/>
                    <scope line="750"/>
                </method>
                <method name="hasNext" type="boolean" line="755"/>
                <method name="next" type="E" line="759">
                    <comment line="766">
                        check for fresher value                        
                    </comment>
                    <comment line="768">
                        we are forced to report old value                        
                    </comment>
                    <comment line="769">
                        but ensure remove fails                        
                    </comment>
                    <comment line="773">
                        skip over nulls                        
                    </comment>
                    <declaration name="lock" type="ReentrantLock" line="760"/>
                    <scope line="762">
                        <declaration name="x" type="E" line="766"/>
                        <scope line="767"/>
                    </scope>
                    <scope line="777"/>
                </method>
                <method name="remove" type="void" line="782">
                    <comment line="792">
                        only remove if item still at index                        
                    </comment>
                    <declaration name="lock" type="ReentrantLock" line="783"/>
                    <scope line="785">
                        <declaration name="i" type="int" line="786"/>
                        <declaration name="x" type="E" line="790"/>
                        <scope line="793">
                            <declaration name="removingHead" type="boolean" line="794"/>
                        </scope>
                    </scope>
                    <scope line="799"/>
                </method>
            </class>
        </class>
    </source>