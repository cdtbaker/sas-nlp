<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.concurrent.locks"/>
        <import package="java.util"/>
        <import package="java.io.Serializable"/>
        <import package="java.io.IOException"/>
        <import package="java.io.ObjectInputStream"/>
        <import package="java.io.ObjectOutputStream"/>
        <class name="ConcurrentHashMap" line="44">
            <type_params>
                <type_param name="K"/>
                <type_param name="V"/>
            </type_params>
            <extends class="AbstractMap">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </extends>
            <comment line="107">
                The basic strategy is to subdivide the table among Segments,
                 each of which itself is a concurrently readable hash table.  To
                 reduce footprint, all but one segments are constructed only
                 when first needed (see ensureSegment). To maintain visibility
                 in the presence of lazy construction, accesses to segments as
                 well as elements of segment&apos;s table must use volatile access,
                 which is done via Unsafe within methods segmentAt etc
                 below. These provide the functionality of AtomicReferenceArrays
                 but reduce the levels of indirection. Additionally,
                 volatile-writes of table elements and entry &quot;next&quot; fields
                 within locked operations use the cheaper &quot;lazySet&quot; forms of
                 writes (via putOrderedObject) because these writes are always
                 followed by lock releases that maintain sequential consistency
                 of table updates.
                
                 Historical note: The previous version of this class relied
                 heavily on &quot;final&quot; fields, which avoided some volatile reads at
                 the expense of a large initial footprint.  Some remnants of
                 that design (including forced construction of segment 0) exist
                 to ensure serialization compatibility.                
            </comment>
            <comment line="130">
                                
            </comment>
            <comment line="169">
                slightly conservative                
            </comment>
            <comment line="179">
                                
            </comment>
            <comment line="647">
                Accessing segments                
            </comment>
            <comment line="695">
                Hash-based segment and entry accesses                
            </comment>
            <comment line="717">
                                
            </comment>
            <comment line="1250">
                                
            </comment>
            <comment line="1428">
                                
            </comment>
            <comment line="1497">
                Unsafe mechanics                
            </comment>
            <implements interface="ConcurrentMap">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </implements>
            <implements interface="Serializable"/>
            <javadoc line="44">
                A hash table supporting full concurrency of retrievals and
                  adjustable expected concurrency for updates. This class obeys the
                  same functional specification as {@link java.util.Hashtable}, and
                  includes versions of methods corresponding to each method of
                  &lt;tt&gt;Hashtable&lt;/tt&gt;. However, even though all operations are
                  thread-safe, retrieval operations do &lt;em&gt;not&lt;/em&gt; entail locking,
                  and there is &lt;em&gt;not&lt;/em&gt; any support for locking the entire table
                  in a way that prevents all access.  This class is fully
                  interoperable with &lt;tt&gt;Hashtable&lt;/tt&gt; in programs that rely on its
                  thread safety but not on its synchronization details.
                  &lt;p&gt; Retrieval operations (including &lt;tt&gt;get&lt;/tt&gt;) generally do not
                  block, so may overlap with update operations (including
                  &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;remove&lt;/tt&gt;). Retrievals reflect the results
                  of the most recently &lt;em&gt;completed&lt;/em&gt; update operations holding
                  upon their onset.  For aggregate operations such as &lt;tt&gt;putAll&lt;/tt&gt;
                  and &lt;tt&gt;clear&lt;/tt&gt;, concurrent retrievals may reflect insertion or
                  removal of only some entries.  Similarly, Iterators and
                  Enumerations return elements reflecting the state of the hash table
                  at some point at or since the creation of the iterator/enumeration.
                  They do &lt;em&gt;not&lt;/em&gt; throw {@link ConcurrentModificationException}.
                  However, iterators are designed to be used by only one thread at a time.
                  &lt;p&gt; The allowed concurrency among update operations is guided by
                  the optional &lt;tt&gt;concurrencyLevel&lt;/tt&gt; constructor argument
                  (default &lt;tt&gt;16&lt;/tt&gt;), which is used as a hint for internal sizing.  The
                  table is internally partitioned to try to permit the indicated
                  number of concurrent updates without contention. Because placement
                  in hash tables is essentially random, the actual concurrency will
                  vary.  Ideally, you should choose a value to accommodate as many
                  threads as will ever concurrently modify the table. Using a
                  significantly higher value than you need can waste space and time,
                  and a significantly lower value can lead to thread contention. But
                  overestimates and underestimates within an order of magnitude do
                  not usually have much noticeable impact. A value of one is
                  appropriate when it is known that only one thread will modify and
                  all others will only read. Also, resizing this or any other kind of
                  hash table is a relatively slow operation, so, when possible, it is
                  a good idea to provide estimates of expected table sizes in
                  constructors.
                  &lt;p&gt;This class and its views and iterators implement all of the
                  &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator}interfaces.
                  &lt;p&gt; Like {@link Hashtable} but unlike {@link HashMap}, this class
                  does &lt;em&gt;not&lt;/em&gt; allow &lt;tt&gt;null&lt;/tt&gt; to be used as a key or value.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea                    
                </author>
                <param>
                    &lt;K&gt;
                       the type of keys maintained by this map                    
                </param>
                <param>
                    &lt;V&gt;
                       the type of mapped values                    
                </param>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="104"/>
            <declaration name="DEFAULT_INITIAL_CAPACITY" type="int" line="131"/>
            <javadoc line="131">
                The default initial capacity for this table,
                  used when not otherwise specified in a constructor.                
            </javadoc>
            <declaration name="DEFAULT_LOAD_FACTOR" type="float" line="137"/>
            <javadoc line="137">
                The default load factor for this table, used when not
                  otherwise specified in a constructor.                
            </javadoc>
            <declaration name="DEFAULT_CONCURRENCY_LEVEL" type="int" line="143"/>
            <javadoc line="143">
                The default concurrency level for this table, used when not
                  otherwise specified in a constructor.                
            </javadoc>
            <declaration name="MAXIMUM_CAPACITY" type="int" line="149"/>
            <javadoc line="149">
                The maximum capacity, used if a higher value is implicitly
                  specified by either of the constructors with arguments.  MUST
                  be a power of two &lt;= 1&lt;&lt;30 to ensure that entries are indexable
                  using ints.                
            </javadoc>
            <declaration name="MIN_SEGMENT_TABLE_CAPACITY" type="int" line="157"/>
            <javadoc line="157">
                The minimum capacity for per-segment tables.  Must be a power
                  of two, at least two to avoid immediate resizing on next use
                  after lazy construction.                
            </javadoc>
            <declaration name="MAX_SEGMENTS" type="int" line="164"/>
            <javadoc line="164">
                The maximum number of segments to allow; used to bound
                  constructor arguments. Must be power of two less than 1 &lt;&lt; 24.                
            </javadoc>
            <declaration name="RETRIES_BEFORE_LOCK" type="int" line="170"/>
            <javadoc line="170">
                Number of unsynchronized retries in size and containsValue
                  methods before resorting to locking. This is used to avoid
                  unbounded retries if tables undergo continuous modification
                  which would make it impossible to obtain an accurate result.                
            </javadoc>
            <declaration name="segmentMask" type="int" line="180"/>
            <javadoc line="180">
                Mask value for indexing into segments. The upper bits of a
                  key&apos;s hash code are used to choose the segment.                
            </javadoc>
            <declaration name="segmentShift" type="int" line="186"/>
            <javadoc line="186">
                Shift value for indexing within segments.                
            </javadoc>
            <declaration name="segments" type="Segment&lt;K,V&gt;[]" line="191"/>
            <javadoc line="191">
                The segments, each of which is a specialized hash table.                
            </javadoc>
            <declaration name="keySet" type="Set&lt;K&gt;" line="196"/>
            <declaration name="entrySet" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="197"/>
            <declaration name="values" type="Collection&lt;V&gt;" line="198"/>
            <class name="HashEntry" line="200">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <javadoc line="200">
                    ConcurrentHashMap list entry. Note that this is never exported
                      out as a user-visible Map.Entry.                    
                </javadoc>
                <declaration name="hash" type="int" line="205"/>
                <declaration name="key" type="K" line="206"/>
                <declaration name="value" type="V" line="207"/>
                <declaration name="next" type="HashEntry&lt;K,V&gt;" line="208"/>
                <method name="HashEntry" type="constructor" line="210">
                    <params>
                        <param name="hash" type="int"/>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                        <param name="next" type="HashEntry<K,V>"/>
                    </params>
                </method>
                <javadoc line="217">
                    Sets next field with volatile write semantics.  (See above
                      about use of putOrderedObject.)                    
                </javadoc>
                <method name="setNext" type="void" line="221">
                    <params>
                        <param name="n" type="HashEntry<K,V>"/>
                    </params>
                </method>
                <declaration name="UNSAFE" type="sun.misc.Unsafe" line="226"/>
                <declaration name="nextOffset" type="long" line="227"/>
                <scope line="228">
                    <scope line="229">
                        <declaration name="k" type="Class" line="231"/>
                    </scope>
                    <scope line="234"/>
                </scope>
            </class>
            <javadoc line="240">
                Gets the ith element of given table (if nonnull) with volatile
                  read semantics. Note: This is manually integrated into a few
                  performance-sensitive methods to reduce call overhead.                
            </javadoc>
            <method name="entryAt" type="HashEntry<K,V>" line="246">
                <params>
                    <param name="tab" type="HashEntry<K,V>[]"/>
                    <param name="i" type="int"/>
                </params>
            </method>
            <javadoc line="252">
                Sets the ith element of given table, with volatile write
                  semantics. (See above about use of putOrderedObject.)                
            </javadoc>
            <method name="setEntryAt" type="void" line="257">
                <params>
                    <param name="tab" type="HashEntry<K,V>[]"/>
                    <param name="i" type="int"/>
                    <param name="e" type="HashEntry<K,V>"/>
                </params>
            </method>
            <javadoc line="261">
                Applies a supplemental hash function to a given hashCode, which
                  defends against poor quality hash functions.  This is critical
                  because ConcurrentHashMap uses power-of-two length hash tables,
                  that otherwise encounter collisions for hashCodes that do not
                  differ in lower or upper bits.                
            </javadoc>
            <method name="hash" type="int" line="268">
                <params>
                    <param name="h" type="int"/>
                </params>
                <comment line="270">
                    Spread bits to regularize both segment and index locations,
                     using variant of single-word Wang/Jenkins hash.                    
                </comment>
            </method>
            <class name="Segment" line="279">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="ReentrantLock"/>
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <implements interface="Serializable"/>
                <javadoc line="279">
                    Segments are specialized versions of hash tables.  This
                      subclasses from ReentrantLock opportunistically, just to
                      simplify some locking and avoid separate construction.                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="311"/>
                <declaration name="MAX_SCAN_RETRIES" type="int" line="313"/>
                <javadoc line="313">
                    The maximum number of times to tryLock in a prescan before
                      possibly blocking on acquire in preparation for a locked
                      segment operation. On multiprocessors, using a bounded
                      number of retries maintains cache acquired while locating
                      nodes.                    
                </javadoc>
                <declaration name="table" type="HashEntry&lt;K,V&gt;[]" line="323"/>
                <javadoc line="323">
                    The per-segment table. Elements are accessed via
                      entryAt/setEntryAt providing volatile semantics.                    
                </javadoc>
                <declaration name="count" type="int" line="329"/>
                <javadoc line="329">
                    The number of elements. Accessed only either within locks
                      or among other volatile reads that maintain visibility.                    
                </javadoc>
                <declaration name="modCount" type="int" line="335"/>
                <javadoc line="335">
                    The total number of mutative operations in this segment.
                      Even though this may overflows 32 bits, it provides
                      sufficient accuracy for stability checks in CHM isEmpty()
                      and size() methods.  Accessed only either within locks or
                      among other volatile reads that maintain visibility.                    
                </javadoc>
                <declaration name="threshold" type="int" line="344"/>
                <javadoc line="344">
                    The table is rehashed when its size exceeds this threshold.
                      (The value of this field is always &lt;tt&gt;(int)(capacity 
                      loadFactor)&lt;/tt&gt;.)                    
                </javadoc>
                <declaration name="loadFactor" type="float" line="351"/>
                <javadoc line="351">
                    The load factor for the hash table.  Even though this value
                      is same for all segments, it is replicated to avoid needing
                      links to outer object.                    
                    <serial>
                                                
                    </serial>
                </javadoc>
                <method name="Segment" type="constructor" line="359">
                    <params>
                        <param name="lf" type="float"/>
                        <param name="threshold" type="int"/>
                        <param name="tab" type="HashEntry<K,V>[]"/>
                    </params>
                </method>
                <method name="put" type="V" line="365">
                    <params>
                        <param name="key" type="K"/>
                        <param name="hash" type="int"/>
                        <param name="value" type="V"/>
                        <param name="onlyIfAbsent" type="boolean"/>
                    </params>
                    <declaration name="node" type="HashEntry&lt;K,V&gt;" line="366"/>
                    <declaration name="oldValue" type="V" line="368"/>
                    <scope line="369">
                        <declaration name="tab" type="HashEntry&lt;K,V&gt;[]" line="370"/>
                        <declaration name="index" type="int" line="371"/>
                        <declaration name="first" type="HashEntry&lt;K,V&gt;" line="372"/>
                        <scope line="373">
                            <scope line="374">
                                <declaration name="k" type="K" line="375"/>
                                <scope line="377">
                                    <scope line="379"/>
                                </scope>
                            </scope>
                            <scope line="387">
                                <declaration name="c" type="int" line="392"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="403"/>
                </method>
                <javadoc line="409">
                    Doubles size of table and repacks entries, also adding the
                      given node to new table                    
                </javadoc>
                <method name="rehash" type="void" line="414">
                    <params>
                        <param name="node" type="HashEntry<K,V>"/>
                    </params>
                    <comment line="416">
                        Reclassify nodes in each list to new table.  Because we
                         are using power-of-two expansion, the elements from
                         each bin must either stay at same index, or move with a
                         power of two offset. We eliminate unnecessary node
                         creation by catching cases where old nodes can be
                         reused because their next fields won&apos;t change.
                         Statistically, at the default threshold, only about
                         one-sixth of them need cloning when a table
                         doubles. The nodes they replace will be garbage
                         collectable as soon as they are no longer referenced by
                         any reader thread that may be in the midst of
                         concurrently traversing table. Entry accesses use plain
                         array indexing because they are followed by volatile
                         table write.                        
                    </comment>
                    <comment line="444">
                        Single node on list                        
                    </comment>
                    <comment line="446">
                        Reuse consecutive sequence at same slot                        
                    </comment>
                    <comment line="459">
                        Clone remaining nodes                        
                    </comment>
                    <comment line="470">
                        add the new node                        
                    </comment>
                    <declaration name="oldTable" type="HashEntry&lt;K,V&gt;[]" line="431"/>
                    <declaration name="oldCapacity" type="int" line="432"/>
                    <declaration name="newCapacity" type="int" line="433"/>
                    <declaration name="newTable" type="HashEntry&lt;K,V&gt;[]" line="435"/>
                    <declaration name="sizeMask" type="int" line="437"/>
                    <scope line="438">
                        <declaration name="e" type="HashEntry&lt;K,V&gt;" line="439"/>
                        <scope line="440">
                            <declaration name="next" type="HashEntry&lt;K,V&gt;" line="441"/>
                            <declaration name="idx" type="int" line="442"/>
                            <scope line="445">
                                <declaration name="lastRun" type="HashEntry&lt;K,V&gt;" line="446"/>
                                <declaration name="lastIdx" type="int" line="447"/>
                                <scope line="450">
                                    <declaration name="k" type="int" line="451"/>
                                    <scope line="452"/>
                                </scope>
                                <scope line="459">
                                    <declaration name="v" type="V" line="460"/>
                                    <declaration name="h" type="int" line="461"/>
                                    <declaration name="k" type="int" line="462"/>
                                    <declaration name="n" type="HashEntry&lt;K,V&gt;" line="463"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <declaration name="nodeIndex" type="int" line="469"/>
                </method>
                <javadoc line="475">
                    Scans for a node containing given key while trying to
                      acquire lock, creating and returning one if not found. Upon
                      return, guarantees that lock is held. UNlike in most
                      methods, calls to method equals are not screened: Since
                      traversal speed doesn&apos;t matter, we might as well help warm
                      up the associated code and accesses as well.                    
                    <return>
                        a new node if key not found, else null                        
                    </return>
                </javadoc>
                <method name="scanAndLockForPut" type="HashEntry<K,V>" line="485">
                    <params>
                        <param name="key" type="K"/>
                        <param name="hash" type="int"/>
                        <param name="value" type="V"/>
                    </params>
                    <comment line="490">
                        negative while locating node                        
                    </comment>
                    <comment line="492">
                        to recheck first below                        
                    </comment>
                    <comment line="495">
                        speculatively create node                        
                    </comment>
                    <comment line="510">
                        re-traverse if entry changed                        
                    </comment>
                    <declaration name="first" type="HashEntry&lt;K,V&gt;" line="486"/>
                    <declaration name="e" type="HashEntry&lt;K,V&gt;" line="487"/>
                    <declaration name="node" type="HashEntry&lt;K,V&gt;" line="488"/>
                    <declaration name="retries" type="int" line="489"/>
                    <scope line="490">
                        <declaration name="f" type="HashEntry&lt;K,V&gt;" line="491"/>
                        <scope line="492">
                            <scope line="493"/>
                        </scope>
                        <scope line="503"/>
                        <scope line="508"/>
                    </scope>
                </method>
                <javadoc line="516">
                    Scans for a node containing the given key while trying to
                      acquire lock for a remove or replace operation. Upon
                      return, guarantees that lock is held.  Note that we must
                      lock even if the key is not found, to ensure sequential
                      consistency of updates.                    
                </javadoc>
                <method name="scanAndLock" type="void" line="523">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="hash" type="int"/>
                    </params>
                    <comment line="525">
                        similar to but simpler than scanAndLockForPut                        
                    </comment>
                    <declaration name="first" type="HashEntry&lt;K,V&gt;" line="525"/>
                    <declaration name="e" type="HashEntry&lt;K,V&gt;" line="526"/>
                    <declaration name="retries" type="int" line="527"/>
                    <scope line="528">
                        <declaration name="f" type="HashEntry&lt;K,V&gt;" line="529"/>
                        <scope line="530"/>
                        <scope line="536"/>
                        <scope line="541"/>
                    </scope>
                </method>
                <javadoc line="548">
                    Remove; match on key only if value null, else match both.                    
                </javadoc>
                <method name="remove" type="V" line="551">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="hash" type="int"/>
                        <param name="value" type="Object"/>
                    </params>
                    <declaration name="oldValue" type="V" line="554"/>
                    <scope line="555">
                        <declaration name="tab" type="HashEntry&lt;K,V&gt;[]" line="556"/>
                        <declaration name="index" type="int" line="557"/>
                        <declaration name="e" type="HashEntry&lt;K,V&gt;" line="558"/>
                        <declaration name="pred" type="HashEntry&lt;K,V&gt;" line="559"/>
                        <scope line="560">
                            <declaration name="k" type="K" line="561"/>
                            <declaration name="next" type="HashEntry&lt;K,V&gt;" line="562"/>
                            <scope line="564">
                                <declaration name="v" type="V" line="565"/>
                                <scope line="566"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="580"/>
                </method>
                <method name="replace" type="boolean" line="586">
                    <params>
                        <param name="key" type="K"/>
                        <param name="hash" type="int"/>
                        <param name="oldValue" type="V"/>
                        <param name="newValue" type="V"/>
                    </params>
                    <declaration name="replaced" type="boolean" line="589"/>
                    <scope line="590">
                        <declaration name="e" type="HashEntry&lt;K,V&gt;" line="591"/>
                        <scope line="592">
                            <declaration name="k" type="K" line="593"/>
                            <scope line="595">
                                <scope line="596"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="604"/>
                </method>
                <method name="replace" type="V" line="610">
                    <params>
                        <param name="key" type="K"/>
                        <param name="hash" type="int"/>
                        <param name="value" type="V"/>
                    </params>
                    <declaration name="oldValue" type="V" line="613"/>
                    <scope line="614">
                        <declaration name="e" type="HashEntry&lt;K,V&gt;" line="615"/>
                        <scope line="616">
                            <declaration name="k" type="K" line="617"/>
                            <scope line="619"/>
                        </scope>
                    </scope>
                    <scope line="626"/>
                </method>
                <method name="clear" type="void" line="632">
                    <scope line="634">
                        <declaration name="tab" type="HashEntry&lt;K,V&gt;[]" line="635"/>
                    </scope>
                    <scope line="640"/>
                </method>
            </class>
            <javadoc line="648">
                Gets the jth element of given segment array (if nonnull) with
                  volatile element access semantics via Unsafe. (The null check
                  can trigger harmlessly only during deserialization.) Note:
                  because each element of segments array is set only once (using
                  fully ordered writes), some performance-sensitive methods rely
                  on this method only as a recheck upon null reads.                
            </javadoc>
            <method name="segmentAt" type="Segment<K,V>" line="657">
                <params>
                    <param name="ss" type="Segment<K,V>[]"/>
                    <param name="j" type="int"/>
                </params>
                <declaration name="u" type="long" line="658"/>
            </method>
            <javadoc line="663">
                Returns the segment for the given index, creating it and
                  recording in segment table (via CAS) if not already present.                
                <param>
                    k the index                    
                </param>
                <return>
                    the segment                    
                </return>
            </javadoc>
            <method name="ensureSegment" type="Segment<K,V>" line="671">
                <params>
                    <param name="k" type="int"/>
                </params>
                <comment line="674">
                    raw offset                    
                </comment>
                <comment line="677">
                    use segment 0 as prototype                    
                </comment>
                <comment line="683">
                    recheck                    
                </comment>
                <declaration name="ss" type="Segment&lt;K,V&gt;[]" line="672"/>
                <declaration name="u" type="long" line="673"/>
                <declaration name="seg" type="Segment&lt;K,V&gt;" line="674"/>
                <scope line="675">
                    <declaration name="proto" type="Segment&lt;K,V&gt;" line="676"/>
                    <declaration name="cap" type="int" line="677"/>
                    <declaration name="lf" type="float" line="678"/>
                    <declaration name="threshold" type="int" line="679"/>
                    <declaration name="tab" type="HashEntry&lt;K,V&gt;[]" line="680"/>
                    <scope line="682">
                        <declaration name="s" type="Segment&lt;K,V&gt;" line="683"/>
                        <scope line="685"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="696">
                Get the segment for the given hash                
            </javadoc>
            <method name="segmentForHash" type="Segment<K,V>" line="700">
                <params>
                    <param name="h" type="int"/>
                </params>
                <declaration name="u" type="long" line="701"/>
            </method>
            <javadoc line="705">
                Gets the table entry for the given segment and hash                
            </javadoc>
            <method name="entryForHash" type="HashEntry<K,V>" line="709">
                <params>
                    <param name="seg" type="Segment<K,V>"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="tab" type="HashEntry&lt;K,V&gt;[]" line="710"/>
            </method>
            <javadoc line="718">
                Creates a new, empty map with the specified initial
                  capacity, load factor and concurrency level.                
                <param>
                    initialCapacity the initial capacity. The implementation
                      performs internal sizing to accommodate this many elements.                    
                </param>
                <param>
                    loadFactor  the load factor threshold, used to control resizing.
                      Resizing may be performed when the average number of elements per
                      bin exceeds this threshold.                    
                </param>
                <param>
                    concurrencyLevel the estimated number of concurrently
                      updating threads. The implementation performs internal sizing
                      to try to accommodate this many threads.                    
                </param>
                <throws>
                    IllegalArgumentException if the initial capacity is
                      negative or the load factor or concurrencyLevel are
                      nonpositive.                    
                </throws>
            </javadoc>
            <method name="ConcurrentHashMap" type="constructor" line="736">
                <params>
                    <param name="initialCapacity" type="int"/>
                    <param name="loadFactor" type="float"/>
                    <param name="concurrencyLevel" type="int"/>
                </params>
                <comment line="742">
                    Find power-of-two sizes best matching arguments                    
                </comment>
                <comment line="759">
                    create segments and segments[0]                    
                </comment>
                <comment line="764">
                    ordered write of segments[0]                    
                </comment>
                <declaration name="sshift" type="int" line="742"/>
                <declaration name="ssize" type="int" line="743"/>
                <scope line="744"/>
                <declaration name="c" type="int" line="752"/>
                <declaration name="cap" type="int" line="755"/>
                <declaration name="s0" type="Segment&lt;K,V&gt;" line="759"/>
                <declaration name="ss" type="Segment&lt;K,V&gt;[]" line="762"/>
            </method>
            <javadoc line="767">
                Creates a new, empty map with the specified initial capacity
                  and load factor and with the default concurrencyLevel (16).                
                <param>
                    initialCapacity The implementation performs internal
                      sizing to accommodate this many elements.                    
                </param>
                <param>
                    loadFactor  the load factor threshold, used to control resizing.
                      Resizing may be performed when the average number of elements per
                      bin exceeds this threshold.                    
                </param>
                <throws>
                    IllegalArgumentException if the initial capacity of
                      elements is negative or the load factor is nonpositive                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="ConcurrentHashMap" type="constructor" line="781">
                <params>
                    <param name="initialCapacity" type="int"/>
                    <param name="loadFactor" type="float"/>
                </params>
            </method>
            <javadoc line="785">
                Creates a new, empty map with the specified initial capacity,
                  and with default load factor (0.75) and concurrencyLevel (16).                
                <param>
                    initialCapacity the initial capacity. The implementation
                      performs internal sizing to accommodate this many elements.                    
                </param>
                <throws>
                    IllegalArgumentException if the initial capacity of
                      elements is negative.                    
                </throws>
            </javadoc>
            <method name="ConcurrentHashMap" type="constructor" line="794">
                <params>
                    <param name="initialCapacity" type="int"/>
                </params>
            </method>
            <javadoc line="798">
                Creates a new, empty map with a default initial capacity (16),
                  load factor (0.75) and concurrencyLevel (16).                
            </javadoc>
            <method name="ConcurrentHashMap" type="constructor" line="802"/>
            <javadoc line="806">
                Creates a new map with the same mappings as the given map.
                  The map is created with a capacity of 1.5 times the number
                  of mappings in the given map or 16 (whichever is greater),
                  and a default load factor (0.75) and concurrencyLevel (16).                
                <param>
                    m the map                    
                </param>
            </javadoc>
            <method name="ConcurrentHashMap" type="constructor" line="814">
                <params>
                    <param name="m" type="Map<? extends K,? extends V>"/>
                </params>
            </method>
            <javadoc line="821">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.                
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="826">
                <comment line="828">
                    Sum per-segment modCounts to avoid mis-reporting when
                     elements are concurrently added and removed in one segment
                     while checking another, in which case the table was never
                     actually empty at any point. (The sum ensures accuracy up
                     through at least 1&lt;&lt;31 per-segment modifications before
                     recheck.)  Methods size() and containsValue() use similar
                     constructions for stability checks.                    
                </comment>
                <comment line="847">
                    recheck unless no modifications                    
                </comment>
                <declaration name="sum" type="long" line="836"/>
                <declaration name="segments" type="Segment&lt;K,V&gt;[]" line="837"/>
                <scope line="838">
                    <declaration name="seg" type="Segment&lt;K,V&gt;" line="839"/>
                    <scope line="840"/>
                </scope>
                <scope line="846">
                    <scope line="847">
                        <declaration name="seg" type="Segment&lt;K,V&gt;" line="848"/>
                        <scope line="849"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="861">
                Returns the number of key-value mappings in this map.  If the
                  map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns
                  &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.                
                <return>
                    the number of key-value mappings in this map                    
                </return>
            </javadoc>
            <method name="size" type="int" line="868">
                <comment line="870">
                    Try a few times to get accurate count. On failure due to
                     continuous async changes in table, resort to locking.                    
                </comment>
                <comment line="874">
                    true if size overflows 32 bits                    
                </comment>
                <comment line="875">
                    sum of modCounts                    
                </comment>
                <comment line="876">
                    previous sum                    
                </comment>
                <comment line="877">
                    first iteration isn&apos;t retry                    
                </comment>
                <comment line="882">
                    force creation                    
                </comment>
                <declaration name="segments" type="Segment&lt;K,V&gt;[]" line="871"/>
                <declaration name="size" type="int" line="872"/>
                <declaration name="overflow" type="boolean" line="873"/>
                <declaration name="sum" type="long" line="874"/>
                <declaration name="last" type="long" line="875"/>
                <declaration name="retries" type="int" line="876"/>
                <scope line="877">
                    <scope line="878">
                        <scope line="879"/>
                        <scope line="886">
                            <declaration name="seg" type="Segment&lt;K,V&gt;" line="887"/>
                            <scope line="888">
                                <declaration name="c" type="int" line="890"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="899">
                    <scope line="900"/>
                </scope>
            </method>
            <javadoc line="908">
                Returns the value to which the specified key is mapped,
                  or {@code null} if this map contains no mapping for the key.
                  &lt;p&gt;More formally, if this map contains a mapping from a key{@code k} to a value {@code v} such that {@code key.equals(k)},
                  then this method returns {@code v}; otherwise it returns{@code null}.  (There can be at most one such mapping.)                
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="get" type="V" line="919">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <comment line="921">
                    manually integrate access methods to reduce overhead                    
                </comment>
                <declaration name="s" type="Segment&lt;K,V&gt;" line="920"/>
                <declaration name="tab" type="HashEntry&lt;K,V&gt;[]" line="921"/>
                <declaration name="h" type="int" line="922"/>
                <declaration name="u" type="long" line="923"/>
                <scope line="925">
                    <scope line="928">
                        <declaration name="k" type="K" line="929"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="937">
                Tests if the specified object is a key in this table.                
                <param>
                    key   possible key                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if and only if the specified object
                      is a key in this table, as determined by the
                      &lt;tt&gt;equals&lt;/tt&gt; method; &lt;tt&gt;false&lt;/tt&gt; otherwise.                    
                </return>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="containsKey" type="boolean" line="947">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <comment line="949">
                    same as get() except no need for volatile value read                    
                </comment>
                <declaration name="s" type="Segment&lt;K,V&gt;" line="948"/>
                <declaration name="tab" type="HashEntry&lt;K,V&gt;[]" line="949"/>
                <declaration name="h" type="int" line="950"/>
                <declaration name="u" type="long" line="951"/>
                <scope line="953">
                    <scope line="956">
                        <declaration name="k" type="K" line="957"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="965">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
                  specified value. Note: This method requires a full internal
                  traversal of the hash table, and so is much slower than
                  method &lt;tt&gt;containsKey&lt;/tt&gt;.                
                <param>
                    value value whose presence in this map is to be tested                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
                      specified value                    
                </return>
                <throws>
                    NullPointerException if the specified value is null                    
                </throws>
            </javadoc>
            <method name="containsValue" type="boolean" line="976">
                <params>
                    <param name="value" type="Object"/>
                </params>
                <comment line="978">
                    Same idea as size()                    
                </comment>
                <comment line="989">
                    force creation                    
                </comment>
                <declaration name="segments" type="Segment&lt;K,V&gt;[]" line="980"/>
                <declaration name="found" type="boolean" line="981"/>
                <declaration name="last" type="long" line="982"/>
                <declaration name="retries" type="int" line="983"/>
                <scope line="984">
                    <scope line="985">
                        <scope line="986"/>
                        <declaration name="hashSum" type="long" line="990"/>
                        <declaration name="sum" type="int" line="991"/>
                        <scope line="992">
                            <declaration name="tab" type="HashEntry&lt;K,V&gt;[]" line="993"/>
                            <declaration name="seg" type="Segment&lt;K,V&gt;" line="994"/>
                            <scope line="995">
                                <scope line="996">
                                    <declaration name="e" type="HashEntry&lt;K,V&gt;" line="997"/>
                                    <scope line="998">
                                        <declaration name="v" type="V" line="999"/>
                                        <scope line="1000"/>
                                    </scope>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="1013">
                    <scope line="1014"/>
                </scope>
            </method>
            <javadoc line="1022">
                Legacy method testing if some key maps into the specified value
                  in this table.  This method is identical in functionality to{@link #containsValue}, and exists solely to ensure
                  full compatibility with class {@link java.util.Hashtable},
                  which supported this method prior to introduction of the
                  Java Collections framework.                
                <param>
                    value a value to search for                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if and only if some key maps to the
                      &lt;tt&gt;value&lt;/tt&gt; argument in this table as
                      determined by the &lt;tt&gt;equals&lt;/tt&gt; method;
                      &lt;tt&gt;false&lt;/tt&gt; otherwise                    
                </return>
                <throws>
                    NullPointerException if the specified value is null                    
                </throws>
            </javadoc>
            <method name="contains" type="boolean" line="1037">
                <params>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="1041">
                Maps the specified key to the specified value in this table.
                  Neither the key nor the value can be null.
                  &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method
                  with a key that is equal to the original key.                
                <param>
                    key key with which the specified value is to be associated                    
                </param>
                <param>
                    value value to be associated with the specified key                    
                </param>
                <return>
                    the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
                      &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;                    
                </return>
                <throws>
                    NullPointerException if the specified key or value is null                    
                </throws>
            </javadoc>
            <method name="put" type="V" line="1055">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
                <comment line="1062">
                    nonvolatile; recheck                    
                </comment>
                <comment line="1063">
                    in ensureSegment                    
                </comment>
                <declaration name="s" type="Segment&lt;K,V&gt;" line="1056"/>
                <declaration name="hash" type="int" line="1059"/>
                <declaration name="j" type="int" line="1060"/>
            </method>
            <javadoc line="1067">
                {@inheritDoc}                
                <return>
                    the previous value associated with the specified key,
                      or &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key                    
                </return>
                <throws>
                    NullPointerException if the specified key or value is null                    
                </throws>
            </javadoc>
            <method name="putIfAbsent" type="V" line="1075">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
                <declaration name="s" type="Segment&lt;K,V&gt;" line="1076"/>
                <declaration name="hash" type="int" line="1079"/>
                <declaration name="j" type="int" line="1080"/>
            </method>
            <javadoc line="1087">
                Copies all of the mappings from the specified map to this one.
                  These mappings replace any mappings that this map had for any of the
                  keys currently in the specified map.                
                <param>
                    m mappings to be stored in this map                    
                </param>
            </javadoc>
            <method name="putAll" type="void" line="1094">
                <params>
                    <param name="m" type="Map<? extends K,? extends V>"/>
                </params>
            </method>
            <javadoc line="1099">
                Removes the key (and its corresponding value) from this map.
                  This method does nothing if the key is not in the map.                
                <param>
                    key the key that needs to be removed                    
                </param>
                <return>
                    the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
                      &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;                    
                </return>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="remove" type="V" line="1108">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <declaration name="hash" type="int" line="1109"/>
                <declaration name="s" type="Segment&lt;K,V&gt;" line="1110"/>
            </method>
            <javadoc line="1114">
                {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="remove" type="boolean" line="1119">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
                <declaration name="hash" type="int" line="1120"/>
                <declaration name="s" type="Segment&lt;K,V&gt;" line="1121"/>
            </method>
            <javadoc line="1126">
                {@inheritDoc}                
                <throws>
                    NullPointerException if any of the arguments are null                    
                </throws>
            </javadoc>
            <method name="replace" type="boolean" line="1131">
                <params>
                    <param name="key" type="K"/>
                    <param name="oldValue" type="V"/>
                    <param name="newValue" type="V"/>
                </params>
                <declaration name="hash" type="int" line="1132"/>
                <declaration name="s" type="Segment&lt;K,V&gt;" line="1135"/>
            </method>
            <javadoc line="1139">
                {@inheritDoc}                
                <return>
                    the previous value associated with the specified key,
                      or &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key                    
                </return>
                <throws>
                    NullPointerException if the specified key or value is null                    
                </throws>
            </javadoc>
            <method name="replace" type="V" line="1146">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
                <declaration name="hash" type="int" line="1147"/>
                <declaration name="s" type="Segment&lt;K,V&gt;" line="1150"/>
            </method>
            <javadoc line="1154">
                Removes all of the mappings from this map.                
            </javadoc>
            <method name="clear" type="void" line="1157">
                <declaration name="segments" type="Segment&lt;K,V&gt;[]" line="1158"/>
                <scope line="1159">
                    <declaration name="s" type="Segment&lt;K,V&gt;" line="1160"/>
                </scope>
            </method>
            <javadoc line="1166">
                Returns a {@link Set} view of the keys contained in this map.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  The set supports element
                  removal, which removes the corresponding mapping from this map,
                  via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
                  &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
                  operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or
                  &lt;tt&gt;addAll&lt;/tt&gt; operations.
                  &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator
                  that will never throw {@link ConcurrentModificationException},
                  and guarantees to traverse elements as they existed upon
                  construction of the iterator, and may (but is not guaranteed to)
                  reflect any modifications subsequent to construction.                
            </javadoc>
            <method name="keySet" type="Set<K>" line="1182">
                <declaration name="ks" type="Set&lt;K&gt;" line="1183"/>
            </method>
            <javadoc line="1187">
                Returns a {@link Collection} view of the values contained in this map.
                  The collection is backed by the map, so changes to the map are
                  reflected in the collection, and vice-versa.  The collection
                  supports element removal, which removes the corresponding
                  mapping from this map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
                  &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
                  &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not
                  support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
                  &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator
                  that will never throw {@link ConcurrentModificationException},
                  and guarantees to traverse elements as they existed upon
                  construction of the iterator, and may (but is not guaranteed to)
                  reflect any modifications subsequent to construction.                
            </javadoc>
            <method name="values" type="Collection<V>" line="1203">
                <declaration name="vs" type="Collection&lt;V&gt;" line="1204"/>
            </method>
            <javadoc line="1208">
                Returns a {@link Set} view of the mappings contained in this map.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  The set supports element
                  removal, which removes the corresponding mapping from the map,
                  via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
                  &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
                  operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or
                  &lt;tt&gt;addAll&lt;/tt&gt; operations.
                  &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator
                  that will never throw {@link ConcurrentModificationException},
                  and guarantees to traverse elements as they existed upon
                  construction of the iterator, and may (but is not guaranteed to)
                  reflect any modifications subsequent to construction.                
            </javadoc>
            <method name="entrySet" type="Set<Map.Entry<K,V>>" line="1224">
                <declaration name="es" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="1225"/>
            </method>
            <javadoc line="1229">
                Returns an enumeration of the keys in this table.                
                <return>
                    an enumeration of the keys in this table                    
                </return>
                <see>
                    #keySet()                    
                </see>
            </javadoc>
            <method name="keys" type="Enumeration<K>" line="1235"/>
            <javadoc line="1239">
                Returns an enumeration of the values in this table.                
                <return>
                    an enumeration of the values in this table                    
                </return>
                <see>
                    #values()                    
                </see>
            </javadoc>
            <method name="elements" type="Enumeration<V>" line="1245"/>
            <class name="HashIterator" line="1251">
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <declaration name="nextSegmentIndex" type="int" line="1252"/>
                <declaration name="nextTableIndex" type="int" line="1253"/>
                <declaration name="currentTable" type="HashEntry&lt;K,V&gt;[]" line="1254"/>
                <declaration name="nextEntry" type="HashEntry&lt;K,V&gt;" line="1255"/>
                <declaration name="lastReturned" type="HashEntry&lt;K,V&gt;" line="1256"/>
                <method name="HashIterator" type="constructor" line="1258"/>
                <javadoc line="1264">
                    Set nextEntry to first node of next non-empty table
                      (in backwards order, to simplify checks).                    
                </javadoc>
                <method name="advance" type="void" line="1268">
                    <scope line="1269">
                        <scope line="1270"/>
                        <scope line="1275">
                            <declaration name="seg" type="Segment&lt;K,V&gt;" line="1276"/>
                        </scope>
                    </scope>
                </method>
                <method name="nextEntry" type="HashEntry<K,V>" line="1285">
                    <comment line="1290">
                        cannot assign until after null check                        
                    </comment>
                    <declaration name="e" type="HashEntry&lt;K,V&gt;" line="1286"/>
                </method>
                <method name="hasNext" type="boolean" line="1295"/>
                <method name="hasMoreElements" type="boolean" line="1296"/>
                <method name="remove" type="void" line="1298"/>
            </class>
            <class name="KeyIterator" line="1306">
                <extends class="HashIterator"/>
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </implements>
                <implements interface="Enumeration">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </implements>
                <method name="next" type="K" line="1310"/>
                <method name="nextElement" type="K" line="1311"/>
            </class>
            <class name="ValueIterator" line="1314">
                <extends class="HashIterator"/>
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <implements interface="Enumeration">
                    <type_params>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <method name="next" type="V" line="1318"/>
                <method name="nextElement" type="V" line="1319"/>
            </class>
            <class name="WriteThroughEntry" line="1322">
                <extends class="AbstractMap.SimpleEntry">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <javadoc line="1322">
                    Custom Entry class used by EntryIterator.next(), that relays
                      setValue changes to the underlying map.                    
                </javadoc>
                <method name="WriteThroughEntry" type="constructor" line="1329">
                    <params>
                        <param name="k" type="K"/>
                        <param name="v" type="V"/>
                    </params>
                </method>
                <javadoc line="1333">
                    Set our entry&apos;s value and write through to the map. The
                      value to return is somewhat arbitrary here. Since a
                      WriteThroughEntry does not necessarily track asynchronous
                      changes, the most recent &quot;previous&quot; value could be
                      different from what we return (or could even have been
                      removed in which case the put will re-establish). We do not
                      and cannot guarantee more.                    
                </javadoc>
                <method name="setValue" type="V" line="1342">
                    <params>
                        <param name="value" type="V"/>
                    </params>
                    <declaration name="v" type="V" line="1344"/>
                </method>
            </class>
            <class name="EntryIterator" line="1350">
                <extends class="HashIterator"/>
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="Entry<K,V>"/>
                    </type_params>
                </implements>
                <method name="next" type="Map.Entry<K,V>" line="1354">
                    <declaration name="e" type="HashEntry&lt;K,V&gt;" line="1355"/>
                </method>
            </class>
            <class name="KeySet" line="1360">
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </extends>
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <method name="iterator" type="Iterator<K>" line="1361"/>
                <method name="size" type="int" line="1364"/>
                <method name="isEmpty" type="boolean" line="1367"/>
                <method name="contains" type="boolean" line="1370">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="1373">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="1376"/>
            </class>
            <class name="Values" line="1381">
                <extends class="AbstractCollection">
                    <type_params>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <method name="iterator" type="Iterator<V>" line="1382"/>
                <method name="size" type="int" line="1385"/>
                <method name="isEmpty" type="boolean" line="1388"/>
                <method name="contains" type="boolean" line="1391">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="1394"/>
            </class>
            <class name="EntrySet" line="1399">
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="Map.Entry<K,V>"/>
                    </type_params>
                </extends>
                <comment line="226">
                    Unsafe mechanics                    
                </comment>
                <comment line="286">
                    Segments maintain a table of entry lists that are always
                     kept in a consistent state, so can be read (via volatile
                     reads of segments and tables) without locking.  This
                     requires replicating nodes when necessary during table
                     resizing, so the old lists can be traversed by readers
                     still using old version of table.
                    
                     This class defines only mutative methods requiring locking.
                     Except as noted, the methods of this class perform the
                     per-segment versions of ConcurrentHashMap methods.  (Other
                     methods are integrated directly into ConcurrentHashMap
                     methods.) These mutative methods use a form of controlled
                     spinning on contention via methods scanAndLock and
                     scanAndLockForPut. These intersperse tryLocks with
                     traversals to locate nodes.  The main benefit is to absorb
                     cache misses (which are very common for hash tables) while
                     obtaining locks so that traversal is faster once
                     acquired. We do not actually use the found nodes since they
                     must be re-acquired under lock anyway to ensure sequential
                     consistency of updates (and in any case may be undetectably
                     stale), but they will normally be much faster to re-locate.
                     Also, scanAndLockForPut speculatively creates a fresh node
                     to use in put if no node is found.                    
                </comment>
                <method name="iterator" type="Iterator<Map.Entry<K,V>>" line="1400"/>
                <method name="contains" type="boolean" line="1403">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="e" type="Map.Entry&lt;?,?&gt;" line="1406"/>
                    <declaration name="v" type="V" line="1407"/>
                </method>
                <method name="remove" type="boolean" line="1410">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="e" type="Map.Entry&lt;?,?&gt;" line="1413"/>
                </method>
                <method name="size" type="int" line="1416"/>
                <method name="isEmpty" type="boolean" line="1419"/>
                <method name="clear" type="void" line="1422"/>
            </class>
            <javadoc line="1429">
                Save the state of the &lt;tt&gt;ConcurrentHashMap&lt;/tt&gt; instance to a
                  stream (i.e., serialize it).                
                <param>
                    s the stream                    
                </param>
                <serialData>
                    the key (Object) and value (Object)
                      for each key-value mapping, followed by a null pair.
                      The key-value mappings are emitted in no particular order.                    
                </serialData>
            </javadoc>
            <method name="writeObject" type="void" line="1438">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <comment line="1440">
                    force all segments for serialization compatibility                    
                </comment>
                <declaration name="segments" type="Segment&lt;K,V&gt;[]" line="1444"/>
                <scope line="1445">
                    <declaration name="seg" type="Segment&lt;K,V&gt;" line="1446"/>
                    <scope line="1448">
                        <declaration name="tab" type="HashEntry&lt;K,V&gt;[]" line="1449"/>
                        <scope line="1450">
                            <declaration name="e" type="HashEntry&lt;K,V&gt;" line="1451"/>
                            <scope line="1452"/>
                        </scope>
                    </scope>
                    <scope line="1457"/>
                </scope>
            </method>
            <javadoc line="1465">
                Reconstitute the &lt;tt&gt;ConcurrentHashMap&lt;/tt&gt; instance from a
                  stream (i.e., deserialize it).                
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="1472">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="1476">
                    Re-initialize segments to be minimally sized, and let grow.                    
                </comment>
                <comment line="1487">
                    Read the keys and values, and put the mappings in the table                    
                </comment>
                <declaration name="cap" type="int" line="1476"/>
                <declaration name="segments" type="Segment&lt;K,V&gt;[]" line="1477"/>
                <scope line="1478">
                    <declaration name="seg" type="Segment&lt;K,V&gt;" line="1479"/>
                    <scope line="1480"/>
                </scope>
                <scope line="1487">
                    <declaration name="key" type="K" line="1488"/>
                    <declaration name="value" type="V" line="1489"/>
                </scope>
            </method>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="1497"/>
            <declaration name="SBASE" type="long" line="1498"/>
            <declaration name="SSHIFT" type="int" line="1499"/>
            <declaration name="TBASE" type="long" line="1500"/>
            <declaration name="TSHIFT" type="int" line="1501"/>
            <scope line="1503">
                <declaration name="ss" type="int" line="1504"/>
                <scope line="1505">
                    <declaration name="tc" type="Class" line="1507"/>
                    <declaration name="sc" type="Class" line="1508"/>
                </scope>
                <scope line="1513"/>
            </scope>
        </class>
    </source>