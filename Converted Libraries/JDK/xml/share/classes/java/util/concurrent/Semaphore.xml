<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util"/>
        <import package="java.util.concurrent.locks"/>
        <import package="java.util.concurrent.atomic"/>
        <class name="Semaphore" line="5">
            <implements interface="java.io.Serializable"/>
            <javadoc line="5">
                A counting semaphore.  Conceptually, a semaphore maintains a set of
                  permits.  Each {@link #acquire} blocks if necessary until a permit is
                  available, and then takes it.  Each {@link #release} adds a permit,
                  potentially releasing a blocking acquirer.
                  However, no actual permit objects are used; the {@code Semaphore} just
                  keeps a count of the number available and acts accordingly.
                  &lt;p&gt;Semaphores are often used to restrict the number of threads than can
                  access some (physical or logical) resource. For example, here is
                  a class that uses a semaphore to control access to a pool of items:
                  &lt;pre&gt;
                  class Pool {
                  private static final int MAX_AVAILABLE = 100;
                  private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);
                  public Object getItem() throws InterruptedException {
                  available.acquire();
                  return getNextAvailableItem();
                  }
                  public void putItem(Object x) {
                  if (markAsUnused(x))
                  available.release();
                  }
                  // Not a particularly efficient data structure; just for demo
                  protected Object[] items = ... whatever kinds of items being managed
                  protected boolean[] used = new boolean[MAX_AVAILABLE];
                  protected synchronized Object getNextAvailableItem() {
                  for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {
                  if (!used[i]) {
                  used[i] = true;
                  return items[i];
                  }
                  }
                  return null; // not reached
                  }
                  protected synchronized boolean markAsUnused(Object item) {
                  for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {
                  if (item == items[i]) {
                  if (used[i]) {
                  used[i] = false;
                  return true;
                  } else
                  return false;
                  }
                  }
                  return false;
                  }
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;Before obtaining an item each thread must acquire a permit from
                  the semaphore, guaranteeing that an item is available for use. When
                  the thread has finished with the item it is returned back to the
                  pool and a permit is returned to the semaphore, allowing another
                  thread to acquire that item.  Note that no synchronization lock is
                  held when {@link #acquire} is called as that would prevent an item
                  from being returned to the pool.  The semaphore encapsulates the
                  synchronization needed to restrict access to the pool, separately
                  from any synchronization needed to maintain the consistency of the
                  pool itself.
                  &lt;p&gt;A semaphore initialized to one, and which is used such that it
                  only has at most one permit available, can serve as a mutual
                  exclusion lock.  This is more commonly known as a &lt;em&gt;binary
                  semaphore&lt;/em&gt;, because it only has two states: one permit
                  available, or zero permits available.  When used in this way, the
                  binary semaphore has the property (unlike many {@link Lock}implementations), that the &amp;quot;lock&amp;quot; can be released by a
                  thread other than the owner (as semaphores have no notion of
                  ownership).  This can be useful in some specialized contexts, such
                  as deadlock recovery.
                  &lt;p&gt; The constructor for this class optionally accepts a
                  &lt;em&gt;fairness&lt;/em&gt; parameter. When set false, this class makes no
                  guarantees about the order in which threads acquire permits. In
                  particular, &lt;em&gt;barging&lt;/em&gt; is permitted, that is, a thread
                  invoking {@link #acquire} can be allocated a permit ahead of a
                  thread that has been waiting - logically the new thread places itself at
                  the head of the queue of waiting threads. When fairness is set true, the
                  semaphore guarantees that threads invoking any of the {@link #acquire() acquire} methods are selected to obtain permits in the order in
                  which their invocation of those methods was processed
                  (first-in-first-out; FIFO). Note that FIFO ordering necessarily
                  applies to specific internal points of execution within these
                  methods.  So, it is possible for one thread to invoke{@code acquire} before another, but reach the ordering point after
                  the other, and similarly upon return from the method.
                  Also note that the untimed {@link #tryAcquire() tryAcquire} methods do not
                  honor the fairness setting, but will take any permits that are
                  available.
                  &lt;p&gt;Generally, semaphores used to control resource access should be
                  initialized as fair, to ensure that no thread is starved out from
                  accessing a resource. When using semaphores for other kinds of
                  synchronization control, the throughput advantages of non-fair
                  ordering often outweigh fairness considerations.
                  &lt;p&gt;This class also provides convenience methods to {@link #acquire(int) acquire} and {@link #release(int) release} multiple
                  permits at a time.  Beware of the increased risk of indefinite
                  postponement when these methods are used without fairness set true.
                  &lt;p&gt;Memory consistency effects: Actions in a thread prior to calling
                  a &quot;release&quot; method such as {@code release()}&lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                  actions following a successful &quot;acquire&quot; method such as {@code acquire()}in another thread.                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="103"/>
            <declaration name="sync" type="Sync" line="104"/>
            <javadoc line="104">
                All mechanics via AbstractQueuedSynchronizer subclass                
            </javadoc>
            <class name="Sync" line="108">
                <extends class="AbstractQueuedSynchronizer"/>
                <javadoc line="108">
                    Synchronization implementation for semaphore.  Uses AQS state
                      to represent permits. Subclassed into fair and nonfair
                      versions.                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="114"/>
                <method name="Sync" type="constructor" line="115">
                    <params>
                        <param name="permits" type="int"/>
                    </params>
                </method>
                <method name="getPermits" type="int" line="118"/>
                <method name="nonfairTryAcquireShared" type="int" line="121">
                    <params>
                        <param name="acquires" type="int"/>
                    </params>
                    <scope line="122">
                        <declaration name="available" type="int" line="123"/>
                        <declaration name="remaining" type="int" line="124"/>
                    </scope>
                </method>
                <method name="tryReleaseShared" type="boolean" line="128">
                    <params>
                        <param name="releases" type="int"/>
                    </params>
                    <scope line="129">
                        <declaration name="current" type="int" line="130"/>
                        <declaration name="next" type="int" line="131"/>
                    </scope>
                </method>
                <method name="reducePermits" type="void" line="136">
                    <params>
                        <param name="reductions" type="int"/>
                    </params>
                    <scope line="137">
                        <declaration name="current" type="int" line="138"/>
                        <declaration name="next" type="int" line="139"/>
                    </scope>
                </method>
                <method name="drainPermits" type="int" line="144">
                    <scope line="145">
                        <declaration name="current" type="int" line="146"/>
                    </scope>
                </method>
            </class>
            <class name="NonfairSync" line="151">
                <extends class="Sync"/>
                <javadoc line="151">
                    NonFair version                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="155"/>
                <method name="NonfairSync" type="constructor" line="156">
                    <params>
                        <param name="permits" type="int"/>
                    </params>
                </method>
                <method name="tryAcquireShared" type="int" line="159">
                    <params>
                        <param name="acquires" type="int"/>
                    </params>
                </method>
            </class>
            <class name="FairSync" line="163">
                <extends class="Sync"/>
                <javadoc line="163">
                    Fair version                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="167"/>
                <method name="FairSync" type="constructor" line="168">
                    <params>
                        <param name="permits" type="int"/>
                    </params>
                </method>
                <method name="tryAcquireShared" type="int" line="171">
                    <params>
                        <param name="acquires" type="int"/>
                    </params>
                    <scope line="172">
                        <declaration name="available" type="int" line="174"/>
                        <declaration name="remaining" type="int" line="175"/>
                    </scope>
                </method>
            </class>
            <javadoc line="180">
                Creates a {@code Semaphore} with the given number of
                  permits and nonfair fairness setting.                
                <param>
                    permits the initial number of permits available.
                      This value may be negative, in which case releases
                      must occur before any acquires will be granted.                    
                </param>
            </javadoc>
            <method name="Semaphore" type="constructor" line="187">
                <params>
                    <param name="permits" type="int"/>
                </params>
            </method>
            <javadoc line="190">
                Creates a {@code Semaphore} with the given number of
                  permits and the given fairness setting.                
                <param>
                    permits the initial number of permits available.
                      This value may be negative, in which case releases
                      must occur before any acquires will be granted.                    
                </param>
                <param>
                    fair {@code true} if this semaphore will guarantee
                      first-in first-out granting of permits under contention,
                      else {@code false}                    
                </param>
            </javadoc>
            <method name="Semaphore" type="constructor" line="200">
                <params>
                    <param name="permits" type="int"/>
                    <param name="fair" type="boolean"/>
                </params>
            </method>
            <javadoc line="203">
                Acquires a permit from this semaphore, blocking until one is
                  available, or the thread is {@linkplain Thread#interrupt interrupted}.
                  &lt;p&gt;Acquires a permit, if one is available and returns immediately,
                  reducing the number of available permits by one.
                  &lt;p&gt;If no permit is available then the current thread becomes
                  disabled for thread scheduling purposes and lies dormant until
                  one of two things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes the {@link #release} method for this
                  semaphore and the current thread is next to be assigned a permit; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread.
                  &lt;/ul&gt;
                  &lt;p&gt;If the current thread:
                  &lt;ul&gt;
                  &lt;li&gt;has its interrupted status set on entry to this method; or
                  &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
                  for a permit,
                  &lt;/ul&gt;
                  then {@link InterruptedException} is thrown and the current thread&apos;s
                  interrupted status is cleared.                
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="acquire" type="void" line="226"/>
            <javadoc line="229">
                Acquires a permit from this semaphore, blocking until one is
                  available.
                  &lt;p&gt;Acquires a permit, if one is available and returns immediately,
                  reducing the number of available permits by one.
                  &lt;p&gt;If no permit is available then the current thread becomes
                  disabled for thread scheduling purposes and lies dormant until
                  some other thread invokes the {@link #release} method for this
                  semaphore and the current thread is next to be assigned a permit.
                  &lt;p&gt;If the current thread is {@linkplain Thread#interrupt interrupted}while waiting for a permit then it will continue to wait, but the
                  time at which the thread is assigned a permit may change compared to
                  the time it would have received the permit had no interruption
                  occurred.  When the thread does return from this method its interrupt
                  status will be set.                
            </javadoc>
            <method name="acquireUninterruptibly" type="void" line="244"/>
            <javadoc line="247">
                Acquires a permit from this semaphore, only if one is available at the
                  time of invocation.
                  &lt;p&gt;Acquires a permit, if one is available and returns immediately,
                  with the value {@code true},
                  reducing the number of available permits by one.
                  &lt;p&gt;If no permit is available then this method will return
                  immediately with the value {@code false}.
                  &lt;p&gt;Even when this semaphore has been set to use a
                  fair ordering policy, a call to {@code tryAcquire()} &lt;em&gt;will&lt;/em&gt;
                  immediately acquire a permit if one is available, whether or not
                  other threads are currently waiting.
                  This &amp;quot;barging&amp;quot; behavior can be useful in certain
                  circumstances, even though it breaks fairness. If you want to honor
                  the fairness setting, then use{@link #tryAcquire(long,TimeUnit) tryAcquire(0, TimeUnit.SECONDS) }which is almost equivalent (it also detects interruption).                
                <return>
                    {@code true} if a permit was acquired and {@code false}otherwise                    
                </return>
            </javadoc>
            <method name="tryAcquire" type="boolean" line="264"/>
            <javadoc line="267">
                Acquires a permit from this semaphore, if one becomes available
                  within the given waiting time and the current thread has not
                  been {@linkplain Thread#interrupt interrupted}.
                  &lt;p&gt;Acquires a permit, if one is available and returns immediately,
                  with the value {@code true},
                  reducing the number of available permits by one.
                  &lt;p&gt;If no permit is available then the current thread becomes
                  disabled for thread scheduling purposes and lies dormant until
                  one of three things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes the {@link #release} method for this
                  semaphore and the current thread is next to be assigned a permit; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread; or
                  &lt;li&gt;The specified waiting time elapses.
                  &lt;/ul&gt;
                  &lt;p&gt;If a permit is acquired then the value {@code true} is returned.
                  &lt;p&gt;If the current thread:
                  &lt;ul&gt;
                  &lt;li&gt;has its interrupted status set on entry to this method; or
                  &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
                  to acquire a permit,
                  &lt;/ul&gt;
                  then {@link InterruptedException} is thrown and the current thread&apos;s
                  interrupted status is cleared.
                  &lt;p&gt;If the specified waiting time elapses then the value {@code false}is returned.  If the time is less than or equal to zero, the method
                  will not wait at all.                
                <param>
                    timeout the maximum time to wait for a permit                    
                </param>
                <param>
                    unit the time unit of the {@code timeout} argument                    
                </param>
                <return>
                    {@code true} if a permit was acquired and {@code false}if the waiting time elapsed before a permit was acquired                    
                </return>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="tryAcquire" type="boolean" line="299">
                <params>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
            </method>
            <javadoc line="302">
                Releases a permit, returning it to the semaphore.
                  &lt;p&gt;Releases a permit, increasing the number of available permits by
                  one.  If any threads are trying to acquire a permit, then one is
                  selected and given the permit that was just released.  That thread
                  is (re)enabled for thread scheduling purposes.
                  &lt;p&gt;There is no requirement that a thread that releases a permit must
                  have acquired that permit by calling {@link #acquire}.
                  Correct usage of a semaphore is established by programming convention
                  in the application.                
            </javadoc>
            <method name="release" type="void" line="313"/>
            <javadoc line="316">
                Acquires the given number of permits from this semaphore,
                  blocking until all are available,
                  or the thread is {@linkplain Thread#interrupt interrupted}.
                  &lt;p&gt;Acquires the given number of permits, if they are available,
                  and returns immediately, reducing the number of available permits
                  by the given amount.
                  &lt;p&gt;If insufficient permits are available then the current thread becomes
                  disabled for thread scheduling purposes and lies dormant until
                  one of two things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes one of the {@link #release() release}methods for this semaphore, the current thread is next to be assigned
                  permits and the number of available permits satisfies this request; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread.
                  &lt;/ul&gt;
                  &lt;p&gt;If the current thread:
                  &lt;ul&gt;
                  &lt;li&gt;has its interrupted status set on entry to this method; or
                  &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
                  for a permit,
                  &lt;/ul&gt;
                  then {@link InterruptedException} is thrown and the current thread&apos;s
                  interrupted status is cleared.
                  Any permits that were to be assigned to this thread are instead
                  assigned to other threads trying to acquire permits, as if
                  permits had been made available by a call to {@link #release()}.                
                <param>
                    permits the number of permits to acquire                    
                </param>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code permits} is negative                    
                </throws>
            </javadoc>
            <method name="acquire" type="void" line="346">
                <params>
                    <param name="permits" type="int"/>
                </params>
            </method>
            <javadoc line="350">
                Acquires the given number of permits from this semaphore,
                  blocking until all are available.
                  &lt;p&gt;Acquires the given number of permits, if they are available,
                  and returns immediately, reducing the number of available permits
                  by the given amount.
                  &lt;p&gt;If insufficient permits are available then the current thread becomes
                  disabled for thread scheduling purposes and lies dormant until
                  some other thread invokes one of the {@link #release() release}methods for this semaphore, the current thread is next to be assigned
                  permits and the number of available permits satisfies this request.
                  &lt;p&gt;If the current thread is {@linkplain Thread#interrupt interrupted}while waiting for permits then it will continue to wait and its
                  position in the queue is not affected.  When the thread does return
                  from this method its interrupt status will be set.                
                <param>
                    permits the number of permits to acquire                    
                </param>
                <throws>
                    IllegalArgumentException if {@code permits} is negative                    
                </throws>
            </javadoc>
            <method name="acquireUninterruptibly" type="void" line="366">
                <params>
                    <param name="permits" type="int"/>
                </params>
            </method>
            <javadoc line="370">
                Acquires the given number of permits from this semaphore, only
                  if all are available at the time of invocation.
                  &lt;p&gt;Acquires the given number of permits, if they are available, and
                  returns immediately, with the value {@code true},
                  reducing the number of available permits by the given amount.
                  &lt;p&gt;If insufficient permits are available then this method will return
                  immediately with the value {@code false} and the number of available
                  permits is unchanged.
                  &lt;p&gt;Even when this semaphore has been set to use a fair ordering
                  policy, a call to {@code tryAcquire} &lt;em&gt;will&lt;/em&gt;
                  immediately acquire a permit if one is available, whether or
                  not other threads are currently waiting.  This
                  &amp;quot;barging&amp;quot; behavior can be useful in certain
                  circumstances, even though it breaks fairness. If you want to
                  honor the fairness setting, then use {@link #tryAcquire(int,long,TimeUnit) tryAcquire(permits, 0, TimeUnit.SECONDS) }which is almost equivalent (it also detects interruption).                
                <param>
                    permits the number of permits to acquire                    
                </param>
                <return>
                    {@code true} if the permits were acquired and{@code false} otherwise                    
                </return>
                <throws>
                    IllegalArgumentException if {@code permits} is negative                    
                </throws>
            </javadoc>
            <method name="tryAcquire" type="boolean" line="390">
                <params>
                    <param name="permits" type="int"/>
                </params>
            </method>
            <javadoc line="394">
                Acquires the given number of permits from this semaphore, if all
                  become available within the given waiting time and the current
                  thread has not been {@linkplain Thread#interrupt interrupted}.
                  &lt;p&gt;Acquires the given number of permits, if they are available and
                  returns immediately, with the value {@code true},
                  reducing the number of available permits by the given amount.
                  &lt;p&gt;If insufficient permits are available then
                  the current thread becomes disabled for thread scheduling
                  purposes and lies dormant until one of three things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes one of the {@link #release() release}methods for this semaphore, the current thread is next to be assigned
                  permits and the number of available permits satisfies this request; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread; or
                  &lt;li&gt;The specified waiting time elapses.
                  &lt;/ul&gt;
                  &lt;p&gt;If the permits are acquired then the value {@code true} is returned.
                  &lt;p&gt;If the current thread:
                  &lt;ul&gt;
                  &lt;li&gt;has its interrupted status set on entry to this method; or
                  &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
                  to acquire the permits,
                  &lt;/ul&gt;
                  then {@link InterruptedException} is thrown and the current thread&apos;s
                  interrupted status is cleared.
                  Any permits that were to be assigned to this thread, are instead
                  assigned to other threads trying to acquire permits, as if
                  the permits had been made available by a call to {@link #release()}.
                  &lt;p&gt;If the specified waiting time elapses then the value {@code false}is returned.  If the time is less than or equal to zero, the method
                  will not wait at all.  Any permits that were to be assigned to this
                  thread, are instead assigned to other threads trying to acquire
                  permits, as if the permits had been made available by a call to{@link #release()}.                
                <param>
                    permits the number of permits to acquire                    
                </param>
                <param>
                    timeout the maximum time to wait for the permits                    
                </param>
                <param>
                    unit the time unit of the {@code timeout} argument                    
                </param>
                <return>
                    {@code true} if all permits were acquired and {@code false}if the waiting time elapsed before all permits were acquired                    
                </return>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code permits} is negative                    
                </throws>
            </javadoc>
            <method name="tryAcquire" type="boolean" line="433">
                <params>
                    <param name="permits" type="int"/>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
            </method>
            <javadoc line="437">
                Releases the given number of permits, returning them to the semaphore.
                  &lt;p&gt;Releases the given number of permits, increasing the number of
                  available permits by that amount.
                  If any threads are trying to acquire permits, then one
                  is selected and given the permits that were just released.
                  If the number of available permits satisfies that thread&apos;s request
                  then that thread is (re)enabled for thread scheduling purposes;
                  otherwise the thread will wait until sufficient permits are available.
                  If there are still permits available
                  after this thread&apos;s request has been satisfied, then those permits
                  are assigned in turn to other threads trying to acquire permits.
                  &lt;p&gt;There is no requirement that a thread that releases a permit must
                  have acquired that permit by calling {@link Semaphore#acquire acquire}.
                  Correct usage of a semaphore is established by programming convention
                  in the application.                
                <param>
                    permits the number of permits to release                    
                </param>
                <throws>
                    IllegalArgumentException if {@code permits} is negative                    
                </throws>
            </javadoc>
            <method name="release" type="void" line="456">
                <params>
                    <param name="permits" type="int"/>
                </params>
            </method>
            <javadoc line="460">
                Returns the current number of permits available in this semaphore.
                  &lt;p&gt;This method is typically used for debugging and testing purposes.                
                <return>
                    the number of permits available in this semaphore                    
                </return>
            </javadoc>
            <method name="availablePermits" type="int" line="465"/>
            <javadoc line="468">
                Acquires and returns all permits that are immediately available.                
                <return>
                    the number of permits acquired                    
                </return>
            </javadoc>
            <method name="drainPermits" type="int" line="472"/>
            <javadoc line="475">
                Shrinks the number of available permits by the indicated
                  reduction. This method can be useful in subclasses that use
                  semaphores to track resources that become unavailable. This
                  method differs from {@code acquire} in that it does not block
                  waiting for permits to become available.                
                <param>
                    reduction the number of permits to remove                    
                </param>
                <throws>
                    IllegalArgumentException if {@code reduction} is negative                    
                </throws>
            </javadoc>
            <method name="reducePermits" type="void" line="484">
                <params>
                    <param name="reduction" type="int"/>
                </params>
            </method>
            <javadoc line="488">
                Returns {@code true} if this semaphore has fairness set true.                
                <return>
                    {@code true} if this semaphore has fairness set true                    
                </return>
            </javadoc>
            <method name="isFair" type="boolean" line="492"/>
            <javadoc line="495">
                Queries whether any threads are waiting to acquire. Note that
                  because cancellations may occur at any time, a {@code true}return does not guarantee that any other thread will ever
                  acquire.  This method is designed primarily for use in
                  monitoring of the system state.                
                <return>
                    {@code true} if there may be other threads waiting to
                      acquire the lock                    
                </return>
            </javadoc>
            <method name="hasQueuedThreads" type="boolean" line="503"/>
            <javadoc line="506">
                Returns an estimate of the number of threads waiting to acquire.
                  The value is only an estimate because the number of threads may
                  change dynamically while this method traverses internal data
                  structures.  This method is designed for use in monitoring of the
                  system state, not for synchronization control.                
                <return>
                    the estimated number of threads waiting for this lock                    
                </return>
            </javadoc>
            <method name="getQueueLength" type="int" line="514"/>
            <javadoc line="517">
                Returns a collection containing threads that may be waiting to acquire.
                  Because the actual set of threads may change dynamically while
                  constructing this result, the returned collection is only a best-effort
                  estimate.  The elements of the returned collection are in no particular
                  order.  This method is designed to facilitate construction of
                  subclasses that provide more extensive monitoring facilities.                
                <return>
                    the collection of threads                    
                </return>
            </javadoc>
            <method name="getQueuedThreads" type="Collection&lt;Thread&gt;" line="526"/>
            <javadoc line="529">
                Returns a string identifying this semaphore, as well as its state.
                  The state, in brackets, includes the String {@code &quot;Permits =&quot;}followed by the number of permits.                
                <return>
                    a string identifying this semaphore, as well as its state                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="534"/>
        </class>
    </source>