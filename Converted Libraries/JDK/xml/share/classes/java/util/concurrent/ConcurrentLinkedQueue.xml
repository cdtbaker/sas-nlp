<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.AbstractQueue"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="java.util.Queue"/>
        <class name="ConcurrentLinkedQueue" line="45">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="AbstractQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <comment line="108">
                This is a modification of the Michael &amp; Scott algorithm,
                 adapted for a garbage-collected environment, with support for
                 interior node deletion (to support remove(Object)).  For
                 explanation, read the paper.
                
                 Note that like most non-blocking algorithms in this package,
                 this implementation relies on the fact that in garbage
                 collected systems, there is no possibility of ABA problems due
                 to recycled nodes, so there is no need to use &quot;counted
                 pointers&quot; or related techniques seen in versions used in
                 non-GC&apos;ed settings.
                
                 The fundamental invariants are:
                 - There is exactly one (last) Node with a null next reference,
                   which is CASed when enqueueing.  This last Node can be
                   reached in O(1) time from tail, but tail is merely an
                   optimization - it can always be reached in O(N) time from
                   head as well.
                 - The elements contained in the queue are the non-null items in
                   Nodes that are reachable from head.  CASing the item
                   reference of a Node to null atomically removes it from the
                   queue.  Reachability of all elements from head must remain
                   true even in the case of concurrent modifications that cause
                   head to advance.  A dequeued Node may remain in use
                   indefinitely due to creation of an Iterator or simply a
                   poll() that has lost its time slice.
                
                 The above might appear to imply that all Nodes are GC-reachable
                 from a predecessor dequeued Node.  That would cause two problems:
                 - allow a rogue Iterator to cause unbounded memory retention
                 - cause cross-generational linking of old Nodes to new Nodes if
                   a Node was tenured while live, which generational GCs have a
                   hard time dealing with, causing repeated major collections.
                 However, only non-deleted Nodes need to be reachable from
                 dequeued Nodes, and reachability does not necessarily have to
                 be of the kind understood by the GC.  We use the trick of
                 linking a Node that has just been dequeued to itself.  Such a
                 self-link implicitly means to advance to head.
                
                 Both head and tail are permitted to lag.  In fact, failing to
                 update them every time one could is a significant optimization
                 (fewer CASes). As with LinkedTransferQueue (see the internal
                 documentation for that class), we use a slack threshold of two;
                 that is, we update headtail when the current pointer appears
                 to be two or more steps away from the firstlast node.
                
                 Since head and tail are updated concurrently and independently,
                 it is possible for tail to lag behind head (why not)?
                
                 CASing a Node&apos;s item reference to null atomically removes the
                 element from the queue.  Iterators skip over Nodes with null
                 items.  Prior implementations of this class had a race between
                 poll() and remove(Object) where the same element would appear
                 to be successfully removed by two concurrent operations.  The
                 method remove(Object) also lazily unlinks deleted Nodes, but
                 this is merely an optimization.
                
                 When constructing a Node (before enqueuing it) we avoid paying
                 for a volatile write to item by using Unsafe.putObject instead
                 of a normal write.  This allows the cost of enqueue to be
                 &quot;one-and-a-half&quot; CASes.
                
                 Both head and tail may or may not point to a Node with a
                 non-null item.  If the queue is empty, all items must of course
                 be null.  Upon creation, both head and tail refer to a dummy
                 Node with null item.  Both head and tail are only updated using
                 CAS, so they never regress, although again this is merely an
                 optimization.                
            </comment>
            <comment line="286">
                Have to override just to update the javadoc                
            </comment>
            <comment line="819">
                Unsafe mechanics                
            </comment>
            <implements interface="Queue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </implements>
            <implements interface="java.io.Serializable"/>
            <javadoc line="45">
                An unbounded thread-safe {@linkplain Queue queue} based on linked nodes.
                  This queue orders elements FIFO (first-in-first-out).
                  The &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the
                  queue the longest time.
                  The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has been on the
                  queue the shortest time. New elements
                  are inserted at the tail of the queue, and the queue retrieval
                  operations obtain elements at the head of the queue.
                  A {@code ConcurrentLinkedQueue} is an appropriate choice when
                  many threads will share access to a common collection.
                  Like most other concurrent collection implementations, this class
                  does not permit the use of {@code null} elements.
                  &lt;p&gt;This implementation employs an efficient &amp;quot;wait-free&amp;quot;
                  algorithm based on one described in &lt;a
                  href=&quot;http://www.cs.rochester.edu/u/michael/PODC96.html&quot;&gt; Simple,
                  Fast, and Practical Non-Blocking and Blocking Concurrent Queue
                  Algorithms&lt;/a&gt; by Maged M. Michael and Michael L. Scott.
                  &lt;p&gt;Iterators are &lt;i&gt;weakly consistent&lt;/i&gt;, returning elements
                  reflecting the state of the queue at some point at or since the
                  creation of the iterator.  They do &lt;em&gt;not&lt;/em&gt; throw {@link java.util.ConcurrentModificationException}, and may proceed concurrently
                  with other operations.  Elements contained in the queue since the creation
                  of the iterator will be returned exactly once.
                  &lt;p&gt;Beware that, unlike in most collections, the {@code size} method
                  is &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these queues, determining the current number
                  of elements requires a traversal of the elements, and so may report
                  inaccurate results if this collection is modified during traversal.
                  Additionally, the bulk operations {@code addAll},{@code removeAll}, {@code retainAll}, {@code containsAll},{@code equals}, and {@code toArray} are &lt;em&gt;not&lt;/em&gt; guaranteed
                  to be performed atomically. For example, an iterator operating
                  concurrently with an {@code addAll} operation might view only some
                  of the added elements.
                  &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                  methods of the {@link Queue} and {@link Iterator} interfaces.
                  &lt;p&gt;Memory consistency effects: As with other concurrent
                  collections, actions in a thread prior to placing an object into a{@code ConcurrentLinkedQueue}&lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                  actions subsequent to the access or removal of that element from
                  the {@code ConcurrentLinkedQueue} in another thread.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea                    
                </author>
                <param>
                    &lt;E&gt;
                       the type of elements held in this collection                    
                </param>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="105"/>
            <class name="Node" line="178">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <comment line="203">
                    Unsafe mechanics                    
                </comment>
                <declaration name="item" type="E" line="179"/>
                <declaration name="next" type="Node&lt;E&gt;" line="180"/>
                <javadoc line="182">
                    Constructs a new node.  Uses relaxed write because item can
                      only be seen after publication via casNext.                    
                </javadoc>
                <method name="Node" type="constructor" line="186">
                    <params>
                        <param name="item" type="E"/>
                    </params>
                </method>
                <method name="casItem" type="boolean" line="190">
                    <params>
                        <param name="cmp" type="E"/>
                        <param name="val" type="E"/>
                    </params>
                </method>
                <method name="lazySetNext" type="void" line="194">
                    <params>
                        <param name="val" type="Node<E>"/>
                    </params>
                </method>
                <method name="casNext" type="boolean" line="198">
                    <params>
                        <param name="cmp" type="Node<E>"/>
                        <param name="val" type="Node<E>"/>
                    </params>
                </method>
                <declaration name="UNSAFE" type="sun.misc.Unsafe" line="204"/>
                <declaration name="itemOffset" type="long" line="205"/>
                <declaration name="nextOffset" type="long" line="206"/>
                <scope line="208">
                    <scope line="209">
                        <declaration name="k" type="Class" line="211"/>
                    </scope>
                    <scope line="216"/>
                </scope>
            </class>
            <declaration name="head" type="Node&lt;E&gt;" line="222"/>
            <javadoc line="222">
                A node from which the first live (non-deleted) node (if any)
                  can be reached in O(1) time.
                  Invariants:
                  - all live nodes are reachable from head via succ()
                  - head != null
                  - (tmp = head).next != tmp || tmp != head
                  Non-invariants:
                  - head.item may or may not be null.
                  - it is permitted for tail to lag behind head, that is, for tail
                  to not be reachable from head!                
            </javadoc>
            <declaration name="tail" type="Node&lt;E&gt;" line="236"/>
            <javadoc line="236">
                A node from which the last node on list (that is, the unique
                  node with node.next == null) can be reached in O(1) time.
                  Invariants:
                  - the last node is always reachable from tail via succ()
                  - tail != null
                  Non-invariants:
                  - tail.item may or may not be null.
                  - it is permitted for tail to lag behind head, that is, for tail
                  to not be reachable from head!
                  - tail.next may or may not be self-pointing to tail.                
            </javadoc>
            <javadoc line="251">
                Creates a {@code ConcurrentLinkedQueue} that is initially empty.                
            </javadoc>
            <method name="ConcurrentLinkedQueue" type="constructor" line="254"/>
            <javadoc line="258">
                Creates a {@code ConcurrentLinkedQueue}initially containing the elements of the given collection,
                  added in traversal order of the collection&apos;s iterator.                
                <param>
                    c the collection of elements to initially contain                    
                </param>
                <throws>
                    NullPointerException if the specified collection or any
                      of its elements are null                    
                </throws>
            </javadoc>
            <method name="ConcurrentLinkedQueue" type="constructor" line="267">
                <params>
                    <param name="c" type="Collection<? extends E>"/>
                </params>
                <declaration name="h" type="Node&lt;E&gt;" line="268"/>
                <scope line="269">
                    <declaration name="newNode" type="Node&lt;E&gt;" line="271"/>
                    <scope line="274"/>
                </scope>
            </method>
            <javadoc line="287">
                Inserts the specified element at the tail of this queue.
                  As the queue is unbounded, this method will never throw{@link IllegalStateException} or return {@code false}.                
                <return>
                    {@code true} (as specified by {@link Collection#add})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="add" type="boolean" line="295">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="299">
                Try to CAS head to p. If successful, repoint old head to itself
                  as sentinel for succ(), below.                
            </javadoc>
            <method name="updateHead" type="void" line="303">
                <params>
                    <param name="h" type="Node<E>"/>
                    <param name="p" type="Node<E>"/>
                </params>
            </method>
            <javadoc line="308">
                Returns the successor of p, or the head node if p.next has been
                  linked to self, which will only be true if traversing with a
                  stale pointer that is now off the list.                
            </javadoc>
            <method name="succ" type="Node<E>" line="313">
                <params>
                    <param name="p" type="Node<E>"/>
                </params>
                <declaration name="next" type="Node&lt;E&gt;" line="314"/>
            </method>
            <javadoc line="318">
                Inserts the specified element at the tail of this queue.
                  As the queue is unbounded, this method will never return {@code false}.                
                <return>
                    {@code true} (as specified by {@link Queue#offer})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="325">
                <params>
                    <param name="e" type="E"/>
                </params>
                <comment line="333">
                    p is last node                    
                </comment>
                <comment line="335">
                    Successful CAS is the linearization point
                     for e to become an element of this queue,
                     and for newNode to become &quot;live&quot;.                    
                </comment>
                <comment line="338">
                    hop two nodes at a time                    
                </comment>
                <comment line="339">
                    Failure is OK.                    
                </comment>
                <comment line="342">
                    Lost CAS race to another thread; re-read next                    
                </comment>
                <comment line="345">
                    We have fallen off list.  If tail is unchanged, it
                     will also be off-list, in which case we need to
                     jump to head, from which all live nodes are always
                     reachable.  Else the new tail is a better bet.                    
                </comment>
                <comment line="351">
                    Check for tail updates after two hops.                    
                </comment>
                <declaration name="newNode" type="Node&lt;E&gt;" line="327"/>
                <scope line="329">
                    <declaration name="q" type="Node&lt;E&gt;" line="330"/>
                    <scope line="331">
                        <scope line="333"/>
                    </scope>
                </scope>
            </method>
            <method name="poll" type="E" line="355">
                <comment line="363">
                    Successful CAS is the linearization point
                     for item to be removed from this queue.                    
                </comment>
                <comment line="365">
                    hop two nodes at a time                    
                </comment>
                <scope line="357">
                    <scope line="358">
                        <declaration name="item" type="E" line="359"/>
                        <scope line="361"/>
                        <scope line="368"/>
                    </scope>
                </scope>
            </method>
            <method name="peek" type="E" line="380">
                <scope line="382">
                    <scope line="383">
                        <declaration name="item" type="E" line="384"/>
                        <scope line="385"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="397">
                Returns the first live (non-deleted) node on list, or null if none.
                  This is yet another variant of poll/peek; here returning the
                  first node, not element.  We could make peek() a wrapper around
                  first(), but that would cost an extra volatile read of item,
                  and the need to add a retry loop to deal with the possibility
                  of losing a race to a concurrent poll().                
            </javadoc>
            <method name="first" type="Node<E>" line="405">
                <scope line="407">
                    <scope line="408">
                        <declaration name="hasItem" type="boolean" line="409"/>
                        <scope line="410"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="422">
                Returns {@code true} if this queue contains no elements.                
                <return>
                    {@code true} if this queue contains no elements                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="427"/>
            <javadoc line="431">
                Returns the number of elements in this queue.  If this queue
                  contains more than {@code Integer.MAX_VALUE} elements, returns{@code Integer.MAX_VALUE}.
                  &lt;p&gt;Beware that, unlike in most collections, this method is
                  &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these queues, determining the current
                  number of elements requires an O(n) traversal.
                  Additionally, if elements are added or removed during execution
                  of this method, the returned result may be inaccurate.  Thus,
                  this method is typically not very useful in concurrent
                  applications.                
                <return>
                    the number of elements in this queue                    
                </return>
            </javadoc>
            <method name="size" type="int" line="447">
                <comment line="452">
                    Collection.size() spec says to max out                    
                </comment>
                <declaration name="count" type="int" line="448"/>
            </method>
            <javadoc line="457">
                Returns {@code true} if this queue contains the specified element.
                  More formally, returns {@code true} if and only if this queue contains
                  at least one element {@code e} such that {@code o.equals(e)}.                
                <param>
                    o object to be checked for containment in this queue                    
                </param>
                <return>
                    {@code true} if this queue contains the specified element                    
                </return>
            </javadoc>
            <method name="contains" type="boolean" line="465">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="467">
                    <declaration name="item" type="E" line="468"/>
                </scope>
            </method>
            <javadoc line="475">
                Removes a single instance of the specified element from this queue,
                  if it is present.  More formally, removes an element {@code e} such
                  that {@code o.equals(e)}, if this queue contains one or more such
                  elements.
                  Returns {@code true} if this queue contained the specified element
                  (or equivalently, if this queue changed as a result of the call).                
                <param>
                    o element to be removed from this queue, if present                    
                </param>
                <return>
                    {@code true} if this queue changed as a result of the call                    
                </return>
            </javadoc>
            <method name="remove" type="boolean" line="486">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="pred" type="Node&lt;E&gt;" line="488"/>
                <scope line="489">
                    <declaration name="item" type="E" line="490"/>
                    <scope line="493">
                        <declaration name="next" type="Node&lt;E&gt;" line="494"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="504">
                Appends all of the elements in the specified collection to the end of
                  this queue, in the order that they are returned by the specified
                  collection&apos;s iterator.  Attempts to {@code addAll} of a queue to
                  itself result in {@code IllegalArgumentException}.                
                <param>
                    c the elements to be inserted into this queue                    
                </param>
                <return>
                    {@code true} if this queue changed as a result of the call                    
                </return>
                <throws>
                    NullPointerException if the specified collection or any
                      of its elements are null                    
                </throws>
                <throws>
                    IllegalArgumentException if the collection is this queue                    
                </throws>
            </javadoc>
            <method name="addAll" type="boolean" line="516">
                <params>
                    <param name="c" type="Collection<? extends E>"/>
                </params>
                <comment line="519">
                    As historically specified in AbstractQueue#addAll                    
                </comment>
                <comment line="522">
                    Copy c into a private chain of Nodes                    
                </comment>
                <comment line="537">
                    Atomically append the chain at the tail of this collection                    
                </comment>
                <comment line="541">
                    p is last node                    
                </comment>
                <comment line="543">
                    Successful CAS is the linearization point
                     for all elements to be added to this queue.                    
                </comment>
                <comment line="546">
                    Try a little harder to update tail,
                     since we may be adding many elements.                    
                </comment>
                <comment line="554">
                    Lost CAS race to another thread; re-read next                    
                </comment>
                <comment line="557">
                    We have fallen off list.  If tail is unchanged, it
                     will also be off-list, in which case we need to
                     jump to head, from which all live nodes are always
                     reachable.  Else the new tail is a better bet.                    
                </comment>
                <comment line="563">
                    Check for tail updates after two hops.                    
                </comment>
                <declaration name="beginningOfTheEnd" type="Node&lt;E&gt;" line="522"/>
                <scope line="523">
                    <declaration name="newNode" type="Node&lt;E&gt;" line="525"/>
                    <scope line="528"/>
                </scope>
                <scope line="537">
                    <declaration name="q" type="Node&lt;E&gt;" line="538"/>
                    <scope line="539">
                        <scope line="541">
                            <scope line="544"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="567">
                Returns an array containing all of the elements in this queue, in
                  proper sequence.
                  &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
                  maintained by this queue.  (In other words, this method must allocate
                  a new array).  The caller is thus free to modify the returned array.
                  &lt;p&gt;This method acts as bridge between array-based and collection-based
                  APIs.                
                <return>
                    an array containing all of the elements in this queue                    
                </return>
            </javadoc>
            <method name="toArray" type="Object[]" line="580">
                <comment line="582">
                    Use ArrayList to deal with resizing.                    
                </comment>
                <declaration name="al" type="ArrayList&lt;E&gt;" line="582"/>
                <scope line="583">
                    <declaration name="item" type="E" line="584"/>
                </scope>
            </method>
            <javadoc line="591">
                Returns an array containing all of the elements in this queue, in
                  proper sequence; the runtime type of the returned array is that of
                  the specified array.  If the queue fits in the specified array, it
                  is returned therein.  Otherwise, a new array is allocated with the
                  runtime type of the specified array and the size of this queue.
                  &lt;p&gt;If this queue fits in the specified array with room to spare
                  (i.e., the array has more elements than this queue), the element in
                  the array immediately following the end of the queue is set to{@code null}.
                  &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
                  array-based and collection-based APIs.  Further, this method allows
                  precise control over the runtime type of the output array, and may,
                  under certain circumstances, be used to save allocation costs.
                  &lt;p&gt;Suppose {@code x} is a queue known to contain only strings.
                  The following code can be used to dump the queue into a newly
                  allocated array of {@code String}:
                  &lt;pre&gt;
                  String[] y = x.toArray(new String[0]);&lt;/pre&gt;
                  Note that {@code toArray(new Object[0])} is identical in function to{@code toArray()}.                
                <param>
                    a the array into which the elements of the queue are to
                      be stored, if it is big enough; otherwise, a new array of the
                      same runtime type is allocated for this purpose                    
                </param>
                <return>
                    an array containing all of the elements in this queue                    
                </return>
                <throws>
                    ArrayStoreException if the runtime type of the specified array
                      is not a supertype of the runtime type of every element in
                      this queue                    
                </throws>
                <throws>
                    NullPointerException if the specified array is null                    
                </throws>
            </javadoc>
            <method name="toArray" type="T[]" line="628">
                <params>
                    <param name="a" type="T[]"/>
                </params>
                <comment line="630">
                    try to use sent-in array                    
                </comment>
                <comment line="644">
                    If won&apos;t fit, use ArrayList version                    
                </comment>
                <declaration name="k" type="int" line="630"/>
                <declaration name="p" type="Node&lt;E&gt;" line="631"/>
                <scope line="632">
                    <declaration name="item" type="E" line="633"/>
                </scope>
                <scope line="637"/>
                <declaration name="al" type="ArrayList&lt;E&gt;" line="644"/>
                <scope line="645">
                    <declaration name="item" type="E" line="646"/>
                </scope>
            </method>
            <javadoc line="653">
                Returns an iterator over the elements in this queue in proper sequence.
                  The elements will be returned in order from first (head) to last (tail).
                  &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that
                  will never throw {@link java.util.ConcurrentModificationExceptionConcurrentModificationException}, and guarantees to traverse
                  elements as they existed upon construction of the iterator, and
                  may (but is not guaranteed to) reflect any modifications
                  subsequent to construction.                
                <return>
                    an iterator over the elements in this queue in proper sequence                    
                </return>
            </javadoc>
            <method name="iterator" type="Iterator<E>" line="666"/>
            <class name="Itr" line="670">
                <comment line="203">
                    Unsafe mechanics                    
                </comment>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="nextNode" type="Node&lt;E&gt;" line="671"/>
                <javadoc line="671">
                    Next node to return item for.                    
                </javadoc>
                <declaration name="nextItem" type="E" line="676"/>
                <javadoc line="676">
                    nextItem holds on to item fields because once we claim
                      that an element exists in hasNext(), we must return it in
                      the following next() call even if it was in the process of
                      being removed when hasNext() was called.                    
                </javadoc>
                <declaration name="lastRet" type="Node&lt;E&gt;" line="684"/>
                <javadoc line="684">
                    Node of the last returned item, to support remove.                    
                </javadoc>
                <method name="Itr" type="constructor" line="689"/>
                <javadoc line="693">
                    Moves to next valid node and returns item to return for
                      next(), or null if no such.                    
                </javadoc>
                <method name="advance" type="E" line="697">
                    <comment line="723">
                        skip over nulls                        
                    </comment>
                    <declaration name="x" type="E" line="699"/>
                    <declaration name="pred" type="Node&lt;E&gt;" line="701"/>
                    <scope line="702"/>
                    <scope line="705"/>
                    <scope line="710">
                        <scope line="711"/>
                        <declaration name="item" type="E" line="716"/>
                        <scope line="717"/>
                        <scope line="721">
                            <declaration name="next" type="Node&lt;E&gt;" line="723"/>
                        </scope>
                    </scope>
                </method>
                <method name="hasNext" type="boolean" line="731"/>
                <method name="next" type="E" line="735"/>
                <method name="remove" type="void" line="740">
                    <comment line="744">
                        rely on a future traversal to relink.                        
                    </comment>
                    <declaration name="l" type="Node&lt;E&gt;" line="741"/>
                </method>
            </class>
            <javadoc line="749">
                Saves the state to a stream (that is, serializes it).                
                <serialData>
                    All of the elements (each an {@code E}) in
                      the proper order, followed by a null                    
                </serialData>
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="757">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <comment line="760">
                    Write out any hidden stuff                    
                </comment>
                <comment line="763">
                    Write out all elements in the proper order.                    
                </comment>
                <comment line="770">
                    Use trailing null as sentinel                    
                </comment>
                <scope line="763">
                    <declaration name="item" type="Object" line="764"/>
                </scope>
            </method>
            <javadoc line="773">
                Reconstitutes the instance from a stream (that is, deserializes it).                
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="778">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="782">
                    Read in elements until trailing null sentinel found                    
                </comment>
                <declaration name="h" type="Node&lt;E&gt;" line="782"/>
                <declaration name="item" type="Object" line="783"/>
                <scope line="784">
                    <declaration name="newNode" type="Node&lt;E&gt;" line="785"/>
                    <scope line="789"/>
                </scope>
            </method>
            <javadoc line="800">
                Throws NullPointerException if argument is null.                
                <param>
                    v the element                    
                </param>
            </javadoc>
            <method name="checkNotNull" type="void" line="805">
                <params>
                    <param name="v" type="Object"/>
                </params>
            </method>
            <method name="casTail" type="boolean" line="810">
                <params>
                    <param name="cmp" type="Node<E>"/>
                    <param name="val" type="Node<E>"/>
                </params>
            </method>
            <method name="casHead" type="boolean" line="814">
                <params>
                    <param name="cmp" type="Node<E>"/>
                    <param name="val" type="Node<E>"/>
                </params>
            </method>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="820"/>
            <declaration name="headOffset" type="long" line="821"/>
            <declaration name="tailOffset" type="long" line="822"/>
            <scope line="823">
                <scope line="824">
                    <declaration name="k" type="Class" line="826"/>
                </scope>
                <scope line="831"/>
            </scope>
        </class>
    </source>