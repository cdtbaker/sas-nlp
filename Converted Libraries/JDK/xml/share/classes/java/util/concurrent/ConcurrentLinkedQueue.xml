<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.AbstractQueue"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="java.util.Queue"/>
        <class name="ConcurrentLinkedQueue" line="8">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="AbstractQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <implements interface="Queue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </implements>
            <implements interface="java.io.Serializable"/>
            <javadoc line="8">
                An unbounded thread-safe {@linkplain Queue queue} based on linked nodes.
                  This queue orders elements FIFO (first-in-first-out).
                  The &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the
                  queue the longest time.
                  The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has been on the
                  queue the shortest time. New elements
                  are inserted at the tail of the queue, and the queue retrieval
                  operations obtain elements at the head of the queue.
                  A {@code ConcurrentLinkedQueue} is an appropriate choice when
                  many threads will share access to a common collection.
                  Like most other concurrent collection implementations, this class
                  does not permit the use of {@code null} elements.
                  &lt;p&gt;This implementation employs an efficient &amp;quot;wait-free&amp;quot;
                  algorithm based on one described in &lt;a
                  href=&quot;http://www.cs.rochester.edu/u/michael/PODC96.html&quot;&gt; Simple,
                  Fast, and Practical Non-Blocking and Blocking Concurrent Queue
                  Algorithms&lt;/a&gt; by Maged M. Michael and Michael L. Scott.
                  &lt;p&gt;Iterators are &lt;i&gt;weakly consistent&lt;/i&gt;, returning elements
                  reflecting the state of the queue at some point at or since the
                  creation of the iterator.  They do &lt;em&gt;not&lt;/em&gt; throw {@link java.util.ConcurrentModificationException}, and may proceed concurrently
                  with other operations.  Elements contained in the queue since the creation
                  of the iterator will be returned exactly once.
                  &lt;p&gt;Beware that, unlike in most collections, the {@code size} method
                  is &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these queues, determining the current number
                  of elements requires a traversal of the elements, and so may report
                  inaccurate results if this collection is modified during traversal.
                  Additionally, the bulk operations {@code addAll},{@code removeAll}, {@code retainAll}, {@code containsAll},{@code equals}, and {@code toArray} are &lt;em&gt;not&lt;/em&gt; guaranteed
                  to be performed atomically. For example, an iterator operating
                  concurrently with an {@code addAll} operation might view only some
                  of the added elements.
                  &lt;p&gt;This class and its iterator implement all of the &lt;em&gt;optional&lt;/em&gt;
                  methods of the {@link Queue} and {@link Iterator} interfaces.
                  &lt;p&gt;Memory consistency effects: As with other concurrent
                  collections, actions in a thread prior to placing an object into a{@code ConcurrentLinkedQueue}&lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                  actions subsequent to the access or removal of that element from
                  the {@code ConcurrentLinkedQueue} in another thread.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea                    
                </author>
                <param>
                    <E>
                      the type of elements held in this collection                    
                </param>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="55"/>
            <class name="Node" line="56">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <declaration name="item" type="E" line="57"/>
                <declaration name="next" type="Node&lt;E&gt;" line="58"/>
                <javadoc line="59">
                    Constructs a new node.  Uses relaxed write because item can
                      only be seen after publication via casNext.                    
                </javadoc>
                <method name="Node" type="constructor" line="63">
                    <params>
                        <param name="item" type="E"/>
                    </params>
                </method>
                <method name="casItem" type="boolean" line="66">
                    <params>
                        <param name="cmp" type="E"/>
                        <param name="val" type="E"/>
                    </params>
                </method>
                <method name="lazySetNext" type="void" line="69">
                    <params>
                        <param name="val" type="Node<E>"/>
                    </params>
                </method>
                <method name="casNext" type="boolean" line="72">
                    <params>
                        <param name="cmp" type="Node<E>"/>
                        <param name="val" type="Node<E>"/>
                    </params>
                </method>
                <declaration name="UNSAFE" type="sun.misc.Unsafe" line="75"/>
                <declaration name="itemOffset" type="long" line="76"/>
                <declaration name="nextOffset" type="long" line="77"/>
                <scope line="78">
                    <scope line="79">
                        <declaration name="k" type="Class" line="81"/>
                    </scope>
                    <scope line="85"/>
                </scope>
            </class>
            <declaration name="head" type="Node&lt;E&gt;" line="90"/>
            <javadoc line="90">
                A node from which the first live (non-deleted) node (if any)
                  can be reached in O(1) time.
                  Invariants:
                  - all live nodes are reachable from head via succ()
                  - head != null
                  - (tmp = head).next != tmp || tmp != head
                  Non-invariants:
                  - head.item may or may not be null.
                  - it is permitted for tail to lag behind head, that is, for tail
                  to not be reachable from head!                
            </javadoc>
            <declaration name="tail" type="Node&lt;E&gt;" line="103"/>
            <javadoc line="103">
                A node from which the last node on list (that is, the unique
                  node with node.next == null) can be reached in O(1) time.
                  Invariants:
                  - the last node is always reachable from tail via succ()
                  - tail != null
                  Non-invariants:
                  - tail.item may or may not be null.
                  - it is permitted for tail to lag behind head, that is, for tail
                  to not be reachable from head!
                  - tail.next may or may not be self-pointing to tail.                
            </javadoc>
            <javadoc line="116">
                Creates a {@code ConcurrentLinkedQueue} that is initially empty.                
            </javadoc>
            <method name="ConcurrentLinkedQueue" type="constructor" line="119"/>
            <javadoc line="122">
                Creates a {@code ConcurrentLinkedQueue}initially containing the elements of the given collection,
                  added in traversal order of the collection&apos;s iterator.                
                <param>
                    c the collection of elements to initially contain                    
                </param>
                <throws>
                    NullPointerException if the specified collection or any
                      of its elements are null                    
                </throws>
            </javadoc>
            <method name="ConcurrentLinkedQueue" type="constructor" line="129">
                <params>
                    <param name="c" type="Collection<? extends E>"/>
                </params>
                <declaration name="h" type="Node&lt;E&gt;" line="130"/>
                <scope line="131">
                    <declaration name="newNode" type="Node&lt;E&gt;" line="133"/>
                    <scope line="135"/>
                </scope>
            </method>
            <javadoc line="144">
                Inserts the specified element at the tail of this queue.
                  As the queue is unbounded, this method will never throw{@link IllegalStateException} or return {@code false}.                
                <return>
                    {@code true} (as specified by {@link Collection#add})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="add" type="boolean" line="150">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="153">
                Try to CAS head to p. If successful, repoint old head to itself
                  as sentinel for succ(), below.                
            </javadoc>
            <method name="updateHead" type="void" line="157">
                <params>
                    <param name="h" type="Node<E>"/>
                    <param name="p" type="Node<E>"/>
                </params>
            </method>
            <javadoc line="160">
                Returns the successor of p, or the head node if p.next has been
                  linked to self, which will only be true if traversing with a
                  stale pointer that is now off the list.                
            </javadoc>
            <method name="succ" type="Node<E>" line="165">
                <params>
                    <param name="p" type="Node<E>"/>
                </params>
                <declaration name="next" type="Node&lt;E&gt;" line="166"/>
            </method>
            <javadoc line="169">
                Inserts the specified element at the tail of this queue.
                  As the queue is unbounded, this method will never return {@code false}.                
                <return>
                    {@code true} (as specified by {@link Queue#offer})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="175">
                <params>
                    <param name="e" type="E"/>
                </params>
                <declaration name="newNode" type="Node&lt;E&gt;" line="177"/>
                <scope line="178">
                    <declaration name="q" type="Node&lt;E&gt;" line="179"/>
                    <scope line="180">
                        <scope line="181"/>
                    </scope>
                </scope>
            </method>
            <method name="poll" type="E" line="190">
                <scope line="191">
                    <scope line="192">
                        <declaration name="item" type="E" line="193"/>
                        <scope line="194"/>
                        <scope line="198"/>
                    </scope>
                </scope>
            </method>
            <method name="peek" type="E" line="207">
                <scope line="208">
                    <scope line="209">
                        <declaration name="item" type="E" line="210"/>
                        <scope line="211"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="220">
                Returns the first live (non-deleted) node on list, or null if none.
                  This is yet another variant of poll/peek; here returning the
                  first node, not element.  We could make peek() a wrapper around
                  first(), but that would cost an extra volatile read of item,
                  and the need to add a retry loop to deal with the possibility
                  of losing a race to a concurrent poll().                
            </javadoc>
            <method name="first" type="Node<E>" line="228">
                <scope line="229">
                    <scope line="230">
                        <declaration name="hasItem" type="boolean" line="231"/>
                        <scope line="232"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="241">
                Returns {@code true} if this queue contains no elements.                
                <return>
                    {@code true} if this queue contains no elements                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="245"/>
            <javadoc line="248">
                Returns the number of elements in this queue.  If this queue
                  contains more than {@code Integer.MAX_VALUE} elements, returns{@code Integer.MAX_VALUE}.
                  &lt;p&gt;Beware that, unlike in most collections, this method is
                  &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these queues, determining the current
                  number of elements requires an O(n) traversal.
                  Additionally, if elements are added or removed during execution
                  of this method, the returned result may be inaccurate.  Thus,
                  this method is typically not very useful in concurrent
                  applications.                
                <return>
                    the number of elements in this queue                    
                </return>
            </javadoc>
            <method name="size" type="int" line="261">
                <declaration name="count" type="int" line="262"/>
            </method>
            <javadoc line="266">
                Returns {@code true} if this queue contains the specified element.
                  More formally, returns {@code true} if and only if this queue contains
                  at least one element {@code e} such that {@code o.equals(e)}.                
                <param>
                    o object to be checked for containment in this queue                    
                </param>
                <return>
                    {@code true} if this queue contains the specified element                    
                </return>
            </javadoc>
            <method name="contains" type="boolean" line="273">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="275">
                    <declaration name="item" type="E" line="276"/>
                </scope>
            </method>
            <javadoc line="281">
                Removes a single instance of the specified element from this queue,
                  if it is present.  More formally, removes an element {@code e} such
                  that {@code o.equals(e)}, if this queue contains one or more such
                  elements.
                  Returns {@code true} if this queue contained the specified element
                  (or equivalently, if this queue changed as a result of the call).                
                <param>
                    o element to be removed from this queue, if present                    
                </param>
                <return>
                    {@code true} if this queue changed as a result of the call                    
                </return>
            </javadoc>
            <method name="remove" type="boolean" line="291">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="pred" type="Node&lt;E&gt;" line="293"/>
                <scope line="294">
                    <declaration name="item" type="E" line="295"/>
                    <scope line="296">
                        <declaration name="next" type="Node&lt;E&gt;" line="297"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="305">
                Appends all of the elements in the specified collection to the end of
                  this queue, in the order that they are returned by the specified
                  collection&apos;s iterator.  Attempts to {@code addAll} of a queue to
                  itself result in {@code IllegalArgumentException}.                
                <param>
                    c the elements to be inserted into this queue                    
                </param>
                <return>
                    {@code true} if this queue changed as a result of the call                    
                </return>
                <throws>
                    NullPointerException if the specified collection or any
                      of its elements are null                    
                </throws>
                <throws>
                    IllegalArgumentException if the collection is this queue                    
                </throws>
            </javadoc>
            <method name="addAll" type="boolean" line="316">
                <params>
                    <param name="c" type="Collection<? extends E>"/>
                </params>
                <declaration name="beginningOfTheEnd" type="Node&lt;E&gt;" line="318"/>
                <scope line="319">
                    <declaration name="newNode" type="Node&lt;E&gt;" line="321"/>
                    <scope line="323"/>
                </scope>
                <scope line="329">
                    <declaration name="q" type="Node&lt;E&gt;" line="330"/>
                    <scope line="331">
                        <scope line="332">
                            <scope line="333"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="344">
                Returns an array containing all of the elements in this queue, in
                  proper sequence.
                  &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
                  maintained by this queue.  (In other words, this method must allocate
                  a new array).  The caller is thus free to modify the returned array.
                  &lt;p&gt;This method acts as bridge between array-based and collection-based
                  APIs.                
                <return>
                    an array containing all of the elements in this queue                    
                </return>
            </javadoc>
            <method name="toArray" type="Object[]" line="354">
                <declaration name="al" type="ArrayList&lt;E&gt;" line="355"/>
                <scope line="356">
                    <declaration name="item" type="E" line="357"/>
                </scope>
            </method>
            <javadoc line="362">
                Returns an array containing all of the elements in this queue, in
                  proper sequence; the runtime type of the returned array is that of
                  the specified array.  If the queue fits in the specified array, it
                  is returned therein.  Otherwise, a new array is allocated with the
                  runtime type of the specified array and the size of this queue.
                  &lt;p&gt;If this queue fits in the specified array with room to spare
                  (i.e., the array has more elements than this queue), the element in
                  the array immediately following the end of the queue is set to{@code null}.
                  &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
                  array-based and collection-based APIs.  Further, this method allows
                  precise control over the runtime type of the output array, and may,
                  under certain circumstances, be used to save allocation costs.
                  &lt;p&gt;Suppose {@code x} is a queue known to contain only strings.
                  The following code can be used to dump the queue into a newly
                  allocated array of {@code String}:
                  &lt;pre&gt;
                  String[] y = x.toArray(new String[0]);&lt;/pre&gt;
                  Note that {@code toArray(new Object[0])} is identical in function to{@code toArray()}.                
                <param>
                    a the array into which the elements of the queue are to
                      be stored, if it is big enough; otherwise, a new array of the
                      same runtime type is allocated for this purpose                    
                </param>
                <return>
                    an array containing all of the elements in this queue                    
                </return>
                <throws>
                    ArrayStoreException if the runtime type of the specified array
                      is not a supertype of the runtime type of every element in
                      this queue                    
                </throws>
                <throws>
                    NullPointerException if the specified array is null                    
                </throws>
            </javadoc>
            <method name="toArray" type="T[]" line="390">
                <params>
                    <param name="a" type="T[]"/>
                </params>
                <declaration name="k" type="int" line="391"/>
                <declaration name="p" type="Node&lt;E&gt;" line="392"/>
                <scope line="393">
                    <declaration name="item" type="E" line="394"/>
                </scope>
                <scope line="397"/>
                <declaration name="al" type="ArrayList&lt;E&gt;" line="401"/>
                <scope line="402">
                    <declaration name="item" type="E" line="403"/>
                </scope>
            </method>
            <javadoc line="408">
                Returns an iterator over the elements in this queue in proper sequence.
                  The elements will be returned in order from first (head) to last (tail).
                  &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that
                  will never throw {@link java.util.ConcurrentModificationExceptionConcurrentModificationException}, and guarantees to traverse
                  elements as they existed upon construction of the iterator, and
                  may (but is not guaranteed to) reflect any modifications
                  subsequent to construction.                
                <return>
                    an iterator over the elements in this queue in proper sequence                    
                </return>
            </javadoc>
            <method name="iterator" type="Iterator<E>" line="418"/>
            <class name="Itr" line="421">
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="nextNode" type="Node&lt;E&gt;" line="422"/>
                <javadoc line="422">
                    Next node to return item for.                    
                </javadoc>
                <declaration name="nextItem" type="E" line="426"/>
                <javadoc line="426">
                    nextItem holds on to item fields because once we claim
                      that an element exists in hasNext(), we must return it in
                      the following next() call even if it was in the process of
                      being removed when hasNext() was called.                    
                </javadoc>
                <declaration name="lastRet" type="Node&lt;E&gt;" line="433"/>
                <javadoc line="433">
                    Node of the last returned item, to support remove.                    
                </javadoc>
                <method name="Itr" type="constructor" line="437"/>
                <javadoc line="440">
                    Moves to next valid node and returns item to return for
                      next(), or null if no such.                    
                </javadoc>
                <method name="advance" type="E" line="444">
                    <declaration name="x" type="E" line="446"/>
                    <declaration name="pred" type="Node&lt;E&gt;" line="447"/>
                    <scope line="448"/>
                    <scope line="452"/>
                    <scope line="456">
                        <scope line="457"/>
                        <declaration name="item" type="E" line="462"/>
                        <scope line="463"/>
                        <scope line="468">
                            <declaration name="next" type="Node&lt;E&gt;" line="469"/>
                        </scope>
                    </scope>
                </method>
                <method name="hasNext" type="boolean" line="475"/>
                <method name="next" type="E" line="478"/>
                <method name="remove" type="void" line="482">
                    <declaration name="l" type="Node&lt;E&gt;" line="483"/>
                </method>
            </class>
            <javadoc line="489">
                Saves the state to a stream (that is, serializes it).                
                <serialData>
                    All of the elements (each an {@code E}) in
                      the proper order, followed by a null                    
                </serialData>
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="495">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <scope line="497">
                    <declaration name="item" type="Object" line="498"/>
                </scope>
            </method>
            <javadoc line="503">
                Reconstitutes the instance from a stream (that is, deserializes it).                
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="507">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <declaration name="h" type="Node&lt;E&gt;" line="509"/>
                <declaration name="item" type="Object" line="510"/>
                <scope line="511">
                    <declaration name="newNode" type="Node&lt;E&gt;" line="512"/>
                    <scope line="514"/>
                </scope>
            </method>
            <javadoc line="523">
                Throws NullPointerException if argument is null.                
                <param>
                    v the element                    
                </param>
            </javadoc>
            <method name="checkNotNull" type="void" line="527">
                <params>
                    <param name="v" type="Object"/>
                </params>
            </method>
            <method name="casTail" type="boolean" line="530">
                <params>
                    <param name="cmp" type="Node<E>"/>
                    <param name="val" type="Node<E>"/>
                </params>
            </method>
            <method name="casHead" type="boolean" line="533">
                <params>
                    <param name="cmp" type="Node<E>"/>
                    <param name="val" type="Node<E>"/>
                </params>
            </method>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="536"/>
            <declaration name="headOffset" type="long" line="537"/>
            <declaration name="tailOffset" type="long" line="538"/>
            <scope line="539">
                <scope line="540">
                    <declaration name="k" type="Class" line="542"/>
                </scope>
                <scope line="546"/>
            </scope>
        </class>
    </source>