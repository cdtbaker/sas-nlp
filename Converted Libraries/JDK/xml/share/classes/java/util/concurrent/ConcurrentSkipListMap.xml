<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util"/>
        <import package="java.util.concurrent.atomic"/>
        <class name="ConcurrentSkipListMap" line="4">
            <type_params>
                <type_param name="K"/>
                <type_param name="V"/>
            </type_params>
            <extends class="AbstractMap">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </extends>
            <implements interface="ConcurrentNavigableMap">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
            </implements>
            <implements interface="Cloneable"/>
            <implements interface="java.io.Serializable"/>
            <javadoc line="4">
                A scalable concurrent {@link ConcurrentNavigableMap} implementation.
                  The map is sorted according to the {@linkplain Comparable natural
                  ordering} of its keys, or by a {@link Comparator} provided at map
                  creation time, depending on which constructor is used.
                  &lt;p&gt;This class implements a concurrent variant of &lt;a
                  href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot; target=&quot;_top&quot;&gt;SkipLists&lt;/a&gt;
                  providing expected average &lt;i&gt;log(n)&lt;/i&gt; time cost for the
                  &lt;tt&gt;containsKey&lt;/tt&gt;, &lt;tt&gt;get&lt;/tt&gt;, &lt;tt&gt;put&lt;/tt&gt; and
                  &lt;tt&gt;remove&lt;/tt&gt; operations and their variants.  Insertion, removal,
                  update, and access operations safely execute concurrently by
                  multiple threads.  Iterators are &lt;i&gt;weakly consistent&lt;/i&gt;, returning
                  elements reflecting the state of the map at some point at or since
                  the creation of the iterator.  They do &lt;em&gt;not&lt;/em&gt; throw {@link ConcurrentModificationException}, and may proceed concurrently with
                  other operations. Ascending key ordered views and their iterators
                  are faster than descending ones.
                  &lt;p&gt;All &lt;tt&gt;Map.Entry&lt;/tt&gt; pairs returned by methods in this class
                  and its views represent snapshots of mappings at the time they were
                  produced. They do &lt;em&gt;not&lt;/em&gt; support the &lt;tt&gt;Entry.setValue&lt;/tt&gt;
                  method. (Note however that it is possible to change mappings in the
                  associated map using &lt;tt&gt;put&lt;/tt&gt;, &lt;tt&gt;putIfAbsent&lt;/tt&gt;, or
                  &lt;tt&gt;replace&lt;/tt&gt;, depending on exactly which effect you need.)
                  &lt;p&gt;Beware that, unlike in most collections, the &lt;tt&gt;size&lt;/tt&gt;
                  method is &lt;em&gt;not&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these maps, determining the current number
                  of elements requires a traversal of the elements, and so may report
                  inaccurate results if this collection is modified during traversal.
                  Additionally, the bulk operations &lt;tt&gt;putAll&lt;/tt&gt;, &lt;tt&gt;equals&lt;/tt&gt;,
                  &lt;tt&gt;toArray&lt;/tt&gt;, &lt;tt&gt;containsValue&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; are
                  &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically. For example, an
                  iterator operating concurrently with a &lt;tt&gt;putAll&lt;/tt&gt; operation
                  might view only some of the added elements.
                  &lt;p&gt;This class and its views and iterators implement all of the
                  &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator}interfaces. Like most other concurrent collections, this class does
                  &lt;em&gt;not&lt;/em&gt; permit the use of &lt;tt&gt;null&lt;/tt&gt; keys or values because some
                  null return values cannot be reliably distinguished from the absence of
                  elements.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <author>
                    Doug Lea                    
                </author>
                <param>
                    <K>
                      the type of keys maintained by this map                    
                </param>
                <param>
                    <V>
                      the type of mapped values                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="52"/>
            <declaration name="seedGenerator" type="Random" line="53"/>
            <javadoc line="53">
                Generates the initial random seed for the cheaper per-instance
                  random number generators used in randomLevel.                
            </javadoc>
            <declaration name="BASE_HEADER" type="Object" line="58"/>
            <javadoc line="58">
                Special value used to identify base-level header                
            </javadoc>
            <declaration name="head" type="HeadIndex&lt;K,V&gt;" line="62"/>
            <javadoc line="62">
                The topmost head index of the skiplist.                
            </javadoc>
            <declaration name="comparator" type="Comparator&lt;? super K&gt;" line="66"/>
            <javadoc line="66">
                The comparator used to maintain order in this map, or null
                  if using natural ordering.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="randomSeed" type="int" line="72"/>
            <javadoc line="72">
                Seed for simple random number generator.  Not volatile since it
                  doesn&apos;t matter too much if different threads don&apos;t see updates.                
            </javadoc>
            <declaration name="keySet" type="KeySet" line="77"/>
            <javadoc line="77">
                Lazily initialized key set                
            </javadoc>
            <declaration name="entrySet" type="EntrySet" line="81"/>
            <javadoc line="81">
                Lazily initialized entry set                
            </javadoc>
            <declaration name="values" type="Values" line="85"/>
            <javadoc line="85">
                Lazily initialized values collection                
            </javadoc>
            <declaration name="descendingMap" type="ConcurrentNavigableMap&lt;K,V&gt;" line="89"/>
            <javadoc line="89">
                Lazily initialized descending key set                
            </javadoc>
            <javadoc line="93">
                Initializes or resets state. Needed by constructors, clone,
                  clear, readObject. and ConcurrentSkipListSet.clone.
                  (Note that comparator must be separately initialized.)                
            </javadoc>
            <method name="initialize" type="void" line="98"/>
            <javadoc line="106">
                compareAndSet head node                
            </javadoc>
            <method name="casHead" type="boolean" line="109">
                <params>
                    <param name="cmp" type="HeadIndex<K,V>"/>
                    <param name="val" type="HeadIndex<K,V>"/>
                </params>
            </method>
            <class name="Node" line="112">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <javadoc line="112">
                    Nodes hold keys and values, and are singly linked in sorted
                      order, possibly with some intervening marker nodes. The list is
                      headed by a dummy node accessible as head.node. The value field
                      is declared only as Object because it takes special non-V
                      values for marker and header nodes.                    
                </javadoc>
                <declaration name="key" type="K" line="120"/>
                <declaration name="value" type="Object" line="121"/>
                <declaration name="next" type="Node&lt;K,V&gt;" line="122"/>
                <javadoc line="123">
                    Creates a new regular node.                    
                </javadoc>
                <method name="Node" type="constructor" line="126">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="Object"/>
                        <param name="next" type="Node<K,V>"/>
                    </params>
                </method>
                <javadoc line="131">
                    Creates a new marker node. A marker is distinguished by
                      having its value field point to itself.  Marker nodes also
                      have null keys, a fact that is exploited in a few places,
                      but this doesn&apos;t distinguish markers from the base-level
                      header node (head.node), which also has a null key.                    
                </javadoc>
                <method name="Node" type="constructor" line="138">
                    <params>
                        <param name="next" type="Node<K,V>"/>
                    </params>
                </method>
                <javadoc line="143">
                    compareAndSet value field                    
                </javadoc>
                <method name="casValue" type="boolean" line="146">
                    <params>
                        <param name="cmp" type="Object"/>
                        <param name="val" type="Object"/>
                    </params>
                </method>
                <javadoc line="149">
                    compareAndSet next field                    
                </javadoc>
                <method name="casNext" type="boolean" line="152">
                    <params>
                        <param name="cmp" type="Node<K,V>"/>
                        <param name="val" type="Node<K,V>"/>
                    </params>
                </method>
                <javadoc line="155">
                    Returns true if this node is a marker. This method isn&apos;t
                      actually called in any current code checking for markers
                      because callers will have already read value field and need
                      to use that read (not another done here) and so directly
                      test if value points to node.                    
                    <param>
                        n a possibly null reference to a node                        
                    </param>
                    <return>
                        true if this node is a marker node                        
                    </return>
                </javadoc>
                <method name="isMarker" type="boolean" line="164"/>
                <javadoc line="167">
                    Returns true if this node is the header of base-level list.                    
                    <return>
                        true if this node is header node                        
                    </return>
                </javadoc>
                <method name="isBaseHeader" type="boolean" line="171"/>
                <javadoc line="174">
                    Tries to append a deletion marker to this node.                    
                    <param>
                        f the assumed current successor of this node                        
                    </param>
                    <return>
                        true if successful                        
                    </return>
                </javadoc>
                <method name="appendMarker" type="boolean" line="179">
                    <params>
                        <param name="f" type="Node<K,V>"/>
                    </params>
                </method>
                <javadoc line="182">
                    Helps out a deletion by appending marker or unlinking from
                      predecessor. This is called during traversals when value
                      field seen to be null.                    
                    <param>
                        b predecessor                        
                    </param>
                    <param>
                        f successor                        
                    </param>
                </javadoc>
                <method name="helpDelete" type="void" line="189">
                    <params>
                        <param name="b" type="Node<K,V>"/>
                        <param name="f" type="Node<K,V>"/>
                    </params>
                    <scope line="190"/>
                </method>
                <javadoc line="195">
                    Returns value if this node contains a valid key-value pair,
                      else null.                    
                    <return>
                        this node's value if it isn't a marker or header or
                          is deleted, else null.                        
                    </return>
                </javadoc>
                <method name="getValidValue" type="V" line="201">
                    <declaration name="v" type="Object" line="202"/>
                </method>
                <javadoc line="206">
                    Creates and returns a new SimpleImmutableEntry holding current
                      mapping if this node holds a valid value, else null.                    
                    <return>
                        new entry or null                        
                    </return>
                </javadoc>
                <method name="createSnapshot" type="AbstractMap.SimpleImmutableEntry<K,V>" line="211">
                    <declaration name="v" type="V" line="212"/>
                </method>
                <declaration name="UNSAFE" type="sun.misc.Unsafe" line="216"/>
                <declaration name="valueOffset" type="long" line="217"/>
                <declaration name="nextOffset" type="long" line="218"/>
                <scope line="219">
                    <scope line="220">
                        <declaration name="k" type="Class" line="222"/>
                    </scope>
                    <scope line="226"/>
                </scope>
            </class>
            <class name="Index" line="231">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <javadoc line="231">
                    Index nodes represent the levels of the skip list.  Note that
                      even though both Nodes and Indexes have forward-pointing
                      fields, they have different types and are handled in different
                      ways, that can&apos;t nicely be captured by placing field in a
                      shared abstract class.                    
                </javadoc>
                <declaration name="node" type="Node&lt;K,V&gt;" line="239"/>
                <declaration name="down" type="Index&lt;K,V&gt;" line="240"/>
                <declaration name="right" type="Index&lt;K,V&gt;" line="241"/>
                <javadoc line="242">
                    Creates index node with given values.                    
                </javadoc>
                <method name="Index" type="constructor" line="245">
                    <params>
                        <param name="node" type="Node<K,V>"/>
                        <param name="down" type="Index<K,V>"/>
                        <param name="right" type="Index<K,V>"/>
                    </params>
                </method>
                <javadoc line="250">
                    compareAndSet right field                    
                </javadoc>
                <method name="casRight" type="boolean" line="253">
                    <params>
                        <param name="cmp" type="Index<K,V>"/>
                        <param name="val" type="Index<K,V>"/>
                    </params>
                </method>
                <javadoc line="256">
                    Returns true if the node this indexes has been deleted.                    
                    <return>
                        true if indexed node is known to be deleted                        
                    </return>
                </javadoc>
                <method name="indexesDeletedNode" type="boolean" line="260"/>
                <javadoc line="263">
                    Tries to CAS newSucc as successor.  To minimize races with
                      unlink that may lose this index node, if the node being
                      indexed is known to be deleted, it doesn&apos;t try to link in.                    
                    <param>
                        succ the expected current successor                        
                    </param>
                    <param>
                        newSucc the new successor                        
                    </param>
                    <return>
                        true if successful                        
                    </return>
                </javadoc>
                <method name="link" type="boolean" line="271">
                    <params>
                        <param name="succ" type="Index<K,V>"/>
                        <param name="newSucc" type="Index<K,V>"/>
                    </params>
                    <declaration name="n" type="Node&lt;K,V&gt;" line="272"/>
                </method>
                <javadoc line="276">
                    Tries to CAS right field to skip over apparent successor
                      succ.  Fails (forcing a retraversal by caller) if this node
                      is known to be deleted.                    
                    <param>
                        succ the expected current successor                        
                    </param>
                    <return>
                        true if successful                        
                    </return>
                </javadoc>
                <method name="unlink" type="boolean" line="283">
                    <params>
                        <param name="succ" type="Index<K,V>"/>
                    </params>
                </method>
                <declaration name="UNSAFE" type="sun.misc.Unsafe" line="286"/>
                <declaration name="rightOffset" type="long" line="287"/>
                <scope line="288">
                    <scope line="289">
                        <declaration name="k" type="Class" line="291"/>
                    </scope>
                    <scope line="294"/>
                </scope>
            </class>
            <class name="HeadIndex" line="299">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="Index">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <javadoc line="299">
                    Nodes heading each level keep track of their level.                    
                </javadoc>
                <declaration name="level" type="int" line="303"/>
                <method name="HeadIndex" type="constructor" line="304">
                    <params>
                        <param name="node" type="Node<K,V>"/>
                        <param name="down" type="Index<K,V>"/>
                        <param name="right" type="Index<K,V>"/>
                        <param name="level" type="int"/>
                    </params>
                </method>
            </class>
            <class name="ComparableUsingComparator" line="309">
                <type_params>
                    <type_param name="K"/>
                </type_params>
                <implements interface="Comparable">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </implements>
                <javadoc line="309">
                    Represents a key with a comparator as a Comparable.
                      Because most sorted collections seem to use natural ordering on
                      Comparables (Strings, Integers, etc), most internal methods are
                      geared to use them. This is generally faster than checking
                      per-comparison whether to use comparator or comparable because
                      it doesn&apos;t require a (Comparable) cast for each comparison.
                      (Optimizers can only sometimes remove such redundant checks
                      themselves.) When Comparators are used,
                      ComparableUsingComparators are created so that they act in the
                      same way as natural orderings. This penalizes use of
                      Comparators vs Comparables, which seems like the right
                      tradeoff.                    
                </javadoc>
                <declaration name="actualKey" type="K" line="324"/>
                <declaration name="cmp" type="Comparator&lt;? super K&gt;" line="325"/>
                <method name="ComparableUsingComparator" type="constructor" line="326">
                    <params>
                        <param name="key" type="K"/>
                        <param name="cmp" type="Comparator<? super K>"/>
                    </params>
                </method>
                <method name="compareTo" type="int" line="330">
                    <params>
                        <param name="k2" type="K"/>
                    </params>
                </method>
            </class>
            <javadoc line="334">
                If using comparator, return a ComparableUsingComparator, else
                  cast key as Comparable, which may cause ClassCastException,
                  which is propagated back to caller.                
            </javadoc>
            <method name="comparable" type="Comparable<? super K>" line="339">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="344">
                Compares using comparator or natural ordering. Used when the
                  ComparableUsingComparator approach doesn&apos;t apply.                
            </javadoc>
            <method name="compare" type="int" line="348">
                <params>
                    <param name="k1" type="K"/>
                    <param name="k2" type="K"/>
                </params>
                <declaration name="cmp" type="Comparator&lt;? super K&gt;" line="349"/>
            </method>
            <javadoc line="353">
                Returns true if given key greater than or equal to least and
                  strictly less than fence, bypassing either test if least or
                  fence are null. Needed mainly in submap operations.                
            </javadoc>
            <method name="inHalfOpenRange" type="boolean" line="358">
                <params>
                    <param name="key" type="K"/>
                    <param name="least" type="K"/>
                    <param name="fence" type="K"/>
                </params>
            </method>
            <javadoc line="362">
                Returns true if given key greater than or equal to least and less
                  or equal to fence. Needed mainly in submap operations.                
            </javadoc>
            <method name="inOpenRange" type="boolean" line="366">
                <params>
                    <param name="key" type="K"/>
                    <param name="least" type="K"/>
                    <param name="fence" type="K"/>
                </params>
            </method>
            <javadoc line="370">
                Returns a base-level node with key strictly less than given key,
                  or the base-level header if there is no such node.  Also
                  unlinks indexes to deleted nodes found along the way.  Callers
                  rely on this side-effect of clearing indices to deleted nodes.                
                <param>
                    key the key                    
                </param>
                <return>
                    a predecessor of key                    
                </return>
            </javadoc>
            <method name="findPredecessor" type="Node<K,V>" line="378">
                <params>
                    <param name="key" type="Comparable<? super K>"/>
                </params>
                <scope line="380">
                    <declaration name="q" type="Index&lt;K,V&gt;" line="381"/>
                    <declaration name="r" type="Index&lt;K,V&gt;" line="382"/>
                    <scope line="383">
                        <scope line="384">
                            <declaration name="n" type="Node&lt;K,V&gt;" line="385"/>
                            <declaration name="k" type="K" line="386"/>
                            <scope line="387"/>
                            <scope line="392"/>
                        </scope>
                        <declaration name="d" type="Index&lt;K,V&gt;" line="398"/>
                        <scope line="399"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="407">
                Returns node holding key or null if no such, clearing out any
                  deleted nodes seen along the way.  Repeatedly traverses at
                  base-level looking for key starting at predecessor returned
                  from findPredecessor, processing base-level deletions as
                  encountered. Some callers rely on this side-effect of clearing
                  deleted nodes.
                  Restarts occur, at traversal step centered on node n, if:
                  (1) After reading n&apos;s next field, n is no longer assumed
                  predecessor b&apos;s current successor, which means that
                  we don&apos;t have a consistent 3-node snapshot and so cannot
                  unlink any subsequent deleted nodes encountered.
                  (2) n&apos;s value field is null, indicating n is deleted, in
                  which case we help out an ongoing structural deletion
                  before retrying.  Even though there are cases where such
                  unlinking doesn&apos;t require restart, they aren&apos;t sorted out
                  here because doing so would not usually outweigh cost of
                  restarting.
                  (3) n is a marker or n&apos;s predecessor&apos;s value field is null,
                  indicating (among other possibilities) that
                  findPredecessor returned a deleted node. We can&apos;t unlink
                  the node because we don&apos;t know its predecessor, so rely
                  on another call to findPredecessor to notice and return
                  some earlier predecessor, which it will do. This check is
                  only strictly needed at beginning of loop, (and the
                  b.value check isn&apos;t strictly needed at all) but is done
                  each iteration to help avoid contention with other
                  threads by callers that will fail to be able to change
                  links, and so will retry anyway.
                  The traversal loops in doPut, doRemove, and findNear all
                  include the same three kinds of checks. And specialized
                  versions appear in findFirst, and findLast and their
                  variants. They can&apos;t easily share code because each uses the
                  reads of fields held in locals occurring in the orders they
                  were performed.                
                <param>
                    key the key                    
                </param>
                <return>
                    node holding key, or null if no such                    
                </return>
            </javadoc>
            <method name="findNode" type="Node<K,V>" line="445">
                <params>
                    <param name="key" type="Comparable<? super K>"/>
                </params>
                <scope line="446">
                    <declaration name="b" type="Node&lt;K,V&gt;" line="447"/>
                    <declaration name="n" type="Node&lt;K,V&gt;" line="448"/>
                    <scope line="449">
                        <declaration name="f" type="Node&lt;K,V&gt;" line="451"/>
                        <declaration name="v" type="Object" line="453"/>
                        <scope line="454"/>
                        <declaration name="c" type="int" line="459"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="467">
                Gets value for key using findNode.                
                <param>
                    okey the key                    
                </param>
                <return>
                    the value, or null if absent                    
                </return>
            </javadoc>
            <method name="doGet" type="V" line="472">
                <params>
                    <param name="okey" type="Object"/>
                </params>
                <declaration name="key" type="Comparable&lt;? super K&gt;" line="473"/>
                <scope line="474">
                    <declaration name="n" type="Node&lt;K,V&gt;" line="475"/>
                    <declaration name="v" type="Object" line="477"/>
                </scope>
            </method>
            <javadoc line="481">
                Main insertion method.  Adds element if not present, or
                  replaces value if present and onlyIfAbsent is false.                
                <param>
                    kkey the key                    
                </param>
                <param>
                    value  the value that must be associated with key                    
                </param>
                <param>
                    onlyIfAbsent if should not insert if already present                    
                </param>
                <return>
                    the old value, or null if newly inserted                    
                </return>
            </javadoc>
            <method name="doPut" type="V" line="489">
                <params>
                    <param name="kkey" type="K"/>
                    <param name="value" type="V"/>
                    <param name="onlyIfAbsent" type="boolean"/>
                </params>
                <declaration name="key" type="Comparable&lt;? super K&gt;" line="490"/>
                <scope line="491">
                    <declaration name="b" type="Node&lt;K,V&gt;" line="492"/>
                    <declaration name="n" type="Node&lt;K,V&gt;" line="493"/>
                    <scope line="494">
                        <scope line="495">
                            <declaration name="f" type="Node&lt;K,V&gt;" line="496"/>
                            <declaration name="v" type="Object" line="498"/>
                            <scope line="499"/>
                            <declaration name="c" type="int" line="504"/>
                            <scope line="505"/>
                            <scope line="510"/>
                        </scope>
                        <declaration name="z" type="Node&lt;K,V&gt;" line="515"/>
                        <declaration name="level" type="int" line="517"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="523">
                Returns a random level for inserting a new node.
                  Hardwired to k=1, p=0.5, max 31 (see above and
                  Pugh&apos;s &quot;Skip List Cookbook&quot;, sec 3.4).
                  This uses the simplest of the generators described in George
                  Marsaglia&apos;s &quot;Xorshift RNGs&quot; paper.  This is not a high-quality
                  generator but is acceptable here.                
            </javadoc>
            <method name="randomLevel" type="int" line="531">
                <declaration name="x" type="int" line="532"/>
                <declaration name="level" type="int" line="537"/>
            </method>
            <javadoc line="541">
                Creates and adds index nodes for the given node.                
                <param>
                    z the node                    
                </param>
                <param>
                    level the level of the index                    
                </param>
            </javadoc>
            <method name="insertIndex" type="void" line="546">
                <params>
                    <param name="z" type="Node<K,V>"/>
                    <param name="level" type="int"/>
                </params>
                <declaration name="h" type="HeadIndex&lt;K,V&gt;" line="547"/>
                <declaration name="max" type="int" line="548"/>
                <scope line="549">
                    <declaration name="idx" type="Index&lt;K,V&gt;" line="550"/>
                </scope>
                <scope line="554">
                    <declaration name="idxs" type="Index&lt;K,V&gt;[]" line="556"/>
                    <declaration name="idx" type="Index&lt;K,V&gt;" line="557"/>
                    <declaration name="oldh" type="HeadIndex&lt;K,V&gt;" line="559"/>
                    <declaration name="k" type="int" line="560"/>
                    <scope line="561">
                        <declaration name="oldLevel" type="int" line="563"/>
                        <scope line="564"/>
                        <declaration name="newh" type="HeadIndex&lt;K,V&gt;" line="568"/>
                        <declaration name="oldbase" type="Node&lt;K,V&gt;" line="569"/>
                        <scope line="571"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="579">
                Adds given index nodes from given level down to 1.                
                <param>
                    idx the topmost index node being inserted                    
                </param>
                <param>
                    h the value of head to use to insert. This must be
                      snapshotted by callers to provide correct insertion level                    
                </param>
                <param>
                    indexLevel the level of the index                    
                </param>
            </javadoc>
            <method name="addIndex" type="void" line="586">
                <params>
                    <param name="idx" type="Index<K,V>"/>
                    <param name="h" type="HeadIndex<K,V>"/>
                    <param name="indexLevel" type="int"/>
                </params>
                <declaration name="insertionLevel" type="int" line="587"/>
                <declaration name="key" type="Comparable&lt;? super K&gt;" line="588"/>
                <scope line="590">
                    <declaration name="j" type="int" line="591"/>
                    <declaration name="q" type="Index&lt;K,V&gt;" line="592"/>
                    <declaration name="r" type="Index&lt;K,V&gt;" line="593"/>
                    <declaration name="t" type="Index&lt;K,V&gt;" line="594"/>
                    <scope line="595">
                        <scope line="596">
                            <declaration name="n" type="Node&lt;K,V&gt;" line="597"/>
                            <declaration name="c" type="int" line="598"/>
                            <scope line="599"/>
                            <scope line="604"/>
                        </scope>
                        <scope line="610">
                            <scope line="611"/>
                            <scope line="616"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="627">
                Main deletion method. Locates node, nulls value, appends a
                  deletion marker, unlinks predecessor, removes associated index
                  nodes, and possibly reduces head index level.
                  Index nodes are cleared out simply by calling findPredecessor.
                  which unlinks indexes to deleted nodes found along path to key,
                  which will include the indexes to this node.  This is done
                  unconditionally. We can&apos;t check beforehand whether there are
                  index nodes because it might be the case that some or all
                  indexes hadn&apos;t been inserted yet for this node during initial
                  search for it, and we&apos;d like to ensure lack of garbage
                  retention, so must call to be sure.                
                <param>
                    okey the key                    
                </param>
                <param>
                    value if non-null, the value that must be
                      associated with key                    
                </param>
                <return>
                    the node, or null if not found                    
                </return>
            </javadoc>
            <method name="doRemove" type="V" line="644">
                <params>
                    <param name="okey" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
                <declaration name="key" type="Comparable&lt;? super K&gt;" line="645"/>
                <scope line="646">
                    <declaration name="b" type="Node&lt;K,V&gt;" line="647"/>
                    <declaration name="n" type="Node&lt;K,V&gt;" line="648"/>
                    <scope line="649">
                        <declaration name="f" type="Node&lt;K,V&gt;" line="651"/>
                        <declaration name="v" type="Object" line="653"/>
                        <scope line="654"/>
                        <declaration name="c" type="int" line="659"/>
                        <scope line="661"/>
                        <scope line="669"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="677">
                Possibly reduce head level if it has no nodes.  This method can
                  (rarely) make mistakes, in which case levels can disappear even
                  though they are about to contain index nodes. This impacts
                  performance, not correctness.  To minimize mistakes as well as
                  to reduce hysteresis, the level is reduced by one only if the
                  topmost three levels look empty. Also, if the removed level
                  looks non-empty after CAS, we try to change it back quick
                  before anyone notices our mistake! (This trick works pretty
                  well because this method will practically never make mistakes
                  unless current thread stalls immediately before first CAS, in
                  which case it is very unlikely to stall again immediately
                  afterwards, so will recover.)
                  We put up with all this rather than just let levels grow
                  because otherwise, even a small map that has undergone a large
                  number of insertions and removals will have a lot of levels,
                  slowing down access more than would an occasional unwanted
                  reduction.                
            </javadoc>
            <method name="tryReduceLevel" type="void" line="696">
                <declaration name="h" type="HeadIndex&lt;K,V&gt;" line="697"/>
                <declaration name="d" type="HeadIndex&lt;K,V&gt;" line="698"/>
                <declaration name="e" type="HeadIndex&lt;K,V&gt;" line="699"/>
            </method>
            <javadoc line="702">
                Specialized variant of findNode to get first valid node.                
                <return>
                    first node or null if empty                    
                </return>
            </javadoc>
            <method name="findFirst" type="Node<K,V>" line="706">
                <scope line="707">
                    <declaration name="b" type="Node&lt;K,V&gt;" line="708"/>
                    <declaration name="n" type="Node&lt;K,V&gt;" line="709"/>
                </scope>
            </method>
            <javadoc line="715">
                Removes first entry; returns its snapshot.                
                <return>
                    null if empty, else snapshot of first entry                    
                </return>
            </javadoc>
            <method name="doRemoveFirstEntry" type="Map.Entry<K,V>" line="719">
                <scope line="720">
                    <declaration name="b" type="Node&lt;K,V&gt;" line="721"/>
                    <declaration name="n" type="Node&lt;K,V&gt;" line="722"/>
                    <declaration name="f" type="Node&lt;K,V&gt;" line="724"/>
                    <declaration name="v" type="Object" line="726"/>
                    <scope line="727"/>
                </scope>
            </method>
            <javadoc line="737">
                Clears out index nodes associated with deleted first entry.                
            </javadoc>
            <method name="clearIndexToFirst" type="void" line="740">
                <scope line="741">
                    <declaration name="q" type="Index&lt;K,V&gt;" line="742"/>
                    <scope line="743">
                        <declaration name="r" type="Index&lt;K,V&gt;" line="744"/>
                        <scope line="746"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="753">
                Specialized version of find to get last valid node.                
                <return>
                    last node or null if empty                    
                </return>
            </javadoc>
            <method name="findLast" type="Node<K,V>" line="757">
                <declaration name="q" type="Index&lt;K,V&gt;" line="758"/>
                <scope line="759">
                    <declaration name="d" type="Index&lt;K,V&gt;" line="760"/>
                    <scope line="761">
                        <scope line="762"/>
                    </scope>
                    <scope line="768"/>
                    <scope line="771">
                        <declaration name="b" type="Node&lt;K,V&gt;" line="772"/>
                        <declaration name="n" type="Node&lt;K,V&gt;" line="773"/>
                        <scope line="774">
                            <declaration name="f" type="Node&lt;K,V&gt;" line="776"/>
                            <declaration name="v" type="Object" line="778"/>
                            <scope line="779"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="791">
                Specialized variant of findPredecessor to get predecessor of last
                  valid node.  Needed when removing the last entry.  It is possible
                  that all successors of returned node will have been deleted upon
                  return, in which case this method can be retried.                
                <return>
                    likely predecessor of last node                    
                </return>
            </javadoc>
            <method name="findPredecessorOfLast" type="Node<K,V>" line="798">
                <scope line="799">
                    <declaration name="q" type="Index&lt;K,V&gt;" line="800"/>
                    <scope line="801">
                        <declaration name="d" type="Index&lt;K,V&gt;" line="802"/>
                        <scope line="803">
                            <scope line="804"/>
                            <scope line="808"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="818">
                Removes last entry; returns its snapshot.
                  Specialized variant of doRemove.                
                <return>
                    null if empty, else snapshot of last entry                    
                </return>
            </javadoc>
            <method name="doRemoveLastEntry" type="Map.Entry<K,V>" line="823">
                <scope line="824">
                    <declaration name="b" type="Node&lt;K,V&gt;" line="825"/>
                    <declaration name="n" type="Node&lt;K,V&gt;" line="826"/>
                    <scope line="827"/>
                    <scope line="831">
                        <declaration name="f" type="Node&lt;K,V&gt;" line="832"/>
                        <declaration name="v" type="Object" line="834"/>
                        <scope line="835"/>
                        <scope line="840"/>
                        <declaration name="key" type="K" line="846"/>
                        <declaration name="ck" type="Comparable&lt;? super K&gt;" line="847"/>
                        <scope line="849"/>
                    </scope>
                </scope>
            </method>
            <declaration name="EQ" type="int" line="857"/>
            <declaration name="LT" type="int" line="858"/>
            <declaration name="GT" type="int" line="859"/>
            <javadoc line="860">
                Utility for ceiling, floor, lower, higher methods.                
                <param>
                    kkey the key                    
                </param>
                <param>
                    rel the relation -- OR'ed combination of EQ, LT, GT                    
                </param>
                <return>
                    nearest node fitting relation, or null if no such                    
                </return>
            </javadoc>
            <method name="findNear" type="Node<K,V>" line="866">
                <params>
                    <param name="kkey" type="K"/>
                    <param name="rel" type="int"/>
                </params>
                <declaration name="key" type="Comparable&lt;? super K&gt;" line="867"/>
                <scope line="868">
                    <declaration name="b" type="Node&lt;K,V&gt;" line="869"/>
                    <declaration name="n" type="Node&lt;K,V&gt;" line="870"/>
                    <scope line="871">
                        <declaration name="f" type="Node&lt;K,V&gt;" line="873"/>
                        <declaration name="v" type="Object" line="875"/>
                        <scope line="876"/>
                        <declaration name="c" type="int" line="881"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="889">
                Returns SimpleImmutableEntry for results of findNear.                
                <param>
                    key the key                    
                </param>
                <param>
                    rel the relation -- OR'ed combination of EQ, LT, GT                    
                </param>
                <return>
                    Entry fitting relation, or null if no such                    
                </return>
            </javadoc>
            <method name="getNear" type="AbstractMap.SimpleImmutableEntry<K,V>" line="895">
                <params>
                    <param name="key" type="K"/>
                    <param name="rel" type="int"/>
                </params>
                <scope line="896">
                    <declaration name="n" type="Node&lt;K,V&gt;" line="897"/>
                    <declaration name="e" type="AbstractMap.SimpleImmutableEntry&lt;K,V&gt;" line="899"/>
                </scope>
            </method>
            <javadoc line="903">
                Constructs a new, empty map, sorted according to the{@linkplain Comparable natural ordering} of the keys.                
            </javadoc>
            <method name="ConcurrentSkipListMap" type="constructor" line="906"/>
            <javadoc line="910">
                Constructs a new, empty map, sorted according to the specified
                  comparator.                
                <param>
                    comparator the comparator that will be used to order this map.
                      If <tt>null</tt>, the {@linkplain Comparable natural
                      ordering} of the keys will be used.                    
                </param>
            </javadoc>
            <method name="ConcurrentSkipListMap" type="constructor" line="917">
                <params>
                    <param name="comparator" type="Comparator<? super K>"/>
                </params>
            </method>
            <javadoc line="921">
                Constructs a new map containing the same mappings as the given map,
                  sorted according to the {@linkplain Comparable natural ordering} of
                  the keys.                
                <param>
                    m the map whose mappings are to be placed in this map                    
                </param>
                <throws>
                    ClassCastException if the keys in <tt>m</tt> are not{@link Comparable}, or are not mutually comparable                    
                </throws>
                <throws>
                    NullPointerException if the specified map or any of its keys
                      or values are null                    
                </throws>
            </javadoc>
            <method name="ConcurrentSkipListMap" type="constructor" line="930">
                <params>
                    <param name="m" type="Map<? extends K,? extends V>"/>
                </params>
            </method>
            <javadoc line="935">
                Constructs a new map containing the same mappings and using the
                  same ordering as the specified sorted map.                
                <param>
                    m the sorted map whose mappings are to be placed in this
                      map, and whose comparator is to be used to sort this map                    
                </param>
                <throws>
                    NullPointerException if the specified sorted map or any of
                      its keys or values are null                    
                </throws>
            </javadoc>
            <method name="ConcurrentSkipListMap" type="constructor" line="943">
                <params>
                    <param name="m" type="SortedMap<K,? extends V>"/>
                </params>
            </method>
            <javadoc line="948">
                Returns a shallow copy of this &lt;tt&gt;ConcurrentSkipListMap&lt;/tt&gt;
                  instance. (The keys and values themselves are not cloned.)                
                <return>
                    a shallow copy of this map                    
                </return>
            </javadoc>
            <method name="clone" type="ConcurrentSkipListMap<K,V>" line="953">
                <declaration name="clone" type="ConcurrentSkipListMap&lt;K,V&gt;" line="954"/>
                <scope line="955"/>
                <scope line="958"/>
            </method>
            <javadoc line="965">
                Streamlined bulk insertion to initialize from elements of
                  given sorted map.  Call only from constructor or clone
                  method.                
            </javadoc>
            <method name="buildFromSorted" type="void" line="970">
                <params>
                    <param name="map" type="SortedMap<K,? extends V>"/>
                </params>
                <declaration name="h" type="HeadIndex&lt;K,V&gt;" line="972"/>
                <declaration name="basepred" type="Node&lt;K,V&gt;" line="973"/>
                <declaration name="preds" type="ArrayList&lt;Index&lt;K,V&gt;&gt;" line="974"/>
                <declaration name="q" type="Index&lt;K,V&gt;" line="976"/>
                <scope line="977"/>
                <declaration name="it" type="Iterator&lt;? extends Map.Entry&lt;? extends K,? extends V&gt;&gt;" line="981"/>
                <scope line="982">
                    <declaration name="e" type="Map.Entry&lt;? extends K,? extends V&gt;" line="983"/>
                    <declaration name="j" type="int" line="984"/>
                    <declaration name="k" type="K" line="986"/>
                    <declaration name="v" type="V" line="987"/>
                    <declaration name="z" type="Node&lt;K,V&gt;" line="989"/>
                    <scope line="992">
                        <declaration name="idx" type="Index&lt;K,V&gt;" line="993"/>
                        <scope line="994">
                            <scope line="997"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1007">
                Save the state of this map to a stream.                
                <serialData>
                    The key (Object) and value (Object) for each
                      key-value mapping represented by the map, followed by
                      <tt>null</tt>. The key-value mappings are emitted in key-order
                      (as determined by the Comparator, or by the keys' natural
                      ordering if no Comparator).                    
                </serialData>
            </javadoc>
            <method name="writeObject" type="void" line="1015">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <scope line="1017">
                    <declaration name="v" type="V" line="1018"/>
                    <scope line="1019"/>
                </scope>
            </method>
            <javadoc line="1026">
                Reconstitute the map from a stream.                
            </javadoc>
            <method name="readObject" type="void" line="1029">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <declaration name="h" type="HeadIndex&lt;K,V&gt;" line="1032"/>
                <declaration name="basepred" type="Node&lt;K,V&gt;" line="1033"/>
                <declaration name="preds" type="ArrayList&lt;Index&lt;K,V&gt;&gt;" line="1034"/>
                <declaration name="q" type="Index&lt;K,V&gt;" line="1036"/>
                <scope line="1037"/>
                <scope line="1041">
                    <declaration name="k" type="Object" line="1042"/>
                    <declaration name="v" type="Object" line="1044"/>
                    <declaration name="key" type="K" line="1046"/>
                    <declaration name="val" type="V" line="1047"/>
                    <declaration name="j" type="int" line="1048"/>
                    <declaration name="z" type="Node&lt;K,V&gt;" line="1050"/>
                    <scope line="1053">
                        <declaration name="idx" type="Index&lt;K,V&gt;" line="1054"/>
                        <scope line="1055">
                            <scope line="1058"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1068">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified
                  key.                
                <param>
                    key key whose presence in this map is to be tested                    
                </param>
                <return>
                    <tt>true</tt> if this map contains a mapping for the specified key                    
                </return>
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="containsKey" type="boolean" line="1077">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="1080">
                Returns the value to which the specified key is mapped,
                  or {@code null} if this map contains no mapping for the key.
                  &lt;p&gt;More formally, if this map contains a mapping from a key{@code k} to a value {@code v} such that {@code key} compares
                  equal to {@code k} according to the map&apos;s ordering, then this
                  method returns {@code v}; otherwise it returns {@code null}.
                  (There can be at most one such mapping.)                
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="get" type="V" line="1091">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="1094">
                Associates the specified value with the specified key in this map.
                  If the map previously contained a mapping for the key, the old
                  value is replaced.                
                <param>
                    key key with which the specified value is to be associated                    
                </param>
                <param>
                    value value to be associated with the specified key                    
                </param>
                <return>
                    the previous value associated with the specified key, or
                      <tt>null</tt> if there was no mapping for the key                    
                </return>
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key or value is null                    
                </throws>
            </javadoc>
            <method name="put" type="V" line="1106">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
            </method>
            <javadoc line="1110">
                Removes the mapping for the specified key from this map if present.                
                <param>
                    key key for which mapping should be removed                    
                </param>
                <return>
                    the previous value associated with the specified key, or
                      <tt>null</tt> if there was no mapping for the key                    
                </return>
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="remove" type="V" line="1119">
                <params>
                    <param name="key" type="Object"/>
                </params>
            </method>
            <javadoc line="1122">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the
                  specified value.  This operation requires time linear in the
                  map size. Additionally, it is possible for the map to change
                  during execution of this method, in which case the returned
                  result may be inaccurate.                
                <param>
                    value value whose presence in this map is to be tested                    
                </param>
                <return>
                    <tt>true</tt> if a mapping to <tt>value</tt> exists;
                      <tt>false</tt> otherwise                    
                </return>
                <throws>
                    NullPointerException if the specified value is null                    
                </throws>
            </javadoc>
            <method name="containsValue" type="boolean" line="1133">
                <params>
                    <param name="value" type="Object"/>
                </params>
                <scope line="1135">
                    <declaration name="v" type="V" line="1136"/>
                </scope>
            </method>
            <javadoc line="1141">
                Returns the number of key-value mappings in this map.  If this map
                  contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, it
                  returns &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.
                  &lt;p&gt;Beware that, unlike in most collections, this method is
                  &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these maps, determining the current
                  number of elements requires traversing them all to count them.
                  Additionally, it is possible for the size to change during
                  execution of this method, in which case the returned result
                  will be inaccurate. Thus, this method is typically not very
                  useful in concurrent applications.                
                <return>
                    the number of elements in this map                    
                </return>
            </javadoc>
            <method name="size" type="int" line="1155">
                <declaration name="count" type="long" line="1156"/>
                <scope line="1157"/>
            </method>
            <javadoc line="1162">
                Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.                
                <return>
                    <tt>true</tt> if this map contains no key-value mappings                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="1166"/>
            <javadoc line="1169">
                Removes all of the mappings from this map.                
            </javadoc>
            <method name="clear" type="void" line="1172"/>
            <javadoc line="1175">
                Returns a {@link NavigableSet} view of the keys contained in this map.
                  The set&apos;s iterator returns the keys in ascending order.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  The set supports element
                  removal, which removes the corresponding mapping from the map,
                  via the {@code Iterator.remove}, {@code Set.remove},{@code removeAll}, {@code retainAll}, and {@code clear}operations.  It does not support the {@code add} or {@code addAll}operations.
                  &lt;p&gt;The view&apos;s {@code iterator} is a &quot;weakly consistent&quot; iterator
                  that will never throw {@link ConcurrentModificationException},
                  and guarantees to traverse elements as they existed upon
                  construction of the iterator, and may (but is not guaranteed to)
                  reflect any modifications subsequent to construction.
                  &lt;p&gt;This method is equivalent to method {@code navigableKeySet}.                
                <return>
                    a navigable set view of the keys in this map                    
                </return>
            </javadoc>
            <method name="keySet" type="NavigableSet<K>" line="1190">
                <declaration name="ks" type="KeySet" line="1191"/>
            </method>
            <method name="navigableKeySet" type="NavigableSet<K>" line="1194">
                <declaration name="ks" type="KeySet" line="1195"/>
            </method>
            <javadoc line="1198">
                Returns a {@link Collection} view of the values contained in this map.
                  The collection&apos;s iterator returns the values in ascending order
                  of the corresponding keys.
                  The collection is backed by the map, so changes to the map are
                  reflected in the collection, and vice-versa.  The collection
                  supports element removal, which removes the corresponding
                  mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
                  &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
                  &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not
                  support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
                  &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator
                  that will never throw {@link ConcurrentModificationException},
                  and guarantees to traverse elements as they existed upon
                  construction of the iterator, and may (but is not guaranteed to)
                  reflect any modifications subsequent to construction.                
            </javadoc>
            <method name="values" type="Collection<V>" line="1215">
                <declaration name="vs" type="Values" line="1216"/>
            </method>
            <javadoc line="1219">
                Returns a {@link Set} view of the mappings contained in this map.
                  The set&apos;s iterator returns the entries in ascending key order.
                  The set is backed by the map, so changes to the map are
                  reflected in the set, and vice-versa.  The set supports element
                  removal, which removes the corresponding mapping from the map,
                  via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
                  &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt;
                  operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or
                  &lt;tt&gt;addAll&lt;/tt&gt; operations.
                  &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator
                  that will never throw {@link ConcurrentModificationException},
                  and guarantees to traverse elements as they existed upon
                  construction of the iterator, and may (but is not guaranteed to)
                  reflect any modifications subsequent to construction.
                  &lt;p&gt;The &lt;tt&gt;Map.Entry&lt;/tt&gt; elements returned by
                  &lt;tt&gt;iterator.next()&lt;/tt&gt; do &lt;em&gt;not&lt;/em&gt; support the
                  &lt;tt&gt;setValue&lt;/tt&gt; operation.                
                <return>
                    a set view of the mappings contained in this map,
                      sorted in ascending key order                    
                </return>
            </javadoc>
            <method name="entrySet" type="Set<Map.Entry<K,V>>" line="1240">
                <declaration name="es" type="EntrySet" line="1241"/>
            </method>
            <method name="descendingMap" type="ConcurrentNavigableMap<K,V>" line="1244">
                <declaration name="dm" type="ConcurrentNavigableMap&lt;K,V&gt;" line="1245"/>
            </method>
            <method name="descendingKeySet" type="NavigableSet<K>" line="1248"/>
            <javadoc line="1251">
                Compares the specified object with this map for equality.
                  Returns &lt;tt&gt;true&lt;/tt&gt; if the given object is also a map and the
                  two maps represent the same mappings.  More formally, two maps
                  &lt;tt&gt;m1&lt;/tt&gt; and &lt;tt&gt;m2&lt;/tt&gt; represent the same mappings if
                  &lt;tt&gt;m1.entrySet().equals(m2.entrySet())&lt;/tt&gt;.  This
                  operation may return misleading results if either map is
                  concurrently modified during execution of this method.                
                <param>
                    o object to be compared for equality with this map                    
                </param>
                <return>
                    <tt>true</tt> if the specified object is equal to this map                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="1262">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <declaration name="m" type="Map&lt;?,?&gt;" line="1265"/>
                <scope line="1266">
                    <scope line="1268">
                        <declaration name="k" type="Object" line="1269"/>
                        <declaration name="v" type="Object" line="1270"/>
                    </scope>
                </scope>
                <scope line="1275"/>
                <scope line="1278"/>
            </method>
            <javadoc line="1282">
                {@inheritDoc}                
                <return>
                    the previous value associated with the specified key,
                      or <tt>null</tt> if there was no mapping for the key                    
                </return>
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key or value is null                    
                </throws>
            </javadoc>
            <method name="putIfAbsent" type="V" line="1290">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
            </method>
            <javadoc line="1294">
                {@inheritDoc}                
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="remove" type="boolean" line="1300">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
            </method>
            <javadoc line="1305">
                {@inheritDoc}                
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if any of the arguments are null                    
                </throws>
            </javadoc>
            <method name="replace" type="boolean" line="1311">
                <params>
                    <param name="key" type="K"/>
                    <param name="oldValue" type="V"/>
                    <param name="newValue" type="V"/>
                </params>
                <declaration name="k" type="Comparable&lt;? super K&gt;" line="1313"/>
                <scope line="1314">
                    <declaration name="n" type="Node&lt;K,V&gt;" line="1315"/>
                    <declaration name="v" type="Object" line="1317"/>
                    <scope line="1318"/>
                </scope>
            </method>
            <javadoc line="1324">
                {@inheritDoc}                
                <return>
                    the previous value associated with the specified key,
                      or <tt>null</tt> if there was no mapping for the key                    
                </return>
                <throws>
                    ClassCastException if the specified key cannot be compared
                      with the keys currently in the map                    
                </throws>
                <throws>
                    NullPointerException if the specified key or value is null                    
                </throws>
            </javadoc>
            <method name="replace" type="V" line="1332">
                <params>
                    <param name="key" type="K"/>
                    <param name="value" type="V"/>
                </params>
                <declaration name="k" type="Comparable&lt;? super K&gt;" line="1334"/>
                <scope line="1335">
                    <declaration name="n" type="Node&lt;K,V&gt;" line="1336"/>
                    <declaration name="v" type="Object" line="1338"/>
                </scope>
            </method>
            <method name="comparator" type="Comparator<? super K>" line="1342"/>
            <javadoc line="1345">
                @throws NoSuchElementException {@inheritDoc}                
            </javadoc>
            <method name="firstKey" type="K" line="1348">
                <declaration name="n" type="Node&lt;K,V&gt;" line="1349"/>
            </method>
            <javadoc line="1353">
                @throws NoSuchElementException {@inheritDoc}                
            </javadoc>
            <method name="lastKey" type="K" line="1356">
                <declaration name="n" type="Node&lt;K,V&gt;" line="1357"/>
            </method>
            <javadoc line="1361">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if {@code fromKey} or {@code toKey} is null                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="subMap" type="ConcurrentNavigableMap<K,V>" line="1366">
                <params>
                    <param name="fromKey" type="K"/>
                    <param name="fromInclusive" type="boolean"/>
                    <param name="toKey" type="K"/>
                    <param name="toInclusive" type="boolean"/>
                </params>
            </method>
            <javadoc line="1370">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if {@code toKey} is null                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="headMap" type="ConcurrentNavigableMap<K,V>" line="1375">
                <params>
                    <param name="toKey" type="K"/>
                    <param name="inclusive" type="boolean"/>
                </params>
            </method>
            <javadoc line="1379">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if {@code fromKey} is null                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="tailMap" type="ConcurrentNavigableMap<K,V>" line="1384">
                <params>
                    <param name="fromKey" type="K"/>
                    <param name="inclusive" type="boolean"/>
                </params>
            </method>
            <javadoc line="1388">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if {@code fromKey} or {@code toKey} is null                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="subMap" type="ConcurrentNavigableMap<K,V>" line="1393">
                <params>
                    <param name="fromKey" type="K"/>
                    <param name="toKey" type="K"/>
                </params>
            </method>
            <javadoc line="1396">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if {@code toKey} is null                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="headMap" type="ConcurrentNavigableMap<K,V>" line="1401">
                <params>
                    <param name="toKey" type="K"/>
                </params>
            </method>
            <javadoc line="1404">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if {@code fromKey} is null                    
                </throws>
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="tailMap" type="ConcurrentNavigableMap<K,V>" line="1409">
                <params>
                    <param name="fromKey" type="K"/>
                </params>
            </method>
            <javadoc line="1412">
                Returns a key-value mapping associated with the greatest key
                  strictly less than the given key, or &lt;tt&gt;null&lt;/tt&gt; if there is
                  no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support the
                  &lt;tt&gt;Entry.setValue&lt;/tt&gt; method.                
                <throws>
                    ClassCastException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="lowerEntry" type="Map.Entry<K,V>" line="1420">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="1423">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="lowerKey" type="K" line="1427">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="n" type="Node&lt;K,V&gt;" line="1428"/>
            </method>
            <javadoc line="1431">
                Returns a key-value mapping associated with the greatest key
                  less than or equal to the given key, or &lt;tt&gt;null&lt;/tt&gt; if there
                  is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support
                  the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method.                
                <param>
                    key the key                    
                </param>
                <throws>
                    ClassCastException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="floorEntry" type="Map.Entry<K,V>" line="1440">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="1443">
                @param key the key                
                <throws>
                    ClassCastException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="floorKey" type="K" line="1448">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="n" type="Node&lt;K,V&gt;" line="1449"/>
            </method>
            <javadoc line="1452">
                Returns a key-value mapping associated with the least key
                  greater than or equal to the given key, or &lt;tt&gt;null&lt;/tt&gt; if
                  there is no such entry. The returned entry does &lt;em&gt;not&lt;/em&gt;
                  support the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method.                
                <throws>
                    ClassCastException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="ceilingEntry" type="Map.Entry<K,V>" line="1460">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="1463">
                @throws ClassCastException {@inheritDoc}                
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="ceilingKey" type="K" line="1467">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="n" type="Node&lt;K,V&gt;" line="1468"/>
            </method>
            <javadoc line="1471">
                Returns a key-value mapping associated with the least key
                  strictly greater than the given key, or &lt;tt&gt;null&lt;/tt&gt; if there
                  is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support
                  the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method.                
                <param>
                    key the key                    
                </param>
                <throws>
                    ClassCastException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="higherEntry" type="Map.Entry<K,V>" line="1480">
                <params>
                    <param name="key" type="K"/>
                </params>
            </method>
            <javadoc line="1483">
                @param key the key                
                <throws>
                    ClassCastException {@inheritDoc}                    
                </throws>
                <throws>
                    NullPointerException if the specified key is null                    
                </throws>
            </javadoc>
            <method name="higherKey" type="K" line="1488">
                <params>
                    <param name="key" type="K"/>
                </params>
                <declaration name="n" type="Node&lt;K,V&gt;" line="1489"/>
            </method>
            <javadoc line="1492">
                Returns a key-value mapping associated with the least
                  key in this map, or &lt;tt&gt;null&lt;/tt&gt; if the map is empty.
                  The returned entry does &lt;em&gt;not&lt;/em&gt; support
                  the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method.                
            </javadoc>
            <method name="firstEntry" type="Map.Entry<K,V>" line="1498">
                <scope line="1499">
                    <declaration name="n" type="Node&lt;K,V&gt;" line="1500"/>
                    <declaration name="e" type="AbstractMap.SimpleImmutableEntry&lt;K,V&gt;" line="1502"/>
                </scope>
            </method>
            <javadoc line="1506">
                Returns a key-value mapping associated with the greatest
                  key in this map, or &lt;tt&gt;null&lt;/tt&gt; if the map is empty.
                  The returned entry does &lt;em&gt;not&lt;/em&gt; support
                  the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method.                
            </javadoc>
            <method name="lastEntry" type="Map.Entry<K,V>" line="1512">
                <scope line="1513">
                    <declaration name="n" type="Node&lt;K,V&gt;" line="1514"/>
                    <declaration name="e" type="AbstractMap.SimpleImmutableEntry&lt;K,V&gt;" line="1516"/>
                </scope>
            </method>
            <javadoc line="1520">
                Removes and returns a key-value mapping associated with
                  the least key in this map, or &lt;tt&gt;null&lt;/tt&gt; if the map is empty.
                  The returned entry does &lt;em&gt;not&lt;/em&gt; support
                  the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method.                
            </javadoc>
            <method name="pollFirstEntry" type="Map.Entry<K,V>" line="1526"/>
            <javadoc line="1529">
                Removes and returns a key-value mapping associated with
                  the greatest key in this map, or &lt;tt&gt;null&lt;/tt&gt; if the map is empty.
                  The returned entry does &lt;em&gt;not&lt;/em&gt; support
                  the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method.                
            </javadoc>
            <method name="pollLastEntry" type="Map.Entry<K,V>" line="1535"/>
            <class name="Iter" line="1538">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                </implements>
                <javadoc line="1538">
                    Base of iterator classes:                    
                </javadoc>
                <declaration name="lastReturned" type="Node&lt;K,V&gt;" line="1542"/>
                <javadoc line="1542">
                    the last node returned by next()                    
                </javadoc>
                <declaration name="next" type="Node&lt;K,V&gt;" line="1546"/>
                <javadoc line="1546">
                    the next node to return from next();                    
                </javadoc>
                <declaration name="nextValue" type="V" line="1550"/>
                <javadoc line="1550">
                    Cache of next value field to maintain weak consistency                    
                </javadoc>
                <javadoc line="1554">
                    Initializes ascending iterator for entire range.                    
                </javadoc>
                <method name="Iter" type="constructor" line="1557">
                    <scope line="1558">
                        <declaration name="x" type="Object" line="1561"/>
                        <scope line="1562"/>
                    </scope>
                </method>
                <method name="hasNext" type="boolean" line="1568"/>
                <javadoc line="1571">
                    Advances next to higher entry.                    
                </javadoc>
                <method name="advance" type="void" line="1574">
                    <scope line="1577">
                        <declaration name="x" type="Object" line="1580"/>
                        <scope line="1581"/>
                    </scope>
                </method>
                <method name="remove" type="void" line="1587">
                    <declaration name="l" type="Node&lt;K,V&gt;" line="1588"/>
                </method>
            </class>
            <class name="ValueIterator" line="1594">
                <extends class="Iter">
                    <type_params>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <method name="next" type="V" line="1595">
                    <declaration name="v" type="V" line="1596"/>
                </method>
            </class>
            <class name="KeyIterator" line="1601">
                <extends class="Iter">
                    <type_params>
                        <type_param name="K"/>
                    </type_params>
                </extends>
                <method name="next" type="K" line="1602">
                    <declaration name="n" type="Node&lt;K,V&gt;" line="1603"/>
                </method>
            </class>
            <class name="EntryIterator" line="1608">
                <extends class="Iter">
                    <type_params>
                        <type_param name="Map.Entry<K,V>"/>
                    </type_params>
                </extends>
                <method name="next" type="Map.Entry<K,V>" line="1609">
                    <declaration name="n" type="Node&lt;K,V&gt;" line="1610"/>
                    <declaration name="v" type="V" line="1611"/>
                </method>
            </class>
            <method name="keyIterator" type="Iterator<K>" line="1616"/>
            <method name="valueIterator" type="Iterator<V>" line="1619"/>
            <method name="entryIterator" type="Iterator<Map.Entry<K,V>>" line="1622"/>
            <method name="toList" type="List<E>" line="1625">
                <params>
                    <param name="c" type="Collection<E>"/>
                </params>
                <declaration name="list" type="List&lt;E&gt;" line="1626"/>
            </method>
            <class name="KeySet" line="1630">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <implements interface="NavigableSet">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="m" type="ConcurrentNavigableMap&lt;E,Object&gt;" line="1631"/>
                <method name="KeySet" type="constructor" line="1632">
                    <params>
                        <param name="map" type="ConcurrentNavigableMap<E,Object>"/>
                    </params>
                </method>
                <method name="size" type="int" line="1635"/>
                <method name="isEmpty" type="boolean" line="1638"/>
                <method name="contains" type="boolean" line="1641">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="1644">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="1647"/>
                <method name="lower" type="E" line="1650">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="floor" type="E" line="1653">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="ceiling" type="E" line="1656">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="higher" type="E" line="1659">
                    <params>
                        <param name="e" type="E"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super E>" line="1662"/>
                <method name="first" type="E" line="1665"/>
                <method name="last" type="E" line="1668"/>
                <method name="pollFirst" type="E" line="1671">
                    <declaration name="e" type="Map.Entry&lt;E,Object&gt;" line="1672"/>
                </method>
                <method name="pollLast" type="E" line="1675">
                    <declaration name="e" type="Map.Entry&lt;E,Object&gt;" line="1676"/>
                </method>
                <method name="iterator" type="Iterator<E>" line="1679"/>
                <method name="equals" type="boolean" line="1683">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="c" type="Collection&lt;?&gt;" line="1686"/>
                    <scope line="1687"/>
                    <scope line="1690"/>
                    <scope line="1693"/>
                </method>
                <method name="toArray" type="Object[]" line="1697"/>
                <method name="toArray" type="T[]" line="1700">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
                <method name="descendingIterator" type="Iterator<E>" line="1703"/>
                <method name="subSet" type="NavigableSet<E>" line="1706">
                    <params>
                        <param name="fromElement" type="E"/>
                        <param name="fromInclusive" type="boolean"/>
                        <param name="toElement" type="E"/>
                        <param name="toInclusive" type="boolean"/>
                    </params>
                </method>
                <method name="headSet" type="NavigableSet<E>" line="1709">
                    <params>
                        <param name="toElement" type="E"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="tailSet" type="NavigableSet<E>" line="1712">
                    <params>
                        <param name="fromElement" type="E"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="subSet" type="NavigableSet<E>" line="1715">
                    <params>
                        <param name="fromElement" type="E"/>
                        <param name="toElement" type="E"/>
                    </params>
                </method>
                <method name="headSet" type="NavigableSet<E>" line="1718">
                    <params>
                        <param name="toElement" type="E"/>
                    </params>
                </method>
                <method name="tailSet" type="NavigableSet<E>" line="1721">
                    <params>
                        <param name="fromElement" type="E"/>
                    </params>
                </method>
                <method name="descendingSet" type="NavigableSet<E>" line="1724"/>
            </class>
            <class name="Values" line="1728">
                <type_params>
                    <type_param name="E"/>
                </type_params>
                <extends class="AbstractCollection">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </extends>
                <declaration name="m" type="ConcurrentNavigableMap&lt;Object,E&gt;" line="1729"/>
                <method name="Values" type="constructor" line="1730">
                    <params>
                        <param name="map" type="ConcurrentNavigableMap<Object,E>"/>
                    </params>
                </method>
                <method name="iterator" type="Iterator<E>" line="1733"/>
                <method name="isEmpty" type="boolean" line="1737"/>
                <method name="size" type="int" line="1740"/>
                <method name="contains" type="boolean" line="1743">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="clear" type="void" line="1746"/>
                <method name="toArray" type="Object[]" line="1749"/>
                <method name="toArray" type="T[]" line="1752">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
            </class>
            <class name="EntrySet" line="1756">
                <type_params>
                    <type_param name="K1"/>
                    <type_param name="V1"/>
                </type_params>
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="Map.Entry<K1,V1>"/>
                    </type_params>
                </extends>
                <declaration name="m" type="ConcurrentNavigableMap&lt;K1,V1&gt;" line="1757"/>
                <method name="EntrySet" type="constructor" line="1758">
                    <params>
                        <param name="map" type="ConcurrentNavigableMap<K1,V1>"/>
                    </params>
                </method>
                <method name="iterator" type="Iterator<Map.Entry<K1,V1>>" line="1761"/>
                <method name="contains" type="boolean" line="1765">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="e" type="Map.Entry&lt;K1,V1&gt;" line="1767"/>
                    <declaration name="v" type="V1" line="1768"/>
                </method>
                <method name="remove" type="boolean" line="1771">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="e" type="Map.Entry&lt;K1,V1&gt;" line="1773"/>
                </method>
                <method name="isEmpty" type="boolean" line="1776"/>
                <method name="size" type="int" line="1779"/>
                <method name="clear" type="void" line="1782"/>
                <method name="equals" type="boolean" line="1785">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <declaration name="c" type="Collection&lt;?&gt;" line="1788"/>
                    <scope line="1789"/>
                    <scope line="1792"/>
                    <scope line="1795"/>
                </method>
                <method name="toArray" type="Object[]" line="1799"/>
                <method name="toArray" type="T[]" line="1802">
                    <params>
                        <param name="a" type="T[]"/>
                    </params>
                </method>
            </class>
            <class name="SubMap" line="1806">
                <type_params>
                    <type_param name="K"/>
                    <type_param name="V"/>
                </type_params>
                <extends class="AbstractMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </extends>
                <implements interface="ConcurrentNavigableMap">
                    <type_params>
                        <type_param name="K"/>
                        <type_param name="V"/>
                    </type_params>
                </implements>
                <implements interface="Cloneable"/>
                <implements interface="java.io.Serializable"/>
                <javadoc line="1806">
                    Submaps returned by {@link ConcurrentSkipListMap} submap operations
                      represent a subrange of mappings of their underlying
                      maps. Instances of this class support all methods of their
                      underlying maps, differing in that mappings outside their range are
                      ignored, and attempts to add mappings outside their ranges result
                      in {@link IllegalArgumentException}.  Instances of this class are
                      constructed only using the &lt;tt&gt;subMap&lt;/tt&gt;, &lt;tt&gt;headMap&lt;/tt&gt;, and
                      &lt;tt&gt;tailMap&lt;/tt&gt; methods of their underlying maps.                    
                    <serial>
                        include                        
                    </serial>
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1818"/>
                <declaration name="m" type="ConcurrentSkipListMap&lt;K,V&gt;" line="1819"/>
                <javadoc line="1819">
                    Underlying map                    
                </javadoc>
                <declaration name="lo" type="K" line="1823"/>
                <javadoc line="1823">
                    lower bound key, or null if from start                    
                </javadoc>
                <declaration name="hi" type="K" line="1827"/>
                <javadoc line="1827">
                    upper bound key, or null if to end                    
                </javadoc>
                <declaration name="loInclusive" type="boolean" line="1831"/>
                <javadoc line="1831">
                    inclusion flag for lo                    
                </javadoc>
                <declaration name="hiInclusive" type="boolean" line="1835"/>
                <javadoc line="1835">
                    inclusion flag for hi                    
                </javadoc>
                <declaration name="isDescending" type="boolean" line="1839"/>
                <javadoc line="1839">
                    direction                    
                </javadoc>
                <declaration name="keySetView" type="KeySet&lt;K&gt;" line="1843"/>
                <declaration name="entrySetView" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="1844"/>
                <declaration name="valuesView" type="Collection&lt;V&gt;" line="1845"/>
                <javadoc line="1846">
                    Creates a new submap, initializing all fields                    
                </javadoc>
                <method name="SubMap" type="constructor" line="1849">
                    <params>
                        <param name="map" type="ConcurrentSkipListMap<K,V>"/>
                        <param name="fromKey" type="K"/>
                        <param name="fromInclusive" type="boolean"/>
                        <param name="toKey" type="K"/>
                        <param name="toInclusive" type="boolean"/>
                        <param name="isDescending" type="boolean"/>
                    </params>
                </method>
                <method name="tooLow" type="boolean" line="1858">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                    <scope line="1859">
                        <declaration name="c" type="int" line="1860"/>
                    </scope>
                </method>
                <method name="tooHigh" type="boolean" line="1865">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                    <scope line="1866">
                        <declaration name="c" type="int" line="1867"/>
                    </scope>
                </method>
                <method name="inBounds" type="boolean" line="1872">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="checkKeyBounds" type="void" line="1875">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <javadoc line="1879">
                    Returns true if node key is less than upper bound of range                    
                </javadoc>
                <method name="isBeforeEnd" type="boolean" line="1882">
                    <params>
                        <param name="n" type="ConcurrentSkipListMap.Node<K,V>"/>
                    </params>
                    <declaration name="k" type="K" line="1885"/>
                    <declaration name="c" type="int" line="1887"/>
                </method>
                <javadoc line="1891">
                    Returns lowest node. This node might not be in range, so
                      most usages need to check bounds                    
                </javadoc>
                <method name="loNode" type="ConcurrentSkipListMap.Node<K,V>" line="1895"/>
                <javadoc line="1900">
                    Returns highest node. This node might not be in range, so
                      most usages need to check bounds                    
                </javadoc>
                <method name="hiNode" type="ConcurrentSkipListMap.Node<K,V>" line="1904"/>
                <javadoc line="1909">
                    Returns lowest absolute key (ignoring directonality)                    
                </javadoc>
                <method name="lowestKey" type="K" line="1912">
                    <declaration name="n" type="ConcurrentSkipListMap.Node&lt;K,V&gt;" line="1913"/>
                </method>
                <javadoc line="1917">
                    Returns highest absolute key (ignoring directonality)                    
                </javadoc>
                <method name="highestKey" type="K" line="1920">
                    <declaration name="n" type="ConcurrentSkipListMap.Node&lt;K,V&gt;" line="1921"/>
                    <scope line="1922">
                        <declaration name="last" type="K" line="1923"/>
                    </scope>
                </method>
                <method name="lowestEntry" type="Map.Entry<K,V>" line="1928">
                    <scope line="1929">
                        <declaration name="n" type="ConcurrentSkipListMap.Node&lt;K,V&gt;" line="1930"/>
                        <declaration name="e" type="Map.Entry&lt;K,V&gt;" line="1932"/>
                    </scope>
                </method>
                <method name="highestEntry" type="Map.Entry<K,V>" line="1936">
                    <scope line="1937">
                        <declaration name="n" type="ConcurrentSkipListMap.Node&lt;K,V&gt;" line="1938"/>
                        <declaration name="e" type="Map.Entry&lt;K,V&gt;" line="1940"/>
                    </scope>
                </method>
                <method name="removeLowest" type="Map.Entry<K,V>" line="1944">
                    <scope line="1945">
                        <declaration name="n" type="Node&lt;K,V&gt;" line="1946"/>
                        <declaration name="k" type="K" line="1948"/>
                        <declaration name="v" type="V" line="1950"/>
                    </scope>
                </method>
                <method name="removeHighest" type="Map.Entry<K,V>" line="1954">
                    <scope line="1955">
                        <declaration name="n" type="Node&lt;K,V&gt;" line="1956"/>
                        <declaration name="k" type="K" line="1958"/>
                        <declaration name="v" type="V" line="1960"/>
                    </scope>
                </method>
                <javadoc line="1964">
                    Submap version of ConcurrentSkipListMap.getNearEntry                    
                </javadoc>
                <method name="getNearEntry" type="Map.Entry<K,V>" line="1967">
                    <params>
                        <param name="key" type="K"/>
                        <param name="rel" type="int"/>
                    </params>
                    <scope line="1968"/>
                    <scope line="1974">
                        <declaration name="n" type="Node&lt;K,V&gt;" line="1975"/>
                        <declaration name="k" type="K" line="1977"/>
                        <declaration name="v" type="V" line="1978"/>
                    </scope>
                </method>
                <method name="getNearKey" type="K" line="1982">
                    <params>
                        <param name="key" type="K"/>
                        <param name="rel" type="int"/>
                    </params>
                    <scope line="1983"/>
                    <scope line="1987">
                        <scope line="1988">
                            <declaration name="n" type="ConcurrentSkipListMap.Node&lt;K,V&gt;" line="1989"/>
                        </scope>
                    </scope>
                    <scope line="1994">
                        <scope line="1995">
                            <declaration name="n" type="ConcurrentSkipListMap.Node&lt;K,V&gt;" line="1996"/>
                            <scope line="1997">
                                <declaration name="last" type="K" line="1998"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="2004">
                        <declaration name="n" type="Node&lt;K,V&gt;" line="2005"/>
                        <declaration name="k" type="K" line="2007"/>
                        <declaration name="v" type="V" line="2008"/>
                    </scope>
                </method>
                <method name="containsKey" type="boolean" line="2012">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                    <declaration name="k" type="K" line="2014"/>
                </method>
                <method name="get" type="V" line="2017">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                    <declaration name="k" type="K" line="2019"/>
                </method>
                <method name="put" type="V" line="2022">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                    </params>
                </method>
                <method name="remove" type="V" line="2026">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                    <declaration name="k" type="K" line="2027"/>
                </method>
                <method name="size" type="int" line="2030">
                    <declaration name="count" type="long" line="2031"/>
                    <scope line="2032"/>
                </method>
                <method name="isEmpty" type="boolean" line="2037"/>
                <method name="containsValue" type="boolean" line="2040">
                    <params>
                        <param name="value" type="Object"/>
                    </params>
                    <scope line="2042">
                        <declaration name="v" type="V" line="2043"/>
                    </scope>
                </method>
                <method name="clear" type="void" line="2048">
                    <scope line="2049"/>
                </method>
                <method name="putIfAbsent" type="V" line="2053">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="2057">
                    <params>
                        <param name="key" type="Object"/>
                        <param name="value" type="Object"/>
                    </params>
                    <declaration name="k" type="K" line="2058"/>
                </method>
                <method name="replace" type="boolean" line="2061">
                    <params>
                        <param name="key" type="K"/>
                        <param name="oldValue" type="V"/>
                        <param name="newValue" type="V"/>
                    </params>
                </method>
                <method name="replace" type="V" line="2065">
                    <params>
                        <param name="key" type="K"/>
                        <param name="value" type="V"/>
                    </params>
                </method>
                <method name="comparator" type="Comparator<? super K>" line="2069">
                    <declaration name="cmp" type="Comparator&lt;? super K&gt;" line="2070"/>
                </method>
                <javadoc line="2074">
                    Utility to create submaps, where given bounds override
                      unbounded(null) ones and/or are checked against bounded ones.                    
                </javadoc>
                <method name="newSubMap" type="SubMap<K,V>" line="2078">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="fromInclusive" type="boolean"/>
                        <param name="toKey" type="K"/>
                        <param name="toInclusive" type="boolean"/>
                    </params>
                    <scope line="2079">
                        <declaration name="tk" type="K" line="2080"/>
                        <declaration name="ti" type="boolean" line="2083"/>
                    </scope>
                    <scope line="2087">
                        <scope line="2088"/>
                        <scope line="2092">
                            <declaration name="c" type="int" line="2093"/>
                        </scope>
                    </scope>
                    <scope line="2097">
                        <scope line="2098"/>
                        <scope line="2102">
                            <declaration name="c" type="int" line="2103"/>
                        </scope>
                    </scope>
                </method>
                <method name="subMap" type="SubMap<K,V>" line="2109">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="fromInclusive" type="boolean"/>
                        <param name="toKey" type="K"/>
                        <param name="toInclusive" type="boolean"/>
                    </params>
                </method>
                <method name="headMap" type="SubMap<K,V>" line="2113">
                    <params>
                        <param name="toKey" type="K"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="tailMap" type="SubMap<K,V>" line="2117">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="inclusive" type="boolean"/>
                    </params>
                </method>
                <method name="subMap" type="SubMap<K,V>" line="2121">
                    <params>
                        <param name="fromKey" type="K"/>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="headMap" type="SubMap<K,V>" line="2124">
                    <params>
                        <param name="toKey" type="K"/>
                    </params>
                </method>
                <method name="tailMap" type="SubMap<K,V>" line="2127">
                    <params>
                        <param name="fromKey" type="K"/>
                    </params>
                </method>
                <method name="descendingMap" type="SubMap<K,V>" line="2130"/>
                <method name="ceilingEntry" type="Map.Entry<K,V>" line="2133">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="ceilingKey" type="K" line="2136">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="lowerEntry" type="Map.Entry<K,V>" line="2139">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="lowerKey" type="K" line="2142">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="floorEntry" type="Map.Entry<K,V>" line="2145">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="floorKey" type="K" line="2148">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="higherEntry" type="Map.Entry<K,V>" line="2151">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="higherKey" type="K" line="2154">
                    <params>
                        <param name="key" type="K"/>
                    </params>
                </method>
                <method name="firstKey" type="K" line="2157"/>
                <method name="lastKey" type="K" line="2160"/>
                <method name="firstEntry" type="Map.Entry<K,V>" line="2163"/>
                <method name="lastEntry" type="Map.Entry<K,V>" line="2166"/>
                <method name="pollFirstEntry" type="Map.Entry<K,V>" line="2169"/>
                <method name="pollLastEntry" type="Map.Entry<K,V>" line="2172"/>
                <method name="keySet" type="NavigableSet<K>" line="2175">
                    <declaration name="ks" type="KeySet&lt;K&gt;" line="2176"/>
                </method>
                <method name="navigableKeySet" type="NavigableSet<K>" line="2179">
                    <declaration name="ks" type="KeySet&lt;K&gt;" line="2180"/>
                </method>
                <method name="values" type="Collection<V>" line="2183">
                    <declaration name="vs" type="Collection&lt;V&gt;" line="2184"/>
                </method>
                <method name="entrySet" type="Set<Map.Entry<K,V>>" line="2187">
                    <declaration name="es" type="Set&lt;Map.Entry&lt;K,V&gt;&gt;" line="2188"/>
                </method>
                <method name="descendingKeySet" type="NavigableSet<K>" line="2191"/>
                <method name="keyIterator" type="Iterator<K>" line="2194"/>
                <method name="valueIterator" type="Iterator<V>" line="2197"/>
                <method name="entryIterator" type="Iterator<Map.Entry<K,V>>" line="2200"/>
                <class name="SubMapIter" line="2203">
                    <type_params>
                        <type_param name="T"/>
                    </type_params>
                    <implements interface="Iterator">
                        <type_params>
                            <type_param name="T"/>
                        </type_params>
                    </implements>
                    <javadoc line="2203">
                        Variant of main Iter class to traverse through submaps.                        
                    </javadoc>
                    <declaration name="lastReturned" type="Node&lt;K,V&gt;" line="2207"/>
                    <javadoc line="2207">
                        the last node returned by next()                        
                    </javadoc>
                    <declaration name="next" type="Node&lt;K,V&gt;" line="2211"/>
                    <javadoc line="2211">
                        the next node to return from next();                        
                    </javadoc>
                    <declaration name="nextValue" type="V" line="2215"/>
                    <javadoc line="2215">
                        Cache of next value field to maintain weak consistency                        
                    </javadoc>
                    <method name="SubMapIter" type="constructor" line="2219">
                        <scope line="2220">
                            <declaration name="x" type="Object" line="2223"/>
                            <scope line="2224"/>
                        </scope>
                    </method>
                    <method name="hasNext" type="boolean" line="2231"/>
                    <method name="advance" type="void" line="2234"/>
                    <method name="ascend" type="void" line="2240">
                        <scope line="2241">
                            <declaration name="x" type="Object" line="2244"/>
                            <scope line="2245"/>
                        </scope>
                    </method>
                    <method name="descend" type="void" line="2252">
                        <scope line="2253">
                            <declaration name="x" type="Object" line="2256"/>
                            <scope line="2257"/>
                        </scope>
                    </method>
                    <method name="remove" type="void" line="2264">
                        <declaration name="l" type="Node&lt;K,V&gt;" line="2265"/>
                    </method>
                </class>
                <class name="SubMapValueIterator" line="2271">
                    <extends class="SubMapIter">
                        <type_params>
                            <type_param name="V"/>
                        </type_params>
                    </extends>
                    <method name="next" type="V" line="2272">
                        <declaration name="v" type="V" line="2273"/>
                    </method>
                </class>
                <class name="SubMapKeyIterator" line="2278">
                    <extends class="SubMapIter">
                        <type_params>
                            <type_param name="K"/>
                        </type_params>
                    </extends>
                    <method name="next" type="K" line="2279">
                        <declaration name="n" type="Node&lt;K,V&gt;" line="2280"/>
                    </method>
                </class>
                <class name="SubMapEntryIterator" line="2285">
                    <extends class="SubMapIter">
                        <type_params>
                            <type_param name="Map.Entry<K,V>"/>
                        </type_params>
                    </extends>
                    <method name="next" type="Map.Entry<K,V>" line="2286">
                        <declaration name="n" type="Node&lt;K,V&gt;" line="2287"/>
                        <declaration name="v" type="V" line="2288"/>
                    </method>
                </class>
            </class>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="2294"/>
            <declaration name="headOffset" type="long" line="2295"/>
            <scope line="2296">
                <scope line="2297">
                    <declaration name="k" type="Class" line="2299"/>
                </scope>
                <scope line="2302"/>
            </scope>
        </class>
    </source>