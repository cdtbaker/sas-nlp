<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Collections"/>
        <import package="java.util.List"/>
        <import package="java.util.Random"/>
        <import package="java.util.concurrent.AbstractExecutorService"/>
        <import package="java.util.concurrent.Callable"/>
        <import package="java.util.concurrent.ExecutorService"/>
        <import package="java.util.concurrent.Future"/>
        <import package="java.util.concurrent.RejectedExecutionException"/>
        <import package="java.util.concurrent.RunnableFuture"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.TimeoutException"/>
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <import package="java.util.concurrent.locks.LockSupport"/>
        <import package="java.util.concurrent.locks.ReentrantLock"/>
        <import package="java.util.concurrent.locks.Condition"/>
        <class name="ForkJoinPool" line="57">
            <extends class="AbstractExecutorService"/>
            <comment line="157">
                Implementation Overview
                
                 This class provides the central bookkeeping and control for a
                 set of worker threads: Submissions from non-FJ threads enter
                 into a submission queue. Workers take these tasks and typically
                 split them into subtasks that may be stolen by other workers.
                 Preference rules give first priority to processing tasks from
                 their own queues (LIFO or FIFO, depending on mode), then to
                 randomized FIFO steals of tasks in other worker queues, and
                 lastly to new submissions.
                
                 The main throughput advantages of work-stealing stem from
                 decentralized control -- workers mostly take tasks from
                 themselves or each other. We cannot negate this in the
                 implementation of other management responsibilities. The main
                 tactic for avoiding bottlenecks is packing nearly all
                 essentially atomic control state into a single 64bit volatile
                 variable (&quot;ctl&quot;). This variable is read on the order of 10-100
                 times as often as it is modified (always via CAS). (There is
                 some additional control state, for example variable &quot;shutdown&quot;
                 for which we can cope with uncoordinated updates.)  This
                 streamlines synchronization and control at the expense of messy
                 constructions needed to repack status bits upon updates.
                 Updates tend not to contend with each other except during
                 bursts while submitted tasks begin or end.  In some cases when
                 they do contend, threads can instead do something else
                 (usually, scan for tasks) until contention subsides.
                
                 To enable packing, we restrict maximum parallelism to (1&lt;&lt;15)-1
                 (which is far in excess of normal operating range) to allow
                 ids, counts, and their negations (used for thresholding) to fit
                 into 16bit fields.
                
                 Recording Workers.  Workers are recorded in the &quot;workers&quot; array
                 that is created upon pool construction and expanded if (rarely)
                 necessary.  This is an array as opposed to some other data
                 structure to support index-based random steals by workers.
                 Updates to the array recording new workers and unrecording
                 terminated ones are protected from each other by a seqLock
                 (scanGuard) but the array is otherwise concurrently readable,
                 and accessed directly by workers. To simplify index-based
                 operations, the array size is always a power of two, and all
                 readers must tolerate null slots. To avoid flailing during
                 start-up, the array is presized to hold twice #parallelism
                 workers (which is unlikely to need further resizing during
                 execution). But to avoid dealing with so many null slots,
                 variable scanGuard includes a mask for the nearest power of two
                 that contains all current workers.  All worker thread creation
                 is on-demand, triggered by task submissions, replacement of
                 terminated workers, andor compensation for blocked
                 workers. However, all other support code is set up to work with
                 other policies.  To ensure that we do not hold on to worker
                 references that would prevent GC, ALL accesses to workers are
                 via indices into the workers array (which is one source of some
                 of the messy code constructions here). In essence, the workers
                 array serves as a weak reference mechanism. Thus for example
                 the wait queue field of ctl stores worker indices, not worker
                 references.  Access to the workers in associated methods (for
                 example signalWork) must both index-check and null-check the
                 IDs. All such accesses ignore bad IDs by returning out early
                 from what they are doing, since this can only be associated
                 with termination, in which case it is OK to give up.
                
                 All uses of the workers array, as well as queue arrays, check
                 that the array is non-null (even if previously non-null). This
                 allows nulling during termination, which is currently not
                 necessary, but remains an option for resource-revocation-based
                 shutdown schemes.
                
                 Wait Queuing. Unlike HPC work-stealing frameworks, we cannot
                 let workers spin indefinitely scanning for tasks when none can
                 be found immediately, and we cannot startresume workers unless
                 there appear to be tasks available.  On the other hand, we must
                 quickly prod them into action when new tasks are submitted or
                 generated.  We parkunpark workers after placing in an event
                 wait queue when they cannot find work. This &quot;queue&quot; is actually
                 a simple Treiber stack, headed by the &quot;id&quot; field of ctl, plus a
                 15bit counter value to both wake up waiters (by advancing their
                 count) and avoid ABA effects. Successors are held in worker
                 field &quot;nextWait&quot;.  Queuing deals with several intrinsic races,
                 mainly that a task-producing thread can miss seeing (and
                 signalling) another thread that gave up looking for work but
                 has not yet entered the wait queue. We solve this by requiring
                 a full sweep of all workers both before (in scan()) and after
                 (in tryAwaitWork()) a newly waiting worker is added to the wait
                 queue. During a rescan, the worker might release some other
                 queued worker rather than itself, which has the same net
                 effect. Because enqueued workers may actually be rescanning
                 rather than waiting, we set and clear the &quot;parked&quot; field of
                 ForkJoinWorkerThread to reduce unnecessary calls to unpark.
                 (Use of the parked field requires a secondary recheck to avoid
                 missed signals.)
                
                 Signalling.  We create or wake up workers only when there
                 appears to be at least one task they might be able to find and
                 execute.  When a submission is added or another worker adds a
                 task to a queue that previously had two or fewer tasks, they
                 signal waiting workers (or trigger creation of new ones if
                 fewer than the given parallelism level -- see signalWork).
                 These primary signals are buttressed by signals during rescans
                 as well as those performed when a worker steals a task and
                 notices that there are more tasks too; together these cover the
                 signals needed in cases when more than two tasks are pushed
                 but untaken.
                
                 Trimming workers. To release resources after periods of lack of
                 use, a worker starting to wait when the pool is quiescent will
                 time out and terminate if the pool has remained quiescent for
                 SHRINK_RATE nanosecs. This will slowly propagate, eventually
                 terminating all workers after long periods of non-use.
                
                 Submissions. External submissions are maintained in an
                 array-based queue that is structured identically to
                 ForkJoinWorkerThread queues except for the use of
                 submissionLock in method addSubmission. Unlike the case for
                 worker queues, multiple external threads can add new
                 submissions, so adding requires a lock.
                
                 Compensation. Beyond work-stealing support and lifecycle
                 control, the main responsibility of this framework is to take
                 actions when one worker is waiting to join a task stolen (or
                 always held by) another.  Because we are multiplexing many
                 tasks on to a pool of workers, we can&apos;t just let them block (as
                 in Thread.join).  We also cannot just reassign the joiner&apos;s
                 run-time stack with another and replace it later, which would
                 be a form of &quot;continuation&quot;, that even if possible is not
                 necessarily a good idea since we sometimes need both an
                 unblocked task and its continuation to progress. Instead we
                 combine two tactics:
                
                   Helping: Arranging for the joiner to execute some task that it
                      would be running if the steal had not occurred.  Method
                      ForkJoinWorkerThread.joinTask tracks joining-&gt;stealing
                      links to try to find such a task.
                
                   Compensating: Unless there are already enough live threads,
                      method tryPreBlock() may create or re-activate a spare
                      thread to compensate for blocked joiners until they
                      unblock.
                
                 The ManagedBlocker extension API can&apos;t use helping so relies
                 only on compensation in method awaitBlocker.
                
                 It is impossible to keep exactly the target parallelism number
                 of threads running at any given time.  Determining the
                 existence of conservatively safe helping targets, the
                 availability of already-created spares, and the apparent need
                 to create new spares are all racy and require heuristic
                 guidance, so we rely on multiple retries of each.  Currently,
                 in keeping with on-demand signalling policy, we compensate only
                 if blocking would leave less than one active (non-waiting,
                 non-blocked) worker. Additionally, to avoid some false alarms
                 due to GC, lagging counters, system activity, etc, compensated
                 blocking for joins is only attempted after rechecks stabilize
                 (retries are interspersed with Thread.yield, for good
                 citizenship).  The variable blockedCount, incremented before
                 blocking and decremented after, is sometimes needed to
                 distinguish cases of waiting for work vs blocking on joins or
                 other managed sync. Both cases are equivalent for most pool
                 control, so we can update non-atomically. (Additionally,
                 contention on blockedCount alleviates some contention on ctl).
                
                 Shutdown and Termination. A call to shutdownNow atomically sets
                 the ctl stop bit and then (non-atomically) sets each workers
                 &quot;terminate&quot; status, cancels all unprocessed tasks, and wakes up
                 all waiting workers.  Detecting whether termination should
                 commence after a non-abrupt shutdown() call requires more work
                 and bookkeeping. We need consensus about quiesence (i.e., that
                 there is no more work) which is reflected in active counts so
                 long as there are no current blockers, as well as possible
                 re-evaluations during independent changes in blocking or
                 quiescing workers.
                
                 Style notes: There is a lot of representation-level coupling
                 among classes ForkJoinPool, ForkJoinWorkerThread, and
                 ForkJoinTask.  Most fields of ForkJoinWorkerThread maintain
                 data structures managed by ForkJoinPool, so are directly
                 accessed.  Conversely we allow access to &quot;workers&quot; array by
                 workers, and direct access to ForkJoinTask.status by both
                 ForkJoinPool and ForkJoinWorkerThread.  There is little point
                 trying to reduce this, since any associated future changes in
                 representations will need to be accompanied by algorithmic
                 changes anyway. All together, these low-level implementation
                 choices produce as much as a factor of 4 performance
                 improvement compared to naive implementations, and enable the
                 processing of billions of tasks per second, at the expense of
                 some ugliness.
                
                 Methods signalWork() and scan() are the main bottlenecks so are
                 especially heavily micro-optimizedmangled.  There are lots of
                 inline assignments (of form &quot;while ((local = field) != 0)&quot;)
                 which are usually the simplest way to ensure the required read
                 orderings (which are sometimes critical). This leads to a
                 &quot;C&quot;-like style of listing declarations of these locals at the
                 heads of methods or blocks.  There are several occurrences of
                 the unusual &quot;do {} while (!cas...)&quot;  which is the simplest way
                 to force an update of a CAS&apos;ed variable. There are also other
                 coding oddities that help some methods perform reasonably even
                 when interpreted (not compiled).
                
                 The order of declarations in this file is: (1) declarations of
                 statics (2) fields (along with constants used when unpacking
                 some of them), listed in an order that tends to reduce
                 contention among them a bit under most JVMs.  (3) internal
                 control methods (4) callbacks and other support for
                 ForkJoinTask and ForkJoinWorkerThread classes, (5) exported
                 methods (plus a few little helpers). (6) static block
                 initializing all statics in a minimally dependent order.                
            </comment>
            <comment line="457">
                16M                
            </comment>
            <comment line="520">
                bit positions/shifts for fields                
            </comment>
            <comment line="526">
                bounds                
            </comment>
            <comment line="527">
                max poolIndex                
            </comment>
            <comment line="528">
                mask short bits                
            </comment>
            <comment line="532">
                masks                
            </comment>
            <comment line="537">
                units for incrementing and decrementing                
            </comment>
            <comment line="541">
                masks and units for dealing with u = (int)(ctl &gt;&gt;&gt; 32)                
            </comment>
            <comment line="549">
                masks and units for dealing with e = (int)ctl                
            </comment>
            <comment line="550">
                no STOP_BIT                
            </comment>
            <comment line="630">
                4 seconds                
            </comment>
            <comment line="653">
                Signalling                
            </comment>
            <comment line="724">
                Scanning for tasks                
            </comment>
            <comment line="912">
                Submissions                
            </comment>
            <comment line="938">
                (pollSubmission is defined below with exported methods)                
            </comment>
            <comment line="966">
                Blocking support                
            </comment>
            <comment line="1106">
                Creating, registering and deregistring workers                
            </comment>
            <comment line="1246">
                Shutdown and termination                
            </comment>
            <comment line="1354">
                misc ForkJoinWorkerThread support                
            </comment>
            <comment line="1399">
                Exported methods                
            </comment>
            <comment line="1401">
                Constructors                
            </comment>
            <comment line="1493">
                Execution methods                
            </comment>
            <comment line="1556">
                AbstractExecutorService methods                
            </comment>
            <comment line="2122">
                AbstractExecutorService overrides.  These rely on undocumented
                 fact that ForkJoinTask.adapt returns ForkJoinTasks that also
                 implement RunnableFuture.                
            </comment>
            <comment line="2134">
                Unsafe mechanics                
            </comment>
            <javadoc line="57">
                An {@link ExecutorService} for running {@link ForkJoinTask}s.
                  A {@code ForkJoinPool} provides the entry point for submissions
                  from non-{@code ForkJoinTask} clients, as well as management and
                  monitoring operations.
                  &lt;p&gt;A {@code ForkJoinPool} differs from other kinds of {@link ExecutorService} mainly by virtue of employing
                  &lt;em&gt;work-stealing&lt;/em&gt;: all threads in the pool attempt to find and
                  execute subtasks created by other active tasks (eventually blocking
                  waiting for work if none exist). This enables efficient processing
                  when most tasks spawn other subtasks (as do most {@codeForkJoinTask}s). When setting &lt;em&gt;asyncMode&lt;/em&gt; to true in
                  constructors, {@code ForkJoinPool}s may also be appropriate for use
                  with event-style tasks that are never joined.
                  &lt;p&gt;A {@code ForkJoinPool} is constructed with a given target
                  parallelism level; by default, equal to the number of available
                  processors. The pool attempts to maintain enough active (or
                  available) threads by dynamically adding, suspending, or resuming
                  internal worker threads, even if some tasks are stalled waiting to
                  join others. However, no such adjustments are guaranteed in the
                  face of blocked IO or other unmanaged synchronization. The nested{@link ManagedBlocker} interface enables extension of the kinds of
                  synchronization accommodated.
                  &lt;p&gt;In addition to execution and lifecycle control methods, this
                  class provides status check methods (for example{@link #getStealCount}) that are intended to aid in developing,
                  tuning, and monitoring fork/join applications. Also, method{@link #toString} returns indications of pool state in a
                  convenient form for informal monitoring.
                  &lt;p&gt; As is the case with other ExecutorServices, there are three
                  main task execution methods summarized in the following
                  table. These are designed to be used by clients not already engaged
                  in fork/join computations in the current pool.  The main forms of
                  these methods accept instances of {@code ForkJoinTask}, but
                  overloaded forms also allow mixed execution of plain {@codeRunnable}- or {@code Callable}- based activities as well.  However,
                  tasks that are already executing in a pool should normally
                  &lt;em&gt;NOT&lt;/em&gt; use these pool execution methods, but instead use the
                  within-computation forms listed in the table.
                  &lt;table BORDER CELLPADDING=3 CELLSPACING=1&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;/td&gt;
                  &lt;td ALIGN=CENTER&gt; &lt;b&gt;Call from non-fork/join clients&lt;/b&gt;&lt;/td&gt;
                  &lt;td ALIGN=CENTER&gt; &lt;b&gt;Call from within fork/join computations&lt;/b&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; &lt;b&gt;Arrange async execution&lt;/td&gt;
                  &lt;td&gt; {@link #execute(ForkJoinTask)}&lt;/td&gt;
                  &lt;td&gt; {@link ForkJoinTask#fork}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; &lt;b&gt;Await and obtain result&lt;/td&gt;
                  &lt;td&gt; {@link #invoke(ForkJoinTask)}&lt;/td&gt;
                  &lt;td&gt; {@link ForkJoinTask#invoke}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; &lt;b&gt;Arrange exec and obtain Future&lt;/td&gt;
                  &lt;td&gt; {@link #submit(ForkJoinTask)}&lt;/td&gt;
                  &lt;td&gt; {@link ForkJoinTask#fork} (ForkJoinTasks &lt;em&gt;are&lt;/em&gt; Futures)&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;p&gt;&lt;b&gt;Sample Usage.&lt;/b&gt; Normally a single {@code ForkJoinPool} is
                  used for all parallel task execution in a program or subsystem.
                  Otherwise, use would not usually outweigh the construction and
                  bookkeeping overhead of creating a large set of threads. For
                  example, a common pool could be used for the {@code SortTasks}illustrated in {@link RecursiveAction}. Because {@codeForkJoinPool} uses threads in {@linkplain java.lang.Thread#isDaemondaemon} mode, there is typically no need to explicitly {@link #shutdown} such a pool upon program exit.
                  &lt;pre&gt;
                  static final ForkJoinPool mainPool = new ForkJoinPool();
                  ...
                  public void sort(long[] array) {
                  mainPool.invoke(new SortTask(array, 0, array.length));
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;&lt;b&gt;Implementation notes&lt;/b&gt;: This implementation restricts the
                  maximum number of running threads to 32767. Attempts to create
                  pools with greater than the maximum number result in{@code IllegalArgumentException}.
                  &lt;p&gt;This implementation rejects submitted tasks (that is, by throwing{@link RejectedExecutionException}) only when the pool is shut down
                  or internal resources have been exhausted.                
                <since>
                    1.7                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <interface name="ForkJoinWorkerThreadFactory">
                <javadoc line="367">
                    Factory for creating new {@link ForkJoinWorkerThread}s.
                      A {@code ForkJoinWorkerThreadFactory} must be defined and used
                      for {@code ForkJoinWorkerThread} subclasses that extend base
                      functionality or initialize threads with different contexts.                    
                </javadoc>
                <method name="newThread" type="ForkJoinWorkerThread" line="374"/>
                <javadoc line="374">
                    Returns a new worker thread operating in the given pool.                    
                    <param>
                        pool the pool this thread works in                        
                    </param>
                    <throws>
                        NullPointerException if the pool is null                        
                    </throws>
                </javadoc>
            </interface>
            <class name="DefaultForkJoinWorkerThreadFactory" line="383">
                <implements interface="ForkJoinWorkerThreadFactory"/>
                <javadoc line="383">
                    Default ForkJoinWorkerThreadFactory implementation; creates a
                      new ForkJoinWorkerThread.                    
                </javadoc>
                <method name="newThread" type="ForkJoinWorkerThread" line="389">
                    <params>
                        <param name="pool" type="ForkJoinPool"/>
                    </params>
                </method>
            </class>
            <declaration name="defaultForkJoinWorkerThreadFactory" type="ForkJoinWorkerThreadFactory" line="394"/>
            <javadoc line="394">
                Creates a new ForkJoinWorkerThread. This factory is used unless
                  overridden in ForkJoinPool constructors.                
            </javadoc>
            <declaration name="modifyThreadPermission" type="RuntimePermission" line="401"/>
            <javadoc line="401">
                Permission required for callers of methods that may start or
                  kill threads.                
            </javadoc>
            <javadoc line="407">
                If there is a security manager, makes sure caller has
                  permission to modify threads.                
            </javadoc>
            <method name="checkPermission" type="void" line="411">
                <declaration name="security" type="SecurityManager" line="412"/>
            </method>
            <declaration name="poolNumberGenerator" type="AtomicInteger" line="417"/>
            <javadoc line="417">
                Generator for assigning sequence numbers as pool names.                
            </javadoc>
            <declaration name="workerSeedGenerator" type="Random" line="422"/>
            <javadoc line="422">
                Generator for initial random seeds for worker victim
                  selection. This is used only to create initial seeds. Random
                  steals use a cheaper xorshift generator per steal attempt. We
                  don&apos;t expect much contention on seedGenerator, so just use a
                  plain Random.                
            </javadoc>
            <declaration name="workers" type="ForkJoinWorkerThread[]" line="431"/>
            <javadoc line="431">
                Array holding all worker threads in the pool.  Initialized upon
                  construction. Array size must be a power of two.  Updates and
                  replacements are protected by scanGuard, but the array is
                  always kept in a consistent enough state to be randomly
                  accessed without locking by workers performing work-stealing,
                  as well as other traversal-based methods in this class, so long
                  as reads memory-acquire by first reading ctl. All readers must
                  tolerate that some array slots may be null.                
            </javadoc>
            <declaration name="INITIAL_QUEUE_CAPACITY" type="int" line="443"/>
            <javadoc line="443">
                Initial size for submission queue array. Must be a power of
                  two.  In many applications, these always stay small so we use a
                  small initial cap.                
            </javadoc>
            <declaration name="MAXIMUM_QUEUE_CAPACITY" type="int" line="450"/>
            <javadoc line="450">
                Maximum size for submission queue array. Must be a power of two
                  less than or equal to 1 &lt;&lt; (31 - width of array entry) to
                  ensure lack of index wraparound, but is capped at a lower
                  value to help users trap runaway computations.                
            </javadoc>
            <declaration name="submissionQueue" type="ForkJoinTask&lt;?&gt;[]" line="458"/>
            <javadoc line="458">
                Array serving as submission queue. Initialized upon construction.                
            </javadoc>
            <declaration name="submissionLock" type="ReentrantLock" line="463"/>
            <javadoc line="463">
                Lock protecting submissions array for addSubmission                
            </javadoc>
            <declaration name="termination" type="Condition" line="468"/>
            <javadoc line="468">
                Condition for awaitTermination, using submissionLock for
                  convenience.                
            </javadoc>
            <declaration name="factory" type="ForkJoinWorkerThreadFactory" line="474"/>
            <javadoc line="474">
                Creation factory for worker threads.                
            </javadoc>
            <declaration name="ueh" type="Thread.UncaughtExceptionHandler" line="479"/>
            <javadoc line="479">
                The uncaught exception handler used when any worker abruptly
                  terminates.                
            </javadoc>
            <declaration name="workerNamePrefix" type="String" line="485"/>
            <javadoc line="485">
                Prefix for assigning names to worker threads                
            </javadoc>
            <declaration name="stealCount" type="long" line="490"/>
            <javadoc line="490">
                Sum of per-thread steal counts, updated only when threads are
                  idle or terminating.                
            </javadoc>
            <declaration name="ctl" type="long" line="496"/>
            <javadoc line="496">
                Main pool control -- a long packed with:
                  AC: Number of active running workers minus target parallelism (16 bits)
                  TC: Number of total workers minus target parallelism (16bits)
                  ST: true if pool is terminating (1 bit)
                  EC: the wait count of top waiting thread (15 bits)
                  ID: ~poolIndex of top of Treiber stack of waiting threads (16 bits)
                  When convenient, we can extract the upper 32 bits of counts and
                  the lower 32 bits of queue state, u = (int)(ctl &gt;&gt;&gt; 32) and e =
                  (int)ctl.  The ec field is never accessed alone, but always
                  together with id and st. The offsets of counts by the target
                  parallelism and the positionings of fields makes it possible to
                  perform the most common checks via sign tests of fields: When
                  ac is negative, there are not enough active workers, when tc is
                  negative, there are not enough total workers, when id is
                  negative, there is at least one waiting worker, and when e is
                  negative, the pool is terminating.  To deal with these possibly
                  negative fields, we use casts in and out of &quot;short&quot; and/or
                  signed shifts to maintain signedness.                
            </javadoc>
            <declaration name="AC_SHIFT" type="int" line="520"/>
            <declaration name="TC_SHIFT" type="int" line="521"/>
            <declaration name="ST_SHIFT" type="int" line="522"/>
            <declaration name="EC_SHIFT" type="int" line="523"/>
            <declaration name="MAX_ID" type="int" line="526"/>
            <declaration name="SMASK" type="int" line="527"/>
            <declaration name="SHORT_SIGN" type="int" line="528"/>
            <declaration name="INT_SIGN" type="int" line="529"/>
            <declaration name="STOP_BIT" type="long" line="532"/>
            <declaration name="AC_MASK" type="long" line="533"/>
            <declaration name="TC_MASK" type="long" line="534"/>
            <declaration name="TC_UNIT" type="long" line="537"/>
            <declaration name="AC_UNIT" type="long" line="538"/>
            <declaration name="UAC_SHIFT" type="int" line="541"/>
            <declaration name="UTC_SHIFT" type="int" line="542"/>
            <declaration name="UAC_MASK" type="int" line="543"/>
            <declaration name="UTC_MASK" type="int" line="544"/>
            <declaration name="UAC_UNIT" type="int" line="545"/>
            <declaration name="UTC_UNIT" type="int" line="546"/>
            <declaration name="E_MASK" type="int" line="549"/>
            <declaration name="EC_UNIT" type="int" line="550"/>
            <declaration name="parallelism" type="int" line="552"/>
            <javadoc line="552">
                The target parallelism level.                
            </javadoc>
            <declaration name="queueBase" type="int" line="557"/>
            <javadoc line="557">
                Index (mod submission queue length) of next element to take
                  from submission queue. Usage is identical to that for
                  per-worker queues -- see ForkJoinWorkerThread internal
                  documentation.                
            </javadoc>
            <declaration name="queueTop" type="int" line="565"/>
            <javadoc line="565">
                Index (mod submission queue length) of next element to add
                  in submission queue. Usage is identical to that for
                  per-worker queues -- see ForkJoinWorkerThread internal
                  documentation.                
            </javadoc>
            <declaration name="shutdown" type="boolean" line="573"/>
            <javadoc line="573">
                True when shutdown() has been called.                
            </javadoc>
            <declaration name="locallyFifo" type="boolean" line="578"/>
            <javadoc line="578">
                True if use local fifo, not default lifo, for local polling
                  Read by, and replicated by ForkJoinWorkerThreads                
            </javadoc>
            <declaration name="quiescerCount" type="int" line="584"/>
            <javadoc line="584">
                The number of threads in ForkJoinWorkerThreads.helpQuiescePool.
                  When non-zero, suppresses automatic shutdown when active
                  counts become zero.                
            </javadoc>
            <declaration name="blockedCount" type="int" line="591"/>
            <javadoc line="591">
                The number of threads blocked in join.                
            </javadoc>
            <declaration name="nextWorkerNumber" type="int" line="596"/>
            <javadoc line="596">
                Counter for worker Thread names (unrelated to their poolIndex)                
            </javadoc>
            <declaration name="nextWorkerIndex" type="int" line="601"/>
            <javadoc line="601">
                The index for the next created worker. Accessed under scanGuard.                
            </javadoc>
            <declaration name="scanGuard" type="int" line="606"/>
            <javadoc line="606">
                SeqLock and index masking for updates to workers array.  Locked
                  when SG_UNIT is set. Unlocking clears bit by adding
                  SG_UNIT. Staleness of read-only operations can be checked by
                  comparing scanGuard to value before the reads. The low 16 bits
                  (i.e, anding with SMASK) hold (the smallest power of two
                  covering all worker indices, minus one, and is used to avoid
                  dealing with large numbers of null slots when the workers array
                  is overallocated.                
            </javadoc>
            <declaration name="SG_UNIT" type="int" line="618"/>
            <declaration name="SHRINK_RATE" type="long" line="620"/>
            <javadoc line="620">
                The wakeup interval (in nanoseconds) for a worker waiting for a
                  task when the pool is quiescent to instead try to shrink the
                  number of workers.  The exact value does not matter too
                  much. It must be short enough to release resources during
                  sustained periods of idleness, but not so short that threads
                  are continually re-created.                
            </javadoc>
            <javadoc line="631">
                Top-level loop for worker threads: On each step: if the
                  previous step swept through all queues and found no tasks, or
                  there are excess threads, then possibly blocks. Otherwise,
                  scans for and, if found, executes a task. Returns when pool
                  and/or worker terminate.                
                <param>
                    w the worker                    
                </param>
            </javadoc>
            <method name="work" type="void" line="640">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                </params>
                <comment line="642">
                    true on empty scans                    
                </comment>
                <comment line="645">
                    active count                    
                </comment>
                <declaration name="swept" type="boolean" line="641"/>
                <declaration name="c" type="long" line="642"/>
                <scope line="643">
                    <declaration name="a" type="int" line="644"/>
                </scope>
            </method>
            <javadoc line="654">
                Wakes up or creates a worker.                
            </javadoc>
            <method name="signalWork" type="void" line="657">
                <comment line="659">
                    The while condition is true if: (there is are too few total
                     workers OR there is at least one waiter) AND (there are too
                     few active workers OR the pool is terminating).  The value
                     of e distinguishes the remaining cases: zero (no waiters)
                     for create, negative if terminating (in which case do
                     nothing), else release a waiter. The secondary checks for
                     release (non-null array etc) can fail if the pool begins
                     terminating after the test, and don&apos;t impose any added cost
                     because JVMs must perform null and bounds checks anyway.                    
                </comment>
                <comment line="673">
                    release a waiting worker                    
                </comment>
                <declaration name="c" type="long" line="669"/>
                <declaration name="e" type="int" line="669"/>
                <scope line="671">
                    <scope line="672">
                        <declaration name="i" type="int" line="673"/>
                        <declaration name="w" type="ForkJoinWorkerThread" line="673"/>
                        <declaration name="ws" type="ForkJoinWorkerThread[]" line="673"/>
                        <declaration name="nc" type="long" line="678"/>
                        <scope line="681"/>
                    </scope>
                    <scope line="691"/>
                </scope>
            </method>
            <javadoc line="698">
                Variant of signalWork to help release waiters on rescans.
                  Tries once to release a waiter if active count &lt; 0.                
                <return>
                    false if failed due to contention, else true                    
                </return>
            </javadoc>
            <method name="tryReleaseWaiter" type="boolean" line="704">
                <declaration name="c" type="long" line="705"/>
                <declaration name="e" type="int" line="705"/>
                <declaration name="w" type="ForkJoinWorkerThread" line="705"/>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="705"/>
                <scope line="710">
                    <declaration name="nc" type="long" line="711"/>
                </scope>
            </method>
            <javadoc line="725">
                Scans for and, if found, executes one task. Scans start at a
                  random index of workers array, and randomly select the first
                  (2#workers)-1 probes, and then, if all empty, resort to 2
                  circular sweeps, which is necessary to check quiescence. and
                  taking a submission only if no stealable tasks were found.  The
                  steal code inside the loop is a specialized form of
                  ForkJoinWorkerThread.deqTask, followed bookkeeping to support
                  helpJoinTask and signal propagation. The code for submission
                  queues is almost identical. On each steal, the worker completes
                  not only the task, but also all local tasks that this task may
                  have generated. On detecting staleness or contention when
                  trying to take a task, this method returns without finishing
                  sweep, which allows global state rechecks before retry.                
                <param>
                    w the worker                    
                </param>
                <param>
                    a the number of active workers                    
                </param>
                <return>
                    true if swept all queues without finding a task                    
                </return>
            </javadoc>
            <method name="scan" type="boolean" line="744">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                    <param name="a" type="int"/>
                </params>
                <comment line="746">
                    mask 0 avoids useless scans if only one active                    
                </comment>
                <comment line="749">
                    staleness check                    
                </comment>
                <comment line="762">
                    propagate if nonempty                    
                </comment>
                <comment line="766">
                    store next seed                    
                </comment>
                <comment line="768">
                    xorshift                    
                </comment>
                <comment line="774">
                    staleness check                    
                </comment>
                <comment line="776">
                    try to take submission                    
                </comment>
                <comment line="789">
                    all queues empty                    
                </comment>
                <declaration name="g" type="int" line="745"/>
                <declaration name="m" type="int" line="746"/>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="747"/>
                <scope line="750">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="751"/>
                    <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="751"/>
                    <declaration name="b" type="int" line="751"/>
                    <declaration name="v" type="ForkJoinWorkerThread" line="752"/>
                    <scope line="754">
                        <declaration name="u" type="long" line="755"/>
                        <scope line="757">
                            <declaration name="d" type="int" line="758"/>
                        </scope>
                    </scope>
                    <scope line="767"/>
                </scope>
                <scope line="775">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="776"/>
                    <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="776"/>
                    <declaration name="b" type="int" line="776"/>
                    <scope line="779">
                        <declaration name="u" type="long" line="780"/>
                        <scope line="782"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="792">
                Tries to enqueue worker w in wait queue and await change in
                  worker&apos;s eventCount.  If the pool is quiescent and there is
                  more than one worker, possibly terminates worker upon exit.
                  Otherwise, before blocking, rescans queues to avoid missed
                  signals.  Upon finding work, releases at least one worker
                  (which may be the current worker). Rescans restart upon
                  detected staleness or failure to release due to
                  contention. Note the unusual conventions about Thread.interrupt
                  here and elsewhere: Because interrupts are used solely to alert
                  threads to check termination, which is checked here anyway, we
                  clear status (using Thread.interrupted) before any call to
                  park, so that park does not immediately return due to status
                  being set via some other unrelated call to interrupt in user
                  code.                
                <param>
                    w the calling worker                    
                </param>
                <param>
                    c the ctl value on entry                    
                </param>
                <return>
                    true if waited or another thread was released upon enq                    
                </return>
            </javadoc>
            <method name="tryAwaitWork" type="boolean" line="812">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                    <param name="c" type="long"/>
                </params>
                <comment line="815">
                    w&apos;s successor record                    
                </comment>
                <comment line="818">
                    return true if lost to a deq, to force scan                    
                </comment>
                <comment line="821">
                    accumulate stealCount                    
                </comment>
                <comment line="826">
                    update next time                    
                </comment>
                <comment line="831">
                    quiescent                    
                </comment>
                <comment line="845">
                    contended                    
                </comment>
                <comment line="851">
                    stale                    
                </comment>
                <comment line="855">
                    reduce contention                    
                </comment>
                <comment line="857">
                    clear before park                    
                </comment>
                <comment line="860">
                    must recheck                    
                </comment>
                <declaration name="v" type="int" line="813"/>
                <declaration name="nc" type="long" line="815"/>
                <scope line="816">
                    <declaration name="d" type="long" line="817"/>
                </scope>
                <scope line="820">
                    <declaration name="s" type="long" line="821"/>
                </scope>
                <scope line="831">
                    <scope line="834">
                        <declaration name="g" type="int" line="835"/>
                        <declaration name="ws" type="ForkJoinWorkerThread[]" line="836"/>
                        <scope line="837">
                            <scope line="839">
                                <declaration name="u" type="ForkJoinWorkerThread" line="840"/>
                                <scope line="841"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="858">
                        <scope line="860"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="870">
                If inactivating worker w has caused pool to become
                  quiescent, check for pool termination, and wait for event
                  for up to SHRINK_RATE nanosecs (rescans are unnecessary in
                  this case because quiescence reflects consensus about lack
                  of work). On timeout, if ctl has not changed, terminate the
                  worker. Upon its termination (see deregisterWorker), it may
                  wake up another worker to possibly repeat this process.                
                <param>
                    w the calling worker                    
                </param>
                <param>
                    currentCtl the ctl value after enqueuing w                    
                </param>
                <param>
                    prevCtl the ctl value if w terminated                    
                </param>
                <param>
                    v the eventCount w awaits change                    
                </param>
            </javadoc>
            <method name="idleAwaitWork" type="void" line="885">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                    <param name="currentCtl" type="long"/>
                    <param name="prevCtl" type="long"/>
                    <param name="v" type="int"/>
                </params>
                <comment line="890">
                    help clean weak refs                    
                </comment>
                <comment line="894">
                    must recheck                    
                </comment>
                <comment line="900">
                    timing slop                    
                </comment>
                <comment line="901">
                    spurious wakeup                    
                </comment>
                <comment line="904">
                    restore previous                    
                </comment>
                <scope line="886">
                    <scope line="890">
                        <declaration name="startTime" type="long" line="891"/>
                        <scope line="902"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="913">
                Enqueues the given task in the submissionQueue.  Same idea as
                  ForkJoinWorkerThread.pushTask except for use of submissionLock.                
                <param>
                    t the task                    
                </param>
            </javadoc>
            <method name="addSubmission" type="void" line="919">
                <params>
                    <param name="t" type="ForkJoinTask<?>"/>
                </params>
                <comment line="925">
                    ignore if queue removed                    
                </comment>
                <declaration name="lock" type="ReentrantLock" line="920"/>
                <scope line="922">
                    <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="923"/>
                    <declaration name="s" type="int" line="923"/>
                    <scope line="924">
                        <declaration name="u" type="long" line="925"/>
                    </scope>
                </scope>
                <scope line="931"/>
            </method>
            <javadoc line="939">
                Creates or doubles submissionQueue array.
                  Basically identical to ForkJoinWorkerThread version.                
            </javadoc>
            <method name="growSubmissionQueue" type="void" line="943">
                <declaration name="oldQ" type="ForkJoinTask&lt;?&gt;[]" line="944"/>
                <declaration name="size" type="int" line="945"/>
                <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="950"/>
                <declaration name="mask" type="int" line="951"/>
                <declaration name="top" type="int" line="952"/>
                <declaration name="oldMask" type="int" line="953"/>
                <scope line="954">
                    <scope line="955">
                        <declaration name="u" type="long" line="956"/>
                        <declaration name="x" type="Object" line="957"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="967">
                Tries to increment blockedCount, decrement active count
                  (sometimes implicitly) and possibly release or create a
                  compensating worker in preparation for blocking. Fails
                  on contention or termination.                
                <return>
                    true if the caller can block, else should recheck and retry                    
                </return>
            </javadoc>
            <method name="tryPreBlock" type="boolean" line="975">
                <comment line="986">
                    skip -- terminating                    
                </comment>
                <comment line="999">
                    release an idle worker                    
                </comment>
                <comment line="1005">
                    no compensation needed                    
                </comment>
                <comment line="1011">
                    create a replacement                    
                </comment>
                <comment line="1014">
                    try to back out on any failure and let caller retry                    
                </comment>
                <declaration name="b" type="int" line="976"/>
                <scope line="977">
                    <declaration name="pc" type="int" line="978"/>
                    <scope line="979">
                        <declaration name="ws" type="ForkJoinWorkerThread[]" line="980"/>
                        <declaration name="w" type="ForkJoinWorkerThread" line="980"/>
                        <declaration name="e" type="int" line="981"/>
                        <declaration name="c" type="long" line="982"/>
                        <declaration name="u" type="int" line="983"/>
                        <scope line="984"/>
                        <scope line="990">
                            <declaration name="nc" type="long" line="991"/>
                            <scope line="994"/>
                        </scope>
                        <scope line="1001">
                            <declaration name="nc" type="long" line="1002"/>
                        </scope>
                        <scope line="1006">
                            <declaration name="nc" type="long" line="1007"/>
                            <scope line="1008"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1020">
                Decrements blockedCount and increments active count                
            </javadoc>
            <method name="postBlock" type="void" line="1023">
                <comment line="1026">
                    no mask                    
                </comment>
                <declaration name="c" type="long" line="1024"/>
                <scope line="1025"/>
                <declaration name="b" type="int" line="1027"/>
                <scope line="1028"/>
            </method>
            <javadoc line="1032">
                Possibly blocks waiting for the given task to complete, or
                  cancels the task if terminating.  Fails to wait if contended.                
                <param>
                    joinMe the task                    
                </param>
            </javadoc>
            <method name="tryAwaitJoin" type="void" line="1038">
                <params>
                    <param name="joinMe" type="ForkJoinTask<?>"/>
                </params>
                <comment line="1041">
                    clear interrupts before checking termination                    
                </comment>
                <declaration name="s" type="int" line="1039"/>
                <scope line="1041">
                    <scope line="1042"/>
                </scope>
            </method>
            <javadoc line="1051">
                Possibly blocks the given worker waiting for joinMe to
                  complete or timeout                
                <param>
                    joinMe the task                    
                </param>
                <param>
                    millis the wait time for underlying Object.wait                    
                </param>
            </javadoc>
            <method name="timedAwaitJoin" type="void" line="1058">
                <params>
                    <param name="joinMe" type="ForkJoinTask<?>"/>
                    <param name="nanos" type="long"/>
                </params>
                <scope line="1059">
                    <scope line="1061"/>
                    <scope line="1065">
                        <declaration name="last" type="long" line="1066"/>
                        <scope line="1067">
                            <declaration name="millis" type="long" line="1068"/>
                            <scope line="1074"/>
                            <declaration name="now" type="long" line="1078"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1088">
                If necessary, compensates for blocker, and blocks                
            </javadoc>
            <method name="awaitBlocker" type="void" line="1092">
                <params>
                    <param name="blocker" type="ManagedBlocker"/>
                </params>
                <scope line="1093">
                    <scope line="1094">
                        <scope line="1095">
                            <scope line="1096"/>
                        </scope>
                        <scope line="1097"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1107">
                Tries to create and start a worker; minimally rolls back counts
                  on failure.                
            </javadoc>
            <method name="addWorker" type="void" line="1111">
                <comment line="1120">
                    null or exceptional factory return                    
                </comment>
                <comment line="1121">
                    adjust counts                    
                </comment>
                <comment line="1127">
                    Propagate exception if originating from an external caller                    
                </comment>
                <declaration name="ex" type="Throwable" line="1112"/>
                <declaration name="t" type="ForkJoinWorkerThread" line="1113"/>
                <scope line="1114"/>
                <scope line="1116"/>
                <scope line="1119">
                    <declaration name="c" type="long" line="1120"/>
                    <scope line="1121"/>
                </scope>
            </method>
            <javadoc line="1135">
                Callback from ForkJoinWorkerThread constructor to assign a
                  public name                
            </javadoc>
            <method name="nextWorkerName" type="String" line="1139">
                <scope line="1140"/>
            </method>
            <javadoc line="1147">
                Callback from ForkJoinWorkerThread constructor to
                  determine its poolIndex and record in workers array.                
                <param>
                    w the worker                    
                </param>
                <return>
                    the worker&apos;s pool index                    
                </return>
            </javadoc>
            <method name="registerWorker" type="int" line="1154">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                </params>
                <comment line="1156">
                    In the typical case, a new worker acquires the lock, uses
                     next available index and returns quickly.  Since we should
                     not block callers (ultimately from signalWork or
                     tryPreBlock) waiting for the lock needed to do this, we
                     instead help release other workers while waiting for the
                     lock.                    
                </comment>
                <comment line="1171">
                    ignore on shutdown                    
                </comment>
                <comment line="1189">
                    help release others                    
                </comment>
                <scope line="1163">
                    <declaration name="ws" type="ForkJoinWorkerThread[]" line="1164"/>
                    <scope line="1167">
                        <declaration name="k" type="int" line="1168"/>
                        <scope line="1169">
                            <scope line="1170">
                                <declaration name="n" type="int" line="1171"/>
                                <scope line="1172"/>
                                <declaration name="m" type="int" line="1180"/>
                            </scope>
                        </scope>
                        <scope line="1183"/>
                    </scope>
                    <scope line="1188">
                        <scope line="1189">
                            <scope line="1190"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1199">
                Final callback from terminating worker.  Removes record of
                  worker from array, and adjusts counts. If pool is shutting
                  down, tries to complete termination.                
                <param>
                    w the worker                    
                </param>
            </javadoc>
            <method name="deregisterWorker" type="void" line="1206">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                    <param name="ex" type="Throwable"/>
                </params>
                <comment line="1211">
                    Remove from array, adjust worker counts and collect steal count.
                     We can intermix failed removes or adjusts with steal updates                    
                </comment>
                <comment line="1222">
                    verify                    
                </comment>
                <comment line="1239">
                    possibly replace if died abnormally                    
                </comment>
                <declaration name="idx" type="int" line="1207"/>
                <declaration name="sc" type="int" line="1208"/>
                <declaration name="steps" type="int" line="1209"/>
                <scope line="1212">
                    <declaration name="s" type="long" line="1213"/>
                    <declaration name="g" type="int" line="1214"/>
                    <scope line="1217">
                        <declaration name="ws" type="ForkJoinWorkerThread[]" line="1218"/>
                    </scope>
                </scope>
                <scope line="1237"/>
            </method>
            <javadoc line="1247">
                Possibly initiates and/or completes termination.                
                <param>
                    now if true, unconditionally terminate, else only
                      if shutdown and empty queue and no active workers                    
                </param>
                <return>
                    true if now terminating or terminated                    
                </return>
            </javadoc>
            <method name="tryTerminate" type="boolean" line="1254">
                <params>
                    <param name="now" type="boolean"/>
                </params>
                <comment line="1263">
                    staleness check                    
                </comment>
                <comment line="1271">
                    signal when 0 workers                    
                </comment>
                <declaration name="c" type="long" line="1255"/>
                <scope line="1256">
                    <scope line="1257">
                        <scope line="1261"/>
                    </scope>
                </scope>
                <scope line="1270">
                    <declaration name="lock" type="ReentrantLock" line="1271"/>
                    <scope line="1273"/>
                    <scope line="1275"/>
                </scope>
            </method>
            <javadoc line="1282">
                Runs up to three passes through workers: (0) Setting
                  termination status for each worker, followed by wakeups up to
                  queued workers; (1) helping cancel tasks; (2) interrupting
                  lagging threads (likely in external tasks, but possibly also
                  blocked in joins).  Each pass repeats previous steps because of
                  potential lagging thread creation.                
            </javadoc>
            <method name="startTerminating" type="void" line="1290">
                <scope line="1292">
                    <declaration name="ws" type="ForkJoinWorkerThread[]" line="1293"/>
                    <scope line="1294">
                        <scope line="1295">
                            <scope line="1296">
                                <scope line="1298">
                                    <scope line="1300">
                                        <scope line="1301"/>
                                        <scope line="1303"/>
                                    </scope>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="1314">
                Polls and cancels all submissions. Called only during termination.                
            </javadoc>
            <method name="cancelSubmissions" type="void" line="1317">
                <scope line="1318">
                    <declaration name="task" type="ForkJoinTask&lt;?&gt;" line="1319"/>
                    <scope line="1320">
                        <scope line="1321"/>
                        <scope line="1323"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1329">
                Tries to set the termination status of waiting workers, and
                  then wakes them up (after which they will terminate).                
            </javadoc>
            <method name="terminateWaiters" type="void" line="1333">
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="1334"/>
                <scope line="1335">
                    <declaration name="w" type="ForkJoinWorkerThread" line="1336"/>
                    <declaration name="c" type="long" line="1336"/>
                    <declaration name="i" type="int" line="1336"/>
                    <declaration name="n" type="int" line="1337"/>
                    <scope line="1339">
                        <scope line="1343"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1355">
                Increment or decrement quiescerCount. Needed only to prevent
                  triggering shutdown if a worker is transiently inactive while
                  checking quiescence.                
                <param>
                    delta 1 for increment, -1 for decrement                    
                </param>
            </javadoc>
            <method name="addQuiescerCount" type="void" line="1362">
                <params>
                    <param name="delta" type="int"/>
                </params>
                <declaration name="c" type="int" line="1363"/>
                <scope line="1364"/>
            </method>
            <javadoc line="1368">
                Directly increment or decrement active count without
                  queuing. This method is used to transiently assert inactivation
                  while checking quiescence.                
                <param>
                    delta 1 for increment, -1 for decrement                    
                </param>
            </javadoc>
            <method name="addActiveCount" type="void" line="1375">
                <params>
                    <param name="delta" type="int"/>
                </params>
                <declaration name="d" type="long" line="1376"/>
                <declaration name="c" type="long" line="1377"/>
                <scope line="1378"/>
            </method>
            <javadoc line="1383">
                Returns the approximate (non-atomic) number of idle threads per
                  active thread.                
            </javadoc>
            <method name="idlePerActive" type="int" line="1387">
                <comment line="1389">
                    Approximate at powers of two for small values, saturate past 4                    
                </comment>
                <declaration name="p" type="int" line="1389"/>
                <declaration name="a" type="int" line="1390"/>
            </method>
            <javadoc line="1402">
                Creates a {@code ForkJoinPool} with parallelism equal to {@link java.lang.Runtime#availableProcessors}, using the {@linkplain #defaultForkJoinWorkerThreadFactory default thread factory},
                  no UncaughtExceptionHandler, and non-async LIFO processing mode.                
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}                    
                </throws>
            </javadoc>
            <method name="ForkJoinPool" type="constructor" line="1413"/>
            <javadoc line="1418">
                Creates a {@code ForkJoinPool} with the indicated parallelism
                  level, the {@linkplain #defaultForkJoinWorkerThreadFactory default thread factory},
                  no UncaughtExceptionHandler, and non-async LIFO processing mode.                
                <param>
                    parallelism the parallelism level                    
                </param>
                <throws>
                    IllegalArgumentException if parallelism less than or
                      equal to zero, or greater than implementation limit                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}                    
                </throws>
            </javadoc>
            <method name="ForkJoinPool" type="constructor" line="1432">
                <params>
                    <param name="parallelism" type="int"/>
                </params>
            </method>
            <javadoc line="1436">
                Creates a {@code ForkJoinPool} with the given parameters.                
                <param>
                    parallelism the parallelism level. For default value,
                      use {@link java.lang.Runtime#availableProcessors}.                    
                </param>
                <param>
                    factory the factory for creating new threads. For default value,
                      use {@link #defaultForkJoinWorkerThreadFactory}.                    
                </param>
                <param>
                    handler the handler for internal worker threads that
                      terminate due to unrecoverable errors encountered while executing
                      tasks. For default value, use {@code null}.                    
                </param>
                <param>
                    asyncMode if true,
                      establishes local first-in-first-out scheduling mode for forked
                      tasks that are never joined. This mode may be more appropriate
                      than default locally stack-based mode in applications in which
                      worker threads only process event-style asynchronous tasks.
                      For default value, use {@code false}.                    
                </param>
                <throws>
                    IllegalArgumentException if parallelism less than or
                      equal to zero, or greater than implementation limit                    
                </throws>
                <throws>
                    NullPointerException if the factory is null                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}                    
                </throws>
            </javadoc>
            <method name="ForkJoinPool" type="constructor" line="1463">
                <params>
                    <param name="parallelism" type="int"/>
                    <param name="factory" type="ForkJoinWorkerThreadFactory"/>
                    <param name="handler" type="Thread.UncaughtExceptionHandler"/>
                    <param name="asyncMode" type="boolean"/>
                </params>
                <comment line="1474">
                    offset ctl counts                    
                </comment>
                <comment line="1477">
                    initialize workers array with room for 2*parallelism if possible                    
                </comment>
                <comment line="1481">
                    See Hackers Delight, sec 3.2, where n &lt; (1 &lt;&lt; 16)                    
                </comment>
                <declaration name="np" type="long" line="1473"/>
                <declaration name="n" type="int" line="1477"/>
                <scope line="1480"/>
                <declaration name="sb" type="StringBuilder" line="1486"/>
            </method>
            <javadoc line="1494">
                Performs the given task, returning its result upon completion.
                  If the computation encounters an unchecked Exception or Error,
                  it is rethrown as the outcome of this invocation.  Rethrown
                  exceptions behave in the same way as regular exceptions, but,
                  when possible, contain stack traces (as displayed for example
                  using {@code ex.printStackTrace()}) of both the current thread
                  as well as the thread actually encountering the exception;
                  minimally only the latter.                
                <param>
                    task the task                    
                </param>
                <return>
                    the task&apos;s result                    
                </return>
                <throws>
                    NullPointerException if the task is null                    
                </throws>
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="invoke" type="T" line="1510">
                <params>
                    <param name="task" type="ForkJoinTask<T>"/>
                </params>
                <comment line="1519">
                    bypass submit if in same pool                    
                </comment>
                <declaration name="t" type="Thread" line="1511"/>
                <scope line="1519"/>
            </method>
            <javadoc line="1525">
                Unless terminating, forks task if within an ongoing FJ
                  computation in the current pool, else submits as external task.                
            </javadoc>
            <method name="forkOrSubmit" type="void" line="1529">
                <params>
                    <param name="task" type="ForkJoinTask<T>"/>
                </params>
                <declaration name="w" type="ForkJoinWorkerThread" line="1530"/>
                <declaration name="t" type="Thread" line="1531"/>
            </method>
            <javadoc line="1541">
                Arranges for (asynchronous) execution of the given task.                
                <param>
                    task the task                    
                </param>
                <throws>
                    NullPointerException if the task is null                    
                </throws>
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="execute" type="void" line="1549">
                <params>
                    <param name="task" type="ForkJoinTask<?>"/>
                </params>
            </method>
            <javadoc line="1557">
                @throws NullPointerException if the task is null                
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="execute" type="void" line="1562">
                <params>
                    <param name="task" type="Runnable"/>
                </params>
                <comment line="1567">
                    avoid re-wrap                    
                </comment>
                <declaration name="job" type="ForkJoinTask&lt;?&gt;" line="1565"/>
            </method>
            <javadoc line="1573">
                Submits a ForkJoinTask for execution.                
                <param>
                    task the task to submit                    
                </param>
                <return>
                    the task                    
                </return>
                <throws>
                    NullPointerException if the task is null                    
                </throws>
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="submit" type="ForkJoinTask<T>" line="1582">
                <params>
                    <param name="task" type="ForkJoinTask<T>"/>
                </params>
            </method>
            <javadoc line="1589">
                @throws NullPointerException if the task is null                
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="submit" type="ForkJoinTask<T>" line="1594">
                <params>
                    <param name="task" type="Callable<T>"/>
                </params>
                <declaration name="job" type="ForkJoinTask&lt;T&gt;" line="1597"/>
            </method>
            <javadoc line="1602">
                @throws NullPointerException if the task is null                
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="submit" type="ForkJoinTask<T>" line="1607">
                <params>
                    <param name="task" type="Runnable"/>
                    <param name="result" type="T"/>
                </params>
                <declaration name="job" type="ForkJoinTask&lt;T&gt;" line="1610"/>
            </method>
            <javadoc line="1615">
                @throws NullPointerException if the task is null                
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="submit" type="ForkJoinTask<?>" line="1620">
                <params>
                    <param name="task" type="Runnable"/>
                </params>
                <comment line="1625">
                    avoid re-wrap                    
                </comment>
                <declaration name="job" type="ForkJoinTask&lt;?&gt;" line="1623"/>
            </method>
            <javadoc line="1632">
                @throws NullPointerException       {@inheritDoc}                
                <throws>
                    RejectedExecutionException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="invokeAll" type="List<Future<T>>" line="1636">
                <params>
                    <param name="tasks" type="Collection<? extends Callable<T>>"/>
                </params>
                <declaration name="forkJoinTasks" type="ArrayList&lt;ForkJoinTask&lt;T&gt;&gt;" line="1637"/>
                <declaration name="futures" type="List&lt;Future&lt;T&gt;&gt;" line="1643"/>
            </method>
            <class name="InvokeAll" line="1648">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <extends class="RecursiveAction"/>
                <declaration name="tasks" type="ArrayList&lt;ForkJoinTask&lt;T&gt;&gt;" line="1649"/>
                <method name="InvokeAll" type="constructor" line="1650">
                    <params>
                        <param name="tasks" type="ArrayList<ForkJoinTask<T>>"/>
                    </params>
                </method>
                <method name="compute" type="void" line="1651">
                    <scope line="1652"/>
                    <scope line="1653"/>
                </method>
                <declaration name="serialVersionUID" type="long" line="1655"/>
            </class>
            <javadoc line="1658">
                Returns the factory used for constructing new workers.                
                <return>
                    the factory used for constructing new workers                    
                </return>
            </javadoc>
            <method name="getFactory" type="ForkJoinWorkerThreadFactory" line="1663"/>
            <javadoc line="1667">
                Returns the handler for internal worker threads that terminate
                  due to unrecoverable errors encountered while executing tasks.                
                <return>
                    the handler, or {@code null} if none                    
                </return>
            </javadoc>
            <method name="getUncaughtExceptionHandler" type="Thread.UncaughtExceptionHandler" line="1673"/>
            <javadoc line="1677">
                Returns the targeted parallelism level of this pool.                
                <return>
                    the targeted parallelism level of this pool                    
                </return>
            </javadoc>
            <method name="getParallelism" type="int" line="1682"/>
            <javadoc line="1686">
                Returns the number of worker threads that have started but not
                  yet terminated.  The result returned by this method may differ
                  from {@link #getParallelism} when threads are created to
                  maintain parallelism when others are cooperatively blocked.                
                <return>
                    the number of worker threads                    
                </return>
            </javadoc>
            <method name="getPoolSize" type="int" line="1694"/>
            <javadoc line="1698">
                Returns {@code true} if this pool uses local first-in-first-out
                  scheduling mode for forked tasks that are never joined.                
                <return>
                    {@code true} if this pool uses async mode                    
                </return>
            </javadoc>
            <method name="getAsyncMode" type="boolean" line="1704"/>
            <javadoc line="1708">
                Returns an estimate of the number of worker threads that are
                  not blocked waiting to join tasks or for other managed
                  synchronization. This method may overestimate the
                  number of running threads.                
                <return>
                    the number of worker threads                    
                </return>
            </javadoc>
            <method name="getRunningThreadCount" type="int" line="1716">
                <comment line="1719">
                    suppress momentarily negative values                    
                </comment>
                <declaration name="r" type="int" line="1717"/>
            </method>
            <javadoc line="1721">
                Returns an estimate of the number of threads that are currently
                  stealing or executing tasks. This method may overestimate the
                  number of active threads.                
                <return>
                    the number of active threads                    
                </return>
            </javadoc>
            <method name="getActiveThreadCount" type="int" line="1728">
                <comment line="1731">
                    suppress momentarily negative values                    
                </comment>
                <declaration name="r" type="int" line="1729"/>
            </method>
            <javadoc line="1733">
                Returns {@code true} if all worker threads are currently idle.
                  An idle worker is one that cannot obtain a task to execute
                  because none are available to steal from other threads, and
                  there are no pending submissions to the pool. This method is
                  conservative; it might not return {@code true} immediately upon
                  idleness of all threads, but will eventually become true if
                  threads remain inactive.                
                <return>
                    {@code true} if all threads are currently idle                    
                </return>
            </javadoc>
            <method name="isQuiescent" type="boolean" line="1744"/>
            <javadoc line="1748">
                Returns an estimate of the total number of tasks stolen from
                  one thread&apos;s work queue by another. The reported value
                  underestimates the actual total number of steals when the pool
                  is not quiescent. This value may be useful for monitoring and
                  tuning fork/join programs: in general, steal counts should be
                  high enough to keep threads busy, but low enough to avoid
                  overhead and contention across threads.                
                <return>
                    the number of steals                    
                </return>
            </javadoc>
            <method name="getStealCount" type="long" line="1759"/>
            <javadoc line="1763">
                Returns an estimate of the total number of tasks currently held
                  in queues by worker threads (but not including tasks submitted
                  to the pool that have not begun executing). This value is only
                  an approximation, obtained by iterating across all threads in
                  the pool. This method may be useful for tuning task
                  granularities.                
                <return>
                    the number of queued tasks                    
                </return>
            </javadoc>
            <method name="getQueuedTaskCount" type="long" line="1773">
                <comment line="1781">
                    must read base first                    
                </comment>
                <declaration name="count" type="long" line="1774"/>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="1775"/>
                <scope line="1777"/>
            </method>
            <javadoc line="1785">
                Returns an estimate of the number of tasks submitted to this
                  pool that have not yet begun executing.  This method may take
                  time proportional to the number of submissions.                
                <return>
                    the number of queued submissions                    
                </return>
            </javadoc>
            <method name="getQueuedSubmissionCount" type="int" line="1792"/>
            <javadoc line="1796">
                Returns {@code true} if there are any tasks submitted to this
                  pool that have not yet begun executing.                
                <return>
                    {@code true} if there are any queued submissions                    
                </return>
            </javadoc>
            <method name="hasQueuedSubmissions" type="boolean" line="1802"/>
            <javadoc line="1806">
                Removes and returns the next unexecuted submission if one is
                  available.  This method may be useful in extensions to this
                  class that re-assign work in systems with multiple pools.                
                <return>
                    the next submission, or {@code null} if none                    
                </return>
            </javadoc>
            <method name="pollSubmission" type="ForkJoinTask<?>" line="1813">
                <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="1814"/>
                <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="1814"/>
                <declaration name="b" type="int" line="1814"/>
                <scope line="1817">
                    <declaration name="u" type="long" line="1818"/>
                    <scope line="1821"/>
                </scope>
            </method>
            <javadoc line="1829">
                Removes all available unexecuted submitted and forked tasks
                  from scheduling queues and adds them to the given collection,
                  without altering their execution status. These may include
                  artificially generated or wrapped tasks. This method is
                  designed to be invoked only when the pool is known to be
                  quiescent. Invocations at other times may not remove all
                  tasks. A failure encountered while attempting to add elements
                  to collection {@code c} may result in elements being in
                  neither, either or both collections when the associated
                  exception is thrown.  The behavior of this operation is
                  undefined if the specified collection is modified while the
                  operation is in progress.                
                <param>
                    c the collection to transfer elements into                    
                </param>
                <return>
                    the number of elements transferred                    
                </return>
            </javadoc>
            <method name="drainTasksTo" type="int" line="1846">
                <params>
                    <param name="c" type="Collection<? super ForkJoinTask<?>>"/>
                </params>
                <declaration name="count" type="int" line="1847"/>
                <scope line="1848">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="1849"/>
                    <scope line="1850"/>
                </scope>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="1855"/>
                <scope line="1857"/>
            </method>
            <javadoc line="1865">
                Returns a string identifying this pool, as well as its state,
                  including indications of run state, parallelism level, and
                  worker and task counts.                
                <return>
                    a string identifying this pool, as well as its state                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1872">
                <comment line="1881">
                    ignore transient negative                    
                </comment>
                <declaration name="st" type="long" line="1873"/>
                <declaration name="qt" type="long" line="1874"/>
                <declaration name="qs" type="long" line="1875"/>
                <declaration name="pc" type="int" line="1876"/>
                <declaration name="c" type="long" line="1877"/>
                <declaration name="tc" type="int" line="1878"/>
                <declaration name="rc" type="int" line="1879"/>
                <declaration name="ac" type="int" line="1882"/>
                <declaration name="level" type="String" line="1883"/>
            </method>
            <javadoc line="1900">
                Initiates an orderly shutdown in which previously submitted
                  tasks are executed, but no new tasks will be accepted.
                  Invocation has no additional effect if already shut down.
                  Tasks that are in the process of being submitted concurrently
                  during the course of this method may or may not be rejected.                
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}                    
                </throws>
            </javadoc>
            <method name="shutdown" type="void" line="1912"/>
            <javadoc line="1918">
                Attempts to cancel and/or stop all tasks, and reject all
                  subsequently submitted tasks.  Tasks that are in the process of
                  being submitted or executed concurrently during the course of
                  this method may or may not be rejected. This method cancels
                  both existing and unexecuted tasks, in order to permit
                  termination in the presence of task dependencies. So the method
                  always returns an empty list (unlike the case for some other
                  Executors).                
                <return>
                    an empty list                    
                </return>
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}                    
                </throws>
            </javadoc>
            <method name="shutdownNow" type="List<Runnable>" line="1934"/>
            <javadoc line="1941">
                Returns {@code true} if all tasks have completed following shut down.                
                <return>
                    {@code true} if all tasks have completed following shut down                    
                </return>
            </javadoc>
            <method name="isTerminated" type="boolean" line="1946">
                <declaration name="c" type="long" line="1947"/>
            </method>
            <javadoc line="1952">
                Returns {@code true} if the process of termination has
                  commenced but not yet completed.  This method may be useful for
                  debugging. A return of {@code true} reported a sufficient
                  period after shutdown may indicate that submitted tasks have
                  ignored or suppressed interruption, or are waiting for IO,
                  causing this executor not to properly terminate. (See the
                  advisory notes for class {@link ForkJoinTask} stating that
                  tasks should not normally entail blocking operations.  But if
                  they do, they must abort them on interrupt.)                
                <return>
                    {@code true} if terminating but not yet terminated                    
                </return>
            </javadoc>
            <method name="isTerminating" type="boolean" line="1965">
                <declaration name="c" type="long" line="1966"/>
            </method>
            <javadoc line="1971">
                Returns true if terminating or terminated. Used by ForkJoinWorkerThread.                
            </javadoc>
            <method name="isAtLeastTerminating" type="boolean" line="1974"/>
            <javadoc line="1978">
                Returns {@code true} if this pool has been shut down.                
                <return>
                    {@code true} if this pool has been shut down                    
                </return>
            </javadoc>
            <method name="isShutdown" type="boolean" line="1983"/>
            <javadoc line="1987">
                Blocks until all tasks have completed execution after a shutdown
                  request, or the timeout occurs, or the current thread is
                  interrupted, whichever happens first.                
                <param>
                    timeout the maximum time to wait                    
                </param>
                <param>
                    unit the time unit of the timeout argument                    
                </param>
                <return>
                    {@code true} if this executor terminated and{@code false} if the timeout elapsed before termination                    
                </return>
                <throws>
                    InterruptedException if interrupted while waiting                    
                </throws>
            </javadoc>
            <method name="awaitTermination" type="boolean" line="1999">
                <params>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="nanos" type="long" line="2000"/>
                <declaration name="lock" type="ReentrantLock" line="2001"/>
                <scope line="2003">
                    <scope line="2004"/>
                </scope>
                <scope line="2011"/>
            </method>
            <interface name="ManagedBlocker">
                <javadoc line="2016">
                    Interface for extending managed parallelism for tasks running
                      in {@link ForkJoinPool}s.
                      &lt;p&gt;A {@code ManagedBlocker} provides two methods.  Method{@code isReleasable} must return {@code true} if blocking is
                      not necessary. Method {@code block} blocks the current thread
                      if necessary (perhaps internally invoking {@code isReleasable}before actually blocking). These actions are performed by any
                      thread invoking {@link ForkJoinPool#managedBlock}.  The
                      unusual methods in this API accommodate synchronizers that may,
                      but don&apos;t usually, block for long periods. Similarly, they
                      allow more efficient internal handling of cases in which
                      additional workers may be, but usually are not, needed to
                      ensure sufficient parallelism.  Toward this end,
                      implementations of method {@code isReleasable} must be amenable
                      to repeated invocation.
                      &lt;p&gt;For example, here is a ManagedBlocker based on a
                      ReentrantLock:
                      &lt;pre&gt; {@code}class ManagedLocker implements ManagedBlocker 
                      final ReentrantLock lock;
                      boolean hasLock = false;
                      ManagedLocker(ReentrantLock lock) { this.lock = lock; }
                      public boolean block() {
                      if (!hasLock)
                      lock.lock();
                      return true;
                      }
                      public boolean isReleasable() {
                      return hasLock || (hasLock = lock.tryLock());
                      }
                      }}&lt;/pre&gt;
                      &lt;p&gt;Here is a class that possibly blocks waiting for an
                      item on a given queue:
                      &lt;pre&gt; {@code}class QueueTaker&lt;E&gt; implements ManagedBlocker 
                      final BlockingQueue&lt;E&gt; queue;
                      volatile E item = null;
                      QueueTaker(BlockingQueue&lt;E&gt; q) { this.queue = q; }
                      public boolean block() throws InterruptedException {
                      if (item == null)
                      item = queue.take();
                      return true;
                      }
                      public boolean isReleasable() {
                      return item != null || (item = queue.poll()) != null;
                      }
                      public E getItem() { // call after pool.managedBlock completes
                      return item;
                      }
                      }}&lt;/pre&gt;                    
                </javadoc>
                <method name="block" type="boolean" line="2072"/>
                <javadoc line="2072">
                    Possibly blocks the current thread, for example waiting for
                      a lock or condition.                    
                    <return>
                        {@code true} if no additional blocking is necessary
                          (i.e., if isReleasable would return true)                        
                    </return>
                    <throws>
                        InterruptedException if interrupted while waiting
                          (the method is not required to do so, but is allowed to)                        
                    </throws>
                </javadoc>
                <method name="isReleasable" type="boolean" line="2083"/>
                <javadoc line="2083">
                    Returns {@code true} if blocking is unnecessary.                    
                </javadoc>
            </interface>
            <javadoc line="2089">
                Blocks in accord with the given blocker.  If the current thread
                  is a {@link ForkJoinWorkerThread}, this method possibly
                  arranges for a spare thread to be activated if necessary to
                  ensure sufficient parallelism while the current thread is blocked.
                  &lt;p&gt;If the caller is not a {@link ForkJoinTask}, this method is
                  behaviorally equivalent to
                  &lt;pre&gt; {@codewhile (!blocker.isReleasable())
                  if (blocker.block())
                  return;}&lt;/pre&gt;
                  If the caller is a {@code ForkJoinTask}, then the pool may
                  first be expanded to ensure parallelism, and later adjusted.                
                <param>
                    blocker the blocker                    
                </param>
                <throws>
                    InterruptedException if blocker.block did so                    
                </throws>
            </javadoc>
            <method name="managedBlock" type="void" line="2110">
                <params>
                    <param name="blocker" type="ManagedBlocker"/>
                </params>
                <declaration name="t" type="Thread" line="2111"/>
                <scope line="2112">
                    <declaration name="w" type="ForkJoinWorkerThread" line="2113"/>
                </scope>
                <scope line="2116">
                    <scope line="2117"/>
                </scope>
            </method>
            <method name="newTaskFor" type="RunnableFuture<T>" line="2125">
                <params>
                    <param name="runnable" type="Runnable"/>
                    <param name="value" type="T"/>
                </params>
            </method>
            <method name="newTaskFor" type="RunnableFuture<T>" line="2129">
                <params>
                    <param name="callable" type="Callable<T>"/>
                </params>
            </method>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="2134"/>
            <declaration name="ctlOffset" type="long" line="2135"/>
            <declaration name="stealCountOffset" type="long" line="2136"/>
            <declaration name="blockedCountOffset" type="long" line="2137"/>
            <declaration name="quiescerCountOffset" type="long" line="2138"/>
            <declaration name="scanGuardOffset" type="long" line="2139"/>
            <declaration name="nextWorkerNumberOffset" type="long" line="2140"/>
            <declaration name="ABASE" type="long" line="2141"/>
            <declaration name="ASHIFT" type="int" line="2142"/>
            <scope line="2144">
                <declaration name="s" type="int" line="2150"/>
                <scope line="2151">
                    <declaration name="k" type="Class" line="2153"/>
                    <declaration name="a" type="Class" line="2166"/>
                </scope>
                <scope line="2169"/>
            </scope>
        </class>
    </source>