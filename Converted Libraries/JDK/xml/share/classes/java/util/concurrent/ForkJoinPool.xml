<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.ArrayList"/>
        <import package="java.util.Arrays"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Collections"/>
        <import package="java.util.List"/>
        <import package="java.util.Random"/>
        <import package="java.util.concurrent.AbstractExecutorService"/>
        <import package="java.util.concurrent.Callable"/>
        <import package="java.util.concurrent.ExecutorService"/>
        <import package="java.util.concurrent.Future"/>
        <import package="java.util.concurrent.RejectedExecutionException"/>
        <import package="java.util.concurrent.RunnableFuture"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.TimeoutException"/>
        <import package="java.util.concurrent.atomic.AtomicInteger"/>
        <import package="java.util.concurrent.locks.LockSupport"/>
        <import package="java.util.concurrent.locks.ReentrantLock"/>
        <import package="java.util.concurrent.locks.Condition"/>
        <class name="ForkJoinPool" line="20">
            <extends class="AbstractExecutorService"/>
            <javadoc line="20">
                An {@link ExecutorService} for running {@link ForkJoinTask}s.
                  A {@code ForkJoinPool} provides the entry point for submissions
                  from non-{@code ForkJoinTask} clients, as well as management and
                  monitoring operations.
                  &lt;p&gt;A {@code ForkJoinPool} differs from other kinds of {@link ExecutorService} mainly by virtue of employing
                  &lt;em&gt;work-stealing&lt;/em&gt;: all threads in the pool attempt to find and
                  execute subtasks created by other active tasks (eventually blocking
                  waiting for work if none exist). This enables efficient processing
                  when most tasks spawn other subtasks (as do most {@codeForkJoinTask}s). When setting &lt;em&gt;asyncMode&lt;/em&gt; to true in
                  constructors, {@code ForkJoinPool}s may also be appropriate for use
                  with event-style tasks that are never joined.
                  &lt;p&gt;A {@code ForkJoinPool} is constructed with a given target
                  parallelism level; by default, equal to the number of available
                  processors. The pool attempts to maintain enough active (or
                  available) threads by dynamically adding, suspending, or resuming
                  internal worker threads, even if some tasks are stalled waiting to
                  join others. However, no such adjustments are guaranteed in the
                  face of blocked IO or other unmanaged synchronization. The nested{@link ManagedBlocker} interface enables extension of the kinds of
                  synchronization accommodated.
                  &lt;p&gt;In addition to execution and lifecycle control methods, this
                  class provides status check methods (for example{@link #getStealCount}) that are intended to aid in developing,
                  tuning, and monitoring fork/join applications. Also, method{@link #toString} returns indications of pool state in a
                  convenient form for informal monitoring.
                  &lt;p&gt; As is the case with other ExecutorServices, there are three
                  main task execution methods summarized in the following
                  table. These are designed to be used by clients not already engaged
                  in fork/join computations in the current pool.  The main forms of
                  these methods accept instances of {@code ForkJoinTask}, but
                  overloaded forms also allow mixed execution of plain {@codeRunnable}- or {@code Callable}- based activities as well.  However,
                  tasks that are already executing in a pool should normally
                  &lt;em&gt;NOT&lt;/em&gt; use these pool execution methods, but instead use the
                  within-computation forms listed in the table.
                  &lt;table BORDER CELLPADDING=3 CELLSPACING=1&gt;
                  &lt;tr&gt;
                  &lt;td&gt;&lt;/td&gt;
                  &lt;td ALIGN=CENTER&gt; &lt;b&gt;Call from non-fork/join clients&lt;/b&gt;&lt;/td&gt;
                  &lt;td ALIGN=CENTER&gt; &lt;b&gt;Call from within fork/join computations&lt;/b&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; &lt;b&gt;Arrange async execution&lt;/td&gt;
                  &lt;td&gt; {@link #execute(ForkJoinTask)}&lt;/td&gt;
                  &lt;td&gt; {@link ForkJoinTask#fork}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; &lt;b&gt;Await and obtain result&lt;/td&gt;
                  &lt;td&gt; {@link #invoke(ForkJoinTask)}&lt;/td&gt;
                  &lt;td&gt; {@link ForkJoinTask#invoke}&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;tr&gt;
                  &lt;td&gt; &lt;b&gt;Arrange exec and obtain Future&lt;/td&gt;
                  &lt;td&gt; {@link #submit(ForkJoinTask)}&lt;/td&gt;
                  &lt;td&gt; {@link ForkJoinTask#fork} (ForkJoinTasks &lt;em&gt;are&lt;/em&gt; Futures)&lt;/td&gt;
                  &lt;/tr&gt;
                  &lt;/table&gt;
                  &lt;p&gt;&lt;b&gt;Sample Usage.&lt;/b&gt; Normally a single {@code ForkJoinPool} is
                  used for all parallel task execution in a program or subsystem.
                  Otherwise, use would not usually outweigh the construction and
                  bookkeeping overhead of creating a large set of threads. For
                  example, a common pool could be used for the {@code SortTasks}illustrated in {@link RecursiveAction}. Because {@codeForkJoinPool} uses threads in {@linkplain java.lang.Thread#isDaemondaemon} mode, there is typically no need to explicitly {@link #shutdown} such a pool upon program exit.
                  &lt;pre&gt;
                  static final ForkJoinPool mainPool = new ForkJoinPool();
                  ...
                  public void sort(long[] array) {
                  mainPool.invoke(new SortTask(array, 0, array.length));
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;&lt;b&gt;Implementation notes&lt;/b&gt;: This implementation restricts the
                  maximum number of running threads to 32767. Attempts to create
                  pools with greater than the maximum number result in{@code IllegalArgumentException}.
                  &lt;p&gt;This implementation rejects submitted tasks (that is, by throwing{@link RejectedExecutionException}) only when the pool is shut down
                  or internal resources have been exhausted.                
                <since>
                    1.7                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <interface name="ForkJoinWorkerThreadFactory">
                <javadoc line="96">
                    Factory for creating new {@link ForkJoinWorkerThread}s.
                      A {@code ForkJoinWorkerThreadFactory} must be defined and used
                      for {@code ForkJoinWorkerThread} subclasses that extend base
                      functionality or initialize threads with different contexts.                    
                </javadoc>
                <method name="newThread" type="ForkJoinWorkerThread" line="103"/>
                <javadoc line="103">
                    Returns a new worker thread operating in the given pool.                    
                    <param>
                        pool the pool this thread works in                        
                    </param>
                    <throws>
                        NullPointerException if the pool is null                        
                    </throws>
                </javadoc>
            </interface>
            <class name="DefaultForkJoinWorkerThreadFactory" line="110">
                <implements interface="ForkJoinWorkerThreadFactory"/>
                <javadoc line="110">
                    Default ForkJoinWorkerThreadFactory implementation; creates a
                      new ForkJoinWorkerThread.                    
                </javadoc>
                <method name="newThread" type="ForkJoinWorkerThread" line="115">
                    <params>
                        <param name="pool" type="ForkJoinPool"/>
                    </params>
                </method>
            </class>
            <declaration name="defaultForkJoinWorkerThreadFactory" type="ForkJoinWorkerThreadFactory" line="119"/>
            <javadoc line="119">
                Creates a new ForkJoinWorkerThread. This factory is used unless
                  overridden in ForkJoinPool constructors.                
            </javadoc>
            <declaration name="modifyThreadPermission" type="RuntimePermission" line="124"/>
            <javadoc line="124">
                Permission required for callers of methods that may start or
                  kill threads.                
            </javadoc>
            <javadoc line="129">
                If there is a security manager, makes sure caller has
                  permission to modify threads.                
            </javadoc>
            <method name="checkPermission" type="void" line="133">
                <declaration name="security" type="SecurityManager" line="134"/>
            </method>
            <declaration name="poolNumberGenerator" type="AtomicInteger" line="137"/>
            <javadoc line="137">
                Generator for assigning sequence numbers as pool names.                
            </javadoc>
            <declaration name="workerSeedGenerator" type="Random" line="141"/>
            <javadoc line="141">
                Generator for initial random seeds for worker victim
                  selection. This is used only to create initial seeds. Random
                  steals use a cheaper xorshift generator per steal attempt. We
                  don&apos;t expect much contention on seedGenerator, so just use a
                  plain Random.                
            </javadoc>
            <declaration name="workers" type="ForkJoinWorkerThread[]" line="149"/>
            <javadoc line="149">
                Array holding all worker threads in the pool.  Initialized upon
                  construction. Array size must be a power of two.  Updates and
                  replacements are protected by scanGuard, but the array is
                  always kept in a consistent enough state to be randomly
                  accessed without locking by workers performing work-stealing,
                  as well as other traversal-based methods in this class, so long
                  as reads memory-acquire by first reading ctl. All readers must
                  tolerate that some array slots may be null.                
            </javadoc>
            <declaration name="INITIAL_QUEUE_CAPACITY" type="int" line="160"/>
            <javadoc line="160">
                Initial size for submission queue array. Must be a power of
                  two.  In many applications, these always stay small so we use a
                  small initial cap.                
            </javadoc>
            <declaration name="MAXIMUM_QUEUE_CAPACITY" type="int" line="166"/>
            <javadoc line="166">
                Maximum size for submission queue array. Must be a power of two
                  less than or equal to 1 &lt;&lt; (31 - width of array entry) to
                  ensure lack of index wraparound, but is capped at a lower
                  value to help users trap runaway computations.                
            </javadoc>
            <declaration name="submissionQueue" type="ForkJoinTask&lt;?&gt;[]" line="173"/>
            <javadoc line="173">
                Array serving as submission queue. Initialized upon construction.                
            </javadoc>
            <declaration name="submissionLock" type="ReentrantLock" line="177"/>
            <javadoc line="177">
                Lock protecting submissions array for addSubmission                
            </javadoc>
            <declaration name="termination" type="Condition" line="181"/>
            <javadoc line="181">
                Condition for awaitTermination, using submissionLock for
                  convenience.                
            </javadoc>
            <declaration name="factory" type="ForkJoinWorkerThreadFactory" line="186"/>
            <javadoc line="186">
                Creation factory for worker threads.                
            </javadoc>
            <declaration name="ueh" type="Thread.UncaughtExceptionHandler" line="190"/>
            <javadoc line="190">
                The uncaught exception handler used when any worker abruptly
                  terminates.                
            </javadoc>
            <declaration name="workerNamePrefix" type="String" line="195"/>
            <javadoc line="195">
                Prefix for assigning names to worker threads                
            </javadoc>
            <declaration name="stealCount" type="long" line="199"/>
            <javadoc line="199">
                Sum of per-thread steal counts, updated only when threads are
                  idle or terminating.                
            </javadoc>
            <declaration name="ctl" type="long" line="204"/>
            <javadoc line="204">
                Main pool control -- a long packed with:
                  AC: Number of active running workers minus target parallelism (16 bits)
                  TC: Number of total workers minus target parallelism (16bits)
                  ST: true if pool is terminating (1 bit)
                  EC: the wait count of top waiting thread (15 bits)
                  ID: ~poolIndex of top of Treiber stack of waiting threads (16 bits)
                  When convenient, we can extract the upper 32 bits of counts and
                  the lower 32 bits of queue state, u = (int)(ctl &gt;&gt;&gt; 32) and e =
                  (int)ctl.  The ec field is never accessed alone, but always
                  together with id and st. The offsets of counts by the target
                  parallelism and the positionings of fields makes it possible to
                  perform the most common checks via sign tests of fields: When
                  ac is negative, there are not enough active workers, when tc is
                  negative, there are not enough total workers, when id is
                  negative, there is at least one waiting worker, and when e is
                  negative, the pool is terminating.  To deal with these possibly
                  negative fields, we use casts in and out of &quot;short&quot; and/or
                  signed shifts to maintain signedness.                
            </javadoc>
            <declaration name="AC_SHIFT" type="int" line="225"/>
            <declaration name="TC_SHIFT" type="int" line="226"/>
            <declaration name="ST_SHIFT" type="int" line="227"/>
            <declaration name="EC_SHIFT" type="int" line="228"/>
            <declaration name="MAX_ID" type="int" line="229"/>
            <declaration name="SMASK" type="int" line="230"/>
            <declaration name="SHORT_SIGN" type="int" line="231"/>
            <declaration name="INT_SIGN" type="int" line="232"/>
            <declaration name="STOP_BIT" type="long" line="233"/>
            <declaration name="AC_MASK" type="long" line="234"/>
            <declaration name="TC_MASK" type="long" line="235"/>
            <declaration name="TC_UNIT" type="long" line="236"/>
            <declaration name="AC_UNIT" type="long" line="237"/>
            <declaration name="UAC_SHIFT" type="int" line="238"/>
            <declaration name="UTC_SHIFT" type="int" line="239"/>
            <declaration name="UAC_MASK" type="int" line="240"/>
            <declaration name="UTC_MASK" type="int" line="241"/>
            <declaration name="UAC_UNIT" type="int" line="242"/>
            <declaration name="UTC_UNIT" type="int" line="243"/>
            <declaration name="E_MASK" type="int" line="244"/>
            <declaration name="EC_UNIT" type="int" line="245"/>
            <declaration name="parallelism" type="int" line="246"/>
            <javadoc line="246">
                The target parallelism level.                
            </javadoc>
            <declaration name="queueBase" type="int" line="250"/>
            <javadoc line="250">
                Index (mod submission queue length) of next element to take
                  from submission queue. Usage is identical to that for
                  per-worker queues -- see ForkJoinWorkerThread internal
                  documentation.                
            </javadoc>
            <declaration name="queueTop" type="int" line="257"/>
            <javadoc line="257">
                Index (mod submission queue length) of next element to add
                  in submission queue. Usage is identical to that for
                  per-worker queues -- see ForkJoinWorkerThread internal
                  documentation.                
            </javadoc>
            <declaration name="shutdown" type="boolean" line="264"/>
            <javadoc line="264">
                True when shutdown() has been called.                
            </javadoc>
            <declaration name="locallyFifo" type="boolean" line="268"/>
            <javadoc line="268">
                True if use local fifo, not default lifo, for local polling
                  Read by, and replicated by ForkJoinWorkerThreads                
            </javadoc>
            <declaration name="quiescerCount" type="int" line="273"/>
            <javadoc line="273">
                The number of threads in ForkJoinWorkerThreads.helpQuiescePool.
                  When non-zero, suppresses automatic shutdown when active
                  counts become zero.                
            </javadoc>
            <declaration name="blockedCount" type="int" line="279"/>
            <javadoc line="279">
                The number of threads blocked in join.                
            </javadoc>
            <declaration name="nextWorkerNumber" type="int" line="283"/>
            <javadoc line="283">
                Counter for worker Thread names (unrelated to their poolIndex)                
            </javadoc>
            <declaration name="nextWorkerIndex" type="int" line="287"/>
            <javadoc line="287">
                The index for the next created worker. Accessed under scanGuard.                
            </javadoc>
            <declaration name="scanGuard" type="int" line="291"/>
            <javadoc line="291">
                SeqLock and index masking for updates to workers array.  Locked
                  when SG_UNIT is set. Unlocking clears bit by adding
                  SG_UNIT. Staleness of read-only operations can be checked by
                  comparing scanGuard to value before the reads. The low 16 bits
                  (i.e, anding with SMASK) hold (the smallest power of two
                  covering all worker indices, minus one, and is used to avoid
                  dealing with large numbers of null slots when the workers array
                  is overallocated.                
            </javadoc>
            <declaration name="SG_UNIT" type="int" line="302"/>
            <declaration name="SHRINK_RATE" type="long" line="303"/>
            <javadoc line="303">
                The wakeup interval (in nanoseconds) for a worker waiting for a
                  task when the pool is quiescent to instead try to shrink the
                  number of workers.  The exact value does not matter too
                  much. It must be short enough to release resources during
                  sustained periods of idleness, but not so short that threads
                  are continually re-created.                
            </javadoc>
            <javadoc line="312">
                Top-level loop for worker threads: On each step: if the
                  previous step swept through all queues and found no tasks, or
                  there are excess threads, then possibly blocks. Otherwise,
                  scans for and, if found, executes a task. Returns when pool
                  and/or worker terminate.                
                <param>
                    w the worker                    
                </param>
            </javadoc>
            <method name="work" type="void" line="320">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                </params>
                <declaration name="swept" type="boolean" line="321"/>
                <declaration name="c" type="long" line="322"/>
                <scope line="323">
                    <declaration name="a" type="int" line="324"/>
                </scope>
            </method>
            <javadoc line="329">
                Wakes up or creates a worker.                
            </javadoc>
            <method name="signalWork" type="void" line="332">
                <declaration name="c" type="long" line="333"/>
                <declaration name="e" type="int" line="334"/>
                <scope line="335">
                    <scope line="336">
                        <declaration name="i" type="int" line="337"/>
                        <declaration name="w" type="ForkJoinWorkerThread" line="338"/>
                        <declaration name="ws" type="ForkJoinWorkerThread[]" line="339"/>
                        <declaration name="nc" type="long" line="341"/>
                        <scope line="342"/>
                    </scope>
                    <scope line="348"/>
                </scope>
            </method>
            <javadoc line="354">
                Variant of signalWork to help release waiters on rescans.
                  Tries once to release a waiter if active count &lt; 0.                
                <return>
                    false if failed due to contention, else true                    
                </return>
            </javadoc>
            <method name="tryReleaseWaiter" type="boolean" line="359">
                <declaration name="c" type="long" line="360"/>
                <declaration name="e" type="int" line="361"/>
                <declaration name="w" type="ForkJoinWorkerThread" line="362"/>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="363"/>
                <scope line="364">
                    <declaration name="nc" type="long" line="365"/>
                </scope>
            </method>
            <javadoc line="372">
                Scans for and, if found, executes one task. Scans start at a
                  random index of workers array, and randomly select the first
                  (2#workers)-1 probes, and then, if all empty, resort to 2
                  circular sweeps, which is necessary to check quiescence. and
                  taking a submission only if no stealable tasks were found.  The
                  steal code inside the loop is a specialized form of
                  ForkJoinWorkerThread.deqTask, followed bookkeeping to support
                  helpJoinTask and signal propagation. The code for submission
                  queues is almost identical. On each steal, the worker completes
                  not only the task, but also all local tasks that this task may
                  have generated. On detecting staleness or contention when
                  trying to take a task, this method returns without finishing
                  sweep, which allows global state rechecks before retry.                
                <param>
                    w the worker                    
                </param>
                <param>
                    a the number of active workers                    
                </param>
                <return>
                    true if swept all queues without finding a task                    
                </return>
            </javadoc>
            <method name="scan" type="boolean" line="390">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                    <param name="a" type="int"/>
                </params>
                <declaration name="g" type="int" line="391"/>
                <declaration name="m" type="int" line="392"/>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="393"/>
                <scope line="395">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="396"/>
                    <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="397"/>
                    <declaration name="b" type="int" line="398"/>
                    <declaration name="v" type="ForkJoinWorkerThread" line="399"/>
                    <scope line="400">
                        <declaration name="u" type="long" line="401"/>
                        <scope line="402">
                            <declaration name="d" type="int" line="403"/>
                        </scope>
                    </scope>
                    <scope line="413"/>
                </scope>
                <scope line="421">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="422"/>
                    <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="423"/>
                    <declaration name="b" type="int" line="424"/>
                    <scope line="425">
                        <declaration name="u" type="long" line="426"/>
                        <scope line="427"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="436">
                Tries to enqueue worker w in wait queue and await change in
                  worker&apos;s eventCount.  If the pool is quiescent and there is
                  more than one worker, possibly terminates worker upon exit.
                  Otherwise, before blocking, rescans queues to avoid missed
                  signals.  Upon finding work, releases at least one worker
                  (which may be the current worker). Rescans restart upon
                  detected staleness or failure to release due to
                  contention. Note the unusual conventions about Thread.interrupt
                  here and elsewhere: Because interrupts are used solely to alert
                  threads to check termination, which is checked here anyway, we
                  clear status (using Thread.interrupted) before any call to
                  park, so that park does not immediately return due to status
                  being set via some other unrelated call to interrupt in user
                  code.                
                <param>
                    w the calling worker                    
                </param>
                <param>
                    c the ctl value on entry                    
                </param>
                <return>
                    true if waited or another thread was released upon enq                    
                </return>
            </javadoc>
            <method name="tryAwaitWork" type="boolean" line="455">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                    <param name="c" type="long"/>
                </params>
                <declaration name="v" type="int" line="456"/>
                <declaration name="nc" type="long" line="458"/>
                <scope line="459">
                    <declaration name="d" type="long" line="460"/>
                </scope>
                <scope line="463">
                    <declaration name="s" type="long" line="464"/>
                </scope>
                <scope line="469">
                    <scope line="471">
                        <declaration name="g" type="int" line="472"/>
                        <declaration name="ws" type="ForkJoinWorkerThread[]" line="473"/>
                        <scope line="474">
                            <scope line="476">
                                <declaration name="u" type="ForkJoinWorkerThread" line="477"/>
                                <scope line="478"/>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="488">
                        <scope line="490"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="499">
                If inactivating worker w has caused pool to become
                  quiescent, check for pool termination, and wait for event
                  for up to SHRINK_RATE nanosecs (rescans are unnecessary in
                  this case because quiescence reflects consensus about lack
                  of work). On timeout, if ctl has not changed, terminate the
                  worker. Upon its termination (see deregisterWorker), it may
                  wake up another worker to possibly repeat this process.                
                <param>
                    w the calling worker                    
                </param>
                <param>
                    currentCtl the ctl value after enqueuing w                    
                </param>
                <param>
                    prevCtl the ctl value if w terminated                    
                </param>
                <param>
                    v the eventCount w awaits change                    
                </param>
            </javadoc>
            <method name="idleAwaitWork" type="void" line="512">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                    <param name="currentCtl" type="long"/>
                    <param name="prevCtl" type="long"/>
                    <param name="v" type="int"/>
                </params>
                <scope line="513">
                    <scope line="516">
                        <declaration name="startTime" type="long" line="517"/>
                        <scope line="523"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="531">
                Enqueues the given task in the submissionQueue.  Same idea as
                  ForkJoinWorkerThread.pushTask except for use of submissionLock.                
                <param>
                    t the task                    
                </param>
            </javadoc>
            <method name="addSubmission" type="void" line="536">
                <params>
                    <param name="t" type="ForkJoinTask<?>"/>
                </params>
                <declaration name="lock" type="ReentrantLock" line="537"/>
                <scope line="539">
                    <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="540"/>
                    <declaration name="s" type="int" line="541"/>
                    <scope line="542">
                        <declaration name="u" type="long" line="543"/>
                    </scope>
                </scope>
                <scope line="549"/>
            </method>
            <javadoc line="554">
                Creates or doubles submissionQueue array.
                  Basically identical to ForkJoinWorkerThread version.                
            </javadoc>
            <method name="growSubmissionQueue" type="void" line="558">
                <declaration name="oldQ" type="ForkJoinTask&lt;?&gt;[]" line="559"/>
                <declaration name="size" type="int" line="560"/>
                <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="563"/>
                <declaration name="mask" type="int" line="564"/>
                <declaration name="top" type="int" line="565"/>
                <declaration name="oldMask" type="int" line="566"/>
                <scope line="567">
                    <scope line="568">
                        <declaration name="u" type="long" line="569"/>
                        <declaration name="x" type="Object" line="570"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="575">
                Tries to increment blockedCount, decrement active count
                  (sometimes implicitly) and possibly release or create a
                  compensating worker in preparation for blocking. Fails
                  on contention or termination.                
                <return>
                    true if the caller can block, else should recheck and retry                    
                </return>
            </javadoc>
            <method name="tryPreBlock" type="boolean" line="582">
                <declaration name="b" type="int" line="583"/>
                <scope line="584">
                    <declaration name="pc" type="int" line="585"/>
                    <scope line="586">
                        <declaration name="ws" type="ForkJoinWorkerThread[]" line="587"/>
                        <declaration name="w" type="ForkJoinWorkerThread" line="588"/>
                        <declaration name="e" type="int" line="589"/>
                        <declaration name="c" type="long" line="590"/>
                        <declaration name="u" type="int" line="591"/>
                        <scope line="592"/>
                        <scope line="594">
                            <declaration name="nc" type="long" line="595"/>
                            <scope line="596"/>
                        </scope>
                        <scope line="602">
                            <declaration name="nc" type="long" line="603"/>
                        </scope>
                        <scope line="606">
                            <declaration name="nc" type="long" line="607"/>
                            <scope line="608"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="618">
                Decrements blockedCount and increments active count                
            </javadoc>
            <method name="postBlock" type="void" line="621">
                <declaration name="c" type="long" line="622"/>
                <scope line="623"/>
                <declaration name="b" type="int" line="626"/>
                <scope line="627"/>
            </method>
            <javadoc line="631">
                Possibly blocks waiting for the given task to complete, or
                  cancels the task if terminating.  Fails to wait if contended.                
                <param>
                    joinMe the task                    
                </param>
            </javadoc>
            <method name="tryAwaitJoin" type="void" line="636">
                <params>
                    <param name="joinMe" type="ForkJoinTask<?>"/>
                </params>
                <declaration name="s" type="int" line="637"/>
                <scope line="639">
                    <scope line="640"/>
                </scope>
            </method>
            <javadoc line="647">
                Possibly blocks the given worker waiting for joinMe to
                  complete or timeout                
                <param>
                    joinMe the task                    
                </param>
                <param>
                    millis the wait time for underlying Object.wait                    
                </param>
            </javadoc>
            <method name="timedAwaitJoin" type="void" line="653">
                <params>
                    <param name="joinMe" type="ForkJoinTask<?>"/>
                    <param name="nanos" type="long"/>
                </params>
                <scope line="654">
                    <scope line="656"/>
                    <scope line="660">
                        <declaration name="last" type="long" line="661"/>
                        <scope line="662">
                            <declaration name="millis" type="long" line="663"/>
                            <scope line="667"/>
                            <declaration name="now" type="long" line="671"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="680">
                If necessary, compensates for blocker, and blocks                
            </javadoc>
            <method name="awaitBlocker" type="void" line="683">
                <params>
                    <param name="blocker" type="ManagedBlocker"/>
                </params>
                <scope line="684">
                    <scope line="685">
                        <scope line="686">
                            <scope line="687"/>
                        </scope>
                        <scope line="691"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="698">
                Tries to create and start a worker; minimally rolls back counts
                  on failure.                
            </javadoc>
            <method name="addWorker" type="void" line="702">
                <declaration name="ex" type="Throwable" line="703"/>
                <declaration name="t" type="ForkJoinWorkerThread" line="704"/>
                <scope line="705"/>
                <scope line="708"/>
                <scope line="711">
                    <declaration name="c" type="long" line="712"/>
                    <scope line="713"/>
                </scope>
            </method>
            <javadoc line="720">
                Callback from ForkJoinWorkerThread constructor to assign a
                  public name                
            </javadoc>
            <method name="nextWorkerName" type="String" line="724">
                <scope line="725"/>
            </method>
            <javadoc line="729">
                Callback from ForkJoinWorkerThread constructor to
                  determine its poolIndex and record in workers array.                
                <param>
                    w the worker                    
                </param>
                <return>
                    the worker's pool index                    
                </return>
            </javadoc>
            <method name="registerWorker" type="int" line="735">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                </params>
                <scope line="736">
                    <declaration name="ws" type="ForkJoinWorkerThread[]" line="737"/>
                    <scope line="738">
                        <declaration name="k" type="int" line="739"/>
                        <scope line="740">
                            <scope line="741">
                                <declaration name="n" type="int" line="742"/>
                                <scope line="743"/>
                                <declaration name="m" type="int" line="749"/>
                            </scope>
                        </scope>
                        <scope line="753"/>
                    </scope>
                    <scope line="758">
                        <scope line="759">
                            <scope line="760"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="767">
                Final callback from terminating worker.  Removes record of
                  worker from array, and adjusts counts. If pool is shutting
                  down, tries to complete termination.                
                <param>
                    w the worker                    
                </param>
            </javadoc>
            <method name="deregisterWorker" type="void" line="773">
                <params>
                    <param name="w" type="ForkJoinWorkerThread"/>
                    <param name="ex" type="Throwable"/>
                </params>
                <declaration name="idx" type="int" line="774"/>
                <declaration name="sc" type="int" line="775"/>
                <declaration name="steps" type="int" line="776"/>
                <scope line="777">
                    <declaration name="s" type="long" line="778"/>
                    <declaration name="g" type="int" line="779"/>
                    <scope line="780">
                        <declaration name="ws" type="ForkJoinWorkerThread[]" line="781"/>
                    </scope>
                </scope>
                <scope line="791"/>
            </method>
            <javadoc line="796">
                Possibly initiates and/or completes termination.                
                <param>
                    now if true, unconditionally terminate, else only
                      if shutdown and empty queue and no active workers                    
                </param>
                <return>
                    true if now terminating or terminated                    
                </return>
            </javadoc>
            <method name="tryTerminate" type="boolean" line="802">
                <params>
                    <param name="now" type="boolean"/>
                </params>
                <declaration name="c" type="long" line="803"/>
                <scope line="804">
                    <scope line="805">
                        <scope line="807"/>
                    </scope>
                </scope>
                <scope line="814">
                    <declaration name="lock" type="ReentrantLock" line="815"/>
                    <scope line="817"/>
                    <scope line="820"/>
                </scope>
            </method>
            <javadoc line="826">
                Runs up to three passes through workers: (0) Setting
                  termination status for each worker, followed by wakeups up to
                  queued workers; (1) helping cancel tasks; (2) interrupting
                  lagging threads (likely in external tasks, but possibly also
                  blocked in joins).  Each pass repeats previous steps because of
                  potential lagging thread creation.                
            </javadoc>
            <method name="startTerminating" type="void" line="834">
                <scope line="836">
                    <declaration name="ws" type="ForkJoinWorkerThread[]" line="837"/>
                    <scope line="838">
                        <scope line="839">
                            <scope line="840">
                                <scope line="842">
                                    <scope line="844">
                                        <scope line="845"/>
                                        <scope line="848"/>
                                    </scope>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="858">
                Polls and cancels all submissions. Called only during termination.                
            </javadoc>
            <method name="cancelSubmissions" type="void" line="861">
                <scope line="862">
                    <declaration name="task" type="ForkJoinTask&lt;?&gt;" line="863"/>
                    <scope line="864">
                        <scope line="865"/>
                        <scope line="868"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="873">
                Tries to set the termination status of waiting workers, and
                  then wakes them up (after which they will terminate).                
            </javadoc>
            <method name="terminateWaiters" type="void" line="877">
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="878"/>
                <scope line="879">
                    <declaration name="w" type="ForkJoinWorkerThread" line="880"/>
                    <declaration name="c" type="long" line="881"/>
                    <declaration name="i" type="int" line="882"/>
                    <declaration name="n" type="int" line="883"/>
                    <scope line="884">
                        <scope line="885"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="893">
                Increment or decrement quiescerCount. Needed only to prevent
                  triggering shutdown if a worker is transiently inactive while
                  checking quiescence.                
                <param>
                    delta 1 for increment, -1 for decrement                    
                </param>
            </javadoc>
            <method name="addQuiescerCount" type="void" line="899">
                <params>
                    <param name="delta" type="int"/>
                </params>
                <declaration name="c" type="int" line="900"/>
                <scope line="901"/>
            </method>
            <javadoc line="905">
                Directly increment or decrement active count without
                  queuing. This method is used to transiently assert inactivation
                  while checking quiescence.                
                <param>
                    delta 1 for increment, -1 for decrement                    
                </param>
            </javadoc>
            <method name="addActiveCount" type="void" line="911">
                <params>
                    <param name="delta" type="int"/>
                </params>
                <declaration name="d" type="long" line="912"/>
                <declaration name="c" type="long" line="913"/>
                <scope line="914"/>
            </method>
            <javadoc line="918">
                Returns the approximate (non-atomic) number of idle threads per
                  active thread.                
            </javadoc>
            <method name="idlePerActive" type="int" line="922">
                <declaration name="p" type="int" line="923"/>
                <declaration name="a" type="int" line="924"/>
            </method>
            <javadoc line="927">
                Creates a {@code ForkJoinPool} with parallelism equal to {@link java.lang.Runtime#availableProcessors}, using the {@linkplain #defaultForkJoinWorkerThreadFactory default thread factory},
                  no UncaughtExceptionHandler, and non-async LIFO processing mode.                
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code ("modifyThread")}                    
                </throws>
            </javadoc>
            <method name="ForkJoinPool" type="constructor" line="934"/>
            <javadoc line="937">
                Creates a {@code ForkJoinPool} with the indicated parallelism
                  level, the {@linkplain #defaultForkJoinWorkerThreadFactory default thread factory},
                  no UncaughtExceptionHandler, and non-async LIFO processing mode.                
                <param>
                    parallelism the parallelism level                    
                </param>
                <throws>
                    IllegalArgumentException if parallelism less than or
                      equal to zero, or greater than implementation limit                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code ("modifyThread")}                    
                </throws>
            </javadoc>
            <method name="ForkJoinPool" type="constructor" line="948">
                <params>
                    <param name="parallelism" type="int"/>
                </params>
            </method>
            <javadoc line="951">
                Creates a {@code ForkJoinPool} with the given parameters.                
                <param>
                    parallelism the parallelism level. For default value,
                      use {@link java.lang.Runtime#availableProcessors}.                    
                </param>
                <param>
                    factory the factory for creating new threads. For default value,
                      use {@link #defaultForkJoinWorkerThreadFactory}.                    
                </param>
                <param>
                    handler the handler for internal worker threads that
                      terminate due to unrecoverable errors encountered while executing
                      tasks. For default value, use {@code null}.                    
                </param>
                <param>
                    asyncMode if true,
                      establishes local first-in-first-out scheduling mode for forked
                      tasks that are never joined. This mode may be more appropriate
                      than default locally stack-based mode in applications in which
                      worker threads only process event-style asynchronous tasks.
                      For default value, use {@code false}.                    
                </param>
                <throws>
                    IllegalArgumentException if parallelism less than or
                      equal to zero, or greater than implementation limit                    
                </throws>
                <throws>
                    NullPointerException if the factory is null                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code ("modifyThread")}                    
                </throws>
            </javadoc>
            <method name="ForkJoinPool" type="constructor" line="973">
                <params>
                    <param name="parallelism" type="int"/>
                    <param name="factory" type="ForkJoinWorkerThreadFactory"/>
                    <param name="handler" type="Thread.UncaughtExceptionHandler"/>
                    <param name="asyncMode" type="boolean"/>
                </params>
                <declaration name="np" type="long" line="981"/>
                <declaration name="n" type="int" line="984"/>
                <scope line="986"/>
                <declaration name="sb" type="StringBuilder" line="995"/>
            </method>
            <javadoc line="1000">
                Performs the given task, returning its result upon completion.
                  If the computation encounters an unchecked Exception or Error,
                  it is rethrown as the outcome of this invocation.  Rethrown
                  exceptions behave in the same way as regular exceptions, but,
                  when possible, contain stack traces (as displayed for example
                  using {@code ex.printStackTrace()}) of both the current thread
                  as well as the thread actually encountering the exception;
                  minimally only the latter.                
                <param>
                    task the task                    
                </param>
                <return>
                    the task's result                    
                </return>
                <throws>
                    NullPointerException if the task is null                    
                </throws>
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="invoke" type="T" line="1015">
                <params>
                    <param name="task" type="ForkJoinTask<T>"/>
                </params>
                <declaration name="t" type="Thread" line="1016"/>
                <scope line="1020"/>
            </method>
            <javadoc line="1025">
                Unless terminating, forks task if within an ongoing FJ
                  computation in the current pool, else submits as external task.                
            </javadoc>
            <method name="forkOrSubmit" type="void" line="1029">
                <params>
                    <param name="task" type="ForkJoinTask<T>"/>
                </params>
                <declaration name="w" type="ForkJoinWorkerThread" line="1030"/>
                <declaration name="t" type="Thread" line="1031"/>
            </method>
            <javadoc line="1036">
                Arranges for (asynchronous) execution of the given task.                
                <param>
                    task the task                    
                </param>
                <throws>
                    NullPointerException if the task is null                    
                </throws>
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="execute" type="void" line="1043">
                <params>
                    <param name="task" type="ForkJoinTask<?>"/>
                </params>
            </method>
            <javadoc line="1047">
                @throws NullPointerException if the task is null                
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="execute" type="void" line="1052">
                <params>
                    <param name="task" type="Runnable"/>
                </params>
                <declaration name="job" type="ForkJoinTask&lt;?&gt;" line="1054"/>
            </method>
            <javadoc line="1059">
                Submits a ForkJoinTask for execution.                
                <param>
                    task the task to submit                    
                </param>
                <return>
                    the task                    
                </return>
                <throws>
                    NullPointerException if the task is null                    
                </throws>
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="submit" type="ForkJoinTask<T>" line="1067">
                <params>
                    <param name="task" type="ForkJoinTask<T>"/>
                </params>
            </method>
            <javadoc line="1072">
                @throws NullPointerException if the task is null                
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="submit" type="ForkJoinTask<T>" line="1077">
                <params>
                    <param name="task" type="Callable<T>"/>
                </params>
                <declaration name="job" type="ForkJoinTask&lt;T&gt;" line="1079"/>
            </method>
            <javadoc line="1083">
                @throws NullPointerException if the task is null                
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="submit" type="ForkJoinTask<T>" line="1088">
                <params>
                    <param name="task" type="Runnable"/>
                    <param name="result" type="T"/>
                </params>
                <declaration name="job" type="ForkJoinTask&lt;T&gt;" line="1090"/>
            </method>
            <javadoc line="1094">
                @throws NullPointerException if the task is null                
                <throws>
                    RejectedExecutionException if the task cannot be
                      scheduled for execution                    
                </throws>
            </javadoc>
            <method name="submit" type="ForkJoinTask<?>" line="1099">
                <params>
                    <param name="task" type="Runnable"/>
                </params>
                <declaration name="job" type="ForkJoinTask&lt;?&gt;" line="1101"/>
            </method>
            <javadoc line="1107">
                @throws NullPointerException       {@inheritDoc}                
                <throws>
                    RejectedExecutionException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="invokeAll" type="List<Future<T>>" line="1111">
                <params>
                    <param name="tasks" type="Collection<? extends Callable<T>>"/>
                </params>
                <declaration name="forkJoinTasks" type="ArrayList&lt;ForkJoinTask&lt;T&gt;&gt;" line="1112"/>
                <declaration name="futures" type="List&lt;Future&lt;T&gt;&gt;" line="1115"/>
            </method>
            <class name="InvokeAll" line="1118">
                <type_params>
                    <type_param name="T"/>
                </type_params>
                <extends class="RecursiveAction"/>
                <declaration name="tasks" type="ArrayList&lt;ForkJoinTask&lt;T&gt;&gt;" line="1119"/>
                <method name="InvokeAll" type="constructor" line="1120">
                    <params>
                        <param name="tasks" type="ArrayList<ForkJoinTask<T>>"/>
                    </params>
                </method>
                <method name="compute" type="void" line="1123">
                    <scope line="1124"/>
                    <scope line="1127"/>
                </method>
                <declaration name="serialVersionUID" type="long" line="1130"/>
            </class>
            <javadoc line="1132">
                Returns the factory used for constructing new workers.                
                <return>
                    the factory used for constructing new workers                    
                </return>
            </javadoc>
            <method name="getFactory" type="ForkJoinWorkerThreadFactory" line="1136"/>
            <javadoc line="1139">
                Returns the handler for internal worker threads that terminate
                  due to unrecoverable errors encountered while executing tasks.                
                <return>
                    the handler, or {@code null} if none                    
                </return>
            </javadoc>
            <method name="getUncaughtExceptionHandler" type="Thread.UncaughtExceptionHandler" line="1144"/>
            <javadoc line="1147">
                Returns the targeted parallelism level of this pool.                
                <return>
                    the targeted parallelism level of this pool                    
                </return>
            </javadoc>
            <method name="getParallelism" type="int" line="1151"/>
            <javadoc line="1154">
                Returns the number of worker threads that have started but not
                  yet terminated.  The result returned by this method may differ
                  from {@link #getParallelism} when threads are created to
                  maintain parallelism when others are cooperatively blocked.                
                <return>
                    the number of worker threads                    
                </return>
            </javadoc>
            <method name="getPoolSize" type="int" line="1161"/>
            <javadoc line="1164">
                Returns {@code true} if this pool uses local first-in-first-out
                  scheduling mode for forked tasks that are never joined.                
                <return>
                    {@code true} if this pool uses async mode                    
                </return>
            </javadoc>
            <method name="getAsyncMode" type="boolean" line="1169"/>
            <javadoc line="1172">
                Returns an estimate of the number of worker threads that are
                  not blocked waiting to join tasks or for other managed
                  synchronization. This method may overestimate the
                  number of running threads.                
                <return>
                    the number of worker threads                    
                </return>
            </javadoc>
            <method name="getRunningThreadCount" type="int" line="1179">
                <declaration name="r" type="int" line="1180"/>
            </method>
            <javadoc line="1183">
                Returns an estimate of the number of threads that are currently
                  stealing or executing tasks. This method may overestimate the
                  number of active threads.                
                <return>
                    the number of active threads                    
                </return>
            </javadoc>
            <method name="getActiveThreadCount" type="int" line="1189">
                <declaration name="r" type="int" line="1190"/>
            </method>
            <javadoc line="1193">
                Returns {@code true} if all worker threads are currently idle.
                  An idle worker is one that cannot obtain a task to execute
                  because none are available to steal from other threads, and
                  there are no pending submissions to the pool. This method is
                  conservative; it might not return {@code true} immediately upon
                  idleness of all threads, but will eventually become true if
                  threads remain inactive.                
                <return>
                    {@code true} if all threads are currently idle                    
                </return>
            </javadoc>
            <method name="isQuiescent" type="boolean" line="1203"/>
            <javadoc line="1206">
                Returns an estimate of the total number of tasks stolen from
                  one thread&apos;s work queue by another. The reported value
                  underestimates the actual total number of steals when the pool
                  is not quiescent. This value may be useful for monitoring and
                  tuning fork/join programs: in general, steal counts should be
                  high enough to keep threads busy, but low enough to avoid
                  overhead and contention across threads.                
                <return>
                    the number of steals                    
                </return>
            </javadoc>
            <method name="getStealCount" type="long" line="1216"/>
            <javadoc line="1219">
                Returns an estimate of the total number of tasks currently held
                  in queues by worker threads (but not including tasks submitted
                  to the pool that have not begun executing). This value is only
                  an approximation, obtained by iterating across all threads in
                  the pool. This method may be useful for tuning task
                  granularities.                
                <return>
                    the number of queued tasks                    
                </return>
            </javadoc>
            <method name="getQueuedTaskCount" type="long" line="1228">
                <declaration name="count" type="long" line="1229"/>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="1230"/>
                <scope line="1231"/>
            </method>
            <javadoc line="1236">
                Returns an estimate of the number of tasks submitted to this
                  pool that have not yet begun executing.  This method may take
                  time proportional to the number of submissions.                
                <return>
                    the number of queued submissions                    
                </return>
            </javadoc>
            <method name="getQueuedSubmissionCount" type="int" line="1242"/>
            <javadoc line="1245">
                Returns {@code true} if there are any tasks submitted to this
                  pool that have not yet begun executing.                
                <return>
                    {@code true} if there are any queued submissions                    
                </return>
            </javadoc>
            <method name="hasQueuedSubmissions" type="boolean" line="1250"/>
            <javadoc line="1253">
                Removes and returns the next unexecuted submission if one is
                  available.  This method may be useful in extensions to this
                  class that re-assign work in systems with multiple pools.                
                <return>
                    the next submission, or {@code null} if none                    
                </return>
            </javadoc>
            <method name="pollSubmission" type="ForkJoinTask<?>" line="1259">
                <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="1260"/>
                <declaration name="q" type="ForkJoinTask&lt;?&gt;[]" line="1261"/>
                <declaration name="b" type="int" line="1262"/>
                <scope line="1263">
                    <declaration name="u" type="long" line="1264"/>
                    <scope line="1265"/>
                </scope>
            </method>
            <javadoc line="1272">
                Removes all available unexecuted submitted and forked tasks
                  from scheduling queues and adds them to the given collection,
                  without altering their execution status. These may include
                  artificially generated or wrapped tasks. This method is
                  designed to be invoked only when the pool is known to be
                  quiescent. Invocations at other times may not remove all
                  tasks. A failure encountered while attempting to add elements
                  to collection {@code c} may result in elements being in
                  neither, either or both collections when the associated
                  exception is thrown.  The behavior of this operation is
                  undefined if the specified collection is modified while the
                  operation is in progress.                
                <param>
                    c the collection to transfer elements into                    
                </param>
                <return>
                    the number of elements transferred                    
                </return>
            </javadoc>
            <method name="drainTasksTo" type="int" line="1288">
                <params>
                    <param name="c" type="Collection<? super ForkJoinTask<?>>"/>
                </params>
                <declaration name="count" type="int" line="1289"/>
                <scope line="1290">
                    <declaration name="t" type="ForkJoinTask&lt;?&gt;" line="1291"/>
                    <scope line="1292"/>
                </scope>
                <declaration name="ws" type="ForkJoinWorkerThread[]" line="1297"/>
                <scope line="1298"/>
            </method>
            <javadoc line="1303">
                Returns a string identifying this pool, as well as its state,
                  including indications of run state, parallelism level, and
                  worker and task counts.                
                <return>
                    a string identifying this pool, as well as its state                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1309">
                <declaration name="st" type="long" line="1310"/>
                <declaration name="qt" type="long" line="1311"/>
                <declaration name="qs" type="long" line="1312"/>
                <declaration name="pc" type="int" line="1313"/>
                <declaration name="c" type="long" line="1314"/>
                <declaration name="tc" type="int" line="1315"/>
                <declaration name="rc" type="int" line="1316"/>
                <declaration name="ac" type="int" line="1318"/>
                <declaration name="level" type="String" line="1319"/>
            </method>
            <javadoc line="1324">
                Initiates an orderly shutdown in which previously submitted
                  tasks are executed, but no new tasks will be accepted.
                  Invocation has no additional effect if already shut down.
                  Tasks that are in the process of being submitted concurrently
                  during the course of this method may or may not be rejected.                
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code ("modifyThread")}                    
                </throws>
            </javadoc>
            <method name="shutdown" type="void" line="1334"/>
            <javadoc line="1339">
                Attempts to cancel and/or stop all tasks, and reject all
                  subsequently submitted tasks.  Tasks that are in the process of
                  being submitted or executed concurrently during the course of
                  this method may or may not be rejected. This method cancels
                  both existing and unexecuted tasks, in order to permit
                  termination in the presence of task dependencies. So the method
                  always returns an empty list (unlike the case for some other
                  Executors).                
                <return>
                    an empty list                    
                </return>
                <throws>
                    SecurityException if a security manager exists and
                      the caller is not permitted to modify threads
                      because it does not hold {@link java.lang.RuntimePermission}{@code ("modifyThread")}                    
                </throws>
            </javadoc>
            <method name="shutdownNow" type="List<Runnable>" line="1353"/>
            <javadoc line="1359">
                Returns {@code true} if all tasks have completed following shut down.                
                <return>
                    {@code true} if all tasks have completed following shut down                    
                </return>
            </javadoc>
            <method name="isTerminated" type="boolean" line="1363">
                <declaration name="c" type="long" line="1364"/>
            </method>
            <javadoc line="1367">
                Returns {@code true} if the process of termination has
                  commenced but not yet completed.  This method may be useful for
                  debugging. A return of {@code true} reported a sufficient
                  period after shutdown may indicate that submitted tasks have
                  ignored or suppressed interruption, or are waiting for IO,
                  causing this executor not to properly terminate. (See the
                  advisory notes for class {@link ForkJoinTask} stating that
                  tasks should not normally entail blocking operations.  But if
                  they do, they must abort them on interrupt.)                
                <return>
                    {@code true} if terminating but not yet terminated                    
                </return>
            </javadoc>
            <method name="isTerminating" type="boolean" line="1379">
                <declaration name="c" type="long" line="1380"/>
            </method>
            <javadoc line="1383">
                Returns true if terminating or terminated. Used by ForkJoinWorkerThread.                
            </javadoc>
            <method name="isAtLeastTerminating" type="boolean" line="1386"/>
            <javadoc line="1389">
                Returns {@code true} if this pool has been shut down.                
                <return>
                    {@code true} if this pool has been shut down                    
                </return>
            </javadoc>
            <method name="isShutdown" type="boolean" line="1393"/>
            <javadoc line="1396">
                Blocks until all tasks have completed execution after a shutdown
                  request, or the timeout occurs, or the current thread is
                  interrupted, whichever happens first.                
                <param>
                    timeout the maximum time to wait                    
                </param>
                <param>
                    unit the time unit of the timeout argument                    
                </param>
                <return>
                    {@code true} if this executor terminated and{@code false} if the timeout elapsed before termination                    
                </return>
                <throws>
                    InterruptedException if interrupted while waiting                    
                </throws>
            </javadoc>
            <method name="awaitTermination" type="boolean" line="1405">
                <params>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="nanos" type="long" line="1406"/>
                <declaration name="lock" type="ReentrantLock" line="1407"/>
                <scope line="1409">
                    <scope line="1410"/>
                </scope>
                <scope line="1416"/>
            </method>
            <interface name="ManagedBlocker">
                <javadoc line="1420">
                    Interface for extending managed parallelism for tasks running
                      in {@link ForkJoinPool}s.
                      &lt;p&gt;A {@code ManagedBlocker} provides two methods.  Method{@code isReleasable} must return {@code true} if blocking is
                      not necessary. Method {@code block} blocks the current thread
                      if necessary (perhaps internally invoking {@code isReleasable}before actually blocking). These actions are performed by any
                      thread invoking {@link ForkJoinPool#managedBlock}.  The
                      unusual methods in this API accommodate synchronizers that may,
                      but don&apos;t usually, block for long periods. Similarly, they
                      allow more efficient internal handling of cases in which
                      additional workers may be, but usually are not, needed to
                      ensure sufficient parallelism.  Toward this end,
                      implementations of method {@code isReleasable} must be amenable
                      to repeated invocation.
                      &lt;p&gt;For example, here is a ManagedBlocker based on a
                      ReentrantLock:
                      &lt;pre&gt; {@code}class ManagedLocker implements ManagedBlocker 
                      final ReentrantLock lock;
                      boolean hasLock = false;
                      ManagedLocker(ReentrantLock lock) { this.lock = lock; }
                      public boolean block() {
                      if (!hasLock)
                      lock.lock();
                      return true;
                      }
                      public boolean isReleasable() {
                      return hasLock || (hasLock = lock.tryLock());
                      }
                      }}&lt;/pre&gt;
                      &lt;p&gt;Here is a class that possibly blocks waiting for an
                      item on a given queue:
                      &lt;pre&gt; {@code}class QueueTaker&lt;E&gt; implements ManagedBlocker 
                      final BlockingQueue&lt;E&gt; queue;
                      volatile E item = null;
                      QueueTaker(BlockingQueue&lt;E&gt; q) { this.queue = q; }
                      public boolean block() throws InterruptedException {
                      if (item == null)
                      item = queue.take();
                      return true;
                      }
                      public boolean isReleasable() {
                      return item != null || (item = queue.poll()) != null;
                      }
                      public E getItem() { // call after pool.managedBlock completes
                      return item;
                      }
                      }}&lt;/pre&gt;                    
                </javadoc>
                <method name="block" type="boolean" line="1469"/>
                <javadoc line="1469">
                    Possibly blocks the current thread, for example waiting for
                      a lock or condition.                    
                    <return>
                        {@code true} if no additional blocking is necessary
                          (i.e., if isReleasable would return true)                        
                    </return>
                    <throws>
                        InterruptedException if interrupted while waiting
                          (the method is not required to do so, but is allowed to)                        
                    </throws>
                </javadoc>
                <method name="isReleasable" type="boolean" line="1478"/>
                <javadoc line="1478">
                    Returns {@code true} if blocking is unnecessary.                    
                </javadoc>
            </interface>
            <javadoc line="1483">
                Blocks in accord with the given blocker.  If the current thread
                  is a {@link ForkJoinWorkerThread}, this method possibly
                  arranges for a spare thread to be activated if necessary to
                  ensure sufficient parallelism while the current thread is blocked.
                  &lt;p&gt;If the caller is not a {@link ForkJoinTask}, this method is
                  behaviorally equivalent to
                  &lt;pre&gt; {@codewhile (!blocker.isReleasable())
                  if (blocker.block())
                  return;}&lt;/pre&gt;
                  If the caller is a {@code ForkJoinTask}, then the pool may
                  first be expanded to ensure parallelism, and later adjusted.                
                <param>
                    blocker the blocker                    
                </param>
                <throws>
                    InterruptedException if blocker.block did so                    
                </throws>
            </javadoc>
            <method name="managedBlock" type="void" line="1498">
                <params>
                    <param name="blocker" type="ManagedBlocker"/>
                </params>
                <declaration name="t" type="Thread" line="1499"/>
                <scope line="1500">
                    <declaration name="w" type="ForkJoinWorkerThread" line="1501"/>
                </scope>
                <scope line="1504">
                    <scope line="1505"/>
                </scope>
            </method>
            <method name="newTaskFor" type="RunnableFuture<T>" line="1510">
                <params>
                    <param name="runnable" type="Runnable"/>
                    <param name="value" type="T"/>
                </params>
            </method>
            <method name="newTaskFor" type="RunnableFuture<T>" line="1513">
                <params>
                    <param name="callable" type="Callable<T>"/>
                </params>
            </method>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="1516"/>
            <declaration name="ctlOffset" type="long" line="1517"/>
            <declaration name="stealCountOffset" type="long" line="1518"/>
            <declaration name="blockedCountOffset" type="long" line="1519"/>
            <declaration name="quiescerCountOffset" type="long" line="1520"/>
            <declaration name="scanGuardOffset" type="long" line="1521"/>
            <declaration name="nextWorkerNumberOffset" type="long" line="1522"/>
            <declaration name="ABASE" type="long" line="1523"/>
            <declaration name="ASHIFT" type="int" line="1524"/>
            <scope line="1525">
                <declaration name="s" type="int" line="1530"/>
                <scope line="1531">
                    <declaration name="k" type="Class" line="1533"/>
                    <declaration name="a" type="Class" line="1540"/>
                </scope>
                <scope line="1544"/>
            </scope>
        </class>
    </source>