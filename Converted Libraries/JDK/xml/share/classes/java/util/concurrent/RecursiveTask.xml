<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <class name="RecursiveTask" line="2">
            <type_params>
                <type_param name="V"/>
            </type_params>
            <extends class="ForkJoinTask">
                <type_params>
                    <type_param name="V"/>
                </type_params>
            </extends>
            <javadoc line="2">
                A recursive result-bearing {@link ForkJoinTask}.
                  &lt;p&gt;For a classic example, here is a task computing Fibonacci numbers:
                  &lt;pre&gt; {@code}class Fibonacci extends RecursiveTask&lt;Integer&gt; 
                  final int n;
                  Fibonacci(int n) { this.n = n; }
                  Integer compute() {
                  if (n &lt;= 1)
                  return n;
                  Fibonacci f1 = new Fibonacci(n - 1);
                  f1.fork();
                  Fibonacci f2 = new Fibonacci(n - 2);
                  return f2.compute() + f1.join();
                  }
                  }}&lt;/pre&gt;
                  However, besides being a dumb way to compute Fibonacci functions
                  (there is a simple fast linear algorithm that you&apos;d use in
                  practice), this is likely to perform poorly because the smallest
                  subtasks are too small to be worthwhile splitting up. Instead, as
                  is the case for nearly all fork/join applications, you&apos;d pick some
                  minimum granularity size (for example 10 here) for which you always
                  sequentially solve rather than subdividing.                
                <since>
                    1.7                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="28"/>
            <declaration name="result" type="V" line="29"/>
            <javadoc line="29">
                The result of the computation.                
            </javadoc>
            <method name="compute" type="V" line="33"/>
            <javadoc line="33">
                The main computation performed by this task.                
            </javadoc>
            <method name="getRawResult" type="V" line="37"/>
            <method name="setRawResult" type="void" line="40">
                <params>
                    <param name="value" type="V"/>
                </params>
            </method>
            <javadoc line="43">
                Implements execution conventions for RecursiveTask.                
            </javadoc>
            <method name="exec" type="boolean" line="46"/>
        </class>
    </source>