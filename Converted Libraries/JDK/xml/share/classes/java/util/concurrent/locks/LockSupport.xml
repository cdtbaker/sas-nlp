<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent.locks">
        <import package="java.util.concurrent"/>
        <import package="sun.misc.Unsafe"/>
        <class name="LockSupport" line="4">
            <javadoc line="4">
                Basic thread blocking primitives for creating locks and other
                  synchronization classes.
                  &lt;p&gt;This class associates, with each thread that uses it, a permit
                  (in the sense of the {@link java.util.concurrent.SemaphoreSemaphore} class). A call to {@code park} will return immediately
                  if the permit is available, consuming it in the process; otherwise
                  it &lt;em&gt;may&lt;/em&gt; block.  A call to {@code unpark} makes the permit
                  available, if it was not already available. (Unlike with Semaphores
                  though, permits do not accumulate. There is at most one.)
                  &lt;p&gt;Methods {@code park} and {@code unpark} provide efficient
                  means of blocking and unblocking threads that do not encounter the
                  problems that cause the deprecated methods {@code Thread.suspend}and {@code Thread.resume} to be unusable for such purposes: Races
                  between one thread invoking {@code park} and another thread trying
                  to {@code unpark} it will preserve liveness, due to the
                  permit. Additionally, {@code park} will return if the caller&apos;s
                  thread was interrupted, and timeout versions are supported. The{@code park} method may also return at any other time, for &quot;no
                  reason&quot;, so in general must be invoked within a loop that rechecks
                  conditions upon return. In this sense {@code park} serves as an
                  optimization of a &quot;busy wait&quot; that does not waste as much time
                  spinning, but must be paired with an {@code unpark} to be
                  effective.
                  &lt;p&gt;The three forms of {@code park} each also support a{@code blocker} object parameter. This object is recorded while
                  the thread is blocked to permit monitoring and diagnostic tools to
                  identify the reasons that threads are blocked. (Such tools may
                  access blockers using method {@link #getBlocker}.) The use of these
                  forms rather than the original forms without this parameter is
                  strongly encouraged. The normal argument to supply as a{@code blocker} within a lock implementation is {@code this}.
                  &lt;p&gt;These methods are designed to be used as tools for creating
                  higher-level synchronization utilities, and are not in themselves
                  useful for most concurrency control applications.  The {@code park}method is designed for use only in constructions of the form:
                  &lt;pre&gt;while (!canProceed()) { ... LockSupport.park(this); }&lt;/pre&gt;
                  where neither {@code canProceed} nor any other actions prior to the
                  call to {@code park} entail locking or blocking.  Because only one
                  permit is associated with each thread, any intermediary uses of{@code park} could interfere with its intended effects.
                  &lt;p&gt;&lt;b&gt;Sample Usage.&lt;/b&gt; Here is a sketch of a first-in-first-out
                  non-reentrant lock class:
                  &lt;pre&gt;{@code}class FIFOMutex 
                  private final AtomicBoolean locked = new AtomicBoolean(false);
                  private final Queue&lt;Thread&gt; waiters
                  = new ConcurrentLinkedQueue&lt;Thread&gt;();
                  public void lock() {
                  boolean wasInterrupted = false;
                  Thread current = Thread.currentThread();
                  waiters.add(current);
                  // Block while not first in queue or cannot acquire lock
                  while (waiters.peek() != current ||
                  !locked.compareAndSet(false, true)) {
                  LockSupport.park(this);
                  if (Thread.interrupted()) // ignore interrupts while waiting
                  wasInterrupted = true;
                  }
                  waiters.remove();
                  if (wasInterrupted)          // reassert interrupt status on exit
                  current.interrupt();
                  }
                  public void unlock() {
                  locked.set(false);
                  LockSupport.unpark(waiters.peek());
                  }
                  }}&lt;/pre&gt;                
            </javadoc>
            <method name="LockSupport" type="constructor" line="66"/>
            <declaration name="unsafe" type="Unsafe" line="68"/>
            <declaration name="parkBlockerOffset" type="long" line="69"/>
            <scope line="70">
                <scope line="71"/>
                <scope line="74"/>
            </scope>
            <method name="setBlocker" type="void" line="78">
                <params>
                    <param name="t" type="Thread"/>
                    <param name="arg" type="Object"/>
                </params>
            </method>
            <javadoc line="81">
                Makes available the permit for the given thread, if it
                  was not already available.  If the thread was blocked on{@code park} then it will unblock.  Otherwise, its next call
                  to {@code park} is guaranteed not to block. This operation
                  is not guaranteed to have any effect at all if the given
                  thread has not been started.                
                <param>
                    thread the thread to unpark, or {@code null}, in which case
                      this operation has no effect                    
                </param>
            </javadoc>
            <method name="unpark" type="void" line="90">
                <params>
                    <param name="thread" type="Thread"/>
                </params>
            </method>
            <javadoc line="93">
                Disables the current thread for thread scheduling purposes unless the
                  permit is available.
                  &lt;p&gt;If the permit is available then it is consumed and the call returns
                  immediately; otherwise
                  the current thread becomes disabled for thread scheduling
                  purposes and lies dormant until one of three things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes {@link #unpark unpark} with the
                  current thread as the target; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread; or
                  &lt;li&gt;The call spuriously (that is, for no reason) returns.
                  &lt;/ul&gt;
                  &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the
                  method to return. Callers should re-check the conditions which caused
                  the thread to park in the first place. Callers may also determine,
                  for example, the interrupt status of the thread upon return.                
                <param>
                    blocker the synchronization object responsible for this
                      thread parking                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="park" type="void" line="114">
                <params>
                    <param name="blocker" type="Object"/>
                </params>
                <declaration name="t" type="Thread" line="115"/>
            </method>
            <javadoc line="120">
                Disables the current thread for thread scheduling purposes, for up to
                  the specified waiting time, unless the permit is available.
                  &lt;p&gt;If the permit is available then it is consumed and the call
                  returns immediately; otherwise the current thread becomes disabled
                  for thread scheduling purposes and lies dormant until one of four
                  things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes {@link #unpark unpark} with the
                  current thread as the target; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread; or
                  &lt;li&gt;The specified waiting time elapses; or
                  &lt;li&gt;The call spuriously (that is, for no reason) returns.
                  &lt;/ul&gt;
                  &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the
                  method to return. Callers should re-check the conditions which caused
                  the thread to park in the first place. Callers may also determine,
                  for example, the interrupt status of the thread, or the elapsed time
                  upon return.                
                <param>
                    blocker the synchronization object responsible for this
                      thread parking                    
                </param>
                <param>
                    nanos the maximum number of nanoseconds to wait                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="parkNanos" type="void" line="144">
                <params>
                    <param name="blocker" type="Object"/>
                    <param name="nanos" type="long"/>
                </params>
                <scope line="145">
                    <declaration name="t" type="Thread" line="146"/>
                </scope>
            </method>
            <javadoc line="152">
                Disables the current thread for thread scheduling purposes, until
                  the specified deadline, unless the permit is available.
                  &lt;p&gt;If the permit is available then it is consumed and the call
                  returns immediately; otherwise the current thread becomes disabled
                  for thread scheduling purposes and lies dormant until one of four
                  things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes {@link #unpark unpark} with the
                  current thread as the target; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} the
                  current thread; or
                  &lt;li&gt;The specified deadline passes; or
                  &lt;li&gt;The call spuriously (that is, for no reason) returns.
                  &lt;/ul&gt;
                  &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the
                  method to return. Callers should re-check the conditions which caused
                  the thread to park in the first place. Callers may also determine,
                  for example, the interrupt status of the thread, or the current time
                  upon return.                
                <param>
                    blocker the synchronization object responsible for this
                      thread parking                    
                </param>
                <param>
                    deadline the absolute time, in milliseconds from the Epoch,
                      to wait until                    
                </param>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="parkUntil" type="void" line="178">
                <params>
                    <param name="blocker" type="Object"/>
                    <param name="deadline" type="long"/>
                </params>
                <declaration name="t" type="Thread" line="179"/>
            </method>
            <javadoc line="184">
                Returns the blocker object supplied to the most recent
                  invocation of a park method that has not yet unblocked, or null
                  if not blocked.  The value returned is just a momentary
                  snapshot -- the thread may have since unblocked or blocked on a
                  different blocker object.                
                <param>
                    t the thread                    
                </param>
                <return>
                    the blocker                    
                </return>
                <throws>
                    NullPointerException if argument is null                    
                </throws>
                <since>
                    1.6                    
                </since>
            </javadoc>
            <method name="getBlocker" type="Object" line="195">
                <params>
                    <param name="t" type="Thread"/>
                </params>
            </method>
            <javadoc line="199">
                Disables the current thread for thread scheduling purposes unless the
                  permit is available.
                  &lt;p&gt;If the permit is available then it is consumed and the call
                  returns immediately; otherwise the current thread becomes disabled
                  for thread scheduling purposes and lies dormant until one of three
                  things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes {@link #unpark unpark} with the
                  current thread as the target; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread; or
                  &lt;li&gt;The call spuriously (that is, for no reason) returns.
                  &lt;/ul&gt;
                  &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the
                  method to return. Callers should re-check the conditions which caused
                  the thread to park in the first place. Callers may also determine,
                  for example, the interrupt status of the thread upon return.                
            </javadoc>
            <method name="park" type="void" line="217"/>
            <javadoc line="220">
                Disables the current thread for thread scheduling purposes, for up to
                  the specified waiting time, unless the permit is available.
                  &lt;p&gt;If the permit is available then it is consumed and the call
                  returns immediately; otherwise the current thread becomes disabled
                  for thread scheduling purposes and lies dormant until one of four
                  things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes {@link #unpark unpark} with the
                  current thread as the target; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread; or
                  &lt;li&gt;The specified waiting time elapses; or
                  &lt;li&gt;The call spuriously (that is, for no reason) returns.
                  &lt;/ul&gt;
                  &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the
                  method to return. Callers should re-check the conditions which caused
                  the thread to park in the first place. Callers may also determine,
                  for example, the interrupt status of the thread, or the elapsed time
                  upon return.                
                <param>
                    nanos the maximum number of nanoseconds to wait                    
                </param>
            </javadoc>
            <method name="parkNanos" type="void" line="241">
                <params>
                    <param name="nanos" type="long"/>
                </params>
            </method>
            <javadoc line="244">
                Disables the current thread for thread scheduling purposes, until
                  the specified deadline, unless the permit is available.
                  &lt;p&gt;If the permit is available then it is consumed and the call
                  returns immediately; otherwise the current thread becomes disabled
                  for thread scheduling purposes and lies dormant until one of four
                  things happens:
                  &lt;ul&gt;
                  &lt;li&gt;Some other thread invokes {@link #unpark unpark} with the
                  current thread as the target; or
                  &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}the current thread; or
                  &lt;li&gt;The specified deadline passes; or
                  &lt;li&gt;The call spuriously (that is, for no reason) returns.
                  &lt;/ul&gt;
                  &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the
                  method to return. Callers should re-check the conditions which caused
                  the thread to park in the first place. Callers may also determine,
                  for example, the interrupt status of the thread, or the current time
                  upon return.                
                <param>
                    deadline the absolute time, in milliseconds from the Epoch,
                      to wait until                    
                </param>
            </javadoc>
            <method name="parkUntil" type="void" line="266">
                <params>
                    <param name="deadline" type="long"/>
                </params>
            </method>
        </class>
    </source>