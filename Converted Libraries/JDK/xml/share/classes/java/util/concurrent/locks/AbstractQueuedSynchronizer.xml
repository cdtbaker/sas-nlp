<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent.locks">
        <import package="java.util"/>
        <import package="java.util.concurrent"/>
        <import package="java.util.concurrent.atomic"/>
        <import package="sun.misc.Unsafe"/>
        <class name="AbstractQueuedSynchronizer" line="6">
            <extends class="AbstractOwnableSynchronizer"/>
            <implements interface="java.io.Serializable"/>
            <javadoc line="6">
                Provides a framework for implementing blocking locks and related
                  synchronizers (semaphores, events, etc) that rely on
                  first-in-first-out (FIFO) wait queues.  This class is designed to
                  be a useful basis for most kinds of synchronizers that rely on a
                  single atomic &lt;tt&gt;int&lt;/tt&gt; value to represent state. Subclasses
                  must define the protected methods that change this state, and which
                  define what that state means in terms of this object being acquired
                  or released.  Given these, the other methods in this class carry
                  out all queuing and blocking mechanics. Subclasses can maintain
                  other state fields, but only the atomically updated &lt;tt&gt;int&lt;/tt&gt;
                  value manipulated using methods {@link #getState}, {@link #setState} and {@link #compareAndSetState} is tracked with respect
                  to synchronization.
                  &lt;p&gt;Subclasses should be defined as non-public internal helper
                  classes that are used to implement the synchronization properties
                  of their enclosing class.  Class
                  &lt;tt&gt;AbstractQueuedSynchronizer&lt;/tt&gt; does not implement any
                  synchronization interface.  Instead it defines methods such as{@link #acquireInterruptibly} that can be invoked as
                  appropriate by concrete locks and related synchronizers to
                  implement their public methods.
                  &lt;p&gt;This class supports either or both a default &lt;em&gt;exclusive&lt;/em&gt;
                  mode and a &lt;em&gt;shared&lt;/em&gt; mode. When acquired in exclusive mode,
                  attempted acquires by other threads cannot succeed. Shared mode
                  acquires by multiple threads may (but need not) succeed. This class
                  does not &amp;quot;understand&amp;quot; these differences except in the
                  mechanical sense that when a shared mode acquire succeeds, the next
                  waiting thread (if one exists) must also determine whether it can
                  acquire as well. Threads waiting in the different modes share the
                  same FIFO queue. Usually, implementation subclasses support only
                  one of these modes, but both can come into play for example in a{@link ReadWriteLock}. Subclasses that support only exclusive or
                  only shared modes need not define the methods supporting the unused mode.
                  &lt;p&gt;This class defines a nested {@link ConditionObject} class that
                  can be used as a {@link Condition} implementation by subclasses
                  supporting exclusive mode for which method {@link #isHeldExclusively} reports whether synchronization is exclusively
                  held with respect to the current thread, method {@link #release}invoked with the current {@link #getState} value fully releases
                  this object, and {@link #acquire}, given this saved state value,
                  eventually restores this object to its previous acquired state.  No
                  &lt;tt&gt;AbstractQueuedSynchronizer&lt;/tt&gt; method otherwise creates such a
                  condition, so if this constraint cannot be met, do not use it.  The
                  behavior of {@link ConditionObject} depends of course on the
                  semantics of its synchronizer implementation.
                  &lt;p&gt;This class provides inspection, instrumentation, and monitoring
                  methods for the internal queue, as well as similar methods for
                  condition objects. These can be exported as desired into classes
                  using an &lt;tt&gt;AbstractQueuedSynchronizer&lt;/tt&gt; for their
                  synchronization mechanics.
                  &lt;p&gt;Serialization of this class stores only the underlying atomic
                  integer maintaining state, so deserialized objects have empty
                  thread queues. Typical subclasses requiring serializability will
                  define a &lt;tt&gt;readObject&lt;/tt&gt; method that restores this to a known
                  initial state upon deserialization.
                  &lt;h3&gt;Usage&lt;/h3&gt;
                  &lt;p&gt;To use this class as the basis of a synchronizer, redefine the
                  following methods, as applicable, by inspecting and/or modifying
                  the synchronization state using {@link #getState}, {@link #setState} and/or {@link #compareAndSetState}:
                  &lt;ul&gt;
                  &lt;li&gt; {@link #tryAcquire}&lt;li&gt; {@link #tryRelease}&lt;li&gt; {@link #tryAcquireShared}&lt;li&gt; {@link #tryReleaseShared}&lt;li&gt; {@link #isHeldExclusively}&lt;/ul&gt;
                  Each of these methods by default throws {@link UnsupportedOperationException}.  Implementations of these methods
                  must be internally thread-safe, and should in general be short and
                  not block. Defining these methods is the &lt;em&gt;only&lt;/em&gt; supported
                  means of using this class. All other methods are declared
                  &lt;tt&gt;final&lt;/tt&gt; because they cannot be independently varied.
                  &lt;p&gt;You may also find the inherited methods from {@link AbstractOwnableSynchronizer} useful to keep track of the thread
                  owning an exclusive synchronizer.  You are encouraged to use them
                  -- this enables monitoring and diagnostic tools to assist users in
                  determining which threads hold locks.
                  &lt;p&gt;Even though this class is based on an internal FIFO queue, it
                  does not automatically enforce FIFO acquisition policies.  The core
                  of exclusive synchronization takes the form:
                  &lt;pre&gt;
                  Acquire:
                  while (!tryAcquire(arg)) {
                  &lt;em&gt;enqueue thread if it is not already queued&lt;/em&gt;;
                  &lt;em&gt;possibly block current thread&lt;/em&gt;;
                  }
                  Release:
                  if (tryRelease(arg))
                  &lt;em&gt;unblock the first queued thread&lt;/em&gt;;
                  &lt;/pre&gt;
                  (Shared mode is similar but may involve cascading signals.)
                  &lt;p&gt;&lt;a name=&quot;barging&quot;&gt;Because checks in acquire are invoked before
                  enqueuing, a newly acquiring thread may &lt;em&gt;barge&lt;/em&gt; ahead of
                  others that are blocked and queued.  However, you can, if desired,
                  define &lt;tt&gt;tryAcquire&lt;/tt&gt; and/or &lt;tt&gt;tryAcquireShared&lt;/tt&gt; to
                  disable barging by internally invoking one or more of the inspection
                  methods, thereby providing a &lt;em&gt;fair&lt;/em&gt; FIFO acquisition order.
                  In particular, most fair synchronizers can define &lt;tt&gt;tryAcquire&lt;/tt&gt;
                  to return &lt;tt&gt;false&lt;/tt&gt; if {@link #hasQueuedPredecessors} (a method
                  specifically designed to be used by fair synchronizers) returns
                  &lt;tt&gt;true&lt;/tt&gt;.  Other variations are possible.
                  &lt;p&gt;Throughput and scalability are generally highest for the
                  default barging (also known as &lt;em&gt;greedy&lt;/em&gt;,
                  &lt;em&gt;renouncement&lt;/em&gt;, and &lt;em&gt;convoy-avoidance&lt;/em&gt;) strategy.
                  While this is not guaranteed to be fair or starvation-free, earlier
                  queued threads are allowed to recontend before later queued
                  threads, and each recontention has an unbiased chance to succeed
                  against incoming threads.  Also, while acquires do not
                  &amp;quot;spin&amp;quot; in the usual sense, they may perform multiple
                  invocations of &lt;tt&gt;tryAcquire&lt;/tt&gt; interspersed with other
                  computations before blocking.  This gives most of the benefits of
                  spins when exclusive synchronization is only briefly held, without
                  most of the liabilities when it isn&apos;t. If so desired, you can
                  augment this by preceding calls to acquire methods with
                  &quot;fast-path&quot; checks, possibly prechecking {@link #hasContended}and/or {@link #hasQueuedThreads} to only do so if the synchronizer
                  is likely not to be contended.
                  &lt;p&gt;This class provides an efficient and scalable basis for
                  synchronization in part by specializing its range of use to
                  synchronizers that can rely on &lt;tt&gt;int&lt;/tt&gt; state, acquire, and
                  release parameters, and an internal FIFO wait queue. When this does
                  not suffice, you can build synchronizers from a lower level using{@link java.util.concurrent.atomic atomic} classes, your own custom{@link java.util.Queue} classes, and {@link LockSupport} blocking
                  support.
                  &lt;h3&gt;Usage Examples&lt;/h3&gt;
                  &lt;p&gt;Here is a non-reentrant mutual exclusion lock class that uses
                  the value zero to represent the unlocked state, and one to
                  represent the locked state. While a non-reentrant lock
                  does not strictly require recording of the current owner
                  thread, this class does so anyway to make usage easier to monitor.
                  It also supports conditions and exposes
                  one of the instrumentation methods:
                  &lt;pre&gt;
                  class Mutex implements Lock, java.io.Serializable {
                  // Our internal helper class
                  private static class Sync extends AbstractQueuedSynchronizer {
                  // Report whether in locked state
                  protected boolean isHeldExclusively() {
                  return getState() == 1;
                  }
                  // Acquire the lock if state is zero
                  public boolean tryAcquire(int acquires) {
                  assert acquires == 1; // Otherwise unused
                  if (compareAndSetState(0, 1)) {
                  setExclusiveOwnerThread(Thread.currentThread());
                  return true;
                  }
                  return false;
                  }
                  // Release the lock by setting state to zero
                  protected boolean tryRelease(int releases) {
                  assert releases == 1; // Otherwise unused
                  if (getState() == 0) throw new IllegalMonitorStateException();
                  setExclusiveOwnerThread(null);
                  setState(0);
                  return true;
                  }
                  // Provide a Condition
                  Condition newCondition() { return new ConditionObject(); }
                  // Deserialize properly
                  private void readObject(ObjectInputStream s)
                  throws IOException, ClassNotFoundException {
                  s.defaultReadObject();
                  setState(0); // reset to unlocked state
                  }
                  }
                  // The sync object does all the hard work. We just forward to it.
                  private final Sync sync = new Sync();
                  public void lock()                { sync.acquire(1); }
                  public boolean tryLock()          { return sync.tryAcquire(1); }
                  public void unlock()              { sync.release(1); }
                  public Condition newCondition()   { return sync.newCondition(); }
                  public boolean isLocked()         { return sync.isHeldExclusively(); }
                  public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
                  public void lockInterruptibly() throws InterruptedException {
                  sync.acquireInterruptibly(1);
                  }
                  public boolean tryLock(long timeout, TimeUnit unit)
                  throws InterruptedException {
                  return sync.tryAcquireNanos(1, unit.toNanos(timeout));
                  }
                  }
                  &lt;/pre&gt;
                  &lt;p&gt;Here is a latch class that is like a {@link CountDownLatch}except that it only requires a single &lt;tt&gt;signal&lt;/tt&gt; to
                  fire. Because a latch is non-exclusive, it uses the &lt;tt&gt;shared&lt;/tt&gt;
                  acquire and release methods.
                  &lt;pre&gt;
                  class BooleanLatch {
                  private static class Sync extends AbstractQueuedSynchronizer {
                  boolean isSignalled() { return getState() != 0; }
                  protected int tryAcquireShared(int ignore) {
                  return isSignalled() ? 1 : -1;
                  }
                  protected boolean tryReleaseShared(int ignore) {
                  setState(1);
                  return true;
                  }
                  }
                  private final Sync sync = new Sync();
                  public boolean isSignalled() { return sync.isSignalled(); }
                  public void signal()         { sync.releaseShared(1); }
                  public void await() throws InterruptedException {
                  sync.acquireSharedInterruptibly(1);
                  }
                  }
                  &lt;/pre&gt;                
                <since>
                    1.5                    
                </since>
                <author>
                    Doug Lea                    
                </author>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="203"/>
            <javadoc line="204">
                Creates a new &lt;tt&gt;AbstractQueuedSynchronizer&lt;/tt&gt; instance
                  with initial synchronization state of zero.                
            </javadoc>
            <method name="AbstractQueuedSynchronizer" type="constructor" line="208"/>
            <class name="Node" line="210">
                <javadoc line="210">
                    Wait queue node class.
                      &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and
                      Hagersten) lock queue. CLH locks are normally used for
                      spinlocks.  We instead use them for blocking synchronizers, but
                      use the same basic tactic of holding some of the control
                      information about a thread in the predecessor of its node.  A
                      &quot;status&quot; field in each node keeps track of whether a thread
                      should block.  A node is signalled when its predecessor
                      releases.  Each node of the queue otherwise serves as a
                      specific-notification-style monitor holding a single waiting
                      thread. The status field does NOT control whether threads are
                      granted locks etc though.  A thread may try to acquire if it is
                      first in the queue. But being first does not guarantee success;
                      it only gives the right to contend.  So the currently released
                      contender thread may need to rewait.
                      &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new
                      tail. To dequeue, you just set the head field.
                      &lt;pre&gt;
                      +------+  prev +-----+       +-----+
                      head |      | &lt;---- |     | &lt;---- |     |  tail
                      +------+       +-----+       +-----+
                      &lt;/pre&gt;
                      &lt;p&gt;Insertion into a CLH queue requires only a single atomic
                      operation on &quot;tail&quot;, so there is a simple atomic point of
                      demarcation from unqueued to queued. Similarly, dequeing
                      involves only updating the &quot;head&quot;. However, it takes a bit
                      more work for nodes to determine who their successors are,
                      in part to deal with possible cancellation due to timeouts
                      and interrupts.
                      &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly
                      needed to handle cancellation. If a node is cancelled, its
                      successor is (normally) relinked to a non-cancelled
                      predecessor. For explanation of similar mechanics in the case
                      of spin locks, see the papers by Scott and Scherer at
                      http://www.cs.rochester.edu/u/scott/synchronization/
                      &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics.
                      The thread id for each node is kept in its own node, so a
                      predecessor signals the next node to wake up by traversing
                      next link to determine which thread it is.  Determination of
                      successor must avoid races with newly queued nodes to set
                      the &quot;next&quot; fields of their predecessors.  This is solved
                      when necessary by checking backwards from the atomically
                      updated &quot;tail&quot; when a node&apos;s successor appears to be null.
                      (Or, said differently, the next-links are an optimization
                      so that we don&apos;t usually need a backward scan.)
                      &lt;p&gt;Cancellation introduces some conservatism to the basic
                      algorithms.  Since we must poll for cancellation of other
                      nodes, we can miss noticing whether a cancelled node is
                      ahead or behind us. This is dealt with by always unparking
                      successors upon cancellation, allowing them to stabilize on
                      a new predecessor, unless we can identify an uncancelled
                      predecessor who will carry this responsibility.
                      &lt;p&gt;CLH queues need a dummy header node to get started. But
                      we don&apos;t create them on construction, because it would be wasted
                      effort if there is never contention. Instead, the node
                      is constructed and head and tail pointers are set upon first
                      contention.
                      &lt;p&gt;Threads waiting on Conditions use the same nodes, but
                      use an additional link. Conditions only need to link nodes
                      in simple (non-concurrent) linked queues because they are
                      only accessed when exclusively held.  Upon await, a node is
                      inserted into a condition queue.  Upon signal, the node is
                      transferred to the main queue.  A special value of status
                      field is used to mark which queue a node is on.
                      &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill
                      Scherer and Michael Scott, along with members of JSR-166
                      expert group, for helpful ideas, discussions, and critiques
                      on the design of this class.                    
                </javadoc>
                <declaration name="SHARED" type="Node" line="281"/>
                <javadoc line="281">
                    Marker to indicate a node is waiting in shared mode                    
                </javadoc>
                <declaration name="EXCLUSIVE" type="Node" line="285"/>
                <javadoc line="285">
                    Marker to indicate a node is waiting in exclusive mode                    
                </javadoc>
                <declaration name="CANCELLED" type="int" line="289"/>
                <javadoc line="289">
                    waitStatus value to indicate thread has cancelled                    
                </javadoc>
                <declaration name="SIGNAL" type="int" line="293"/>
                <javadoc line="293">
                    waitStatus value to indicate successor&apos;s thread needs unparking                    
                </javadoc>
                <declaration name="CONDITION" type="int" line="297"/>
                <javadoc line="297">
                    waitStatus value to indicate thread is waiting on condition                    
                </javadoc>
                <declaration name="PROPAGATE" type="int" line="301"/>
                <javadoc line="301">
                    waitStatus value to indicate the next acquireShared should
                      unconditionally propagate                    
                </javadoc>
                <declaration name="waitStatus" type="int" line="306"/>
                <javadoc line="306">
                    Status field, taking on only the values:
                      SIGNAL:     The successor of this node is (or will soon be)
                      blocked (via park), so the current node must
                      unpark its successor when it releases or
                      cancels. To avoid races, acquire methods must
                      first indicate they need a signal,
                      then retry the atomic acquire, and then,
                      on failure, block.
                      CANCELLED:  This node is cancelled due to timeout or interrupt.
                      Nodes never leave this state. In particular,
                      a thread with cancelled node never again blocks.
                      CONDITION:  This node is currently on a condition queue.
                      It will not be used as a sync queue node
                      until transferred, at which time the status
                      will be set to 0. (Use of this value here has
                      nothing to do with the other uses of the
                      field, but simplifies mechanics.)
                      PROPAGATE:  A releaseShared should be propagated to other
                      nodes. This is set (for head node only) in
                      doReleaseShared to ensure propagation
                      continues, even if other operations have
                      since intervened.
                      0:          None of the above
                      The values are arranged numerically to simplify use.
                      Non-negative values mean that a node doesn&apos;t need to
                      signal. So, most code doesn&apos;t need to check for particular
                      values, just for sign.
                      The field is initialized to 0 for normal sync nodes, and
                      CONDITION for condition nodes.  It is modified using CAS
                      (or when possible, unconditional volatile writes).                    
                </javadoc>
                <declaration name="prev" type="Node" line="339"/>
                <javadoc line="339">
                    Link to predecessor node that current node/thread relies on
                      for checking waitStatus. Assigned during enqueing, and nulled
                      out (for sake of GC) only upon dequeuing.  Also, upon
                      cancellation of a predecessor, we short-circuit while
                      finding a non-cancelled one, which will always exist
                      because the head node is never cancelled: A node becomes
                      head only as a result of successful acquire. A
                      cancelled thread never succeeds in acquiring, and a thread only
                      cancels itself, not any other node.                    
                </javadoc>
                <declaration name="next" type="Node" line="351"/>
                <javadoc line="351">
                    Link to the successor node that the current node/thread
                      unparks upon release. Assigned during enqueuing, adjusted
                      when bypassing cancelled predecessors, and nulled out (for
                      sake of GC) when dequeued.  The enq operation does not
                      assign next field of a predecessor until after attachment,
                      so seeing a null next field does not necessarily mean that
                      node is at end of queue. However, if a next field appears
                      to be null, we can scan prev&apos;s from the tail to
                      double-check.  The next field of cancelled nodes is set to
                      point to the node itself instead of null, to make life
                      easier for isOnSyncQueue.                    
                </javadoc>
                <declaration name="thread" type="Thread" line="365"/>
                <javadoc line="365">
                    The thread that enqueued this node.  Initialized on
                      construction and nulled out after use.                    
                </javadoc>
                <declaration name="nextWaiter" type="Node" line="370"/>
                <javadoc line="370">
                    Link to next node waiting on condition, or the special
                      value SHARED.  Because condition queues are accessed only
                      when holding in exclusive mode, we just need a simple
                      linked queue to hold nodes while they are waiting on
                      conditions. They are then transferred to the queue to
                      re-acquire. And because conditions can only be exclusive,
                      we save a field by using special value to indicate shared
                      mode.                    
                </javadoc>
                <javadoc line="381">
                    Returns true if node is waiting in shared mode                    
                </javadoc>
                <method name="isShared" type="boolean" line="384"/>
                <javadoc line="387">
                    Returns previous node, or throws NullPointerException if null.
                      Use when predecessor cannot be null.  The null check could
                      be elided, but is present to help the VM.                    
                    <return>
                        the predecessor of this node                        
                    </return>
                </javadoc>
                <method name="predecessor" type="Node" line="393">
                    <declaration name="p" type="Node" line="394"/>
                </method>
                <method name="Node" type="constructor" line="398"/>
                <method name="Node" type="constructor" line="400">
                    <params>
                        <param name="thread" type="Thread"/>
                        <param name="mode" type="Node"/>
                    </params>
                </method>
                <method name="Node" type="constructor" line="404">
                    <params>
                        <param name="thread" type="Thread"/>
                        <param name="waitStatus" type="int"/>
                    </params>
                </method>
            </class>
            <declaration name="head" type="Node" line="409"/>
            <javadoc line="409">
                Head of the wait queue, lazily initialized.  Except for
                  initialization, it is modified only via method setHead.  Note:
                  If head exists, its waitStatus is guaranteed not to be
                  CANCELLED.                
            </javadoc>
            <declaration name="tail" type="Node" line="416"/>
            <javadoc line="416">
                Tail of the wait queue, lazily initialized.  Modified only via
                  method enq to add new wait node.                
            </javadoc>
            <declaration name="state" type="int" line="421"/>
            <javadoc line="421">
                The synchronization state.                
            </javadoc>
            <javadoc line="425">
                Returns the current value of synchronization state.
                  This operation has memory semantics of a &lt;tt&gt;volatile&lt;/tt&gt; read.                
                <return>
                    current state value                    
                </return>
            </javadoc>
            <method name="getState" type="int" line="430"/>
            <javadoc line="433">
                Sets the value of synchronization state.
                  This operation has memory semantics of a &lt;tt&gt;volatile&lt;/tt&gt; write.                
                <param>
                    newState the new state value                    
                </param>
            </javadoc>
            <method name="setState" type="void" line="438">
                <params>
                    <param name="newState" type="int"/>
                </params>
            </method>
            <javadoc line="441">
                Atomically sets synchronization state to the given updated
                  value if the current state value equals the expected value.
                  This operation has memory semantics of a &lt;tt&gt;volatile&lt;/tt&gt; read
                  and write.                
                <param>
                    expect the expected value                    
                </param>
                <param>
                    update the new value                    
                </param>
                <return>
                    true if successful. False return indicates that the actual
                      value was not equal to the expected value.                    
                </return>
            </javadoc>
            <method name="compareAndSetState" type="boolean" line="451">
                <params>
                    <param name="expect" type="int"/>
                    <param name="update" type="int"/>
                </params>
            </method>
            <declaration name="spinForTimeoutThreshold" type="long" line="454"/>
            <javadoc line="454">
                The number of nanoseconds for which it is faster to spin
                  rather than to use timed park. A rough estimate suffices
                  to improve responsiveness with very short timeouts.                
            </javadoc>
            <javadoc line="460">
                Inserts node into queue, initializing if necessary. See picture above.                
                <param>
                    node the node to insert                    
                </param>
                <return>
                    node&apos;s predecessor                    
                </return>
            </javadoc>
            <method name="enq" type="Node" line="465">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <scope line="466">
                    <declaration name="t" type="Node" line="467"/>
                    <scope line="468"/>
                    <scope line="471">
                        <scope line="473"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="480">
                Creates and enqueues node for current thread and given mode.                
                <param>
                    mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared                    
                </param>
                <return>
                    the new node                    
                </return>
            </javadoc>
            <method name="addWaiter" type="Node" line="485">
                <params>
                    <param name="mode" type="Node"/>
                </params>
                <declaration name="node" type="Node" line="486"/>
                <declaration name="pred" type="Node" line="487"/>
                <scope line="488">
                    <scope line="490"/>
                </scope>
            </method>
            <javadoc line="498">
                Sets head of queue to be node, thus dequeuing. Called only by
                  acquire methods.  Also nulls out unused fields for sake of GC
                  and to suppress unnecessary signals and traversals.                
                <param>
                    node the node                    
                </param>
            </javadoc>
            <method name="setHead" type="void" line="504">
                <params>
                    <param name="node" type="Node"/>
                </params>
            </method>
            <javadoc line="509">
                Wakes up node&apos;s successor, if one exists.                
                <param>
                    node the node                    
                </param>
            </javadoc>
            <method name="unparkSuccessor" type="void" line="513">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="ws" type="int" line="514"/>
                <declaration name="s" type="Node" line="516"/>
                <scope line="517"/>
            </method>
            <javadoc line="523">
                Release action for shared mode -- signal successor and ensure
                  propagation. (Note: For exclusive mode, release just amounts
                  to calling unparkSuccessor of head if it needs signal.)                
            </javadoc>
            <method name="doReleaseShared" type="void" line="528">
                <scope line="529">
                    <declaration name="h" type="Node" line="530"/>
                    <scope line="531">
                        <declaration name="ws" type="int" line="532"/>
                        <scope line="533"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="542">
                Sets head of queue, and checks if successor may be waiting
                  in shared mode, if so propagating if either propagate &gt; 0 or
                  PROPAGATE status was set.                
                <param>
                    node the node                    
                </param>
                <param>
                    propagate the return value from a tryAcquireShared                    
                </param>
            </javadoc>
            <method name="setHeadAndPropagate" type="void" line="549">
                <params>
                    <param name="node" type="Node"/>
                    <param name="propagate" type="int"/>
                </params>
                <declaration name="h" type="Node" line="550"/>
                <scope line="552">
                    <declaration name="s" type="Node" line="553"/>
                </scope>
            </method>
            <javadoc line="557">
                Cancels an ongoing attempt to acquire.                
                <param>
                    node the node                    
                </param>
            </javadoc>
            <method name="cancelAcquire" type="void" line="561">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="pred" type="Node" line="564"/>
                <declaration name="predNext" type="Node" line="566"/>
                <scope line="568"/>
                <scope line="571">
                    <declaration name="ws" type="int" line="572"/>
                    <scope line="573">
                        <declaration name="next" type="Node" line="574"/>
                    </scope>
                    <scope line="577"/>
                </scope>
            </method>
            <javadoc line="583">
                Checks and updates status for a node that failed to acquire.
                  Returns true if thread should block. This is the main signal
                  control in all acquire loops.  Requires that pred == node.prev                
                <param>
                    pred node&apos;s predecessor holding status                    
                </param>
                <param>
                    node the node                    
                </param>
                <return>
                    {@code true} if thread should block                    
                </return>
            </javadoc>
            <method name="shouldParkAfterFailedAcquire" type="boolean" line="591">
                <params>
                    <param name="pred" type="Node"/>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="ws" type="int" line="592"/>
                <scope line="594">
                    <scope line="595"/>
                </scope>
                <scope line="601"/>
            </method>
            <javadoc line="606">
                Convenience method to interrupt current thread.                
            </javadoc>
            <method name="selfInterrupt" type="void" line="609"/>
            <javadoc line="612">
                Convenience method to park and then check if interrupted                
                <return>
                    {@code true} if interrupted                    
                </return>
            </javadoc>
            <method name="parkAndCheckInterrupt" type="boolean" line="616"/>
            <javadoc line="620">
                Acquires in exclusive uninterruptible mode for thread already in
                  queue. Used by condition wait methods as well as acquire.                
                <param>
                    node the node                    
                </param>
                <param>
                    arg the acquire argument                    
                </param>
                <return>
                    {@code true} if interrupted while waiting                    
                </return>
            </javadoc>
            <method name="acquireQueued" type="boolean" line="627">
                <params>
                    <param name="node" type="Node"/>
                    <param name="arg" type="int"/>
                </params>
                <declaration name="failed" type="boolean" line="628"/>
                <scope line="629">
                    <declaration name="interrupted" type="boolean" line="630"/>
                    <scope line="631">
                        <declaration name="p" type="Node" line="632"/>
                        <scope line="633"/>
                    </scope>
                </scope>
                <scope line="642"/>
            </method>
            <javadoc line="646">
                Acquires in exclusive interruptible mode.                
                <param>
                    arg the acquire argument                    
                </param>
            </javadoc>
            <method name="doAcquireInterruptibly" type="void" line="650">
                <params>
                    <param name="arg" type="int"/>
                </params>
                <declaration name="node" type="Node" line="651"/>
                <declaration name="failed" type="boolean" line="652"/>
                <scope line="653">
                    <scope line="654">
                        <declaration name="p" type="Node" line="655"/>
                        <scope line="656"/>
                    </scope>
                </scope>
                <scope line="665"/>
            </method>
            <javadoc line="669">
                Acquires in exclusive timed mode.                
                <param>
                    arg the acquire argument                    
                </param>
                <param>
                    nanosTimeout max wait time                    
                </param>
                <return>
                    {@code true} if acquired                    
                </return>
            </javadoc>
            <method name="doAcquireNanos" type="boolean" line="675">
                <params>
                    <param name="arg" type="int"/>
                    <param name="nanosTimeout" type="long"/>
                </params>
                <declaration name="lastTime" type="long" line="676"/>
                <declaration name="node" type="Node" line="677"/>
                <declaration name="failed" type="boolean" line="678"/>
                <scope line="679">
                    <scope line="680">
                        <declaration name="p" type="Node" line="681"/>
                        <scope line="682"/>
                        <declaration name="now" type="long" line="690"/>
                    </scope>
                </scope>
                <scope line="696"/>
            </method>
            <javadoc line="700">
                Acquires in shared uninterruptible mode.                
                <param>
                    arg the acquire argument                    
                </param>
            </javadoc>
            <method name="doAcquireShared" type="void" line="704">
                <params>
                    <param name="arg" type="int"/>
                </params>
                <declaration name="node" type="Node" line="705"/>
                <declaration name="failed" type="boolean" line="706"/>
                <scope line="707">
                    <declaration name="interrupted" type="boolean" line="708"/>
                    <scope line="709">
                        <declaration name="p" type="Node" line="710"/>
                        <scope line="711">
                            <declaration name="r" type="int" line="712"/>
                            <scope line="713"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="724"/>
            </method>
            <javadoc line="728">
                Acquires in shared interruptible mode.                
                <param>
                    arg the acquire argument                    
                </param>
            </javadoc>
            <method name="doAcquireSharedInterruptibly" type="void" line="732">
                <params>
                    <param name="arg" type="int"/>
                </params>
                <declaration name="node" type="Node" line="733"/>
                <declaration name="failed" type="boolean" line="734"/>
                <scope line="735">
                    <scope line="736">
                        <declaration name="p" type="Node" line="737"/>
                        <scope line="738">
                            <declaration name="r" type="int" line="739"/>
                            <scope line="740"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="750"/>
            </method>
            <javadoc line="754">
                Acquires in shared timed mode.                
                <param>
                    arg the acquire argument                    
                </param>
                <param>
                    nanosTimeout max wait time                    
                </param>
                <return>
                    {@code true} if acquired                    
                </return>
            </javadoc>
            <method name="doAcquireSharedNanos" type="boolean" line="760">
                <params>
                    <param name="arg" type="int"/>
                    <param name="nanosTimeout" type="long"/>
                </params>
                <declaration name="lastTime" type="long" line="761"/>
                <declaration name="node" type="Node" line="762"/>
                <declaration name="failed" type="boolean" line="763"/>
                <scope line="764">
                    <scope line="765">
                        <declaration name="p" type="Node" line="766"/>
                        <scope line="767">
                            <declaration name="r" type="int" line="768"/>
                            <scope line="769"/>
                        </scope>
                        <declaration name="now" type="long" line="778"/>
                    </scope>
                </scope>
                <scope line="784"/>
            </method>
            <javadoc line="788">
                Attempts to acquire in exclusive mode. This method should query
                  if the state of the object permits it to be acquired in the
                  exclusive mode, and if so to acquire it.
                  &lt;p&gt;This method is always invoked by the thread performing
                  acquire.  If this method reports failure, the acquire method
                  may queue the thread, if it is not already queued, until it is
                  signalled by a release from some other thread. This can be used
                  to implement method {@link Lock#tryLock()}.
                  &lt;p&gt;The default
                  implementation throws {@link UnsupportedOperationException}.                
                <param>
                    arg the acquire argument. This value is always the one
                      passed to an acquire method, or is the value saved on entry
                      to a condition wait.  The value is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
                <return>
                    {@code true} if successful. Upon success, this object has
                      been acquired.                    
                </return>
                <throws>
                    IllegalMonitorStateException if acquiring would place this
                      synchronizer in an illegal state. This exception must be
                      thrown in a consistent fashion for synchronization to work
                      correctly.                    
                </throws>
                <throws>
                    UnsupportedOperationException if exclusive mode is not supported                    
                </throws>
            </javadoc>
            <method name="tryAcquire" type="boolean" line="811">
                <params>
                    <param name="arg" type="int"/>
                </params>
            </method>
            <javadoc line="814">
                Attempts to set the state to reflect a release in exclusive
                  mode.
                  &lt;p&gt;This method is always invoked by the thread performing release.
                  &lt;p&gt;The default implementation throws{@link UnsupportedOperationException}.                
                <param>
                    arg the release argument. This value is always the one
                      passed to a release method, or the current state value upon
                      entry to a condition wait.  The value is otherwise
                      uninterpreted and can represent anything you like.                    
                </param>
                <return>
                    {@code true} if this object is now in a fully released
                      state, so that any waiting threads may attempt to acquire;
                      and {@code false} otherwise.                    
                </return>
                <throws>
                    IllegalMonitorStateException if releasing would place this
                      synchronizer in an illegal state. This exception must be
                      thrown in a consistent fashion for synchronization to work
                      correctly.                    
                </throws>
                <throws>
                    UnsupportedOperationException if exclusive mode is not supported                    
                </throws>
            </javadoc>
            <method name="tryRelease" type="boolean" line="832">
                <params>
                    <param name="arg" type="int"/>
                </params>
            </method>
            <javadoc line="835">
                Attempts to acquire in shared mode. This method should query if
                  the state of the object permits it to be acquired in the shared
                  mode, and if so to acquire it.
                  &lt;p&gt;This method is always invoked by the thread performing
                  acquire.  If this method reports failure, the acquire method
                  may queue the thread, if it is not already queued, until it is
                  signalled by a release from some other thread.
                  &lt;p&gt;The default implementation throws {@link UnsupportedOperationException}.                
                <param>
                    arg the acquire argument. This value is always the one
                      passed to an acquire method, or is the value saved on entry
                      to a condition wait.  The value is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
                <return>
                    a negative value on failure; zero if acquisition in shared
                      mode succeeded but no subsequent shared-mode acquire can
                      succeed; and a positive value if acquisition in shared
                      mode succeeded and subsequent shared-mode acquires might
                      also succeed, in which case a subsequent waiting thread
                      must check availability. (Support for three different
                      return values enables this method to be used in contexts
                      where acquires only sometimes act exclusively.)  Upon
                      success, this object has been acquired.                    
                </return>
                <throws>
                    IllegalMonitorStateException if acquiring would place this
                      synchronizer in an illegal state. This exception must be
                      thrown in a consistent fashion for synchronization to work
                      correctly.                    
                </throws>
                <throws>
                    UnsupportedOperationException if shared mode is not supported                    
                </throws>
            </javadoc>
            <method name="tryAcquireShared" type="int" line="863">
                <params>
                    <param name="arg" type="int"/>
                </params>
            </method>
            <javadoc line="866">
                Attempts to set the state to reflect a release in shared mode.
                  &lt;p&gt;This method is always invoked by the thread performing release.
                  &lt;p&gt;The default implementation throws{@link UnsupportedOperationException}.                
                <param>
                    arg the release argument. This value is always the one
                      passed to a release method, or the current state value upon
                      entry to a condition wait.  The value is otherwise
                      uninterpreted and can represent anything you like.                    
                </param>
                <return>
                    {@code true} if this release of shared mode may permit a
                      waiting acquire (shared or exclusive) to succeed; and{@code false} otherwise                    
                </return>
                <throws>
                    IllegalMonitorStateException if releasing would place this
                      synchronizer in an illegal state. This exception must be
                      thrown in a consistent fashion for synchronization to work
                      correctly.                    
                </throws>
                <throws>
                    UnsupportedOperationException if shared mode is not supported                    
                </throws>
            </javadoc>
            <method name="tryReleaseShared" type="boolean" line="882">
                <params>
                    <param name="arg" type="int"/>
                </params>
            </method>
            <javadoc line="885">
                Returns {@code true} if synchronization is held exclusively with
                  respect to the current (calling) thread.  This method is invoked
                  upon each call to a non-waiting {@link ConditionObject} method.
                  (Waiting methods instead invoke {@link #release}.)
                  &lt;p&gt;The default implementation throws {@link UnsupportedOperationException}. This method is invoked
                  internally only within {@link ConditionObject} methods, so need
                  not be defined if conditions are not used.                
                <return>
                    {@code true} if synchronization is held exclusively;{@code false} otherwise                    
                </return>
                <throws>
                    UnsupportedOperationException if conditions are not supported                    
                </throws>
            </javadoc>
            <method name="isHeldExclusively" type="boolean" line="896"/>
            <javadoc line="899">
                Acquires in exclusive mode, ignoring interrupts.  Implemented
                  by invoking at least once {@link #tryAcquire},
                  returning on success.  Otherwise the thread is queued, possibly
                  repeatedly blocking and unblocking, invoking {@link #tryAcquire} until success.  This method can be used
                  to implement method {@link Lock#lock}.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquire} but is otherwise uninterpreted and
                      can represent anything you like.                    
                </param>
            </javadoc>
            <method name="acquire" type="void" line="908">
                <params>
                    <param name="arg" type="int"/>
                </params>
            </method>
            <javadoc line="911">
                Acquires in exclusive mode, aborting if interrupted.
                  Implemented by first checking interrupt status, then invoking
                  at least once {@link #tryAcquire}, returning on
                  success.  Otherwise the thread is queued, possibly repeatedly
                  blocking and unblocking, invoking {@link #tryAcquire}until success or the thread is interrupted.  This method can be
                  used to implement method {@link Lock#lockInterruptibly}.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquire} but is otherwise uninterpreted and
                      can represent anything you like.                    
                </param>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="acquireInterruptibly" type="void" line="922">
                <params>
                    <param name="arg" type="int"/>
                </params>
            </method>
            <javadoc line="926">
                Attempts to acquire in exclusive mode, aborting if interrupted,
                  and failing if the given timeout elapses.  Implemented by first
                  checking interrupt status, then invoking at least once {@link #tryAcquire}, returning on success.  Otherwise, the thread is
                  queued, possibly repeatedly blocking and unblocking, invoking{@link #tryAcquire} until success or the thread is interrupted
                  or the timeout elapses.  This method can be used to implement
                  method {@link Lock#tryLock(long,TimeUnit)}.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquire} but is otherwise uninterpreted and
                      can represent anything you like.                    
                </param>
                <param>
                    nanosTimeout the maximum number of nanoseconds to wait                    
                </param>
                <return>
                    {@code true} if acquired; {@code false} if timed out                    
                </return>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="tryAcquireNanos" type="boolean" line="939">
                <params>
                    <param name="arg" type="int"/>
                    <param name="nanosTimeout" type="long"/>
                </params>
            </method>
            <javadoc line="943">
                Releases in exclusive mode.  Implemented by unblocking one or
                  more threads if {@link #tryRelease} returns true.
                  This method can be used to implement method {@link Lock#unlock}.                
                <param>
                    arg the release argument.  This value is conveyed to{@link #tryRelease} but is otherwise uninterpreted and
                      can represent anything you like.                    
                </param>
                <return>
                    the value returned from {@link #tryRelease}                    
                </return>
            </javadoc>
            <method name="release" type="boolean" line="951">
                <params>
                    <param name="arg" type="int"/>
                </params>
                <scope line="952">
                    <declaration name="h" type="Node" line="953"/>
                </scope>
            </method>
            <javadoc line="959">
                Acquires in shared mode, ignoring interrupts.  Implemented by
                  first invoking at least once {@link #tryAcquireShared},
                  returning on success.  Otherwise the thread is queued, possibly
                  repeatedly blocking and unblocking, invoking {@link #tryAcquireShared} until success.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquireShared} but is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
            </javadoc>
            <method name="acquireShared" type="void" line="967">
                <params>
                    <param name="arg" type="int"/>
                </params>
            </method>
            <javadoc line="970">
                Acquires in shared mode, aborting if interrupted.  Implemented
                  by first checking interrupt status, then invoking at least once{@link #tryAcquireShared}, returning on success.  Otherwise the
                  thread is queued, possibly repeatedly blocking and unblocking,
                  invoking {@link #tryAcquireShared} until success or the thread
                  is interrupted.                
                <param>
                    arg the acquire argument
                      This value is conveyed to {@link #tryAcquireShared} but is
                      otherwise uninterpreted and can represent anything
                      you like.                    
                </param>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="acquireSharedInterruptibly" type="void" line="982">
                <params>
                    <param name="arg" type="int"/>
                </params>
            </method>
            <javadoc line="986">
                Attempts to acquire in shared mode, aborting if interrupted, and
                  failing if the given timeout elapses.  Implemented by first
                  checking interrupt status, then invoking at least once {@link #tryAcquireShared}, returning on success.  Otherwise, the
                  thread is queued, possibly repeatedly blocking and unblocking,
                  invoking {@link #tryAcquireShared} until success or the thread
                  is interrupted or the timeout elapses.                
                <param>
                    arg the acquire argument.  This value is conveyed to{@link #tryAcquireShared} but is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
                <param>
                    nanosTimeout the maximum number of nanoseconds to wait                    
                </param>
                <return>
                    {@code true} if acquired; {@code false} if timed out                    
                </return>
                <throws>
                    InterruptedException if the current thread is interrupted                    
                </throws>
            </javadoc>
            <method name="tryAcquireSharedNanos" type="boolean" line="999">
                <params>
                    <param name="arg" type="int"/>
                    <param name="nanosTimeout" type="long"/>
                </params>
            </method>
            <javadoc line="1003">
                Releases in shared mode.  Implemented by unblocking one or more
                  threads if {@link #tryReleaseShared} returns true.                
                <param>
                    arg the release argument.  This value is conveyed to{@link #tryReleaseShared} but is otherwise uninterpreted
                      and can represent anything you like.                    
                </param>
                <return>
                    the value returned from {@link #tryReleaseShared}                    
                </return>
            </javadoc>
            <method name="releaseShared" type="boolean" line="1010">
                <params>
                    <param name="arg" type="int"/>
                </params>
                <scope line="1011"/>
            </method>
            <javadoc line="1017">
                Queries whether any threads are waiting to acquire. Note that
                  because cancellations due to interrupts and timeouts may occur
                  at any time, a {@code true} return does not guarantee that any
                  other thread will ever acquire.
                  &lt;p&gt;In this implementation, this operation returns in
                  constant time.                
                <return>
                    {@code true} if there may be other threads waiting to acquire                    
                </return>
            </javadoc>
            <method name="hasQueuedThreads" type="boolean" line="1026"/>
            <javadoc line="1029">
                Queries whether any threads have ever contended to acquire this
                  synchronizer; that is if an acquire method has ever blocked.
                  &lt;p&gt;In this implementation, this operation returns in
                  constant time.                
                <return>
                    {@code true} if there has ever been contention                    
                </return>
            </javadoc>
            <method name="hasContended" type="boolean" line="1036"/>
            <javadoc line="1039">
                Returns the first (longest-waiting) thread in the queue, or{@code null} if no threads are currently queued.
                  &lt;p&gt;In this implementation, this operation normally returns in
                  constant time, but may iterate upon contention if other threads are
                  concurrently modifying the queue.                
                <return>
                    the first (longest-waiting) thread in the queue, or{@code null} if no threads are currently queued                    
                </return>
            </javadoc>
            <method name="getFirstQueuedThread" type="Thread" line="1046"/>
            <javadoc line="1049">
                Version of getFirstQueuedThread called when fastpath fails                
            </javadoc>
            <method name="fullGetFirstQueuedThread" type="Thread" line="1052">
                <declaration name="h" type="Node" line="1053"/>
                <declaration name="st" type="Thread" line="1054"/>
                <declaration name="t" type="Node" line="1056"/>
                <declaration name="firstThread" type="Thread" line="1057"/>
                <scope line="1058">
                    <declaration name="tt" type="Thread" line="1059"/>
                </scope>
            </method>
            <javadoc line="1065">
                Returns true if the given thread is currently queued.
                  &lt;p&gt;This implementation traverses the queue to determine
                  presence of the given thread.                
                <param>
                    thread the thread                    
                </param>
                <return>
                    {@code true} if the given thread is on the queue                    
                </return>
                <throws>
                    NullPointerException if the thread is null                    
                </throws>
            </javadoc>
            <method name="isQueued" type="boolean" line="1073">
                <params>
                    <param name="thread" type="Thread"/>
                </params>
            </method>
            <javadoc line="1078">
                Returns {@code true} if the apparent first queued thread, if one
                  exists, is waiting in exclusive mode.  If this method returns{@code true}, and the current thread is attempting to acquire in
                  shared mode (that is, this method is invoked from {@link #tryAcquireShared}) then it is guaranteed that the current thread
                  is not the first queued thread.  Used only as a heuristic in
                  ReentrantReadWriteLock.                
            </javadoc>
            <method name="apparentlyFirstQueuedIsExclusive" type="boolean" line="1085">
                <declaration name="h" type="Node" line="1086"/>
            </method>
            <javadoc line="1089">
                Queries whether any threads have been waiting to acquire longer
                  than the current thread.
                  &lt;p&gt;An invocation of this method is equivalent to (but may be
                  more efficient than):
                  &lt;pre&gt; 
                   Thread.currentThread() &amp;&amp;
                  hasQueuedThreads()
                  &lt;/pre&gt;
                  &lt;p&gt;Note that because cancellations due to interrupts and
                  timeouts may occur at any time, a {@code true} return does not
                  guarantee that some other thread will acquire before the current
                  thread.  Likewise, it is possible for another thread to win a
                  race to enqueue after this method has returned {@code false},
                  due to the queue being empty.
                  &lt;p&gt;This method is designed to be used by a fair synchronizer to
                  avoid &lt;a href=&quot;AbstractQueuedSynchronizer#barging&quot;&gt;barging&lt;/a&gt;.
                  Such a synchronizer&apos;s {@link #tryAcquire} method should return{@code false}, and its {@link #tryAcquireShared} method should
                  return a negative value, if this method returns {@code true}(unless this is a reentrant acquire).  For example, the {@codetryAcquire} method for a fair, reentrant, exclusive mode
                  synchronizer might look like this:
                  &lt;pre&gt; {@code}protected boolean tryAcquire(int arg) 
                  if (isHeldExclusively()) {
                  // A reentrant acquire; increment hold count
                  return true;
                  } else if (hasQueuedPredecessors()) {
                  return false;
                  } else {
                  // try to acquire normally
                  }
                  }}&lt;/pre&gt;                
                <return>
                    {@code true} if there is a queued thread preceding the
                      current thread, and {@code false} if the current thread
                      is at the head of the queue or the queue is empty                    
                </return>
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="hasQueuedPredecessors" type="boolean" line="1122">
                <declaration name="t" type="Node" line="1123"/>
                <declaration name="h" type="Node" line="1124"/>
                <declaration name="s" type="Node" line="1125"/>
            </method>
            <javadoc line="1128">
                Returns an estimate of the number of threads waiting to
                  acquire.  The value is only an estimate because the number of
                  threads may change dynamically while this method traverses
                  internal data structures.  This method is designed for use in
                  monitoring system state, not for synchronization
                  control.                
                <return>
                    the estimated number of threads waiting to acquire                    
                </return>
            </javadoc>
            <method name="getQueueLength" type="int" line="1137">
                <declaration name="n" type="int" line="1138"/>
                <scope line="1139"/>
            </method>
            <javadoc line="1144">
                Returns a collection containing threads that may be waiting to
                  acquire.  Because the actual set of threads may change
                  dynamically while constructing this result, the returned
                  collection is only a best-effort estimate.  The elements of the
                  returned collection are in no particular order.  This method is
                  designed to facilitate construction of subclasses that provide
                  more extensive monitoring facilities.                
                <return>
                    the collection of threads                    
                </return>
            </javadoc>
            <method name="getQueuedThreads" type="Collection&lt;Thread&gt;" line="1154">
                <declaration name="list" type="ArrayList&amp;lt;Thread&amp;gt;" line="1155"/>
                <scope line="1156">
                    <declaration name="t" type="Thread" line="1157"/>
                </scope>
            </method>
            <javadoc line="1162">
                Returns a collection containing threads that may be waiting to
                  acquire in exclusive mode. This has the same properties
                  as {@link #getQueuedThreads} except that it only returns
                  those threads waiting due to an exclusive acquire.                
                <return>
                    the collection of threads                    
                </return>
            </javadoc>
            <method name="getExclusiveQueuedThreads" type="Collection&lt;Thread&gt;" line="1169">
                <declaration name="list" type="ArrayList&amp;lt;Thread&amp;gt;" line="1170"/>
                <scope line="1171">
                    <scope line="1172">
                        <declaration name="t" type="Thread" line="1173"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1179">
                Returns a collection containing threads that may be waiting to
                  acquire in shared mode. This has the same properties
                  as {@link #getQueuedThreads} except that it only returns
                  those threads waiting due to a shared acquire.                
                <return>
                    the collection of threads                    
                </return>
            </javadoc>
            <method name="getSharedQueuedThreads" type="Collection&lt;Thread&gt;" line="1186">
                <declaration name="list" type="ArrayList&amp;lt;Thread&amp;gt;" line="1187"/>
                <scope line="1188">
                    <scope line="1189">
                        <declaration name="t" type="Thread" line="1190"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1196">
                Returns a string identifying this synchronizer, as well as its state.
                  The state, in brackets, includes the String {@code &quot;State =&quot;}followed by the current value of {@link #getState}, and either{@code &quot;nonempty&quot;} or {@code &quot;empty&quot;} depending on whether the
                  queue is empty.                
                <return>
                    a string identifying this synchronizer, as well as its state                    
                </return>
            </javadoc>
            <method name="toString" type="String" line="1202">
                <declaration name="s" type="int" line="1203"/>
                <declaration name="q" type="String" line="1204"/>
            </method>
            <javadoc line="1207">
                Returns true if a node, always one that was initially placed on
                  a condition queue, is now waiting to reacquire on sync queue.                
                <param>
                    node the node                    
                </param>
                <return>
                    true if is reacquiring                    
                </return>
            </javadoc>
            <method name="isOnSyncQueue" type="boolean" line="1213">
                <params>
                    <param name="node" type="Node"/>
                </params>
            </method>
            <javadoc line="1218">
                Returns true if node is on sync queue by searching backwards from tail.
                  Called only when needed by isOnSyncQueue.                
                <return>
                    true if present                    
                </return>
            </javadoc>
            <method name="findNodeFromTail" type="boolean" line="1223">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="t" type="Node" line="1224"/>
                <scope line="1225"/>
            </method>
            <javadoc line="1231">
                Transfers a node from a condition queue onto sync queue.
                  Returns true if successful.                
                <param>
                    node the node                    
                </param>
                <return>
                    true if successfully transferred (else the node was
                      cancelled before signal).                    
                </return>
            </javadoc>
            <method name="transferForSignal" type="boolean" line="1238">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="p" type="Node" line="1240"/>
                <declaration name="ws" type="int" line="1241"/>
            </method>
            <javadoc line="1245">
                Transfers node, if necessary, to sync queue after a cancelled
                  wait. Returns true if thread was cancelled before being
                  signalled.                
                <param>
                    current the waiting thread                    
                </param>
                <param>
                    node its node                    
                </param>
                <return>
                    true if cancelled before the node was signalled                    
                </return>
            </javadoc>
            <method name="transferAfterCancelledWait" type="boolean" line="1253">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <scope line="1254"/>
            </method>
            <javadoc line="1261">
                Invokes release with current state value; returns saved state.
                  Cancels node and throws exception on failure.                
                <param>
                    node the condition node for this wait                    
                </param>
                <return>
                    previous sync state                    
                </return>
            </javadoc>
            <method name="fullyRelease" type="int" line="1267">
                <params>
                    <param name="node" type="Node"/>
                </params>
                <declaration name="failed" type="boolean" line="1268"/>
                <scope line="1269">
                    <declaration name="savedState" type="int" line="1270"/>
                    <scope line="1271"/>
                    <scope line="1275"/>
                </scope>
                <scope line="1279"/>
            </method>
            <javadoc line="1283">
                Queries whether the given ConditionObject
                  uses this synchronizer as its lock.                
                <param>
                    condition the condition                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if owned                    
                </return>
                <throws>
                    NullPointerException if the condition is null                    
                </throws>
            </javadoc>
            <method name="owns" type="boolean" line="1290">
                <params>
                    <param name="condition" type="ConditionObject"/>
                </params>
            </method>
            <javadoc line="1294">
                Queries whether any threads are waiting on the given condition
                  associated with this synchronizer. Note that because timeouts
                  and interrupts may occur at any time, a &lt;tt&gt;true&lt;/tt&gt; return
                  does not guarantee that a future &lt;tt&gt;signal&lt;/tt&gt; will awaken
                  any threads.  This method is designed primarily for use in
                  monitoring of the system state.                
                <param>
                    condition the condition                    
                </param>
                <return>
                    &lt;tt&gt;true&lt;/tt&gt; if there are any waiting threads                    
                </return>
                <throws>
                    IllegalMonitorStateException if exclusive synchronization
                      is not held                    
                </throws>
                <throws>
                    IllegalArgumentException if the given condition is
                      not associated with this synchronizer                    
                </throws>
                <throws>
                    NullPointerException if the condition is null                    
                </throws>
            </javadoc>
            <method name="hasWaiters" type="boolean" line="1309">
                <params>
                    <param name="condition" type="ConditionObject"/>
                </params>
            </method>
            <javadoc line="1313">
                Returns an estimate of the number of threads waiting on the
                  given condition associated with this synchronizer. Note that
                  because timeouts and interrupts may occur at any time, the
                  estimate serves only as an upper bound on the actual number of
                  waiters.  This method is designed for use in monitoring of the
                  system state, not for synchronization control.                
                <param>
                    condition the condition                    
                </param>
                <return>
                    the estimated number of waiting threads                    
                </return>
                <throws>
                    IllegalMonitorStateException if exclusive synchronization
                      is not held                    
                </throws>
                <throws>
                    IllegalArgumentException if the given condition is
                      not associated with this synchronizer                    
                </throws>
                <throws>
                    NullPointerException if the condition is null                    
                </throws>
            </javadoc>
            <method name="getWaitQueueLength" type="int" line="1328">
                <params>
                    <param name="condition" type="ConditionObject"/>
                </params>
            </method>
            <javadoc line="1332">
                Returns a collection containing those threads that may be
                  waiting on the given condition associated with this
                  synchronizer.  Because the actual set of threads may change
                  dynamically while constructing this result, the returned
                  collection is only a best-effort estimate. The elements of the
                  returned collection are in no particular order.                
                <param>
                    condition the condition                    
                </param>
                <return>
                    the collection of threads                    
                </return>
                <throws>
                    IllegalMonitorStateException if exclusive synchronization
                      is not held                    
                </throws>
                <throws>
                    IllegalArgumentException if the given condition is
                      not associated with this synchronizer                    
                </throws>
                <throws>
                    NullPointerException if the condition is null                    
                </throws>
            </javadoc>
            <method name="getWaitingThreads" type="Collection&lt;Thread&gt;" line="1347">
                <params>
                    <param name="condition" type="ConditionObject"/>
                </params>
            </method>
            <class name="ConditionObject" line="1351">
                <implements interface="Condition"/>
                <implements interface="java.io.Serializable"/>
                <javadoc line="1351">
                    Condition implementation for a {@link AbstractQueuedSynchronizer} serving as the basis of a {@link Lock} implementation.
                      &lt;p&gt;Method documentation for this class describes mechanics,
                      not behavioral specifications from the point of view of Lock
                      and Condition users. Exported versions of this class will in
                      general need to be accompanied by documentation describing
                      condition semantics that rely on those of the associated
                      &lt;tt&gt;AbstractQueuedSynchronizer&lt;/tt&gt;.
                      &lt;p&gt;This class is Serializable, but all fields are transient,
                      so deserialized conditions have no waiters.                    
                </javadoc>
                <declaration name="serialVersionUID" type="long" line="1363"/>
                <declaration name="firstWaiter" type="Node" line="1364"/>
                <javadoc line="1364">
                    First node of condition queue.                    
                </javadoc>
                <declaration name="lastWaiter" type="Node" line="1368"/>
                <javadoc line="1368">
                    Last node of condition queue.                    
                </javadoc>
                <javadoc line="1372">
                    Creates a new &lt;tt&gt;ConditionObject&lt;/tt&gt; instance.                    
                </javadoc>
                <method name="ConditionObject" type="constructor" line="1375"/>
                <javadoc line="1377">
                    Adds a new waiter to wait queue.                    
                    <return>
                        its new wait node                        
                    </return>
                </javadoc>
                <method name="addConditionWaiter" type="Node" line="1381">
                    <declaration name="t" type="Node" line="1382"/>
                    <scope line="1383"/>
                    <declaration name="node" type="Node" line="1387"/>
                </method>
                <javadoc line="1393">
                    Removes and transfers nodes until hit non-cancelled one or
                      null. Split out from signal in part to encourage compilers
                      to inline the case of no waiters.                    
                    <param>
                        first (non-null) the first node on condition queue                        
                    </param>
                </javadoc>
                <method name="doSignal" type="void" line="1399">
                    <params>
                        <param name="first" type="Node"/>
                    </params>
                    <scope line="1400"/>
                </method>
                <javadoc line="1406">
                    Removes and transfers all nodes.                    
                    <param>
                        first (non-null) the first node on condition queue                        
                    </param>
                </javadoc>
                <method name="doSignalAll" type="void" line="1410">
                    <params>
                        <param name="first" type="Node"/>
                    </params>
                    <scope line="1412">
                        <declaration name="next" type="Node" line="1413"/>
                    </scope>
                </method>
                <javadoc line="1420">
                    Unlinks cancelled waiter nodes from condition queue.
                      Called only while holding lock. This is called when
                      cancellation occurred during condition wait, and upon
                      insertion of a new waiter when lastWaiter is seen to have
                      been cancelled. This method is needed to avoid garbage
                      retention in the absence of signals. So even though it may
                      require a full traversal, it comes into play only when
                      timeouts or cancellations occur in the absence of
                      signals. It traverses all nodes rather than stopping at a
                      particular target to unlink all pointers to garbage nodes
                      without requiring many re-traversals during cancellation
                      storms.                    
                </javadoc>
                <method name="unlinkCancelledWaiters" type="void" line="1434">
                    <declaration name="t" type="Node" line="1435"/>
                    <declaration name="trail" type="Node" line="1436"/>
                    <scope line="1437">
                        <declaration name="next" type="Node" line="1438"/>
                        <scope line="1439"/>
                    </scope>
                </method>
                <javadoc line="1449">
                    Moves the longest-waiting thread, if one exists, from the
                      wait queue for this condition to the wait queue for the
                      owning lock.                    
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="signal" type="void" line="1455">
                    <declaration name="first" type="Node" line="1457"/>
                </method>
                <javadoc line="1460">
                    Moves all threads from the wait queue for this condition to
                      the wait queue for the owning lock.                    
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="signalAll" type="void" line="1465">
                    <declaration name="first" type="Node" line="1467"/>
                </method>
                <javadoc line="1470">
                    Implements uninterruptible condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="awaitUninterruptibly" type="void" line="1481">
                    <declaration name="node" type="Node" line="1482"/>
                    <declaration name="savedState" type="int" line="1483"/>
                    <declaration name="interrupted" type="boolean" line="1484"/>
                    <scope line="1485"/>
                </method>
                <declaration name="REINTERRUPT" type="int" line="1491"/>
                <javadoc line="1491">
                    Mode meaning to reinterrupt on exit from wait                    
                </javadoc>
                <declaration name="THROW_IE" type="int" line="1495"/>
                <javadoc line="1495">
                    Mode meaning to throw InterruptedException on exit from wait                    
                </javadoc>
                <javadoc line="1499">
                    Checks for interrupt, returning THROW_IE if interrupted
                      before signalled, REINTERRUPT if after signalled, or
                      0 if not interrupted.                    
                </javadoc>
                <method name="checkInterruptWhileWaiting" type="int" line="1504">
                    <params>
                        <param name="node" type="Node"/>
                    </params>
                </method>
                <javadoc line="1507">
                    Throws InterruptedException, reinterrupts current thread, or
                      does nothing, depending on mode.                    
                </javadoc>
                <method name="reportInterruptAfterWait" type="void" line="1511">
                    <params>
                        <param name="interruptMode" type="int"/>
                    </params>
                </method>
                <javadoc line="1515">
                    Implements interruptible condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; If current thread is interrupted, throw InterruptedException.
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled or interrupted.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="await" type="void" line="1528">
                    <declaration name="node" type="Node" line="1530"/>
                    <declaration name="savedState" type="int" line="1531"/>
                    <declaration name="interruptMode" type="int" line="1532"/>
                    <scope line="1533"/>
                </method>
                <javadoc line="1541">
                    Implements timed condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; If current thread is interrupted, throw InterruptedException.
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled, interrupted, or timed out.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="awaitNanos" type="long" line="1554">
                    <params>
                        <param name="nanosTimeout" type="long"/>
                    </params>
                    <declaration name="node" type="Node" line="1556"/>
                    <declaration name="savedState" type="int" line="1557"/>
                    <declaration name="lastTime" type="long" line="1558"/>
                    <declaration name="interruptMode" type="int" line="1559"/>
                    <scope line="1560">
                        <scope line="1561"/>
                        <declaration name="now" type="long" line="1567"/>
                    </scope>
                </method>
                <javadoc line="1576">
                    Implements absolute timed condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; If current thread is interrupted, throw InterruptedException.
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled, interrupted, or timed out.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
                      &lt;li&gt; If timed out while blocked in step 4, return false, else true.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="awaitUntil" type="boolean" line="1590">
                    <params>
                        <param name="deadline" type="Date"/>
                    </params>
                    <declaration name="abstime" type="long" line="1592"/>
                    <declaration name="node" type="Node" line="1594"/>
                    <declaration name="savedState" type="int" line="1595"/>
                    <declaration name="timedout" type="boolean" line="1596"/>
                    <declaration name="interruptMode" type="int" line="1597"/>
                    <scope line="1598">
                        <scope line="1599"/>
                    </scope>
                </method>
                <javadoc line="1611">
                    Implements timed condition wait.
                      &lt;ol&gt;
                      &lt;li&gt; If current thread is interrupted, throw InterruptedException.
                      &lt;li&gt; Save lock state returned by {@link #getState}.
                      &lt;li&gt; Invoke {@link #release} with
                      saved state as argument, throwing
                      IllegalMonitorStateException if it fails.
                      &lt;li&gt; Block until signalled, interrupted, or timed out.
                      &lt;li&gt; Reacquire by invoking specialized version of{@link #acquire} with saved state as argument.
                      &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
                      &lt;li&gt; If timed out while blocked in step 4, return false, else true.
                      &lt;/ol&gt;                    
                </javadoc>
                <method name="await" type="boolean" line="1625">
                    <params>
                        <param name="time" type="long"/>
                        <param name="unit" type="TimeUnit"/>
                    </params>
                    <declaration name="nanosTimeout" type="long" line="1627"/>
                    <declaration name="node" type="Node" line="1629"/>
                    <declaration name="savedState" type="int" line="1630"/>
                    <declaration name="lastTime" type="long" line="1631"/>
                    <declaration name="timedout" type="boolean" line="1632"/>
                    <declaration name="interruptMode" type="int" line="1633"/>
                    <scope line="1634">
                        <scope line="1635"/>
                        <declaration name="now" type="long" line="1641"/>
                    </scope>
                </method>
                <javadoc line="1650">
                    Returns true if this condition was created by the given
                      synchronization object.                    
                    <return>
                        {@code true} if owned                        
                    </return>
                </javadoc>
                <method name="isOwnedBy" type="boolean" line="1655">
                    <params>
                        <param name="sync" type="AbstractQueuedSynchronizer"/>
                    </params>
                </method>
                <javadoc line="1658">
                    Queries whether any threads are waiting on this condition.
                      Implements {@link AbstractQueuedSynchronizer#hasWaiters}.                    
                    <return>
                        {@code true} if there are any waiting threads                        
                    </return>
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="hasWaiters" type="boolean" line="1664">
                    <scope line="1666"/>
                </method>
                <javadoc line="1671">
                    Returns an estimate of the number of threads waiting on
                      this condition.
                      Implements {@link AbstractQueuedSynchronizer#getWaitQueueLength}.                    
                    <return>
                        the estimated number of waiting threads                        
                    </return>
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="getWaitQueueLength" type="int" line="1678">
                    <declaration name="n" type="int" line="1680"/>
                    <scope line="1681"/>
                </method>
                <javadoc line="1686">
                    Returns a collection containing those threads that may be
                      waiting on this Condition.
                      Implements {@link AbstractQueuedSynchronizer#getWaitingThreads}.                    
                    <return>
                        the collection of threads                        
                    </return>
                    <throws>
                        IllegalMonitorStateException if {@link #isHeldExclusively}returns {@code false}                        
                    </throws>
                </javadoc>
                <method name="getWaitingThreads" type="Collection&lt;Thread&gt;" line="1693">
                    <declaration name="list" type="ArrayList&amp;lt;Thread&amp;gt;" line="1695"/>
                    <scope line="1696">
                        <scope line="1697">
                            <declaration name="t" type="Thread" line="1698"/>
                        </scope>
                    </scope>
                </method>
            </class>
            <declaration name="unsafe" type="Unsafe" line="1705"/>
            <javadoc line="1705">
                Setup to support compareAndSet. We need to natively implement
                  this here: For the sake of permitting future enhancements, we
                  cannot explicitly subclass AtomicInteger, which would be
                  efficient and useful otherwise. So, as the lesser of evils, we
                  natively implement using hotspot intrinsics API. And while we
                  are at it, we do the same for other CASable fields (which could
                  otherwise be done with atomic field updaters).                
            </javadoc>
            <declaration name="stateOffset" type="long" line="1715"/>
            <declaration name="headOffset" type="long" line="1716"/>
            <declaration name="tailOffset" type="long" line="1717"/>
            <declaration name="waitStatusOffset" type="long" line="1718"/>
            <declaration name="nextOffset" type="long" line="1719"/>
            <scope line="1720">
                <scope line="1721"/>
                <scope line="1728"/>
            </scope>
            <javadoc line="1732">
                CAS head field. Used only by enq.                
            </javadoc>
            <method name="compareAndSetHead" type="boolean" line="1735">
                <params>
                    <param name="update" type="Node"/>
                </params>
            </method>
            <javadoc line="1738">
                CAS tail field. Used only by enq.                
            </javadoc>
            <method name="compareAndSetTail" type="boolean" line="1741">
                <params>
                    <param name="expect" type="Node"/>
                    <param name="update" type="Node"/>
                </params>
            </method>
            <javadoc line="1744">
                CAS waitStatus field of a node.                
            </javadoc>
            <method name="compareAndSetWaitStatus" type="boolean" line="1747">
                <params>
                    <param name="node" type="Node"/>
                    <param name="expect" type="int"/>
                    <param name="update" type="int"/>
                </params>
            </method>
            <javadoc line="1750">
                CAS next field of a node.                
            </javadoc>
            <method name="compareAndSetNext" type="boolean" line="1753">
                <params>
                    <param name="node" type="Node"/>
                    <param name="expect" type="Node"/>
                    <param name="update" type="Node"/>
                </params>
            </method>
        </class>
    </source>