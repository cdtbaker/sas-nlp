<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.util.concurrent">
        <import package="java.util.AbstractQueue"/>
        <import package="java.util.Collection"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.NoSuchElementException"/>
        <import package="java.util.Queue"/>
        <import package="java.util.concurrent.TimeUnit"/>
        <import package="java.util.concurrent.locks.LockSupport"/>
        <class name="LinkedTransferQueue" line="9">
            <type_params>
                <type_param name="E"/>
            </type_params>
            <extends class="AbstractQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </extends>
            <implements interface="TransferQueue">
                <type_params>
                    <type_param name="E"/>
                </type_params>
            </implements>
            <implements interface="java.io.Serializable"/>
            <javadoc line="9">
                An unbounded {@link TransferQueue} based on linked nodes.
                  This queue orders elements FIFO (first-in-first-out) with respect
                  to any given producer.  The &lt;em&gt;head&lt;/em&gt; of the queue is that
                  element that has been on the queue the longest time for some
                  producer.  The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has
                  been on the queue the shortest time for some producer.
                  &lt;p&gt;Beware that, unlike in most collections, the {@code size} method
                  is &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these queues, determining the current number
                  of elements requires a traversal of the elements, and so may report
                  inaccurate results if this collection is modified during traversal.
                  Additionally, the bulk operations {@code addAll},{@code removeAll}, {@code retainAll}, {@code containsAll},{@code equals}, and {@code toArray} are &lt;em&gt;not&lt;/em&gt; guaranteed
                  to be performed atomically. For example, an iterator operating
                  concurrently with an {@code addAll} operation might view only some
                  of the added elements.
                  &lt;p&gt;This class and its iterator implement all of the
                  &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link Iterator} interfaces.
                  &lt;p&gt;Memory consistency effects: As with other concurrent
                  collections, actions in a thread prior to placing an object into a{@code LinkedTransferQueue}&lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
                  actions subsequent to the access or removal of that element from
                  the {@code LinkedTransferQueue} in another thread.
                  &lt;p&gt;This class is a member of the
                  &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
                  Java Collections Framework&lt;/a&gt;.                
                <since>
                    1.7                    
                </since>
                <author>
                    Doug Lea                    
                </author>
                <param>
                    <E>
                      the type of elements held in this collection                    
                </param>
            </javadoc>
            <declaration name="serialVersionUID" type="long" line="40"/>
            <declaration name="MP" type="boolean" line="41"/>
            <javadoc line="41">
                True if on multiprocessor                
            </javadoc>
            <declaration name="FRONT_SPINS" type="int" line="45"/>
            <javadoc line="45">
                The number of times to spin (with randomly interspersed calls
                  to Thread.yield) on multiprocessor before blocking when a node
                  is apparently the first waiter in the queue.  See above for
                  explanation. Must be a power of two. The value is empirically
                  derived -- it works pretty well across a variety of processors,
                  numbers of CPUs, and OSes.                
            </javadoc>
            <declaration name="CHAINED_SPINS" type="int" line="54"/>
            <javadoc line="54">
                The number of times to spin before blocking when a node is
                  preceded by another node that is apparently spinning.  Also
                  serves as an increment to FRONT_SPINS on phase changes, and as
                  base average frequency for yielding during spins. Must be a
                  power of two.                
            </javadoc>
            <declaration name="SWEEP_THRESHOLD" type="int" line="62"/>
            <javadoc line="62">
                The maximum number of estimated removal failures (sweepVotes)
                  to tolerate before sweeping through the queue unlinking
                  cancelled nodes that were not unlinked upon initial
                  removal. See above for explanation. The value must be at least
                  two to avoid useless sweeps when removing trailing nodes.                
            </javadoc>
            <class name="Node" line="70">
                <javadoc line="70">
                    Queue nodes. Uses Object, not E, for items to allow forgetting
                      them after use.  Relies heavily on Unsafe mechanics to minimize
                      unnecessary ordering constraints: Writes that are intrinsically
                      ordered wrt other accesses or CASes use simple relaxed forms.                    
                </javadoc>
                <declaration name="isData" type="boolean" line="77"/>
                <declaration name="item" type="Object" line="78"/>
                <declaration name="next" type="Node" line="79"/>
                <declaration name="waiter" type="Thread" line="80"/>
                <method name="casNext" type="boolean" line="81">
                    <params>
                        <param name="cmp" type="Node"/>
                        <param name="val" type="Node"/>
                    </params>
                </method>
                <method name="casItem" type="boolean" line="84">
                    <params>
                        <param name="cmp" type="Object"/>
                        <param name="val" type="Object"/>
                    </params>
                </method>
                <javadoc line="87">
                    Constructs a new node.  Uses relaxed write because item can
                      only be seen after publication via casNext.                    
                </javadoc>
                <method name="Node" type="constructor" line="91">
                    <params>
                        <param name="item" type="Object"/>
                        <param name="isData" type="boolean"/>
                    </params>
                </method>
                <javadoc line="95">
                    Links node to itself to avoid garbage retention.  Called
                      only after CASing head field, so uses relaxed write.                    
                </javadoc>
                <method name="forgetNext" type="void" line="99"/>
                <javadoc line="102">
                    Sets item to self and waiter to null, to avoid garbage
                      retention after matching or cancelling. Uses relaxed writes
                      because order is already constrained in the only calling
                      contexts: item is forgotten only after volatile/atomic
                      mechanics that extract items.  Similarly, clearing waiter
                      follows either CAS or return from park (if ever parked;
                      else we don&apos;t care).                    
                </javadoc>
                <method name="forgetContents" type="void" line="111"/>
                <javadoc line="115">
                    Returns true if this node has been matched, including the
                      case of artificial matches due to cancellation.                    
                </javadoc>
                <method name="isMatched" type="boolean" line="119">
                    <declaration name="x" type="Object" line="120"/>
                </method>
                <javadoc line="123">
                    Returns true if this is an unmatched request node.                    
                </javadoc>
                <method name="isUnmatchedRequest" type="boolean" line="126"/>
                <javadoc line="129">
                    Returns true if a node with the given mode cannot be
                      appended to this node because this node is unmatched and
                      has opposite data mode.                    
                </javadoc>
                <method name="cannotPrecede" type="boolean" line="134">
                    <params>
                        <param name="haveData" type="boolean"/>
                    </params>
                    <declaration name="d" type="boolean" line="135"/>
                    <declaration name="x" type="Object" line="136"/>
                </method>
                <javadoc line="139">
                    Tries to artificially match a data node -- used by remove.                    
                </javadoc>
                <method name="tryMatchData" type="boolean" line="142">
                    <declaration name="x" type="Object" line="143"/>
                    <scope line="144"/>
                </method>
                <declaration name="serialVersionUID" type="long" line="150"/>
                <declaration name="UNSAFE" type="sun.misc.Unsafe" line="151"/>
                <declaration name="itemOffset" type="long" line="152"/>
                <declaration name="nextOffset" type="long" line="153"/>
                <declaration name="waiterOffset" type="long" line="154"/>
                <scope line="155">
                    <scope line="156">
                        <declaration name="k" type="Class" line="158"/>
                    </scope>
                    <scope line="163"/>
                </scope>
            </class>
            <declaration name="head" type="Node" line="168"/>
            <javadoc line="168">
                head of the queue; null until first enqueue                
            </javadoc>
            <declaration name="tail" type="Node" line="172"/>
            <javadoc line="172">
                tail of the queue; null until first append                
            </javadoc>
            <declaration name="sweepVotes" type="int" line="176"/>
            <javadoc line="176">
                The number of apparent failures to unsplice removed nodes                
            </javadoc>
            <method name="casTail" type="boolean" line="180">
                <params>
                    <param name="cmp" type="Node"/>
                    <param name="val" type="Node"/>
                </params>
            </method>
            <method name="casHead" type="boolean" line="183">
                <params>
                    <param name="cmp" type="Node"/>
                    <param name="val" type="Node"/>
                </params>
            </method>
            <method name="casSweepVotes" type="boolean" line="186">
                <params>
                    <param name="cmp" type="int"/>
                    <param name="val" type="int"/>
                </params>
            </method>
            <declaration name="NOW" type="int" line="189"/>
            <declaration name="ASYNC" type="int" line="190"/>
            <declaration name="SYNC" type="int" line="191"/>
            <declaration name="TIMED" type="int" line="192"/>
            <method name="cast" type="E" line="193">
                <params>
                    <param name="item" type="Object"/>
                </params>
            </method>
            <javadoc line="196">
                Implements all queuing methods. See above for explanation.                
                <param>
                    e the item or null for take                    
                </param>
                <param>
                    haveData true if this is a put, else a take                    
                </param>
                <param>
                    how NOW, ASYNC, SYNC, or TIMED                    
                </param>
                <param>
                    nanos timeout in nanosecs, used only if mode is TIMED                    
                </param>
                <return>
                    an item if matched, else e                    
                </return>
                <throws>
                    NullPointerException if haveData mode but e is null                    
                </throws>
            </javadoc>
            <method name="xfer" type="E" line="205">
                <params>
                    <param name="e" type="E"/>
                    <param name="haveData" type="boolean"/>
                    <param name="how" type="int"/>
                    <param name="nanos" type="long"/>
                </params>
                <declaration name="s" type="Node" line="207"/>
                <scope line="208">
                    <scope line="209">
                        <declaration name="isData" type="boolean" line="210"/>
                        <declaration name="item" type="Object" line="211"/>
                        <scope line="212">
                            <scope line="214">
                                <scope line="215">
                                    <declaration name="n" type="Node" line="216"/>
                                    <scope line="217"/>
                                </scope>
                            </scope>
                        </scope>
                        <declaration name="n" type="Node" line="227"/>
                    </scope>
                    <scope line="230">
                        <declaration name="pred" type="Node" line="232"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="239">
                Tries to append node s as tail.                
                <param>
                    s the node to append                    
                </param>
                <param>
                    haveData true if appending in data mode                    
                </param>
                <return>
                    null on failure due to losing race with append in
                      different mode, else s's predecessor, or s itself if no
                      predecessor                    
                </return>
            </javadoc>
            <method name="tryAppend" type="Node" line="247">
                <params>
                    <param name="s" type="Node"/>
                    <param name="haveData" type="boolean"/>
                </params>
                <scope line="248">
                    <declaration name="n" type="Node" line="249"/>
                    <scope line="250"/>
                    <scope line="256">
                        <scope line="257"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="264">
                Spins/yields/blocks until node s is matched or caller gives up.                
                <param>
                    s the waiting node                    
                </param>
                <param>
                    pred the predecessor of s, or s itself if it has no
                      predecessor, or null if unknown (the null case does not occur
                      in any current calls but may in possible future extensions)                    
                </param>
                <param>
                    e the comparison value for checking match                    
                </param>
                <param>
                    timed if true, wait only until timeout elapses                    
                </param>
                <param>
                    nanos timeout in nanosecs, used only if timed is true                    
                </param>
                <return>
                    matched item, or e if unmatched on interrupt or timeout                    
                </return>
            </javadoc>
            <method name="awaitMatch" type="E" line="275">
                <params>
                    <param name="s" type="Node"/>
                    <param name="pred" type="Node"/>
                    <param name="e" type="E"/>
                    <param name="timed" type="boolean"/>
                    <param name="nanos" type="long"/>
                </params>
                <declaration name="lastTime" type="long" line="276"/>
                <declaration name="w" type="Thread" line="277"/>
                <declaration name="spins" type="int" line="278"/>
                <declaration name="randomYields" type="ThreadLocalRandom" line="279"/>
                <scope line="280">
                    <declaration name="item" type="Object" line="281"/>
                    <scope line="282"/>
                    <scope line="286"/>
                    <scope line="290"/>
                    <scope line="293"/>
                    <scope line="297"/>
                    <scope line="300">
                        <declaration name="now" type="long" line="301"/>
                    </scope>
                    <scope line="305"/>
                </scope>
            </method>
            <javadoc line="310">
                Returns spin/yield value for a node with given predecessor and
                  data mode. See above for explanation.                
            </javadoc>
            <method name="spinsFor" type="int" line="314">
                <params>
                    <param name="pred" type="Node"/>
                    <param name="haveData" type="boolean"/>
                </params>
                <scope line="315"/>
            </method>
            <javadoc line="322">
                Returns the successor of p, or the head node if p.next has been
                  linked to self, which will only be true if traversing with a
                  stale pointer that is now off the list.                
            </javadoc>
            <method name="succ" type="Node" line="327">
                <params>
                    <param name="p" type="Node"/>
                </params>
                <declaration name="next" type="Node" line="328"/>
            </method>
            <javadoc line="331">
                Returns the first unmatched node of the given mode, or null if
                  none.  Used by methods isEmpty, hasWaitingConsumer.                
            </javadoc>
            <method name="firstOfMode" type="Node" line="335">
                <params>
                    <param name="isData" type="boolean"/>
                </params>
                <scope line="336"/>
            </method>
            <javadoc line="341">
                Returns the item in the first unmatched node with isData; or
                  null if none.  Used by peek.                
            </javadoc>
            <method name="firstDataItem" type="E" line="345">
                <scope line="346">
                    <declaration name="item" type="Object" line="347"/>
                    <scope line="348"/>
                </scope>
            </method>
            <javadoc line="355">
                Traverses and counts unmatched nodes of the given mode.
                  Used by methods size and getWaitingConsumerCount.                
            </javadoc>
            <method name="countOfMode" type="int" line="359">
                <params>
                    <param name="data" type="boolean"/>
                </params>
                <declaration name="count" type="int" line="360"/>
                <scope line="361">
                    <scope line="362"/>
                    <declaration name="n" type="Node" line="366"/>
                    <scope line="368"/>
                </scope>
            </method>
            <class name="Itr" line="375">
                <implements interface="Iterator">
                    <type_params>
                        <type_param name="E"/>
                    </type_params>
                </implements>
                <declaration name="nextNode" type="Node" line="376"/>
                <declaration name="nextItem" type="E" line="377"/>
                <declaration name="lastRet" type="Node" line="378"/>
                <declaration name="lastPred" type="Node" line="379"/>
                <javadoc line="380">
                    Moves to next node after prev, or first node if prev null.                    
                </javadoc>
                <method name="advance" type="void" line="383">
                    <params>
                        <param name="prev" type="Node"/>
                    </params>
                    <declaration name="r" type="Node" line="384"/>
                    <scope line="387">
                        <declaration name="s" type="Node" line="388"/>
                    </scope>
                    <scope line="392">
                        <scope line="395"/>
                        <declaration name="item" type="Object" line="399"/>
                        <scope line="400">
                            <scope line="401"/>
                        </scope>
                    </scope>
                </method>
                <method name="Itr" type="constructor" line="416"/>
                <method name="hasNext" type="boolean" line="419"/>
                <method name="next" type="E" line="422">
                    <declaration name="p" type="Node" line="423"/>
                    <declaration name="e" type="E" line="425"/>
                </method>
                <method name="remove" type="void" line="429">
                    <declaration name="lastRet" type="Node" line="430"/>
                </method>
            </class>
            <javadoc line="436">
                Unsplices (now or later) the given deleted/cancelled node with
                  the given predecessor.                
                <param>
                    pred a node that was at one time known to be the
                      predecessor of s, or null or s itself if s is/was at head                    
                </param>
                <param>
                    s the node to be unspliced                    
                </param>
            </javadoc>
            <method name="unsplice" type="void" line="443">
                <params>
                    <param name="pred" type="Node"/>
                    <param name="s" type="Node"/>
                </params>
                <scope line="445">
                    <declaration name="n" type="Node" line="446"/>
                    <scope line="447">
                        <scope line="448">
                            <declaration name="h" type="Node" line="449"/>
                            <declaration name="hn" type="Node" line="452"/>
                        </scope>
                        <scope line="456">
                            <scope line="457">
                                <declaration name="v" type="int" line="458"/>
                                <scope line="459"/>
                                <scope line="462"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <javadoc line="471">
                Unlinks matched (typically cancelled) nodes encountered in a
                  traversal from head.                
            </javadoc>
            <method name="sweep" type="void" line="475">
                <scope line="476"/>
            </method>
            <javadoc line="483">
                Main implementation of remove(Object)                
            </javadoc>
            <method name="findAndRemove" type="boolean" line="486">
                <params>
                    <param name="e" type="Object"/>
                </params>
                <scope line="487">
                    <scope line="488">
                        <declaration name="item" type="Object" line="489"/>
                        <scope line="490">
                            <scope line="491"/>
                        </scope>
                        <scope line="498"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="506">
                Creates an initially empty {@code LinkedTransferQueue}.                
            </javadoc>
            <method name="LinkedTransferQueue" type="constructor" line="509"/>
            <javadoc line="511">
                Creates a {@code LinkedTransferQueue}initially containing the elements of the given collection,
                  added in traversal order of the collection&apos;s iterator.                
                <param>
                    c the collection of elements to initially contain                    
                </param>
                <throws>
                    NullPointerException if the specified collection or any
                      of its elements are null                    
                </throws>
            </javadoc>
            <method name="LinkedTransferQueue" type="constructor" line="518">
                <params>
                    <param name="c" type="Collection<? extends E>"/>
                </params>
            </method>
            <javadoc line="522">
                Inserts the specified element at the tail of this queue.
                  As the queue is unbounded, this method will never block.                
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="put" type="void" line="527">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="530">
                Inserts the specified element at the tail of this queue.
                  As the queue is unbounded, this method will never block or
                  return {@code false}.                
                <return>
                    {@code true} (as specified by{@link BlockingQueue#offer(Object,long,TimeUnit) BlockingQueue.offer})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="537">
                <params>
                    <param name="e" type="E"/>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
            </method>
            <javadoc line="541">
                Inserts the specified element at the tail of this queue.
                  As the queue is unbounded, this method will never return {@code false}.                
                <return>
                    {@code true} (as specified by {@link Queue#offer})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="offer" type="boolean" line="547">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="551">
                Inserts the specified element at the tail of this queue.
                  As the queue is unbounded, this method will never throw{@link IllegalStateException} or return {@code false}.                
                <return>
                    {@code true} (as specified by {@link Collection#add})                    
                </return>
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="add" type="boolean" line="557">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="561">
                Transfers the element to a waiting consumer immediately, if possible.
                  &lt;p&gt;More precisely, transfers the specified element immediately
                  if there exists a consumer already waiting to receive it (in{@link #take} or timed {@link #poll(long,TimeUnit) poll}),
                  otherwise returning {@code false} without enqueuing the element.                
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="tryTransfer" type="boolean" line="568">
                <params>
                    <param name="e" type="E"/>
                </params>
            </method>
            <javadoc line="571">
                Transfers the element to a consumer, waiting if necessary to do so.
                  &lt;p&gt;More precisely, transfers the specified element immediately
                  if there exists a consumer already waiting to receive it (in{@link #take} or timed {@link #poll(long,TimeUnit) poll}),
                  else inserts the specified element at the tail of this queue
                  and waits until the element is received by a consumer.                
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="transfer" type="void" line="579">
                <params>
                    <param name="e" type="E"/>
                </params>
                <scope line="580"/>
            </method>
            <javadoc line="585">
                Transfers the element to a consumer if it is possible to do so
                  before the timeout elapses.
                  &lt;p&gt;More precisely, transfers the specified element immediately
                  if there exists a consumer already waiting to receive it (in{@link #take} or timed {@link #poll(long,TimeUnit) poll}),
                  else inserts the specified element at the tail of this queue
                  and waits until the element is received by a consumer,
                  returning {@code false} if the specified wait time elapses
                  before the element can be transferred.                
                <throws>
                    NullPointerException if the specified element is null                    
                </throws>
            </javadoc>
            <method name="tryTransfer" type="boolean" line="596">
                <params>
                    <param name="e" type="E"/>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
            </method>
            <method name="take" type="E" line="601">
                <declaration name="e" type="E" line="602"/>
            </method>
            <method name="poll" type="E" line="607">
                <params>
                    <param name="timeout" type="long"/>
                    <param name="unit" type="TimeUnit"/>
                </params>
                <declaration name="e" type="E" line="608"/>
            </method>
            <method name="poll" type="E" line="612"/>
            <javadoc line="615">
                @throws NullPointerException     {@inheritDoc}                
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="drainTo" type="int" line="619">
                <params>
                    <param name="c" type="Collection<? super E>"/>
                </params>
                <declaration name="n" type="int" line="622"/>
                <declaration name="e" type="E" line="623"/>
                <scope line="624"/>
            </method>
            <javadoc line="630">
                @throws NullPointerException     {@inheritDoc}                
                <throws>
                    IllegalArgumentException {@inheritDoc}                    
                </throws>
            </javadoc>
            <method name="drainTo" type="int" line="634">
                <params>
                    <param name="c" type="Collection<? super E>"/>
                    <param name="maxElements" type="int"/>
                </params>
                <declaration name="n" type="int" line="637"/>
                <declaration name="e" type="E" line="638"/>
                <scope line="639"/>
            </method>
            <javadoc line="645">
                Returns an iterator over the elements in this queue in proper sequence.
                  The elements will be returned in order from first (head) to last (tail).
                  &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that
                  will never throw {@link java.util.ConcurrentModificationExceptionConcurrentModificationException}, and guarantees to traverse
                  elements as they existed upon construction of the iterator, and
                  may (but is not guaranteed to) reflect any modifications
                  subsequent to construction.                
                <return>
                    an iterator over the elements in this queue in proper sequence                    
                </return>
            </javadoc>
            <method name="iterator" type="Iterator<E>" line="655"/>
            <method name="peek" type="E" line="658"/>
            <javadoc line="661">
                Returns {@code true} if this queue contains no elements.                
                <return>
                    {@code true} if this queue contains no elements                    
                </return>
            </javadoc>
            <method name="isEmpty" type="boolean" line="665">
                <scope line="666"/>
            </method>
            <method name="hasWaitingConsumer" type="boolean" line="671"/>
            <javadoc line="674">
                Returns the number of elements in this queue.  If this queue
                  contains more than {@code Integer.MAX_VALUE} elements, returns{@code Integer.MAX_VALUE}.
                  &lt;p&gt;Beware that, unlike in most collections, this method is
                  &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
                  asynchronous nature of these queues, determining the current
                  number of elements requires an O(n) traversal.                
                <return>
                    the number of elements in this queue                    
                </return>
            </javadoc>
            <method name="size" type="int" line="683"/>
            <method name="getWaitingConsumerCount" type="int" line="686"/>
            <javadoc line="689">
                Removes a single instance of the specified element from this queue,
                  if it is present.  More formally, removes an element {@code e} such
                  that {@code o.equals(e)}, if this queue contains one or more such
                  elements.
                  Returns {@code true} if this queue contained the specified element
                  (or equivalently, if this queue changed as a result of the call).                
                <param>
                    o element to be removed from this queue, if present                    
                </param>
                <return>
                    {@code true} if this queue changed as a result of the call                    
                </return>
            </javadoc>
            <method name="remove" type="boolean" line="699">
                <params>
                    <param name="o" type="Object"/>
                </params>
            </method>
            <javadoc line="702">
                Returns {@code true} if this queue contains the specified element.
                  More formally, returns {@code true} if and only if this queue contains
                  at least one element {@code e} such that {@code o.equals(e)}.                
                <param>
                    o object to be checked for containment in this queue                    
                </param>
                <return>
                    {@code true} if this queue contains the specified element                    
                </return>
            </javadoc>
            <method name="contains" type="boolean" line="709">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="711">
                    <declaration name="item" type="Object" line="712"/>
                    <scope line="713"/>
                </scope>
            </method>
            <javadoc line="720">
                Always returns {@code Integer.MAX_VALUE} because a{@code LinkedTransferQueue} is not capacity constrained.                
                <return>
                    {@code Integer.MAX_VALUE} (as specified by{@link BlockingQueue#remainingCapacity()})                    
                </return>
            </javadoc>
            <method name="remainingCapacity" type="int" line="724"/>
            <javadoc line="727">
                Saves the state to a stream (that is, serializes it).                
                <serialData>
                    All of the elements (each an {@code E}) in
                      the proper order, followed by a null                    
                </serialData>
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="733">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
            </method>
            <javadoc line="738">
                Reconstitutes the Queue instance from a stream (that is,
                  deserializes it).                
                <param>
                    s the stream                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="743">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <scope line="745">
                    <declaration name="item" type="E" line="746"/>
                </scope>
            </method>
            <declaration name="UNSAFE" type="sun.misc.Unsafe" line="751"/>
            <declaration name="headOffset" type="long" line="752"/>
            <declaration name="tailOffset" type="long" line="753"/>
            <declaration name="sweepVotesOffset" type="long" line="754"/>
            <scope line="755">
                <scope line="756">
                    <declaration name="k" type="Class" line="758"/>
                </scope>
                <scope line="763"/>
            </scope>
        </class>
    </source>