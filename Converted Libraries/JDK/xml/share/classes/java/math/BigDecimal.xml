<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.math">
        <import package="java.util.Arrays"/>
        <import package="java.math.BigInteger.LONG_MASK"/>
        <class name="BigDecimal" line="35">
            <extends class="Number"/>
            <comment line="236">
                Note: this may have any value, so
                 calculations must be done in longs                
            </comment>
            <comment line="267">
                All 18-digit base ten strings fit into a long; not all 19-digit
                 strings will                
            </comment>
            <comment line="273">
                                
            </comment>
            <comment line="284">
                Cache of common small BigDecimal values.                
            </comment>
            <comment line="299">
                Cache of zero scaled by 0 - 15                
            </comment>
            <comment line="319">
                Half of Long.MIN_VALUE &amp; Long.MAX_VALUE.                
            </comment>
            <comment line="323">
                Constants                
            </comment>
            <comment line="348">
                Constructors                
            </comment>
            <comment line="1002">
                Static Factory Methods                
            </comment>
            <comment line="1073">
                Arithmetic Operations                
            </comment>
            <comment line="2209">
                Rounding Modes                
            </comment>
            <comment line="2283">
                Scaling/Rounding Operations                
            </comment>
            <comment line="2453">
                Decimal Point Motion Operations                
            </comment>
            <comment line="2534">
                Comparison Operations                
            </comment>
            <comment line="2683">
                Hash Function                
            </comment>
            <comment line="2705">
                Format Converters                
            </comment>
            <comment line="2885">
                                
            </comment>
            <comment line="3159">
                Private class to build a string representation for BigDecimal object.
                 &quot;StringBuilderHelper&quot; is constructed as a thread local variable so it is
                 thread safe. The StringBuilder field acts as a buffer to hold the temporary
                 representation of BigDecimal. The cmpCharArray holds all the characters for
                 the compact representation of BigDecimal (except for &apos;-&apos; sign&apos; if it is
                 negative) if its intCompact field is not INFLATED. It is shared by all
                 calls to toString() and its variants in that particular thread.                
            </comment>
            <comment line="3797">
                Internal printing routine                
            </comment>
            <implements interface="Comparable">
                <type_params>
                    <type_param name="BigDecimal"/>
                </type_params>
            </implements>
            <javadoc line="35">
                Immutable, arbitrary-precision signed decimal numbers.  A{@code BigDecimal} consists of an arbitrary precision integer
                  &lt;i&gt;unscaled value&lt;/i&gt; and a 32-bit integer &lt;i&gt;scale&lt;/i&gt;.  If zero
                  or positive, the scale is the number of digits to the right of the
                  decimal point.  If negative, the unscaled value of the number is
                  multiplied by ten to the power of the negation of the scale.  The
                  value of the number represented by the {@code BigDecimal} is
                  therefore &lt;tt&gt;(unscaledValue &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;.
                  &lt;p&gt;The {@code BigDecimal} class provides operations for
                  arithmetic, scale manipulation, rounding, comparison, hashing, and
                  format conversion.  The {@link #toString} method provides a
                  canonical representation of a {@code BigDecimal}.
                  &lt;p&gt;The {@code BigDecimal} class gives its user complete control
                  over rounding behavior.  If no rounding mode is specified and the
                  exact result cannot be represented, an exception is thrown;
                  otherwise, calculations can be carried out to a chosen precision
                  and rounding mode by supplying an appropriate {@link MathContext}object to the operation.  In either case, eight &lt;em&gt;rounding
                  modes&lt;/em&gt; are provided for the control of rounding.  Using the
                  integer fields in this class (such as {@link #ROUND_HALF_UP}) to
                  represent rounding mode is largely obsolete; the enumeration values
                  of the {@code RoundingMode} {@code enum}, (such as {@link RoundingMode#HALF_UP}) should be used instead.
                  &lt;p&gt;When a {@code MathContext} object is supplied with a precision
                  setting of 0 (for example, {@link MathContext#UNLIMITED}),
                  arithmetic operations are exact, as are the arithmetic methods
                  which take no {@code MathContext} object.  (This is the only
                  behavior that was supported in releases prior to 5.)  As a
                  corollary of computing the exact result, the rounding mode setting
                  of a {@code MathContext} object with a precision setting of 0 is
                  not used and thus irrelevant.  In the case of divide, the exact
                  quotient could have an infinitely long decimal expansion; for
                  example, 1 divided by 3.  If the quotient has a nonterminating
                  decimal expansion and the operation is specified to return an exact
                  result, an {@code ArithmeticException} is thrown.  Otherwise, the
                  exact result of the division is returned, as done for other
                  operations.
                  &lt;p&gt;When the precision setting is not 0, the rules of{@code BigDecimal} arithmetic are broadly compatible with selected
                  modes of operation of the arithmetic defined in ANSI X3.274-1996
                  and ANSI X3.274-1996/AM 1-2000 (section 7.4).  Unlike those
                  standards, {@code BigDecimal} includes many rounding modes, which
                  were mandatory for division in {@code BigDecimal} releases prior
                  to 5.  Any conflicts between these ANSI standards and the{@code BigDecimal} specification are resolved in favor of{@code BigDecimal}.
                  &lt;p&gt;Since the same numerical value can have different
                  representations (with different scales), the rules of arithmetic
                  and rounding must specify both the numerical result and the scale
                  used in the result&apos;s representation.
                  &lt;p&gt;In general the rounding modes and precision setting determine
                  how operations return results with a limited number of digits when
                  the exact result has more digits (perhaps infinitely many in the
                  case of division) than the number of digits returned.
                  First, the
                  total number of digits to return is specified by the{@code MathContext}&apos;s {@code precision} setting; this determines
                  the result&apos;s &lt;i&gt;precision&lt;/i&gt;.  The digit count starts from the
                  leftmost nonzero digit of the exact result.  The rounding mode
                  determines how any discarded trailing digits affect the returned
                  result.
                  &lt;p&gt;For all arithmetic operators , the operation is carried out as
                  though an exact intermediate result were first calculated and then
                  rounded to the number of digits specified by the precision setting
                  (if necessary), using the selected rounding mode.  If the exact
                  result is not returned, some digit positions of the exact result
                  are discarded.  When rounding increases the magnitude of the
                  returned result, it is possible for a new digit position to be
                  created by a carry propagating to a leading {@literal &quot;9&quot;} digit.
                  For example, rounding the value 999.9 to three digits rounding up
                  would be numerically equal to one thousand, represented as
                  100&amp;times;10&lt;sup&gt;1&lt;/sup&gt;.  In such cases, the new {@literal &quot;1&quot;} is
                  the leading digit position of the returned result.
                  &lt;p&gt;Besides a logical exact result, each arithmetic operation has a
                  preferred scale for representing a result.  The preferred
                  scale for each operation is listed in the table below.
                  &lt;table border&gt;
                  &lt;caption&gt;&lt;b&gt;Preferred Scales for Results of Arithmetic Operations
                  &lt;/b&gt;&lt;/caption&gt;
                  &lt;tr&gt;&lt;th&gt;Operation&lt;/th&gt;&lt;th&gt;Preferred Scale of Result&lt;/th&gt;&lt;/tr&gt;
                  &lt;tr&gt;&lt;td&gt;Add&lt;/td&gt;&lt;td&gt;max(addend.scale(), augend.scale())&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;Subtract&lt;/td&gt;&lt;td&gt;max(minuend.scale(), subtrahend.scale())&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;Multiply&lt;/td&gt;&lt;td&gt;multiplier.scale() + multiplicand.scale()&lt;/td&gt;
                  &lt;tr&gt;&lt;td&gt;Divide&lt;/td&gt;&lt;td&gt;dividend.scale() - divisor.scale()&lt;/td&gt;
                  &lt;/table&gt;
                  These scales are the ones used by the methods which return exact
                  arithmetic results; except that an exact divide may have to use a
                  larger scale since the exact result may have more digits.  For
                  example, {@code 1/32} is {@code 0.03125}.
                  &lt;p&gt;Before rounding, the scale of the logical exact intermediate
                  result is the preferred scale for that operation.  If the exact
                  numerical result cannot be represented in {@code precision}digits, rounding selects the set of digits to return and the scale
                  of the result is reduced from the scale of the intermediate result
                  to the least scale which can represent the {@code precision}digits actually returned.  If the exact result can be represented
                  with at most {@code precision} digits, the representation
                  of the result with the scale closest to the preferred scale is
                  returned.  In particular, an exactly representable quotient may be
                  represented in fewer than {@code precision} digits by removing
                  trailing zeros and decreasing the scale.  For example, rounding to
                  three digits using the {@linkplain RoundingMode#FLOOR floor}rounding mode, &lt;br&gt;{@code 19/100 = 0.19   // integer=19,  scale=2} &lt;br&gt;
                  but&lt;br&gt;{@code 21/110 = 0.190  // integer=190, scale=3} &lt;br&gt;
                  &lt;p&gt;Note that for add, subtract, and multiply, the reduction in
                  scale will equal the number of digit positions of the exact result
                  which are discarded. If the rounding causes a carry propagation to
                  create a new high-order digit position, an additional digit of the
                  result is discarded than when no new digit position is created.
                  &lt;p&gt;Other methods may have slightly different rounding semantics.
                  For example, the result of the {@code pow} method using the{@linkplain #pow(int,MathContext) specified algorithm} can
                  occasionally differ from the rounded mathematical result by more
                  than one unit in the last place, one &lt;i&gt;{@linkplain #ulp() ulp}&lt;/i&gt;.
                  &lt;p&gt;Two types of operations are provided for manipulating the scale
                  of a {@code BigDecimal}: scaling/rounding operations and decimal
                  point motion operations.  Scaling/rounding operations ({@link #setScale setScale} and {@link #round round}) return a{@code BigDecimal} whose value is approximately (or exactly) equal
                  to that of the operand, but whose scale or precision is the
                  specified value; that is, they increase or decrease the precision
                  of the stored number with minimal effect on its value.  Decimal
                  point motion operations ({@link #movePointLeft movePointLeft} and{@link #movePointRight movePointRight}) return a{@code BigDecimal} created from the operand by moving the decimal
                  point a specified distance in the specified direction.
                  &lt;p&gt;For the sake of brevity and clarity, pseudo-code is used
                  throughout the descriptions of {@code BigDecimal} methods.  The
                  pseudo-code expression {@code (i + j)} is shorthand for &quot;a{@code BigDecimal} whose value is that of the {@code BigDecimal}{@code i} added to that of the {@code BigDecimal}{@code j}.&quot; The pseudo-code expression {@code (i == j)} is
                  shorthand for &quot;{@code true} if and only if the{@code BigDecimal} {@code i} represents the same value as the{@code BigDecimal} {@code j}.&quot; Other pseudo-code expressions
                  are interpreted similarly.  Square brackets are used to represent
                  the particular {@code BigInteger} and scale pair defining a{@code BigDecimal} value; for example [19, 2] is the{@code BigDecimal} numerically equal to 0.19 having a scale of 2.
                  &lt;p&gt;Note: care should be exercised if {@code BigDecimal} objects
                  are used as keys in a {@link java.util.SortedMap SortedMap} or
                  elements in a {@link java.util.SortedSet SortedSet} since{@code BigDecimal}&apos;s &lt;i&gt;natural ordering&lt;/i&gt; is &lt;i&gt;inconsistent
                  with equals&lt;/i&gt;.  See {@link Comparable}, {@link java.util.SortedMap} or {@link java.util.SortedSet} for more
                  information.
                  &lt;p&gt;All methods and constructors for this class throw{@code NullPointerException} when passed a {@code null} object
                  reference for any input parameter.                
                <see>
                    BigInteger                    
                </see>
                <see>
                    MathContext                    
                </see>
                <see>
                    RoundingMode                    
                </see>
                <see>
                    java.util.SortedMap                    
                </see>
                <see>
                    java.util.SortedSet                    
                </see>
                <author>
                    Josh Bloch                    
                </author>
                <author>
                    Mike Cowlishaw                    
                </author>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <declaration name="intVal" type="BigInteger" line="220"/>
            <javadoc line="220">
                The unscaled value of this BigDecimal, as returned by {@link #unscaledValue}.                
                <serial>
                                        
                </serial>
                <see>
                    #unscaledValue                    
                </see>
            </javadoc>
            <declaration name="scale" type="int" line="229"/>
            <javadoc line="229">
                The scale of this BigDecimal, as returned by {@link #scale}.                
                <serial>
                                        
                </serial>
                <see>
                    #scale                    
                </see>
            </javadoc>
            <declaration name="precision" type="int" line="237"/>
            <javadoc line="237">
                The number of decimal digits in this BigDecimal, or 0 if the
                  number of digits are not known (lookaside information).  If
                  nonzero, the value is guaranteed correct.  Use the precision()
                  method to obtain and set the value if it might be 0.  This
                  field is mutable until set nonzero.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="stringCache" type="String" line="248"/>
            <javadoc line="248">
                Used to store the canonical string representation, if computed.                
            </javadoc>
            <declaration name="INFLATED" type="long" line="253"/>
            <javadoc line="253">
                Sentinel value for {@link #intCompact} indicating the
                  significand information is only available from {@code intVal}.                
            </javadoc>
            <declaration name="intCompact" type="long" line="259"/>
            <javadoc line="259">
                If the absolute value of the significand of this BigDecimal is
                  less than or equal to {@code Long.MAX_VALUE}, the value can be
                  compactly stored in this field and used in computations.                
            </javadoc>
            <declaration name="MAX_COMPACT_DIGITS" type="int" line="268"/>
            <declaration name="MAX_BIGINT_BITS" type="int" line="270"/>
            <declaration name="serialVersionUID" type="long" line="273"/>
            <declaration name="threadLocalStringBuilderHelper" type="ThreadLocal&lt;StringBuilderHelper&gt;" line="275"/>
            <anonymous_class line="276">
                <method name="initialValue" type="StringBuilderHelper" line="278"/>
            </anonymous_class>
            <declaration name="zeroThroughTen" type="BigDecimal" line="284"/>
            <declaration name="ZERO_SCALED_BY" type="BigDecimal[]" line="299"/>
            <declaration name="HALF_LONG_MAX_VALUE" type="long" line="319"/>
            <declaration name="HALF_LONG_MIN_VALUE" type="long" line="320"/>
            <declaration name="ZERO" type="BigDecimal" line="323"/>
            <javadoc line="323">
                The value 0, with a scale of 0.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="ONE" type="BigDecimal" line="331"/>
            <javadoc line="331">
                The value 1, with a scale of 0.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <declaration name="TEN" type="BigDecimal" line="339"/>
            <javadoc line="339">
                The value 10, with a scale of 0.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <javadoc line="349">
                Trusted package private constructor.
                  Trusted simply means if val is INFLATED, intVal could not be null and
                  if intVal is null, val could not be INFLATED.                
            </javadoc>
            <method name="BigDecimal" type="constructor" line="354">
                <params>
                    <param name="intVal" type="BigInteger"/>
                    <param name="val" type="long"/>
                    <param name="scale" type="int"/>
                    <param name="prec" type="int"/>
                </params>
            </method>
            <javadoc line="361">
                Translates a character array representation of a{@code BigDecimal} into a {@code BigDecimal}, accepting the
                  same sequence of characters as the {@link #BigDecimal(String)}constructor, while allowing a sub-array to be specified.
                  &lt;p&gt;Note that if the sequence of characters is already available
                  within a character array, using this constructor is faster than
                  converting the {@code char} array to string and using the{@code BigDecimal(String)} constructor .                
                <param>
                    in {@code char} array that is the source of characters.                    
                </param>
                <param>
                    offset first character in the array to inspect.                    
                </param>
                <param>
                    len number of characters to consider.                    
                </param>
                <throws>
                    NumberFormatException if {@code in} is not a valid
                      representation of a {@code BigDecimal} or the defined subarray
                      is not wholly within {@code in}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="380">
                <params>
                    <param name="in" type="char[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                </params>
                <comment line="382">
                    protect against huge length.                    
                </comment>
                <comment line="385">
                    This is the primary string to BigDecimal constructor; all
                     incoming strings end up here; it uses explicit (inline)
                     parsing for speed and generates at most one intermediate
                     (temporary) object (a char[] array) for non-compact case.                    
                </comment>
                <comment line="390">
                    Use locals for all fields values until completion                    
                </comment>
                <comment line="391">
                    record precision value                    
                </comment>
                <comment line="392">
                    record scale value                    
                </comment>
                <comment line="393">
                    the compact value in long                    
                </comment>
                <comment line="394">
                    the inflated value in BigInteger                    
                </comment>
                <comment line="396">
                    use array bounds checking to handle too-long, len == 0,
                     bad offset, etc.                    
                </comment>
                <comment line="399">
                    handle the sign                    
                </comment>
                <comment line="400">
                    assume positive                    
                </comment>
                <comment line="402">
                    leading minus means negative                    
                </comment>
                <comment line="405">
                    leading + allowed                    
                </comment>
                <comment line="410">
                    should now be at numeric part of the significand                    
                </comment>
                <comment line="411">
                    true when there is a &apos;.&apos;                    
                </comment>
                <comment line="412">
                    record start of integer                    
                </comment>
                <comment line="413">
                    exponent                    
                </comment>
                <comment line="414">
                    current character                    
                </comment>
                <comment line="417">
                    integer significand array &amp; idx is the index to it. The array
                     is ONLY used when we can&apos;t use a compact representation.                    
                </comment>
                <comment line="424">
                    have digit                    
                </comment>
                <comment line="426">
                    First compact case, we need not to preserve the character
                     and we can just compute the value in place.                    
                </comment>
                <comment line="436">
                    else digit is a redundant leading zero                    
                </comment>
                <comment line="439">
                    prec unchanged if preceded by 0s                    
                </comment>
                <comment line="442">
                    the unscaled value is likely a BigInteger object.                    
                </comment>
                <comment line="450">
                    else c must be a redundant leading zero                    
                </comment>
                <comment line="453">
                    prec unchanged if preceded by 0s                    
                </comment>
                <comment line="461">
                    have dot                    
                </comment>
                <comment line="463">
                    have dot                    
                </comment>
                <comment line="464">
                    two dots                    
                </comment>
                <comment line="469">
                    exponent expected                    
                </comment>
                <comment line="476">
                    optional sign                    
                </comment>
                <comment line="482">
                    no exponent digits                    
                </comment>
                <comment line="484">
                    skip leading zeros in the exponent                    
                </comment>
                <comment line="490">
                    too many nonzero exponent digits                    
                </comment>
                <comment line="492">
                    c now holds first digit of exponent                    
                </comment>
                <comment line="499">
                    not a digit                    
                </comment>
                <comment line="504">
                    that was final character                    
                </comment>
                <comment line="508">
                    apply sign                    
                </comment>
                <comment line="510">
                    Next test is required for backwards compatibility                    
                </comment>
                <comment line="511">
                    overflow                    
                </comment>
                <comment line="513">
                    [saves a test]                    
                </comment>
                <comment line="515">
                    here when no characters left                    
                </comment>
                <comment line="516">
                    no digits found                    
                </comment>
                <comment line="519">
                    Adjust scale if exp is not zero.                    
                </comment>
                <comment line="520">
                    had significant exponent                    
                </comment>
                <comment line="521">
                    Can&apos;t call checkScale which relies on proper fields value                    
                </comment>
                <comment line="529">
                    Remove leading zeros from precision (digits count)                    
                </comment>
                <declaration name="prec" type="int" line="390"/>
                <declaration name="scl" type="int" line="391"/>
                <declaration name="rs" type="long" line="392"/>
                <declaration name="rb" type="BigInteger" line="393"/>
                <scope line="397">
                    <declaration name="isneg" type="boolean" line="399"/>
                    <scope line="400"/>
                    <scope line="404"/>
                    <declaration name="dot" type="boolean" line="410"/>
                    <declaration name="cfirst" type="int" line="411"/>
                    <declaration name="exp" type="long" line="412"/>
                    <declaration name="c" type="char" line="413"/>
                    <declaration name="isCompact" type="boolean" line="415"/>
                    <declaration name="coeff" type="char" line="418"/>
                    <declaration name="idx" type="int" line="419"/>
                    <scope line="421">
                        <scope line="424">
                            <scope line="427">
                                <declaration name="digit" type="int" line="428"/>
                                <scope line="429">
                                    <scope line="432"/>
                                </scope>
                                <scope line="436"/>
                            </scope>
                            <scope line="441">
                                <scope line="442">
                                    <scope line="443"/>
                                    <scope line="446"/>
                                </scope>
                                <scope line="450"/>
                            </scope>
                        </scope>
                        <scope line="461"/>
                        <declaration name="negexp" type="boolean" line="474"/>
                        <scope line="476"/>
                        <scope line="484"/>
                        <scope line="492">
                            <declaration name="v" type="int" line="493"/>
                            <scope line="494"/>
                            <scope line="496"/>
                        </scope>
                    </scope>
                    <scope line="519">
                        <declaration name="adjustedScale" type="long" line="521"/>
                    </scope>
                    <scope line="529"/>
                    <scope line="531">
                        <declaration name="quick" type="char" line="532"/>
                        <scope line="533"/>
                        <scope line="536"/>
                    </scope>
                </scope>
                <scope line="544"/>
                <scope line="546"/>
            </method>
            <javadoc line="555">
                Translates a character array representation of a{@code BigDecimal} into a {@code BigDecimal}, accepting the
                  same sequence of characters as the {@link #BigDecimal(String)}constructor, while allowing a sub-array to be specified and
                  with rounding according to the context settings.
                  &lt;p&gt;Note that if the sequence of characters is already available
                  within a character array, using this constructor is faster than
                  converting the {@code char} array to string and using the{@code BigDecimal(String)} constructor .                
                <param>
                    in {@code char} array that is the source of characters.                    
                </param>
                <param>
                    offset first character in the array to inspect.                    
                </param>
                <param>
                    len number of characters to consider..                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <throws>
                    NumberFormatException if {@code in} is not a valid
                      representation of a {@code BigDecimal} or the defined subarray
                      is not wholly within {@code in}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="578">
                <params>
                    <param name="in" type="char[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="584">
                Translates a character array representation of a{@code BigDecimal} into a {@code BigDecimal}, accepting the
                  same sequence of characters as the {@link #BigDecimal(String)}constructor.
                  &lt;p&gt;Note that if the sequence of characters is already available
                  as a character array, using this constructor is faster than
                  converting the {@code char} array to string and using the{@code BigDecimal(String)} constructor .                
                <param>
                    in {@code char} array that is the source of characters.                    
                </param>
                <throws>
                    NumberFormatException if {@code in} is not a valid
                      representation of a {@code BigDecimal}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="600">
                <params>
                    <param name="in" type="char[]"/>
                </params>
            </method>
            <javadoc line="604">
                Translates a character array representation of a{@code BigDecimal} into a {@code BigDecimal}, accepting the
                  same sequence of characters as the {@link #BigDecimal(String)}constructor and with rounding according to the context
                  settings.
                  &lt;p&gt;Note that if the sequence of characters is already available
                  as a character array, using this constructor is faster than
                  converting the {@code char} array to string and using the{@code BigDecimal(String)} constructor .                
                <param>
                    in {@code char} array that is the source of characters.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <throws>
                    NumberFormatException if {@code in} is not a valid
                      representation of a {@code BigDecimal}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="624">
                <params>
                    <param name="in" type="char[]"/>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="628">
                Translates the string representation of a {@code BigDecimal}into a {@code BigDecimal}.  The string representation consists
                  of an optional sign, {@code &apos;+&apos;} (&lt;tt&gt; &apos;&amp;#92;u002B&apos;&lt;/tt&gt;) or{@code &apos;-&apos;} (&lt;tt&gt;&apos;&amp;#92;u002D&apos;&lt;/tt&gt;), followed by a sequence of
                  zero or more decimal digits (&quot;the integer&quot;), optionally
                  followed by a fraction, optionally followed by an exponent.
                  &lt;p&gt;The fraction consists of a decimal point followed by zero
                  or more decimal digits.  The string must contain at least one
                  digit in either the integer or the fraction.  The number formed
                  by the sign, the integer and the fraction is referred to as the
                  &lt;i&gt;significand&lt;/i&gt;.
                  &lt;p&gt;The exponent consists of the character {@code &apos;e&apos;}(&lt;tt&gt;&apos;&amp;#92;u0065&apos;&lt;/tt&gt;) or {@code &apos;E&apos;} (&lt;tt&gt;&apos;&amp;#92;u0045&apos;&lt;/tt&gt;)
                  followed by one or more decimal digits.  The value of the
                  exponent must lie between -{@link Integer#MAX_VALUE} ({@link Integer#MIN_VALUE}+1) and {@link Integer#MAX_VALUE}, inclusive.
                  &lt;p&gt;More formally, the strings this constructor accepts are
                  described by the following grammar:
                  &lt;blockquote&gt;
                  &lt;dl&gt;
                  &lt;dt&gt;&lt;i&gt;BigDecimalString:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; Significand Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;p&gt;
                  &lt;dt&gt;&lt;i&gt;Sign:&lt;/i&gt;
                  &lt;dd&gt;{@code +}&lt;dd&gt;{@code -}&lt;p&gt;
                  &lt;dt&gt;&lt;i&gt;Significand:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;IntegerPart&lt;/i&gt; {@code .} &lt;i&gt;FractionPart&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
                  &lt;dd&gt;{@code .} &lt;i&gt;FractionPart&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;IntegerPart&lt;/i&gt;
                  &lt;p&gt;
                  &lt;dt&gt;&lt;i&gt;IntegerPart:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Digits&lt;/i&gt;
                  &lt;p&gt;
                  &lt;dt&gt;&lt;i&gt;FractionPart:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Digits&lt;/i&gt;
                  &lt;p&gt;
                  &lt;dt&gt;&lt;i&gt;Exponent:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;ExponentIndicator SignedInteger&lt;/i&gt;
                  &lt;p&gt;
                  &lt;dt&gt;&lt;i&gt;ExponentIndicator:&lt;/i&gt;
                  &lt;dd&gt;{@code e}&lt;dd&gt;{@code E}&lt;p&gt;
                  &lt;dt&gt;&lt;i&gt;SignedInteger:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; Digits&lt;/i&gt;
                  &lt;p&gt;
                  &lt;dt&gt;&lt;i&gt;Digits:&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Digit&lt;/i&gt;
                  &lt;dd&gt;&lt;i&gt;Digits Digit&lt;/i&gt;
                  &lt;p&gt;
                  &lt;dt&gt;&lt;i&gt;Digit:&lt;/i&gt;
                  &lt;dd&gt;any character for which {@link Character#isDigit}returns {@code true}, including 0, 1, 2 ...
                  &lt;/dl&gt;
                  &lt;/blockquote&gt;
                  &lt;p&gt;The scale of the returned {@code BigDecimal} will be the
                  number of digits in the fraction, or zero if the string
                  contains no decimal point, subject to adjustment for any
                  exponent; if the string contains an exponent, the exponent is
                  subtracted from the scale.  The value of the resulting scale
                  must lie between {@code Integer.MIN_VALUE} and{@code Integer.MAX_VALUE}, inclusive.
                  &lt;p&gt;The character-to-digit mapping is provided by {@link java.lang.Character#digit} set to convert to radix 10.  The
                  String may not contain any extraneous characters (whitespace,
                  for example).
                  &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;br&gt;
                  The value of the returned {@code BigDecimal} is equal to
                  &lt;i&gt;significand&lt;/i&gt; &amp;times; 10&lt;sup&gt;&amp;nbsp;&lt;i&gt;exponent&lt;/i&gt;&lt;/sup&gt;.
                  For each string on the left, the resulting representation
                  [{@code BigInteger}, {@code scale}] is shown on the right.
                  &lt;pre&gt;
                  &quot;0&quot;            [0,0]
                  &quot;0.00&quot;         [0,2]
                  &quot;123&quot;          [123,0]
                  &quot;-123&quot;         [-123,0]
                  &quot;1.23E3&quot;       [123,-1]
                  &quot;1.23E+3&quot;      [123,-1]
                  &quot;12.3E+7&quot;      [123,-6]
                  &quot;12.0&quot;         [120,1]
                  &quot;12.3&quot;         [123,1]
                  &quot;0.00123&quot;      [123,5]
                  &quot;-1.23E-12&quot;    [-123,14]
                  &quot;1234.5E-4&quot;    [12345,5]
                  &quot;0E+7&quot;         [0,-7]
                  &quot;-0&quot;           [0,0]
                  &lt;/pre&gt;
                  &lt;p&gt;Note: For values other than {@code float} and{@code double} NaN and &amp;plusmn;Infinity, this constructor is
                  compatible with the values returned by {@link Float#toString}and {@link Double#toString}.  This is generally the preferred
                  way to convert a {@code float} or {@code double} into a
                  BigDecimal, as it doesn&apos;t suffer from the unpredictability of
                  the {@link #BigDecimal(double)} constructor.                
                <param>
                    val String representation of {@code BigDecimal}.                    
                </param>
                <throws>
                    NumberFormatException if {@code val} is not a valid
                      representation of a {@code BigDecimal}.                    
                </throws>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="738">
                <params>
                    <param name="val" type="String"/>
                </params>
            </method>
            <javadoc line="742">
                Translates the string representation of a {@code BigDecimal}into a {@code BigDecimal}, accepting the same strings as the{@link #BigDecimal(String)} constructor, with rounding
                  according to the context settings.                
                <param>
                    val string representation of a {@code BigDecimal}.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <throws>
                    NumberFormatException if {@code val} is not a valid
                      representation of a BigDecimal.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="756">
                <params>
                    <param name="val" type="String"/>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="762">
                Translates a {@code double} into a {@code BigDecimal} which
                  is the exact decimal representation of the {@code double}&apos;s
                  binary floating-point value.  The scale of the returned{@code BigDecimal} is the smallest value such that
                  &lt;tt&gt;(10&lt;sup&gt;scale&lt;/sup&gt; &amp;times; val)&lt;/tt&gt; is an integer.
                  &lt;p&gt;
                  &lt;b&gt;Notes:&lt;/b&gt;
                  &lt;ol&gt;
                  &lt;li&gt;
                  The results of this constructor can be somewhat unpredictable.
                  One might assume that writing {@code new BigDecimal(0.1)} in
                  Java creates a {@code BigDecimal} which is exactly equal to
                  0.1 (an unscaled value of 1, with a scale of 1), but it is
                  actually equal to
                  0.1000000000000000055511151231257827021181583404541015625.
                  This is because 0.1 cannot be represented exactly as a{@code double} (or, for that matter, as a binary fraction of
                  any finite length).  Thus, the value that is being passed
                  &lt;i&gt;in&lt;/i&gt; to the constructor is not exactly equal to 0.1,
                  appearances notwithstanding.
                  &lt;li&gt;
                  The {@code String} constructor, on the other hand, is
                  perfectly predictable: writing {@code new BigDecimal(&quot;0.1&quot;)}creates a {@code BigDecimal} which is &lt;i&gt;exactly&lt;/i&gt; equal to
                  0.1, as one would expect.  Therefore, it is generally
                  recommended that the {@linkplain #BigDecimal(String)&lt;tt&gt;String&lt;/tt&gt; constructor} be used in preference to this one.
                  &lt;li&gt;
                  When a {@code double} must be used as a source for a{@code BigDecimal}, note that this constructor provides an
                  exact conversion; it does not give the same result as
                  converting the {@code double} to a {@code String} using the{@link Double#toString(double)} method and then using the{@link #BigDecimal(String)} constructor.  To get that result,
                  use the {@code static} {@link #valueOf(double)} method.
                  &lt;/ol&gt;                
                <param>
                    val {@code double} value to be converted to{@code BigDecimal}.                    
                </param>
                <throws>
                    NumberFormatException if {@code val} is infinite or NaN.                    
                </throws>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="806">
                <params>
                    <param name="val" type="double"/>
                </params>
                <comment line="811">
                    Translate the double into sign, exponent and significand, according
                     to the formulae in JLS, Section 20.10.22.                    
                </comment>
                <comment line="819">
                    At this point, val == sign * significand * 2**exponent.                    
                </comment>
                <comment line="821">
                    Special case zero to supress nonterminating normalization
                     and bogus scale calculation.                    
                </comment>
                <comment line="832">
                    Normalize                    
                </comment>
                <comment line="833">
                    i.e., significand is even                    
                </comment>
                <comment line="838">
                    Calculate intVal and scale                    
                </comment>
                <declaration name="valBits" type="long" line="812"/>
                <declaration name="sign" type="int" line="813"/>
                <declaration name="exponent" type="int" line="814"/>
                <declaration name="significand" type="long" line="815"/>
                <scope line="824"/>
                <scope line="832"/>
                <declaration name="s" type="long" line="838"/>
                <declaration name="b" type="BigInteger" line="839"/>
                <scope line="840"/>
                <scope line="843"/>
                <scope line="845"/>
            </method>
            <javadoc line="852">
                Translates a {@code double} into a {@code BigDecimal}, with
                  rounding according to the context settings.  The scale of the{@code BigDecimal} is the smallest value such that
                  &lt;tt&gt;(10&lt;sup&gt;scale&lt;/sup&gt; &amp;times; val)&lt;/tt&gt; is an integer.
                  &lt;p&gt;The results of this constructor can be somewhat unpredictable
                  and its use is generally not recommended; see the notes under
                  the {@link #BigDecimal(double)} constructor.                
                <param>
                    val {@code double} value to be converted to{@code BigDecimal}.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the result is inexact but the
                      RoundingMode is UNNECESSARY.                    
                </throws>
                <throws>
                    NumberFormatException if {@code val} is infinite or NaN.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="870">
                <params>
                    <param name="val" type="double"/>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="876">
                Translates a {@code BigInteger} into a {@code BigDecimal}.
                  The scale of the {@code BigDecimal} is zero.                
                <param>
                    val {@code BigInteger} value to be converted to{@code BigDecimal}.                    
                </param>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="883">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
            </method>
            <javadoc line="888">
                Translates a {@code BigInteger} into a {@code BigDecimal}rounding according to the context settings.  The scale of the{@code BigDecimal} is zero.                
                <param>
                    val {@code BigInteger} value to be converted to{@code BigDecimal}.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="900">
                <params>
                    <param name="val" type="BigInteger"/>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="906">
                Translates a {@code BigInteger} unscaled value and an{@code int} scale into a {@code BigDecimal}.  The value of
                  the {@code BigDecimal} is
                  &lt;tt&gt;(unscaledVal &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;.                
                <param>
                    unscaledVal unscaled value of the {@code BigDecimal}.                    
                </param>
                <param>
                    scale scale of the {@code BigDecimal}.                    
                </param>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="915">
                <params>
                    <param name="unscaledVal" type="BigInteger"/>
                    <param name="scale" type="int"/>
                </params>
                <comment line="917">
                    Negative scales are now allowed                    
                </comment>
            </method>
            <javadoc line="921">
                Translates a {@code BigInteger} unscaled value and an{@code int} scale into a {@code BigDecimal}, with rounding
                  according to the context settings.  The value of the{@code BigDecimal} is &lt;tt&gt;(unscaledVal &amp;times;
                  10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;, rounded according to the{@code precision} and rounding mode settings.                
                <param>
                    unscaledVal unscaled value of the {@code BigDecimal}.                    
                </param>
                <param>
                    scale scale of the {@code BigDecimal}.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="936">
                <params>
                    <param name="unscaledVal" type="BigInteger"/>
                    <param name="scale" type="int"/>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="943">
                Translates an {@code int} into a {@code BigDecimal}.  The
                  scale of the {@code BigDecimal} is zero.                
                <param>
                    val {@code int} value to be converted to{@code BigDecimal}.                    
                </param>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="951">
                <params>
                    <param name="val" type="int"/>
                </params>
            </method>
            <javadoc line="955">
                Translates an {@code int} into a {@code BigDecimal}, with
                  rounding according to the context settings.  The scale of the{@code BigDecimal}, before any rounding, is zero.                
                <param>
                    val {@code int} value to be converted to {@code BigDecimal}.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="966">
                <params>
                    <param name="val" type="int"/>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="972">
                Translates a {@code long} into a {@code BigDecimal}.  The
                  scale of the {@code BigDecimal} is zero.                
                <param>
                    val {@code long} value to be converted to {@code BigDecimal}.                    
                </param>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="979">
                <params>
                    <param name="val" type="long"/>
                </params>
            </method>
            <javadoc line="984">
                Translates a {@code long} into a {@code BigDecimal}, with
                  rounding according to the context settings.  The scale of the{@code BigDecimal}, before any rounding, is zero.                
                <param>
                    val {@code long} value to be converted to {@code BigDecimal}.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="BigDecimal" type="constructor" line="995">
                <params>
                    <param name="val" type="long"/>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="1003">
                Translates a {@code long} unscaled value and an{@code int} scale into a {@code BigDecimal}.  This{@literal &quot;static factory method&quot;} is provided in preference to
                  a ({@code long}, {@code int}) constructor because it
                  allows for reuse of frequently used {@code BigDecimal} values..                
                <param>
                    unscaledVal unscaled value of the {@code BigDecimal}.                    
                </param>
                <param>
                    scale scale of the {@code BigDecimal}.                    
                </param>
                <return>
                    a {@code BigDecimal} whose value is
                      <tt>(unscaledVal &times; 10<sup>-scale</sup>)</tt>.                    
                </return>
            </javadoc>
            <method name="valueOf" type="BigDecimal" line="1015">
                <params>
                    <param name="unscaledVal" type="long"/>
                    <param name="scale" type="int"/>
                </params>
                <scope line="1018"/>
            </method>
            <javadoc line="1029">
                Translates a {@code long} value into a {@code BigDecimal}with a scale of zero.  This {@literal &quot;static factory method&quot;}is provided in preference to a ({@code long}) constructor
                  because it allows for reuse of frequently used{@code BigDecimal} values.                
                <param>
                    val value of the {@code BigDecimal}.                    
                </param>
                <return>
                    a {@code BigDecimal} whose value is {@code val}.                    
                </return>
            </javadoc>
            <method name="valueOf" type="BigDecimal" line="1039">
                <params>
                    <param name="val" type="long"/>
                </params>
            </method>
            <javadoc line="1047">
                Translates a {@code double} into a {@code BigDecimal}, using
                  the {@code double}&apos;s canonical string representation provided
                  by the {@link Double#toString(double)} method.
                  &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This is generally the preferred way to convert
                  a {@code double} (or {@code float}) into a{@code BigDecimal}, as the value returned is equal to that
                  resulting from constructing a {@code BigDecimal} from the
                  result of using {@link Double#toString(double)}.                
                <param>
                    val {@code double} to convert to a {@code BigDecimal}.                    
                </param>
                <return>
                    a {@code BigDecimal} whose value is equal to or approximately
                      equal to the value of {@code val}.                    
                </return>
                <throws>
                    NumberFormatException if {@code val} is infinite or NaN.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="valueOf" type="BigDecimal" line="1064">
                <params>
                    <param name="val" type="double"/>
                </params>
                <comment line="1066">
                    Reminder: a zero double returns &apos;0.0&apos;, so we cannot fastpath
                     to use the constant ZERO.  This might be important enough to
                     justify a factory approach, a cache, or a few private
                     constants, later.                    
                </comment>
            </method>
            <javadoc line="1073">
                Returns a {@code BigDecimal} whose value is {@code (this +
                  augend)}, and whose scale is {@code max(this.scale(),
                  augend.scale())}.                
                <param>
                    augend value to be added to this {@code BigDecimal}.                    
                </param>
                <return>
                    {@code this + augend}                    
                </return>
            </javadoc>
            <method name="add" type="BigDecimal" line="1081">
                <params>
                    <param name="augend" type="BigDecimal"/>
                </params>
                <comment line="1106">
                    See &quot;Hacker&apos;s Delight&quot; section 2-12 for explanation of
                     the overflow test.                    
                </comment>
                <comment line="1108">
                    not overflowed                    
                </comment>
                <declaration name="xs" type="long" line="1082"/>
                <declaration name="ys" type="long" line="1083"/>
                <declaration name="fst" type="BigInteger" line="1084"/>
                <declaration name="snd" type="BigInteger" line="1085"/>
                <declaration name="rscale" type="int" line="1086"/>
                <declaration name="sdiff" type="long" line="1088"/>
                <scope line="1089">
                    <scope line="1090">
                        <declaration name="raise" type="int" line="1091"/>
                    </scope>
                    <scope line="1096">
                        <declaration name="raise" type="int" line="1097"/>
                    </scope>
                </scope>
                <scope line="1103">
                    <declaration name="sum" type="long" line="1104"/>
                </scope>
                <declaration name="sum" type="BigInteger" line="1114"/>
            </method>
            <javadoc line="1120">
                Returns a {@code BigDecimal} whose value is {@code (this + augend)},
                  with rounding according to the context settings.
                  If either number is zero and the precision setting is nonzero then
                  the other number, rounded if necessary, is used as the result.                
                <param>
                    augend value to be added to this {@code BigDecimal}.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    {@code this + augend}, rounded as necessary.                    
                </return>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="add" type="BigDecimal" line="1134">
                <params>
                    <param name="augend" type="BigDecimal"/>
                    <param name="mc" type="MathContext"/>
                </params>
                <comment line="1140">
                    Could optimize if values are compact                    
                </comment>
                <comment line="1144">
                    If either number is zero then the other number, rounded and
                     scaled if necessary, is used as the result.                    
                </comment>
                <comment line="1154">
                    Could use a factory for zero instead of a new object                    
                </comment>
                <comment line="1168">
                    result.scale &lt; preferredScale                    
                </comment>
                <comment line="1173">
                    can achieve target scale                    
                </comment>
                <comment line="1181">
                    scales differ; alignment needed                    
                </comment>
                <declaration name="lhs" type="BigDecimal" line="1137"/>
                <scope line="1145">
                    <declaration name="lhsIsZero" type="boolean" line="1146"/>
                    <declaration name="augendIsZero" type="boolean" line="1147"/>
                    <scope line="1149">
                        <declaration name="preferredScale" type="int" line="1150"/>
                        <declaration name="result" type="BigDecimal" line="1151"/>
                        <scope line="1161">
                            <declaration name="scaledResult" type="BigDecimal" line="1162"/>
                        </scope>
                        <scope line="1167">
                            <declaration name="precisionDiff" type="int" line="1168"/>
                            <declaration name="scaleDiff" type="int" line="1169"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="padding" type="long" line="1179"/>
                <scope line="1180">
                    <declaration name="arg" type="BigDecimal" line="1181"/>
                </scope>
                <declaration name="d" type="BigDecimal" line="1187"/>
            </method>
            <javadoc line="1192">
                Returns an array of length two, the sum of whose entries is
                  equal to the rounded sum of the {@code BigDecimal} arguments.
                  &lt;p&gt;If the digit positions of the arguments have a sufficient
                  gap between them, the value smaller in magnitude can be
                  condensed into a {@literal &quot;sticky bit&quot;} and the end result will
                  round the same way &lt;em&gt;if&lt;/em&gt; the precision of the final
                  result does not include the high order digit of the small
                  magnitude operand.
                  &lt;p&gt;Note that while strictly speaking this is an optimization,
                  it makes a much wider range of additions practical.
                  &lt;p&gt;This corresponds to a pre-shift operation in a fixed
                  precision floating-point adder; this method is complicated by
                  variable precision of the result as determined by the
                  MathContext.  A more nuanced operation could implement a{@literal &quot;right shift&quot;} on the smaller magnitude operand so
                  that the number of digits of the smaller operand could be
                  reduced even though the significands partially overlapped.                
            </javadoc>
            <method name="preAlign" type="BigDecimal[]" line="1215">
                <params>
                    <param name="lhs" type="BigDecimal"/>
                    <param name="augend" type="BigDecimal"/>
                    <param name="padding" type="long"/>
                    <param name="mc" type="MathContext"/>
                </params>
                <comment line="1221">
                    lhs is big;   augend is small                    
                </comment>
                <comment line="1224">
                    lhs is small; augend is big                    
                </comment>
                <comment line="1229">
                    This is the estimated scale of an ulp of the result; it
                     assumes that the result doesn&apos;t have a carry-out on a true
                     add (e.g. 999 + 1 =&gt; 1000) or any subtractive cancellation
                     on borrowing (e.g. 100 - 1.2 =&gt; 98.8)                    
                </comment>
                <comment line="1237">
                    The low-order digit position of big is big.scale().  This
                     is true regardless of whether big has a positive or
                     negative scale.  The high-order digit position of small is
                     small.scale - (small.precision() - 1).  To do the full
                     condensation, the digit positions of big and small must be
                     disjoint and the digit positions of small should not be
                     directly visible in the result.                    
                </comment>
                <comment line="1247">
                    big and small disjoint                    
                </comment>
                <comment line="1248">
                    small digits not visible                    
                </comment>
                <comment line="1253">
                    Since addition is symmetric, preserving input order in
                     returned operands doesn&apos;t matter                    
                </comment>
                <declaration name="big" type="BigDecimal" line="1217"/>
                <declaration name="small" type="BigDecimal" line="1218"/>
                <scope line="1220"/>
                <scope line="1223"/>
                <declaration name="estResultUlpScale" type="long" line="1234"/>
                <declaration name="smallHighDigitPos" type="long" line="1245"/>
                <scope line="1247"/>
                <declaration name="result" type="BigDecimal[]" line="1254"/>
            </method>
            <javadoc line="1258">
                Returns a {@code BigDecimal} whose value is {@code (this -
                  subtrahend)}, and whose scale is {@code max(this.scale(),
                  subtrahend.scale())}.                
                <param>
                    subtrahend value to be subtracted from this {@code BigDecimal}.                    
                </param>
                <return>
                    {@code this - subtrahend}                    
                </return>
            </javadoc>
            <method name="subtract" type="BigDecimal" line="1266">
                <params>
                    <param name="subtrahend" type="BigDecimal"/>
                </params>
            </method>
            <javadoc line="1270">
                Returns a {@code BigDecimal} whose value is {@code (this - subtrahend)},
                  with rounding according to the context settings.
                  If {@code subtrahend} is zero then this, rounded if necessary, is used as the
                  result.  If this is zero then the result is {@code subtrahend.negate(mc)}.                
                <param>
                    subtrahend value to be subtracted from this {@code BigDecimal}.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    {@code this - subtrahend}, rounded as necessary.                    
                </return>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="subtract" type="BigDecimal" line="1284">
                <params>
                    <param name="subtrahend" type="BigDecimal"/>
                    <param name="mc" type="MathContext"/>
                </params>
                <comment line="1289">
                    share the special rounding code in add()                    
                </comment>
                <declaration name="nsubtrahend" type="BigDecimal" line="1285"/>
            </method>
            <javadoc line="1292">
                Returns a {@code BigDecimal} whose value is &lt;tt&gt;(this &amp;times;
                  multiplicand)&lt;/tt&gt;, and whose scale is {@code (this.scale() +
                  multiplicand.scale())}.                
                <param>
                    multiplicand value to be multiplied by this {@code BigDecimal}.                    
                </param>
                <return>
                    {@code this  multiplicand}                    
                </return>
            </javadoc>
            <method name="multiply" type="BigDecimal" line="1300">
                <params>
                    <param name="multiplicand" type="BigDecimal"/>
                </params>
                <comment line="1306">
                    Might be able to do a more clever check incorporating the
                     inflated check into the overflow computation.                    
                </comment>
                <comment line="1309">
                    If the product is not an overflowed value, continue
                     to use the compact representation.  if either of x or y
                     is INFLATED, the product should also be regarded as
                     an overflow. Before using the overflow test suggested in
                     &quot;Hacker&apos;s Delight&quot; section 2-12, we perform quick checks
                     using the precision information to see whether the overflow
                     would occur since division is expensive on most CPUs.                    
                </comment>
                <declaration name="x" type="long" line="1301"/>
                <declaration name="y" type="long" line="1302"/>
                <declaration name="productScale" type="int" line="1303"/>
                <scope line="1307">
                    <declaration name="product" type="long" line="1317"/>
                    <declaration name="prec" type="long" line="1318"/>
                </scope>
                <declaration name="rb" type="BigInteger" line="1324"/>
            </method>
            <javadoc line="1334">
                Returns a {@code BigDecimal} whose value is &lt;tt&gt;(this &amp;times;
                  multiplicand)&lt;/tt&gt;, with rounding according to the context settings.                
                <param>
                    multiplicand value to be multiplied by this {@code BigDecimal}.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    {@code this  multiplicand}, rounded as necessary.                    
                </return>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="multiply" type="BigDecimal" line="1345">
                <params>
                    <param name="multiplicand" type="BigDecimal"/>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="1351">
                Returns a {@code BigDecimal} whose value is {@code (this /
                  divisor)}, and whose scale is as specified.  If rounding must
                  be performed to generate a result with the specified scale, the
                  specified rounding mode is applied.
                  &lt;p&gt;The new {@link #divide(BigDecimal,int,RoundingMode)} method
                  should be used in preference to this legacy method.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <param>
                    scale scale of the {@code BigDecimal} quotient to be returned.                    
                </param>
                <param>
                    roundingMode rounding mode to apply.                    
                </param>
                <return>
                    {@code this / divisor}                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor} is zero,{@code roundingMode==ROUND_UNNECESSARY} and
                      the specified scale is insufficient to represent the result
                      of the division exactly.                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code roundingMode} does not
                      represent a valid rounding mode.                    
                </throws>
                <see>
                    #ROUND_UP                    
                </see>
                <see>
                    #ROUND_DOWN                    
                </see>
                <see>
                    #ROUND_CEILING                    
                </see>
                <see>
                    #ROUND_FLOOR                    
                </see>
                <see>
                    #ROUND_HALF_UP                    
                </see>
                <see>
                    #ROUND_HALF_DOWN                    
                </see>
                <see>
                    #ROUND_HALF_EVEN                    
                </see>
                <see>
                    #ROUND_UNNECESSARY                    
                </see>
            </javadoc>
            <method name="divide" type="BigDecimal" line="1379">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                    <param name="scale" type="int"/>
                    <param name="roundingMode" type="int"/>
                </params>
                <comment line="1381">
                    IMPLEMENTATION NOTE: This method must return a new object
                     since divideAndRound uses divide to generate a value whose
                     scale is then modified.                    
                </comment>
                <comment line="1388">
                    Rescale dividend or divisor (whichever can be &quot;upscaled&quot; to
                     produce correctly scaled quotient).
                     Take care to detect out-of-range scales                    
                </comment>
                <declaration name="dividend" type="BigDecimal" line="1392"/>
            </method>
            <javadoc line="1403">
                Internally used for division operation. The dividend and divisor are
                  passed both in {@code long} format and {@code BigInteger} format. The
                  returned {@code BigDecimal} object is the quotient whose scale is set to
                  the passed in scale. If the remainder is not zero, it will be rounded
                  based on the passed in roundingMode. Also, if the remainder is zero and
                  the last parameter, i.e. preferredScale is NOT equal to scale, the
                  trailing zeros of the result is stripped to match the preferredScale.                
            </javadoc>
            <method name="divideAndRound" type="BigDecimal" line="1415">
                <params>
                    <param name="ldividend" type="long"/>
                    <param name="bdividend" type="BigInteger"/>
                    <param name="ldivisor" type="long"/>
                    <param name="bdivisor" type="BigInteger"/>
                    <param name="scale" type="int"/>
                    <param name="roundingMode" type="int"/>
                    <param name="preferredScale" type="int"/>
                </params>
                <comment line="1417">
                    record remainder is zero or not                    
                </comment>
                <comment line="1418">
                    quotient sign                    
                </comment>
                <comment line="1419">
                    store quotient &amp; remainder in long                    
                </comment>
                <comment line="1420">
                    store quotient                    
                </comment>
                <comment line="1421">
                    store remainder                    
                </comment>
                <comment line="1434">
                    Descend into mutables for faster remainder checks                    
                </comment>
                <comment line="1451">
                                        
                </comment>
                <comment line="1452">
                    Rounding prohibited                    
                </comment>
                <comment line="1454">
                    Away from zero                    
                </comment>
                <comment line="1456">
                    Towards zero                    
                </comment>
                <comment line="1458">
                    Towards +infinity                    
                </comment>
                <comment line="1460">
                    Towards -infinity                    
                </comment>
                <comment line="1465">
                    2 * r can&apos;t fit into long                    
                </comment>
                <comment line="1473">
                    We&apos;re closer to higher digit                    
                </comment>
                <comment line="1474">
                    We&apos;re closer to lower digit                    
                </comment>
                <comment line="1480">
                    roundingMode == ROUND_HALF_EVEN, true iff quotient is odd                    
                </comment>
                <declaration name="isRemainderZero" type="boolean" line="1416"/>
                <declaration name="qsign" type="int" line="1417"/>
                <declaration name="q" type="long" line="1418"/>
                <declaration name="mq" type="MutableBigInteger" line="1419"/>
                <declaration name="mr" type="MutableBigInteger" line="1420"/>
                <declaration name="mdivisor" type="MutableBigInteger" line="1421"/>
                <declaration name="isLongDivision" type="boolean" line="1422"/>
                <scope line="1423"/>
                <scope line="1430">
                    <declaration name="mdividend" type="MutableBigInteger" line="1434"/>
                    <scope line="1436"/>
                    <scope line="1440"/>
                </scope>
                <declaration name="increment" type="boolean" line="1447"/>
                <scope line="1448">
                    <declaration name="cmpFracHalf" type="int" line="1449"/>
                    <scope line="1451"/>
                    <scope line="1453"/>
                    <scope line="1455"/>
                    <scope line="1457"/>
                    <scope line="1459"/>
                    <scope line="1461">
                        <scope line="1462">
                            <scope line="1463"/>
                            <scope line="1465"/>
                        </scope>
                        <scope line="1468"/>
                    </scope>
                </scope>
                <declaration name="res" type="BigDecimal" line="1483"/>
                <scope line="1486"/>
            </method>
            <javadoc line="1496">
                Returns a {@code BigDecimal} whose value is {@code (this /
                  divisor)}, and whose scale is as specified.  If rounding must
                  be performed to generate a result with the specified scale, the
                  specified rounding mode is applied.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <param>
                    scale scale of the {@code BigDecimal} quotient to be returned.                    
                </param>
                <param>
                    roundingMode rounding mode to apply.                    
                </param>
                <return>
                    {@code this / divisor}                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor} is zero,{@code roundingMode==RoundingMode.UNNECESSARY} and
                      the specified scale is insufficient to represent the result
                      of the division exactly.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="divide" type="BigDecimal" line="1512">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                    <param name="scale" type="int"/>
                    <param name="roundingMode" type="RoundingMode"/>
                </params>
            </method>
            <javadoc line="1516">
                Returns a {@code BigDecimal} whose value is {@code (this /
                  divisor)}, and whose scale is {@code this.scale()}.  If
                  rounding must be performed to generate a result with the given
                  scale, the specified rounding mode is applied.
                  &lt;p&gt;The new {@link #divide(BigDecimal,RoundingMode)} method
                  should be used in preference to this legacy method.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <param>
                    roundingMode rounding mode to apply.                    
                </param>
                <return>
                    {@code this / divisor}                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor==0}, or{@code roundingMode==ROUND_UNNECESSARY} and{@code this.scale()} is insufficient to represent the result
                      of the division exactly.                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code roundingMode} does not
                      represent a valid rounding mode.                    
                </throws>
                <see>
                    #ROUND_UP                    
                </see>
                <see>
                    #ROUND_DOWN                    
                </see>
                <see>
                    #ROUND_CEILING                    
                </see>
                <see>
                    #ROUND_FLOOR                    
                </see>
                <see>
                    #ROUND_HALF_UP                    
                </see>
                <see>
                    #ROUND_HALF_DOWN                    
                </see>
                <see>
                    #ROUND_HALF_EVEN                    
                </see>
                <see>
                    #ROUND_UNNECESSARY                    
                </see>
            </javadoc>
            <method name="divide" type="BigDecimal" line="1543">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                    <param name="roundingMode" type="int"/>
                </params>
            </method>
            <javadoc line="1547">
                Returns a {@code BigDecimal} whose value is {@code (this /
                  divisor)}, and whose scale is {@code this.scale()}.  If
                  rounding must be performed to generate a result with the given
                  scale, the specified rounding mode is applied.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <param>
                    roundingMode rounding mode to apply.                    
                </param>
                <return>
                    {@code this / divisor}                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor==0}, or{@code roundingMode==RoundingMode.UNNECESSARY} and{@code this.scale()} is insufficient to represent the result
                      of the division exactly.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="divide" type="BigDecimal" line="1562">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                    <param name="roundingMode" type="RoundingMode"/>
                </params>
            </method>
            <javadoc line="1566">
                Returns a {@code BigDecimal} whose value is {@code (this /
                  divisor)}, and whose preferred scale is {@code (this.scale() -
                  divisor.scale())}; if the exact quotient cannot be
                  represented (because it has a non-terminating decimal
                  expansion) an {@code ArithmeticException} is thrown.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <throws>
                    ArithmeticException if the exact quotient does not have a
                      terminating decimal expansion                    
                </throws>
                <return>
                    {@code this / divisor}                    
                </return>
                <since>
                    1.5                    
                </since>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="divide" type="BigDecimal" line="1580">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                </params>
                <comment line="1582">
                    Handle zero cases first.                    
                </comment>
                <comment line="1585">
                    x/0                    
                </comment>
                <comment line="1586">
                    0/0                    
                </comment>
                <comment line="1587">
                    NaN                    
                </comment>
                <comment line="1591">
                    Calculate preferred scale                    
                </comment>
                <comment line="1593">
                    0/y                    
                </comment>
                <comment line="1601">
                    If the quotient thisdivisor has a terminating decimal
                     expansion, the expansion can have no more than
                     (a.precision() + ceil(10b.precision)3) digits.
                     Therefore, create a MathContext object with this
                     precision and do a divide with the UNNECESSARY rounding
                     mode.                    
                </comment>
                <comment line="1623">
                    divide(BigDecimal, mc) tries to adjust the quotient to
                     the desired one by removing trailing zeros; since the
                     exact divide method does not have an explicit digit
                     limit, we can add zeros too.                    
                </comment>
                <scope line="1584"/>
                <declaration name="preferredScale" type="int" line="1591"/>
                <scope line="1597">
                    <declaration name="mc" type="MathContext" line="1608"/>
                    <declaration name="quotient" type="BigDecimal" line="1612"/>
                    <scope line="1613"/>
                    <scope line="1615"/>
                    <declaration name="quotientScale" type="int" line="1620"/>
                </scope>
            </method>
            <javadoc line="1634">
                Returns a {@code BigDecimal} whose value is {@code (this /
                  divisor)}, with rounding according to the context settings.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    {@code this / divisor}, rounded as necessary.                    
                </return>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY} or{@code mc.precision == 0} and the quotient has a
                      non-terminating decimal expansion.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="divide" type="BigDecimal" line="1647">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                    <param name="mc" type="MathContext"/>
                </params>
                <comment line="1655">
                    Now calculate the answer.  We use the existing
                     divide-and-round method, but as this rounds to scale we have
                     to normalize the values here to achieve the desired result.
                     For x/y we first handle y=0 and x=0, and then normalize x and
                     y to give x&apos; and y&apos; with the following constraints:
                       (a) 0.1 &lt;= x&apos; &lt; 1
                       (b)  x&apos; &lt;= y&apos; &lt; 10*x&apos;
                     Dividing x&apos;/y&apos; with the required scale set to mc.precision then
                     will give a result in the range 0.1 to 1 rounded to exactly
                     the right number of digits (except in the case of a result of
                     1.000... which can arise when x=y, or when rounding overflows
                     The 1.000... case will reduce properly to 1.                    
                </comment>
                <comment line="1667">
                    x/0                    
                </comment>
                <comment line="1668">
                    0/0                    
                </comment>
                <comment line="1669">
                    NaN                    
                </comment>
                <comment line="1672">
                    0/y                    
                </comment>
                <comment line="1676">
                    Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]                    
                </comment>
                <comment line="1683">
                    satisfy constraint (b)                    
                </comment>
                <comment line="1684">
                    [that is, divisor *= 10]                    
                </comment>
                <comment line="1686">
                    In order to find out whether the divide generates the exact result,
                     we avoid calling the above divide method. &apos;quotient&apos; holds the
                     return BigDecimal object whose scale will be set to &apos;scl&apos;.                    
                </comment>
                <comment line="1700">
                    doRound, here, only affects 1000000000 case.                    
                </comment>
                <declaration name="mcp" type="int" line="1648"/>
                <declaration name="dividend" type="BigDecimal" line="1652"/>
                <declaration name="preferredScale" type="long" line="1653"/>
                <scope line="1666"/>
                <declaration name="xscale" type="int" line="1676"/>
                <declaration name="yscale" type="int" line="1677"/>
                <declaration name="quotient" type="BigDecimal" line="1688"/>
                <declaration name="scl" type="int" line="1689"/>
            </method>
            <javadoc line="1705">
                Returns a {@code BigDecimal} whose value is the integer part
                  of the quotient {@code (this / divisor)} rounded down.  The
                  preferred scale of the result is {@code (this.scale() -
                  divisor.scale())}.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <return>
                    The integer part of {@code this / divisor}.                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor==0}                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="divideToIntegralValue" type="BigDecimal" line="1716">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                </params>
                <comment line="1718">
                    Calculate preferred scale                    
                </comment>
                <comment line="1721">
                    much faster when this &lt;&lt; divisor                    
                </comment>
                <comment line="1728">
                    Perform a divide with enough digits to round to a correct
                     integer value; then remove any fractional digits                    
                </comment>
                <comment line="1743">
                    pad with zeros if necessary                    
                </comment>
                <declaration name="preferredScale" type="int" line="1718"/>
                <scope line="1719"/>
                <declaration name="maxDigits" type="int" line="1730"/>
                <declaration name="quotient" type="BigDecimal" line="1734"/>
                <scope line="1736"/>
                <scope line="1741"/>
            </method>
            <javadoc line="1748">
                Returns a {@code BigDecimal} whose value is the integer part
                  of {@code (this / divisor)}.  Since the integer part of the
                  exact quotient does not depend on the rounding mode, the
                  rounding mode does not affect the values returned by this
                  method.  The preferred scale of the result is{@code (this.scale() - divisor.scale())}.  An{@code ArithmeticException} is thrown if the integer part of
                  the exact quotient needs more than {@code mc.precision}digits.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    The integer part of {@code this / divisor}.                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor==0}                    
                </throws>
                <throws>
                    ArithmeticException if {@code mc.precision} {@literal >} 0 and the result
                      requires a precision of more than {@code mc.precision} digits.                    
                </throws>
                <since>
                    1.5                    
                </since>
                <author>
                    Joseph D. Darcy                    
                </author>
            </javadoc>
            <method name="divideToIntegralValue" type="BigDecimal" line="1768">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                    <param name="mc" type="MathContext"/>
                </params>
                <comment line="1770">
                    exact result                    
                </comment>
                <comment line="1771">
                    zero result                    
                </comment>
                <comment line="1774">
                    Calculate preferred scale                    
                </comment>
                <comment line="1777">
                    Perform a normal divide to mc.precision digits.  If the
                     remainder has absolute value less than the divisor, the
                     integer portion of the quotient fits into mc.precision
                     digits.  Next, remove any fractional digits from the
                     quotient and adjust the scale to the preferred value.                    
                </comment>
                <comment line="1788">
                    Result is an integer. See if quotient represents the
                     full integer portion of the exact quotient; if it does,
                     the computed remainder will be less than the divisor.                    
                </comment>
                <comment line="1794">
                    If the quotient is the full integer value,
                     |dividend-product| &lt; |divisor|.                    
                </comment>
                <comment line="1800">
                    Integer portion of quotient will fit into precision
                     digits; recompute quotient to scale 0 to avoid double
                     rounding and then try to adjust, if necessary.                    
                </comment>
                <comment line="1807">
                    else result.scale() == 0;                    
                </comment>
                <declaration name="preferredScale" type="int" line="1774"/>
                <declaration name="result" type="BigDecimal" line="1783"/>
                <scope line="1786">
                    <declaration name="product" type="BigDecimal" line="1792"/>
                    <scope line="1795"/>
                </scope>
                <scope line="1798"/>
                <declaration name="precisionDiff" type="int" line="1808"/>
                <scope line="1810"/>
                <scope line="1813"/>
            </method>
            <javadoc line="1819">
                Returns a {@code BigDecimal} whose value is {@code (this % divisor)}.
                  &lt;p&gt;The remainder is given by{@code this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))}.
                  Note that this is not the modulo operation (the result can be
                  negative).                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <return>
                    {@code this % divisor}.                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor==0}                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="remainder" type="BigDecimal" line="1832">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                </params>
                <declaration name="divrem" type="BigDecimal" line="1833"/>
            </method>
            <javadoc line="1838">
                Returns a {@code BigDecimal} whose value is {@code (this %
                  divisor)}, with rounding according to the context settings.
                  The {@code MathContext} settings affect the implicit divide
                  used to compute the remainder.  The remainder computation
                  itself is by definition exact.  Therefore, the remainder may
                  contain more than {@code mc.getPrecision()} digits.
                  &lt;p&gt;The remainder is given by{@code this.subtract(this.divideToIntegralValue(divisor,
                  mc).multiply(divisor))}.  Note that this is not the modulo
                  operation (the result can be negative).                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    {@code this % divisor}, rounded as necessary.                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor==0}                    
                </throws>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}, or {@code mc.precision}{@literal >} 0 and the result of {@code this.divideToIntgralValue(divisor)} would
                      require a precision of more than {@code mc.precision} digits.                    
                </throws>
                <see>
                    #divideToIntegralValue(java.math.BigDecimal,java.math.MathContext)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="remainder" type="BigDecimal" line="1862">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                    <param name="mc" type="MathContext"/>
                </params>
                <declaration name="divrem" type="BigDecimal" line="1863"/>
            </method>
            <javadoc line="1867">
                Returns a two-element {@code BigDecimal} array containing the
                  result of {@code divideToIntegralValue} followed by the result of{@code remainder} on the two operands.
                  &lt;p&gt;Note that if both the integer quotient and remainder are
                  needed, this method is faster than using the{@code divideToIntegralValue} and {@code remainder} methods
                  separately because the division need only be carried out once.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided,
                      and the remainder computed.                    
                </param>
                <return>
                    a two element {@code BigDecimal} array: the quotient
                      (the result of {@code divideToIntegralValue}) is the initial element
                      and the remainder is the final element.                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor==0}                    
                </throws>
                <see>
                    #divideToIntegralValue(java.math.BigDecimal,java.math.MathContext)                    
                </see>
                <see>
                    #remainder(java.math.BigDecimal,java.math.MathContext)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="divideAndRemainder" type="BigDecimal[]" line="1887">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                </params>
                <comment line="1889">
                    we use the identity  x = i * y + r to determine r                    
                </comment>
                <declaration name="result" type="BigDecimal[]" line="1889"/>
            </method>
            <javadoc line="1896">
                Returns a two-element {@code BigDecimal} array containing the
                  result of {@code divideToIntegralValue} followed by the result of{@code remainder} on the two operands calculated with rounding
                  according to the context settings.
                  &lt;p&gt;Note that if both the integer quotient and remainder are
                  needed, this method is faster than using the{@code divideToIntegralValue} and {@code remainder} methods
                  separately because the division need only be carried out once.                
                <param>
                    divisor value by which this {@code BigDecimal} is to be divided,
                      and the remainder computed.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    a two element {@code BigDecimal} array: the quotient
                      (the result of {@code divideToIntegralValue}) is the
                      initial element and the remainder is the final element.                    
                </return>
                <throws>
                    ArithmeticException if {@code divisor==0}                    
                </throws>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}, or {@code mc.precision}{@literal >} 0 and the result of {@code this.divideToIntgralValue(divisor)} would
                      require a precision of more than {@code mc.precision} digits.                    
                </throws>
                <see>
                    #divideToIntegralValue(java.math.BigDecimal,java.math.MathContext)                    
                </see>
                <see>
                    #remainder(java.math.BigDecimal,java.math.MathContext)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="divideAndRemainder" type="BigDecimal[]" line="1922">
                <params>
                    <param name="divisor" type="BigDecimal"/>
                    <param name="mc" type="MathContext"/>
                </params>
                <declaration name="result" type="BigDecimal[]" line="1926"/>
                <declaration name="lhs" type="BigDecimal" line="1927"/>
            </method>
            <javadoc line="1934">
                Returns a {@code BigDecimal} whose value is
                  &lt;tt&gt;(this&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;, The power is computed exactly, to
                  unlimited precision.
                  &lt;p&gt;The parameter {@code n} must be in the range 0 through
                  999999999, inclusive.  {@code ZERO.pow(0)} returns {@link #ONE}.
                  Note that future releases may expand the allowable exponent
                  range of this method.                
                <param>
                    n power to raise this {@code BigDecimal} to.                    
                </param>
                <return>
                    <tt>this<sup>n</sup></tt>                    
                </return>
                <throws>
                    ArithmeticException if {@code n} is out of range.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="pow" type="BigDecimal" line="1951">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="1955">
                    No need to calculate pow(n) if result will over/underflow.
                     Don&apos;t attempt to support &quot;supernormal&quot; numbers.                    
                </comment>
                <declaration name="newScale" type="int" line="1956"/>
            </method>
            <javadoc line="1962">
                Returns a {@code BigDecimal} whose value is
                  &lt;tt&gt;(this&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;.  The current implementation uses
                  the core algorithm defined in ANSI standard X3.274-1996 with
                  rounding according to the context settings.  In general, the
                  returned numerical value is within two ulps of the exact
                  numerical value for the chosen precision.  Note that future
                  releases may use a different algorithm with a decreased
                  allowable error bound and increased allowable exponent range.
                  &lt;p&gt;The X3.274-1996 algorithm is:
                  &lt;ul&gt;
                  &lt;li&gt; An {@code ArithmeticException} exception is thrown if
                  &lt;ul&gt;
                  &lt;li&gt;{@code abs(n) &gt; 999999999}&lt;li&gt;{@code mc.precision == 0} and {@code n &lt; 0}&lt;li&gt;{@code mc.precision &gt; 0} and {@code n} has more than{@code mc.precision} decimal digits
                  &lt;/ul&gt;
                  &lt;li&gt; if {@code n} is zero, {@link #ONE} is returned even if{@code this} is zero, otherwise
                  &lt;ul&gt;
                  &lt;li&gt; if {@code n} is positive, the result is calculated via
                  the repeated squaring technique into a single accumulator.
                  The individual multiplications with the accumulator use the
                  same math context settings as in {@code mc} except for a
                  precision increased to {@code mc.precision + elength + 1}where {@code elength} is the number of decimal digits in{@code n}.
                  &lt;li&gt; if {@code n} is negative, the result is calculated as if{@code n} were positive; this value is then divided into one
                  using the working precision specified above.
                  &lt;li&gt; The final value from either the positive or negative case
                  is then rounded to the destination precision.
                  &lt;/ul&gt;
                  &lt;/ul&gt;                
                <param>
                    n power to raise this {@code BigDecimal} to.                    
                </param>
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    <tt>this<sup>n</sup></tt> using the ANSI standard X3.274-1996
                      algorithm                    
                </return>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}, or {@code n} is out
                      of range.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="pow" type="BigDecimal" line="2012">
                <params>
                    <param name="n" type="int"/>
                    <param name="mc" type="MathContext"/>
                </params>
                <comment line="2019">
                    x**0 == 1 in X3.274                    
                </comment>
                <comment line="2022">
                    working settings                    
                </comment>
                <comment line="2023">
                    magnitude of n                    
                </comment>
                <comment line="2026">
                    length of n in digits                    
                </comment>
                <comment line="2027">
                    X3.274 rule                    
                </comment>
                <comment line="2032">
                    ready to carry out power calculation...                    
                </comment>
                <comment line="2033">
                    accumulator                    
                </comment>
                <comment line="2034">
                    set once we&apos;ve seen a 1-bit                    
                </comment>
                <comment line="2035">
                    for each bit [top bit ignored]                    
                </comment>
                <comment line="2036">
                    shift left 1 bit                    
                </comment>
                <comment line="2037">
                    top bit is set                    
                </comment>
                <comment line="2038">
                    OK, we&apos;re off                    
                </comment>
                <comment line="2039">
                    acc=acc*x                    
                </comment>
                <comment line="2042">
                    that was the last bit                    
                </comment>
                <comment line="2044">
                    acc=acc*acc [square]                    
                </comment>
                <comment line="2045">
                    else (!seenbit) no point in squaring ONE                    
                </comment>
                <comment line="2047">
                    if negative n, calculate the reciprocal using working precision                    
                </comment>
                <comment line="2048">
                    [hence mc.precision&gt;0]                    
                </comment>
                <comment line="2050">
                    round to final precision and strip zeros                    
                </comment>
                <declaration name="lhs" type="BigDecimal" line="2020"/>
                <declaration name="workmc" type="MathContext" line="2021"/>
                <declaration name="mag" type="int" line="2022"/>
                <scope line="2023">
                    <declaration name="elength" type="int" line="2025"/>
                </scope>
                <declaration name="acc" type="BigDecimal" line="2032"/>
                <declaration name="seenbit" type="boolean" line="2033"/>
                <scope line="2034">
                    <scope line="2036"/>
                </scope>
            </method>
            <javadoc line="2053">
                Returns a {@code BigDecimal} whose value is the absolute value
                  of this {@code BigDecimal}, and whose scale is{@code this.scale()}.                
                <return>
                    {@code abs(this)}                    
                </return>
            </javadoc>
            <method name="abs" type="BigDecimal" line="2060"/>
            <javadoc line="2064">
                Returns a {@code BigDecimal} whose value is the absolute value
                  of this {@code BigDecimal}, with rounding according to the
                  context settings.                
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    {@code abs(this)}, rounded as necessary.                    
                </return>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="abs" type="BigDecimal" line="2075">
                <params>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="2079">
                Returns a {@code BigDecimal} whose value is {@code (-this)},
                  and whose scale is {@code this.scale()}.                
                <return>
                    {@code -this}.                    
                </return>
            </javadoc>
            <method name="negate" type="BigDecimal" line="2085">
                <declaration name="result" type="BigDecimal" line="2086"/>
                <scope line="2089"/>
            </method>
            <javadoc line="2096">
                Returns a {@code BigDecimal} whose value is {@code (-this)},
                  with rounding according to the context settings.                
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    {@code -this}, rounded as necessary.                    
                </return>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="negate" type="BigDecimal" line="2106">
                <params>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="2110">
                Returns a {@code BigDecimal} whose value is {@code (+this)}, and whose
                  scale is {@code this.scale()}.
                  &lt;p&gt;This method, which simply returns this {@code BigDecimal}is included for symmetry with the unary minus method {@link #negate()}.                
                <return>
                    {@code this}.                    
                </return>
                <see>
                    #negate()                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="plus" type="BigDecimal" line="2122"/>
            <javadoc line="2126">
                Returns a {@code BigDecimal} whose value is {@code (+this)},
                  with rounding according to the context settings.
                  &lt;p&gt;The effect of this method is identical to that of the {@link #round(MathContext)} method.                
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    {@code this}, rounded as necessary.  A zero result will
                      have a scale of 0.                    
                </return>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
                <see>
                    #round(MathContext)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="plus" type="BigDecimal" line="2141">
                <params>
                    <param name="mc" type="MathContext"/>
                </params>
                <comment line="2143">
                    no rounding please                    
                </comment>
            </method>
            <javadoc line="2147">
                Returns the signum function of this {@code BigDecimal}.                
                <return>
                    -1, 0, or 1 as the value of this {@code BigDecimal}is negative, zero, or positive.                    
                </return>
            </javadoc>
            <method name="signum" type="int" line="2153"/>
            <javadoc line="2159">
                Returns the &lt;i&gt;scale&lt;/i&gt; of this {@code BigDecimal}.  If zero
                  or positive, the scale is the number of digits to the right of
                  the decimal point.  If negative, the unscaled value of the
                  number is multiplied by ten to the power of the negation of the
                  scale.  For example, a scale of {@code -3} means the unscaled
                  value is multiplied by 1000.                
                <return>
                    the scale of this {@code BigDecimal}.                    
                </return>
            </javadoc>
            <method name="scale" type="int" line="2169"/>
            <javadoc line="2173">
                Returns the &lt;i&gt;precision&lt;/i&gt; of this {@code BigDecimal}.  (The
                  precision is the number of digits in the unscaled value.)
                  &lt;p&gt;The precision of a zero value is 1.                
                <return>
                    the precision of this {@code BigDecimal}.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="precision" type="int" line="2182">
                <declaration name="result" type="int" line="2183"/>
                <scope line="2184">
                    <declaration name="s" type="long" line="2185"/>
                </scope>
            </method>
            <javadoc line="2196">
                Returns a {@code BigInteger} whose value is the &lt;i&gt;unscaled
                  value&lt;/i&gt; of this {@code BigDecimal}.  (Computes &lt;tt&gt;(this 
                  10&lt;sup&gt;this.scale()&lt;/sup&gt;)&lt;/tt&gt;.)                
                <return>
                    the unscaled value of this {@code BigDecimal}.                    
                </return>
                <since>
                    1.2                    
                </since>
            </javadoc>
            <method name="unscaledValue" type="BigInteger" line="2204"/>
            <declaration name="ROUND_UP" type="int" line="2210"/>
            <javadoc line="2210">
                Rounding mode to round away from zero.  Always increments the
                  digit prior to a nonzero discarded fraction.  Note that this rounding
                  mode never decreases the magnitude of the calculated value.                
            </javadoc>
            <declaration name="ROUND_DOWN" type="int" line="2217"/>
            <javadoc line="2217">
                Rounding mode to round towards zero.  Never increments the digit
                  prior to a discarded fraction (i.e., truncates).  Note that this
                  rounding mode never increases the magnitude of the calculated value.                
            </javadoc>
            <declaration name="ROUND_CEILING" type="int" line="2224"/>
            <javadoc line="2224">
                Rounding mode to round towards positive infinity.  If the{@code BigDecimal} is positive, behaves as for{@code ROUND_UP}; if negative, behaves as for{@code ROUND_DOWN}.  Note that this rounding mode never
                  decreases the calculated value.                
            </javadoc>
            <declaration name="ROUND_FLOOR" type="int" line="2233"/>
            <javadoc line="2233">
                Rounding mode to round towards negative infinity.  If the{@code BigDecimal} is positive, behave as for{@code ROUND_DOWN}; if negative, behave as for{@code ROUND_UP}.  Note that this rounding mode never
                  increases the calculated value.                
            </javadoc>
            <declaration name="ROUND_HALF_UP" type="int" line="2242"/>
            <javadoc line="2242">
                Rounding mode to round towards {@literal &quot;nearest neighbor&quot;}unless both neighbors are equidistant, in which case round up.
                  Behaves as for {@code ROUND_UP} if the discarded fraction is
                  &amp;ge; 0.5; otherwise, behaves as for {@code ROUND_DOWN}.  Note
                  that this is the rounding mode that most of us were taught in
                  grade school.                
            </javadoc>
            <declaration name="ROUND_HALF_DOWN" type="int" line="2252"/>
            <javadoc line="2252">
                Rounding mode to round towards {@literal &quot;nearest neighbor&quot;}unless both neighbors are equidistant, in which case round
                  down.  Behaves as for {@code ROUND_UP} if the discarded
                  fraction is {@literal &gt;} 0.5; otherwise, behaves as for{@code ROUND_DOWN}.                
            </javadoc>
            <declaration name="ROUND_HALF_EVEN" type="int" line="2261"/>
            <javadoc line="2261">
                Rounding mode to round towards the {@literal &quot;nearest neighbor&quot;}unless both neighbors are equidistant, in which case, round
                  towards the even neighbor.  Behaves as for{@code ROUND_HALF_UP} if the digit to the left of the
                  discarded fraction is odd; behaves as for{@code ROUND_HALF_DOWN} if it&apos;s even.  Note that this is the
                  rounding mode that minimizes cumulative error when applied
                  repeatedly over a sequence of calculations.                
            </javadoc>
            <declaration name="ROUND_UNNECESSARY" type="int" line="2273"/>
            <javadoc line="2273">
                Rounding mode to assert that the requested operation has an exact
                  result, hence no rounding is necessary.  If this rounding mode is
                  specified on an operation that yields an inexact result, an{@code ArithmeticException} is thrown.                
            </javadoc>
            <javadoc line="2284">
                Returns a {@code BigDecimal} rounded according to the{@code MathContext} settings.  If the precision setting is 0 then
                  no rounding takes place.
                  &lt;p&gt;The effect of this method is identical to that of the{@link #plus(MathContext)} method.                
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    a {@code BigDecimal} rounded according to the{@code MathContext} settings.                    
                </return>
                <throws>
                    ArithmeticException if the rounding mode is{@code UNNECESSARY} and the{@code BigDecimal}  operation would require rounding.                    
                </throws>
                <see>
                    #plus(MathContext)                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="round" type="BigDecimal" line="2301">
                <params>
                    <param name="mc" type="MathContext"/>
                </params>
            </method>
            <javadoc line="2305">
                Returns a {@code BigDecimal} whose scale is the specified
                  value, and whose unscaled value is determined by multiplying or
                  dividing this {@code BigDecimal}&apos;s unscaled value by the
                  appropriate power of ten to maintain its overall value.  If the
                  scale is reduced by the operation, the unscaled value must be
                  divided (rather than multiplied), and the value may be changed;
                  in this case, the specified rounding mode is applied to the
                  division.
                  &lt;p&gt;Note that since BigDecimal objects are immutable, calls of
                  this method do &lt;i&gt;not&lt;/i&gt; result in the original object being
                  modified, contrary to the usual convention of having methods
                  named &lt;tt&gt;set&lt;i&gt;X&lt;/i&gt;&lt;/tt&gt; mutate field &lt;i&gt;{@code X}&lt;/i&gt;.
                  Instead, {@code setScale} returns an object with the proper
                  scale; the returned object may or may not be newly allocated.                
                <param>
                    newScale scale of the {@code BigDecimal} value to be returned.                    
                </param>
                <param>
                    roundingMode The rounding mode to apply.                    
                </param>
                <return>
                    a {@code BigDecimal} whose scale is the specified value,
                      and whose unscaled value is determined by multiplying or
                      dividing this {@code BigDecimal}'s unscaled value by the
                      appropriate power of ten to maintain its overall value.                    
                </return>
                <throws>
                    ArithmeticException if {@code roundingMode==UNNECESSARY}and the specified scaling operation would require
                      rounding.                    
                </throws>
                <see>
                    RoundingMode                    
                </see>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="setScale" type="BigDecimal" line="2334">
                <params>
                    <param name="newScale" type="int"/>
                    <param name="roundingMode" type="RoundingMode"/>
                </params>
            </method>
            <javadoc line="2338">
                Returns a {@code BigDecimal} whose scale is the specified
                  value, and whose unscaled value is determined by multiplying or
                  dividing this {@code BigDecimal}&apos;s unscaled value by the
                  appropriate power of ten to maintain its overall value.  If the
                  scale is reduced by the operation, the unscaled value must be
                  divided (rather than multiplied), and the value may be changed;
                  in this case, the specified rounding mode is applied to the
                  division.
                  &lt;p&gt;Note that since BigDecimal objects are immutable, calls of
                  this method do &lt;i&gt;not&lt;/i&gt; result in the original object being
                  modified, contrary to the usual convention of having methods
                  named &lt;tt&gt;set&lt;i&gt;X&lt;/i&gt;&lt;/tt&gt; mutate field &lt;i&gt;{@code X}&lt;/i&gt;.
                  Instead, {@code setScale} returns an object with the proper
                  scale; the returned object may or may not be newly allocated.
                  &lt;p&gt;The new {@link #setScale(int,RoundingMode)} method should
                  be used in preference to this legacy method.                
                <param>
                    newScale scale of the {@code BigDecimal} value to be returned.                    
                </param>
                <param>
                    roundingMode The rounding mode to apply.                    
                </param>
                <return>
                    a {@code BigDecimal} whose scale is the specified value,
                      and whose unscaled value is determined by multiplying or
                      dividing this {@code BigDecimal}'s unscaled value by the
                      appropriate power of ten to maintain its overall value.                    
                </return>
                <throws>
                    ArithmeticException if {@code roundingMode==ROUND_UNNECESSARY}and the specified scaling operation would require
                      rounding.                    
                </throws>
                <throws>
                    IllegalArgumentException if {@code roundingMode} does not
                      represent a valid rounding mode.                    
                </throws>
                <see>
                    #ROUND_UP                    
                </see>
                <see>
                    #ROUND_DOWN                    
                </see>
                <see>
                    #ROUND_CEILING                    
                </see>
                <see>
                    #ROUND_FLOOR                    
                </see>
                <see>
                    #ROUND_HALF_UP                    
                </see>
                <see>
                    #ROUND_HALF_DOWN                    
                </see>
                <see>
                    #ROUND_HALF_EVEN                    
                </see>
                <see>
                    #ROUND_UNNECESSARY                    
                </see>
            </javadoc>
            <method name="setScale" type="BigDecimal" line="2378">
                <params>
                    <param name="newScale" type="int"/>
                    <param name="roundingMode" type="int"/>
                </params>
                <comment line="2384">
                    easy case                    
                </comment>
                <comment line="2386">
                    zero can have any scale                    
                </comment>
                <comment line="2399">
                    newScale &lt; oldScale -- drop some digits
                     Can&apos;t predict the precision due to the effect of rounding.                    
                </comment>
                <declaration name="oldScale" type="int" line="2382"/>
                <declaration name="rs" type="long" line="2388"/>
                <scope line="2389">
                    <declaration name="raise" type="int" line="2390"/>
                    <declaration name="rb" type="BigInteger" line="2391"/>
                </scope>
                <scope line="2397">
                    <declaration name="drop" type="int" line="2400"/>
                </scope>
            </method>
            <javadoc line="2412">
                Returns a {@code BigDecimal} whose scale is the specified
                  value, and whose value is numerically equal to this{@code BigDecimal}&apos;s.  Throws an {@code ArithmeticException}if this is not possible.
                  &lt;p&gt;This call is typically used to increase the scale, in which
                  case it is guaranteed that there exists a {@code BigDecimal}of the specified scale and the correct value.  The call can
                  also be used to reduce the scale if the caller knows that the{@code BigDecimal} has sufficiently many zeros at the end of
                  its fractional part (i.e., factors of ten in its integer value)
                  to allow for the rescaling without changing its value.
                  &lt;p&gt;This method returns the same result as the two-argument
                  versions of {@code setScale}, but saves the caller the trouble
                  of specifying a rounding mode in cases where it is irrelevant.
                  &lt;p&gt;Note that since {@code BigDecimal} objects are immutable,
                  calls of this method do &lt;i&gt;not&lt;/i&gt; result in the original
                  object being modified, contrary to the usual convention of
                  having methods named &lt;tt&gt;set&lt;i&gt;X&lt;/i&gt;&lt;/tt&gt; mutate field
                  &lt;i&gt;{@code X}&lt;/i&gt;.  Instead, {@code setScale} returns an
                  object with the proper scale; the returned object may or may
                  not be newly allocated.                
                <param>
                    newScale scale of the {@code BigDecimal} value to be returned.                    
                </param>
                <return>
                    a {@code BigDecimal} whose scale is the specified value, and
                      whose unscaled value is determined by multiplying or dividing
                      this {@code BigDecimal}'s unscaled value by the appropriate
                      power of ten to maintain its overall value.                    
                </return>
                <throws>
                    ArithmeticException if the specified scaling operation would
                      require rounding.                    
                </throws>
                <see>
                    #setScale(int,int)                    
                </see>
                <see>
                    #setScale(int,RoundingMode)                    
                </see>
            </javadoc>
            <method name="setScale" type="BigDecimal" line="2448">
                <params>
                    <param name="newScale" type="int"/>
                </params>
            </method>
            <javadoc line="2454">
                Returns a {@code BigDecimal} which is equivalent to this one
                  with the decimal point moved {@code n} places to the left.  If{@code n} is non-negative, the call merely adds {@code n} to
                  the scale.  If {@code n} is negative, the call is equivalent
                  to {@code movePointRight(-n)}.  The {@code BigDecimal}returned by this call has value &lt;tt&gt;(this &amp;times;
                  10&lt;sup&gt;-n&lt;/sup&gt;)&lt;/tt&gt; and scale {@code max(this.scale()+n,
                  0)}.                
                <param>
                    n number of places to move the decimal point to the left.                    
                </param>
                <return>
                    a {@code BigDecimal} which is equivalent to this one with the
                      decimal point moved {@code n} places to the left.                    
                </return>
                <throws>
                    ArithmeticException if scale overflows.                    
                </throws>
            </javadoc>
            <method name="movePointLeft" type="BigDecimal" line="2469">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="2471">
                    Cannot use movePointRight(-n) in case of n==Integer.MIN_VALUE                    
                </comment>
                <declaration name="newScale" type="int" line="2471"/>
                <declaration name="num" type="BigDecimal" line="2472"/>
            </method>
            <javadoc line="2476">
                Returns a {@code BigDecimal} which is equivalent to this one
                  with the decimal point moved {@code n} places to the right.
                  If {@code n} is non-negative, the call merely subtracts{@code n} from the scale.  If {@code n} is negative, the call
                  is equivalent to {@code movePointLeft(-n)}.  The{@code BigDecimal} returned by this call has value &lt;tt&gt;(this
                  &amp;times; 10&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt; and scale {@code max(this.scale()-n,
                  0)}.                
                <param>
                    n number of places to move the decimal point to the right.                    
                </param>
                <return>
                    a {@code BigDecimal} which is equivalent to this one
                      with the decimal point moved {@code n} places to the right.                    
                </return>
                <throws>
                    ArithmeticException if scale overflows.                    
                </throws>
            </javadoc>
            <method name="movePointRight" type="BigDecimal" line="2491">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="2493">
                    Cannot use movePointLeft(-n) in case of n==Integer.MIN_VALUE                    
                </comment>
                <declaration name="newScale" type="int" line="2493"/>
                <declaration name="num" type="BigDecimal" line="2494"/>
            </method>
            <javadoc line="2498">
                Returns a BigDecimal whose numerical value is equal to
                  ({@code this}  10&lt;sup&gt;n&lt;/sup&gt;).  The scale of
                  the result is {@code (this.scale() - n)}.                
                <throws>
                    ArithmeticException if the scale would be
                      outside the range of a 32-bit integer.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="scaleByPowerOfTen" type="BigDecimal" line="2508">
                <params>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="2513">
                Returns a {@code BigDecimal} which is numerically equal to
                  this one but with any trailing zeros removed from the
                  representation.  For example, stripping the trailing zeros from
                  the {@code BigDecimal} value {@code 600.0}, which has
                  [{@code BigInteger}, {@code scale}] components equals to
                  [6000, 1], yields {@code 6E2} with [{@code BigInteger},{@code scale}] components equals to [6, -2]                
                <return>
                    a numerically equal {@code BigDecimal} with any
                      trailing zeros removed.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="stripTrailingZeros" type="BigDecimal" line="2526">
                <declaration name="result" type="BigDecimal" line="2528"/>
            </method>
            <javadoc line="2535">
                Compares this {@code BigDecimal} with the specified{@code BigDecimal}.  Two {@code BigDecimal} objects that are
                  equal in value but have a different scale (like 2.0 and 2.00)
                  are considered equal by this method.  This method is provided
                  in preference to individual methods for each of the six boolean
                  comparison operators ({@literal &lt;}, ==,{@literal &gt;}, {@literal &gt;=}, !=, {@literal &lt;=}).  The
                  suggested idiom for performing these comparisons is:{@code (x.compareTo(y)} &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; {@code 0)}, where
                  &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; is one of the six comparison operators.                
                <param>
                    val {@code BigDecimal} to which this {@code BigDecimal} is
                      to be compared.                    
                </param>
                <return>
                    -1, 0, or 1 as this {@code BigDecimal} is numerically
                      less than, equal to, or greater than {@code val}.                    
                </return>
            </javadoc>
            <method name="compareTo" type="int" line="2552">
                <params>
                    <param name="val" type="BigDecimal"/>
                </params>
                <comment line="2554">
                    Quick path for equal scale and non-inflated case.                    
                </comment>
                <scope line="2554">
                    <declaration name="xs" type="long" line="2555"/>
                    <declaration name="ys" type="long" line="2556"/>
                </scope>
                <declaration name="xsign" type="int" line="2560"/>
                <declaration name="ysign" type="int" line="2561"/>
                <declaration name="cmp" type="int" line="2566"/>
            </method>
            <javadoc line="2570">
                Version of compareTo that ignores sign.                
            </javadoc>
            <method name="compareMagnitude" type="int" line="2573">
                <params>
                    <param name="val" type="BigDecimal"/>
                </params>
                <comment line="2575">
                    Match scales, avoid unnecessary inflation                    
                </comment>
                <comment line="2585">
                    Avoid matching scales if the (adjusted) exponents differ                    
                </comment>
                <comment line="2586">
                    [-1]                    
                </comment>
                <comment line="2587">
                    [-1]                    
                </comment>
                <comment line="2600">
                    sdiff &gt; 0                    
                </comment>
                <declaration name="ys" type="long" line="2575"/>
                <declaration name="xs" type="long" line="2576"/>
                <declaration name="sdiff" type="int" line="2582"/>
                <scope line="2583">
                    <declaration name="xae" type="int" line="2585"/>
                    <declaration name="yae" type="int" line="2586"/>
                    <declaration name="rb" type="BigInteger" line="2591"/>
                    <scope line="2592">
                        <scope line="2595"/>
                    </scope>
                    <scope line="2599">
                        <scope line="2602"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2616">
                Compares this {@code BigDecimal} with the specified{@code Object} for equality.  Unlike {@link #compareTo(BigDecimal) compareTo}, this method considers two{@code BigDecimal} objects equal only if they are equal in
                  value and scale (thus 2.0 is not equal to 2.00 when compared by
                  this method).                
                <param>
                    x {@code Object} to which this {@code BigDecimal} is
                      to be compared.                    
                </param>
                <return>
                    {@code true} if and only if the specified {@code Object} is a{@code BigDecimal} whose value and scale are equal to this{@code BigDecimal}'s.                    
                </return>
                <see>
                    #compareTo(java.math.BigDecimal)                    
                </see>
                <see>
                    #hashCode                    
                </see>
            </javadoc>
            <method name="equals" type="boolean" line="2633">
                <params>
                    <param name="x" type="Object"/>
                </params>
                <declaration name="xDec" type="BigDecimal" line="2636"/>
                <declaration name="s" type="long" line="2641"/>
                <declaration name="xs" type="long" line="2642"/>
                <scope line="2643"/>
            </method>
            <javadoc line="2653">
                Returns the minimum of this {@code BigDecimal} and{@code val}.                
                <param>
                    val value with which the minimum is to be computed.                    
                </param>
                <return>
                    the {@code BigDecimal} whose value is the lesser of this{@code BigDecimal} and {@code val}.  If they are equal,
                      as defined by the {@link #compareTo(BigDecimal) compareTo}method, {@code this} is returned.                    
                </return>
                <see>
                    #compareTo(java.math.BigDecimal)                    
                </see>
            </javadoc>
            <method name="min" type="BigDecimal" line="2664">
                <params>
                    <param name="val" type="BigDecimal"/>
                </params>
            </method>
            <javadoc line="2668">
                Returns the maximum of this {@code BigDecimal} and {@code val}.                
                <param>
                    val value with which the maximum is to be computed.                    
                </param>
                <return>
                    the {@code BigDecimal} whose value is the greater of this{@code BigDecimal} and {@code val}.  If they are equal,
                      as defined by the {@link #compareTo(BigDecimal) compareTo}method, {@code this} is returned.                    
                </return>
                <see>
                    #compareTo(java.math.BigDecimal)                    
                </see>
            </javadoc>
            <method name="max" type="BigDecimal" line="2678">
                <params>
                    <param name="val" type="BigDecimal"/>
                </params>
            </method>
            <javadoc line="2684">
                Returns the hash code for this {@code BigDecimal}.  Note that
                  two {@code BigDecimal} objects that are numerically equal but
                  differ in scale (like 2.0 and 2.00) will generally &lt;i&gt;not&lt;/i&gt;
                  have the same hash code.                
                <return>
                    hash code for this {@code BigDecimal}.                    
                </return>
                <see>
                    #equals(Object)                    
                </see>
            </javadoc>
            <method name="hashCode" type="int" line="2694">
                <scope line="2695">
                    <declaration name="val2" type="long" line="2696"/>
                    <declaration name="temp" type="int" line="2697"/>
                </scope>
            </method>
            <javadoc line="2706">
                Returns the string representation of this {@code BigDecimal},
                  using scientific notation if an exponent is needed.
                  &lt;p&gt;A standard canonical string form of the {@code BigDecimal}is created as though by the following steps: first, the
                  absolute value of the unscaled value of the {@code BigDecimal}is converted to a string in base ten using the characters{@code &apos;0&apos;} through {@code &apos;9&apos;} with no leading zeros (except
                  if its value is zero, in which case a single {@code &apos;0&apos;}character is used).
                  &lt;p&gt;Next, an &lt;i&gt;adjusted exponent&lt;/i&gt; is calculated; this is the
                  negated scale, plus the number of characters in the converted
                  unscaled value, less one.  That is,{@code -scale+(ulength-1)}, where {@code ulength} is the
                  length of the absolute value of the unscaled value in decimal
                  digits (its &lt;i&gt;precision&lt;/i&gt;).
                  &lt;p&gt;If the scale is greater than or equal to zero and the
                  adjusted exponent is greater than or equal to {@code -6}, the
                  number will be converted to a character form without using
                  exponential notation.  In this case, if the scale is zero then
                  no decimal point is added and if the scale is positive a
                  decimal point will be inserted with the scale specifying the
                  number of characters to the right of the decimal point.{@code &apos;0&apos;} characters are added to the left of the converted
                  unscaled value as necessary.  If no character precedes the
                  decimal point after this insertion then a conventional{@code &apos;0&apos;} character is prefixed.
                  &lt;p&gt;Otherwise (that is, if the scale is negative, or the
                  adjusted exponent is less than {@code -6}), the number will be
                  converted to a character form using exponential notation.  In
                  this case, if the converted {@code BigInteger} has more than
                  one digit a decimal point is inserted after the first digit.
                  An exponent in character form is then suffixed to the converted
                  unscaled value (perhaps with inserted decimal point); this
                  comprises the letter {@code &apos;E&apos;} followed immediately by the
                  adjusted exponent converted to a character form.  The latter is
                  in base ten, using the characters {@code &apos;0&apos;} through{@code &apos;9&apos;} with no leading zeros, and is always prefixed by a
                  sign character {@code &apos;-&apos;} (&lt;tt&gt;&apos;&amp;#92;u002D&apos;&lt;/tt&gt;) if the
                  adjusted exponent is negative, {@code &apos;+&apos;}(&lt;tt&gt;&apos;&amp;#92;u002B&apos;&lt;/tt&gt;) otherwise).
                  &lt;p&gt;Finally, the entire string is prefixed by a minus sign
                  character {@code &apos;-&apos;} (&lt;tt&gt;&apos;&amp;#92;u002D&apos;&lt;/tt&gt;) if the unscaled
                  value is less than zero.  No sign character is prefixed if the
                  unscaled value is zero or positive.
                  &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;
                  &lt;p&gt;For each representation [&lt;i&gt;unscaled value&lt;/i&gt;, &lt;i&gt;scale&lt;/i&gt;]
                  on the left, the resulting string is shown on the right.
                  &lt;pre&gt;
                  [123,0]      &quot;123&quot;
                  [-123,0]     &quot;-123&quot;
                  [123,-1]     &quot;1.23E+3&quot;
                  [123,-3]     &quot;1.23E+5&quot;
                  [123,1]      &quot;12.3&quot;
                  [123,5]      &quot;0.00123&quot;
                  [123,10]     &quot;1.23E-8&quot;
                  [-123,12]    &quot;-1.23E-10&quot;
                  &lt;/pre&gt;
                  &lt;b&gt;Notes:&lt;/b&gt;
                  &lt;ol&gt;
                  &lt;li&gt;There is a one-to-one mapping between the distinguishable{@code BigDecimal} values and the result of this conversion.
                  That is, every distinguishable {@code BigDecimal} value
                  (unscaled value and scale) has a unique string representation
                  as a result of using {@code toString}.  If that string
                  representation is converted back to a {@code BigDecimal} using
                  the {@link #BigDecimal(String)} constructor, then the original
                  value will be recovered.
                  &lt;li&gt;The string produced for a given number is always the same;
                  it is not affected by locale.  This means that it can be used
                  as a canonical string representation for exchanging decimal
                  data, or as a key for a Hashtable, etc.  Locale-sensitive
                  number formatting and parsing is handled by the {@link java.text.NumberFormat} class and its subclasses.
                  &lt;li&gt;The {@link #toEngineeringString} method may be used for
                  presenting numbers with exponents in engineering notation, and the{@link #setScale(int,RoundingMode) setScale} method may be used for
                  rounding a {@code BigDecimal} so it has a known number of digits after
                  the decimal point.
                  &lt;li&gt;The digit-to-character mapping provided by{@code Character.forDigit} is used.
                  &lt;/ol&gt;                
                <return>
                    string representation of this {@code BigDecimal}.                    
                </return>
                <see>
                    Character#forDigit                    
                </see>
                <see>
                    #BigDecimal(java.lang.String)                    
                </see>
            </javadoc>
            <method name="toString" type="String" line="2806">
                <declaration name="sc" type="String" line="2807"/>
            </method>
            <javadoc line="2813">
                Returns a string representation of this {@code BigDecimal},
                  using engineering notation if an exponent is needed.
                  &lt;p&gt;Returns a string that represents the {@code BigDecimal} as
                  described in the {@link #toString()} method, except that if
                  exponential notation is used, the power of ten is adjusted to
                  be a multiple of three (engineering notation) such that the
                  integer part of nonzero values will be in the range 1 through
                  999.  If exponential notation is used for zero values, a
                  decimal point and one or two fractional zero digits are used so
                  that the scale of the zero value is preserved.  Note that
                  unlike the output of {@link #toString()}, the output of this
                  method is &lt;em&gt;not&lt;/em&gt; guaranteed to recover the same [integer,
                  scale] pair of this {@code BigDecimal} if the output string is
                  converting back to a {@code BigDecimal} using the {@linkplain #BigDecimal(String) string constructor}.  The result of this method meets
                  the weaker constraint of always producing a numerically equal
                  result from applying the string constructor to the method&apos;s output.                
                <return>
                    string representation of this {@code BigDecimal}, using
                      engineering notation if an exponent is needed.                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toEngineeringString" type="String" line="2837"/>
            <javadoc line="2841">
                Returns a string representation of this {@code BigDecimal}without an exponent field.  For values with a positive scale,
                  the number of digits to the right of the decimal point is used
                  to indicate scale.  For values with a zero or negative scale,
                  the resulting string is generated as if the value were
                  converted to a numerically equal value with zero scale and as
                  if all the trailing zeros of the zero scale value were present
                  in the result.
                  The entire string is prefixed by a minus sign character &apos;-&apos;
                  (&lt;tt&gt;&apos;&amp;#92;u002D&apos;&lt;/tt&gt;) if the unscaled value is less than
                  zero. No sign character is prefixed if the unscaled value is
                  zero or positive.
                  Note that if the result of this method is passed to the{@linkplain #BigDecimal(String) string constructor}, only the
                  numerical value of this {@code BigDecimal} will necessarily be
                  recovered; the representation of the new {@code BigDecimal}may have a different scale.  In particular, if this{@code BigDecimal} has a negative scale, the string resulting
                  from this method will have a scale of zero when processed by
                  the string constructor.
                  (This method behaves analogously to the {@code toString}method in 1.4 and earlier releases.)                
                <return>
                    a string representation of this {@code BigDecimal}without an exponent field.                    
                </return>
                <since>
                    1.5                    
                </since>
                <see>
                    #toString()                    
                </see>
                <see>
                    #toEngineeringString()                    
                </see>
            </javadoc>
            <method name="toPlainString" type="String" line="2874">
                <comment line="2880">
                    No decimal point                    
                </comment>
                <declaration name="bd" type="BigDecimal" line="2875"/>
            </method>
            <method name="getValueString" type="String" line="2885">
                <params>
                    <param name="signum" type="int"/>
                    <param name="intString" type="String"/>
                    <param name="scale" type="int"/>
                </params>
                <comment line="2887">
                                        
                </comment>
                <comment line="2890">
                                        
                </comment>
                <comment line="2892">
                                        
                </comment>
                <comment line="2897">
                                        
                </comment>
                <declaration name="buf" type="StringBuilder" line="2887"/>
                <declaration name="insertionPoint" type="int" line="2888"/>
                <scope line="2889"/>
                <scope line="2891"/>
                <scope line="2896"/>
            </method>
            <javadoc line="2906">
                Converts this {@code BigDecimal} to a {@code BigInteger}.
                  This conversion is analogous to the
                  &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to{@code long} as defined in section 5.1.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
                  any fractional part of this{@code BigDecimal} will be discarded.  Note that this
                  conversion can lose information about the precision of the{@code BigDecimal} value.
                  &lt;p&gt;
                  To have an exception thrown if the conversion is inexact (in
                  other words if a nonzero fractional part is discarded), use the{@link #toBigIntegerExact()} method.                
                <return>
                    this {@code BigDecimal} converted to a {@code BigInteger}.                    
                </return>
            </javadoc>
            <method name="toBigInteger" type="BigInteger" line="2923">
                <comment line="2925">
                    force to an integer, quietly                    
                </comment>
            </method>
            <javadoc line="2928">
                Converts this {@code BigDecimal} to a {@code BigInteger},
                  checking for lost information.  An exception is thrown if this{@code BigDecimal} has a nonzero fractional part.                
                <return>
                    this {@code BigDecimal} converted to a {@code BigInteger}.                    
                </return>
                <throws>
                    ArithmeticException if {@code this} has a nonzero
                      fractional part.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="toBigIntegerExact" type="BigInteger" line="2938">
                <comment line="2940">
                    round to an integer, with Exception if decimal part non-0                    
                </comment>
            </method>
            <javadoc line="2943">
                Converts this {@code BigDecimal} to a {@code long}.
                  This conversion is analogous to the
                  &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to{@code short} as defined in section 5.1.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
                  any fractional part of this{@code BigDecimal} will be discarded, and if the resulting
                  &quot;{@code BigInteger}&quot; is too big to fit in a{@code long}, only the low-order 64 bits are returned.
                  Note that this conversion can lose information about the
                  overall magnitude and precision of this {@code BigDecimal} value as well
                  as return a result with the opposite sign.                
                <return>
                    this {@code BigDecimal} converted to a {@code long}.                    
                </return>
            </javadoc>
            <method name="longValue" type="long" line="2959"/>
            <javadoc line="2965">
                Converts this {@code BigDecimal} to a {@code long}, checking
                  for lost information.  If this {@code BigDecimal} has a
                  nonzero fractional part or is out of the possible range for a{@code long} result then an {@code ArithmeticException} is
                  thrown.                
                <return>
                    this {@code BigDecimal} converted to a {@code long}.                    
                </return>
                <throws>
                    ArithmeticException if {@code this} has a nonzero
                      fractional part, or will not fit in a {@code long}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="longValueExact" type="long" line="2977">
                <comment line="2981">
                    If more than 19 digits in integer part it cannot possibly fit                    
                </comment>
                <comment line="2982">
                    [OK for negative scale too]                    
                </comment>
                <comment line="2984">
                    Fastpath zero and &lt; 1.0 numbers (the latter can be very slow
                     to round if very small)                    
                </comment>
                <comment line="2990">
                    round to an integer, with Exception if decimal part non-0                    
                </comment>
                <comment line="2992">
                    need to check carefully                    
                </comment>
                <declaration name="num" type="BigDecimal" line="2990"/>
            </method>
            <class name="LongOverflow" line="2996">
                <comment line="3167">
                    Placeholder for BigDecimal string                    
                </comment>
                <comment line="3168">
                    character array to place the intCompact                    
                </comment>
                <comment line="3176">
                    Accessors.                    
                </comment>
                <declaration name="LONGMIN" type="BigInteger" line="2997"/>
                <javadoc line="2997">
                    BigInteger equal to Long.MIN_VALUE.                    
                </javadoc>
                <declaration name="LONGMAX" type="BigInteger" line="3000"/>
                <javadoc line="3000">
                    BigInteger equal to Long.MAX_VALUE.                    
                </javadoc>
                <method name="check" type="void" line="3003">
                    <params>
                        <param name="num" type="BigDecimal"/>
                    </params>
                </method>
            </class>
            <javadoc line="3011">
                Converts this {@code BigDecimal} to an {@code int}.
                  This conversion is analogous to the
                  &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to{@code short} as defined in section 5.1.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
                  any fractional part of this{@code BigDecimal} will be discarded, and if the resulting
                  &quot;{@code BigInteger}&quot; is too big to fit in an{@code int}, only the low-order 32 bits are returned.
                  Note that this conversion can lose information about the
                  overall magnitude and precision of this {@code BigDecimal}value as well as return a result with the opposite sign.                
                <return>
                    this {@code BigDecimal} converted to an {@code int}.                    
                </return>
            </javadoc>
            <method name="intValue" type="int" line="3027"/>
            <javadoc line="3033">
                Converts this {@code BigDecimal} to an {@code int}, checking
                  for lost information.  If this {@code BigDecimal} has a
                  nonzero fractional part or is out of the possible range for an{@code int} result then an {@code ArithmeticException} is
                  thrown.                
                <return>
                    this {@code BigDecimal} converted to an {@code int}.                    
                </return>
                <throws>
                    ArithmeticException if {@code this} has a nonzero
                      fractional part, or will not fit in an {@code int}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="intValueExact" type="int" line="3045">
                <comment line="3048">
                    will check decimal part                    
                </comment>
                <declaration name="num" type="long" line="3046"/>
            </method>
            <javadoc line="3053">
                Converts this {@code BigDecimal} to a {@code short}, checking
                  for lost information.  If this {@code BigDecimal} has a
                  nonzero fractional part or is out of the possible range for a{@code short} result then an {@code ArithmeticException} is
                  thrown.                
                <return>
                    this {@code BigDecimal} converted to a {@code short}.                    
                </return>
                <throws>
                    ArithmeticException if {@code this} has a nonzero
                      fractional part, or will not fit in a {@code short}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="shortValueExact" type="short" line="3065">
                <comment line="3068">
                    will check decimal part                    
                </comment>
                <declaration name="num" type="long" line="3066"/>
            </method>
            <javadoc line="3073">
                Converts this {@code BigDecimal} to a {@code byte}, checking
                  for lost information.  If this {@code BigDecimal} has a
                  nonzero fractional part or is out of the possible range for a{@code byte} result then an {@code ArithmeticException} is
                  thrown.                
                <return>
                    this {@code BigDecimal} converted to a {@code byte}.                    
                </return>
                <throws>
                    ArithmeticException if {@code this} has a nonzero
                      fractional part, or will not fit in a {@code byte}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="byteValueExact" type="byte" line="3085">
                <comment line="3088">
                    will check decimal part                    
                </comment>
                <declaration name="num" type="long" line="3086"/>
            </method>
            <javadoc line="3093">
                Converts this {@code BigDecimal} to a {@code float}.
                  This conversion is similar to the
                  &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to{@code float} as defined in section 5.1.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
                  if this {@code BigDecimal} has too great a
                  magnitude to represent as a {@code float}, it will be
                  converted to {@link Float#NEGATIVE_INFINITY} or {@link Float#POSITIVE_INFINITY} as appropriate.  Note that even when
                  the return value is finite, this conversion can lose
                  information about the precision of the {@code BigDecimal}value.                
                <return>
                    this {@code BigDecimal} converted to a {@code float}.                    
                </return>
            </javadoc>
            <method name="floatValue" type="float" line="3109">
                <comment line="3113">
                    Somewhat inefficient, but guaranteed to work.                    
                </comment>
            </method>
            <javadoc line="3116">
                Converts this {@code BigDecimal} to a {@code double}.
                  This conversion is similar to the
                  &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to{@code float} as defined in section 5.1.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
                  if this {@code BigDecimal} has too great a
                  magnitude represent as a {@code double}, it will be
                  converted to {@link Double#NEGATIVE_INFINITY} or {@link Double#POSITIVE_INFINITY} as appropriate.  Note that even when
                  the return value is finite, this conversion can lose
                  information about the precision of the {@code BigDecimal}value.                
                <return>
                    this {@code BigDecimal} converted to a {@code double}.                    
                </return>
            </javadoc>
            <method name="doubleValue" type="double" line="3132">
                <comment line="3136">
                    Somewhat inefficient, but guaranteed to work.                    
                </comment>
            </method>
            <javadoc line="3139">
                Returns the size of an ulp, a unit in the last place, of this{@code BigDecimal}.  An ulp of a nonzero {@code BigDecimal}value is the positive distance between this value and the{@code BigDecimal} value next larger in magnitude with the
                  same number of digits.  An ulp of a zero value is numerically
                  equal to 1 with the scale of {@code this}.  The result is
                  stored with the same scale as {@code this} so the result
                  for zero and nonzero values is equal to {@code [1,
                  this.scale()]}.                
                <return>
                    the size of an ulp of {@code this}                    
                </return>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="ulp" type="BigDecimal" line="3153"/>
            <class name="StringBuilderHelper" line="3165">
                <comment line="3167">
                    Placeholder for BigDecimal string                    
                </comment>
                <comment line="3168">
                    character array to place the intCompact                    
                </comment>
                <comment line="3176">
                    Accessors.                    
                </comment>
                <declaration name="sb" type="StringBuilder" line="3166"/>
                <declaration name="cmpCharArray" type="char[]" line="3167"/>
                <method name="StringBuilderHelper" type="constructor" line="3169">
                    <comment line="3172">
                        All non negative longs can be made to fit into 19 character array.                        
                    </comment>
                </method>
                <method name="getStringBuilder" type="StringBuilder" line="3176"/>
                <method name="getCompactCharArray" type="char[]" line="3181"/>
                <javadoc line="3185">
                    Places characters representing the intCompact in {@code long} into
                      cmpCharArray and returns the offset to the array where the
                      representation starts.                    
                    <param>
                        intCompact the number to put into the cmpCharArray.                        
                    </param>
                    <return>
                        offset to the array where the representation starts.
                          Note: intCompact must be greater or equal to zero.                        
                    </return>
                </javadoc>
                <method name="putIntCompact" type="int" line="3194">
                    <params>
                        <param name="intCompact" type="long"/>
                    </params>
                    <comment line="3200">
                        since we start from the least significant digit, charPos points to
                         the last character in cmpCharArray.                        
                    </comment>
                    <comment line="3204">
                        Get 2 digits/iteration using longs until quotient fits into an int                        
                    </comment>
                    <comment line="3213">
                        Get 2 digits/iteration using ints when i2 &gt;= 100                        
                    </comment>
                    <declaration name="q" type="long" line="3197"/>
                    <declaration name="r" type="int" line="3198"/>
                    <declaration name="charPos" type="int" line="3201"/>
                    <scope line="3204"/>
                    <declaration name="q2" type="int" line="3213"/>
                    <declaration name="i2" type="int" line="3214"/>
                    <scope line="3215"/>
                </method>
                <declaration name="DIGIT_TENS" type="char[]" line="3230"/>
                <declaration name="DIGIT_ONES" type="char[]" line="3243"/>
            </class>
            <javadoc line="3257">
                Lay out this {@code BigDecimal} into a {@code char[]} array.
                  The Java 1.2 equivalent to this was called {@code getValueString}.                
                <param>
                    sci {@code true} for Scientific exponential notation;{@code false} for Engineering                    
                </param>
                <return>
                    string with canonical string representation of this{@code BigDecimal}                    
                </return>
            </javadoc>
            <method name="layoutChars" type="String" line="3266">
                <params>
                    <param name="sci" type="boolean"/>
                </params>
                <comment line="3268">
                    zero scale is trivial                    
                </comment>
                <comment line="3275">
                    offset is the starting index for coeff array                    
                </comment>
                <comment line="3276">
                    Get the significand as an absolute value                    
                </comment>
                <comment line="3285">
                    Construct a buffer, with sufficient capacity for all cases.
                     If E-notation is needed, length will be: +1 if negative, +1
                     if &apos;.&apos; needed, +2 for &quot;E+&quot;, + up to 10 for adjusted exponent.
                     Otherwise it could have +1 if negative, plus leading &quot;0.00000&quot;                    
                </comment>
                <comment line="3290">
                    prefix &apos;-&apos; if negative                    
                </comment>
                <comment line="3294">
                    plain number                    
                </comment>
                <comment line="3295">
                    count of padding zeros                    
                </comment>
                <comment line="3296">
                    0.xxx form                    
                </comment>
                <comment line="3303">
                    xx.xx form                    
                </comment>
                <comment line="3308">
                    E-notation is needed                    
                </comment>
                <comment line="3309">
                    Scientific notation                    
                </comment>
                <comment line="3310">
                    first character                    
                </comment>
                <comment line="3311">
                    more to come                    
                </comment>
                <comment line="3315">
                    Engineering notation                    
                </comment>
                <comment line="3318">
                    [adjusted was negative]                    
                </comment>
                <comment line="3319">
                    now a multiple of 3                    
                </comment>
                <comment line="3324">
                    exponent is a multiple of three                    
                </comment>
                <comment line="3337">
                    significand all in integer                    
                </comment>
                <comment line="3339">
                    may need some zeros, too                    
                </comment>
                <comment line="3342">
                    xx.xxE form                    
                </comment>
                <comment line="3348">
                    [!sci could have made 0]                    
                </comment>
                <comment line="3350">
                    force sign for positive                    
                </comment>
                <declaration name="sbHelper" type="StringBuilderHelper" line="3272"/>
                <declaration name="coeff" type="char[]" line="3273"/>
                <declaration name="offset" type="int" line="3274"/>
                <scope line="3276"/>
                <scope line="3279"/>
                <declaration name="buf" type="StringBuilder" line="3288"/>
                <declaration name="coeffLen" type="int" line="3291"/>
                <declaration name="adjusted" type="long" line="3292"/>
                <scope line="3293">
                    <declaration name="pad" type="int" line="3294"/>
                    <scope line="3295">
                        <scope line="3298"/>
                    </scope>
                    <scope line="3302"/>
                </scope>
                <scope line="3307">
                    <scope line="3308">
                        <scope line="3310"/>
                    </scope>
                    <scope line="3314">
                        <declaration name="sig" type="int" line="3315"/>
                        <scope line="3320"/>
                        <scope line="3336"/>
                        <scope line="3341"/>
                    </scope>
                    <scope line="3347"/>
                </scope>
            </method>
            <javadoc line="3357">
                Return 10 to the power n, as a {@code BigInteger}.                
                <param>
                    n the power of ten to be returned (>=0)                    
                </param>
                <return>
                    a {@code BigInteger} with the value (10<sup>n</sup>)                    
                </return>
            </javadoc>
            <method name="bigTenToThe" type="BigInteger" line="3363">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="3375">
                    BigInteger.pow is slow, so make 10**n by constructing a
                     BigInteger from a character string (still not very fast)                    
                </comment>
                <scope line="3367">
                    <declaration name="pows" type="BigInteger[]" line="3368"/>
                </scope>
                <declaration name="tenpow" type="char" line="3376"/>
            </method>
            <javadoc line="3383">
                Expand the BIG_TEN_POWERS_TABLE array to contain at least 10n.                
                <param>
                    n the power of ten to be returned (>=0)                    
                </param>
                <return>
                    a {@code BigDecimal} with the value (10<sup>n</sup>) and
                      in the meantime, the BIG_TEN_POWERS_TABLE array gets
                      expanded to the size greater than n.                    
                </return>
            </javadoc>
            <method name="expandBigIntegerTenPowers" type="BigInteger" line="3391">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="3396">
                    The following comparison and the above synchronized statement is
                     to prevent multiple threads from expanding the same array.                    
                </comment>
                <comment line="3405">
                    Based on the following facts:
                     1. pows is a private local varible;
                     2. the following store is a volatile store.
                     the newly created array elements can be safely published.                    
                </comment>
                <scope line="3392">
                    <declaration name="pows" type="BigInteger[]" line="3393"/>
                    <declaration name="curLen" type="int" line="3394"/>
                    <scope line="3397">
                        <declaration name="newLen" type="int" line="3398"/>
                    </scope>
                </scope>
            </method>
            <declaration name="LONG_TEN_POWERS_TABLE" type="long[]" line="3414"/>
            <declaration name="BIG_TEN_POWERS_TABLE" type="BigInteger" line="3436"/>
            <declaration name="BIG_TEN_POWERS_TABLE_INITLEN" type="int" line="3453"/>
            <declaration name="BIG_TEN_POWERS_TABLE_MAX" type="int" line="3455"/>
            <declaration name="THRESHOLDS_TABLE" type="long" line="3458"/>
            <javadoc line="3480">
                Compute val  10 ^ n; return this product if it is
                  representable as a long, INFLATED otherwise.                
            </javadoc>
            <method name="longMultiplyPowerTen" type="long" line="3484">
                <params>
                    <param name="val" type="long"/>
                    <param name="n" type="int"/>
                </params>
                <declaration name="tab" type="long[]" line="3487"/>
                <declaration name="bounds" type="long[]" line="3488"/>
                <scope line="3489">
                    <declaration name="tenpower" type="long" line="3490"/>
                </scope>
            </method>
            <javadoc line="3499">
                Compute this  10 ^ n.
                  Needed mainly to allow special casing to trap zero value                
            </javadoc>
            <method name="bigMultiplyPowerTen" type="BigInteger" line="3503">
                <params>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="3513">
                Assign appropriate BigInteger to intVal field if intVal is
                  null, i.e. the compact representation is in use.                
            </javadoc>
            <method name="inflate" type="BigInteger" line="3517"/>
            <javadoc line="3523">
                Match the scales of two {@code BigDecimal}s to align their
                  least significant digits.
                  &lt;p&gt;If the scales of val[0] and val[1] differ, rescale
                  (non-destructively) the lower-scaled {@code BigDecimal} so
                  they match.  That is, the lower-scaled reference will be
                  replaced by a reference to a new object with the same scale as
                  the other {@code BigDecimal}.                
                <param>
                    val array of two elements referring to the two{@code BigDecimal}s to be aligned.                    
                </param>
            </javadoc>
            <method name="matchScale" type="void" line="3536">
                <params>
                    <param name="val" type="BigDecimal[]"/>
                </params>
                <scope line="3537"/>
                <scope line="3539"/>
                <scope line="3541"/>
            </method>
            <javadoc line="3546">
                Reconstitute the {@code BigDecimal} instance from a stream (that is,
                  deserialize it).                
                <param>
                    s the stream being read.                    
                </param>
            </javadoc>
            <method name="readObject" type="void" line="3553">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="3555">
                    Read in all fields                    
                </comment>
                <comment line="3557">
                    validate possibly bad fields                    
                </comment>
                <comment line="3561">
                    [all values of scale are now allowed]                    
                </comment>
                <scope line="3557">
                    <declaration name="message" type="String" line="3558"/>
                </scope>
            </method>
            <javadoc line="3565">
                Serialize this {@code BigDecimal} to the stream in question                
                <param>
                    s the stream to serialize to.                    
                </param>
            </javadoc>
            <method name="writeObject" type="void" line="3571">
                <params>
                    <param name="s" type="java.io.ObjectOutputStream"/>
                </params>
                <comment line="3573">
                    Must inflate to maintain compatible serial form.                    
                </comment>
                <comment line="3576">
                    Write proper fields                    
                </comment>
            </method>
            <javadoc line="3580">
                Returns the length of the absolute value of a {@code long}, in decimal
                  digits.                
                <param>
                    x the {@code long}                    
                </param>
                <return>
                    the length of the unscaled value, in deciaml digits.                    
                </return>
            </javadoc>
            <method name="longDigitLength" type="int" line="3587">
                <params>
                    <param name="x" type="long"/>
                </params>
                <comment line="3589">
                    As described in &quot;Bit Twiddling Hacks&quot; by Sean Anderson,
                     (http:graphics.stanford.edu~seanderbithacks.html)
                     integer log 10 of x is within 1 of
                     (12334096) (1 + integer log 2 of x).
                     The fraction 12334096 approximates log10(2). So we first
                     do a version of log2 (a variant of Long class with
                     pre-checks and opposite directionality) and then scale and
                     check against powers table. This is a little simpler in
                     present context than the version in Hacker&apos;s Delight sec
                     11-4.  Adding one to bit length allows comparing downward
                     from the LONG_TEN_POWERS_TABLE that we need anyway.                    
                </comment>
                <comment line="3605">
                    must screen for 0, might as well 10                    
                </comment>
                <comment line="3607">
                    not 63, to avoid needing to add 1 later                    
                </comment>
                <comment line="3616">
                    if r &gt;= length, must have max possible digits for long                    
                </comment>
                <declaration name="n" type="int" line="3606"/>
                <declaration name="y" type="int" line="3607"/>
                <scope line="3608"/>
                <scope line="3609"/>
                <scope line="3610"/>
                <scope line="3611"/>
                <scope line="3612"/>
                <declaration name="r" type="int" line="3613"/>
                <declaration name="tab" type="long[]" line="3614"/>
            </method>
            <javadoc line="3619">
                Returns the length of the absolute value of a BigInteger, in
                  decimal digits.                
                <param>
                    b the BigInteger                    
                </param>
                <return>
                    the length of the unscaled value, in decimal digits                    
                </return>
            </javadoc>
            <method name="bigDigitLength" type="int" line="3626">
                <params>
                    <param name="b" type="BigInteger"/>
                </params>
                <comment line="3628">
                    Same idea as the long version, but we need a better
                     approximation of log10(2). Using 6464569932^31
                     is accurate up to max possible reported bitLength.                    
                </comment>
                <declaration name="r" type="int" line="3634"/>
            </method>
            <javadoc line="3639">
                Remove insignificant trailing zeros from this{@code BigDecimal} until the preferred scale is reached or no
                  more zeros can be removed.  If the preferred scale is less than
                  Integer.MIN_VALUE, all the trailing zeros will be removed.{@code BigInteger} assistance could help, here?
                  &lt;p&gt;WARNING: This method should only be called on new objects as
                  it mutates the value fields.                
                <return>
                    this {@code BigDecimal} with a scale possibly reduced
                      to be closed to the preferred scale.                    
                </return>
            </javadoc>
            <method name="stripZerosToMatchScale" type="BigDecimal" line="3653">
                <params>
                    <param name="preferredScale" type="long"/>
                </params>
                <comment line="3656">
                    quotient-remainder pair                    
                </comment>
                <comment line="3660">
                    odd number cannot end in 0                    
                </comment>
                <comment line="3663">
                    non-0 remainder                    
                </comment>
                <comment line="3665">
                    could Overflow                    
                </comment>
                <comment line="3666">
                    adjust precision if known                    
                </comment>
                <declaration name="qr" type="BigInteger" line="3655"/>
                <scope line="3657"/>
            </method>
            <javadoc line="3673">
                Check a scale for Underflow or Overflow.  If this BigDecimal is
                  nonzero, throw an exception if the scale is outof range. If this
                  is zero, saturate the scale to the extreme value of the right
                  sign if the scale is out of range.                
                <param>
                    val The new scale.                    
                </param>
                <throws>
                    ArithmeticException (overflow or underflow) if the new
                      scale is out of range.                    
                </throws>
                <return>
                    validated scale as an int.                    
                </return>
            </javadoc>
            <method name="checkScale" type="int" line="3684">
                <params>
                    <param name="val" type="long"/>
                </params>
                <declaration name="asInt" type="int" line="3685"/>
                <scope line="3686">
                    <declaration name="b" type="BigInteger" line="3688"/>
                </scope>
            </method>
            <javadoc line="3696">
                Round an operand; used only if digits &amp;gt; 0.  Does not change{@code this}; if rounding is needed a new {@code BigDecimal}is created and returned.                
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the result is inexact but the
                      rounding mode is {@code UNNECESSARY}.                    
                </throws>
            </javadoc>
            <method name="roundOp" type="BigDecimal" line="3705">
                <params>
                    <param name="mc" type="MathContext"/>
                </params>
                <declaration name="rounded" type="BigDecimal" line="3706"/>
            </method>
            <javadoc line="3710">
                Round this BigDecimal according to the MathContext settings;
                  used only if precision {@literal &gt;} 0.
                  &lt;p&gt;WARNING: This method should only be called on new objects as
                  it mutates the value fields.                
                <param>
                    mc the context to use.                    
                </param>
                <throws>
                    ArithmeticException if the rounding mode is{@code RoundingMode.UNNECESSARY} and the{@code BigDecimal} operation would require rounding.                    
                </throws>
            </javadoc>
            <method name="roundThis" type="void" line="3721">
                <params>
                    <param name="mc" type="MathContext"/>
                </params>
                <comment line="3724">
                    wasn&apos;t rounded                    
                </comment>
                <declaration name="rounded" type="BigDecimal" line="3722"/>
            </method>
            <javadoc line="3731">
                Returns a {@code BigDecimal} rounded according to the
                  MathContext settings; used only if {@code mc.precision &gt; 0}.
                  Does not change {@code this}; if rounding is needed a new{@code BigDecimal} is created and returned.                
                <param>
                    mc the context to use.                    
                </param>
                <return>
                    a {@code BigDecimal} rounded according to the MathContext
                      settings.  May return this, if no rounding needed.                    
                </return>
                <throws>
                    ArithmeticException if the rounding mode is{@code RoundingMode.UNNECESSARY} and the
                      result is inexact.                    
                </throws>
            </javadoc>
            <method name="doRound" type="BigDecimal" line="3744">
                <params>
                    <param name="d" type="BigDecimal"/>
                    <param name="mc" type="MathContext"/>
                </params>
                <comment line="3748">
                    This might (rarely) iterate to cover the 999=&gt;1000 case                    
                </comment>
                <declaration name="mcp" type="int" line="3745"/>
                <declaration name="drop" type="int" line="3746"/>
                <scope line="3748">
                    <declaration name="newScale" type="int" line="3749"/>
                    <declaration name="mode" type="int" line="3750"/>
                </scope>
            </method>
            <javadoc line="3763">
                Returns the compact value for given {@code BigInteger}, or
                  INFLATED if too big. Relies on internal representation of{@code BigInteger}.                
            </javadoc>
            <method name="compactValFor" type="long" line="3768">
                <params>
                    <param name="b" type="BigInteger"/>
                </params>
                <declaration name="m" type="int[]" line="3769"/>
                <declaration name="len" type="int" line="3770"/>
                <declaration name="d" type="int" line="3773"/>
                <declaration name="u" type="long" line="3777"/>
            </method>
            <method name="longCompareMagnitude" type="int" line="3783">
                <params>
                    <param name="x" type="long"/>
                    <param name="y" type="long"/>
                </params>
            </method>
            <method name="saturateLong" type="int" line="3791">
                <params>
                    <param name="s" type="long"/>
                </params>
                <declaration name="i" type="int" line="3792"/>
            </method>
            <method name="print" type="void" line="3799">
                <params>
                    <param name="name" type="String"/>
                    <param name="bd" type="BigDecimal"/>
                </params>
            </method>
            <javadoc line="3808">
                Check internal invariants of this BigDecimal.  These invariants
                  include:
                  &lt;ul&gt;
                  &lt;li&gt;The object must be initialized; either intCompact must not be
                  INFLATED or intVal is non-null.  Both of these conditions may
                  be true.
                  &lt;li&gt;If both intCompact and intVal and set, their values must be
                  consistent.
                  &lt;li&gt;If precision is nonzero, it must have the right value.
                  &lt;/ul&gt;
                  Note: Since this is an audit method, we are not supposed to change the
                  state of this BigDecimal object.                
            </javadoc>
            <method name="audit" type="BigDecimal" line="3827">
                <comment line="3834">
                    Check precision                    
                </comment>
                <comment line="3848">
                    Check precision                    
                </comment>
                <scope line="3828">
                    <scope line="3829"/>
                    <scope line="3834"/>
                </scope>
                <scope line="3838">
                    <scope line="3839">
                        <declaration name="val" type="long" line="3840"/>
                        <scope line="3841"/>
                    </scope>
                    <scope line="3848"/>
                </scope>
            </method>
        </class>
    </source>