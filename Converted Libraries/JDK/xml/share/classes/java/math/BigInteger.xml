<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.math">
        <import package="java.util.Random"/>
        <import package="java.io"/>
        <class name="BigInteger" line="35">
            <extends class="Number"/>
            <comment line="122">
                These &quot;redundant fields&quot; are initialized with recognizable nonsense                
            </comment>
            <comment line="123">
                values, and cached the first time they are needed (or never, if they                
            </comment>
            <comment line="124">
                aren&apos;t needed).                
            </comment>
            <comment line="177">
                Constructors                
            </comment>
            <comment line="357">
                Constructs a new BigInteger using a char array with radix=10                
            </comment>
            <comment line="411">
                Create an integer with the digits between the two indexes                
            </comment>
            <comment line="412">
                Assumes start &lt; end. The result may be negative, but it                
            </comment>
            <comment line="413">
                is to be treated as an unsigned value.                
            </comment>
            <comment line="429">
                bitsPerDigit in the given radix times 1024                
            </comment>
            <comment line="430">
                Rounded up to avoid underallocation.                
            </comment>
            <comment line="437">
                Multiply x array times word y in place, and add word z                
            </comment>
            <comment line="543">
                Minimum size in bits that the requested prime number has                
            </comment>
            <comment line="544">
                before we use the large prime number generating algorithms                
            </comment>
            <comment line="547">
                Certainty required to meet the spec of probablePrime                
            </comment>
            <comment line="938">
                Static Factory Methods                
            </comment>
            <comment line="992">
                Constants                
            </comment>
            <comment line="1035">
                Arithmetic Operations                
            </comment>
            <comment line="1478">
                shifts a up to len right n bits assumes no leading zeros, 0&lt;n&lt;32                
            </comment>
            <comment line="1489">
                shifts a up to len left n bits assumes no leading zeros, 0&lt;=n&lt;32                
            </comment>
            <comment line="1542">
                Modular Arithmetic Operations                
            </comment>
            <comment line="1637">
                Sentinel                
            </comment>
            <comment line="1896">
                Returns -1, 0 or +1 as big-endian unsigned int array arg1 is less than,
                 equal to, or greater than arg2 up to length len.                
            </comment>
            <comment line="2047">
                Shift Operations                
            </comment>
            <comment line="2181">
                Bitwise Operations                
            </comment>
            <comment line="2269">
                Single Bit Operations                
            </comment>
            <comment line="2384">
                Miscellaneous Bit Operations                
            </comment>
            <comment line="2450">
                Primality Testing                
            </comment>
            <comment line="2478">
                Comparison Operations                
            </comment>
            <comment line="2588">
                Hash Function                
            </comment>
            <comment line="2665">
                                
            </comment>
            <comment line="2933">
                The following two arrays are used for fast String conversions.  Both
                 are indexed by radix.  The first is the number of digits of the given
                 radix that can fit in a Java long without &quot;going negative&quot;, i.e., the
                 highest integer n such that radixn &lt; 263.  The second is the
                 &quot;long radix&quot; that tears each number into &quot;long digits&quot;, each of which
                 consists of the number of digits in the corresponding element in
                 digitsPerLong (longRadix[i] = idigitPerLong[i]).  Both arrays have
                 nonsense values in their 0 and 1 elements, as radixes 0 and 1 are not
                 used.                
            </comment>
            <comment line="2968">
                These two arrays are the integer analogue of above.                
            </comment>
            <comment line="2985">
                These routines provide access to the two&apos;s complement representation
                 of BigIntegers.                
            </comment>
            <comment line="2998">
                                
            </comment>
            <comment line="3003">
                                
            </comment>
            <comment line="3125">
                Support for resetting final fields while deserializing                
            </comment>
            <implements interface="Comparable">
                <type_params>
                    <type_param name="BigInteger"/>
                </type_params>
            </implements>
            <javadoc line="35">
                Immutable arbitrary-precision integers.  All operations behave as if
                  BigIntegers were represented in two&apos;s-complement notation (like Java&apos;s
                  primitive integer types).  BigInteger provides analogues to all of Java&apos;s
                  primitive integer operators, and all relevant methods from java.lang.Math.
                  Additionally, BigInteger provides operations for modular arithmetic, GCD
                  calculation, primality testing, prime generation, bit manipulation,
                  and a few other miscellaneous operations.
                  &lt;p&gt;Semantics of arithmetic operations exactly mimic those of Java&apos;s integer
                  arithmetic operators, as defined in &lt;i&gt;The Java Language Specification&lt;/i&gt;.
                  For example, division by zero throws an {@code ArithmeticException}, and
                  division of a negative by a positive yields a negative (or zero) remainder.
                  All of the details in the Spec concerning overflow are ignored, as
                  BigIntegers are made as large as necessary to accommodate the results of an
                  operation.
                  &lt;p&gt;Semantics of shift operations extend those of Java&apos;s shift operators
                  to allow for negative shift distances.  A right-shift with a negative
                  shift distance results in a left shift, and vice-versa.  The unsigned
                  right shift operator ({@code &gt;&gt;&gt;}) is omitted, as this operation makes
                  little sense in combination with the &quot;infinite word size&quot; abstraction
                  provided by this class.
                  &lt;p&gt;Semantics of bitwise logical operations exactly mimic those of Java&apos;s
                  bitwise integer operators.  The binary operators ({@code and},{@code or}, {@code xor}) implicitly perform sign extension on the shorter
                  of the two operands prior to performing the operation.
                  &lt;p&gt;Comparison operations perform signed integer comparisons, analogous to
                  those performed by Java&apos;s relational and equality operators.
                  &lt;p&gt;Modular arithmetic operations are provided to compute residues, perform
                  exponentiation, and compute multiplicative inverses.  These methods always
                  return a non-negative result, between {@code 0} and {@code (modulus - 1)},
                  inclusive.
                  &lt;p&gt;Bit operations operate on a single bit of the two&apos;s-complement
                  representation of their operand.  If necessary, the operand is sign-
                  extended so that it contains the designated bit.  None of the single-bit
                  operations can produce a BigInteger with a different sign from the
                  BigInteger being operated on, as they affect only a single bit, and the
                  &quot;infinite word size&quot; abstraction provided by this class ensures that there
                  are infinitely many &quot;virtual sign bits&quot; preceding each BigInteger.
                  &lt;p&gt;For the sake of brevity and clarity, pseudo-code is used throughout the
                  descriptions of BigInteger methods.  The pseudo-code expression{@code (i + j)} is shorthand for &quot;a BigInteger whose value is
                  that of the BigInteger {@code i} plus that of the BigInteger {@code j}.&quot;
                  The pseudo-code expression {@code (i == j)} is shorthand for
                  &quot;{@code true} if and only if the BigInteger {@code i} represents the same
                  value as the BigInteger {@code j}.&quot;  Other pseudo-code expressions are
                  interpreted similarly.
                  &lt;p&gt;All methods and constructors in this class throw{@code NullPointerException} when passed
                  a null object reference for any input parameter.                
                <see>
                    BigDecimal                    
                </see>
                <author>
                    Josh Bloch                    
                </author>
                <author>
                    Michael McCloskey                    
                </author>
                <since>
                    JDK1.1                    
                </since>
            </javadoc>
            <declaration name="signum" type="int" line="100"/>
            <javadoc line="100">
                The signum of this BigInteger: -1 for negative, 0 for zero, or
                  1 for positive.  Note that the BigInteger zero &lt;i&gt;must&lt;/i&gt; have
                  a signum of 0.  This is necessary to ensures that there is exactly one
                  representation for each BigInteger value.                
                <serial>
                                        
                </serial>
            </javadoc>
            <declaration name="mag" type="int[]" line="110"/>
            <javadoc line="110">
                The magnitude of this BigInteger, in &lt;i&gt;big-endian&lt;/i&gt; order: the
                  zeroth element of this array is the most-significant int of the
                  magnitude.  The magnitude must be &quot;minimal&quot; in that the most-significant
                  int ({@code mag[0]}) must be non-zero.  This is necessary to
                  ensure that there is exactly one representation for each BigInteger
                  value.  Note that this implies that the BigInteger zero has a
                  zero-length mag array.                
            </javadoc>
            <declaration name="bitCount" type="int" line="125"/>
            <javadoc line="125">
                One plus the bitCount of this BigInteger. Zeros means unitialized.                
                <serial>
                                        
                </serial>
                <see>
                    #bitCount                    
                </see>
                <deprecated>
                    Deprecated since logical value is offset from stored
                      value and correction factor is applied in accessor method.                    
                </deprecated>
            </javadoc>
            <declaration name="bitLength" type="int" line="136"/>
            <javadoc line="136">
                One plus the bitLength of this BigInteger. Zeros means unitialized.
                  (either value is acceptable).                
                <serial>
                                        
                </serial>
                <see>
                    #bitLength()                    
                </see>
                <deprecated>
                    Deprecated since logical value is offset from stored
                      value and correction factor is applied in accessor method.                    
                </deprecated>
            </javadoc>
            <declaration name="lowestSetBit" type="int" line="148"/>
            <javadoc line="148">
                Two plus the lowest set bit of this BigInteger, as returned by
                  getLowestSetBit().                
                <serial>
                                        
                </serial>
                <see>
                    #getLowestSetBit                    
                </see>
                <deprecated>
                    Deprecated since logical value is offset from stored
                      value and correction factor is applied in accessor method.                    
                </deprecated>
            </javadoc>
            <declaration name="firstNonzeroIntNum" type="int" line="160"/>
            <javadoc line="160">
                Two plus the index of the lowest-order int in the magnitude of this
                  BigInteger that contains a nonzero int, or -2 (either value is acceptable).
                  The least significant int has int-number 0, the next int in order of
                  increasing significance has int-number 1, and so forth.                
                <deprecated>
                    Deprecated since logical value is offset from stored
                      value and correction factor is applied in accessor method.                    
                </deprecated>
            </javadoc>
            <declaration name="LONG_MASK" type="long" line="171"/>
            <javadoc line="171">
                This mask is used to obtain the value of an int as if it were unsigned.                
            </javadoc>
            <javadoc line="178">
                Translates a byte array containing the two&apos;s-complement binary
                  representation of a BigInteger into a BigInteger.  The input array is
                  assumed to be in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant
                  byte is in the zeroth element.                
                <param>
                    val big-endian two's-complement binary representation of
                      BigInteger.                    
                </param>
                <throws>
                    NumberFormatException {@code val} is zero bytes long.                    
                </throws>
            </javadoc>
            <method name="BigInteger" type="constructor" line="188">
                <params>
                    <param name="val" type="byte[]"/>
                </params>
                <scope line="192"/>
                <scope line="195"/>
            </method>
            <javadoc line="201">
                This private constructor translates an int array containing the
                  two&apos;s-complement binary representation of a BigInteger into a
                  BigInteger. The input array is assumed to be in &lt;i&gt;big-endian&lt;/i&gt;
                  int-order: the most significant int is in the zeroth element.                
            </javadoc>
            <method name="BigInteger" type="constructor" line="207">
                <params>
                    <param name="val" type="int[]"/>
                </params>
                <scope line="211"/>
                <scope line="214"/>
            </method>
            <javadoc line="220">
                Translates the sign-magnitude representation of a BigInteger into a
                  BigInteger.  The sign is represented as an integer signum value: -1 for
                  negative, 0 for zero, or 1 for positive.  The magnitude is a byte array
                  in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant byte is in the
                  zeroth element.  A zero-length magnitude array is permissible, and will
                  result in a BigInteger value of 0, whether signum is -1, 0 or 1.                
                <param>
                    signum signum of the number (-1 for negative, 0 for zero, 1
                      for positive).                    
                </param>
                <param>
                    magnitude big-endian binary representation of the magnitude of
                      the number.                    
                </param>
                <throws>
                    NumberFormatException {@code signum} is not one of the three
                      legal values (-1, 0, and 1), or {@code signum} is 0 and{@code magnitude} contains one or more non-zero bytes.                    
                </throws>
            </javadoc>
            <method name="BigInteger" type="constructor" line="236">
                <params>
                    <param name="signum" type="int"/>
                    <param name="magnitude" type="byte[]"/>
                </params>
                <scope line="242"/>
                <scope line="244"/>
            </method>
            <javadoc line="251">
                A constructor for internal use that translates the sign-magnitude
                  representation of a BigInteger into a BigInteger. It checks the
                  arguments and copies the magnitude so this constructor would be
                  safe for external use.                
            </javadoc>
            <method name="BigInteger" type="constructor" line="257">
                <params>
                    <param name="signum" type="int"/>
                    <param name="magnitude" type="int[]"/>
                </params>
                <scope line="263"/>
                <scope line="265"/>
            </method>
            <javadoc line="272">
                Translates the String representation of a BigInteger in the
                  specified radix into a BigInteger.  The String representation
                  consists of an optional minus or plus sign followed by a
                  sequence of one or more digits in the specified radix.  The
                  character-to-digit mapping is provided by {@codeCharacter.digit}.  The String may not contain any extraneous
                  characters (whitespace, for example).                
                <param>
                    val String representation of BigInteger.                    
                </param>
                <param>
                    radix radix to be used in interpreting {@code val}.                    
                </param>
                <throws>
                    NumberFormatException {@code val} is not a valid representation
                      of a BigInteger in the specified radix, or {@code radix} is
                      outside the range from {@link Character#MIN_RADIX} to{@link Character#MAX_RADIX}, inclusive.                    
                </throws>
                <see>
                    Character#digit                    
                </see>
            </javadoc>
            <method name="BigInteger" type="constructor" line="289">
                <params>
                    <param name="val" type="String"/>
                    <param name="radix" type="int"/>
                </params>
                <comment line="298">
                    Check for at most one leading sign                    
                </comment>
                <comment line="303">
                    No leading sign character or at most one leading sign character                    
                </comment>
                <comment line="314">
                    Skip leading zeros and compute number of digits in magnitude                    
                </comment>
                <comment line="327">
                    Pre-allocate array of expected size. May be too large but can                    
                </comment>
                <comment line="328">
                    never be too small. Typically exact.                    
                </comment>
                <comment line="333">
                    Process first (potentially short) digit group                    
                </comment>
                <comment line="342">
                    Process remaining digit groups                    
                </comment>
                <comment line="352">
                    Required for cases where the array was overallocated.                    
                </comment>
                <declaration name="cursor" type="int" line="290"/>
                <declaration name="len" type="int" line="291"/>
                <declaration name="sign" type="int" line="299"/>
                <declaration name="index1" type="int" line="300"/>
                <declaration name="index2" type="int" line="301"/>
                <scope line="302">
                    <scope line="304"/>
                </scope>
                <scope line="318"/>
                <declaration name="numBits" type="int" line="329"/>
                <declaration name="numWords" type="int" line="330"/>
                <declaration name="magnitude" type="int[]" line="331"/>
                <declaration name="firstGroupLen" type="int" line="334"/>
                <declaration name="group" type="String" line="337"/>
                <declaration name="superRadix" type="int" line="343"/>
                <declaration name="groupVal" type="int" line="344"/>
                <scope line="345"/>
            </method>
            <method name="BigInteger" type="constructor" line="357">
                <params>
                    <param name="val" type="char[]"/>
                </params>
                <comment line="361">
                    Check for leading minus sign                    
                </comment>
                <comment line="374">
                    Skip leading zeros and compute number of digits in magnitude                    
                </comment>
                <comment line="386">
                    Pre-allocate array of expected size                    
                </comment>
                <comment line="396">
                    Process first (potentially short) digit group                    
                </comment>
                <comment line="402">
                    Process remaining digit groups                    
                </comment>
                <declaration name="cursor" type="int" line="358"/>
                <declaration name="len" type="int" line="359"/>
                <declaration name="sign" type="int" line="362"/>
                <scope line="363"/>
                <scope line="368"/>
                <scope line="377"/>
                <declaration name="numWords" type="int" line="387"/>
                <scope line="388"/>
                <scope line="390">
                    <declaration name="numBits" type="int" line="391"/>
                </scope>
                <declaration name="magnitude" type="int[]" line="394"/>
                <declaration name="firstGroupLen" type="int" line="397"/>
                <scope line="403">
                    <declaration name="groupVal" type="int" line="404"/>
                </scope>
            </method>
            <method name="parseInt" type="int" line="413">
                <params>
                    <param name="source" type="char[]"/>
                    <param name="start" type="int"/>
                    <param name="end" type="int"/>
                </params>
                <declaration name="result" type="int" line="414"/>
                <scope line="418">
                    <declaration name="nextVal" type="int" line="419"/>
                </scope>
            </method>
            <declaration name="bitsPerDigit" type="long" line="430"/>
            <method name="destructiveMulAdd" type="void" line="437">
                <params>
                    <param name="x" type="int[]"/>
                    <param name="y" type="int"/>
                    <param name="z" type="int"/>
                </params>
                <comment line="438">
                    Perform the multiplication word by word                    
                </comment>
                <comment line="451">
                    Perform the addition                    
                </comment>
                <declaration name="ylong" type="long" line="439"/>
                <declaration name="zlong" type="long" line="440"/>
                <declaration name="len" type="int" line="441"/>
                <declaration name="product" type="long" line="443"/>
                <declaration name="carry" type="long" line="444"/>
                <scope line="445"/>
                <declaration name="sum" type="long" line="452"/>
                <scope line="455"/>
            </method>
            <javadoc line="462">
                Translates the decimal String representation of a BigInteger into a
                  BigInteger.  The String representation consists of an optional minus
                  sign followed by a sequence of one or more decimal digits.  The
                  character-to-digit mapping is provided by {@code Character.digit}.
                  The String may not contain any extraneous characters (whitespace, for
                  example).                
                <param>
                    val decimal String representation of BigInteger.                    
                </param>
                <throws>
                    NumberFormatException {@code val} is not a valid representation
                      of a BigInteger.                    
                </throws>
                <see>
                    Character#digit                    
                </see>
            </javadoc>
            <method name="BigInteger" type="constructor" line="475">
                <params>
                    <param name="val" type="String"/>
                </params>
            </method>
            <javadoc line="479">
                Constructs a randomly generated BigInteger, uniformly distributed over
                  the range 0 to (2&lt;sup&gt;{@code numBits}&lt;/sup&gt; - 1), inclusive.
                  The uniformity of the distribution assumes that a fair source of random
                  bits is provided in {@code rnd}.  Note that this constructor always
                  constructs a non-negative BigInteger.                
                <param>
                    numBits maximum bitLength of the new BigInteger.                    
                </param>
                <param>
                    rnd source of randomness to be used in computing the new
                      BigInteger.                    
                </param>
                <throws>
                    IllegalArgumentException {@code numBits} is negative.                    
                </throws>
                <see>
                    #bitLength()                    
                </see>
            </javadoc>
            <method name="BigInteger" type="constructor" line="492">
                <params>
                    <param name="numBits" type="int"/>
                    <param name="rnd" type="Random"/>
                </params>
            </method>
            <method name="randomBits" type="byte[]" line="496">
                <params>
                    <param name="numBits" type="int"/>
                    <param name="rnd" type="Random"/>
                </params>
                <comment line="499">
                    avoid overflow                    
                </comment>
                <comment line="502">
                    Generate random bytes and mask out any excess bits                    
                </comment>
                <declaration name="numBytes" type="int" line="499"/>
                <declaration name="randomBits" type="byte[]" line="500"/>
                <scope line="503">
                    <declaration name="excessBits" type="int" line="505"/>
                </scope>
            </method>
            <javadoc line="511">
                Constructs a randomly generated positive BigInteger that is probably
                  prime, with the specified bitLength.
                  &lt;p&gt;It is recommended that the {@link #probablePrime probablePrime}method be used in preference to this constructor unless there
                  is a compelling need to specify a certainty.                
                <param>
                    bitLength bitLength of the returned BigInteger.                    
                </param>
                <param>
                    certainty a measure of the uncertainty that the caller is
                      willing to tolerate.  The probability that the new BigInteger
                      represents a prime number will exceed
                      (1 - 1/2<sup>{@code certainty}</sup>).  The execution time of
                      this constructor is proportional to the value of this parameter.                    
                </param>
                <param>
                    rnd source of random bits used to select candidates to be
                      tested for primality.                    
                </param>
                <throws>
                    ArithmeticException {@code bitLength < 2}.                    
                </throws>
                <see>
                    #bitLength()                    
                </see>
            </javadoc>
            <method name="BigInteger" type="constructor" line="530">
                <params>
                    <param name="bitLength" type="int"/>
                    <param name="certainty" type="int"/>
                    <param name="rnd" type="Random"/>
                </params>
                <comment line="535">
                    The cutoff of 95 was chosen empirically for best performance                    
                </comment>
                <declaration name="prime" type="BigInteger" line="531"/>
            </method>
            <declaration name="SMALL_PRIME_THRESHOLD" type="int" line="544"/>
            <declaration name="DEFAULT_PRIME_CERTAINTY" type="int" line="547"/>
            <javadoc line="549">
                Returns a positive BigInteger that is probably prime, with the
                  specified bitLength. The probability that a BigInteger returned
                  by this method is composite does not exceed 2&lt;sup&gt;-100&lt;/sup&gt;.                
                <param>
                    bitLength bitLength of the returned BigInteger.                    
                </param>
                <param>
                    rnd source of random bits used to select candidates to be
                      tested for primality.                    
                </param>
                <return>
                    a BigInteger of {@code bitLength} bits that is probably prime                    
                </return>
                <throws>
                    ArithmeticException {@code bitLength < 2}.                    
                </throws>
                <see>
                    #bitLength()                    
                </see>
                <since>
                    1.4                    
                </since>
            </javadoc>
            <method name="probablePrime" type="BigInteger" line="562">
                <params>
                    <param name="bitLength" type="int"/>
                    <param name="rnd" type="Random"/>
                </params>
                <comment line="566">
                    The cutoff of 95 was chosen empirically for best performance                    
                </comment>
            </method>
            <javadoc line="572">
                Find a random number of the specified bitLength that is probably prime.
                  This method is used for smaller primes, its performance degrades on
                  larger bitlengths.
                  This method assumes bitLength &gt; 1.                
            </javadoc>
            <method name="smallPrime" type="BigInteger" line="579">
                <params>
                    <param name="bitLength" type="int"/>
                    <param name="certainty" type="int"/>
                    <param name="rnd" type="Random"/>
                </params>
                <comment line="582">
                    High bit of high int                    
                </comment>
                <comment line="583">
                    Bits to keep in high int                    
                </comment>
                <comment line="586">
                    Construct a candidate                    
                </comment>
                <comment line="589">
                    Ensure exact length                    
                </comment>
                <comment line="591">
                    Make odd if bitlen &gt; 2                    
                </comment>
                <comment line="595">
                    Do cheap &quot;pre-test&quot; if applicable                    
                </comment>
                <comment line="601">
                    Candidate is composite; try another                    
                </comment>
                <comment line="604">
                    All candidates of bitLength 2 and 3 are prime by this point                    
                </comment>
                <comment line="608">
                    Do expensive test if we survive pre-test (or it&apos;s inapplicable)                    
                </comment>
                <declaration name="magLen" type="int" line="580"/>
                <declaration name="temp" type="int" line="581"/>
                <declaration name="highBit" type="int" line="582"/>
                <declaration name="highMask" type="int" line="583"/>
                <scope line="585">
                    <declaration name="p" type="BigInteger" line="593"/>
                    <scope line="596">
                        <declaration name="r" type="long" line="597"/>
                    </scope>
                </scope>
            </method>
            <declaration name="SMALL_PRIME_PRODUCT" type="BigInteger" line="614"/>
            <javadoc line="617">
                Find a random number of the specified bitLength that is probably prime.
                  This method is more appropriate for larger bitlengths since it uses
                  a sieve to eliminate most composites before using a more expensive
                  test.                
            </javadoc>
            <method name="largePrime" type="BigInteger" line="623">
                <params>
                    <param name="bitLength" type="int"/>
                    <param name="certainty" type="int"/>
                    <param name="rnd" type="Random"/>
                </params>
                <comment line="628">
                    Use a sieve length likely to contain the next prime number                    
                </comment>
                <declaration name="p" type="BigInteger" line="624"/>
                <declaration name="searchLen" type="int" line="629"/>
                <declaration name="searchSieve" type="BitSieve" line="630"/>
                <declaration name="candidate" type="BigInteger" line="631"/>
                <scope line="633"/>
            </method>
            <javadoc line="644">
                Returns the first integer greater than this {@code BigInteger} that
                  is probably prime.  The probability that the number returned by this
                  method is composite does not exceed 2&lt;sup&gt;-100&lt;/sup&gt;. This method will
                  never skip over a prime when searching: if it returns {@code p}, there
                  is no prime {@code q} such that {@code this &lt; q &lt; p}.                
                <return>
                    the first integer greater than this {@code BigInteger} that
                      is probably prime.                    
                </return>
                <throws>
                    ArithmeticException {@code this < 0}.                    
                </throws>
                <since>
                    1.5                    
                </since>
            </javadoc>
            <method name="nextProbablePrime" type="BigInteger" line="656">
                <comment line="660">
                    Handle trivial cases                    
                </comment>
                <comment line="666">
                    Fastpath for small numbers                    
                </comment>
                <comment line="669">
                    Ensure an odd number                    
                </comment>
                <comment line="674">
                    Do cheap &quot;pre-test&quot; if applicable                    
                </comment>
                <comment line="681">
                    Candidate is composite; try another                    
                </comment>
                <comment line="685">
                    All candidates of bitLength 2 and 3 are prime by this point                    
                </comment>
                <comment line="689">
                    The expensive test                    
                </comment>
                <comment line="697">
                    Start at previous even number                    
                </comment>
                <comment line="701">
                    Looking for the next large prime                    
                </comment>
                <declaration name="result" type="BigInteger" line="664"/>
                <scope line="667">
                    <scope line="673">
                        <scope line="675">
                            <declaration name="r" type="long" line="676"/>
                            <scope line="679"/>
                        </scope>
                    </scope>
                </scope>
                <declaration name="searchLen" type="int" line="702"/>
                <scope line="704">
                    <declaration name="searchSieve" type="BitSieve" line="705"/>
                    <declaration name="candidate" type="BigInteger" line="706"/>
                </scope>
            </method>
            <javadoc line="714">
                Returns {@code true} if this BigInteger is probably prime,{@code false} if it&apos;s definitely composite.
                  This method assumes bitLength &gt; 2.                
                <param>
                    certainty a measure of the uncertainty that the caller is
                      willing to tolerate: if the call returns {@code true}the probability that this BigInteger is prime exceeds{@code (1 - 1/2<sup>certainty</sup>)}.  The execution time of
                      this method is proportional to the value of this parameter.                    
                </param>
                <return>
                    {@code true} if this BigInteger is probably prime,{@code false} if it's definitely composite.                    
                </return>
            </javadoc>
            <method name="primeToCertainty" type="boolean" line="728">
                <params>
                    <param name="certainty" type="int"/>
                    <param name="random" type="Random"/>
                </params>
                <comment line="732">
                    The relationship between the certainty and the number of rounds                    
                </comment>
                <comment line="733">
                    we perform is given in the draft standard ANSI X9.80, &quot;PRIME                    
                </comment>
                <comment line="734">
                    NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES&quot;.                    
                </comment>
                <declaration name="rounds" type="int" line="729"/>
                <declaration name="n" type="int" line="730"/>
                <declaration name="sizeInBits" type="int" line="735"/>
                <scope line="736"/>
                <scope line="742"/>
                <scope line="744"/>
                <scope line="746"/>
                <scope line="748"/>
                <scope line="750"/>
            </method>
            <javadoc line="758">
                Returns true iff this BigInteger is a Lucas-Lehmer probable prime.
                  The following assumptions are made:
                  This BigInteger is a positive, odd number.                
            </javadoc>
            <method name="passesLucasLehmer" type="boolean" line="764">
                <comment line="767">
                    Step 1                    
                </comment>
                <comment line="770">
                    5, -7, 9, -11, ...                    
                </comment>
                <comment line="774">
                    Step 2                    
                </comment>
                <comment line="777">
                    Step 3                    
                </comment>
                <declaration name="thisPlusOne" type="BigInteger" line="765"/>
                <declaration name="d" type="int" line="768"/>
                <scope line="769"/>
                <declaration name="u" type="BigInteger" line="775"/>
            </method>
            <javadoc line="781">
                Computes Jacobi(p,n).
                  Assumes n positive, odd, n&gt;=3.                
            </javadoc>
            <method name="jacobiSymbol" type="int" line="785">
                <params>
                    <param name="p" type="int"/>
                    <param name="n" type="BigInteger"/>
                </params>
                <comment line="789">
                    Algorithm and comments adapted from Colin Plumb&apos;s C library.                    
                </comment>
                <comment line="793">
                    Make p positive                    
                </comment>
                <comment line="798">
                    3 (011) or 7 (111) mod 8                    
                </comment>
                <comment line="801">
                    Get rid of factors of 2 in p                    
                </comment>
                <comment line="807">
                    3 (011) or 5 (101) mod 8                    
                </comment>
                <comment line="811">
                    Then, apply quadratic reciprocity                    
                </comment>
                <comment line="812">
                    p = u = 3 (mod 4)?                    
                </comment>
                <comment line="814">
                    And reduce u mod p                    
                </comment>
                <comment line="817">
                    Now compute Jacobi(u,p), u &lt; p                    
                </comment>
                <comment line="824">
                    3 (011) or 5 (101) mod 8                    
                </comment>
                <comment line="828">
                    Now both u and p are odd, so use quadratic reciprocity                    
                </comment>
                <comment line="831">
                    u = p = 3 (mod 4)?                    
                </comment>
                <comment line="833">
                    Now u &gt;= p, so it can be reduced                    
                </comment>
                <declaration name="j" type="int" line="790"/>
                <declaration name="u" type="int" line="791"/>
                <scope line="794">
                    <declaration name="n8" type="int" line="796"/>
                </scope>
                <scope line="804"/>
                <scope line="818">
                    <scope line="821"/>
                    <declaration name="t" type="int" line="830"/>
                </scope>
            </method>
            <method name="lucasLehmerSequence" type="BigInteger" line="839">
                <params>
                    <param name="z" type="int"/>
                    <param name="k" type="BigInteger"/>
                    <param name="n" type="BigInteger"/>
                </params>
                <declaration name="d" type="BigInteger" line="840"/>
                <declaration name="u" type="BigInteger" line="841"/>
                <declaration name="u2" type="BigInteger" line="841"/>
                <declaration name="v" type="BigInteger" line="842"/>
                <declaration name="v2" type="BigInteger" line="842"/>
                <scope line="844">
                    <scope line="854"/>
                </scope>
            </method>
            <declaration name="staticRandom" type="Random" line="871"/>
            <method name="getSecureRandom" type="Random" line="873">
                <scope line="874"/>
            </method>
            <javadoc line="880">
                Returns true iff this BigInteger passes the specified number of
                  Miller-Rabin tests. This test is taken from the DSA spec (NIST FIPS
                  186-2).
                  The following assumptions are made:
                  This BigInteger is a positive, odd number greater than 2.
                  iterations&lt;=50.                
            </javadoc>
            <method name="passesMillerRabin" type="boolean" line="889">
                <params>
                    <param name="iterations" type="int"/>
                    <param name="rnd" type="Random"/>
                </params>
                <comment line="890">
                    Find a and m such that m is odd and this == 1 + 2**a * m                    
                </comment>
                <comment line="896">
                    Do the tests                    
                </comment>
                <comment line="901">
                    Generate a uniform random on (1, this)                    
                </comment>
                <declaration name="thisMinusOne" type="BigInteger" line="891"/>
                <declaration name="m" type="BigInteger" line="892"/>
                <declaration name="a" type="int" line="893"/>
                <scope line="897"/>
                <scope line="900">
                    <declaration name="b" type="BigInteger" line="902"/>
                    <scope line="903"/>
                    <declaration name="j" type="int" line="907"/>
                    <declaration name="z" type="BigInteger" line="908"/>
                    <scope line="909"/>
                </scope>
            </method>
            <javadoc line="918">
                This internal constructor differs from its public cousin
                  with the arguments reversed in two ways: it assumes that its
                  arguments are correct, and it doesn&apos;t copy the magnitude array.                
            </javadoc>
            <method name="BigInteger" type="constructor" line="923">
                <params>
                    <param name="magnitude" type="int[]"/>
                    <param name="signum" type="int"/>
                </params>
            </method>
            <javadoc line="928">
                This private constructor is for internal use and assumes that its
                  arguments are correct.                
            </javadoc>
            <method name="BigInteger" type="constructor" line="932">
                <params>
                    <param name="magnitude" type="byte[]"/>
                    <param name="signum" type="int"/>
                </params>
            </method>
            <javadoc line="939">
                Returns a BigInteger whose value is equal to that of the
                  specified {@code long}.  This &quot;static factory method&quot; is
                  provided in preference to a ({@code long}) constructor
                  because it allows for reuse of frequently used BigIntegers.                
                <param>
                    val value of the BigInteger to return.                    
                </param>
                <return>
                    a BigInteger with the specified value.                    
                </return>
            </javadoc>
            <method name="valueOf" type="BigInteger" line="948">
                <params>
                    <param name="val" type="long"/>
                </params>
                <comment line="949">
                    If -MAX_CONSTANT &lt; val &lt; MAX_CONSTANT, return stashed constant                    
                </comment>
            </method>
            <javadoc line="960">
                Constructs a BigInteger with the specified value, which may not be zero.                
            </javadoc>
            <method name="BigInteger" type="constructor" line="963">
                <params>
                    <param name="val" type="long"/>
                </params>
                <scope line="964"/>
                <scope line="967"/>
                <declaration name="highWord" type="int" line="971"/>
                <scope line="972"/>
                <scope line="975"/>
            </method>
            <javadoc line="982">
                Returns a BigInteger with the given two&apos;s complement representation.
                  Assumes that the input array will not be modified (the returned
                  BigInteger will reference the input array if feasible).                
            </javadoc>
            <method name="valueOf" type="BigInteger" line="987">
                <params>
                    <param name="val" type="int"/>
                </params>
            </method>
            <declaration name="MAX_CONSTANT" type="int" line="993"/>
            <javadoc line="993">
                Initialize static constant array when class is loaded.                
            </javadoc>
            <declaration name="posConst" type="BigInteger" line="997"/>
            <declaration name="negConst" type="BigInteger" line="998"/>
            <scope line="999">
                <scope line="1000">
                    <declaration name="magnitude" type="int[]" line="1001"/>
                </scope>
            </scope>
            <declaration name="ZERO" type="BigInteger" line="1008"/>
            <javadoc line="1008">
                The BigInteger constant zero.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="ONE" type="BigInteger" line="1015"/>
            <javadoc line="1015">
                The BigInteger constant one.                
                <since>
                    1.2                    
                </since>
            </javadoc>
            <declaration name="TWO" type="BigInteger" line="1022"/>
            <javadoc line="1022">
                The BigInteger constant two.  (Not exported.)                
            </javadoc>
            <declaration name="TEN" type="BigInteger" line="1027"/>
            <javadoc line="1027">
                The BigInteger constant ten.                
                <since>
                    1.5                    
                </since>
            </javadoc>
            <javadoc line="1036">
                Returns a BigInteger whose value is {@code (this + val)}.                
                <param>
                    val value to be added to this BigInteger.                    
                </param>
                <return>
                    {@code this + val}                    
                </return>
            </javadoc>
            <method name="add" type="BigInteger" line="1042">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="cmp" type="int" line="1050"/>
                <declaration name="resultMag" type="int[]" line="1053"/>
            </method>
            <javadoc line="1060">
                Adds the contents of the int arrays x and y. This method allocates
                  a new int array to hold the answer and returns a reference to that
                  array.                
            </javadoc>
            <method name="add" type="int[]" line="1065">
                <params>
                    <param name="x" type="int[]"/>
                    <param name="y" type="int[]"/>
                </params>
                <comment line="1066">
                    If x is shorter, swap the two arrays                    
                </comment>
                <comment line="1078">
                    Add common parts of both numbers                    
                </comment>
                <comment line="1085">
                    Copy remainder of longer number while carry propagation is required                    
                </comment>
                <comment line="1090">
                    Copy remainder of longer number                    
                </comment>
                <comment line="1094">
                    Grow result if necessary                    
                </comment>
                <scope line="1067">
                    <declaration name="tmp" type="int[]" line="1068"/>
                </scope>
                <declaration name="xIndex" type="int" line="1073"/>
                <declaration name="yIndex" type="int" line="1074"/>
                <declaration name="result" type="int" line="1075"/>
                <declaration name="sum" type="long" line="1076"/>
                <scope line="1079"/>
                <declaration name="carry" type="boolean" line="1086"/>
                <scope line="1095">
                    <declaration name="bigger" type="int" line="1096"/>
                </scope>
            </method>
            <javadoc line="1104">
                Returns a BigInteger whose value is {@code (this - val)}.                
                <param>
                    val value to be subtracted from this BigInteger.                    
                </param>
                <return>
                    {@code this - val}                    
                </return>
            </javadoc>
            <method name="subtract" type="BigInteger" line="1110">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="cmp" type="int" line="1118"/>
                <declaration name="resultMag" type="int[]" line="1121"/>
            </method>
            <javadoc line="1127">
                Subtracts the contents of the second int arrays (little) from the
                  first (big).  The first int array (big) must represent a larger number
                  than the second.  This method allocates the space necessary to hold the
                  answer.                
            </javadoc>
            <method name="subtract" type="int[]" line="1133">
                <params>
                    <param name="big" type="int[]"/>
                    <param name="little" type="int[]"/>
                </params>
                <comment line="1139">
                    Subtract common parts of both numbers                    
                </comment>
                <comment line="1147">
                    Subtract remainder of longer number while borrow propagates                    
                </comment>
                <comment line="1152">
                    Copy remainder of longer number                    
                </comment>
                <declaration name="bigIndex" type="int" line="1134"/>
                <declaration name="result" type="int" line="1135"/>
                <declaration name="littleIndex" type="int" line="1136"/>
                <declaration name="difference" type="long" line="1137"/>
                <scope line="1140"/>
                <declaration name="borrow" type="boolean" line="1148"/>
            </method>
            <javadoc line="1159">
                Returns a BigInteger whose value is {@code (this  val)}.                
                <param>
                    val value to be multiplied by this BigInteger.                    
                </param>
                <return>
                    {@code this  val}                    
                </return>
            </javadoc>
            <method name="multiply" type="BigInteger" line="1165">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="result" type="int[]" line="1169"/>
            </method>
            <javadoc line="1175">
                Package private methods used by BigDecimal code to multiply a BigInteger
                  with a long. Assumes v is not equal to INFLATED.                
            </javadoc>
            <method name="multiply" type="BigInteger" line="1179">
                <params>
                    <param name="v" type="long"/>
                </params>
                <comment line="1187">
                    higher order bits                    
                </comment>
                <comment line="1188">
                    lower order bits                    
                </comment>
                <declaration name="rsign" type="int" line="1184"/>
                <declaration name="dh" type="long" line="1187"/>
                <declaration name="dl" type="long" line="1188"/>
                <declaration name="xlen" type="int" line="1190"/>
                <declaration name="value" type="int[]" line="1191"/>
                <declaration name="rmag" type="int[]" line="1192"/>
                <declaration name="carry" type="long" line="1193"/>
                <declaration name="rstart" type="int" line="1194"/>
                <scope line="1195">
                    <declaration name="product" type="long" line="1196"/>
                </scope>
                <scope line="1201">
                    <scope line="1204">
                        <declaration name="product" type="long" line="1205"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1217">
                Multiplies int arrays x and y to the specified lengths and places
                  the result into z. There will be no leading zeros in the resultant array.                
            </javadoc>
            <method name="multiplyToLen" type="int[]" line="1221">
                <params>
                    <param name="x" type="int[]"/>
                    <param name="xlen" type="int"/>
                    <param name="y" type="int[]"/>
                    <param name="ylen" type="int"/>
                    <param name="z" type="int[]"/>
                </params>
                <declaration name="xstart" type="int" line="1222"/>
                <declaration name="ystart" type="int" line="1223"/>
                <declaration name="carry" type="long" line="1228"/>
                <scope line="1229">
                    <declaration name="product" type="long" line="1230"/>
                </scope>
                <scope line="1237">
                    <scope line="1239">
                        <declaration name="product" type="long" line="1240"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="1251">
                Returns a BigInteger whose value is {@code (this&lt;sup&gt;2&lt;/sup&gt;)}.                
                <return>
                    {@code this<sup>2</sup>}                    
                </return>
            </javadoc>
            <method name="square" type="BigInteger" line="1256">
                <declaration name="z" type="int[]" line="1259"/>
            </method>
            <javadoc line="1263">
                Squares the contents of the int array x. The result is placed into the
                  int array z.  The contents of x are not changed.                
            </javadoc>
            <method name="squareToLen" type="int[]" line="1267">
                <params>
                    <param name="x" type="int[]"/>
                    <param name="len" type="int"/>
                    <param name="z" type="int[]"/>
                </params>
                <comment line="1268">
                    The algorithm used here is adapted from Colin Plumb&apos;s C library.
                     Technique: Consider the partial products in the multiplication
                     of &quot;abcde&quot; by itself:
                    
                                   a  b  c  d  e
                                  a  b  c  d  e
                              ==================
                                  ae be ce de ee
                               ad bd cd dd de
                            ac bc cc cd ce
                         ab bb bc bd be
                      aa ab ac ad ae
                    
                     Note that everything above the main diagonal:
                                  ae be ce de = (abcd)  e
                               ad bd cd       = (abc)  d
                            ac bc             = (ab)  c
                         ab                   = (a)  b
                    
                     is a copy of everything below the main diagonal:
                                           de
                                     cd ce
                               bc bd be
                         ab ac ad ae
                    
                     Thus, the sum is 2  (off the diagonal) + diagonal.
                    
                     This is accumulated beginning with the diagonal (which
                     consist of the squares of the digits of the input), which is then
                     divided by two, the off-diagonal added, and multiplied by two
                     again.  The low bit is simply a copy of the low bit of the
                     input, so it doesn&apos;t need special care.                    
                </comment>
                <comment line="1306">
                    Store the squares, right shifted one bit (i.e., divided by 2)                    
                </comment>
                <comment line="1316">
                    Add in off-diagonal sums                    
                </comment>
                <comment line="1323">
                    Shift back up and set low bit                    
                </comment>
                <declaration name="zlen" type="int" line="1302"/>
                <declaration name="lastProductLowWord" type="int" line="1307"/>
                <scope line="1308">
                    <declaration name="piece" type="long" line="1309"/>
                    <declaration name="product" type="long" line="1310"/>
                </scope>
                <scope line="1317">
                    <declaration name="t" type="int" line="1318"/>
                </scope>
            </method>
            <javadoc line="1330">
                Returns a BigInteger whose value is {@code (this / val)}.                
                <param>
                    val value by which this BigInteger is to be divided.                    
                </param>
                <return>
                    {@code this / val}                    
                </return>
                <throws>
                    ArithmeticException if {@code val} is zero.                    
                </throws>
            </javadoc>
            <method name="divide" type="BigInteger" line="1337">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="q" type="MutableBigInteger" line="1338"/>
            </method>
            <javadoc line="1346">
                Returns an array of two BigIntegers containing {@code (this / val)}followed by {@code (this % val)}.                
                <param>
                    val value by which this BigInteger is to be divided, and the
                      remainder computed.                    
                </param>
                <return>
                    an array of two BigIntegers: the quotient {@code (this / val)}is the initial element, and the remainder {@code (this % val)}is the final element.                    
                </return>
                <throws>
                    ArithmeticException if {@code val} is zero.                    
                </throws>
            </javadoc>
            <method name="divideAndRemainder" type="BigInteger[]" line="1357">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="result" type="BigInteger[]" line="1358"/>
                <declaration name="q" type="MutableBigInteger" line="1359"/>
                <declaration name="r" type="MutableBigInteger" line="1362"/>
            </method>
            <javadoc line="1368">
                Returns a BigInteger whose value is {@code (this % val)}.                
                <param>
                    val value by which this BigInteger is to be divided, and the
                      remainder computed.                    
                </param>
                <return>
                    {@code this % val}                    
                </return>
                <throws>
                    ArithmeticException if {@code val} is zero.                    
                </throws>
            </javadoc>
            <method name="remainder" type="BigInteger" line="1376">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="q" type="MutableBigInteger" line="1377"/>
            </method>
            <javadoc line="1384">
                Returns a BigInteger whose value is &lt;tt&gt;(this&lt;sup&gt;exponent&lt;/sup&gt;)&lt;/tt&gt;.
                  Note that {@code exponent} is an integer rather than a BigInteger.                
                <param>
                    exponent exponent to which this BigInteger is to be raised.                    
                </param>
                <return>
                    <tt>this<sup>exponent</sup></tt>                    
                </return>
                <throws>
                    ArithmeticException {@code exponent} is negative.  (This would
                      cause the operation to yield a non-integer value.)                    
                </throws>
            </javadoc>
            <method name="pow" type="BigInteger" line="1393">
                <params>
                    <param name="exponent" type="int"/>
                </params>
                <comment line="1399">
                    Perform exponentiation using repeated squaring trick                    
                </comment>
                <declaration name="newSign" type="int" line="1400"/>
                <declaration name="baseToPow2" type="int[]" line="1401"/>
                <declaration name="result" type="int[]" line="1402"/>
                <scope line="1404">
                    <scope line="1405"/>
                    <scope line="1410"/>
                </scope>
            </method>
            <javadoc line="1418">
                Returns a BigInteger whose value is the greatest common divisor of{@code abs(this)} and {@code abs(val)}.  Returns 0 if{@code this==0 &amp;&amp; val==0}.                
                <param>
                    val value with which the GCD is to be computed.                    
                </param>
                <return>
                    {@code GCD(abs(this), abs(val))}                    
                </return>
            </javadoc>
            <method name="gcd" type="BigInteger" line="1426">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="a" type="MutableBigInteger" line="1432"/>
                <declaration name="b" type="MutableBigInteger" line="1433"/>
                <declaration name="result" type="MutableBigInteger" line="1435"/>
            </method>
            <javadoc line="1440">
                Package private method to return bit length for an integer.                
            </javadoc>
            <method name="bitLengthForInt" type="int" line="1443">
                <params>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="1447">
                Left shift int array a up to len by n bits. Returns the array that
                  results from the shift since space may have to be reallocated.                
            </javadoc>
            <method name="leftShift" type="int[]" line="1451">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="len" type="int"/>
                    <param name="n" type="int"/>
                </params>
                <comment line="1456">
                    If shift can be done without recopy, do so                    
                </comment>
                <comment line="1460">
                    Array must be resized                    
                </comment>
                <declaration name="nInts" type="int" line="1452"/>
                <declaration name="nBits" type="int" line="1453"/>
                <declaration name="bitsInHighWord" type="int" line="1454"/>
                <scope line="1457"/>
                <scope line="1460">
                    <scope line="1461">
                        <declaration name="result" type="int" line="1462"/>
                    </scope>
                    <scope line="1467">
                        <declaration name="result" type="int" line="1468"/>
                    </scope>
                </scope>
            </method>
            <method name="primitiveRightShift" type="void" line="1478">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="len" type="int"/>
                    <param name="n" type="int"/>
                </params>
                <declaration name="n2" type="int" line="1479"/>
                <scope line="1480">
                    <declaration name="b" type="int" line="1481"/>
                </scope>
            </method>
            <method name="primitiveLeftShift" type="void" line="1489">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="len" type="int"/>
                    <param name="n" type="int"/>
                </params>
                <declaration name="n2" type="int" line="1493"/>
                <scope line="1494">
                    <declaration name="b" type="int" line="1495"/>
                </scope>
            </method>
            <javadoc line="1502">
                Calculate bitlength of contents of the first len elements an int array,
                  assuming there are no leading zero ints.                
            </javadoc>
            <method name="bitLength" type="int" line="1506">
                <params>
                    <param name="val" type="int[]"/>
                    <param name="len" type="int"/>
                </params>
            </method>
            <javadoc line="1512">
                Returns a BigInteger whose value is the absolute value of this
                  BigInteger.                
                <return>
                    {@code abs(this)}                    
                </return>
            </javadoc>
            <method name="abs" type="BigInteger" line="1518"/>
            <javadoc line="1522">
                Returns a BigInteger whose value is {@code (-this)}.                
                <return>
                    {@code -this}                    
                </return>
            </javadoc>
            <method name="negate" type="BigInteger" line="1527"/>
            <javadoc line="1531">
                Returns the signum function of this BigInteger.                
                <return>
                    -1, 0 or 1 as the value of this BigInteger is negative, zero or
                      positive.                    
                </return>
            </javadoc>
            <method name="signum" type="int" line="1537"/>
            <javadoc line="1543">
                Returns a BigInteger whose value is {@code (this mod m}).  This method
                  differs from {@code remainder} in that it always returns a
                  &lt;i&gt;non-negative&lt;/i&gt; BigInteger.                
                <param>
                    m the modulus.                    
                </param>
                <return>
                    {@code this mod m}                    
                </return>
                <throws>
                    ArithmeticException {@code m} &le; 0                    
                </throws>
                <see>
                    #remainder                    
                </see>
            </javadoc>
            <method name="mod" type="BigInteger" line="1553">
                <params>
                    <param name="m" type="BigInteger"/>
                </params>
                <declaration name="result" type="BigInteger" line="1557"/>
            </method>
            <javadoc line="1561">
                Returns a BigInteger whose value is
                  &lt;tt&gt;(this&lt;sup&gt;exponent&lt;/sup&gt; mod m)&lt;/tt&gt;.  (Unlike {@code pow}, this
                  method permits negative exponents.)                
                <param>
                    exponent the exponent.                    
                </param>
                <param>
                    m the modulus.                    
                </param>
                <return>
                    <tt>this<sup>exponent</sup> mod m</tt>                    
                </return>
                <throws>
                    ArithmeticException {@code m} &le; 0 or the exponent is
                      negative and this BigInteger is not <i>relatively
                      prime</i> to {@code m}.                    
                </throws>
                <see>
                    #modInverse                    
                </see>
            </javadoc>
            <method name="modPow" type="BigInteger" line="1574">
                <params>
                    <param name="exponent" type="BigInteger"/>
                    <param name="m" type="BigInteger"/>
                </params>
                <comment line="1578">
                    Trivial cases                    
                </comment>
                <comment line="1598">
                    odd modulus                    
                </comment>
                <comment line="1601">
                    Even modulus.  Tear it into an &quot;odd part&quot; (m1) and power of two
                     (m2), exponentiate mod m1, manually exponentiate mod m2, and
                     use Chinese Remainder Theorem to combine results.                    
                </comment>
                <comment line="1607">
                    Tear m apart into odd part (m1) and power of 2 (m2)                    
                </comment>
                <comment line="1608">
                    Max pow of 2 that divides m                    
                </comment>
                <comment line="1610">
                    m/2**p                    
                </comment>
                <comment line="1611">
                    2**p                    
                </comment>
                <comment line="1613">
                    Calculate new base from m1                    
                </comment>
                <comment line="1617">
                    Caculate (base ** exponent) mod m1.                    
                </comment>
                <comment line="1621">
                    Calculate (this ** exponent) mod m2                    
                </comment>
                <comment line="1624">
                    Combine results using Chinese Remainder Theorem                    
                </comment>
                <declaration name="invertResult" type="boolean" line="1591"/>
                <declaration name="base" type="BigInteger" line="1595"/>
                <declaration name="result" type="BigInteger" line="1597"/>
                <scope line="1598"/>
                <scope line="1600">
                    <declaration name="p" type="int" line="1608"/>
                    <declaration name="m1" type="BigInteger" line="1610"/>
                    <declaration name="m2" type="BigInteger" line="1611"/>
                    <declaration name="base2" type="BigInteger" line="1614"/>
                    <declaration name="a1" type="BigInteger" line="1618"/>
                    <declaration name="a2" type="BigInteger" line="1622"/>
                    <declaration name="y1" type="BigInteger" line="1625"/>
                    <declaration name="y2" type="BigInteger" line="1626"/>
                </scope>
            </method>
            <declaration name="bnExpModThreshTable" type="int[]" line="1635"/>
            <javadoc line="1638">
                Returns a BigInteger whose value is x to the power of y mod z.
                  Assumes: z is odd &amp;&amp; x &lt; z.                
            </javadoc>
            <method name="oddModPow" type="BigInteger" line="1642">
                <params>
                    <param name="y" type="BigInteger"/>
                    <param name="z" type="BigInteger"/>
                </params>
                <comment line="1643">
                    The algorithm is adapted from Colin Plumb&apos;s C library.
                    
                     The window algorithm:
                     The idea is to keep a running product of b1 = n^(high-order bits of exp)
                     and then keep appending exponent bits to it.  The following patterns
                     apply to a 3-bit window (k = 3):
                     To append   0: square
                     To append   1: square, multiply by n^1
                     To append  10: square, multiply by n^1, square
                     To append  11: square, square, multiply by n^3
                     To append 100: square, multiply by n^1, square, square
                     To append 101: square, square, square, multiply by n^5
                     To append 110: square, square, multiply by n^3, square
                     To append 111: square, square, square, multiply by n^7
                    
                     Since each pattern involves only one multiply, the longer the pattern
                     the better, except that a 0 (no multiplies) can be appended directly.
                     We precompute a table of odd powers of n, up to 2^k, and can then
                     multiply k bits of exponent at a time.  Actually, assuming random
                     exponents, there is on average one zero bit between needs to
                     multiply (12 of the time there&apos;s none, 14 of the time there&apos;s 1,
                     18 of the time, there&apos;s 2, 132 of the time, there&apos;s 3, etc.), so
                     you have to do one multiply per k+1 bits of exponent.
                    
                     The loop walks down the exponent, squaring the result buffer as
                     it goes.  There is a wbits+1 bit lookahead buffer, buf, that is
                     filled with the upcoming exponent bits.  (What is read after the
                     end of the exponent is unimportant, but it is filled with zero here.)
                     When the most-significant bit of this buffer becomes set, i.e.
                     (buf &amp; tblmask) != 0, we have to decide what pattern to multiply
                     by, and when to do it.  We decide, remember to do it in future
                     after a suitable number of squarings have passed (e.g. a pattern
                     of &quot;100&quot; in the buffer requires that we multiply by n^1 immediately;
                     a pattern of &quot;110&quot; calls for multiplying by n^3 after one more
                     squaring), clear the buffer, and continue.
                    
                     When we start, there is one more optimization: the result buffer
                     is implcitly one, so squaring it or multiplying by it can be
                     optimized away.  Further, if we start with a pattern like &quot;100&quot;
                     in the lookahead window, rather than placing n into the buffer
                     and then starting to square it, we have already computed n^2
                     to compute the odd-powers table, so we can place that into
                     the buffer and save a squaring.
                    
                     This means that if you have a k-bit window, to compute n^z,
                     where z is the high k bits of the exponent, 12 of the time
                     it requires no squarings.  14 of the time, it requires 1
                     squaring, ... 12^(k-1) of the time, it reqires k-2 squarings.
                     And the remaining 12^(k-1) of the time, the top k bits are a
                     1 followed by k-1 0 bits, so it again only requires k-2
                     squarings, not k-1.  The average of these is 1.  Add that
                     to the one squaring we have to do to compute the table,
                     and you&apos;ll see that a k-bit window saves k-2 squarings
                     as well as reducing the multiplies.  (It actually doesn&apos;t
                     hurt in the case k = 1, either.)                    
                </comment>
                <comment line="1700">
                    Special case for exponent of one                    
                </comment>
                <comment line="1704">
                    Special case for base of zero                    
                </comment>
                <comment line="1713">
                    Select an appropriate window size                    
                </comment>
                <comment line="1716">
                    if exponent is 65537 (0x10001), use minimum window size                    
                </comment>
                <comment line="1723">
                    Calculate appropriate table size                    
                </comment>
                <comment line="1726">
                    Allocate table for precomputed odd powers of base in Montgomery form                    
                </comment>
                <comment line="1731">
                    Compute the modular inverse                    
                </comment>
                <comment line="1734">
                    Convert base to Montgomery form                    
                </comment>
                <comment line="1744">
                    Pad table[0] with leading zeros so its length is at least modLen                    
                </comment>
                <comment line="1753">
                    Set b to the square of the base                    
                </comment>
                <comment line="1757">
                    Set t to high half of b                    
                </comment>
                <comment line="1762">
                    Fill in the table with odd powers of the base                    
                </comment>
                <comment line="1768">
                    Pre load the window that slides over the exponent                    
                </comment>
                <comment line="1786">
                    The first iteration, which is hoisted out of the main loop                    
                </comment>
                <comment line="1802">
                    The main loop                    
                </comment>
                <comment line="1805">
                    Advance the window                    
                </comment>
                <comment line="1818">
                    Examine the window for pending multiplies                    
                </comment>
                <comment line="1829">
                    Perform multiply                    
                </comment>
                <comment line="1842">
                    Check if done                    
                </comment>
                <comment line="1846">
                    Square the input                    
                </comment>
                <comment line="1855">
                    Convert result out of Montgomery form and return                    
                </comment>
                <declaration name="base" type="int[]" line="1708"/>
                <declaration name="exp" type="int[]" line="1709"/>
                <declaration name="mod" type="int[]" line="1710"/>
                <declaration name="modLen" type="int" line="1711"/>
                <declaration name="wbits" type="int" line="1714"/>
                <declaration name="ebits" type="int" line="1715"/>
                <scope line="1717">
                    <scope line="1718"/>
                </scope>
                <declaration name="tblmask" type="int" line="1724"/>
                <declaration name="table" type="int[][]" line="1727"/>
                <declaration name="inv" type="int" line="1732"/>
                <declaration name="a" type="int[]" line="1735"/>
                <declaration name="q" type="MutableBigInteger" line="1737"/>
                <declaration name="r" type="MutableBigInteger" line="1741"/>
                <scope line="1745">
                    <declaration name="offset" type="int" line="1746"/>
                    <declaration name="t2" type="int[]" line="1747"/>
                </scope>
                <declaration name="b" type="int[]" line="1754"/>
                <declaration name="t" type="int[]" line="1758"/>
                <scope line="1763">
                    <declaration name="prod" type="int[]" line="1764"/>
                </scope>
                <declaration name="bitpos" type="int" line="1769"/>
                <declaration name="buf" type="int" line="1771"/>
                <declaration name="elen" type="int" line="1772"/>
                <declaration name="eIndex" type="int" line="1773"/>
                <scope line="1774">
                    <scope line="1777"/>
                </scope>
                <declaration name="multpos" type="int" line="1784"/>
                <declaration name="isone" type="boolean" line="1788"/>
                <scope line="1791"/>
                <declaration name="mult" type="int[]" line="1796"/>
                <scope line="1803">
                    <scope line="1808">
                        <scope line="1811"/>
                    </scope>
                    <scope line="1819">
                        <scope line="1821"/>
                    </scope>
                    <scope line="1830">
                        <scope line="1831"/>
                        <scope line="1834"/>
                    </scope>
                    <scope line="1847"/>
                </scope>
                <declaration name="t2" type="int[]" line="1856"/>
            </method>
            <javadoc line="1869">
                Montgomery reduce n, modulo mod.  This reduces modulo mod and divides
                  by 2^(32mlen). Adapted from Colin Plumb&apos;s C library.                
            </javadoc>
            <method name="montReduce" type="int[]" line="1873">
                <params>
                    <param name="n" type="int[]"/>
                    <param name="mod" type="int[]"/>
                    <param name="mlen" type="int"/>
                    <param name="inv" type="int"/>
                </params>
                <declaration name="c" type="int" line="1874"/>
                <declaration name="len" type="int" line="1875"/>
                <declaration name="offset" type="int" line="1876"/>
                <scope line="1878">
                    <declaration name="nEnd" type="int" line="1879"/>
                    <declaration name="carry" type="int" line="1880"/>
                </scope>
            </method>
            <method name="intArrayCmpToLen" type="int" line="1899">
                <params>
                    <param name="arg1" type="int[]"/>
                    <param name="arg2" type="int[]"/>
                    <param name="len" type="int"/>
                </params>
                <scope line="1900">
                    <declaration name="b1" type="long" line="1901"/>
                    <declaration name="b2" type="long" line="1902"/>
                </scope>
            </method>
            <javadoc line="1911">
                Subtracts two numbers of same length, returning borrow.                
            </javadoc>
            <method name="subN" type="int" line="1914">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="b" type="int[]"/>
                    <param name="len" type="int"/>
                </params>
                <declaration name="sum" type="long" line="1915"/>
                <scope line="1917"/>
            </method>
            <javadoc line="1926">
                Multiply an array by one word k and add to result, return the carry                
            </javadoc>
            <method name="mulAdd" type="int" line="1929">
                <params>
                    <param name="out" type="int[]"/>
                    <param name="in" type="int[]"/>
                    <param name="offset" type="int"/>
                    <param name="len" type="int"/>
                    <param name="k" type="int"/>
                </params>
                <declaration name="kLong" type="long" line="1930"/>
                <declaration name="carry" type="long" line="1931"/>
                <scope line="1934">
                    <declaration name="product" type="long" line="1935"/>
                </scope>
            </method>
            <javadoc line="1943">
                Add one word to the number a mlen words into a. Return the resulting
                  carry.                
            </javadoc>
            <method name="addOne" type="int" line="1947">
                <params>
                    <param name="a" type="int[]"/>
                    <param name="offset" type="int"/>
                    <param name="mlen" type="int"/>
                    <param name="carry" type="int"/>
                </params>
                <comment line="1955">
                    Carry out of number                    
                </comment>
                <declaration name="t" type="long" line="1949"/>
                <scope line="1954">
                    <scope line="1955"/>
                    <scope line="1957"/>
                </scope>
            </method>
            <javadoc line="1966">
                Returns a BigInteger whose value is (this  exponent) mod (2p)                
            </javadoc>
            <method name="modPow2" type="BigInteger" line="1969">
                <params>
                    <param name="exponent" type="BigInteger"/>
                    <param name="p" type="int"/>
                </params>
                <comment line="1970">
                    Perform exponentiation using repeated squaring trick, chopping off
                     high order bits as indicated by modulus.                    
                </comment>
                <declaration name="result" type="BigInteger" line="1974"/>
                <declaration name="baseToPow2" type="BigInteger" line="1975"/>
                <declaration name="expOffset" type="int" line="1976"/>
                <declaration name="limit" type="int" line="1978"/>
                <scope line="1983"/>
            </method>
            <javadoc line="1994">
                Returns a BigInteger whose value is this mod(2p).
                  Assumes that this {@code BigInteger &gt;= 0} and {@code p &gt; 0}.                
            </javadoc>
            <method name="mod2" type="BigInteger" line="1998">
                <params>
                    <param name="p" type="int"/>
                </params>
                <comment line="2002">
                    Copy remaining ints of mag                    
                </comment>
                <comment line="2008">
                    Mask out any excess bits                    
                </comment>
                <declaration name="numInts" type="int" line="2003"/>
                <declaration name="mag" type="int[]" line="2004"/>
                <declaration name="excessBits" type="int" line="2009"/>
            </method>
            <javadoc line="2015">
                Returns a BigInteger whose value is {@code (this}&lt;sup&gt;-1&lt;/sup&gt; {@code mod m)}.                
                <param>
                    m the modulus.                    
                </param>
                <return>
                    {@code this}<sup>-1</sup> {@code mod m}.                    
                </return>
                <throws>
                    ArithmeticException {@code  m} &le; 0, or this BigInteger
                      has no multiplicative inverse mod m (that is, this BigInteger
                      is not <i>relatively prime</i> to m).                    
                </throws>
            </javadoc>
            <method name="modInverse" type="BigInteger" line="2024">
                <params>
                    <param name="m" type="BigInteger"/>
                </params>
                <comment line="2031">
                    Calculate (this mod m)                    
                </comment>
                <declaration name="modVal" type="BigInteger" line="2032"/>
                <declaration name="a" type="MutableBigInteger" line="2039"/>
                <declaration name="b" type="MutableBigInteger" line="2040"/>
                <declaration name="result" type="MutableBigInteger" line="2042"/>
            </method>
            <javadoc line="2048">
                Returns a BigInteger whose value is {@code (this &lt;&lt; n)}.
                  The shift distance, {@code n}, may be negative, in which case
                  this method performs a right shift.
                  (Computes &lt;tt&gt;floor(this  2&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;.)                
                <param>
                    n shift distance, in bits.                    
                </param>
                <return>
                    {@code this << n}                    
                </return>
                <throws>
                    ArithmeticException if the shift distance is {@codeInteger.MIN_VALUE}.                    
                </throws>
                <see>
                    #shiftRight                    
                </see>
            </javadoc>
            <method name="shiftLeft" type="BigInteger" line="2060">
                <params>
                    <param name="n" type="int"/>
                </params>
                <scope line="2065">
                    <scope line="2066"/>
                    <scope line="2068"/>
                </scope>
                <declaration name="nInts" type="int" line="2073"/>
                <declaration name="nBits" type="int" line="2074"/>
                <declaration name="magLen" type="int" line="2075"/>
                <declaration name="newMag" type="int" line="2076"/>
                <scope line="2078"/>
                <scope line="2082">
                    <declaration name="i" type="int" line="2083"/>
                    <declaration name="nBits2" type="int" line="2084"/>
                    <declaration name="highBits" type="int" line="2085"/>
                    <scope line="2086"/>
                    <scope line="2089"/>
                    <declaration name="j" type="int" line="2092"/>
                </scope>
            </method>
            <javadoc line="2101">
                Returns a BigInteger whose value is {@code (this &gt;&gt; n)}.  Sign
                  extension is performed.  The shift distance, {@code n}, may be
                  negative, in which case this method performs a left shift.
                  (Computes &lt;tt&gt;floor(this / 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/tt&gt;.)                
                <param>
                    n shift distance, in bits.                    
                </param>
                <return>
                    {@code this >> n}                    
                </return>
                <throws>
                    ArithmeticException if the shift distance is {@codeInteger.MIN_VALUE}.                    
                </throws>
                <see>
                    #shiftLeft                    
                </see>
            </javadoc>
            <method name="shiftRight" type="BigInteger" line="2113">
                <params>
                    <param name="n" type="int"/>
                </params>
                <comment line="2129">
                    Special case: entire contents shifted off the end                    
                </comment>
                <comment line="2155">
                    Find out whether any one-bits were shifted off the end.                    
                </comment>
                <scope line="2116">
                    <scope line="2117"/>
                    <scope line="2119"/>
                </scope>
                <declaration name="nInts" type="int" line="2124"/>
                <declaration name="nBits" type="int" line="2125"/>
                <declaration name="magLen" type="int" line="2126"/>
                <declaration name="newMag" type="int" line="2127"/>
                <scope line="2133">
                    <declaration name="newMagLen" type="int" line="2134"/>
                </scope>
                <scope line="2138">
                    <declaration name="i" type="int" line="2139"/>
                    <declaration name="highBits" type="int" line="2140"/>
                    <scope line="2141"/>
                    <scope line="2144"/>
                    <declaration name="nBits2" type="int" line="2148"/>
                    <declaration name="j" type="int" line="2149"/>
                </scope>
                <scope line="2154">
                    <declaration name="onesLost" type="boolean" line="2156"/>
                </scope>
            </method>
            <method name="javaIncrement" type="int[]" line="2169">
                <params>
                    <param name="val" type="int[]"/>
                </params>
                <declaration name="lastSum" type="int" line="2170"/>
                <scope line="2173"/>
            </method>
            <javadoc line="2182">
                Returns a BigInteger whose value is {@code (this &amp; val)}.  (This
                  method returns a negative BigInteger if and only if this and val are
                  both negative.)                
                <param>
                    val value to be AND'ed with this BigInteger.                    
                </param>
                <return>
                    {@code this & val}                    
                </return>
            </javadoc>
            <method name="and" type="BigInteger" line="2190">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="result" type="int[]" line="2191"/>
            </method>
            <javadoc line="2199">
                Returns a BigInteger whose value is {@code (this | val)}.  (This method
                  returns a negative BigInteger if and only if either this or val is
                  negative.)                
                <param>
                    val value to be OR'ed with this BigInteger.                    
                </param>
                <return>
                    {@code this | val}                    
                </return>
            </javadoc>
            <method name="or" type="BigInteger" line="2207">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="result" type="int[]" line="2208"/>
            </method>
            <javadoc line="2216">
                Returns a BigInteger whose value is {@code (this ^ val)}.  (This method
                  returns a negative BigInteger if and only if exactly one of this and
                  val are negative.)                
                <param>
                    val value to be XOR'ed with this BigInteger.                    
                </param>
                <return>
                    {@code this ^ val}                    
                </return>
            </javadoc>
            <method name="xor" type="BigInteger" line="2224">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="result" type="int[]" line="2225"/>
            </method>
            <javadoc line="2233">
                Returns a BigInteger whose value is {@code (~this)}.  (This method
                  returns a negative value if and only if this BigInteger is
                  non-negative.)                
                <return>
                    {@code ~this}                    
                </return>
            </javadoc>
            <method name="not" type="BigInteger" line="2240">
                <declaration name="result" type="int[]" line="2241"/>
            </method>
            <javadoc line="2248">
                Returns a BigInteger whose value is {@code (this &amp; ~val)}.  This
                  method, which is equivalent to {@code and(val.not())}, is provided as
                  a convenience for masking operations.  (This method returns a negative
                  BigInteger if and only if {@code this} is negative and {@code val} is
                  positive.)                
                <param>
                    val value to be complemented and AND'ed with this BigInteger.                    
                </param>
                <return>
                    {@code this & ~val}                    
                </return>
            </javadoc>
            <method name="andNot" type="BigInteger" line="2258">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="result" type="int[]" line="2259"/>
            </method>
            <javadoc line="2270">
                Returns {@code true} if and only if the designated bit is set.
                  (Computes {@code ((this &amp; (1&lt;&lt;n)) != 0)}.)                
                <param>
                    n index of bit to test.                    
                </param>
                <return>
                    {@code true} if and only if the designated bit is set.                    
                </return>
                <throws>
                    ArithmeticException {@code n} is negative.                    
                </throws>
            </javadoc>
            <method name="testBit" type="boolean" line="2278">
                <params>
                    <param name="n" type="int"/>
                </params>
            </method>
            <javadoc line="2285">
                Returns a BigInteger whose value is equivalent to this BigInteger
                  with the designated bit set.  (Computes {@code (this | (1&lt;&lt;n))}.)                
                <param>
                    n index of bit to set.                    
                </param>
                <return>
                    {@code this | (1<<n)}                    
                </return>
                <throws>
                    ArithmeticException {@code n} is negative.                    
                </throws>
            </javadoc>
            <method name="setBit" type="BigInteger" line="2293">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="intNum" type="int" line="2297"/>
                <declaration name="result" type="int[]" line="2298"/>
            </method>
            <javadoc line="2308">
                Returns a BigInteger whose value is equivalent to this BigInteger
                  with the designated bit cleared.
                  (Computes {@code (this &amp; ~(1&lt;&lt;n))}.)                
                <param>
                    n index of bit to clear.                    
                </param>
                <return>
                    {@code this & ~(1<<n)}                    
                </return>
                <throws>
                    ArithmeticException {@code n} is negative.                    
                </throws>
            </javadoc>
            <method name="clearBit" type="BigInteger" line="2317">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="intNum" type="int" line="2321"/>
                <declaration name="result" type="int[]" line="2322"/>
            </method>
            <javadoc line="2332">
                Returns a BigInteger whose value is equivalent to this BigInteger
                  with the designated bit flipped.
                  (Computes {@code (this ^ (1&lt;&lt;n))}.)                
                <param>
                    n index of bit to flip.                    
                </param>
                <return>
                    {@code this ^ (1<<n)}                    
                </return>
                <throws>
                    ArithmeticException {@code n} is negative.                    
                </throws>
            </javadoc>
            <method name="flipBit" type="BigInteger" line="2341">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="intNum" type="int" line="2345"/>
                <declaration name="result" type="int[]" line="2346"/>
            </method>
            <javadoc line="2356">
                Returns the index of the rightmost (lowest-order) one bit in this
                  BigInteger (the number of zero bits to the right of the rightmost
                  one bit).  Returns -1 if this BigInteger contains no one bits.
                  (Computes {@code (this==0? -1 : log2(this &amp; -this))}.)                
                <return>
                    index of the rightmost one bit in this BigInteger.                    
                </return>
            </javadoc>
            <method name="getLowestSetBit" type="int" line="2364">
                <comment line="2366">
                    lowestSetBit not initialized yet                    
                </comment>
                <comment line="2371">
                    Search for lowest order nonzero int                    
                </comment>
                <declaration name="lsb" type="int" line="2365"/>
                <scope line="2366">
                    <scope line="2368"/>
                    <scope line="2370">
                        <declaration name="i" type="int" line="2372"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2385">
                Returns the number of bits in the minimal two&apos;s-complement
                  representation of this BigInteger, &lt;i&gt;excluding&lt;/i&gt; a sign bit.
                  For positive BigIntegers, this is equivalent to the number of bits in
                  the ordinary binary representation.  (Computes{@code (ceil(log2(this &lt; 0 ? -this : this+1)))}.)                
                <return>
                    number of bits in the minimal two's-complement
                      representation of this BigInteger, <i>excluding</i> a sign bit.                    
                </return>
            </javadoc>
            <method name="bitLength" type="int" line="2395">
                <comment line="2397">
                    bitLength not initialized yet                    
                </comment>
                <comment line="2401">
                    offset by one to initialize                    
                </comment>
                <comment line="2403">
                    Calculate the bit length of the magnitude                    
                </comment>
                <comment line="2406">
                    Check if magnitude is a power of two                    
                </comment>
                <declaration name="n" type="int" line="2396"/>
                <scope line="2397">
                    <declaration name="m" type="int[]" line="2398"/>
                    <declaration name="len" type="int" line="2399"/>
                    <scope line="2400"/>
                    <scope line="2402">
                        <declaration name="magBitLength" type="int" line="2404"/>
                        <scope line="2405">
                            <declaration name="pow2" type="boolean" line="2407"/>
                        </scope>
                        <scope line="2412"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2421">
                Returns the number of bits in the two&apos;s complement representation
                  of this BigInteger that differ from its sign bit.  This method is
                  useful when implementing bit-vector style sets atop BigIntegers.                
                <return>
                    number of bits in the two's complement representation
                      of this BigInteger that differ from its sign bit.                    
                </return>
            </javadoc>
            <method name="bitCount" type="int" line="2429">
                <comment line="2431">
                    bitCount not initialized yet                    
                </comment>
                <comment line="2432">
                    offset by one to initialize                    
                </comment>
                <comment line="2433">
                    Count the bits in the magnitude                    
                </comment>
                <comment line="2437">
                    Count the trailing zeros in the magnitude                    
                </comment>
                <declaration name="bc" type="int" line="2430"/>
                <scope line="2431">
                    <scope line="2436">
                        <declaration name="magTrailingZeroCount" type="int" line="2438"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="2451">
                Returns {@code true} if this BigInteger is probably prime,{@code false} if it&apos;s definitely composite.  If{@code certainty} is &amp;le; 0, {@code true} is
                  returned.                
                <param>
                    certainty a measure of the uncertainty that the caller is
                      willing to tolerate: if the call returns {@code true}the probability that this BigInteger is prime exceeds
                      (1 - 1/2<sup>{@code certainty}</sup>).  The execution time of
                      this method is proportional to the value of this parameter.                    
                </param>
                <return>
                    {@code true} if this BigInteger is probably prime,{@code false} if it's definitely composite.                    
                </return>
            </javadoc>
            <method name="isProbablePrime" type="boolean" line="2465">
                <params>
                    <param name="certainty" type="int"/>
                </params>
                <declaration name="w" type="BigInteger" line="2468"/>
            </method>
            <javadoc line="2479">
                Compares this BigInteger with the specified BigInteger.  This
                  method is provided in preference to individual methods for each
                  of the six boolean comparison operators ({@literal &lt;}, ==,{@literal &gt;}, {@literal &gt;=}, !=, {@literal &lt;=}).  The suggested
                  idiom for performing these comparisons is: {@code(x.compareTo(y)} &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; {@code 0)}, where
                  &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; is one of the six comparison operators.                
                <param>
                    val BigInteger to which this BigInteger is to be compared.                    
                </param>
                <return>
                    -1, 0 or 1 as this BigInteger is numerically less than, equal
                      to, or greater than {@code val}.                    
                </return>
            </javadoc>
            <method name="compareTo" type="int" line="2492">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <scope line="2493"/>
            </method>
            <javadoc line="2506">
                Compares the magnitude array of this BigInteger with the specified
                  BigInteger&apos;s. This is the version of compareTo ignoring sign.                
                <param>
                    val BigInteger whose magnitude array to be compared.                    
                </param>
                <return>
                    -1, 0 or 1 as this magnitude array is less than, equal to or
                      greater than the magnitude aray for the specified BigInteger's.                    
                </return>
            </javadoc>
            <method name="compareMagnitude" type="int" line="2514">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
                <declaration name="m1" type="int[]" line="2515"/>
                <declaration name="len1" type="int" line="2516"/>
                <declaration name="m2" type="int[]" line="2517"/>
                <declaration name="len2" type="int" line="2518"/>
                <scope line="2523">
                    <declaration name="a" type="int" line="2524"/>
                    <declaration name="b" type="int" line="2525"/>
                </scope>
            </method>
            <javadoc line="2532">
                Compares this BigInteger with the specified Object for equality.                
                <param>
                    x Object to which this BigInteger is to be compared.                    
                </param>
                <return>
                    {@code true} if and only if the specified Object is a
                      BigInteger whose value is numerically equal to this BigInteger.                    
                </return>
            </javadoc>
            <method name="equals" type="boolean" line="2539">
                <params>
                    <param name="x" type="Object"/>
                </params>
                <comment line="2540">
                    This test is just an optimization, which may or may not help                    
                </comment>
                <declaration name="xInt" type="BigInteger" line="2547"/>
                <declaration name="m" type="int[]" line="2551"/>
                <declaration name="len" type="int" line="2552"/>
                <declaration name="xm" type="int[]" line="2553"/>
            </method>
            <javadoc line="2564">
                Returns the minimum of this BigInteger and {@code val}.                
                <param>
                    val value with which the minimum is to be computed.                    
                </param>
                <return>
                    the BigInteger whose value is the lesser of this BigInteger and{@code val}.  If they are equal, either may be returned.                    
                </return>
            </javadoc>
            <method name="min" type="BigInteger" line="2571">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
            </method>
            <javadoc line="2575">
                Returns the maximum of this BigInteger and {@code val}.                
                <param>
                    val value with which the maximum is to be computed.                    
                </param>
                <return>
                    the BigInteger whose value is the greater of this and{@code val}.  If they are equal, either may be returned.                    
                </return>
            </javadoc>
            <method name="max" type="BigInteger" line="2582">
                <params>
                    <param name="val" type="BigInteger"/>
                </params>
            </method>
            <javadoc line="2589">
                Returns the hash code for this BigInteger.                
                <return>
                    hash code for this BigInteger.                    
                </return>
            </javadoc>
            <method name="hashCode" type="int" line="2594">
                <declaration name="hashCode" type="int" line="2595"/>
            </method>
            <javadoc line="2603">
                Returns the String representation of this BigInteger in the
                  given radix.  If the radix is outside the range from {@link Character#MIN_RADIX} to {@link Character#MAX_RADIX} inclusive,
                  it will default to 10 (as is the case for{@code Integer.toString}).  The digit-to-character mapping
                  provided by {@code Character.forDigit} is used, and a minus
                  sign is prepended if appropriate.  (This representation is
                  compatible with the {@link #BigInteger(String,int) (String,
                  int)} constructor.)                
                <param>
                    radix  radix of the String representation.                    
                </param>
                <return>
                    String representation of this BigInteger in the given radix.                    
                </return>
                <see>
                    Integer#toString                    
                </see>
                <see>
                    Character#forDigit                    
                </see>
                <see>
                    #BigInteger(java.lang.String,int)                    
                </see>
            </javadoc>
            <method name="toString" type="String" line="2620">
                <params>
                    <param name="radix" type="int"/>
                </params>
                <comment line="2626">
                    Compute upper bound on number of digit groups and allocate space                    
                </comment>
                <comment line="2630">
                    Translate number to string, a digit group at a time                    
                </comment>
                <comment line="2647">
                    Put sign (if any) and first digit group into result buffer                    
                </comment>
                <comment line="2653">
                    Append remaining digit groups padded with leading zeros                    
                </comment>
                <comment line="2655">
                    Prepend (any) leading zeros for this digit group                    
                </comment>
                <declaration name="maxNumDigitGroups" type="int" line="2627"/>
                <declaration name="digitGroup" type="String" line="2628"/>
                <declaration name="tmp" type="BigInteger" line="2631"/>
                <declaration name="numGroups" type="int" line="2632"/>
                <scope line="2633">
                    <declaration name="d" type="BigInteger" line="2634"/>
                    <declaration name="q" type="MutableBigInteger" line="2636"/>
                    <declaration name="r" type="MutableBigInteger" line="2639"/>
                    <declaration name="q2" type="BigInteger" line="2640"/>
                    <declaration name="r2" type="BigInteger" line="2641"/>
                </scope>
                <declaration name="buf" type="StringBuilder" line="2648"/>
                <scope line="2654">
                    <declaration name="numLeadingZeros" type="int" line="2656"/>
                </scope>
            </method>
            <declaration name="zeros" type="String" line="2665"/>
            <scope line="2666"/>
            <javadoc line="2673">
                Returns the decimal String representation of this BigInteger.
                  The digit-to-character mapping provided by{@code Character.forDigit} is used, and a minus sign is
                  prepended if appropriate.  (This representation is compatible
                  with the {@link #BigInteger(String) (String)} constructor, and
                  allows for String concatenation with Java&apos;s + operator.)                
                <return>
                    decimal String representation of this BigInteger.                    
                </return>
                <see>
                    Character#forDigit                    
                </see>
                <see>
                    #BigInteger(java.lang.String)                    
                </see>
            </javadoc>
            <method name="toString" type="String" line="2685"/>
            <javadoc line="2689">
                Returns a byte array containing the two&apos;s-complement
                  representation of this BigInteger.  The byte array will be in
                  &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant byte is in
                  the zeroth element.  The array will contain the minimum number
                  of bytes required to represent this BigInteger, including at
                  least one sign bit, which is {@code (ceil((this.bitLength() +
                  1)/8))}.  (This representation is compatible with the{@link #BigInteger(byte[]) (byte[])} constructor.)                
                <return>
                    a byte array containing the two's-complement representation of
                      this BigInteger.                    
                </return>
                <see>
                    #BigInteger(byte[])                    
                </see>
            </javadoc>
            <method name="toByteArray" type="byte[]" line="2703">
                <declaration name="byteLen" type="int" line="2704"/>
                <declaration name="byteArray" type="byte[]" line="2705"/>
                <scope line="2707">
                    <scope line="2708"/>
                    <scope line="2711"/>
                </scope>
            </method>
            <javadoc line="2720">
                Converts this BigInteger to an {@code int}.  This
                  conversion is analogous to a
                  &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code long} to{@code int} as defined in section 5.1.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
                  if this BigInteger is too big to fit in an{@code int}, only the low-order 32 bits are returned.
                  Note that this conversion can lose information about the
                  overall magnitude of the BigInteger value as well as return a
                  result with the opposite sign.                
                <return>
                    this BigInteger converted to an {@code int}.                    
                </return>
            </javadoc>
            <method name="intValue" type="int" line="2734">
                <declaration name="result" type="int" line="2735"/>
            </method>
            <javadoc line="2740">
                Converts this BigInteger to a {@code long}.  This
                  conversion is analogous to a
                  &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code long} to{@code int} as defined in section 5.1.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
                  if this BigInteger is too big to fit in a{@code long}, only the low-order 64 bits are returned.
                  Note that this conversion can lose information about the
                  overall magnitude of the BigInteger value as well as return a
                  result with the opposite sign.                
                <return>
                    this BigInteger converted to a {@code long}.                    
                </return>
            </javadoc>
            <method name="longValue" type="long" line="2754">
                <declaration name="result" type="long" line="2755"/>
            </method>
            <javadoc line="2762">
                Converts this BigInteger to a {@code float}.  This
                  conversion is similar to the
                  &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to{@code float} as defined in section 5.1.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
                  if this BigInteger has too great a magnitude
                  to represent as a {@code float}, it will be converted to{@link Float#NEGATIVE_INFINITY} or {@link Float#POSITIVE_INFINITY} as appropriate.  Note that even when
                  the return value is finite, this conversion can lose
                  information about the precision of the BigInteger value.                
                <return>
                    this BigInteger converted to a {@code float}.                    
                </return>
            </javadoc>
            <method name="floatValue" type="float" line="2777">
                <comment line="2778">
                    Somewhat inefficient, but guaranteed to work.                    
                </comment>
            </method>
            <javadoc line="2782">
                Converts this BigInteger to a {@code double}.  This
                  conversion is similar to the
                  &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to{@code float} as defined in section 5.1.3 of
                  &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
                  if this BigInteger has too great a magnitude
                  to represent as a {@code double}, it will be converted to{@link Double#NEGATIVE_INFINITY} or {@link Double#POSITIVE_INFINITY} as appropriate.  Note that even when
                  the return value is finite, this conversion can lose
                  information about the precision of the BigInteger value.                
                <return>
                    this BigInteger converted to a {@code double}.                    
                </return>
            </javadoc>
            <method name="doubleValue" type="double" line="2797">
                <comment line="2798">
                    Somewhat inefficient, but guaranteed to work.                    
                </comment>
            </method>
            <javadoc line="2802">
                Returns a copy of the input array stripped of any leading zero bytes.                
            </javadoc>
            <method name="stripLeadingZeroInts" type="int[]" line="2805">
                <params>
                    <param name="val" type="int"/>
                </params>
                <comment line="2809">
                    Find first nonzero byte                    
                </comment>
                <declaration name="vlen" type="int" line="2806"/>
                <declaration name="keep" type="int" line="2807"/>
            </method>
            <javadoc line="2815">
                Returns the input array stripped of any leading zero bytes.
                  Since the source is trusted the copying may be skipped.                
            </javadoc>
            <method name="trustedStripLeadingZeroInts" type="int[]" line="2819">
                <params>
                    <param name="val" type="int"/>
                </params>
                <comment line="2823">
                    Find first nonzero byte                    
                </comment>
                <declaration name="vlen" type="int" line="2820"/>
                <declaration name="keep" type="int" line="2821"/>
            </method>
            <javadoc line="2829">
                Returns a copy of the input array stripped of any leading zero bytes.                
            </javadoc>
            <method name="stripLeadingZeroBytes" type="int[]" line="2832">
                <params>
                    <param name="a" type="byte"/>
                </params>
                <comment line="2836">
                    Find first nonzero byte                    
                </comment>
                <comment line="2840">
                    Allocate new array and copy relevant part of input array                    
                </comment>
                <declaration name="byteLength" type="int" line="2833"/>
                <declaration name="keep" type="int" line="2834"/>
                <declaration name="intLength" type="int" line="2841"/>
                <declaration name="result" type="int[]" line="2842"/>
                <declaration name="b" type="int" line="2843"/>
                <scope line="2844">
                    <declaration name="bytesRemaining" type="int" line="2846"/>
                    <declaration name="bytesToTransfer" type="int" line="2847"/>
                </scope>
            </method>
            <javadoc line="2854">
                Takes an array a representing a negative 2&apos;s-complement number and
                  returns the minimal (no leading zero bytes) unsigned whose value is -a.                
            </javadoc>
            <method name="makePositive" type="int[]" line="2858">
                <params>
                    <param name="a" type="byte"/>
                </params>
                <comment line="2862">
                    Find first non-sign (0xff) byte of input                    
                </comment>
                <comment line="2867">
                    Allocate output array.  If all non-sign bytes are 0x00, we must                    
                </comment>
                <comment line="2876">
                    Copy one&apos;s complement of input into output, leaving extra                    
                </comment>
                <comment line="2887">
                    Mask indicates which bits must be complemented                    
                </comment>
                <comment line="2892">
                    Add one to one&apos;s complement to generate two&apos;s complement                    
                </comment>
                <declaration name="keep" type="int" line="2859"/>
                <declaration name="byteLength" type="int" line="2860"/>
                <declaration name="extraByte" type="int" line="2872"/>
                <declaration name="intLength" type="int" line="2873"/>
                <declaration name="result" type="int" line="2874"/>
                <declaration name="b" type="int" line="2878"/>
                <scope line="2879">
                    <declaration name="numBytesToTransfer" type="int" line="2881"/>
                    <declaration name="mask" type="int" line="2888"/>
                </scope>
                <scope line="2893"/>
            </method>
            <javadoc line="2902">
                Takes an array a representing a negative 2&apos;s-complement number and
                  returns the minimal (no leading zero ints) unsigned whose value is -a.                
            </javadoc>
            <method name="makePositive" type="int[]" line="2906">
                <params>
                    <param name="a" type="int"/>
                </params>
                <comment line="2909">
                    Find first non-sign (0xffffffff) int of input                    
                </comment>
                <comment line="2913">
                    Allocate output array.  If all non-sign ints are 0x00, we must                    
                </comment>
                <comment line="2920">
                    Copy one&apos;s complement of input into output, leaving extra                    
                </comment>
                <comment line="2925">
                    Add one to one&apos;s complement to generate two&apos;s complement                    
                </comment>
                <declaration name="keep" type="int" line="2907"/>
                <declaration name="extraInt" type="int" line="2917"/>
                <declaration name="result" type="int" line="2918"/>
            </method>
            <declaration name="digitsPerLong" type="int" line="2943"/>
            <declaration name="longRadix" type="BigInteger" line="2947"/>
            <declaration name="digitsPerInt" type="int" line="2970"/>
            <declaration name="intRadix" type="int" line="2974"/>
            <javadoc line="2989">
                Returns the length of the two&apos;s complement representation in ints,
                  including space for at least one sign bit.                
            </javadoc>
            <method name="intLength" type="int" line="2993"/>
            <method name="signBit" type="int" line="2998"/>
            <method name="signInt" type="int" line="3003"/>
            <javadoc line="3007">
                Returns the specified int of the little-endian two&apos;s complement
                  representation (int 0 is the least significant).  The int number can
                  be arbitrarily high (values are logically preceded by infinitely many
                  sign ints).                
            </javadoc>
            <method name="getInt" type="int" line="3013">
                <params>
                    <param name="n" type="int"/>
                </params>
                <declaration name="magInt" type="int" line="3019"/>
            </method>
            <javadoc line="3025">
                Returns the index of the int that contains the first nonzero int in the
                  little-endian binary representation of the magnitude (int 0 is the
                  least significant). If the magnitude is zero, return value is undefined.                
            </javadoc>
            <method name="firstNonzeroIntNum" type="int" line="3030">
                <comment line="3032">
                    firstNonzeroIntNum not initialized yet                    
                </comment>
                <comment line="3035">
                    Search for the first nonzero int                    
                </comment>
                <comment line="3041">
                    offset by two to initialize                    
                </comment>
                <declaration name="fn" type="int" line="3031"/>
                <scope line="3032">
                    <declaration name="i" type="int" line="3036"/>
                    <declaration name="mlen" type="int" line="3037"/>
                </scope>
            </method>
            <declaration name="serialVersionUID" type="long" line="3046"/>
            <javadoc line="3046">
                use serialVersionUID from JDK 1.1. for interoperability                
            </javadoc>
            <declaration name="serialPersistentFields" type="ObjectStreamField[]" line="3049"/>
            <javadoc line="3049">
                Serializable fields for BigInteger.                
                <serialField>
                    signum  int
                      signum of this BigInteger.                    
                </serialField>
                <serialField>
                    magnitude int[]
                      magnitude array of this BigInteger.                    
                </serialField>
                <serialField>
                    bitCount  int
                      number of bits in this BigInteger                    
                </serialField>
                <serialField>
                    bitLength int
                      the number of bits in the minimal two's-complement
                      representation of this BigInteger                    
                </serialField>
                <serialField>
                    lowestSetBit int
                      lowest set bit in the twos complement representation                    
                </serialField>
            </javadoc>
            <javadoc line="3073">
                Reconstitute the {@code BigInteger} instance from a stream (that is,
                  deserialize it). The magnitude is read in as an array of bytes
                  for historical reasons, but it is converted to an array of ints
                  and the byte array is discarded.
                  Note:
                  The current convention is to initialize the cache fields, bitCount,
                  bitLength and lowestSetBit, to 0 rather than some other marker value.
                  Therefore, no explicit action to set these fields needs to be taken in
                  readObject because those fields already have a 0 value be default since
                  defaultReadObject is not being used.                
            </javadoc>
            <method name="readObject" type="void" line="3086">
                <params>
                    <param name="s" type="java.io.ObjectInputStream"/>
                </params>
                <comment line="3087">
                    In order to maintain compatibility with previous serialized forms,
                     the magnitude of a BigInteger is serialized as an array of bytes.
                     The magnitude field is used as a temporary store for the byte array
                     that is deserialized. The cached computation fields should be
                     transient but are serialized for compatibility reasons.                    
                </comment>
                <comment line="3095">
                    prepare to read the alternate persistent fields                    
                </comment>
                <comment line="3098">
                    Read the alternate persistent fields that we care about                    
                </comment>
                <comment line="3102">
                    Validate signum                    
                </comment>
                <comment line="3116">
                    Commit final fields via Unsafe                    
                </comment>
                <comment line="3119">
                    Calculate mag field from magnitude and discard magnitude                    
                </comment>
                <declaration name="fields" type="ObjectInputStream.GetField" line="3096"/>
                <declaration name="sign" type="int" line="3099"/>
                <declaration name="magnitude" type="byte[]" line="3100"/>
                <scope line="3103">
                    <declaration name="message" type="String" line="3104"/>
                </scope>
                <scope line="3109">
                    <declaration name="message" type="String" line="3110"/>
                </scope>
            </method>
            <declaration name="unsafe" type="sun.misc.Unsafe" line="3125"/>
            <declaration name="signumOffset" type="long" line="3126"/>
            <declaration name="magOffset" type="long" line="3127"/>
            <scope line="3128">
                <scope line="3129"/>
                <scope line="3134"/>
            </scope>
            <javadoc line="3139">
                Save the {@code BigInteger} instance to a stream.
                  The magnitude of a BigInteger is serialized as a byte array for
                  historical reasons.                
                <serialData>
                    two necessary fields are written as well as obsolete
                      fields for compatibility with older versions.                    
                </serialData>
            </javadoc>
            <method name="writeObject" type="void" line="3147">
                <params>
                    <param name="s" type="ObjectOutputStream"/>
                </params>
                <comment line="3148">
                    set the values of the Serializable fields                    
                </comment>
                <comment line="3152">
                    The values written for cached fields are compatible with older                    
                </comment>
                <comment line="3153">
                    versions, but are ignored in readObject so don&apos;t otherwise matter.                    
                </comment>
                <comment line="3159">
                    save them                    
                </comment>
                <declaration name="fields" type="ObjectOutputStream.PutField" line="3149"/>
            </method>
            <javadoc line="3163">
                Returns the mag array as an array of bytes.                
            </javadoc>
            <method name="magSerializedForm" type="byte[]" line="3166">
                <declaration name="len" type="int" line="3167"/>
                <declaration name="bitLen" type="int" line="3169"/>
                <declaration name="byteLen" type="int" line="3170"/>
                <declaration name="result" type="byte[]" line="3171"/>
                <scope line="3174">
                    <scope line="3175"/>
                    <scope line="3178"/>
                </scope>
            </method>
        </class>
    </source>