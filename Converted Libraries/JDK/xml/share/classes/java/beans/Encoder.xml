<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.beans">
        <import package="com.sun.beans.finder.PersistenceDelegateFinder"/>
        <import package="java.util.HashMap"/>
        <import package="java.util.IdentityHashMap"/>
        <import package="java.util.Map"/>
        <class name="Encoder" line="6">
            <javadoc line="6">
                An &lt;code&gt;Encoder&lt;/code&gt; is a class which can be used to create
                  files or streams that encode the state of a collection of
                  JavaBeans in terms of their public APIs. The &lt;code&gt;Encoder&lt;/code&gt;,
                  in conjunction with its persistence delegates, is responsible for
                  breaking the object graph down into a series of &lt;code&gt;Statements&lt;/code&gt;s
                  and &lt;code&gt;Expression&lt;/code&gt;s which can be used to create it.
                  A subclass typically provides a syntax for these expressions
                  using some human readable form - like Java source code or XML.                
                <since>
                    1.4                    
                </since>
                <author>
                    Philip Milne                    
                </author>
            </javadoc>
            <declaration name="finder" type="PersistenceDelegateFinder" line="19"/>
            <declaration name="bindings" type="Map" line="20"/>
            <declaration name="exceptionListener" type="ExceptionListener" line="21"/>
            <declaration name="executeStatements" type="boolean" line="22"/>
            <declaration name="attributes" type="Map" line="23"/>
            <javadoc line="24">
                Write the specified object to the output stream.
                  The serialized form will denote a series of
                  expressions, the combined effect of which will create
                  an equivalent object when the input stream is read.
                  By default, the object is assumed to be a &lt;em&gt;JavaBean&lt;/em&gt;
                  with a nullary constructor, whose state is defined by
                  the matching pairs of &quot;setter&quot; and &quot;getter&quot; methods
                  returned by the Introspector.                
                <param>
                    o The object to be written to the stream.                    
                </param>
                <see>
                    XMLDecoder#readObject                    
                </see>
            </javadoc>
            <method name="writeObject" type="void" line="36">
                <params>
                    <param name="o" type="Object"/>
                </params>
                <scope line="37"/>
                <declaration name="info" type="PersistenceDelegate" line="40"/>
            </method>
            <javadoc line="43">
                Sets the exception handler for this stream to &lt;code&gt;exceptionListener&lt;/code&gt;.
                  The exception handler is notified when this stream catches recoverable
                  exceptions.                
                <param>
                    exceptionListener The exception handler for this stream;
                      if &lt;code&gt;null&lt;/code&gt; the default exception listener will be used.                    
                </param>
                <see>
                    #getExceptionListener                    
                </see>
            </javadoc>
            <method name="setExceptionListener" type="void" line="51">
                <params>
                    <param name="exceptionListener" type="ExceptionListener"/>
                </params>
            </method>
            <javadoc line="54">
                Gets the exception handler for this stream.                
                <return>
                    The exception handler for this stream;
                      Will return the default exception listener if this has not explicitly been set.                    
                </return>
                <see>
                    #setExceptionListener                    
                </see>
            </javadoc>
            <method name="getExceptionListener" type="ExceptionListener" line="60"/>
            <method name="getValue" type="Object" line="63">
                <params>
                    <param name="exp" type="Expression"/>
                </params>
                <scope line="64"/>
                <scope line="67"/>
            </method>
            <javadoc line="72">
                Returns the persistence delegate for the given type.
                  The persistence delegate is calculated by applying
                  the following rules in order:
                  &lt;ol&gt;
                  &lt;li&gt;
                  If a persistence delegate is associated with the given type
                  by using the {@link #setPersistenceDelegate} method
                  it is returned.
                  &lt;li&gt;
                  A persistence delegate is then looked up by the name
                  composed of the the fully qualified name of the given type
                  and the &quot;PersistenceDelegate&quot; postfix.
                  For example, a persistence delegate for the {@code Bean} class
                  should be named {@code BeanPersistenceDelegate}and located in the same package.
                  &lt;pre&gt;
                  public class Bean { ... }
                  public class BeanPersistenceDelegate { ... }&lt;/pre&gt;
                  The instance of the {@code BeanPersistenceDelegate} class
                  is returned for the {@code Bean} class.
                  &lt;li&gt;
                  If the type is {@code null},
                  a shared internal persistence delegate is returned
                  that encodes {@code null} value.
                  &lt;li&gt;
                  If the type is a {@code enum} declaration,
                  a shared internal persistence delegate is returned
                  that encodes constants of this enumeration
                  by their names.
                  &lt;li&gt;
                  If the type is a primitive type or the corresponding wrapper,
                  a shared internal persistence delegate is returned
                  that encodes values of the given type.
                  &lt;li&gt;
                  If the type is an array,
                  a shared internal persistence delegate is returned
                  that encodes an array of the appropriate type and length,
                  and each of its elements as if they are properties.
                  &lt;li&gt;
                  If the type is a proxy,
                  a shared internal persistence delegate is returned
                  that encodes a proxy instance by using
                  the {@link java.lang.reflect.Proxy#newProxyInstance} method.
                  &lt;li&gt;
                  If the {@link BeanInfo} for this type has a {@link BeanDescriptor}which defined a &quot;persistenceDelegate&quot; attribute,
                  the value of this named attribute is returned.
                  &lt;li&gt;
                  In all other cases the default persistence delegate is returned.
                  The default persistence delegate assumes the type is a &lt;em&gt;JavaBean&lt;/em&gt;,
                  implying that it has a default constructor and that its state
                  may be characterized by the matching pairs of &quot;setter&quot; and &quot;getter&quot;
                  methods returned by the {@link Introspector} class.
                  The default constructor is the constructor with the greatest number
                  of parameters that has the {@link ConstructorProperties} annotation.
                  If none of the constructors has the {@code ConstructorProperties} annotation,
                  then the nullary constructor (constructor with no parameters) will be used.
                  For example, in the following code fragment, the nullary constructor
                  for the {@code Foo} class will be used,
                  while the two-parameter constructor
                  for the {@code Bar} class will be used.
                  &lt;pre&gt;
                  public class Foo {
                  public Foo() { ... }
                  public Foo(int x) { ... }
                  }
                  public class Bar {
                  public Bar() { ... }
                  &amp;#64;ConstructorProperties({&quot;x&quot;})
                  public Bar(int x) { ... }
                  &amp;#64;ConstructorProperties({&quot;x&quot;, &quot;y&quot;})
                  public Bar(int x, int y) { ... }
                  }&lt;/pre&gt;
                  &lt;/ol&gt;                
                <param>
                    type  the class of the objects                    
                </param>
                <return>
                    the persistence delegate for the given type                    
                </return>
                <see>
                    #setPersistenceDelegate                    
                </see>
                <see>
                    java.beans.Introspector#getBeanInfo                    
                </see>
                <see>
                    java.beans.BeanInfo#getBeanDescriptor                    
                </see>
            </javadoc>
            <method name="getPersistenceDelegate" type="PersistenceDelegate" line="151">
                <params>
                    <param name="type" type="Class&lt;?&gt;"/>
                </params>
                <declaration name="pd" type="PersistenceDelegate" line="152"/>
            </method>
            <javadoc line="155">
                Associates the specified persistence delegate with the given type.                
                <param>
                    type  the class of objects that the specified persistence delegate applies to                    
                </param>
                <param>
                    delegate  the persistence delegate for instances of the given type                    
                </param>
                <see>
                    #getPersistenceDelegate                    
                </see>
                <see>
                    java.beans.Introspector#getBeanInfo                    
                </see>
                <see>
                    java.beans.BeanInfo#getBeanDescriptor                    
                </see>
            </javadoc>
            <method name="setPersistenceDelegate" type="void" line="163">
                <params>
                    <param name="type" type="Class&lt;?&gt;"/>
                    <param name="delegate" type="PersistenceDelegate"/>
                </params>
            </method>
            <javadoc line="166">
                Removes the entry for this instance, returning the old entry.                
                <param>
                    oldInstance The entry that should be removed.                    
                </param>
                <return>
                    The entry that was removed.                    
                </return>
                <see>
                    #get                    
                </see>
            </javadoc>
            <method name="remove" type="Object" line="172">
                <params>
                    <param name="oldInstance" type="Object"/>
                </params>
                <declaration name="exp" type="Expression" line="173"/>
            </method>
            <javadoc line="176">
                Returns a tentative value for &lt;code&gt;oldInstance&lt;/code&gt; in
                  the environment created by this stream. A persistence
                  delegate can use its &lt;code&gt;mutatesTo&lt;/code&gt; method to
                  determine whether this value may be initialized to
                  form the equivalent object at the output or whether
                  a new object must be instantiated afresh. If the
                  stream has not yet seen this value, null is returned.                
                <param>
                    oldInstance The instance to be looked up.                    
                </param>
                <return>
                    The object, null if the object has not been seen before.                    
                </return>
            </javadoc>
            <method name="get" type="Object" line="187">
                <params>
                    <param name="oldInstance" type="Object"/>
                </params>
                <scope line="188"/>
                <declaration name="exp" type="Expression" line="191"/>
            </method>
            <method name="writeObject1" type="Object" line="194">
                <params>
                    <param name="oldInstance" type="Object"/>
                </params>
                <declaration name="o" type="Object" line="195"/>
                <scope line="196"/>
            </method>
            <method name="cloneStatement" type="Statement" line="202">
                <params>
                    <param name="oldExp" type="Statement"/>
                </params>
                <declaration name="oldTarget" type="Object" line="203"/>
                <declaration name="newTarget" type="Object" line="204"/>
                <declaration name="oldArgs" type="Object[]" line="205"/>
                <declaration name="newArgs" type="Object[]" line="206"/>
                <scope line="207"/>
                <declaration name="newExp" type="Statement" line="210"/>
            </method>
            <javadoc line="214">
                Writes statement &lt;code&gt;oldStm&lt;/code&gt; to the stream.
                  The &lt;code&gt;oldStm&lt;/code&gt; should be written entirely
                  in terms of the callers environment, i.e. the
                  target and all arguments should be part of the
                  object graph being written. These expressions
                  represent a series of &quot;what happened&quot; expressions
                  which tell the output stream how to produce an
                  object graph like the original.
                  &lt;p&gt;
                  The implementation of this method will produce
                  a second expression to represent the same expression in
                  an environment that will exist when the stream is read.
                  This is achieved simply by calling &lt;code&gt;writeObject&lt;/code&gt;
                  on the target and all the arguments and building a new
                  expression with the results.                
                <param>
                    oldStm The expression to be written to the stream.                    
                </param>
            </javadoc>
            <method name="writeStatement" type="void" line="232">
                <params>
                    <param name="oldStm" type="Statement"/>
                </params>
                <declaration name="newStm" type="Statement" line="233"/>
                <scope line="234">
                    <scope line="235"/>
                    <scope line="238"/>
                </scope>
            </method>
            <javadoc line="243">
                The implementation first checks to see if an
                  expression with this value has already been written.
                  If not, the expression is cloned, using
                  the same procedure as &lt;code&gt;writeStatement&lt;/code&gt;,
                  and the value of this expression is reconciled
                  with the value of the cloned expression
                  by calling &lt;code&gt;writeObject&lt;/code&gt;.                
                <param>
                    oldExp The expression to be written to the stream.                    
                </param>
            </javadoc>
            <method name="writeExpression" type="void" line="253">
                <params>
                    <param name="oldExp" type="Expression"/>
                </params>
                <declaration name="oldValue" type="Object" line="254"/>
                <scope line="255"/>
            </method>
            <method name="clear" type="void" line="261"/>
            <method name="setAttribute" type="void" line="264">
                <params>
                    <param name="key" type="Object"/>
                    <param name="value" type="Object"/>
                </params>
                <scope line="265"/>
            </method>
            <method name="getAttribute" type="Object" line="270">
                <params>
                    <param name="key" type="Object"/>
                </params>
                <scope line="271"/>
            </method>
        </class>
    </source>