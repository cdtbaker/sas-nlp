<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.beans">
        <import package="java.lang.reflect.AccessibleObject"/>
        <import package="java.lang.reflect.Array"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="com.sun.beans.finder.ClassFinder"/>
        <import package="com.sun.beans.finder.ConstructorFinder"/>
        <import package="com.sun.beans.finder.MethodFinder"/>
        <import package="sun.reflect.misc.MethodUtil"/>
        <class name="Statement" line="15">
            <javadoc line="15">
                A &lt;code&gt;Statement&lt;/code&gt; object represents a primitive statement
                  in which a single method is applied to a target and
                  a set of arguments - as in &lt;code&gt;&quot;a.setFoo(b)&quot;&lt;/code&gt;.
                  Note that where this example uses names
                  to denote the target and its argument, a statement
                  object does not require a name space and is constructed with
                  the values themselves.
                  The statement object associates the named method
                  with its environment as a simple set of values:
                  the target and an array of argument values.                
                <since>
                    1.4                    
                </since>
                <author>
                    Philip Milne                    
                </author>
            </javadoc>
            <declaration name="emptyArray" type="Object[]" line="30"/>
            <declaration name="defaultExceptionListener" type="ExceptionListener" line="31"/>
            <anonymous_class line="31">
                <method name="exceptionThrown" type="void" line="32">
                    <params>
                        <param name="e" type="Exception"/>
                    </params>
                </method>
            </anonymous_class>
            <declaration name="acc" type="AccessControlContext" line="38"/>
            <declaration name="target" type="Object" line="39"/>
            <declaration name="methodName" type="String" line="40"/>
            <declaration name="arguments" type="Object[]" line="41"/>
            <declaration name="loader" type="ClassLoader" line="42"/>
            <javadoc line="43">
                Creates a new {@link Statement} object
                  for the specified target object to invoke the method
                  specified by the name and by the array of arguments.
                  &lt;p&gt;
                  The {@code target} and the {@code methodName} values should not be {@code null}.
                  Otherwise an attempt to execute this {@code Expression}will result in a {@code NullPointerException}.
                  If the {@code arguments} value is {@code null},
                  an empty array is used as the value of the {@code arguments} property.                
                <param>
                    target  the target object of this statement                    
                </param>
                <param>
                    methodName  the name of the method to invoke on the specified target                    
                </param>
                <param>
                    arguments  the array of arguments to invoke the specified method                    
                </param>
            </javadoc>
            <method name="Statement" type="constructor" line="56">
                <params>
                    <param name="target" type="Object"/>
                    <param name="methodName" type="String"/>
                    <param name="arguments" type="Object[]"/>
                </params>
            </method>
            <javadoc line="61">
                Returns the target object of this statement.
                  If this method returns {@code null},
                  the {@link #execute} method
                  throws a {@code NullPointerException}.                
                <return>
                    the target object of this statement                    
                </return>
            </javadoc>
            <method name="getTarget" type="Object" line="68"/>
            <javadoc line="71">
                Returns the name of the method to invoke.
                  If this method returns {@code null},
                  the {@link #execute} method
                  throws a {@code NullPointerException}.                
                <return>
                    the name of the method                    
                </return>
            </javadoc>
            <method name="getMethodName" type="String" line="78"/>
            <javadoc line="81">
                Returns the arguments for the method to invoke.
                  The number of arguments and their types
                  must match the method being  called.{@code null} can be used as a synonym of an empty array.                
                <return>
                    the array of arguments                    
                </return>
            </javadoc>
            <method name="getArguments" type="Object[]" line="87"/>
            <javadoc line="90">
                The {@code execute} method finds a method whose name is the same
                  as the {@code methodName} property, and invokes the method on
                  the target.
                  When the target&apos;s class defines many methods with the given name
                  the implementation should choose the most specific method using
                  the algorithm specified in the Java Language Specification
                  (15.11). The dynamic class of the target and arguments are used
                  in place of the compile-time type information and, like the{@link java.lang.reflect.Method} class itself, conversion between
                  primitive values and their associated wrapper classes is handled
                  internally.
                  &lt;p&gt;
                  The following method types are handled as special cases:
                  &lt;ul&gt;
                  &lt;li&gt;
                  Static methods may be called by using a class object as the target.
                  &lt;li&gt;
                  The reserved method name &quot;new&quot; may be used to call a class&apos;s constructor
                  as if all classes defined static &quot;new&quot; methods. Constructor invocations
                  are typically considered {@code Expression}s rather than {@code Statement}s
                  as they return a value.
                  &lt;li&gt;
                  The method names &quot;get&quot; and &quot;set&quot; defined in the {@link java.util.List}interface may also be applied to array instances, mapping to
                  the static methods of the same name in the {@code Array} class.
                  &lt;/ul&gt;                
                <throws>
                    NullPointerException if the value of the {@code target} or{@code methodName} property is {@code null}                    
                </throws>
                <throws>
                    NoSuchMethodException if a matching method is not found                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and
                      it denies the method invocation                    
                </throws>
                <throws>
                    Exception that is thrown by the invoked method                    
                </throws>
                <see>
                    java.lang.reflect.Method                    
                </see>
            </javadoc>
            <method name="execute" type="void" line="122"/>
            <method name="invoke" type="Object" line="125">
                <declaration name="acc" type="AccessControlContext" line="126"/>
                <scope line="127"/>
                <scope line="130">
                    <anonymous_class line="131">
                        <method name="run" type="Object" line="132"/>
                    </anonymous_class>
                </scope>
                <scope line="138"/>
            </method>
            <method name="invokeInternal" type="Object" line="142">
                <declaration name="target" type="Object" line="143"/>
                <declaration name="methodName" type="String" line="144"/>
                <scope line="145"/>
                <declaration name="arguments" type="Object[]" line="148"/>
                <scope line="149"/>
                <scope line="152"/>
                <declaration name="argClasses" type="Class[]" line="155"/>
                <scope line="156"/>
                <declaration name="m" type="AccessibleObject" line="159"/>
                <scope line="160">
                    <scope line="161"/>
                    <scope line="164">
                        <declaration name="result" type="Object" line="165"/>
                        <scope line="166"/>
                    </scope>
                    <scope line="171">
                        <scope line="172"/>
                        <scope line="175"/>
                        <scope line="178"/>
                    </scope>
                    <scope line="182"/>
                    <scope line="185"/>
                </scope>
                <scope line="189">
                    <scope line="190">
                        <declaration name="index" type="int" line="191"/>
                        <scope line="192"/>
                        <scope line="195"/>
                    </scope>
                </scope>
                <scope line="202">
                    <scope line="203">
                        <scope line="204"/>
                        <scope line="207"/>
                    </scope>
                    <scope line="211"/>
                    <scope line="214">
                        <declaration name="te" type="Throwable" line="215"/>
                        <scope line="216"/>
                        <scope line="219"/>
                    </scope>
                </scope>
            </method>
            <method name="instanceName" type="String" line="226">
                <params>
                    <param name="instance" type="Object"/>
                </params>
                <scope line="227"/>
                <scope line="230"/>
                <scope line="233"/>
            </method>
            <javadoc line="237">
                Prints the value of this statement using a Java-style syntax.                
            </javadoc>
            <method name="toString" type="String" line="240">
                <declaration name="target" type="Object" line="241"/>
                <declaration name="methodName" type="String" line="242"/>
                <declaration name="arguments" type="Object[]" line="243"/>
                <scope line="244"/>
                <declaration name="result" type="StringBuffer" line="247"/>
                <declaration name="n" type="int" line="248"/>
                <scope line="249">
                    <scope line="251"/>
                </scope>
            </method>
            <method name="getMethod" type="Method" line="258">
                <params>
                    <param name="type" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="args" type="Class<?>"/>
                </params>
                <scope line="259"/>
                <scope line="262"/>
            </method>
        </class>
    </source>