<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.beans">
        <import package="java.lang.reflect.AccessibleObject"/>
        <import package="java.lang.reflect.Array"/>
        <import package="java.lang.reflect.Constructor"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.security.AccessControlContext"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="com.sun.beans.finder.ClassFinder"/>
        <import package="com.sun.beans.finder.ConstructorFinder"/>
        <import package="com.sun.beans.finder.MethodFinder"/>
        <import package="sun.reflect.misc.MethodUtil"/>
        <class name="Statement" line="42">
            <javadoc line="42">
                A &lt;code&gt;Statement&lt;/code&gt; object represents a primitive statement
                  in which a single method is applied to a target and
                  a set of arguments - as in &lt;code&gt;&quot;a.setFoo(b)&quot;&lt;/code&gt;.
                  Note that where this example uses names
                  to denote the target and its argument, a statement
                  object does not require a name space and is constructed with
                  the values themselves.
                  The statement object associates the named method
                  with its environment as a simple set of values:
                  the target and an array of argument values.                
                <since>
                    1.4                    
                </since>
                <author>
                    Philip Milne                    
                </author>
            </javadoc>
            <declaration name="emptyArray" type="Object[]" line="60"/>
            <declaration name="defaultExceptionListener" type="ExceptionListener" line="62"/>
            <anonymous_class line="62">
                <method name="exceptionThrown" type="void" line="63">
                    <params>
                        <param name="e" type="Exception"/>
                    </params>
                    <comment line="66">
                        e.printStackTrace();                        
                    </comment>
                </method>
            </anonymous_class>
            <declaration name="acc" type="AccessControlContext" line="70"/>
            <declaration name="target" type="Object" line="71"/>
            <declaration name="methodName" type="String" line="72"/>
            <declaration name="arguments" type="Object[]" line="73"/>
            <declaration name="loader" type="ClassLoader" line="74"/>
            <javadoc line="76">
                Creates a new {@link Statement} object
                  for the specified target object to invoke the method
                  specified by the name and by the array of arguments.
                  &lt;p&gt;
                  The {@code target} and the {@code methodName} values should not be {@code null}.
                  Otherwise an attempt to execute this {@code Expression}will result in a {@code NullPointerException}.
                  If the {@code arguments} value is {@code null},
                  an empty array is used as the value of the {@code arguments} property.                
                <param>
                    target  the target object of this statement                    
                </param>
                <param>
                    methodName  the name of the method to invoke on the specified target                    
                </param>
                <param>
                    arguments  the array of arguments to invoke the specified method                    
                </param>
            </javadoc>
            <method name="Statement" type="constructor" line="92">
                <params>
                    <param name="target" type="Object"/>
                    <param name="methodName" type="String"/>
                    <param name="arguments" type="Object[]"/>
                </params>
            </method>
            <javadoc line="98">
                Returns the target object of this statement.
                  If this method returns {@code null},
                  the {@link #execute} method
                  throws a {@code NullPointerException}.                
                <return>
                    the target object of this statement                    
                </return>
            </javadoc>
            <method name="getTarget" type="Object" line="106"/>
            <javadoc line="110">
                Returns the name of the method to invoke.
                  If this method returns {@code null},
                  the {@link #execute} method
                  throws a {@code NullPointerException}.                
                <return>
                    the name of the method                    
                </return>
            </javadoc>
            <method name="getMethodName" type="String" line="118"/>
            <javadoc line="122">
                Returns the arguments for the method to invoke.
                  The number of arguments and their types
                  must match the method being  called.{@code null} can be used as a synonym of an empty array.                
                <return>
                    the array of arguments                    
                </return>
            </javadoc>
            <method name="getArguments" type="Object[]" line="130"/>
            <javadoc line="134">
                The {@code execute} method finds a method whose name is the same
                  as the {@code methodName} property, and invokes the method on
                  the target.
                  When the target&apos;s class defines many methods with the given name
                  the implementation should choose the most specific method using
                  the algorithm specified in the Java Language Specification
                  (15.11). The dynamic class of the target and arguments are used
                  in place of the compile-time type information and, like the{@link java.lang.reflect.Method} class itself, conversion between
                  primitive values and their associated wrapper classes is handled
                  internally.
                  &lt;p&gt;
                  The following method types are handled as special cases:
                  &lt;ul&gt;
                  &lt;li&gt;
                  Static methods may be called by using a class object as the target.
                  &lt;li&gt;
                  The reserved method name &quot;new&quot; may be used to call a class&apos;s constructor
                  as if all classes defined static &quot;new&quot; methods. Constructor invocations
                  are typically considered {@code Expression}s rather than {@code Statement}s
                  as they return a value.
                  &lt;li&gt;
                  The method names &quot;get&quot; and &quot;set&quot; defined in the {@link java.util.List}interface may also be applied to array instances, mapping to
                  the static methods of the same name in the {@code Array} class.
                  &lt;/ul&gt;                
                <throws>
                    NullPointerException if the value of the {@code target} or{@code methodName} property is {@code null}                    
                </throws>
                <throws>
                    NoSuchMethodException if a matching method is not found                    
                </throws>
                <throws>
                    SecurityException if a security manager exists and
                      it denies the method invocation                    
                </throws>
                <throws>
                    Exception that is thrown by the invoked method                    
                </throws>
                <see>
                    java.lang.reflect.Method                    
                </see>
            </javadoc>
            <method name="execute" type="void" line="172"/>
            <method name="invoke" type="Object" line="176">
                <declaration name="acc" type="AccessControlContext" line="177"/>
                <scope line="178"/>
                <scope line="181">
                    <anonymous_class line="183">
                        <method name="run" type="Object" line="184"/>
                    </anonymous_class>
                </scope>
                <scope line="191"/>
            </method>
            <method name="invokeInternal" type="Object" line="196">
                <comment line="210">
                    Class.forName() won&apos;t load classes outside
                     of core from a class inside core. Special
                     case this method.                    
                </comment>
                <comment line="223">
                    For class methods, simluate the effect of a meta class
                    by taking the union of the static methods of the
                    actual class, with the instance methods of &quot;Class.class&quot;
                    and the overloaded &quot;newInstance&quot; methods defined by the
                    constructors.
                    This way &quot;System.class&quot;, for example, will perform both
                    the static method getProperties() and the instance method
                    getSuperclass() defined in &quot;Class.class&quot;.                    
                </comment>
                <comment line="236">
                    Provide a short form for array instantiation by faking an nary-constructor.                    
                </comment>
                <comment line="245">
                    The Character class, as of 1.4, does not have a constructor
                     which takes a String. All of the other &quot;wrapper&quot; classes
                     for Java&apos;s primitive types have a String constructor so we
                     fake such a constructor here so that this special case can be
                     ignored elsewhere.                    
                </comment>
                <comment line="269">
                    This special casing of arrays is not necessary, but makes files
                    involving arrays much shorter and simplifies the archiving infrastrcure.
                    The Array.set() method introduces an unusual idea - that of a static method
                    changing the state of an instance. Normally statements with side
                    effects on objects are instance methods of the objects themselves
                    and we reinstate this rule (perhaps temporarily) by special-casing arrays.                    
                </comment>
                <declaration name="target" type="Object" line="197"/>
                <declaration name="methodName" type="String" line="198"/>
                <scope line="200"/>
                <declaration name="arguments" type="Object[]" line="205"/>
                <scope line="206"/>
                <scope line="212"/>
                <declaration name="argClasses" type="Class[]" line="215"/>
                <scope line="216"/>
                <declaration name="m" type="AccessibleObject" line="220"/>
                <scope line="221">
                    <scope line="232"/>
                    <scope line="236">
                        <declaration name="result" type="Object" line="237"/>
                        <scope line="238"/>
                    </scope>
                    <scope line="243">
                        <scope line="250"/>
                        <scope line="253"/>
                        <scope line="256"/>
                    </scope>
                    <scope line="260"/>
                    <scope line="263"/>
                </scope>
                <scope line="267">
                    <scope line="277">
                        <declaration name="index" type="int" line="278"/>
                        <scope line="279"/>
                        <scope line="282"/>
                    </scope>
                </scope>
                <scope line="289">
                    <scope line="290">
                        <scope line="291"/>
                        <scope line="294"/>
                    </scope>
                    <scope line="298"/>
                    <scope line="303">
                        <declaration name="te" type="Throwable" line="304"/>
                        <scope line="305"/>
                        <scope line="308"/>
                    </scope>
                </scope>
            </method>
            <method name="instanceName" type="String" line="316">
                <params>
                    <param name="instance" type="Object"/>
                </params>
                <comment line="323">
                    Note: there is a minor problem with using the non-caching
                     NameGenerator method. The return value will not have
                     specific information about the inner class name. For example,
                     In 1.4.2 an inner class would be represented as JList$1 now
                     would be named Class.                    
                </comment>
                <scope line="317"/>
                <scope line="319"/>
                <scope line="321"/>
            </method>
            <javadoc line="332">
                Prints the value of this statement using a Java-style syntax.                
            </javadoc>
            <method name="toString" type="String" line="335">
                <comment line="337">
                    Respect a subclass&apos;s implementation here.                    
                </comment>
                <declaration name="target" type="Object" line="337"/>
                <declaration name="methodName" type="String" line="338"/>
                <declaration name="arguments" type="Object[]" line="339"/>
                <scope line="340"/>
                <declaration name="result" type="StringBuffer" line="343"/>
                <declaration name="n" type="int" line="344"/>
                <scope line="345">
                    <scope line="347"/>
                </scope>
            </method>
            <method name="getMethod" type="Method" line="355">
                <params>
                    <param name="type" type="Class<?>"/>
                    <param name="name" type="String"/>
                    <param name="args" type="Class<?>"/>
                </params>
                <scope line="356"/>
                <scope line="359"/>
            </method>
        </class>
    </source>