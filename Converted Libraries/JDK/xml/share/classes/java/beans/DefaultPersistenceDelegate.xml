<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.beans">
        <import package="java.util"/>
        <import package="java.lang.reflect"/>
        <import package="java.util.Objects"/>
        <import package="sun.reflect.misc"/>
        <class name="DefaultPersistenceDelegate" line="33">
            <extends class="PersistenceDelegate"/>
            <comment line="221">
                Write out the properties of this instance.                
            </comment>
            <javadoc line="33">
                The &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; is a concrete implementation of
                  the abstract &lt;code&gt;PersistenceDelegate&lt;/code&gt; class and
                  is the delegate used by default for classes about
                  which no information is available. The &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt;
                  provides, version resilient, public API-based persistence for
                  classes that follow the JavaBeans&amp;trade; conventions without any class specific
                  configuration.
                  &lt;p&gt;
                  The key assumptions are that the class has a nullary constructor
                  and that its state is accurately represented by matching pairs
                  of &quot;setter&quot; and &quot;getter&quot; methods in the order they are returned
                  by the Introspector.
                  In addition to providing code-free persistence for JavaBeans,
                  the &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; provides a convenient means
                  to effect persistent storage for classes that have a constructor
                  that, while not nullary, simply requires some property values
                  as arguments.                
                <see>
                    #DefaultPersistenceDelegate(String[])                    
                </see>
                <see>
                    java.beans.Introspector                    
                </see>
                <since>
                    1.4                    
                </since>
                <author>
                    Philip Milne                    
                </author>
            </javadoc>
            <declaration name="constructor" type="String[]" line="61"/>
            <declaration name="definesEquals" type="Boolean" line="62"/>
            <javadoc line="64">
                Creates a persistence delegate for a class with a nullary constructor.                
                <see>
                    #DefaultPersistenceDelegate(java.lang.String[])                    
                </see>
            </javadoc>
            <method name="DefaultPersistenceDelegate" type="constructor" line="69"/>
            <javadoc line="73">
                Creates a default persistence delegate for a class with a
                  constructor whose arguments are the values of the property
                  names as specified by &lt;code&gt;constructorPropertyNames&lt;/code&gt;.
                  The constructor arguments are created by
                  evaluating the property names in the order they are supplied.
                  To use this class to specify a single preferred constructor for use
                  in the serialization of a particular type, we state the
                  names of the properties that make up the constructor&apos;s
                  arguments. For example, the &lt;code&gt;Font&lt;/code&gt; class which
                  does not define a nullary constructor can be handled
                  with the following persistence delegate:
                  &lt;pre&gt;
                  new DefaultPersistenceDelegate(new String[]{&quot;name&quot;, &quot;style&quot;, &quot;size&quot;});
                  &lt;/pre&gt;                
                <param>
                    constructorPropertyNames The property names for the arguments of this constructor.                    
                </param>
                <see>
                    #instantiate                    
                </see>
            </javadoc>
            <method name="DefaultPersistenceDelegate" type="constructor" line="94">
                <params>
                    <param name="constructorPropertyNames" type="String[]"/>
                </params>
            </method>
            <method name="definesEquals" type="boolean" line="98">
                <params>
                    <param name="type" type="Class"/>
                </params>
                <scope line="99"/>
                <scope line="102"/>
            </method>
            <method name="definesEquals" type="boolean" line="107">
                <params>
                    <param name="instance" type="Object"/>
                </params>
                <scope line="108"/>
                <scope line="111">
                    <declaration name="result" type="boolean" line="112"/>
                </scope>
            </method>
            <javadoc line="118">
                If the number of arguments in the specified constructor is non-zero and
                  the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method
                  this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;.
                  Otherwise, this method uses the superclass&apos;s definition which returns true if the
                  classes of the two instances are equal.                
                <param>
                    oldInstance The instance to be copied.                    
                </param>
                <param>
                    newInstance The instance that is to be modified.                    
                </param>
                <return>
                    True if an equivalent copy of <code>newInstance</code> may be
                      created by applying a series of mutations to <code>oldInstance</code>.                    
                </return>
                <see>
                    #DefaultPersistenceDelegate(String[])                    
                </see>
            </javadoc>
            <method name="mutatesTo" type="boolean" line="132">
                <params>
                    <param name="oldInstance" type="Object"/>
                    <param name="newInstance" type="Object"/>
                </params>
                <comment line="133">
                    Assume the instance is either mutable or a singleton                    
                </comment>
                <comment line="134">
                    if it has a nullary constructor.                    
                </comment>
            </method>
            <javadoc line="140">
                This default implementation of the &lt;code&gt;instantiate&lt;/code&gt; method returns
                  an expression containing the predefined method name &quot;new&quot; which denotes a
                  call to a constructor with the arguments as specified in
                  the &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt;&apos;s constructor.                
                <param>
                    oldInstance The instance to be instantiated.                    
                </param>
                <param>
                    out The code output stream.                    
                </param>
                <return>
                    An expression whose value is <code>oldInstance</code>.                    
                </return>
                <throws>
                    NullPointerException if {@code out} is {@code null}                    
                </throws>
                <see>
                    #DefaultPersistenceDelegate(String[])                    
                </see>
            </javadoc>
            <method name="instantiate" type="Expression" line="154">
                <params>
                    <param name="oldInstance" type="Object"/>
                    <param name="out" type="Encoder"/>
                </params>
                <declaration name="nArgs" type="int" line="155"/>
                <declaration name="type" type="Class" line="156"/>
                <declaration name="constructorArgs" type="Object[]" line="157"/>
                <scope line="158">
                    <scope line="159">
                        <declaration name="method" type="Method" line="160"/>
                    </scope>
                    <scope line="163"/>
                </scope>
            </method>
            <method name="findMethod" type="Method" line="170">
                <params>
                    <param name="type" type="Class"/>
                    <param name="property" type="String"/>
                </params>
                <scope line="171"/>
                <declaration name="pd" type="PropertyDescriptor" line="174"/>
                <scope line="175"/>
                <declaration name="method" type="Method" line="178"/>
                <scope line="179"/>
            </method>
            <method name="doProperty" type="void" line="185">
                <params>
                    <param name="type" type="Class"/>
                    <param name="pd" type="PropertyDescriptor"/>
                    <param name="oldInstance" type="Object"/>
                    <param name="newInstance" type="Object"/>
                    <param name="out" type="Encoder"/>
                </params>
                <comment line="196">
                    Search for a static constant with this value;                    
                </comment>
                <declaration name="getter" type="Method" line="186"/>
                <declaration name="setter" type="Method" line="187"/>
                <scope line="189">
                    <declaration name="oldGetExp" type="Expression" line="190"/>
                    <declaration name="newGetExp" type="Expression" line="191"/>
                    <declaration name="oldValue" type="Object" line="192"/>
                    <declaration name="newValue" type="Object" line="193"/>
                    <scope line="195">
                        <declaration name="e" type="Object" line="197"/>
                        <scope line="198">
                            <declaration name="a" type="Object[]" line="199"/>
                            <scope line="200">
                                <scope line="201">
                                    <declaration name="f" type="Field" line="202"/>
                                    <scope line="203"/>
                                </scope>
                                <scope line="208"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="invokeStatement" type="void" line="216">
                <params>
                    <param name="instance" type="Object"/>
                    <param name="methodName" type="String"/>
                    <param name="args" type="Object[]"/>
                    <param name="out" type="Encoder"/>
                </params>
            </method>
            <method name="initBean" type="void" line="221">
                <params>
                    <param name="type" type="Class"/>
                    <param name="oldInstance" type="Object"/>
                    <param name="newInstance" type="Object"/>
                    <param name="out" type="Encoder"/>
                </params>
                <comment line="247">
                    Properties                    
                </comment>
                <comment line="260">
                    Listeners                    
                </comment>
                <comment line="261">
                    Pending(milne). There is a general problem with the archival of
                    listeners which is unresolved as of 1.4. Many of the methods
                    which install one object inside another (typically &quot;add&quot; methods
                    or setters) automatically install a listener on the &quot;child&quot; object
                    so that its &quot;parent&quot; may respond to changes that are made to it.
                    For example the JTable:setModel() method automatically adds a
                    TableModelListener (the JTable itself in this case) to the supplied
                    table model.
                    
                    We do not need to explictly add these listeners to the model in an
                    archive as they will be added automatically by, in the above case,
                    the JTable&apos;s &quot;setModel&quot; method. In some cases, we must specifically
                    avoid trying to do this since the listener may be an inner class
                    that cannot be instantiated using public API.
                    
                    No general mechanism currently
                    exists for differentiating between these kind of listeners and
                    those which were added explicitly by the user. A mechanism must
                    be created to provide a general means to differentiate these
                    special cases so as to provide reliable persistence of listeners
                    for the general case.                    
                </comment>
                <comment line="285">
                    Just handle the listeners of Components for now.                    
                </comment>
                <comment line="294">
                    The ComponentListener is added automatically, when                    
                </comment>
                <comment line="295">
                    Contatiner:add is called on the parent.                    
                </comment>
                <comment line="300">
                    JMenuItems have a change listener added to them in                    
                </comment>
                <comment line="301">
                    their &quot;add&quot; methods to enable accessibility support -                    
                </comment>
                <comment line="302">
                    see the add method in JMenuItem for details. We cannot                    
                </comment>
                <comment line="303">
                    instantiate this instance as it is a private inner class                    
                </comment>
                <comment line="304">
                    and do not need to do this anyway since it will be created                    
                </comment>
                <comment line="305">
                    and installed by the &quot;add&quot; method. Special case this for now,                    
                </comment>
                <comment line="306">
                    ignoring all change listeners on JMenuItems.                    
                </comment>
                <comment line="330">
                    Asssume the listeners are in the same order and that there are no gaps.                    
                </comment>
                <comment line="331">
                    Eventually, this may need to do true differencing.                    
                </comment>
                <comment line="334">
                    System.out.println(&quot;Adding listener: &quot; + addListenerMethodName + oldL[i]);                    
                </comment>
                <scope line="222">
                    <declaration name="mod" type="int" line="223"/>
                    <scope line="224"/>
                    <scope line="227">
                        <declaration name="oldGetExp" type="Expression" line="228"/>
                        <declaration name="newGetExp" type="Expression" line="229"/>
                        <declaration name="oldValue" type="Object" line="230"/>
                        <declaration name="newValue" type="Object" line="231"/>
                        <scope line="233"/>
                    </scope>
                    <scope line="237"/>
                </scope>
                <declaration name="info" type="BeanInfo" line="241"/>
                <scope line="242"/>
                <scope line="244"/>
                <scope line="248">
                    <scope line="249"/>
                    <scope line="252"/>
                    <scope line="255"/>
                </scope>
                <scope line="284"/>
                <scope line="287">
                    <scope line="288"/>
                    <declaration name="listenerType" type="Class" line="291"/>
                    <scope line="296"/>
                    <scope line="308"/>
                    <declaration name="oldL" type="EventListener[]" line="312"/>
                    <declaration name="newL" type="EventListener[]" line="313"/>
                    <scope line="314">
                        <declaration name="m" type="Method" line="315"/>
                    </scope>
                    <scope line="319">
                        <scope line="320">
                            <declaration name="m" type="Method" line="321"/>
                        </scope>
                        <scope line="325"/>
                    </scope>
                    <declaration name="addListenerMethodName" type="String" line="332"/>
                    <scope line="333"/>
                    <declaration name="removeListenerMethodName" type="String" line="338"/>
                    <scope line="339"/>
                </scope>
            </method>
            <javadoc line="345">
                This default implementation of the &lt;code&gt;initialize&lt;/code&gt; method assumes
                  all state held in objects of this type is exposed via the
                  matching pairs of &quot;setter&quot; and &quot;getter&quot; methods in the order
                  they are returned by the Introspector. If a property descriptor
                  defines a &quot;transient&quot; attribute with a value equal to
                  &lt;code&gt;Boolean.TRUE&lt;/code&gt; the property is ignored by this
                  default implementation. Note that this use of the word
                  &quot;transient&quot; is quite independent of the field modifier
                  that is used by the &lt;code&gt;ObjectOutputStream&lt;/code&gt;.
                  &lt;p&gt;
                  For each non-transient property, an expression is created
                  in which the nullary &quot;getter&quot; method is applied
                  to the &lt;code&gt;oldInstance&lt;/code&gt;. The value of this
                  expression is the value of the property in the instance that is
                  being serialized. If the value of this expression
                  in the cloned environment &lt;code&gt;mutatesTo&lt;/code&gt; the
                  target value, the new value is initialized to make it
                  equivalent to the old value. In this case, because
                  the property value has not changed there is no need to
                  call the corresponding &quot;setter&quot; method and no statement
                  is emitted. If not however, the expression for this value
                  is replaced with another expression (normally a constructor)
                  and the corresponding &quot;setter&quot; method is called to install
                  the new property value in the object. This scheme removes
                  default information from the output produced by streams
                  using this delegate.
                  &lt;p&gt;
                  In passing these statements to the output stream, where they
                  will be executed, side effects are made to the &lt;code&gt;newInstance&lt;/code&gt;.
                  In most cases this allows the problem of properties
                  whose values depend on each other to actually help the
                  serialization process by making the number of statements
                  that need to be written to the output smaller. In general,
                  the problem of handling interdependent properties is reduced to
                  that of finding an order for the properties in
                  a class such that no property value depends on the value of
                  a subsequent property.                
                <param>
                    oldInstance The instance to be copied.                    
                </param>
                <param>
                    newInstance The instance that is to be modified.                    
                </param>
                <param>
                    out The stream to which any initialization statements should be written.                    
                </param>
                <throws>
                    NullPointerException if {@code out} is {@code null}                    
                </throws>
                <see>
                    java.beans.Introspector#getBeanInfo                    
                </see>
                <see>
                    java.beans.PropertyDescriptor                    
                </see>
            </javadoc>
            <method name="initialize" type="void" line="396">
                <params>
                    <param name="type" type="Class<?>"/>
                    <param name="oldInstance" type="Object"/>
                    <param name="newInstance" type="Object"/>
                    <param name="out" type="Encoder"/>
                </params>
                <comment line="397">
                    System.out.println(&quot;DefulatPD:initialize&quot; + type);                    
                </comment>
                <comment line="399">
                    !type.isInterface()) {                    
                </comment>
                <scope line="399"/>
            </method>
            <method name="getPropertyDescriptor" type="PropertyDescriptor" line="404">
                <params>
                    <param name="type" type="Class"/>
                    <param name="property" type="String"/>
                </params>
                <scope line="405">
                    <scope line="406"/>
                </scope>
                <scope line="410"/>
            </method>
        </class>
    </source>