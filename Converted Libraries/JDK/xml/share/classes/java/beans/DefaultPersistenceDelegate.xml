<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.beans">
        <import package="java.util"/>
        <import package="java.lang.reflect"/>
        <import package="java.util.Objects"/>
        <import package="sun.reflect.misc"/>
        <class name="DefaultPersistenceDelegate" line="6">
            <extends class="PersistenceDelegate"/>
            <javadoc line="6">
                The &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; is a concrete implementation of
                  the abstract &lt;code&gt;PersistenceDelegate&lt;/code&gt; class and
                  is the delegate used by default for classes about
                  which no information is available. The &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt;
                  provides, version resilient, public API-based persistence for
                  classes that follow the JavaBeans&amp;trade; conventions without any class specific
                  configuration.
                  &lt;p&gt;
                  The key assumptions are that the class has a nullary constructor
                  and that its state is accurately represented by matching pairs
                  of &quot;setter&quot; and &quot;getter&quot; methods in the order they are returned
                  by the Introspector.
                  In addition to providing code-free persistence for JavaBeans,
                  the &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; provides a convenient means
                  to effect persistent storage for classes that have a constructor
                  that, while not nullary, simply requires some property values
                  as arguments.                
                <see>
                    #DefaultPersistenceDelegate(String[])                    
                </see>
                <see>
                    java.beans.Introspector                    
                </see>
                <since>
                    1.4                    
                </since>
                <author>
                    Philip Milne                    
                </author>
            </javadoc>
            <declaration name="constructor" type="String[]" line="30"/>
            <declaration name="definesEquals" type="Boolean" line="31"/>
            <javadoc line="32">
                Creates a persistence delegate for a class with a nullary constructor.                
                <see>
                    #DefaultPersistenceDelegate(java.lang.String[])                    
                </see>
            </javadoc>
            <method name="DefaultPersistenceDelegate" type="constructor" line="36"/>
            <javadoc line="39">
                Creates a default persistence delegate for a class with a
                  constructor whose arguments are the values of the property
                  names as specified by &lt;code&gt;constructorPropertyNames&lt;/code&gt;.
                  The constructor arguments are created by
                  evaluating the property names in the order they are supplied.
                  To use this class to specify a single preferred constructor for use
                  in the serialization of a particular type, we state the
                  names of the properties that make up the constructor&apos;s
                  arguments. For example, the &lt;code&gt;Font&lt;/code&gt; class which
                  does not define a nullary constructor can be handled
                  with the following persistence delegate:
                  &lt;pre&gt;
                  new DefaultPersistenceDelegate(new String[]{&quot;name&quot;, &quot;style&quot;, &quot;size&quot;});
                  &lt;/pre&gt;                
                <param>
                    constructorPropertyNames The property names for the arguments of this constructor.                    
                </param>
                <see>
                    #instantiate                    
                </see>
            </javadoc>
            <method name="DefaultPersistenceDelegate" type="constructor" line="57">
                <params>
                    <param name="constructorPropertyNames" type="String[]"/>
                </params>
            </method>
            <method name="definesEquals" type="boolean" line="60">
                <params>
                    <param name="type" type="Class"/>
                </params>
                <scope line="61"/>
                <scope line="64"/>
            </method>
            <method name="definesEquals" type="boolean" line="68">
                <params>
                    <param name="instance" type="Object"/>
                </params>
                <scope line="69"/>
                <scope line="72">
                    <declaration name="result" type="boolean" line="73"/>
                </scope>
            </method>
            <javadoc line="78">
                If the number of arguments in the specified constructor is non-zero and
                  the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method
                  this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;.
                  Otherwise, this method uses the superclass&apos;s definition which returns true if the
                  classes of the two instances are equal.                
                <param>
                    oldInstance The instance to be copied.                    
                </param>
                <param>
                    newInstance The instance that is to be modified.                    
                </param>
                <return>
                    True if an equivalent copy of &lt;code&gt;newInstance&lt;/code&gt; may be
                      created by applying a series of mutations to &lt;code&gt;oldInstance&lt;/code&gt;.                    
                </return>
                <see>
                    #DefaultPersistenceDelegate(String[])                    
                </see>
            </javadoc>
            <method name="mutatesTo" type="boolean" line="90">
                <params>
                    <param name="oldInstance" type="Object"/>
                    <param name="newInstance" type="Object"/>
                </params>
            </method>
            <javadoc line="93">
                This default implementation of the &lt;code&gt;instantiate&lt;/code&gt; method returns
                  an expression containing the predefined method name &quot;new&quot; which denotes a
                  call to a constructor with the arguments as specified in
                  the &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt;&apos;s constructor.                
                <param>
                    oldInstance The instance to be instantiated.                    
                </param>
                <param>
                    out The code output stream.                    
                </param>
                <return>
                    An expression whose value is &lt;code&gt;oldInstance&lt;/code&gt;.                    
                </return>
                <throws>
                    NullPointerException if {@code out} is {@code null}                    
                </throws>
                <see>
                    #DefaultPersistenceDelegate(String[])                    
                </see>
            </javadoc>
            <method name="instantiate" type="Expression" line="104">
                <params>
                    <param name="oldInstance" type="Object"/>
                    <param name="out" type="Encoder"/>
                </params>
                <declaration name="nArgs" type="int" line="105"/>
                <declaration name="type" type="Class" line="106"/>
                <declaration name="constructorArgs" type="Object[]" line="107"/>
                <scope line="108">
                    <scope line="109">
                        <declaration name="method" type="Method" line="110"/>
                    </scope>
                    <scope line="113"/>
                </scope>
            </method>
            <method name="findMethod" type="Method" line="119">
                <params>
                    <param name="type" type="Class"/>
                    <param name="property" type="String"/>
                </params>
                <scope line="120"/>
                <declaration name="pd" type="PropertyDescriptor" line="123"/>
                <scope line="124"/>
                <declaration name="method" type="Method" line="127"/>
                <scope line="128"/>
            </method>
            <method name="doProperty" type="void" line="133">
                <params>
                    <param name="type" type="Class"/>
                    <param name="pd" type="PropertyDescriptor"/>
                    <param name="oldInstance" type="Object"/>
                    <param name="newInstance" type="Object"/>
                    <param name="out" type="Encoder"/>
                </params>
                <declaration name="getter" type="Method" line="134"/>
                <declaration name="setter" type="Method" line="135"/>
                <scope line="136">
                    <declaration name="oldGetExp" type="Expression" line="137"/>
                    <declaration name="newGetExp" type="Expression" line="138"/>
                    <declaration name="oldValue" type="Object" line="139"/>
                    <declaration name="newValue" type="Object" line="140"/>
                    <scope line="142">
                        <declaration name="e" type="Object" line="143"/>
                        <scope line="144">
                            <declaration name="a" type="Object[]" line="145"/>
                            <scope line="146">
                                <scope line="147">
                                    <declaration name="f" type="Field" line="148"/>
                                    <scope line="149"/>
                                </scope>
                                <scope line="154"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="invokeStatement" type="void" line="162">
                <params>
                    <param name="instance" type="Object"/>
                    <param name="methodName" type="String"/>
                    <param name="args" type="Object[]"/>
                    <param name="out" type="Encoder"/>
                </params>
            </method>
            <method name="initBean" type="void" line="165">
                <params>
                    <param name="type" type="Class"/>
                    <param name="oldInstance" type="Object"/>
                    <param name="newInstance" type="Object"/>
                    <param name="out" type="Encoder"/>
                </params>
                <scope line="166">
                    <declaration name="mod" type="int" line="167"/>
                    <scope line="168"/>
                    <scope line="171">
                        <declaration name="oldGetExp" type="Expression" line="172"/>
                        <declaration name="newGetExp" type="Expression" line="173"/>
                        <declaration name="oldValue" type="Object" line="174"/>
                        <declaration name="newValue" type="Object" line="175"/>
                        <scope line="177"/>
                    </scope>
                    <scope line="181"/>
                </scope>
                <declaration name="info" type="BeanInfo" line="185"/>
                <scope line="186"/>
                <scope line="189"/>
                <scope line="192">
                    <scope line="193"/>
                    <scope line="196"/>
                    <scope line="199"/>
                </scope>
                <scope line="203"/>
                <scope line="206">
                    <scope line="207"/>
                    <declaration name="listenerType" type="Class" line="210"/>
                    <scope line="211"/>
                    <scope line="214"/>
                    <declaration name="oldL" type="EventListener[]" line="217"/>
                    <declaration name="newL" type="EventListener[]" line="218"/>
                    <scope line="219">
                        <declaration name="m" type="Method" line="220"/>
                    </scope>
                    <scope line="224">
                        <scope line="225">
                            <declaration name="m" type="Method" line="226"/>
                        </scope>
                        <scope line="230"/>
                    </scope>
                    <declaration name="addListenerMethodName" type="String" line="234"/>
                    <scope line="235"/>
                    <declaration name="removeListenerMethodName" type="String" line="238"/>
                    <scope line="239"/>
                </scope>
            </method>
            <javadoc line="244">
                This default implementation of the &lt;code&gt;initialize&lt;/code&gt; method assumes
                  all state held in objects of this type is exposed via the
                  matching pairs of &quot;setter&quot; and &quot;getter&quot; methods in the order
                  they are returned by the Introspector. If a property descriptor
                  defines a &quot;transient&quot; attribute with a value equal to
                  &lt;code&gt;Boolean.TRUE&lt;/code&gt; the property is ignored by this
                  default implementation. Note that this use of the word
                  &quot;transient&quot; is quite independent of the field modifier
                  that is used by the &lt;code&gt;ObjectOutputStream&lt;/code&gt;.
                  &lt;p&gt;
                  For each non-transient property, an expression is created
                  in which the nullary &quot;getter&quot; method is applied
                  to the &lt;code&gt;oldInstance&lt;/code&gt;. The value of this
                  expression is the value of the property in the instance that is
                  being serialized. If the value of this expression
                  in the cloned environment &lt;code&gt;mutatesTo&lt;/code&gt; the
                  target value, the new value is initialized to make it
                  equivalent to the old value. In this case, because
                  the property value has not changed there is no need to
                  call the corresponding &quot;setter&quot; method and no statement
                  is emitted. If not however, the expression for this value
                  is replaced with another expression (normally a constructor)
                  and the corresponding &quot;setter&quot; method is called to install
                  the new property value in the object. This scheme removes
                  default information from the output produced by streams
                  using this delegate.
                  &lt;p&gt;
                  In passing these statements to the output stream, where they
                  will be executed, side effects are made to the &lt;code&gt;newInstance&lt;/code&gt;.
                  In most cases this allows the problem of properties
                  whose values depend on each other to actually help the
                  serialization process by making the number of statements
                  that need to be written to the output smaller. In general,
                  the problem of handling interdependent properties is reduced to
                  that of finding an order for the properties in
                  a class such that no property value depends on the value of
                  a subsequent property.                
                <param>
                    oldInstance The instance to be copied.                    
                </param>
                <param>
                    newInstance The instance that is to be modified.                    
                </param>
                <param>
                    out The stream to which any initialization statements should be written.                    
                </param>
                <throws>
                    NullPointerException if {@code out} is {@code null}                    
                </throws>
                <see>
                    java.beans.Introspector#getBeanInfo                    
                </see>
                <see>
                    java.beans.PropertyDescriptor                    
                </see>
            </javadoc>
            <method name="initialize" type="void" line="289">
                <params>
                    <param name="type" type="Class&lt;?&gt;"/>
                    <param name="oldInstance" type="Object"/>
                    <param name="newInstance" type="Object"/>
                    <param name="out" type="Encoder"/>
                </params>
                <scope line="291"/>
            </method>
            <method name="getPropertyDescriptor" type="PropertyDescriptor" line="295">
                <params>
                    <param name="type" type="Class"/>
                    <param name="property" type="String"/>
                </params>
                <scope line="296">
                    <scope line="297"/>
                </scope>
                <scope line="301"/>
            </method>
        </class>
    </source>