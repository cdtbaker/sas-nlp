<?xml version="1.0" encoding="UTF-8"?>
    <source package="">
        <import package="java.io"/>
        <import package="java.net"/>
        <import package="java.lang.Byte"/>
        <class name="PollingServer" line="36">
            <comment line="192">
                main ... just check if a concurrency was specified                
            </comment>
            <comment line="206">
                This class is for handling the Client data.
                 The PollingServer spawns off a number of these based upon
                 the number of CPUs (or concurrency argument).
                 Each just loops grabbing events off the queue and
                 processing them.                
            </comment>
            <javadoc line="36">
                Simple Java &quot;server&quot; using the Poller class
                  to multiplex on incoming connections.  Note
                  that handoff of events, via linked Q is not
                  actually be a performance booster here, since
                  the processing of events is cheaper than
                  the overhead in scheduling/executing them.
                  Although this demo does allow for concurrency
                  in handling connections, it uses a rather
                  primitive &quot;gang scheduling&quot; policy to keep
                  the code simpler.                
            </javadoc>
            <declaration name="MAXCONN" type="int" line="51"/>
            <declaration name="PORTNUM" type="int" line="52"/>
            <declaration name="BYTESPEROP" type="int" line="53"/>
            <declaration name="eventSync" type="Object" line="55"/>
            <javadoc line="55">
                This synchronization object protects access to certain
                  data (bytesRead,eventsToProcess) by concurrent Consumer threads.                
            </javadoc>
            <declaration name="instr" type="InputStream[]" line="61"/>
            <declaration name="mapping" type="int[]" line="62"/>
            <declaration name="linkedQ" type="LinkedQueue" line="63"/>
            <declaration name="bytesRead" type="int" line="64"/>
            <declaration name="bytesToRead" type="int" line="65"/>
            <declaration name="eventsToProcess" type="int" line="66"/>
            <method name="PollingServer" type="constructor" line="68">
                <params>
                    <param name="concurrency" type="int"/>
                </params>
                <comment line="83">
                    Create the Poller object Mux, allow for up to MAXCONN
                     socketsfiledescriptors to be polled.                    
                </comment>
                <comment line="104">
                    Start the consumer threads to read data.                    
                </comment>
                <comment line="112">
                    Take connections, read Data                    
                </comment>
                <comment line="132">
                    may be done!                    
                </comment>
                <comment line="134">
                    Wait for events                    
                </comment>
                <comment line="141">
                    Process all the events we got from Mux.waitMultiple                    
                </comment>
                <comment line="150">
                    New connection coming in on the ServerSocket
                     Add the socket to the Mux, keep track of mapping
                     the fdval returned by Mux.add to the connection.                    
                </comment>
                <comment line="160">
                    just processed this one!                    
                </comment>
                <comment line="164">
                    We&apos;ve got data from this client connection.
                     Put it on the queue for the consumer threads to process.                    
                </comment>
                <comment line="180">
                    Tell the client it can now go away                    
                </comment>
                <comment line="184">
                    Tell the cunsumer threads they can exit.                    
                </comment>
                <declaration name="sockArr" type="Socket[]" line="69"/>
                <declaration name="timestart" type="long" line="70"/>
                <declaration name="revents" type="short[]" line="71"/>
                <declaration name="fds" type="int[]" line="72"/>
                <declaration name="bytes" type="int" line="73"/>
                <declaration name="Mux" type="Poller" line="74"/>
                <declaration name="serverFd" type="int" line="75"/>
                <declaration name="totalConn" type="int" line="76"/>
                <declaration name="connects" type="int" line="77"/>
                <scope line="80">
                    <declaration name="skMain" type="ServerSocket" line="82"/>
                    <declaration name="ctrlSock" type="Socket" line="90"/>
                    <declaration name="ctrlReader" type="BufferedReader" line="92"/>
                    <declaration name="ctrlString" type="String" line="94"/>
                    <scope line="108"/>
                    <declaration name="numEvents" type="int" line="115"/>
                    <scope line="117">
                        <declaration name="loopWaits" type="int" line="119"/>
                        <scope line="120">
                            <scope line="121">
                                <scope line="124"/>
                                <scope line="124"/>
                            </scope>
                        </scope>
                        <scope line="138"/>
                        <declaration name="cnt" type="int" line="144"/>
                        <scope line="145">
                            <declaration name="fd" type="int" line="146"/>
                            <scope line="148">
                                <scope line="149">
                                    <declaration name="fdval" type="int" line="157"/>
                                    <scope line="159"/>
                                </scope>
                                <scope line="163"/>
                            </scope>
                            <scope line="170"/>
                        </scope>
                    </scope>
                    <declaration name="buff" type="byte[]" line="181"/>
                    <scope line="185"/>
                </scope>
                <scope line="188"/>
            </method>
            <method name="main" type="void" line="195">
                <params>
                    <param name="args" type="String"/>
                </params>
                <declaration name="concurrency" type="int" line="196"/>
                <declaration name="server" type="PollingServer" line="202"/>
            </method>
            <class name="Consumer" line="212">
                <extends class="Thread"/>
                <declaration name="threadNumber" type="int" line="213"/>
                <method name="Consumer" type="constructor" line="214">
                    <params>
                        <param name="i" type="int"/>
                    </params>
                </method>
                <method name="run" type="void" line="216">
                    <comment line="225">
                                                
                    </comment>
                    <comment line="227">
                        We have to map the fd value returned from waitMultiple
                         to the actual input stream associated with that fd.
                         Take a look at how the Mux.add() was done to see how
                         we stored that.                        
                    </comment>
                    <comment line="239">
                        Any real server would do some synchronized and some
                         unsynchronized work on behalf of the client, and
                         most likely send some data back...but this is a
                         gross oversimplification.                        
                    </comment>
                    <declaration name="buff" type="byte[]" line="217"/>
                    <declaration name="bytes" type="int" line="218"/>
                    <declaration name="instream" type="InputStream" line="220"/>
                    <scope line="221">
                        <scope line="222">
                            <declaration name="Fd" type="Integer" line="223"/>
                            <declaration name="fd" type="int" line="224"/>
                            <declaration name="map" type="int" line="233"/>
                        </scope>
                        <scope line="236"/>
                        <scope line="238">
                            <scope line="245">
                                <scope line="248"/>
                            </scope>
                        </scope>
                    </scope>
                </method>
            </class>
        </class>
    </source>