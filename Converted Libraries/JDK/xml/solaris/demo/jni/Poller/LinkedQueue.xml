<?xml version="1.0" encoding="UTF-8"?>
    <source package="">
        <class name="LinkedQueue" line="1">
            <javadoc line="1">
                A linked list based channel implementation,
                  adapted from the TwoLockQueue class from CPJ.
                  The algorithm avoids contention between puts
                  and takes when the queue is not empty.
                  Normally a put and a take can proceed simultaneously.
                  (Although it does not allow multiple concurrent puts or takes.)
                  This class tends to perform more efficently than
                  other Channel implementations in producer/consumer
                  applications.
                  &lt;p&gt;[&lt;a href=&quot;http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html&quot;&gt; Introduction to this package. &lt;/a&gt;]                
            </javadoc>
            <declaration name="head_" type="LinkedNode" line="14"/>
            <javadoc line="14">
                Dummy header node of list. The first actual node, if it exists, is always
                  at head_.next. After each take, the old first node becomes the head.                
            </javadoc>
            <declaration name="count_" type="int" line="19"/>
            <declaration name="lastMonitor_" type="Object" line="20"/>
            <javadoc line="20">
                Helper monitor for managing access to last node, in case it is also first.
                  last_ and waitingForTake_ ONLY used with synch on appendMonitor_                
            </javadoc>
            <declaration name="last_" type="LinkedNode" line="25"/>
            <javadoc line="25">
                The last node of list. Put() appends to list, so modifies last_                
            </javadoc>
            <declaration name="waitingForTake_" type="int" line="29"/>
            <javadoc line="29">
                The number of threads waiting for a take.
                  Notifications are provided in put only if greater than zero.
                  The bookkeeping is worth it here since in reasonably balanced
                  usages, the notifications will hardly ever be necessary, so
                  the call overhead to notify can be eliminated.                
            </javadoc>
            <method name="LinkedQueue" type="constructor" line="37"/>
            <javadoc line="42">
                Main mechanics for put/offer                
            </javadoc>
            <method name="insert" type="void" line="45">
                <params>
                    <param name="x" type="Object"/>
                </params>
                <scope line="46">
                    <declaration name="p" type="LinkedNode" line="47"/>
                </scope>
            </method>
            <javadoc line="55">
                Main mechanics for take/poll                
            </javadoc>
            <method name="extract" type="Object" line="58">
                <declaration name="x" type="Object" line="59"/>
                <declaration name="first" type="LinkedNode" line="60"/>
                <scope line="61"/>
            </method>
            <method name="put" type="void" line="69">
                <params>
                    <param name="x" type="Object"/>
                </params>
            </method>
            <method name="offer" type="boolean" line="74">
                <params>
                    <param name="x" type="Object"/>
                    <param name="msecs" type="long"/>
                </params>
            </method>
            <method name="take" type="Object" line="80">
                <declaration name="x" type="Object" line="82"/>
                <scope line="84">
                    <scope line="85">
                        <scope line="86">
                            <scope line="88">
                                <scope line="90"/>
                                <scope line="94"/>
                            </scope>
                        </scope>
                        <scope line="99"/>
                    </scope>
                </scope>
            </method>
            <method name="peek" type="Object" line="107">
                <declaration name="first" type="LinkedNode" line="108"/>
            </method>
            <method name="isEmpty" type="boolean" line="112"/>
            <method name="poll" type="Object" line="115">
                <params>
                    <param name="msecs" type="long"/>
                </params>
                <declaration name="x" type="Object" line="117"/>
                <scope line="119">
                    <scope line="120">
                        <scope line="121">
                            <declaration name="waitTime" type="long" line="122"/>
                            <declaration name="start" type="long" line="123"/>
                            <scope line="125">
                                <scope line="127"/>
                                <scope line="131"/>
                            </scope>
                        </scope>
                        <scope line="137"/>
                    </scope>
                </scope>
            </method>
            <class name="LinkedNode" line="145">
                <declaration name="value" type="Object" line="146"/>
                <declaration name="next" type="LinkedNode" line="147"/>
                <method name="LinkedNode" type="constructor" line="148">
                    <params>
                        <param name="x" type="Object"/>
                    </params>
                </method>
                <method name="LinkedNode" type="constructor" line="151">
                    <params>
                        <param name="x" type="Object"/>
                        <param name="n" type="LinkedNode"/>
                    </params>
                </method>
            </class>
        </class>
    </source>