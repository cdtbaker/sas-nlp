<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt.AWTPermission"/>
        <import package="java.awt.DisplayMode"/>
        <import package="java.awt.GraphicsEnvironment"/>
        <import package="java.awt.GraphicsDevice"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.Window"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.HashMap"/>
        <import package="sun.java2d.opengl.GLXGraphicsConfig"/>
        <import package="sun.java2d.xr.XRGraphicsConfig"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <class name="X11GraphicsDevice" line="45">
            <extends class="GraphicsDevice"/>
            <comment line="71">
                Initialize JNI field and method IDs for fields that may be
                 accessed from C.                
            </comment>
            <comment line="189">
                Returns the number of X11 visuals representable as an
                 X11GraphicsConfig object.                
            </comment>
            <comment line="195">
                Returns the visualid for the given index of graphics configurations.                
            </comment>
            <comment line="199">
                Returns the depth for the given index of graphics configurations.                
            </comment>
            <comment line="204">
                Returns the colormap for the given index of graphics configurations.                
            </comment>
            <comment line="210">
                Whether or not double-buffering extension is supported                
            </comment>
            <comment line="212">
                Callback for adding a new double buffer visual into our set                
            </comment>
            <comment line="216">
                Enumerates all visuals that support double buffering                
            </comment>
            <implements interface="DisplayChangedListener"/>
            <javadoc line="45">
                This is an implementation of a GraphicsDevice object for a single
                  X11 screen.                
                <see>
                    GraphicsEnvironment                    
                </see>
                <see>
                    GraphicsConfiguration                    
                </see>
            </javadoc>
            <declaration name="screen" type="int" line="56"/>
            <declaration name="x11ProxyKeyMap" type="HashMap" line="57"/>
            <declaration name="fullScreenExclusivePermission" type="AWTPermission" line="59"/>
            <declaration name="xrandrExtSupported" type="Boolean" line="60"/>
            <declaration name="configLock" type="Object" line="61"/>
            <declaration name="topLevels" type="SunDisplayChanger" line="62"/>
            <declaration name="origDisplayMode" type="DisplayMode" line="63"/>
            <declaration name="shutdownHookRegistered" type="boolean" line="64"/>
            <method name="X11GraphicsDevice" type="constructor" line="66">
                <params>
                    <param name="screennum" type="int"/>
                </params>
            </method>
            <method name="initIDs" type="void" line="74"/>
            <scope line="76">
                <scope line="77"/>
            </scope>
            <javadoc line="82">
                Returns the X11 screen of the device.                
            </javadoc>
            <method name="getScreen" type="int" line="85"/>
            <method name="getProxyKeyFor" type="Object" line="89">
                <params>
                    <param name="st" type="SurfaceType"/>
                </params>
                <scope line="90">
                    <declaration name="o" type="Object" line="91"/>
                    <scope line="92"/>
                </scope>
            </method>
            <method name="getDisplay" type="long" line="100"/>
            <javadoc line="100">
                Returns the X11 Display of this device.
                  This method is also in MDrawingSurfaceInfo but need it here
                  to be able to allow a GraphicsConfigTemplate to get the Display.                
            </javadoc>
            <javadoc line="107">
                Returns the type of the graphics device.                
                <see>
                    #TYPE_RASTER_SCREEN                    
                </see>
                <see>
                    #TYPE_PRINTER                    
                </see>
                <see>
                    #TYPE_IMAGE_BUFFER                    
                </see>
            </javadoc>
            <method name="getType" type="int" line="113"/>
            <javadoc line="117">
                Returns the identification string associated with this graphics
                  device.                
            </javadoc>
            <method name="getIDstring" type="String" line="121"/>
            <declaration name="configs" type="GraphicsConfiguration[]" line="126"/>
            <declaration name="defaultConfig" type="GraphicsConfiguration" line="127"/>
            <declaration name="doubleBufferVisuals" type="HashSet" line="128"/>
            <javadoc line="130">
                Returns all of the graphics
                  configurations associated with this graphics device.                
            </javadoc>
            <method name="getConfigurations" type="GraphicsConfiguration[]" line="134">
                <scope line="135">
                    <scope line="136"/>
                </scope>
            </method>
            <method name="makeConfigurations" type="void" line="143">
                <comment line="145">
                    Index 0 is always the default config                    
                </comment>
                <scope line="144">
                    <declaration name="i" type="int" line="145"/>
                    <declaration name="num" type="int" line="146"/>
                    <declaration name="ret" type="GraphicsConfiguration[]" line="147"/>
                    <scope line="148"/>
                    <scope line="151"/>
                    <declaration name="glxSupported" type="boolean" line="155"/>
                    <declaration name="xrenderSupported" type="boolean" line="156"/>
                    <declaration name="dbeSupported" type="boolean" line="158"/>
                    <scope line="159"/>
                    <scope line="163">
                        <declaration name="visNum" type="int" line="164"/>
                        <declaration name="depth" type="int" line="165"/>
                        <scope line="166"/>
                        <scope line="169">
                            <declaration name="doubleBuffer" type="boolean" line="170"/>
                            <scope line="174"/>
                            <scope line="177"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="getNumConfigs" type="int" line="192"/>
            <method name="getConfigVisualId" type="int" line="197"/>
            <method name="getConfigDepth" type="int" line="201"/>
            <method name="getConfigColormap" type="int" line="206"/>
            <method name="isDBESupported" type="boolean" line="210"/>
            <method name="addDoubleBufferVisual" type="void" line="212">
                <params>
                    <param name="visNum" type="int"/>
                </params>
            </method>
            <method name="getDoubleBufferVisuals" type="void" line="216"/>
            <javadoc line="218">
                Returns the default graphics configuration
                  associated with this graphics device.                
            </javadoc>
            <method name="getDefaultConfiguration" type="GraphicsConfiguration" line="222">
                <scope line="223">
                    <scope line="224"/>
                </scope>
            </method>
            <method name="makeDefaultConfiguration" type="void" line="231">
                <scope line="232">
                    <declaration name="visNum" type="int" line="233"/>
                    <scope line="234">
                        <scope line="236">
                            <scope line="237"/>
                            <scope line="239"/>
                        </scope>
                    </scope>
                    <scope line="246">
                        <declaration name="depth" type="int" line="247"/>
                        <declaration name="doubleBuffer" type="boolean" line="248"/>
                        <scope line="249"/>
                        <scope line="256">
                            <scope line="257"/>
                        </scope>
                        <scope line="263"/>
                    </scope>
                </scope>
            </method>
            <method name="enterFullScreenExclusive" type="void" line="272"/>
            <method name="exitFullScreenExclusive" type="void" line="273"/>
            <method name="initXrandrExtension" type="boolean" line="274"/>
            <method name="getCurrentDisplayMode" type="DisplayMode" line="275"/>
            <method name="enumDisplayModes" type="void" line="276"/>
            <method name="configDisplayMode" type="void" line="278"/>
            <method name="resetNativeData" type="void" line="281"/>
            <javadoc line="283">
                Returns true only if:
                  - the Xrandr extension is present
                  - the necessary Xrandr functions were loaded successfully
                  - XINERAMA is not enabled                
            </javadoc>
            <method name="isXrandrExtensionSupported" type="boolean" line="289">
                <scope line="290"/>
            </method>
            <method name="isFullScreenSupported" type="boolean" line="298">
                <comment line="299">
                    REMIND: for now we will only allow fullscreen exclusive mode                    
                </comment>
                <comment line="300">
                    on the primary screen; we could change this behavior slightly                    
                </comment>
                <comment line="301">
                    in the future by allowing only one screen to be in fullscreen                    
                </comment>
                <comment line="302">
                    exclusive mode at any given time...                    
                </comment>
                <declaration name="fsAvailable" type="boolean" line="303"/>
                <scope line="304">
                    <declaration name="security" type="SecurityManager" line="305"/>
                    <scope line="306">
                        <scope line="307"/>
                        <scope line="311"/>
                        <scope line="313"/>
                    </scope>
                </scope>
            </method>
            <method name="isDisplayChangeSupported" type="boolean" line="322"/>
            <method name="enterFullScreenExclusive" type="void" line="326">
                <params>
                    <param name="w" type="Window"/>
                </params>
                <declaration name="peer" type="X11ComponentPeer" line="327"/>
                <scope line="328"/>
            </method>
            <method name="exitFullScreenExclusive" type="void" line="334">
                <params>
                    <param name="w" type="Window"/>
                </params>
                <declaration name="peer" type="X11ComponentPeer" line="335"/>
                <scope line="336"/>
            </method>
            <method name="setFullScreenWindow" type="void" line="343">
                <params>
                    <param name="w" type="Window"/>
                </params>
                <comment line="351">
                    enter windowed mode (and restore original display mode)                    
                </comment>
                <comment line="359">
                    save original display mode                    
                </comment>
                <comment line="364">
                    enter fullscreen mode                    
                </comment>
                <declaration name="old" type="Window" line="344"/>
                <scope line="345"/>
                <declaration name="fsSupported" type="boolean" line="349"/>
                <scope line="350"/>
                <scope line="358">
                    <scope line="360"/>
                </scope>
            </method>
            <method name="getDefaultDisplayMode" type="DisplayMode" line="369">
                <declaration name="gc" type="GraphicsConfiguration" line="370"/>
                <declaration name="r" type="Rectangle" line="371"/>
            </method>
            <method name="getDisplayMode" type="DisplayMode" line="378">
                <scope line="379"/>
                <scope line="381">
                    <scope line="382"/>
                </scope>
            </method>
            <method name="getDisplayModes" type="DisplayMode[]" line="390">
                <scope line="391"/>
                <declaration name="modes" type="ArrayList&lt;DisplayMode&gt;" line="394"/>
                <declaration name="retArray" type="DisplayMode[]" line="396"/>
            </method>
            <method name="setDisplayMode" type="void" line="401">
                <params>
                    <param name="dm" type="DisplayMode"/>
                </params>
                <comment line="421">
                    register a shutdown hook so that we return to the                    
                </comment>
                <comment line="422">
                    original DisplayMode when the VM exits (if the application                    
                </comment>
                <comment line="423">
                    is already in the original DisplayMode at that time, this                    
                </comment>
                <comment line="424">
                    hook will have no effect)                    
                </comment>
                <comment line="452">
                    switch to the new DisplayMode                    
                </comment>
                <comment line="457">
                    update bounds of the fullscreen window                    
                </comment>
                <comment line="460">
                    configDisplayMode() is synchronous, so the display change will be                    
                </comment>
                <comment line="461">
                    complete by the time we get here (and it is therefore safe to call                    
                </comment>
                <comment line="462">
                    displayChanged() now)                    
                </comment>
                <scope line="402"/>
                <declaration name="w" type="Window" line="406"/>
                <scope line="407"/>
                <scope line="411"/>
                <scope line="416"/>
                <scope line="420">
                    <anonymous_class line="426">
                        <method name="run" type="Void" line="427">
                            <declaration name="mainTG" type="ThreadGroup" line="428"/>
                            <declaration name="parentTG" type="ThreadGroup" line="429"/>
                            <scope line="430"/>
                            <anonymous_class line="434">
                                <method name="run" type="void" line="435">
                                    <declaration name="old" type="Window" line="436"/>
                                    <scope line="437"/>
                                </method>
                            </anonymous_class>
                            <declaration name="r" type="Runnable" line="434"/>
                            <declaration name="t" type="Thread" line="443"/>
                        </method>
                    </anonymous_class>
                    <declaration name="a" type="PrivilegedAction&lt;Void&gt;" line="426"/>
                </scope>
            </method>
            <method name="getMatchingDisplayMode" type="DisplayMode" line="467">
                <params>
                    <param name="dm" type="DisplayMode"/>
                </params>
                <scope line="468"/>
                <declaration name="modes" type="DisplayMode[]" line="471"/>
                <scope line="472">
                    <scope line="478"/>
                </scope>
            </method>
            <javadoc line="485">
                From the DisplayChangedListener interface; called from
                  X11GraphicsEnvironment when the display mode has been changed.                
            </javadoc>
            <method name="displayChanged" type="void" line="489">
                <comment line="490">
                    reset the list of configs (and default config)                    
                </comment>
                <comment line="495">
                    reset the native data structures associated with this device (they                    
                </comment>
                <comment line="496">
                    will be reinitialized when the GraphicsConfigs are configured)                    
                </comment>
                <comment line="499">
                    pass on to all top-level windows on this screen                    
                </comment>
            </method>
            <javadoc line="503">
                From the DisplayChangedListener interface; devices do not need
                  to react to this event.                
            </javadoc>
            <method name="paletteChanged" type="void" line="507"/>
            <javadoc line="510">
                Add a DisplayChangeListener to be notified when the display settings
                  are changed.  Typically, only top-level containers need to be added
                  to X11GraphicsDevice.                
            </javadoc>
            <method name="addDisplayChangedListener" type="void" line="515">
                <params>
                    <param name="client" type="DisplayChangedListener"/>
                </params>
            </method>
            <javadoc line="519">
                Remove a DisplayChangeListener from this X11GraphicsDevice.                
            </javadoc>
            <method name="removeDisplayChangedListener" type="void" line="522">
                <params>
                    <param name="client" type="DisplayChangedListener"/>
                </params>
            </method>
            <method name="toString" type="String" line="526"/>
        </class>
    </source>