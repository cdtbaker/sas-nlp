<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt.AWTException"/>
        <import package="java.awt.BufferCapabilities"/>
        <import package="java.awt.BufferCapabilities.FlipContents"/>
        <import package="java.awt.Component"/>
        <import package="java.awt.Toolkit"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.GraphicsDevice"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.ImageCapabilities"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.color.ColorSpace"/>
        <import package="java.awt.image.ComponentColorModel"/>
        <import package="java.awt.image.DirectColorModel"/>
        <import package="java.awt.image.DataBuffer"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.Rectangle"/>
        <import package="sun.java2d.Disposer"/>
        <import package="sun.java2d.DisposerRecord"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.loops.RenderLoops"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.x11.X11SurfaceData"/>
        <import package="sun.awt.image.OffScreenImage"/>
        <import package="sun.awt.image.SunVolatileImage"/>
        <import package="sun.awt.image.SurfaceManager"/>
        <import package="sun.awt.X11ComponentPeer"/>
        <class name="X11GraphicsConfig" line="60">
            <extends class="GraphicsConfiguration"/>
            <comment line="83">
                will be set on native level from init()                
            </comment>
            <comment line="98">
                Note this method is currently here for backward compatability
                 as this was the method used in jdk 1.2 beta4 to create the
                 X11GraphicsConfig objects. Java3D code had called this method
                 explicitly so without this, if a user tries to use JDK1.2 fcs
                 with Java3D beta1, a NoSuchMethod execption is thrown and
                 the program exits. REMOVE this method after Java3D fcs is
                 released!                
            </comment>
            <comment line="304">
                Initialize JNI field and method IDs for fields that may be
                  accessed from C.                
            </comment>
            <comment line="360">
                The following methods are invoked from {M,X}Toolkit.java and
                 X11ComponentPeer.java rather than having the X11-dependent
                 implementations hardcoded in those classes.  This way the appropriate
                 actions are taken based on the peer&apos;s GraphicsConfig, whether it is
                 an X11GraphicsConfig or a GLXGraphicsConfig.                
            </comment>
            <implements interface="SurfaceManager.ProxiedGraphicsConfig"/>
            <javadoc line="60">
                This is an implementation of a GraphicsConfiguration object for a
                  single X11 visual.                
                <see>
                    GraphicsEnvironment                    
                </see>
                <see>
                    GraphicsDevice                    
                </see>
            </javadoc>
            <declaration name="screen" type="X11GraphicsDevice" line="70"/>
            <declaration name="visual" type="int" line="71"/>
            <declaration name="depth" type="int" line="72"/>
            <declaration name="colormap" type="int" line="73"/>
            <declaration name="colorModel" type="ColorModel" line="74"/>
            <declaration name="aData" type="long" line="75"/>
            <declaration name="doubleBuffer" type="boolean" line="76"/>
            <declaration name="disposerReferent" type="Object" line="77"/>
            <declaration name="bufferCaps" type="BufferCapabilities" line="78"/>
            <declaration name="imageCaps" type="ImageCapabilities" line="79"/>
            <declaration name="bitsPerPixel" type="int" line="83"/>
            <declaration name="surfaceType" type="SurfaceType" line="85"/>
            <declaration name="solidloops" type="RenderLoops" line="87"/>
            <method name="getConfig" type="X11GraphicsConfig" line="93">
                <params>
                    <param name="device" type="X11GraphicsDevice"/>
                    <param name="visualnum" type="int"/>
                    <param name="depth" type="int"/>
                    <param name="colormap" type="int"/>
                    <param name="doubleBuffer" type="boolean"/>
                </params>
            </method>
            <method name="getConfig" type="X11GraphicsConfig" line="109">
                <params>
                    <param name="device" type="X11GraphicsDevice"/>
                    <param name="visualnum" type="int"/>
                    <param name="depth" type="int"/>
                    <param name="colormap" type="int"/>
                    <param name="type" type="int"/>
                </params>
            </method>
            <method name="getNumColors" type="int" line="113"/>
            <method name="init" type="void" line="114"/>
            <method name="makeColorModel" type="ColorModel" line="115"/>
            <method name="X11GraphicsConfig" type="constructor" line="120">
                <params>
                    <param name="device" type="X11GraphicsDevice"/>
                    <param name="visualnum" type="int"/>
                    <param name="depth" type="int"/>
                    <param name="colormap" type="int"/>
                    <param name="doubleBuffer" type="boolean"/>
                </params>
                <comment line="129">
                    add a record to the Disposer so that we destroy the native
                     AwtGraphicsConfigData when this object goes away (i.e. after a
                     display change event)                    
                </comment>
                <declaration name="x11CfgData" type="long" line="131"/>
            </method>
            <javadoc line="136">
                Return the graphics device associated with this configuration.                
            </javadoc>
            <method name="getDevice" type="GraphicsDevice" line="139"/>
            <javadoc line="143">
                Returns the visual id associated with this configuration.                
            </javadoc>
            <method name="getVisual" type="int" line="146"/>
            <javadoc line="151">
                Returns the depth associated with this configuration.                
            </javadoc>
            <method name="getDepth" type="int" line="154"/>
            <javadoc line="158">
                Returns the colormap associated with this configuration.                
            </javadoc>
            <method name="getColormap" type="int" line="161"/>
            <javadoc line="165">
                Returns a number of bits allocated per pixel
                  (might be different from depth)                
            </javadoc>
            <method name="getBitsPerPixel" type="int" line="169"/>
            <method name="getSurfaceType" type="SurfaceType" line="173">
                <scope line="174"/>
            </method>
            <method name="getProxyKey" type="Object" line="182"/>
            <javadoc line="186">
                Return the RenderLoops this type of destination uses for
                  solid fills and strokes.                
            </javadoc>
            <method name="getSolidLoops" type="RenderLoops" line="190">
                <params>
                    <param name="stype" type="SurfaceType"/>
                </params>
                <scope line="191"/>
            </method>
            <javadoc line="199">
                Returns the color model associated with this configuration.                
            </javadoc>
            <method name="getColorModel" type="ColorModel" line="202">
                <comment line="205">
                    Force SystemColors to be resolved before we create the CM                    
                </comment>
                <comment line="207">
                    This method, makeColorModel(), can return null if the
                     toolkit is not initialized yet.
                     The toolkit will then call back to this routine after it
                     is initialized and makeColorModel() should return a non-null
                     colorModel.                    
                </comment>
                <scope line="203"/>
            </method>
            <javadoc line="219">
                Returns the color model associated with this configuration that
                  supports the specified transparency.                
            </javadoc>
            <method name="getColorModel" type="ColorModel" line="223">
                <params>
                    <param name="transparency" type="int"/>
                </params>
            </method>
            <method name="createDCM32" type="DirectColorModel" line="237">
                <params>
                    <param name="rMask" type="int"/>
                    <param name="gMask" type="int"/>
                    <param name="bMask" type="int"/>
                    <param name="aMask" type="int"/>
                    <param name="aPre" type="boolean"/>
                </params>
            </method>
            <method name="createABGRCCM" type="ComponentColorModel" line="243">
                <declaration name="cs" type="ColorSpace" line="244"/>
                <declaration name="nBits" type="int[]" line="245"/>
                <declaration name="bOffs" type="int[]" line="246"/>
            </method>
            <javadoc line="252">
                Returns the default Transform for this configuration.  This
                  Transform is typically the Identity transform for most normal
                  screens.  Device coordinates for screen and printer devices will
                  have the origin in the upper left-hand corner of the target region of
                  the device, with X coordinates
                  increasing to the right and Y coordinates increasing downwards.
                  For image buffers, this Transform will be the Identity transform.                
            </javadoc>
            <method name="getDefaultTransform" type="AffineTransform" line="261"/>
            <javadoc line="265">
                Returns a Transform that can be composed with the default Transform
                  of a Graphics2D so that 72 units in user space will equal 1 inch
                  in device space.
                  Given a Graphics2D, g, one can reset the transformation to create
                  such a mapping by using the following pseudocode:
                  &lt;pre&gt;
                  GraphicsConfiguration gc = g.getGraphicsConfiguration();
                  g.setTransform(gc.getDefaultTransform());
                  g.transform(gc.getNormalizingTransform());
                  &lt;/pre&gt;
                  Note that sometimes this Transform will be identity (e.g. for
                  printers or metafile output) and that this Transform is only
                  as accurate as the information supplied by the underlying system.
                  For image buffers, this Transform will be the Identity transform,
                  since there is no valid distance measurement.                
            </javadoc>
            <method name="getNormalizingTransform" type="AffineTransform" line="284">
                <declaration name="xscale" type="double" line="285"/>
                <declaration name="yscale" type="double" line="286"/>
            </method>
            <method name="getXResolution" type="double" line="290"/>
            <method name="getYResolution" type="double" line="291"/>
            <method name="getAData" type="long" line="293"/>
            <method name="toString" type="String" line="297"/>
            <method name="initIDs" type="void" line="307"/>
            <scope line="309"/>
            <method name="getBounds" type="Rectangle" line="313"/>
            <method name="pGetBounds" type="Rectangle" line="317"/>
            <class name="XDBECapabilities" line="319">
                <extends class="BufferCapabilities"/>
                <method name="XDBECapabilities" type="constructor" line="320"/>
            </class>
            <method name="getBufferCapabilities" type="BufferCapabilities" line="325">
                <scope line="326">
                    <scope line="327"/>
                    <scope line="329"/>
                </scope>
            </method>
            <method name="getImageCapabilities" type="ImageCapabilities" line="336"/>
            <method name="isDoubleBuffered" type="boolean" line="340"/>
            <method name="dispose" type="void" line="344"/>
            <class name="X11GCDisposerRecord" line="346">
                <implements interface="DisposerRecord"/>
                <declaration name="x11ConfigData" type="long" line="347"/>
                <method name="X11GCDisposerRecord" type="constructor" line="348">
                    <params>
                        <param name="x11CfgData" type="long"/>
                    </params>
                </method>
                <method name="dispose" type="void" line="351">
                    <scope line="352"/>
                </method>
            </class>
            <javadoc line="367">
                Creates a new SurfaceData that will be associated with the given
                  X11ComponentPeer.                
            </javadoc>
            <method name="createSurfaceData" type="SurfaceData" line="371">
                <params>
                    <param name="peer" type="X11ComponentPeer"/>
                </params>
            </method>
            <javadoc line="375">
                Creates a new hidden-acceleration image of the given width and height
                  that is associated with the target Component.                
            </javadoc>
            <method name="createAcceleratedImage" type="Image" line="381">
                <params>
                    <param name="target" type="Component"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="383">
                    As of 1.7 we no longer create pmoffscreens here...                    
                </comment>
                <declaration name="model" type="ColorModel" line="383"/>
                <declaration name="wr" type="WritableRaster" line="384"/>
            </method>
            <method name="createBackBuffer" type="long" line="390"/>
            <javadoc line="390">
                The following methods correspond to the multibuffering methods in
                  X11ComponentPeer.java...                
            </javadoc>
            <method name="swapBuffers" type="void" line="396"/>
            <javadoc line="398">
                Attempts to create an XDBE-based backbuffer for the given peer.  If
                  the requested configuration is not natively supported, an AWTException
                  is thrown.  Otherwise, if the backbuffer creation is successful, a
                  handle to the native backbuffer is returned.                
            </javadoc>
            <method name="createBackBuffer" type="long" line="407">
                <params>
                    <param name="peer" type="X11ComponentPeer"/>
                    <param name="numBuffers" type="int"/>
                    <param name="caps" type="BufferCapabilities"/>
                </params>
                <scope line="408"/>
                <scope line="411"/>
                <declaration name="configCaps" type="BufferCapabilities" line="415"/>
                <scope line="416"/>
                <declaration name="window" type="long" line="420"/>
                <declaration name="swapAction" type="int" line="421"/>
            </method>
            <method name="destroyBackBuffer" type="void" line="426"/>
            <javadoc line="426">
                Destroys the backbuffer object represented by the given handle value.                
            </javadoc>
            <javadoc line="431">
                Creates a VolatileImage that essentially wraps the target Component&apos;s
                  backbuffer, using the provided backbuffer handle.                
            </javadoc>
            <method name="createBackBufferImage" type="VolatileImage" line="437">
                <params>
                    <param name="target" type="Component"/>
                    <param name="backBuffer" type="long"/>
                </params>
            </method>
            <javadoc line="443">
                Performs the native XDBE flip operation for the given target Component.                
            </javadoc>
            <method name="flip" type="void" line="450">
                <params>
                    <param name="peer" type="X11ComponentPeer"/>
                    <param name="target" type="Component"/>
                    <param name="xBackBuffer" type="VolatileImage"/>
                    <param name="x1" type="int"/>
                    <param name="y1" type="int"/>
                    <param name="x2" type="int"/>
                    <param name="y2" type="int"/>
                    <param name="flipAction" type="BufferCapabilities.FlipContents"/>
                </params>
                <declaration name="window" type="long" line="451"/>
                <declaration name="swapAction" type="int" line="452"/>
            </method>
            <javadoc line="456">
                Maps the given FlipContents constant to the associated XDBE swap
                  action constant.                
            </javadoc>
            <method name="getSwapAction" type="int" line="461">
                <params>
                    <param name="flipAction" type="BufferCapabilities.FlipContents"/>
                </params>
                <comment line="470">
                    UNDEFINED                    
                </comment>
                <scope line="462"/>
                <scope line="464"/>
                <scope line="466"/>
                <scope line="468"/>
            </method>
            <method name="isTranslucencyCapable" type="boolean" line="474"/>
            <method name="isTranslucencyCapable" type="boolean" line="478"/>
        </class>
    </source>