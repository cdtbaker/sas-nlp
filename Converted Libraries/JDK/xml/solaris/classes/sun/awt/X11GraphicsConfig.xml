<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt.AWTException"/>
        <import package="java.awt.BufferCapabilities"/>
        <import package="java.awt.BufferCapabilities.FlipContents"/>
        <import package="java.awt.Component"/>
        <import package="java.awt.Toolkit"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.GraphicsDevice"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.ImageCapabilities"/>
        <import package="java.awt.Transparency"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.color.ColorSpace"/>
        <import package="java.awt.image.ComponentColorModel"/>
        <import package="java.awt.image.DirectColorModel"/>
        <import package="java.awt.image.DataBuffer"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="java.awt.image.WritableRaster"/>
        <import package="java.awt.geom.AffineTransform"/>
        <import package="java.awt.Rectangle"/>
        <import package="sun.java2d.Disposer"/>
        <import package="sun.java2d.DisposerRecord"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.loops.RenderLoops"/>
        <import package="sun.java2d.loops.SurfaceType"/>
        <import package="sun.java2d.loops.CompositeType"/>
        <import package="sun.java2d.x11.X11SurfaceData"/>
        <import package="sun.awt.image.OffScreenImage"/>
        <import package="sun.awt.image.SunVolatileImage"/>
        <import package="sun.awt.image.SurfaceManager"/>
        <import package="sun.awt.X11ComponentPeer"/>
        <class name="X11GraphicsConfig" line="33">
            <extends class="GraphicsConfiguration"/>
            <implements interface="SurfaceManager.ProxiedGraphicsConfig"/>
            <javadoc line="33">
                This is an implementation of a GraphicsConfiguration object for a
                  single X11 visual.                
                <see>
                    GraphicsEnvironment                    
                </see>
                <see>
                    GraphicsDevice                    
                </see>
            </javadoc>
            <declaration name="screen" type="X11GraphicsDevice" line="40"/>
            <declaration name="visual" type="int" line="41"/>
            <declaration name="depth" type="int" line="42"/>
            <declaration name="colormap" type="int" line="43"/>
            <declaration name="colorModel" type="ColorModel" line="44"/>
            <declaration name="aData" type="long" line="45"/>
            <declaration name="doubleBuffer" type="boolean" line="46"/>
            <declaration name="disposerReferent" type="Object" line="47"/>
            <declaration name="bufferCaps" type="BufferCapabilities" line="48"/>
            <declaration name="imageCaps" type="ImageCapabilities" line="49"/>
            <declaration name="bitsPerPixel" type="int" line="50"/>
            <declaration name="surfaceType" type="SurfaceType" line="51"/>
            <declaration name="solidloops" type="RenderLoops" line="52"/>
            <method name="getConfig" type="X11GraphicsConfig" line="53">
                <params>
                    <param name="device" type="X11GraphicsDevice"/>
                    <param name="visualnum" type="int"/>
                    <param name="depth" type="int"/>
                    <param name="colormap" type="int"/>
                    <param name="doubleBuffer" type="boolean"/>
                </params>
            </method>
            <method name="getConfig" type="X11GraphicsConfig" line="56">
                <params>
                    <param name="device" type="X11GraphicsDevice"/>
                    <param name="visualnum" type="int"/>
                    <param name="depth" type="int"/>
                    <param name="colormap" type="int"/>
                    <param name="type" type="int"/>
                </params>
            </method>
            <method name="getNumColors" type="int" line="59"/>
            <method name="init" type="void" line="60"/>
            <method name="makeColorModel" type="ColorModel" line="61"/>
            <method name="X11GraphicsConfig" type="constructor" line="62">
                <params>
                    <param name="device" type="X11GraphicsDevice"/>
                    <param name="visualnum" type="int"/>
                    <param name="depth" type="int"/>
                    <param name="colormap" type="int"/>
                    <param name="doubleBuffer" type="boolean"/>
                </params>
                <declaration name="x11CfgData" type="long" line="69"/>
            </method>
            <javadoc line="72">
                Return the graphics device associated with this configuration.                
            </javadoc>
            <method name="getDevice" type="GraphicsDevice" line="75"/>
            <javadoc line="78">
                Returns the visual id associated with this configuration.                
            </javadoc>
            <method name="getVisual" type="int" line="81"/>
            <javadoc line="84">
                Returns the depth associated with this configuration.                
            </javadoc>
            <method name="getDepth" type="int" line="87"/>
            <javadoc line="90">
                Returns the colormap associated with this configuration.                
            </javadoc>
            <method name="getColormap" type="int" line="93"/>
            <javadoc line="96">
                Returns a number of bits allocated per pixel
                  (might be different from depth)                
            </javadoc>
            <method name="getBitsPerPixel" type="int" line="100"/>
            <method name="getSurfaceType" type="SurfaceType" line="103">
                <scope line="104"/>
            </method>
            <method name="getProxyKey" type="Object" line="110"/>
            <javadoc line="113">
                Return the RenderLoops this type of destination uses for
                  solid fills and strokes.                
            </javadoc>
            <method name="getSolidLoops" type="RenderLoops" line="117">
                <params>
                    <param name="stype" type="SurfaceType"/>
                </params>
                <scope line="118"/>
            </method>
            <javadoc line="123">
                Returns the color model associated with this configuration.                
            </javadoc>
            <method name="getColorModel" type="ColorModel" line="126">
                <scope line="127"/>
            </method>
            <javadoc line="134">
                Returns the color model associated with this configuration that
                  supports the specified transparency.                
            </javadoc>
            <method name="getColorModel" type="ColorModel" line="138">
                <params>
                    <param name="transparency" type="int"/>
                </params>
            </method>
            <method name="createDCM32" type="DirectColorModel" line="150">
                <params>
                    <param name="rMask" type="int"/>
                    <param name="gMask" type="int"/>
                    <param name="bMask" type="int"/>
                    <param name="aMask" type="int"/>
                    <param name="aPre" type="boolean"/>
                </params>
            </method>
            <method name="createABGRCCM" type="ComponentColorModel" line="153">
                <declaration name="cs" type="ColorSpace" line="154"/>
                <declaration name="nBits" type="int[]" line="155"/>
                <declaration name="bOffs" type="int[]" line="156"/>
            </method>
            <javadoc line="159">
                Returns the default Transform for this configuration.  This
                  Transform is typically the Identity transform for most normal
                  screens.  Device coordinates for screen and printer devices will
                  have the origin in the upper left-hand corner of the target region of
                  the device, with X coordinates
                  increasing to the right and Y coordinates increasing downwards.
                  For image buffers, this Transform will be the Identity transform.                
            </javadoc>
            <method name="getDefaultTransform" type="AffineTransform" line="168"/>
            <javadoc line="171">
                Returns a Transform that can be composed with the default Transform
                  of a Graphics2D so that 72 units in user space will equal 1 inch
                  in device space.
                  Given a Graphics2D, g, one can reset the transformation to create
                  such a mapping by using the following pseudocode:
                  &lt;pre&gt;
                  GraphicsConfiguration gc = g.getGraphicsConfiguration();
                  g.setTransform(gc.getDefaultTransform());
                  g.transform(gc.getNormalizingTransform());
                  &lt;/pre&gt;
                  Note that sometimes this Transform will be identity (e.g. for
                  printers or metafile output) and that this Transform is only
                  as accurate as the information supplied by the underlying system.
                  For image buffers, this Transform will be the Identity transform,
                  since there is no valid distance measurement.                
            </javadoc>
            <method name="getNormalizingTransform" type="AffineTransform" line="188">
                <declaration name="xscale" type="double" line="189"/>
                <declaration name="yscale" type="double" line="190"/>
            </method>
            <method name="getXResolution" type="double" line="193"/>
            <method name="getYResolution" type="double" line="194"/>
            <method name="getAData" type="long" line="195"/>
            <method name="toString" type="String" line="198"/>
            <method name="initIDs" type="void" line="201"/>
            <scope line="202"/>
            <method name="getBounds" type="Rectangle" line="205"/>
            <method name="pGetBounds" type="Rectangle" line="208"/>
            <class name="XDBECapabilities" line="209">
                <extends class="BufferCapabilities"/>
                <method name="XDBECapabilities" type="constructor" line="210"/>
            </class>
            <method name="getBufferCapabilities" type="BufferCapabilities" line="214">
                <scope line="215">
                    <scope line="216"/>
                    <scope line="219"/>
                </scope>
            </method>
            <method name="getImageCapabilities" type="ImageCapabilities" line="225"/>
            <method name="isDoubleBuffered" type="boolean" line="228"/>
            <method name="dispose" type="void" line="231"/>
            <class name="X11GCDisposerRecord" line="232">
                <implements interface="DisposerRecord"/>
                <declaration name="x11ConfigData" type="long" line="233"/>
                <method name="X11GCDisposerRecord" type="constructor" line="234">
                    <params>
                        <param name="x11CfgData" type="long"/>
                    </params>
                </method>
                <method name="dispose" type="void" line="237">
                    <scope line="238"/>
                </method>
            </class>
            <javadoc line="244">
                Creates a new SurfaceData that will be associated with the given
                  X11ComponentPeer.                
            </javadoc>
            <method name="createSurfaceData" type="SurfaceData" line="248">
                <params>
                    <param name="peer" type="X11ComponentPeer"/>
                </params>
            </method>
            <javadoc line="251">
                Creates a new hidden-acceleration image of the given width and height
                  that is associated with the target Component.                
            </javadoc>
            <method name="createAcceleratedImage" type="Image" line="255">
                <params>
                    <param name="target" type="Component"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <declaration name="model" type="ColorModel" line="256"/>
                <declaration name="wr" type="WritableRaster" line="257"/>
            </method>
            <method name="createBackBuffer" type="long" line="260"/>
            <javadoc line="260">
                The following methods correspond to the multibuffering methods in
                  X11ComponentPeer.java...                
            </javadoc>
            <method name="swapBuffers" type="void" line="265"/>
            <javadoc line="266">
                Attempts to create an XDBE-based backbuffer for the given peer.  If
                  the requested configuration is not natively supported, an AWTException
                  is thrown.  Otherwise, if the backbuffer creation is successful, a
                  handle to the native backbuffer is returned.                
            </javadoc>
            <method name="createBackBuffer" type="long" line="272">
                <params>
                    <param name="peer" type="X11ComponentPeer"/>
                    <param name="numBuffers" type="int"/>
                    <param name="caps" type="BufferCapabilities"/>
                </params>
                <scope line="273"/>
                <scope line="276"/>
                <declaration name="configCaps" type="BufferCapabilities" line="279"/>
                <scope line="280"/>
                <declaration name="window" type="long" line="283"/>
                <declaration name="swapAction" type="int" line="284"/>
            </method>
            <method name="destroyBackBuffer" type="void" line="287"/>
            <javadoc line="287">
                Destroys the backbuffer object represented by the given handle value.                
            </javadoc>
            <javadoc line="291">
                Creates a VolatileImage that essentially wraps the target Component&apos;s
                  backbuffer, using the provided backbuffer handle.                
            </javadoc>
            <method name="createBackBufferImage" type="VolatileImage" line="295">
                <params>
                    <param name="target" type="Component"/>
                    <param name="backBuffer" type="long"/>
                </params>
            </method>
            <javadoc line="298">
                Performs the native XDBE flip operation for the given target Component.                
            </javadoc>
            <method name="flip" type="void" line="301">
                <params>
                    <param name="peer" type="X11ComponentPeer"/>
                    <param name="target" type="Component"/>
                    <param name="xBackBuffer" type="VolatileImage"/>
                    <param name="x1" type="int"/>
                    <param name="y1" type="int"/>
                    <param name="x2" type="int"/>
                    <param name="y2" type="int"/>
                    <param name="flipAction" type="BufferCapabilities.FlipContents"/>
                </params>
                <declaration name="window" type="long" line="302"/>
                <declaration name="swapAction" type="int" line="303"/>
            </method>
            <javadoc line="306">
                Maps the given FlipContents constant to the associated XDBE swap
                  action constant.                
            </javadoc>
            <method name="getSwapAction" type="int" line="310">
                <params>
                    <param name="flipAction" type="BufferCapabilities.FlipContents"/>
                </params>
                <scope line="311"/>
                <scope line="314"/>
                <scope line="317"/>
                <scope line="320"/>
            </method>
            <method name="isTranslucencyCapable" type="boolean" line="324"/>
            <method name="isTranslucencyCapable" type="boolean" line="327"/>
        </class>
    </source>