<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.motif">
        <import package="java.awt"/>
        <import package="java.awt.im.InputMethodHighlight"/>
        <import package="java.awt.im.spi.InputMethodDescriptor"/>
        <import package="java.awt.image"/>
        <import package="java.awt.peer"/>
        <import package="java.awt.datatransfer.Clipboard"/>
        <import package="java.awt.event"/>
        <import package="java.lang.reflect"/>
        <import package="java.lang.Math"/>
        <import package="java.io"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.security.PrivilegedActionException"/>
        <import package="java.security.PrivilegedExceptionAction"/>
        <import package="java.util.Properties"/>
        <import package="java.util.Map"/>
        <import package="java.util.Iterator"/>
        <import package="sun.awt.AppContext"/>
        <import package="sun.awt.AWTAutoShutdown"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.UNIXToolkit"/>
        <import package="sun.awt.GlobalCursorManager"/>
        <import package="sun.awt.datatransfer.DataTransferer"/>
        <import package="java.awt.dnd.DragSource"/>
        <import package="java.awt.dnd.DragGestureListener"/>
        <import package="java.awt.dnd.DragGestureEvent"/>
        <import package="java.awt.dnd.DragGestureRecognizer"/>
        <import package="java.awt.dnd.MouseDragGestureRecognizer"/>
        <import package="java.awt.dnd.InvalidDnDOperationException"/>
        <import package="java.awt.dnd.peer.DragSourceContextPeer"/>
        <import package="sun.awt.X11FontManager"/>
        <import package="sun.awt.X11GraphicsConfig"/>
        <import package="sun.awt.X11GraphicsEnvironment"/>
        <import package="sun.awt.XSettings"/>
        <import package="sun.print.PrintJob2D"/>
        <import package="sun.misc.PerformanceLogger"/>
        <import package="sun.misc.Unsafe"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <class name="MToolkit" line="78">
            <extends class="UNIXToolkit"/>
            <comment line="83">
                the system clipboard - CLIPBOARD selection                
            </comment>
            <comment line="84">
                X11Clipboard clipboard;                
            </comment>
            <comment line="85">
                the system selection - PRIMARY selection                
            </comment>
            <comment line="86">
                X11Clipboard selection;                
            </comment>
            <comment line="88">
                Dynamic Layout Resize client code setting                
            </comment>
            <comment line="105">
                Note: The MToolkit object depends on the static initializer
                 of X11GraphicsEnvironment to initialize the connection to
                 the X11 server.                
            </comment>
            <comment line="128">
                public static final String DATA_TRANSFERER_CLASS_NAME = &quot;sun.awt.motif.MDataTransferer&quot;;                
            </comment>
            <comment line="190">
                Create peer objects.                
            </comment>
            <comment line="338">
                public MEmbeddedFramePeer createEmbeddedFrame(MEmbeddedFrame target)                
            </comment>
            <comment line="339">
                {                
            </comment>
            <comment line="340">
                MEmbeddedFramePeer peer = new MEmbeddedFramePeer(target);                
            </comment>
            <comment line="341">
                targetCreatedPeer(target, peer);                
            </comment>
            <comment line="342">
                return peer;                
            </comment>
            <comment line="343">
                return null;                
            </comment>
            <comment line="344">
                }                
            </comment>
            <comment line="351">
                On X, support for dynamic layout on resizing is governed by the
                 window manager.  If the window manager supports it, it happens
                 automatically.  The setter method for this property is
                 irrelevant on X.                
            </comment>
            <comment line="365">
                Called from isDynamicLayoutActive() and from
                 lazilyLoadDynamicLayoutSupportedProperty()                
            </comment>
            <comment line="607">
                Called from lazilyLoadDesktopProperty because we may not know if
                 the user has quit the previous window manager and started another.                
            </comment>
            <comment line="654">
                                
            </comment>
            <comment line="655">
                The following support Gnome&apos;s equivalent of desktop properties.                
            </comment>
            <comment line="656">
                A writeup of this can be found at:                
            </comment>
            <comment line="657">
                http://www.freedesktop.org/standards/xsettings/xsettings.html                
            </comment>
            <comment line="658">
                                
            </comment>
            <implements interface="Runnable"/>
            <declaration name="log" type="PlatformLogger" line="80"/>
            <declaration name="dynamicLayoutSetting" type="boolean" line="88"/>
            <declaration name="loadedXSettings" type="boolean" line="90"/>
            <javadoc line="90">
                True when the x settings have been loaded.                
            </javadoc>
            <declaration name="xs" type="XSettings" line="95"/>
            <javadoc line="95">
                XSETTINGS for the default screen.
                  &lt;p&gt;
                  &lt;strong&gt;XXX:&lt;/strong&gt; see &lt;code&gt;MToolkit.parseXSettings&lt;/code&gt;
                  and &lt;code&gt;awt_xsettings_update&lt;/code&gt; in
                  &lt;samp&gt;awt_MToolkit.c&lt;/samp&gt;                
            </javadoc>
            <declaration name="config" type="X11GraphicsConfig" line="109"/>
            <declaration name="motifdnd" type="boolean" line="111"/>
            <scope line="113">
                <scope line="114"/>
                <scope line="116"/>
            </scope>
            <method name="MToolkit" type="constructor" line="129">
                <comment line="147">
                    SunToolkit.setDataTransfererClassName(DATA_TRANSFERER_CLASS_NAME);                    
                </comment>
                <comment line="174">
                    Fix for 4701990.
                     AWTAutoShutdown state must be changed before the toolkit thread
                     starts to avoid race condition.                    
                </comment>
                <scope line="131"/>
                <scope line="134">
                    <declaration name="mainClassName" type="String" line="135"/>
                    <declaration name="trace" type="StackTraceElement" line="137"/>
                    <declaration name="bottom" type="int" line="138"/>
                    <scope line="139"/>
                    <scope line="142"/>
                    <declaration name="toolkitThread" type="Thread" line="149"/>
                    <anonymous_class line="153">
                        <method name="run" type="Void" line="154">
                            <declaration name="mainTG" type="ThreadGroup" line="155"/>
                            <declaration name="parentTG" type="ThreadGroup" line="156"/>
                            <scope line="158"/>
                            <anonymous_class line="162">
                                <method name="run" type="void" line="163"/>
                            </anonymous_class>
                            <declaration name="shutdownThread" type="Thread" line="162"/>
                        </method>
                    </anonymous_class>
                    <declaration name="a" type="PrivilegedAction&lt;Void&gt;" line="153"/>
                </scope>
            </method>
            <method name="init" type="void" line="185"/>
            <method name="run" type="void" line="186"/>
            <method name="shutdown" type="void" line="187"/>
            <method name="createButton" type="ButtonPeer" line="193">
                <params>
                    <param name="target" type="Button"/>
                </params>
                <comment line="194">
                    ButtonPeer peer = new MButtonPeer(target);                    
                </comment>
                <comment line="195">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="196">
                    return peer;                    
                </comment>
            </method>
            <method name="createTextField" type="TextFieldPeer" line="200">
                <params>
                    <param name="target" type="TextField"/>
                </params>
                <comment line="201">
                    TextFieldPeer peer = new MTextFieldPeer(target);                    
                </comment>
                <comment line="202">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="203">
                    return peer;                    
                </comment>
            </method>
            <method name="createLabel" type="LabelPeer" line="207">
                <params>
                    <param name="target" type="Label"/>
                </params>
                <comment line="208">
                    LabelPeer peer = new MLabelPeer(target);                    
                </comment>
                <comment line="209">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="210">
                    return peer;                    
                </comment>
            </method>
            <method name="createList" type="ListPeer" line="214">
                <params>
                    <param name="target" type="List"/>
                </params>
                <comment line="215">
                    ListPeer peer = new MListPeer(target);                    
                </comment>
                <comment line="216">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="217">
                    return peer;                    
                </comment>
            </method>
            <method name="createCheckbox" type="CheckboxPeer" line="221">
                <params>
                    <param name="target" type="Checkbox"/>
                </params>
                <comment line="222">
                    CheckboxPeer peer = new MCheckboxPeer(target);                    
                </comment>
                <comment line="223">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="224">
                    return peer;                    
                </comment>
            </method>
            <method name="createScrollbar" type="ScrollbarPeer" line="228">
                <params>
                    <param name="target" type="Scrollbar"/>
                </params>
                <comment line="229">
                    ScrollbarPeer peer = new MScrollbarPeer(target);                    
                </comment>
                <comment line="230">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="231">
                    return peer;                    
                </comment>
            </method>
            <method name="createScrollPane" type="ScrollPanePeer" line="235">
                <params>
                    <param name="target" type="ScrollPane"/>
                </params>
                <comment line="236">
                    ScrollPanePeer peer = new MScrollPanePeer(target);                    
                </comment>
                <comment line="237">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="238">
                    return peer;                    
                </comment>
            </method>
            <method name="createTextArea" type="TextAreaPeer" line="242">
                <params>
                    <param name="target" type="TextArea"/>
                </params>
                <comment line="243">
                    TextAreaPeer peer = new MTextAreaPeer(target);                    
                </comment>
                <comment line="244">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="245">
                    return peer;                    
                </comment>
            </method>
            <method name="createChoice" type="ChoicePeer" line="249">
                <params>
                    <param name="target" type="Choice"/>
                </params>
                <comment line="250">
                    ChoicePeer peer = new MChoicePeer(target);                    
                </comment>
                <comment line="251">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="252">
                    return peer;                    
                </comment>
            </method>
            <method name="createFrame" type="FramePeer" line="256">
                <params>
                    <param name="target" type="Frame"/>
                </params>
                <comment line="257">
                    FramePeer peer = new MFramePeer(target);                    
                </comment>
                <comment line="258">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="259">
                    return peer;                    
                </comment>
            </method>
            <method name="createCanvas" type="CanvasPeer" line="263">
                <params>
                    <param name="target" type="Canvas"/>
                </params>
                <comment line="264">
                    CanvasPeer peer = (isXEmbedServerRequested() ? new MEmbedCanvasPeer(target) : new MCanvasPeer(target));                    
                </comment>
                <comment line="265">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="266">
                    return peer;                    
                </comment>
            </method>
            <method name="createPanel" type="PanelPeer" line="270">
                <params>
                    <param name="target" type="Panel"/>
                </params>
                <comment line="271">
                    PanelPeer peer = new MPanelPeer(target);                    
                </comment>
                <comment line="272">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="273">
                    return peer;                    
                </comment>
            </method>
            <method name="createWindow" type="WindowPeer" line="277">
                <params>
                    <param name="target" type="Window"/>
                </params>
                <comment line="278">
                    WindowPeer peer = new MWindowPeer(target);                    
                </comment>
                <comment line="279">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="280">
                    return peer;                    
                </comment>
            </method>
            <method name="createDialog" type="DialogPeer" line="284">
                <params>
                    <param name="target" type="Dialog"/>
                </params>
                <comment line="285">
                    DialogPeer peer = new MDialogPeer(target);                    
                </comment>
                <comment line="286">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="287">
                    return peer;                    
                </comment>
            </method>
            <method name="createFileDialog" type="FileDialogPeer" line="291">
                <params>
                    <param name="target" type="FileDialog"/>
                </params>
                <comment line="292">
                    FileDialogPeer peer = new MFileDialogPeer(target);                    
                </comment>
                <comment line="293">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="294">
                    return peer;                    
                </comment>
            </method>
            <method name="createMenuBar" type="MenuBarPeer" line="298">
                <params>
                    <param name="target" type="MenuBar"/>
                </params>
                <comment line="299">
                    MenuBarPeer peer = new MMenuBarPeer(target);                    
                </comment>
                <comment line="300">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="301">
                    return peer;                    
                </comment>
            </method>
            <method name="createMenu" type="MenuPeer" line="305">
                <params>
                    <param name="target" type="Menu"/>
                </params>
                <comment line="306">
                    MenuPeer peer = new MMenuPeer(target);                    
                </comment>
                <comment line="307">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="308">
                    return peer;                    
                </comment>
            </method>
            <method name="createPopupMenu" type="PopupMenuPeer" line="312">
                <params>
                    <param name="target" type="PopupMenu"/>
                </params>
                <comment line="313">
                    PopupMenuPeer peer = new MPopupMenuPeer(target);                    
                </comment>
                <comment line="314">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="315">
                    return peer;                    
                </comment>
            </method>
            <method name="createMenuItem" type="MenuItemPeer" line="319">
                <params>
                    <param name="target" type="MenuItem"/>
                </params>
                <comment line="320">
                    MenuItemPeer peer = new MMenuItemPeer(target);                    
                </comment>
                <comment line="321">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="322">
                    return peer;                    
                </comment>
            </method>
            <method name="createCheckboxMenuItem" type="CheckboxMenuItemPeer" line="326">
                <params>
                    <param name="target" type="CheckboxMenuItem"/>
                </params>
                <comment line="327">
                    CheckboxMenuItemPeer peer = new MCheckboxMenuItemPeer(target);                    
                </comment>
                <comment line="328">
                    targetCreatedPeer(target, peer);                    
                </comment>
                <comment line="329">
                    return peer;                    
                </comment>
            </method>
            <method name="createKeyboardFocusManagerPeer" type="KeyboardFocusManagerPeer" line="333">
                <params>
                    <param name="manager" type="KeyboardFocusManager"/>
                </params>
            </method>
            <method name="getFontPeer" type="FontPeer" line="346">
                <params>
                    <param name="name" type="String"/>
                    <param name="style" type="int"/>
                </params>
            </method>
            <method name="setDynamicLayout" type="void" line="356">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <method name="isDynamicLayoutSet" type="boolean" line="360"/>
            <method name="isDynamicLayoutSupportedNative" type="boolean" line="367"/>
            <method name="isDynamicLayoutActive" type="boolean" line="369"/>
            <method name="isFrameStateSupported" type="boolean" line="373"/>
            <method name="createTrayIcon" type="TrayIconPeer" line="375">
                <params>
                    <param name="target" type="TrayIcon"/>
                </params>
            </method>
            <method name="createSystemTray" type="SystemTrayPeer" line="379">
                <params>
                    <param name="target" type="SystemTray"/>
                </params>
            </method>
            <method name="isTraySupported" type="boolean" line="383"/>
            <method name="makeColorModel" type="ColorModel" line="387"/>
            <declaration name="screenmodel" type="ColorModel" line="388"/>
            <method name="getStaticColorModel" type="ColorModel" line="390">
                <scope line="391"/>
            </method>
            <method name="getColorModel" type="ColorModel" line="397"/>
            <method name="getScreenResolution" type="int" line="401"/>
            <method name="getScreenInsets" type="Insets" line="403">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
            </method>
            <method name="getScreenWidth" type="int" line="407"/>
            <method name="getScreenHeight" type="int" line="408"/>
            <method name="getFontMetrics" type="FontMetrics" line="410">
                <params>
                    <param name="font" type="Font"/>
                </params>
                <comment line="411">
                    REMIND: platform font flag should be obsolete soon
                    if (!RasterOutputManager.usesPlatformFont()) {
                    return super.getFontMetrics(font);
                    } else {
                    return X11FontMetrics.getFontMetrics(font);
                    }                    
                </comment>
            </method>
            <method name="getPrintJob" type="PrintJob" line="423">
                <params>
                    <param name="frame" type="Frame"/>
                    <param name="doctitle" type="String"/>
                    <param name="props" type="Properties"/>
                </params>
                <scope line="425"/>
                <declaration name="printJob" type="PrintJob2D" line="429"/>
                <scope line="431"/>
            </method>
            <method name="getPrintJob" type="PrintJob" line="440">
                <params>
                    <param name="frame" type="Frame"/>
                    <param name="doctitle" type="String"/>
                    <param name="jobAttributes" type="JobAttributes"/>
                    <param name="pageAttributes" type="PageAttributes"/>
                </params>
                <scope line="443"/>
                <declaration name="printJob" type="PrintJob2D" line="447"/>
                <scope line="450"/>
            </method>
            <method name="beep" type="void" line="457"/>
            <method name="getSystemClipboard" type="Clipboard" line="459">
                <comment line="460">
                    SecurityManager security = System.getSecurityManager();                    
                </comment>
                <comment line="461">
                    if (security != null) {                    
                </comment>
                <comment line="462">
                    security.checkSystemClipboardAccess();                    
                </comment>
                <comment line="463">
                    }                    
                </comment>
                <comment line="464">
                    synchronized (this) {                    
                </comment>
                <comment line="465">
                    if (clipboard == null) {                    
                </comment>
                <comment line="466">
                    clipboard = new X11Clipboard(&quot;System&quot;, &quot;CLIPBOARD&quot;);                    
                </comment>
                <comment line="467">
                    }                    
                </comment>
                <comment line="468">
                    }                    
                </comment>
                <comment line="469">
                    return clipboard;                    
                </comment>
            </method>
            <method name="getSystemSelection" type="Clipboard" line="473">
                <comment line="474">
                    SecurityManager security = System.getSecurityManager();                    
                </comment>
                <comment line="475">
                    if (security != null) {                    
                </comment>
                <comment line="476">
                    security.checkSystemClipboardAccess();                    
                </comment>
                <comment line="477">
                    }                    
                </comment>
                <comment line="478">
                    synchronized (this) {                    
                </comment>
                <comment line="479">
                    if (selection == null) {                    
                </comment>
                <comment line="480">
                    selection = new X11Clipboard(&quot;Selection&quot;, &quot;PRIMARY&quot;);                    
                </comment>
                <comment line="481">
                    }                    
                </comment>
                <comment line="482">
                    }                    
                </comment>
                <comment line="483">
                    return selection;                    
                </comment>
            </method>
            <method name="getLockingKeyState" type="boolean" line="487">
                <params>
                    <param name="key" type="int"/>
                </params>
                <scope line="489"/>
            </method>
            <method name="getLockingKeyStateNative" type="boolean" line="495"/>
            <method name="loadSystemColors" type="void" line="497"/>
            <javadoc line="499">
                Give native peers the ability to query the native container
                  given a native component (e.g. the direct parent may be lightweight).                
            </javadoc>
            <method name="getNativeContainer" type="Container" line="503">
                <params>
                    <param name="c" type="Component"/>
                </params>
            </method>
            <method name="targetToPeer" type="Object" line="507">
                <params>
                    <param name="target" type="Object"/>
                </params>
            </method>
            <method name="targetDisposedPeer" type="void" line="511">
                <params>
                    <param name="target" type="Object"/>
                    <param name="peer" type="Object"/>
                </params>
            </method>
            <method name="createDragSourceContextPeer" type="DragSourceContextPeer" line="515">
                <params>
                    <param name="dge" type="DragGestureEvent"/>
                </params>
                <comment line="516">
                    if (MToolkit.useMotifDnD()) {                    
                </comment>
                <comment line="517">
                    return MDragSourceContextPeer.createDragSourceContextPeer(dge);                    
                </comment>
                <comment line="518">
                    } else {                    
                </comment>
                <comment line="519">
                    return X11DragSourceContextPeer.createDragSourceContextPeer(dge);                    
                </comment>
                <comment line="520">
                    }                    
                </comment>
            </method>
            <method name="createDragGestureRecognizer" type="T" line="528">
                <params>
                    <param name="abstractRecognizerClass" type="Class<T>"/>
                    <param name="ds" type="DragSource"/>
                    <param name="c" type="Component"/>
                    <param name="srcActions" type="int"/>
                    <param name="dgl" type="DragGestureListener"/>
                </params>
                <comment line="529">
                    if (MouseDragGestureRecognizer.class.equals(abstractRecognizerClass))                    
                </comment>
                <comment line="530">
                    return (T)new MMouseDragGestureRecognizer(ds, c, srcActions, dgl);                    
                </comment>
                <comment line="531">
                    else                    
                </comment>
            </method>
            <javadoc line="535">
                Returns a new input method adapter descriptor for native input methods.                
            </javadoc>
            <method name="getInputMethodAdapterDescriptor" type="InputMethodDescriptor" line="538">
                <comment line="539">
                    return new MInputMethodDescriptor();                    
                </comment>
            </method>
            <javadoc line="542">
                Returns a style map for the input method highlight.                
            </javadoc>
            <method name="mapInputMethodHighlight" type="Map" line="545">
                <params>
                    <param name="highlight" type="InputMethodHighlight"/>
                </params>
                <comment line="546">
                    return MInputMethod.mapInputMethodHighlight(highlight);                    
                </comment>
            </method>
            <javadoc line="549">
                Returns a new custom cursor.                
            </javadoc>
            <method name="createCustomCursor" type="Cursor" line="553">
                <params>
                    <param name="cursor" type="Image"/>
                    <param name="hotSpot" type="Point"/>
                    <param name="name" type="String"/>
                </params>
                <comment line="554">
                    return new MCustomCursor(cursor, hotSpot, name);                    
                </comment>
            </method>
            <javadoc line="557">
                Returns the supported cursor size                
            </javadoc>
            <method name="getBestCursorSize" type="Dimension" line="560">
                <params>
                    <param name="preferredWidth" type="int"/>
                    <param name="preferredHeight" type="int"/>
                </params>
                <comment line="561">
                    MCustomCursor.getBestCursorSize(                    
                </comment>
                <comment line="562">
                    java.lang.Math.max(1,preferredWidth), java.lang.Math.max(1,preferredHeight));                    
                </comment>
            </method>
            <method name="getMaximumCursorColors" type="int" line="565">
                <comment line="566">
                    Black and white.                    
                </comment>
            </method>
            <declaration name="prefix" type="String" line="569"/>
            <declaration name="postfix" type="String" line="570"/>
            <declaration name="dndPrefix" type="String" line="571"/>
            <method name="lazilyLoadDesktopProperty" type="Object" line="573">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="574">
                    <declaration name="cursorName" type="String" line="575"/>
                    <scope line="577"/>
                    <scope line="579"/>
                </scope>
                <scope line="586"/>
                <scope line="593">
                    <scope line="595"/>
                </scope>
            </method>
            <method name="lazilyLoadDynamicLayoutSupportedProperty" type="Boolean" line="610">
                <params>
                    <param name="name" type="String"/>
                </params>
                <declaration name="nativeDynamic" type="boolean" line="611"/>
                <scope line="613"/>
            </method>
            <method name="getMulticlickTime" type="int" line="620"/>
            <method name="initializeDesktopProperties" type="void" line="622">
                <comment line="627">
                    As of 1.4, no wheel mice are supported on Solaris
                     however, they are on Linux, and there isn&apos;t a way to detect them,
                     so we leave this property unset to indicate we&apos;re not sure if there&apos;s
                     a wheel mouse or not.                    
                </comment>
                <comment line="632">
                    desktopProperties.put(&quot;awt.wheelMousePresent&quot;, Boolean.valueOf(false));                    
                </comment>
                <comment line="634">
                    We don&apos;t want to call getMultilclickTime() if we&apos;re headless                    
                </comment>
                <scope line="635"/>
            </method>
            <method name="createRobot" type="RobotPeer" line="643">
                <params>
                    <param name="target" type="Robot"/>
                    <param name="screen" type="GraphicsDevice"/>
                </params>
                <comment line="644">
                                        
                </comment>
                <comment line="645">
                    return new MRobotPeer(screen.getDefaultConfiguration());                    
                </comment>
            </method>
            <method name="useMotifDnD" type="boolean" line="649"/>
            <method name="loadXSettings" type="void" line="659"/>
            <javadoc line="659">
                Triggers a callback to parseXSettings with the x settings values
                  from the window server. Note that this will NOT call
                  parseXSettings if we are not running on a GNOME desktop.                
            </javadoc>
            <javadoc line="666">
                Callback from the native side indicating some, or all, of the
                  desktop properties have changed and need to be reloaded.
                  &lt;code&gt;data&lt;/code&gt; is the byte array directly from the x server and
                  may be in little endian format.
                  &lt;p&gt;
                  NB: This could be called from any thread if triggered by
                  &lt;code&gt;loadXSettings&lt;/code&gt;.  It is called from the toolkit
                  thread if triggered by an XSETTINGS change.                
            </javadoc>
            <method name="parseXSettings" type="void" line="676">
                <params>
                    <param name="screen_XXX_ignored" type="int"/>
                    <param name="data" type="byte[]"/>
                </params>
                <comment line="677">
                    XXX: notyet: map screen -&gt; per screen XSettings object                    
                </comment>
                <comment line="678">
                    for now native code only calls us for default screen                    
                </comment>
                <comment line="679">
                    see awt_MToolkit.c awt_xsettings_update().                    
                </comment>
                <comment line="697">
                    XXX: we probably want to do something smarter.  In                    
                </comment>
                <comment line="698">
                    particular, &quot;Net&quot; properties are of interest to the                    
                </comment>
                <comment line="699">
                    &quot;core&quot; AWT itself.  E.g.                    
                </comment>
                <comment line="700">
                                        
                </comment>
                <comment line="701">
                    Net/DndDragThreshold -&gt; ???                    
                </comment>
                <comment line="702">
                    Net/DoubleClickTime  -&gt; awt.multiClickInterval                    
                </comment>
                <scope line="680"/>
                <declaration name="updatedSettings" type="Map" line="684"/>
                <scope line="685"/>
                <declaration name="i" type="Iterator" line="689"/>
                <scope line="690">
                    <declaration name="e" type="Map.Entry" line="691"/>
                    <declaration name="name" type="String" line="692"/>
                </scope>
                <declaration name="dragThreshold" type="Integer" line="708"/>
                <scope line="709"/>
                <scope line="712"/>
            </method>
            <method name="needsXEmbedImpl" type="boolean" line="717"/>
            <method name="isModalityTypeSupported" type="boolean" line="721">
                <params>
                    <param name="modalityType" type="Dialog.ModalityType"/>
                </params>
            </method>
            <method name="isModalExclusionTypeSupported" type="boolean" line="726">
                <params>
                    <param name="exclusionType" type="Dialog.ModalExclusionType"/>
                </params>
            </method>
            <method name="isSyncUpdated" type="boolean" line="730"/>
            <method name="isSyncFailed" type="boolean" line="731"/>
            <method name="getEventNumber" type="int" line="732"/>
            <method name="updateSyncSelection" type="void" line="733"/>
            <declaration name="WORKAROUND_SLEEP" type="long" line="734"/>
            <javadoc line="736">
                @inheritDoc                
            </javadoc>
            <method name="syncNativeQueue" type="boolean" line="739">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <comment line="745">
                    Wait for selection notify for oops on win                    
                </comment>
                <comment line="753">
                    This &quot;while&quot; is a protection from spurious                    
                </comment>
                <comment line="754">
                    wake-ups.  However, we shouldn&apos;t wait for too long                    
                </comment>
                <scope line="741">
                    <declaration name="event_number" type="long" line="742"/>
                    <declaration name="start" type="long" line="746"/>
                    <scope line="747">
                        <scope line="748"/>
                        <scope line="750"/>
                        <scope line="755"/>
                    </scope>
                    <scope line="759">
                        <scope line="761"/>
                        <scope line="763"/>
                        <scope line="765"/>
                    </scope>
                </scope>
                <scope line="770"/>
            </method>
            <method name="grab" type="void" line="775">
                <params>
                    <param name="w" type="Window"/>
                </params>
                <declaration name="peer" type="WindowPeer" line="776"/>
                <scope line="777"/>
            </method>
            <method name="ungrab" type="void" line="782">
                <params>
                    <param name="w" type="Window"/>
                </params>
                <declaration name="peer" type="WindowPeer" line="783"/>
                <scope line="784"/>
            </method>
            <method name="nativeGrab" type="void" line="788"/>
            <method name="nativeUnGrab" type="void" line="789"/>
            <method name="isDesktopSupported" type="boolean" line="792"/>
            <method name="createDesktopPeer" type="DesktopPeer" line="797">
                <params>
                    <param name="target" type="Desktop"/>
                </params>
            </method>
            <declaration name="UNDETERMINED_WM" type="int" line="801"/>
            <method name="getWMID" type="int" line="816">
                <declaration name="wmName" type="String" line="817"/>
                <scope line="819"/>
                <scope line="821"/>
                <scope line="823"/>
                <scope line="825"/>
                <scope line="827"/>
                <scope line="829"/>
                <scope line="831"/>
                <scope line="833"/>
                <scope line="835"/>
                <scope line="837"/>
                <scope line="839"/>
                <scope line="841"/>
            </method>
            <method name="getWMName" type="String" line="847"/>
        </class>
    </source>