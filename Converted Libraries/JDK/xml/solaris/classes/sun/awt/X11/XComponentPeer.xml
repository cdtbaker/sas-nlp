<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.X11">
        <import package="java.awt.AWTEvent"/>
        <import package="java.awt.AWTException"/>
        <import package="java.awt.BufferCapabilities"/>
        <import package="java.awt.Color"/>
        <import package="java.awt.Component"/>
        <import package="java.awt.Container"/>
        <import package="java.awt.Cursor"/>
        <import package="java.awt.Dimension"/>
        <import package="java.awt.Font"/>
        <import package="java.awt.FontMetrics"/>
        <import package="java.awt.Graphics"/>
        <import package="java.awt.GraphicsConfiguration"/>
        <import package="java.awt.Image"/>
        <import package="java.awt.Insets"/>
        <import package="java.awt.KeyboardFocusManager"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.awt.SystemColor"/>
        <import package="java.awt.Toolkit"/>
        <import package="java.awt.Window"/>
        <import package="java.awt.dnd.DropTarget"/>
        <import package="java.awt.dnd.peer.DropTargetPeer"/>
        <import package="java.awt.event.FocusEvent"/>
        <import package="java.awt.event.InputEvent"/>
        <import package="java.awt.event.InputMethodEvent"/>
        <import package="java.awt.event.KeyEvent"/>
        <import package="java.awt.event.MouseEvent"/>
        <import package="java.awt.event.MouseWheelEvent"/>
        <import package="java.awt.event.PaintEvent"/>
        <import package="java.awt.event.WindowEvent"/>
        <import package="java.awt.event.InvocationEvent"/>
        <import package="java.awt.image.ImageObserver"/>
        <import package="java.awt.image.ImageProducer"/>
        <import package="java.awt.image.VolatileImage"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.peer.ContainerPeer"/>
        <import package="java.awt.peer.LightweightPeer"/>
        <import package="java.lang.reflect"/>
        <import package="java.security"/>
        <import package="java.util.Collection"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Set"/>
        <import package="java.util.Vector"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt"/>
        <import package="sun.awt.event.IgnorePaintEvent"/>
        <import package="sun.awt.image.SunVolatileImage"/>
        <import package="sun.awt.image.ToolkitImage"/>
        <import package="sun.java2d.BackBufferCapsProvider"/>
        <import package="sun.java2d.pipe.Region"/>
        <class name="XComponentPeer" line="78">
            <extends class="XWindow"/>
            <comment line="93">
                Actually used only by XDecoratedPeer                
            </comment>
            <comment line="99">
                Colors calculated as on Motif using MotifColorUtilties.
                 If you use these, call updateMotifColors() in the peer&apos;s Constructor and
                 setBackground().  Examples are XCheckboxPeer and XButtonPeer.                
            </comment>
            <comment line="216">
                FOCUS STUFF                
            </comment>
            <comment line="294">
                TODO: consider moving it to KeyboardFocusManagerPeerImpl                
            </comment>
            <comment line="416">
                public so aw/Window can call it                
            </comment>
            <comment line="504">
                                
            </comment>
            <comment line="530">
                                
            </comment>
            <comment line="534">
                                
            </comment>
            <comment line="539">
                                
            </comment>
            <comment line="656">
                Draw a 3D rectangle using the Motif colors.
                 &quot;Normal&quot; rectangles have shadows on the bottom.
                 &quot;Depressed&quot; rectangles (such as pressed buttons) have shadows on the top,
                 in which case true should be passed for topShadow.                
            </comment>
            <comment line="733">
                The method changes the cursor.
                 @param cursor - a new cursor to change to.
                 @param ignoreSubComponents - if {@code true} is passed then
                                              the new cursor will be installed on window.
                                              if {@code false} is passed then
                                              subsequent components will try to handle
                                              this request and install their cursor.                
            </comment>
            <comment line="742">
                ignoreSubComponents not used here                
            </comment>
            <comment line="808">
                Returns true if we are inside begin/endLayout and
                 are waiting for native painting                
            </comment>
            <comment line="999">
                drawXXX() methods are used to print the native components by
                 rendering the Motif look ourselves.
                 ToDo(aim): needs to query native motif for more accurate color
                 information.                
            </comment>
            <comment line="1234">
                End of multi-buffering                
            </comment>
            <implements interface="ComponentPeer"/>
            <implements interface="DropTargetPeer"/>
            <implements interface="BackBufferCapsProvider"/>
            <declaration name="log" type="PlatformLogger" line="81"/>
            <declaration name="buffersLog" type="PlatformLogger" line="82"/>
            <declaration name="focusLog" type="PlatformLogger" line="83"/>
            <declaration name="fontLog" type="PlatformLogger" line="84"/>
            <declaration name="enableLog" type="PlatformLogger" line="85"/>
            <declaration name="shapeLog" type="PlatformLogger" line="86"/>
            <declaration name="paintPending" type="boolean" line="88"/>
            <declaration name="isLayouting" type="boolean" line="89"/>
            <declaration name="enabled" type="boolean" line="90"/>
            <declaration name="boundsOperation" type="int" line="93"/>
            <declaration name="foreground" type="Color" line="95"/>
            <declaration name="background" type="Color" line="96"/>
            <declaration name="darkShadow" type="Color" line="101"/>
            <declaration name="lightShadow" type="Color" line="102"/>
            <declaration name="selectColor" type="Color" line="103"/>
            <declaration name="font" type="Font" line="105"/>
            <declaration name="backBuffer" type="long" line="106"/>
            <declaration name="xBackBuffer" type="VolatileImage" line="107"/>
            <declaration name="systemColors" type="Color[]" line="109"/>
            <method name="XComponentPeer" type="constructor" line="111"/>
            <method name="XComponentPeer" type="constructor" line="114">
                <params>
                    <param name="params" type="XCreateWindowParams"/>
                </params>
            </method>
            <method name="XComponentPeer" type="constructor" line="118">
                <params>
                    <param name="target" type="Component"/>
                    <param name="parentWindow" type="long"/>
                    <param name="bounds" type="Rectangle"/>
                </params>
            </method>
            <javadoc line="122">
                Standard peer constructor, with corresponding Component                
            </javadoc>
            <method name="XComponentPeer" type="constructor" line="125">
                <params>
                    <param name="target" type="Component"/>
                </params>
            </method>
            <method name="preInit" type="void" line="130">
                <params>
                    <param name="params" type="XCreateWindowParams"/>
                </params>
            </method>
            <method name="postInit" type="void" line="134">
                <params>
                    <param name="params" type="XCreateWindowParams"/>
                </params>
                <comment line="154">
                    If any of our heavyweight ancestors are disable, we should be too
                     See 6176875 for more information                    
                </comment>
                <declaration name="c" type="Color" line="136"/>
                <declaration name="f" type="Font" line="137"/>
                <declaration name="cursor" type="Cursor" line="138"/>
                <scope line="146">
                    <declaration name="r" type="Rectangle" line="147"/>
                </scope>
                <declaration name="comp" type="Component" line="155"/>
                <scope line="156">
                    <scope line="158"/>
                </scope>
                <scope line="165"/>
            </method>
            <method name="isInitialReshape" type="boolean" line="170"/>
            <method name="reparent" type="void" line="174">
                <params>
                    <param name="newNativeParent" type="ContainerPeer"/>
                </params>
                <declaration name="newPeer" type="XComponentPeer" line="175"/>
                <scope line="177"/>
                <scope line="180"/>
            </method>
            <method name="isReparentSupported" type="boolean" line="184"/>
            <method name="isObscured" type="boolean" line="188">
                <declaration name="container" type="Container" line="189"/>
                <scope line="192"/>
                <declaration name="parent" type="Container" line="196"/>
                <scope line="197"/>
                <scope line="201">
                    <declaration name="wpeer" type="XWindowPeer" line="202"/>
                    <scope line="203"/>
                </scope>
            </method>
            <method name="canDetermineObscurity" type="boolean" line="211"/>
            <declaration name="bHasFocus" type="boolean" line="219"/>
            <javadoc line="219">
                Keeps the track of focused state of the _NATIVE_ window                
            </javadoc>
            <javadoc line="224">
                Descendants should use this method to determine whether or not native window
                  has focus.                
            </javadoc>
            <method name="hasFocus" type="boolean" line="228"/>
            <javadoc line="232">
                Called when component receives focus                
            </javadoc>
            <method name="focusGained" type="void" line="235">
                <params>
                    <param name="e" type="FocusEvent"/>
                </params>
            </method>
            <javadoc line="240">
                Called when component loses focus                
            </javadoc>
            <method name="focusLost" type="void" line="243">
                <params>
                    <param name="e" type="FocusEvent"/>
                </params>
            </method>
            <method name="isFocusable" type="boolean" line="248">
                <comment line="250">
                                        
                </comment>
            </method>
            <declaration name="seClass" type="Class" line="253"/>
            <declaration name="seCtor" type="Constructor" line="254"/>
            <method name="wrapInSequenced" type="AWTEvent" line="256">
                <params>
                    <param name="event" type="AWTEvent"/>
                </params>
                <scope line="257">
                    <scope line="258"/>
                    <scope line="262">
                        <anonymous_class line="263">
                            <method name="run" type="Object" line="264">
                                <declaration name="ctor" type="Constructor" line="265"/>
                            </method>
                        </anonymous_class>
                    </scope>
                </scope>
                <scope line="274"/>
                <scope line="277"/>
                <scope line="280"/>
                <scope line="283"/>
                <scope line="286"/>
            </method>
            <method name="requestFocus" type="boolean" line="297">
                <params>
                    <param name="lightweightChild" type="Component"/>
                    <param name="temporary" type="boolean"/>
                    <param name="focusedWindowChangeAllowed" type="boolean"/>
                    <param name="time" type="long"/>
                    <param name="cause" type="CausedFocusEvent.Cause"/>
                </params>
                <comment line="315">
                    Currently we just generate focus events like we deal with lightweight instead of calling
                     XSetInputFocus on native window                    
                </comment>
                <comment line="319">
                    The problems with requests in non-focused window arise because shouldNativelyFocusHeavyweight
                     checks that native window is focused while appropriate WINDOW_GAINED_FOCUS has not yet
                     been processed - it is in EventQueue. Thus, SNFH allows native request and stores request record
                     in requests list - and it breaks our requests sequence as first record on WGF should be the last
                     focus owner which had focus before WLF. So, we should not add request record for such requests
                     but store this component in mostRecent - and return true as before for compatibility.                    
                </comment>
                <comment line="335">
                    Passing null &apos;actualFocusedWindow&apos; as we don&apos;t want to restore focus on it
                     when a component inside a Frame is requesting focus.
                     See 6314575 for details.                    
                </comment>
                <comment line="343">
                    If parent window can be made focused and has been made focused(synchronously)
                     then we can proceed with children, otherwise we retreat.                    
                </comment>
                <comment line="353">
                    Motif compatibility code                    
                </comment>
                <comment line="355">
                    Either lightweight or excessive request - all events are generated.                    
                </comment>
                <scope line="301"/>
                <declaration name="result" type="int" line="305"/>
                <declaration name="parentWindow" type="Window" line="326"/>
                <scope line="327"/>
                <declaration name="wpeer" type="XWindowPeer" line="330"/>
                <scope line="331"/>
                <declaration name="res" type="boolean" line="339"/>
                <scope line="344"/>
            </method>
            <method name="rejectFocusRequestHelper" type="boolean" line="360">
                <params>
                    <param name="logMsg" type="String"/>
                </params>
            </method>
            <method name="handleJavaFocusEvent" type="void" line="366">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <scope line="368"/>
                <scope line="370"/>
            </method>
            <method name="handleJavaWindowFocusEvent" type="void" line="375">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
            </method>
            <javadoc line="378">
                END OF FOCUS STUFF                
            </javadoc>
            <method name="setVisible" type="void" line="384">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <method name="hide" type="void" line="388"/>
            <javadoc line="393">
                @see java.awt.peer.ComponentPeer                
            </javadoc>
            <method name="setEnabled" type="void" line="396">
                <params>
                    <param name="value" type="boolean"/>
                </params>
                <declaration name="repaintNeeded" type="boolean" line="398"/>
                <scope line="400">
                    <declaration name="list" type="Component" line="401"/>
                    <scope line="402">
                        <declaration name="childEnabled" type="boolean" line="403"/>
                        <declaration name="p" type="ComponentPeer" line="404"/>
                        <scope line="405"/>
                    </scope>
                </scope>
                <scope line="410"/>
            </method>
            <method name="isEnabled" type="boolean" line="418"/>
            <method name="enable" type="void" line="424"/>
            <method name="disable" type="void" line="428"/>
            <method name="paint" type="void" line="432">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <method name="repaint" type="void" line="434">
                <params>
                    <param name="tm" type="long"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
            </method>
            <method name="getGraphics" type="Graphics" line="439"/>
            <method name="print" type="void" line="445">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="447">
                    clear rect here to emulate X clears rect before Expose                    
                </comment>
                <comment line="451">
                    paint peer                    
                </comment>
                <comment line="453">
                    allow target to change the picture                    
                </comment>
            </method>
            <method name="setBounds" type="void" line="456">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="op" type="int"/>
                </params>
            </method>
            <method name="reshape" type="void" line="466">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
            </method>
            <method name="coalescePaintEvent" type="void" line="470">
                <params>
                    <param name="e" type="PaintEvent"/>
                </params>
                <declaration name="r" type="Rectangle" line="471"/>
                <scope line="472"/>
                <scope line="475"/>
            </method>
            <method name="getParentTopLevel" type="XWindowPeer" line="489">
                <comment line="493">
                    Search for parent window                    
                </comment>
                <declaration name="compAccessor" type="AWTAccessor.ComponentAccessor" line="490"/>
                <declaration name="parent" type="Container" line="491"/>
                <scope line="493"/>
                <scope line="496"/>
                <scope line="498"/>
            </method>
            <method name="handleJavaMouseEvent" type="void" line="504">
                <params>
                    <param name="e" type="MouseEvent"/>
                </params>
                <comment line="514">
                    Simple windows are non-focusable in X terms but focusable in Java terms.
                     As X-non-focusable they don&apos;t receive any focus events - we should generate them
                     by ourselfves.                    
                </comment>
                <comment line="517">
                    if (parentXWindow.isFocusableWindow() /*&amp;&amp; parentXWindow.isSimpleWindow()*/ &amp;&amp;
                                           !(getCurrentNativeFocusedWindow() == parentWindow))
                                       {
                                           setCurrentNativeFocusedWindow(parentWindow);
                                           WindowEvent wfg = new WindowEvent(parentWindow, WindowEvent.WINDOW_GAINED_FOCUS);
                                           parentWindow.dispatchEvent(wfg);
                                       }                    
                </comment>
                <scope line="510">
                    <declaration name="parentXWindow" type="XWindowPeer" line="511"/>
                    <declaration name="parentWindow" type="Window" line="512"/>
                </scope>
            </method>
            <method name="handleJavaKeyEvent" type="void" line="530">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
            </method>
            <method name="handleJavaMouseWheelEvent" type="void" line="534">
                <params>
                    <param name="e" type="MouseWheelEvent"/>
                </params>
            </method>
            <method name="handleJavaInputMethodEvent" type="void" line="539">
                <params>
                    <param name="e" type="InputMethodEvent"/>
                </params>
            </method>
            <method name="handleF10JavaKeyEvent" type="void" line="542">
                <params>
                    <param name="e" type="KeyEvent"/>
                </params>
                <scope line="543">
                    <declaration name="winPeer" type="XWindowPeer" line="544"/>
                    <scope line="545">
                        <declaration name="mPeer" type="XMenuBarPeer" line="546"/>
                        <scope line="547"/>
                    </scope>
                </scope>
            </method>
            <method name="handleEvent" type="void" line="554">
                <params>
                    <param name="e" type="java.awt.AWTEvent"/>
                </params>
                <comment line="570">
                    even if target is disabled.                    
                </comment>
                <comment line="581">
                    Got native painting                    
                </comment>
                <comment line="583">
                    Fallthrough to next statement                    
                </comment>
                <comment line="585">
                    Skip all painting while layouting and all UPDATEs
                     while waiting for native paint                    
                </comment>
                <scope line="555">
                    <scope line="556">
                        <scope line="557"/>
                    </scope>
                    <scope line="563"/>
                </scope>
                <scope line="568"/>
                <scope line="572"/>
                <declaration name="id" type="int" line="576"/>
                <scope line="586"/>
            </method>
            <method name="handleButtonPressRelease" type="void" line="604">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="606">
                    Fix for 6385277.
                     We request focus on simple Window by click in order
                     to make it behave like FrameDialog in this case and also to unify
                     the behaviour with what we have on MS Windows.
                     handleJavaMouseEvent() would be more suitable place to do this
                     but we want Swing to have this functionality also.                    
                </comment>
                <comment line="622">
                    Request focus on the EDT of &apos;parentWindow&apos; because
                     XDecoratedPeer.requestWindowFocus() calls client code.                    
                </comment>
                <scope line="613">
                    <declaration name="parentXWindow" type="XWindowPeer" line="614"/>
                    <declaration name="parentWindow" type="Window" line="615"/>
                    <scope line="618">
                        <anonymous_class line="619">
                            <method name="run" type="void" line="620">
                                <comment line="622">
                                    Request focus on the EDT of &apos;parentWindow&apos; because
                                     XDecoratedPeer.requestWindowFocus() calls client code.                                    
                                </comment>
                            </method>
                        </anonymous_class>
                    </scope>
                </scope>
            </method>
            <method name="getMinimumSize" type="Dimension" line="631"/>
            <method name="getPreferredSize" type="Dimension" line="635"/>
            <method name="layout" type="void" line="639"/>
            <method name="getToolkit" type="java.awt.Toolkit" line="641"/>
            <method name="updateMotifColors" type="void" line="645">
                <params>
                    <param name="bg" type="Color"/>
                </params>
                <declaration name="red" type="int" line="646"/>
                <declaration name="green" type="int" line="647"/>
                <declaration name="blue" type="int" line="648"/>
            </method>
            <method name="drawMotif3DRect" type="void" line="663">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="topShadow" type="boolean"/>
                </params>
                <comment line="666">
                    top                    
                </comment>
                <comment line="667">
                    left                    
                </comment>
                <comment line="670">
                    bottom                    
                </comment>
                <comment line="671">
                    right                    
                </comment>
            </method>
            <method name="setBackground" type="void" line="673">
                <params>
                    <param name="c" type="Color"/>
                </params>
                <scope line="675"/>
            </method>
            <method name="setForeground" type="void" line="682">
                <params>
                    <param name="c" type="Color"/>
                </params>
                <scope line="684"/>
            </method>
            <javadoc line="690">
                Gets the font metrics for the specified font.                
                <param>
                    font the font for which font metrics is to be
                      obtained                    
                </param>
                <return>
                    the font metrics for &lt;code&gt;font&lt;/code&gt;                    
                </return>
                <see>
                    #getFont                    
                </see>
                <see>
                    #getPeer                    
                </see>
                <see>
                    java.awt.peer.ComponentPeer#getFontMetrics(Font)                    
                </see>
                <see>
                    Toolkit#getFontMetrics(Font)                    
                </see>
                <since>
                    JDK1.0                    
                </since>
            </javadoc>
            <method name="getFontMetrics" type="FontMetrics" line="701">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <method name="setFont" type="void" line="706">
                <params>
                    <param name="f" type="Font"/>
                </params>
                <comment line="714">
                    as it stands currently we dont need to do layout or repaint since
                     layout is done in the Component upon setFont.
                    layout();
                     target.repaint();
                    repaint()?                    
                </comment>
                <scope line="707">
                    <scope line="708"/>
                </scope>
            </method>
            <method name="getFont" type="Font" line="720"/>
            <method name="updateCursorImmediately" type="void" line="724"/>
            <method name="pSetCursor" type="void" line="728">
                <params>
                    <param name="cursor" type="Cursor"/>
                </params>
            </method>
            <method name="pSetCursor" type="void" line="742">
                <params>
                    <param name="cursor" type="Cursor"/>
                    <param name="ignoreSubComponents" type="boolean"/>
                </params>
                <scope line="744">
                    <declaration name="xcursor" type="long" line="745"/>
                    <declaration name="xwa" type="XSetWindowAttributes" line="747"/>
                    <declaration name="valuemask" type="long" line="750"/>
                </scope>
                <scope line="755"/>
            </method>
            <method name="createImage" type="Image" line="760">
                <params>
                    <param name="producer" type="ImageProducer"/>
                </params>
            </method>
            <method name="createImage" type="Image" line="764">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
            </method>
            <method name="createVolatileImage" type="VolatileImage" line="768">
                <params>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
            </method>
            <method name="prepareImage" type="boolean" line="772">
                <params>
                    <param name="img" type="Image"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="o" type="ImageObserver"/>
                </params>
            </method>
            <method name="checkImage" type="int" line="776">
                <params>
                    <param name="img" type="Image"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="o" type="ImageObserver"/>
                </params>
            </method>
            <method name="preferredSize" type="Dimension" line="780"/>
            <method name="minimumSize" type="Dimension" line="784"/>
            <method name="getInsets" type="Insets" line="788"/>
            <method name="beginValidate" type="void" line="792"/>
            <method name="endValidate" type="void" line="795"/>
            <javadoc line="799">
                DEPRECATED:  Replaced by getInsets().                
            </javadoc>
            <method name="insets" type="Insets" line="803"/>
            <method name="isPaintPending" type="boolean" line="809"/>
            <method name="handlesWheelScrolling" type="boolean" line="813"/>
            <method name="beginLayout" type="void" line="817">
                <comment line="819">
                    Skip all painting till endLayout                    
                </comment>
            </method>
            <method name="endLayout" type="void" line="823">
                <comment line="828">
                    if not waiting for native painting repaint damaged area                    
                </comment>
                <scope line="826"/>
            </method>
            <method name="getWinBackground" type="Color" line="834"/>
            <method name="getRGBvals" type="int[]" line="838">
                <params>
                    <param name="c" type="Color"/>
                </params>
                <declaration name="rgbvals" type="int" line="840"/>
            </method>
            <declaration name="BACKGROUND_COLOR" type="int" line="849"/>
            <declaration name="HIGHLIGHT_COLOR" type="int" line="850"/>
            <declaration name="SHADOW_COLOR" type="int" line="851"/>
            <declaration name="FOREGROUND_COLOR" type="int" line="852"/>
            <method name="getGUIcolors" type="Color[]" line="854">
                <comment line="875">
                                        
                </comment>
                <comment line="899">
                    c[SHADOW_COLOR] = c[BACKGROUND_COLOR].darker();
                    int r2 = c[SHADOW_COLOR].getRed();
                    int g2 = c[SHADOW_COLOR].getGreen();
                    int b2 = c[SHADOW_COLOR].getBlue();                    
                </comment>
                <comment line="910">
                    if ((c[BACKGROUND_COLOR].equals(c[HIGHLIGHT_COLOR]))
                    &amp;&amp; (c[BACKGROUND_COLOR].equals(c[SHADOW_COLOR]))) {
                    c[SHADOW_COLOR] = new Color(c[BACKGROUND_COLOR].getRed() + 75,
                    c[BACKGROUND_COLOR].getGreen() + 75,
                    c[BACKGROUND_COLOR].getBlue() + 75);
                    c[HIGHLIGHT_COLOR] = c[SHADOW_COLOR].brighter();
                    } else if (c[BACKGROUND_COLOR].equals(c[HIGHLIGHT_COLOR])) {
                    c[HIGHLIGHT_COLOR] = c[SHADOW_COLOR];
                    c[SHADOW_COLOR] = c[SHADOW_COLOR].darker();
                    }                    
                </comment>
                <comment line="924">
                    Reduce the contrast
                     Calculate the NTSC gray (NB: REC709 L* might be better!)
                     for foreground and background; then multiply the foreground
                     by the average lightness                    
                </comment>
                <comment line="937">
                    255 * 100 * 2                    
                </comment>
                <comment line="944">
                    This probably means the foreground color is black or white                    
                </comment>
                <declaration name="c" type="Color" line="855"/>
                <declaration name="backb" type="float" line="856"/>
                <scope line="858"/>
                <scope line="861"/>
                <declaration name="rgb" type="int[]" line="865"/>
                <declaration name="hsb" type="float[]" line="867"/>
                <scope line="878">
                    <scope line="879"/>
                    <scope line="881"/>
                </scope>
                <scope line="884">
                    <scope line="885">
                        <scope line="886"/>
                        <scope line="889"/>
                    </scope>
                </scope>
                <scope line="906"/>
                <scope line="921">
                    <declaration name="tc" type="Color" line="929"/>
                    <declaration name="bg" type="int" line="930"/>
                    <declaration name="fg" type="int" line="933"/>
                    <declaration name="ave" type="float" line="935"/>
                    <declaration name="newForeground" type="Color" line="938"/>
                    <scope line="942"/>
                </scope>
            </method>
            <javadoc line="954">
                Returns an array of Colors similar to getGUIcolors(), but using the
                  System colors.  This is useful if pieces of a Component (such as
                  the integrated scrollbars of a List) should retain the System color
                  instead of the background color set by Component.setBackground().                
            </javadoc>
            <method name="getSystemColors" type="Color[]" line="960">
                <scope line="961"/>
            </method>
            <javadoc line="971">
                Draw a 3D oval.                
            </javadoc>
            <method name="draw3DOval" type="void" line="976">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="colors" type="Color"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="raised" type="boolean"/>
                </params>
                <declaration name="c" type="Color" line="977"/>
            </method>
            <method name="draw3DRect" type="void" line="987">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="colors" type="Color"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="raised" type="boolean"/>
                </params>
                <declaration name="c" type="Color" line="988"/>
            </method>
            <method name="draw3DOval" type="void" line="1006">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="bg" type="Color"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="raised" type="boolean"/>
                </params>
                <declaration name="c" type="Color" line="1007"/>
                <declaration name="shadow" type="Color" line="1008"/>
                <declaration name="highlight" type="Color" line="1009"/>
            </method>
            <method name="draw3DRect" type="void" line="1020">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="bg" type="Color"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="raised" type="boolean"/>
                </params>
                <declaration name="c" type="Color" line="1021"/>
                <declaration name="shadow" type="Color" line="1022"/>
                <declaration name="highlight" type="Color" line="1023"/>
            </method>
            <method name="drawScrollbar" type="void" line="1035">
                <params>
                    <param name="g" type="Graphics"/>
                    <param name="bg" type="Color"/>
                    <param name="thickness" type="int"/>
                    <param name="length" type="int"/>
                    <param name="min" type="int"/>
                    <param name="max" type="int"/>
                    <param name="val" type="int"/>
                    <param name="vis" type="int"/>
                    <param name="horizontal" type="boolean"/>
                </params>
                <comment line="1051">
                    enforce a minimum handle size                    
                </comment>
                <comment line="1060">
                    paint the background slightly darker                    
                </comment>
                <comment line="1074">
                    paint the thumb and arrows in the normal background color                    
                </comment>
                <comment line="1104">
                    // // // draw the &quot;highlighted&quot; edges                    
                </comment>
                <comment line="1107">
                    outline &amp; arrows                    
                </comment>
                <comment line="1112">
                    arrows                    
                </comment>
                <comment line="1121">
                    arrows                    
                </comment>
                <comment line="1127">
                    thumb                    
                </comment>
                <comment line="1140">
                    // // // draw the &quot;shadowed&quot; edges                    
                </comment>
                <comment line="1143">
                    outline &amp;&amp; arrows                    
                </comment>
                <comment line="1148">
                    arrows                    
                </comment>
                <comment line="1157">
                    arrows                    
                </comment>
                <comment line="1163">
                    thumb                    
                </comment>
                <declaration name="c" type="Color" line="1036"/>
                <declaration name="f" type="double" line="1037"/>
                <declaration name="v1" type="int" line="1038"/>
                <declaration name="v2" type="int" line="1039"/>
                <declaration name="w2" type="int" line="1040"/>
                <declaration name="tpts_x" type="int" line="1041"/>
                <declaration name="tpts_y" type="int" line="1042"/>
                <scope line="1044">
                    <scope line="1046"/>
                </scope>
                <scope line="1049"/>
                <declaration name="ctr" type="int" line="1055"/>
                <declaration name="sbmin" type="int" line="1056"/>
                <declaration name="sbmax" type="int" line="1057"/>
                <scope line="1060">
                    <declaration name="d" type="Color" line="1061"/>
                    <scope line="1066"/>
                    <scope line="1068"/>
                </scope>
                <scope line="1075">
                    <scope line="1076"/>
                    <scope line="1078"/>
                </scope>
                <scope line="1086"/>
                <scope line="1088"/>
                <scope line="1095"/>
                <scope line="1097"/>
                <declaration name="highlight" type="Color" line="1101"/>
                <scope line="1107"/>
                <scope line="1116"/>
                <scope line="1127">
                    <scope line="1128"/>
                    <scope line="1131"/>
                </scope>
                <declaration name="shadow" type="Color" line="1137"/>
                <scope line="1143"/>
                <scope line="1152"/>
                <scope line="1163">
                    <scope line="1164"/>
                    <scope line="1167"/>
                </scope>
            </method>
            <declaration name="backBufferCaps" type="BufferCapabilities" line="1175"/>
            <javadoc line="1175">
                The following multibuffering-related methods delegate to our
                  associated GraphicsConfig (X11 or GLX) to handle the appropriate
                  native windowing system specific actions.                
            </javadoc>
            <method name="createBuffers" type="void" line="1185">
                <params>
                    <param name="numBuffers" type="int"/>
                    <param name="caps" type="BufferCapabilities"/>
                </params>
                <comment line="1190">
                    set the caps first, they&apos;re used when creating the bb                    
                </comment>
                <scope line="1186"/>
            </method>
            <method name="getBackBufferCaps" type="BufferCapabilities" line="1197"/>
            <method name="flip" type="void" line="1203">
                <params>
                    <param name="x1" type="int"/>
                    <param name="y1" type="int"/>
                    <param name="x2" type="int"/>
                    <param name="y2" type="int"/>
                    <param name="flipAction" type="BufferCapabilities.FlipContents"/>
                </params>
                <scope line="1204"/>
                <scope line="1207"/>
            </method>
            <method name="getBackBuffer" type="Image" line="1214">
                <scope line="1215"/>
                <scope line="1218"/>
            </method>
            <method name="destroyBuffers" type="void" line="1224">
                <scope line="1225"/>
            </method>
            <method name="notifyTextComponentChange" type="void" line="1235">
                <params>
                    <param name="add" type="boolean"/>
                </params>
                <comment line="1244">
                    FIX ME - FIX ME need to implement InputMethods
                    if (parent instanceof java.awt.Frame ||
                    parent instanceof java.awt.Dialog) {
                    if (add)
                    ((MInputMethodControl)parent.getPeer()).addTextComponent((MComponentPeer)this);
                    else
                    ((MInputMethodControl)parent.getPeer()).removeTextComponent((MComponentPeer)this);
                    }                    
                </comment>
                <declaration name="parent" type="Container" line="1236"/>
                <scope line="1239"/>
            </method>
            <javadoc line="1254">
                Returns true if this event is disabled and shouldn&apos;t be processed by window
                  Currently if target component is disabled the following event will be disabled on window:
                  ButtonPress, ButtonRelease, KeyPress, KeyRelease, EnterNotify, LeaveNotify, MotionNotify                
            </javadoc>
            <method name="isEventDisabled" type="boolean" line="1259">
                <params>
                    <param name="e" type="XEvent"/>
                </params>
                <scope line="1261"/>
            </method>
            <method name="getPeerBackground" type="Color" line="1282"/>
            <method name="getPeerForeground" type="Color" line="1286"/>
            <method name="getPeerFont" type="Font" line="1290"/>
            <method name="getPeerSize" type="Dimension" line="1294"/>
            <method name="setBoundsOperation" type="void" line="1298">
                <params>
                    <param name="operation" type="int"/>
                </params>
                <scope line="1299">
                    <scope line="1300"/>
                    <scope line="1302"/>
                </scope>
            </method>
            <method name="operationToString" type="String" line="1308">
                <params>
                    <param name="operation" type="int"/>
                </params>
            </method>
            <javadoc line="1322">
                Lowers this component at the bottom of the above HW peer. If the above parameter
                  is null then the method places this component at the top of the Z-order.                
            </javadoc>
            <method name="setZOrder" type="void" line="1326">
                <params>
                    <param name="above" type="ComponentPeer"/>
                </params>
                <declaration name="aboveWindow" type="long" line="1327"/>
                <scope line="1330"/>
                <scope line="1332"/>
            </method>
            <method name="addTree" type="void" line="1337">
                <params>
                    <param name="order" type="Collection"/>
                    <param name="set" type="Set"/>
                    <param name="cont" type="Container"/>
                </params>
                <comment line="1349">
                    It is lightweight container, it might contain heavyweight components attached to this
                     peer                    
                </comment>
                <scope line="1338">
                    <declaration name="comp" type="Component" line="1339"/>
                    <declaration name="peer" type="ComponentPeer" line="1340"/>
                    <scope line="1341">
                        <declaration name="window" type="Long" line="1342"/>
                        <scope line="1343"/>
                    </scope>
                    <scope line="1347"/>
                </scope>
            </method>
            <javadoc line="1355">
                DropTargetPeer implementation                
            </javadoc>
            <method name="addDropTarget" type="void" line="1357">
                <params>
                    <param name="dt" type="DropTarget"/>
                </params>
                <declaration name="comp" type="Component" line="1358"/>
                <scope line="1359"/>
                <scope line="1363">
                    <declaration name="wpeer" type="XWindowPeer" line="1364"/>
                    <scope line="1365"/>
                </scope>
            </method>
            <method name="removeDropTarget" type="void" line="1371">
                <params>
                    <param name="dt" type="DropTarget"/>
                </params>
                <declaration name="comp" type="Component" line="1372"/>
                <scope line="1373"/>
                <scope line="1377">
                    <declaration name="wpeer" type="XWindowPeer" line="1378"/>
                    <scope line="1379"/>
                </scope>
            </method>
            <javadoc line="1385">
                Applies the shape to the X-window.                
                <since>
                    1.7                    
                </since>
            </javadoc>
            <method name="applyShape" type="void" line="1389">
                <params>
                    <param name="shape" type="Region"/>
                </params>
                <scope line="1390">
                    <scope line="1391"/>
                    <scope line="1399">
                        <scope line="1400"/>
                        <scope line="1408"/>
                    </scope>
                    <scope line="1417"/>
                </scope>
                <scope line="1420">
                    <scope line="1421"/>
                </scope>
            </method>
            <method name="updateGraphicsData" type="boolean" line="1427">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <comment line="1438">
                    If the new visual differs from the old one, the peer must be
                     recreated because X11 does not allow changing the visual on the fly.
                     So we even skip the initGraphicsConfiguration() call.
                     The initial assignment should happen though, hence the != -1 thing.                    
                </comment>
                <declaration name="oldVisual" type="int" line="1428"/>
                <scope line="1430"/>
                <scope line="1433"/>
                <scope line="1441"/>
            </method>
        </class>
    </source>