<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.X11">
        <import package="java.awt"/>
        <import package="java.awt.event.InputEvent"/>
        <import package="java.awt.event.MouseEvent"/>
        <import package="java.awt.event.KeyEvent"/>
        <import package="java.awt.datatransfer.Clipboard"/>
        <import package="java.awt.dnd.DragSource"/>
        <import package="java.awt.dnd.DragGestureListener"/>
        <import package="java.awt.dnd.DragGestureEvent"/>
        <import package="java.awt.dnd.DragGestureRecognizer"/>
        <import package="java.awt.dnd.MouseDragGestureRecognizer"/>
        <import package="java.awt.dnd.InvalidDnDOperationException"/>
        <import package="java.awt.dnd.peer.DragSourceContextPeer"/>
        <import package="java.awt.im.InputMethodHighlight"/>
        <import package="java.awt.im.spi.InputMethodDescriptor"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.awt.peer"/>
        <import package="java.beans.PropertyChangeListener"/>
        <import package="java.lang.reflect.InvocationTargetException"/>
        <import package="java.lang.reflect.Method"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util"/>
        <import package="javax.swing.LookAndFeel"/>
        <import package="javax.swing.UIDefaults"/>
        <import package="sun.awt"/>
        <import package="sun.font.FontConfigManager"/>
        <import package="sun.font.FontManager"/>
        <import package="sun.misc.PerformanceLogger"/>
        <import package="sun.print.PrintJob2D"/>
        <import package="sun.security.action.GetBooleanAction"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <class name="XToolkit" line="59">
            <extends class="UNIXToolkit"/>
            <comment line="67">
                There is 400 ms is set by default on Windows and 500 by default on KDE and GNOME.
                We use the same hardcoded constant.                
            </comment>
            <comment line="76">
                the system clipboard - CLIPBOARD selection                
            </comment>
            <comment line="78">
                the system selection - PRIMARY selection                
            </comment>
            <comment line="81">
                Dynamic Layout Resize client code setting                
            </comment>
            <comment line="84">
                Is it allowed to generate events assigned to extra mouse buttons.
                Set to true by default.                
            </comment>
            <comment line="113">
                Dimensions of default screen                
            </comment>
            <comment line="114">
                Pixel                
            </comment>
            <comment line="139">
                Return (potentially) platform specific display timeout for the
                 tray icon                
            </comment>
            <comment line="145">
                ---- ERROR HANDLER CODE ----//                
            </comment>
            <comment line="147">
                Error handler at the moment of XToolkit initialization                
            </comment>
            <comment line="152">
                XErrorEvent being handled                
            </comment>
            <comment line="157">
                Current error handler or null if no error handler is set                
            </comment>
            <comment line="162">
                Value of sun.awt.noisyerrorhandler system property                
            </comment>
            <comment line="179">
                Should be called under LOCK                
            </comment>
            <comment line="196">
                Called from the native code when an error occurs                
            </comment>
            <comment line="215">
                ---- END OF ERROR HANDLER CODE ----//                
            </comment>
            <comment line="749">
                If we&apos;re running in non-Xinerama environment and the current
                 window manager supports _NET protocol then the screen insets
                 are calculated using _NET_WM_WORKAREA property of the root
                 window.
                 Otherwise, i. e. if Xinerama is on or _NET_WM_WORKAREA is
                 not set, we try to calculate the insets ourselves using
                 getScreenInsetsManually method.                
            </comment>
            <comment line="796">
                Manual calculation of screen insets: get all the windows with
                 _NET_WM_STRUT_NET_WM_STRUT_PARTIAL hints and add these
                 hints&apos; values to screen insets.
                
                 This method should be called under XToolkit.awtLock()                
            </comment>
            <comment line="887">
                The current implementation of disabling background erasing for
                 canvases is that we don&apos;t set any native background color
                 (with XSetWindowBackground) for the canvas window. However,
                 this color is set in the peer constructor - see
                 XWindow.postInit() for details. That&apos;s why this method from
                 SunToolkit is not overridden in XToolkit: it&apos;s too late to
                 disable background erasing :(                
            </comment>
            <comment line="896">
                @Override
                public void disableBackgroundErase(Canvas canvas) {
                XCanvasPeer peer = (XCanvasPeer)canvas.getPeer();
                if (peer == null) {
                throw new IllegalStateException(&quot;Canvas must have a valid peer&quot;);
                }
                peer.disableBackgroundErase();
                }                
            </comment>
            <comment line="907">
                Need this for XMenuItemPeer.                
            </comment>
            <comment line="918">
                Need this for XMenuItemPeer.                
            </comment>
            <comment line="928">
                On X, support for dynamic layout on resizing is governed by the
                 window manager.  If the window manager supports it, it happens
                 automatically.  The setter method for this property is
                 irrelevant on X.                
            </comment>
            <comment line="942">
                Called from isDynamicLayoutActive() and from
                 lazilyLoadDynamicLayoutSupportedProperty()                
            </comment>
            <comment line="1386">
                                
            </comment>
            <comment line="1640">
                Like XKeysymToKeycode, but ensures that keysym is the primary
                 symbol on the keycode returned.  Returns zero otherwise.                
            </comment>
            <comment line="1720">
                Assign meaning - alt, meta, etc. - to X modifiers mod1 ... mod5.
                 Only consider primary symbols on keycodes attached to modifiers.                
            </comment>
            <comment line="1993">
                This function converts between the X server time (number of milliseconds
                 since the last server reset) and the UTC time for the &apos;when&apos; field of an
                 InputEvent (or another event type with a timestamp).                
            </comment>
            <comment line="2177">
                so far, I don&apos;t use it leaving all calculations
                 to XkbTranslateKeyCode                
            </comment>
            <implements interface="Runnable"/>
            <declaration name="log" type="PlatformLogger" line="60"/>
            <declaration name="eventLog" type="PlatformLogger" line="61"/>
            <declaration name="timeoutTaskLog" type="PlatformLogger" line="62"/>
            <declaration name="keyEventLog" type="PlatformLogger" line="63"/>
            <declaration name="backingStoreLog" type="PlatformLogger" line="64"/>
            <declaration name="AWT_MULTICLICK_DEFAULT_TIME" type="int" line="68"/>
            <declaration name="PRIMARY_LOOP" type="boolean" line="70"/>
            <declaration name="SECONDARY_LOOP" type="boolean" line="71"/>
            <declaration name="awtAppClassName" type="String" line="73"/>
            <declaration name="clipboard" type="XClipboard" line="76"/>
            <declaration name="selection" type="XClipboard" line="78"/>
            <declaration name="dynamicLayoutSetting" type="boolean" line="81"/>
            <declaration name="areExtraMouseButtonsEnabled" type="boolean" line="85"/>
            <declaration name="loadedXSettings" type="boolean" line="87"/>
            <javadoc line="87">
                True when the x settings have been loaded.                
            </javadoc>
            <declaration name="xs" type="XSettings" line="92"/>
            <javadoc line="92">
                XSETTINGS for the default screen.
                  &lt;p&gt;                
            </javadoc>
            <declaration name="fcManager" type="FontConfigManager" line="98"/>
            <declaration name="arrowCursor" type="int" line="100"/>
            <declaration name="winMap" type="TreeMap" line="101"/>
            <declaration name="specialPeerMap" type="HashMap" line="102"/>
            <declaration name="winToDispatcher" type="HashMap" line="103"/>
            <declaration name="_display" type="long" line="104"/>
            <declaration name="uidefaults" type="UIDefaults" line="105"/>
            <declaration name="localEnv" type="X11GraphicsEnvironment" line="106"/>
            <declaration name="device" type="X11GraphicsDevice" line="107"/>
            <declaration name="config" type="X11GraphicsConfig" line="108"/>
            <declaration name="awt_multiclick_time" type="int" line="109"/>
            <declaration name="securityWarningEnabled" type="boolean" line="110"/>
            <declaration name="screenWidth" type="int" line="112"/>
            <declaration name="awt_defaultFg" type="long" line="113"/>
            <declaration name="xPeer" type="XMouseInfoPeer" line="114"/>
            <declaration name="m_removeSourceEvents" type="Method" line="115"/>
            <scope line="117">
                <scope line="119"/>
                <scope line="121">
                    <scope line="126"/>
                </scope>
            </scope>
            <method name="getTrayIconDisplayTimeout" type="long" line="142"/>
            <declaration name="saved_error_handler" type="long" line="149"/>
            <declaration name="saved_error" type="XErrorEvent" line="154"/>
            <declaration name="current_error_handler" type="XErrorHandler" line="159"/>
            <declaration name="noisyAwtHandler" type="boolean" line="164"/>
            <method name="WITH_XERROR_HANDLER" type="void" line="166">
                <params>
                    <param name="handler" type="XErrorHandler"/>
                </params>
            </method>
            <method name="RESTORE_XERROR_HANDLER" type="void" line="171">
                <comment line="173">
                    wait until all requests are processed by the X server
                     and only then uninstall the error handler                    
                </comment>
            </method>
            <method name="SAVED_ERROR_HANDLER" type="int" line="179">
                <params>
                    <param name="display" type="long"/>
                    <param name="error" type="XErrorEvent"/>
                </params>
                <comment line="182">
                    Default XErrorHandler may just terminate the process. Don&apos;t call it.
                     return XlibWrapper.CallErrorHandler(saved_error_handler, display, error.pData);                    
                </comment>
                <scope line="180"/>
                <scope line="184"/>
            </method>
            <method name="globalErrorHandler" type="int" line="196">
                <params>
                    <param name="display" type="long"/>
                    <param name="event_ptr" type="long"/>
                </params>
                <scope line="197"/>
                <declaration name="event" type="XErrorEvent" line="200"/>
                <scope line="202">
                    <scope line="203"/>
                    <scope line="205"/>
                </scope>
                <scope line="208"/>
            </method>
            <method name="initIDs" type="void" line="216"/>
            <method name="waitForEvents" type="void" line="217"/>
            <declaration name="toolkitThread" type="Thread" line="218"/>
            <method name="isToolkitThread" type="boolean" line="219"/>
            <method name="initSecurityWarning" type="void" line="223">
                <comment line="225">
                    Enable warning only for internal builds                    
                </comment>
                <declaration name="runtime" type="String" line="225"/>
            </method>
            <method name="isSecurityWarningEnabled" type="boolean" line="229"/>
            <method name="awt_output_flush" type="void" line="233"/>
            <method name="awtFUnlock" type="void" line="235"/>
            <method name="nativeLoadSystemColors" type="void" line="241"/>
            <method name="getUIDefaults" type="UIDefaults" line="243">
                <scope line="244"/>
            </method>
            <method name="loadSystemColors" type="void" line="250">
                <params>
                    <param name="systemColors" type="int[]"/>
                </params>
            </method>
            <method name="initUIDefaults" type="void" line="257">
                <comment line="260">
                    Load Defaults from MotifLookAndFeel                    
                </comment>
                <comment line="262">
                    This dummy load is necessary to get SystemColor initialized. !!!!!!                    
                </comment>
                <scope line="258">
                    <declaration name="c" type="Color" line="262"/>
                    <declaration name="lnf" type="LookAndFeel" line="264"/>
                </scope>
                <scope line="268"/>
            </method>
            <declaration name="displayLock" type="Object" line="273"/>
            <method name="getDisplay" type="long" line="275"/>
            <method name="getDefaultRootWindow" type="long" line="279">
                <scope line="281">
                    <declaration name="res" type="long" line="282"/>
                    <scope line="285"/>
                </scope>
                <scope line="289"/>
            </method>
            <method name="init" type="void" line="294">
                <comment line="310">
                    set system property if not yet assigned                    
                </comment>
                <scope line="296">
                    <scope line="298"/>
                    <declaration name="defaultScreen" type="AwtScreenData" line="303"/>
                </scope>
                <scope line="313"/>
                <anonymous_class line="316">
                    <method name="run" type="Void" line="317">
                        <declaration name="mainTG" type="ThreadGroup" line="318"/>
                        <declaration name="parentTG" type="ThreadGroup" line="319"/>
                        <scope line="320"/>
                        <anonymous_class line="324">
                            <method name="run" type="void" line="325">
                                <declaration name="peer" type="XSystemTrayPeer" line="326"/>
                                <scope line="327"/>
                                <scope line="330"/>
                                <scope line="334"/>
                            </method>
                        </anonymous_class>
                        <declaration name="shutdownThread" type="Thread" line="324"/>
                    </method>
                </anonymous_class>
                <declaration name="a" type="PrivilegedAction&lt;Void&gt;" line="316"/>
            </method>
            <method name="getCorrectXIDString" type="String" line="347">
                <params>
                    <param name="val" type="String"/>
                </params>
                <scope line="348"/>
                <scope line="350"/>
            </method>
            <method name="getEnv" type="String" line="355"/>
            <method name="getAWTAppClassName" type="String" line="358"/>
            <declaration name="DATA_TRANSFERER_CLASS_NAME" type="String" line="362"/>
            <method name="XToolkit" type="constructor" line="364">
                <scope line="366"/>
                <scope line="370">
                    <declaration name="mainClassName" type="String" line="371"/>
                    <declaration name="trace" type="StackTraceElement" line="373"/>
                    <declaration name="bottom" type="int" line="374"/>
                    <scope line="375"/>
                    <scope line="378"/>
                    <anonymous_class line="387">
                        <method name="run" type="Thread" line="388">
                            <declaration name="currentTG" type="ThreadGroup" line="389"/>
                            <declaration name="parentTG" type="ThreadGroup" line="390"/>
                            <scope line="391"/>
                            <declaration name="thread" type="Thread" line="395"/>
                        </method>
                    </anonymous_class>
                    <declaration name="action" type="PrivilegedAction&lt;Thread&gt;" line="387"/>
                </scope>
            </method>
            <method name="createButton" type="ButtonPeer" line="406">
                <params>
                    <param name="target" type="Button"/>
                </params>
                <declaration name="peer" type="ButtonPeer" line="407"/>
            </method>
            <method name="createFrame" type="FramePeer" line="412">
                <params>
                    <param name="target" type="Frame"/>
                </params>
                <declaration name="peer" type="FramePeer" line="413"/>
            </method>
            <method name="addToWinMap" type="void" line="419">
                <params>
                    <param name="window" type="long"/>
                    <param name="xwin" type="XBaseWindow"/>
                </params>
                <scope line="420"/>
            </method>
            <method name="removeFromWinMap" type="void" line="425">
                <params>
                    <param name="window" type="long"/>
                    <param name="xwin" type="XBaseWindow"/>
                </params>
                <scope line="426"/>
            </method>
            <method name="windowToXWindow" type="XBaseWindow" line="430">
                <params>
                    <param name="window" type="long"/>
                </params>
                <scope line="431"/>
            </method>
            <method name="addEventDispatcher" type="void" line="436">
                <params>
                    <param name="window" type="long"/>
                    <param name="dispatcher" type="XEventDispatcher"/>
                </params>
                <scope line="437">
                    <declaration name="key" type="Long" line="438"/>
                    <declaration name="dispatchers" type="Collection" line="439"/>
                    <scope line="440"/>
                </scope>
            </method>
            <method name="removeEventDispatcher" type="void" line="447">
                <params>
                    <param name="window" type="long"/>
                    <param name="dispatcher" type="XEventDispatcher"/>
                </params>
                <scope line="448">
                    <declaration name="key" type="Long" line="449"/>
                    <declaration name="dispatchers" type="Collection" line="450"/>
                    <scope line="451"/>
                </scope>
            </method>
            <declaration name="lastCursorPos" type="Point" line="457"/>
            <javadoc line="459">
                Returns whether there is last remembered cursor position.  The
                  position is remembered from X mouse events on our peers.  The
                  position is stored in &lt;code&gt;p&lt;/code&gt;.                
                <return>
                    true, if there is remembered last cursor position,
                      false otherwise                    
                </return>
            </javadoc>
            <method name="getLastCursorPos" type="boolean" line="466">
                <params>
                    <param name="p" type="Point"/>
                </params>
                <scope line="468">
                    <scope line="469"/>
                </scope>
                <scope line="474"/>
            </method>
            <method name="processGlobalMotionEvent" type="void" line="479">
                <params>
                    <param name="e" type="XEvent"/>
                </params>
                <comment line="481">
                    Only our windows guaranteely generate MotionNotify, so we
                     should track enter/leave, to catch the moment when to
                     switch to XQueryPointer                    
                </comment>
                <comment line="497">
                    Leave from our window                    
                </comment>
                <comment line="505">
                    Entrance into our window                    
                </comment>
                <scope line="483">
                    <declaration name="ev" type="XMotionEvent" line="484"/>
                    <scope line="486">
                        <scope line="487"/>
                        <scope line="489"/>
                    </scope>
                    <scope line="492"/>
                </scope>
                <scope line="495">
                    <scope line="498"/>
                    <scope line="500"/>
                </scope>
                <scope line="503">
                    <declaration name="ev" type="XCrossingEvent" line="505"/>
                    <scope line="507">
                        <scope line="508"/>
                        <scope line="510"/>
                    </scope>
                    <scope line="513"/>
                </scope>
            </method>
            <interface name="XEventListener">
                <method name="eventProcessed" type="void" line="520"/>
            </interface>
            <declaration name="listeners" type="Collection&lt;XEventListener&gt;" line="523"/>
            <method name="addXEventListener" type="void" line="525">
                <params>
                    <param name="listener" type="XEventListener"/>
                </params>
                <scope line="526"/>
            </method>
            <method name="notifyListeners" type="void" line="531">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <scope line="532">
                    <declaration name="copy" type="XEvent" line="535"/>
                    <scope line="536">
                        <scope line="537"/>
                    </scope>
                    <scope line="540"/>
                </scope>
            </method>
            <method name="dispatchEvent" type="void" line="546">
                <params>
                    <param name="ev" type="XEvent"/>
                </params>
                <comment line="557">
                    The &apos;window&apos; field in this event is unused.
                     This application itself does nothing to initiate such an event
                     (no calls of XChangeKeyboardMapping etc.).
                     SunRay server sends this event to the application once on every
                     keyboard (not just layout) change which means, quite seldom.                    
                </comment>
                <comment line="572">
                    Clone it to avoid synchronization during dispatching                    
                </comment>
                <declaration name="xany" type="XAnyEvent" line="547"/>
                <scope line="551"/>
                <scope line="555"/>
                <declaration name="dispatchers" type="Collection" line="567"/>
                <scope line="568">
                    <declaration name="key" type="Long" line="569"/>
                    <scope line="571"/>
                </scope>
                <scope line="575">
                    <declaration name="iter" type="Iterator" line="576"/>
                    <scope line="577">
                        <declaration name="disp" type="XEventDispatcher" line="578"/>
                    </scope>
                </scope>
            </method>
            <method name="processException" type="void" line="585">
                <params>
                    <param name="thr" type="Throwable"/>
                </params>
                <scope line="586"/>
            </method>
            <method name="awt_toolkit_init" type="void" line="591"/>
            <method name="run" type="void" line="593"/>
            <method name="run" type="void" line="599">
                <params>
                    <param name="loop" type="boolean"/>
                </params>
                <comment line="603">
                    Fix for 6829923: we should gracefully handle toolkit thread interruption                    
                </comment>
                <comment line="605">
                    We expect interruption from the AppContext.dispose() method only.
                     If the thread is interrupted from another place, let&apos;s skip it
                     for compatibility reasons. Probably some time later we&apos;ll remove
                     the check for AppContext.isDisposed() and will unconditionally
                     break the loop here.                    
                </comment>
                <comment line="617">
                    In the secondary loop we may have already aquired awt_lock
                     several times, so waitForEvents() might be unable to release
                     the awt_lock and this causes lock up.
                     For now, we just avoid waitForEvents in the secondary loop.                    
                </comment>
                <comment line="626">
                    If no events are queued, waitForEvents() causes calls to
                     awtUnlock(), awtJNI_ThreadYield, poll, awtLock(),
                     so it spends most of its time in poll, without holding the lock.                    
                </comment>
                <comment line="653">
                    Check if input method consumes the event                    
                </comment>
                <comment line="672">
                    IS THIS CORRECT?                    
                </comment>
                <declaration name="ev" type="XEvent" line="600"/>
                <scope line="601">
                    <scope line="603">
                        <scope line="609"/>
                    </scope>
                    <scope line="614">
                        <scope line="615">
                            <scope line="620"/>
                        </scope>
                        <scope line="623">
                            <scope line="629"/>
                        </scope>
                        <scope line="636"/>
                        <scope line="639"/>
                        <scope line="644"/>
                        <scope line="648"/>
                        <declaration name="w" type="long" line="653"/>
                        <scope line="654">
                            <declaration name="owner" type="Component" line="655"/>
                            <scope line="657">
                                <declaration name="ownerWindow" type="XWindow" line="658"/>
                                <scope line="659"/>
                            </scope>
                        </scope>
                        <scope line="664"/>
                        <scope line="667"/>
                        <scope line="670"/>
                    </scope>
                    <scope line="675"/>
                    <scope line="678"/>
                    <scope line="681"/>
                </scope>
            </method>
            <method name="getDefaultScreenWidth" type="int" line="687">
                <scope line="688">
                    <declaration name="display" type="long" line="689"/>
                    <scope line="691"/>
                    <scope line="693"/>
                </scope>
            </method>
            <method name="getDefaultScreenHeight" type="int" line="700">
                <scope line="701">
                    <declaration name="display" type="long" line="702"/>
                    <scope line="704"/>
                    <scope line="706"/>
                </scope>
            </method>
            <method name="getScreenWidth" type="int" line="713"/>
            <method name="getScreenHeight" type="int" line="717"/>
            <method name="getWorkArea" type="Rectangle" line="722">
                <params>
                    <param name="root" type="long"/>
                </params>
                <declaration name="XA_NET_WORKAREA" type="XAtom" line="723"/>
                <declaration name="native_ptr" type="long" line="725"/>
                <scope line="727">
                    <declaration name="workareaPresent" type="boolean" line="728"/>
                    <scope line="731">
                        <declaration name="rootX" type="int" line="732"/>
                        <declaration name="rootY" type="int" line="733"/>
                        <declaration name="rootWidth" type="int" line="734"/>
                        <declaration name="rootHeight" type="int" line="735"/>
                    </scope>
                </scope>
                <scope line="741"/>
            </method>
            <method name="getScreenInsets" type="Insets" line="758">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <declaration name="netProto" type="XNETProtocol" line="759"/>
                <scope line="761"/>
                <scope line="767">
                    <declaration name="x11gc" type="X11GraphicsConfig" line="768"/>
                    <declaration name="x11gd" type="X11GraphicsDevice" line="769"/>
                    <declaration name="root" type="long" line="770"/>
                    <declaration name="rootBounds" type="Rectangle" line="771"/>
                    <declaration name="x11ge" type="X11GraphicsEnvironment" line="773"/>
                    <scope line="776">
                        <declaration name="workArea" type="Rectangle" line="777"/>
                        <scope line="779"/>
                    </scope>
                </scope>
                <scope line="790"/>
            </method>
            <method name="getScreenInsetsManually" type="Insets" line="803">
                <params>
                    <param name="root" type="long"/>
                    <param name="rootBounds" type="Rectangle"/>
                    <param name="screenBounds" type="Rectangle"/>
                </params>
                <comment line="805">
                    During the manual calculation of screen insets we iterate
                     all the X windows hierarchy starting from root window. This
                     constant is the max level inspected in this hierarchy.
                     3 is a heuristic value: I suppose any the toolbar-like
                     window is a child of either root or desktop window.                    
                </comment>
                <comment line="827">
                    Note that most of the modern window managers unmap
                     application window if it is iconified. Thus, any
                     _NET_WM_STRUT[_PARTIAL] hints for iconified windows
                     are not included to the screen insets.                    
                </comment>
                <comment line="841">
                    first, check if _NET_WM_STRUT or _NET_WM_STRUT_PARTIAL are present
                     if both are set on the window, _NET_WM_STRUT_PARTIAL is used (see _NET spec)                    
                </comment>
                <comment line="850">
                    second, verify that window is located on the proper screen                    
                </comment>
                <comment line="856">
                    if _NET_WM_STRUT_PARTIAL is present, we should use its values to detect
                     if the struts area intersects with screenBounds, however some window
                     managers don&apos;t set this hint correctly, so we just get intersection with windowBounds                    
                </comment>
                <declaration name="MAX_NESTED_LEVEL" type="int" line="811"/>
                <declaration name="XA_NET_WM_STRUT" type="XAtom" line="813"/>
                <declaration name="XA_NET_WM_STRUT_PARTIAL" type="XAtom" line="814"/>
                <declaration name="insets" type="Insets" line="816"/>
                <declaration name="search" type="java.util.List" line="818"/>
                <scope line="822">
                    <declaration name="window" type="long" line="823"/>
                    <declaration name="windowLevel" type="int" line="824"/>
                    <scope line="833"/>
                    <declaration name="native_ptr" type="long" line="837"/>
                    <scope line="839">
                        <declaration name="strutPresent" type="boolean" line="842"/>
                        <scope line="844"/>
                        <scope line="848">
                            <declaration name="windowBounds" type="Rectangle" line="850"/>
                            <scope line="852"/>
                            <scope line="859"/>
                        </scope>
                    </scope>
                    <scope line="868"/>
                    <scope line="873">
                        <declaration name="children" type="Set&lt;Long&gt;" line="874"/>
                        <scope line="876"/>
                    </scope>
                </scope>
            </method>
            <method name="targetToPeer" type="Object" line="907">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <declaration name="p" type="Object" line="908"/>
                <scope line="909"/>
            </method>
            <method name="targetDisposedPeer" type="void" line="918">
                <params>
                    <param name="target" type="Object"/>
                    <param name="peer" type="Object"/>
                </params>
            </method>
            <method name="createRobot" type="RobotPeer" line="922">
                <params>
                    <param name="target" type="Robot"/>
                    <param name="screen" type="GraphicsDevice"/>
                </params>
            </method>
            <method name="setDynamicLayout" type="void" line="933">
                <params>
                    <param name="b" type="boolean"/>
                </params>
            </method>
            <method name="isDynamicLayoutSet" type="boolean" line="937"/>
            <method name="isDynamicLayoutSupported" type="boolean" line="944"/>
            <method name="isDynamicLayoutActive" type="boolean" line="948"/>
            <method name="getFontPeer" type="FontPeer" line="953">
                <params>
                    <param name="name" type="String"/>
                    <param name="style" type="int"/>
                </params>
            </method>
            <method name="createDragSourceContextPeer" type="DragSourceContextPeer" line="957">
                <params>
                    <param name="dge" type="DragGestureEvent"/>
                </params>
            </method>
            <method name="createDragGestureRecognizer" type="T" line="967">
                <params>
                    <param name="recognizerClass" type="Class<T>"/>
                    <param name="ds" type="DragSource"/>
                    <param name="c" type="Component"/>
                    <param name="srcActions" type="int"/>
                    <param name="dgl" type="DragGestureListener"/>
                </params>
            </method>
            <method name="createCheckboxMenuItem" type="CheckboxMenuItemPeer" line="974">
                <params>
                    <param name="target" type="CheckboxMenuItem"/>
                </params>
                <comment line="977">
                    vb157120: looks like we don&apos;t need to map menu items
                    in new menus implementation
                    targetCreatedPeer(target, peer);                    
                </comment>
                <declaration name="peer" type="XCheckboxMenuItemPeer" line="975"/>
            </method>
            <method name="createMenuItem" type="MenuItemPeer" line="982">
                <params>
                    <param name="target" type="MenuItem"/>
                </params>
                <comment line="985">
                    vb157120: looks like we don&apos;t need to map menu items
                    in new menus implementation
                    targetCreatedPeer(target, peer);                    
                </comment>
                <declaration name="peer" type="XMenuItemPeer" line="983"/>
            </method>
            <method name="createTextField" type="TextFieldPeer" line="990">
                <params>
                    <param name="target" type="TextField"/>
                </params>
                <declaration name="peer" type="TextFieldPeer" line="991"/>
            </method>
            <method name="createLabel" type="LabelPeer" line="996">
                <params>
                    <param name="target" type="Label"/>
                </params>
                <declaration name="peer" type="LabelPeer" line="997"/>
            </method>
            <method name="createList" type="ListPeer" line="1002">
                <params>
                    <param name="target" type="java.awt.List"/>
                </params>
                <declaration name="peer" type="ListPeer" line="1003"/>
            </method>
            <method name="createCheckbox" type="CheckboxPeer" line="1008">
                <params>
                    <param name="target" type="Checkbox"/>
                </params>
                <declaration name="peer" type="CheckboxPeer" line="1009"/>
            </method>
            <method name="createScrollbar" type="ScrollbarPeer" line="1014">
                <params>
                    <param name="target" type="Scrollbar"/>
                </params>
                <declaration name="peer" type="XScrollbarPeer" line="1015"/>
            </method>
            <method name="createScrollPane" type="ScrollPanePeer" line="1020">
                <params>
                    <param name="target" type="ScrollPane"/>
                </params>
                <declaration name="peer" type="XScrollPanePeer" line="1021"/>
            </method>
            <method name="createTextArea" type="TextAreaPeer" line="1026">
                <params>
                    <param name="target" type="TextArea"/>
                </params>
                <declaration name="peer" type="TextAreaPeer" line="1027"/>
            </method>
            <method name="createChoice" type="ChoicePeer" line="1032">
                <params>
                    <param name="target" type="Choice"/>
                </params>
                <declaration name="peer" type="XChoicePeer" line="1033"/>
            </method>
            <method name="createCanvas" type="CanvasPeer" line="1038">
                <params>
                    <param name="target" type="Canvas"/>
                </params>
                <declaration name="peer" type="XCanvasPeer" line="1039"/>
            </method>
            <method name="createPanel" type="PanelPeer" line="1044">
                <params>
                    <param name="target" type="Panel"/>
                </params>
                <declaration name="peer" type="PanelPeer" line="1045"/>
            </method>
            <method name="createWindow" type="WindowPeer" line="1050">
                <params>
                    <param name="target" type="Window"/>
                </params>
                <declaration name="peer" type="WindowPeer" line="1051"/>
            </method>
            <method name="createDialog" type="DialogPeer" line="1056">
                <params>
                    <param name="target" type="Dialog"/>
                </params>
                <declaration name="peer" type="DialogPeer" line="1057"/>
            </method>
            <declaration name="sunAwtDisableGtkFileDialogs" type="Boolean" line="1062"/>
            <javadoc line="1064">
                Returns the value of &quot;sun.awt.disableGtkFileDialogs&quot; property. Default
                  value is {@code false}.                
            </javadoc>
            <method name="getSunAwtDisableGtkFileDialogs" type="boolean" line="1068">
                <scope line="1069"/>
            </method>
            <method name="createFileDialog" type="FileDialogPeer" line="1076">
                <params>
                    <param name="target" type="FileDialog"/>
                </params>
                <comment line="1079">
                    The current GtkFileChooser is available from GTK+ 2.4                    
                </comment>
                <declaration name="peer" type="FileDialogPeer" line="1077"/>
                <scope line="1079"/>
                <scope line="1081"/>
            </method>
            <method name="createMenuBar" type="MenuBarPeer" line="1088">
                <params>
                    <param name="target" type="MenuBar"/>
                </params>
                <declaration name="peer" type="XMenuBarPeer" line="1089"/>
            </method>
            <method name="createMenu" type="MenuPeer" line="1094">
                <params>
                    <param name="target" type="Menu"/>
                </params>
                <comment line="1097">
                    vb157120: looks like we don&apos;t need to map menu items
                    in new menus implementation
                    targetCreatedPeer(target, peer);                    
                </comment>
                <declaration name="peer" type="XMenuPeer" line="1095"/>
            </method>
            <method name="createPopupMenu" type="PopupMenuPeer" line="1102">
                <params>
                    <param name="target" type="PopupMenu"/>
                </params>
                <declaration name="peer" type="XPopupMenuPeer" line="1103"/>
            </method>
            <method name="getMouseInfoPeer" type="MouseInfoPeer" line="1108">
                <scope line="1109"/>
            </method>
            <method name="createEmbeddedFrame" type="XEmbeddedFramePeer" line="1116">
                <params>
                    <param name="target" type="XEmbeddedFrame"/>
                </params>
                <declaration name="peer" type="XEmbeddedFramePeer" line="1117"/>
            </method>
            <method name="createEmbedProxy" type="XEmbedChildProxyPeer" line="1122">
                <params>
                    <param name="target" type="XEmbedChildProxy"/>
                </params>
                <declaration name="peer" type="XEmbedChildProxyPeer" line="1123"/>
            </method>
            <method name="createKeyboardFocusManagerPeer" type="KeyboardFocusManagerPeer" line="1128">
                <params>
                    <param name="manager" type="KeyboardFocusManager"/>
                </params>
                <declaration name="peer" type="XKeyboardFocusManagerPeer" line="1129"/>
            </method>
            <javadoc line="1133">
                Returns a new custom cursor.                
            </javadoc>
            <method name="createCustomCursor" type="Cursor" line="1137">
                <params>
                    <param name="cursor" type="Image"/>
                    <param name="hotSpot" type="Point"/>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="createTrayIcon" type="TrayIconPeer" line="1143">
                <params>
                    <param name="target" type="TrayIcon"/>
                </params>
                <declaration name="peer" type="TrayIconPeer" line="1144"/>
            </method>
            <method name="createSystemTray" type="SystemTrayPeer" line="1149">
                <params>
                    <param name="target" type="SystemTray"/>
                </params>
                <declaration name="peer" type="SystemTrayPeer" line="1150"/>
            </method>
            <method name="isTraySupported" type="boolean" line="1154">
                <declaration name="peer" type="XSystemTrayPeer" line="1155"/>
                <scope line="1156"/>
            </method>
            <javadoc line="1162">
                Returns the supported cursor size                
            </javadoc>
            <method name="getBestCursorSize" type="Dimension" line="1165">
                <params>
                    <param name="preferredWidth" type="int"/>
                    <param name="preferredHeight" type="int"/>
                </params>
            </method>
            <method name="getMaximumCursorColors" type="int" line="1171">
                <comment line="1173">
                    Black and white.                    
                </comment>
            </method>
            <method name="mapInputMethodHighlight" type="Map" line="1175">
                <params>
                    <param name="highlight" type="InputMethodHighlight"/>
                </params>
            </method>
            <method name="getLockingKeyState" type="boolean" line="1179">
                <params>
                    <param name="key" type="int"/>
                </params>
                <scope line="1181"/>
                <scope line="1185"/>
                <scope line="1187"/>
            </method>
            <method name="getSystemClipboard" type="Clipboard" line="1192">
                <declaration name="security" type="SecurityManager" line="1193"/>
                <scope line="1194"/>
                <scope line="1197">
                    <scope line="1198"/>
                </scope>
            </method>
            <method name="getSystemSelection" type="Clipboard" line="1205">
                <declaration name="security" type="SecurityManager" line="1206"/>
                <scope line="1207"/>
                <scope line="1210">
                    <scope line="1211"/>
                </scope>
            </method>
            <method name="beep" type="void" line="1218">
                <scope line="1220"/>
                <scope line="1223"/>
            </method>
            <method name="getPrintJob" type="PrintJob" line="1229">
                <params>
                    <param name="frame" type="Frame"/>
                    <param name="doctitle" type="String"/>
                    <param name="props" type="Properties"/>
                </params>
                <scope line="1231"/>
                <declaration name="printJob" type="PrintJob2D" line="1235"/>
                <scope line="1237"/>
            </method>
            <method name="getPrintJob" type="PrintJob" line="1246">
                <params>
                    <param name="frame" type="Frame"/>
                    <param name="doctitle" type="String"/>
                    <param name="jobAttributes" type="JobAttributes"/>
                    <param name="pageAttributes" type="PageAttributes"/>
                </params>
                <scope line="1247"/>
                <declaration name="printJob" type="PrintJob2D" line="1251"/>
                <scope line="1254"/>
            </method>
            <method name="XSync" type="void" line="1261">
                <scope line="1263"/>
                <scope line="1265"/>
            </method>
            <method name="getScreenResolution" type="int" line="1270">
                <declaration name="display" type="long" line="1271"/>
                <scope line="1273"/>
                <scope line="1278"/>
            </method>
            <method name="getDefaultXColormap" type="long" line="1283"/>
            <method name="getDefaultScreenData" type="long" line="1284"/>
            <declaration name="screenmodel" type="ColorModel" line="1286"/>
            <method name="getStaticColorModel" type="ColorModel" line="1288">
                <scope line="1289"/>
            </method>
            <method name="getColorModel" type="ColorModel" line="1295"/>
            <javadoc line="1299">
                Returns a new input method adapter descriptor for native input methods.                
            </javadoc>
            <method name="getInputMethodAdapterDescriptor" type="InputMethodDescriptor" line="1302"/>
            <method name="getMultiClickTime" type="int" line="1306">
                <scope line="1307"/>
            </method>
            <method name="initializeMultiClickTime" type="void" line="1312">
                <comment line="1324">
                    Note: OpenWindows.MultiClickTimeout is in tenths of
                    a second, so we need to multiply by 100 to convert to                    
                </comment>
                <scope line="1314">
                    <scope line="1315">
                        <declaration name="multiclick_time_query" type="String" line="1316"/>
                        <scope line="1317"/>
                        <scope line="1319">
                            <scope line="1322"/>
                            <scope line="1327"/>
                        </scope>
                    </scope>
                    <scope line="1331"/>
                    <scope line="1333"/>
                </scope>
                <scope line="1336"/>
                <scope line="1339"/>
            </method>
            <method name="isFrameStateSupported" type="boolean" line="1346">
                <params>
                    <param name="state" type="int"/>
                </params>
                <scope line="1347"/>
                <scope line="1349"/>
            </method>
            <method name="dumpPeers" type="void" line="1354">
                <scope line="1355">
                    <declaration name="iter" type="Iterator" line="1357"/>
                    <scope line="1358">
                        <declaration name="entry" type="Map.Entry" line="1359"/>
                        <scope line="1361">
                            <declaration name="target" type="Component" line="1362"/>
                        </scope>
                    </scope>
                    <scope line="1371">
                        <declaration name="entry" type="Map.Entry" line="1372"/>
                    </scope>
                    <scope line="1378">
                        <declaration name="entry" type="Map.Entry" line="1379"/>
                    </scope>
                </scope>
            </method>
            <declaration name="initialized" type="boolean" line="1386"/>
            <declaration name="timeStampUpdated" type="boolean" line="1387"/>
            <declaration name="timeStamp" type="long" line="1388"/>
            <declaration name="timeFetcher" type="XEventDispatcher" line="1390"/>
            <anonymous_class line="1391">
                <method name="dispatchEvent" type="void" line="1392">
                    <params>
                        <param name="ev" type="XEvent"/>
                    </params>
                    <declaration name="xpe" type="XPropertyEvent" line="1395"/>
                    <scope line="1398"/>
                    <scope line="1402"/>
                </method>
            </anonymous_class>
            <declaration name="_XA_JAVA_TIME_PROPERTY_ATOM" type="XAtom" line="1411"/>
            <method name="getCurrentServerTime" type="long" line="1413">
                <comment line="1451">
                    Note: the returned timeStamp can be incorrect in this case.                    
                </comment>
                <scope line="1415">
                    <scope line="1416">
                        <scope line="1417"/>
                        <scope line="1431">
                            <declaration name="event" type="XEvent" line="1432"/>
                            <scope line="1433"/>
                            <scope line="1440"/>
                        </scope>
                        <scope line="1444">
                            <scope line="1445"/>
                        </scope>
                    </scope>
                    <scope line="1449"/>
                </scope>
                <scope line="1453"/>
            </method>
            <method name="initializeDesktopProperties" type="void" line="1458">
                <comment line="1468">
                    Don&apos;t want to call getMultiClickTime() if we are headless                    
                </comment>
                <scope line="1468"/>
            </method>
            <method name="getNumberOfButtonsImpl" type="int" line="1476"/>
            <javadoc line="1476">
                This method runs through the XPointer and XExtendedPointer array.
                  XExtendedPointer has priority because on some systems XPointer
                  (which is assigned to the virtual pointer) reports the maximum
                  capabilities of the mouse pointer (i.e. 32 physical buttons).                
            </javadoc>
            <method name="getNumberOfButtons" type="int" line="1485">
                <comment line="1492">
                    4th and 5th buttons are for wheel and shouldn&apos;t be reported as buttons.
                    If we have more than 3 physical buttons and a wheel, we report N-2 buttons.
                    If we have 3 physical buttons and a wheel, we report 3 buttons.
                    If we have 1,2,3 physical buttons, we report it as is i.e. 1,2 or 3 respectively.                    
                </comment>
                <comment line="1502">
                    Assume don&apos;t have to re-query the number again and again.                    
                </comment>
                <scope line="1487">
                    <scope line="1488">
                        <scope line="1495"/>
                        <scope line="1497"/>
                    </scope>
                </scope>
                <scope line="1503"/>
            </method>
            <declaration name="prefix" type="String" line="1508"/>
            <declaration name="postfix" type="String" line="1509"/>
            <declaration name="dndPrefix" type="String" line="1510"/>
            <method name="lazilyLoadDesktopProperty" type="Object" line="1512">
                <params>
                    <param name="name" type="String"/>
                </params>
                <scope line="1513">
                    <declaration name="cursorName" type="String" line="1514"/>
                    <scope line="1516"/>
                    <scope line="1518"/>
                </scope>
                <scope line="1523"/>
                <scope line="1527"/>
            </method>
            <method name="addPropertyChangeListener" type="void" line="1534">
                <params>
                    <param name="name" type="String"/>
                    <param name="pcl" type="PropertyChangeListener"/>
                </params>
            </method>
            <javadoc line="1539">
                Initializes XAWTXSettings if a property for a given property name is provided by
                  XSettings and they are not initialized yet.                
                <return>
                    true if the method has initialized XAWTXSettings.                    
                </return>
            </javadoc>
            <method name="initXSettingsIfNeeded" type="boolean" line="1545">
                <params>
                    <param name="propName" type="String"/>
                </params>
                <comment line="1555">
                    If no desktop font hint could be retrieved, check for
                     KDE running KWin and retrieve settings from fontconfig.
                     If that isn&apos;t found let SunToolkit will see if there&apos;s a
                     system property set by a user.                    
                </comment>
                <comment line="1564">
                    set the fontconfigKDE property so that
                     getDesktopHints() below will see it
                     and set the public property.                    
                </comment>
                <scope line="1550">
                    <scope line="1552">
                        <scope line="1559">
                            <scope line="1560">
                                <declaration name="hint" type="Object" line="1561"/>
                                <scope line="1562"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="loadXSettings" type="void" line="1581"/>
            <javadoc line="1585">
                Callback from the native side indicating some, or all, of the
                  desktop properties have changed and need to be reloaded.
                  &lt;code&gt;data&lt;/code&gt; is the byte array directly from the x server and
                  may be in little endian format.
                  &lt;p&gt;
                  NB: This could be called from any thread if triggered by
                  &lt;code&gt;loadXSettings&lt;/code&gt;.  It is called from the System EDT
                  if triggered by an XSETTINGS change.                
            </javadoc>
            <method name="parseXSettings" type="void" line="1595">
                <params>
                    <param name="screen_XXX_ignored" type="int"/>
                    <param name="updatedSettings" type="Map"/>
                </params>
                <comment line="1611">
                    XXX: we probably want to do something smarter.  In
                     particular, &quot;Net&quot; properties are of interest to the
                     &quot;core&quot; AWT itself.  E.g.
                    
                     Net/DndDragThreshold -&gt; ???
                     Net/DoubleClickTime  -&gt; awt.multiClickInterval                    
                </comment>
                <scope line="1597"/>
                <declaration name="i" type="Iterator" line="1601"/>
                <scope line="1602">
                    <declaration name="e" type="Map.Entry" line="1603"/>
                    <declaration name="name" type="String" line="1604"/>
                </scope>
                <declaration name="dragThreshold" type="Integer" line="1621"/>
                <scope line="1622"/>
                <scope line="1625"/>
            </method>
            <declaration name="altMask" type="int" line="1633"/>
            <declaration name="metaMask" type="int" line="1634"/>
            <declaration name="numLockMask" type="int" line="1635"/>
            <declaration name="modeSwitchMask" type="int" line="1636"/>
            <declaration name="modLockIsShiftLock" type="int" line="1637"/>
            <method name="keysymToPrimaryKeycode" type="int" line="1642">
                <params>
                    <param name="sym" type="long"/>
                </params>
                <scope line="1644">
                    <declaration name="code" type="int" line="1645"/>
                    <scope line="1646"/>
                    <declaration name="primary" type="long" line="1649"/>
                    <scope line="1650"/>
                </scope>
                <scope line="1654"/>
            </method>
            <method name="getModifierState" type="boolean" line="1658">
                <params>
                    <param name="jkc" type="int"/>
                </params>
                <comment line="1678">
                    ignore zero keycode                    
                </comment>
                <comment line="1693">
                    Now we know to which modifier is assigned the keycode
                     correspondent to the keysym correspondent to the java
                     keycode. We are going to check a state of this modifier.
                     If a modifier is a weird one, we cannot help it.                    
                </comment>
                <comment line="1699">
                    get any application window                    
                </comment>
                <comment line="1702">
                    get root window                    
                </comment>
                <comment line="1706">
                    root                    
                </comment>
                <comment line="1707">
                    child                    
                </comment>
                <comment line="1708">
                    root_x                    
                </comment>
                <comment line="1709">
                    root_y                    
                </comment>
                <comment line="1710">
                    child_x                    
                </comment>
                <comment line="1711">
                    child_y                    
                </comment>
                <comment line="1712">
                    mask                    
                </comment>
                <declaration name="iKeyMask" type="int" line="1659"/>
                <declaration name="ks" type="long" line="1660"/>
                <declaration name="kc" type="int" line="1661"/>
                <scope line="1662"/>
                <scope line="1666">
                    <declaration name="modmap" type="XModifierKeymap" line="1667"/>
                    <declaration name="nkeys" type="int" line="1670"/>
                    <declaration name="map_ptr" type="long" line="1672"/>
                    <scope line="1673">
                        <scope line="1674">
                            <declaration name="keycode" type="int" line="1675"/>
                            <scope line="1676"/>
                            <scope line="1679"/>
                        </scope>
                        <scope line="1684"/>
                    </scope>
                    <scope line="1689"/>
                    <declaration name="window" type="long" line="1696"/>
                    <scope line="1697"/>
                    <scope line="1700"/>
                    <declaration name="res" type="boolean" line="1704"/>
                    <declaration name="mask" type="int" line="1712"/>
                </scope>
                <scope line="1714"/>
            </method>
            <method name="setupModifierMap" type="void" line="1722">
                <comment line="1751">
                                        
                </comment>
                <declaration name="metaL" type="int" line="1723"/>
                <declaration name="metaR" type="int" line="1724"/>
                <declaration name="altL" type="int" line="1725"/>
                <declaration name="altR" type="int" line="1726"/>
                <declaration name="numLock" type="int" line="1727"/>
                <declaration name="modeSwitch" type="int" line="1728"/>
                <declaration name="shiftLock" type="int" line="1729"/>
                <declaration name="capsLock" type="int" line="1730"/>
                <declaration name="modmask" type="int" line="1732"/>
                <scope line="1737">
                    <declaration name="modmap" type="XModifierKeymap" line="1738"/>
                    <declaration name="nkeys" type="int" line="1741"/>
                    <declaration name="map_ptr" type="long" line="1743"/>
                    <scope line="1748">
                        <scope line="1749">
                            <declaration name="keycode" type="int" line="1751"/>
                            <scope line="1753"/>
                            <scope line="1758"/>
                            <scope line="1762"/>
                            <scope line="1766"/>
                            <scope line="1770"/>
                        </scope>
                    </scope>
                    <scope line="1778">
                        <declaration name="keycode" type="int" line="1779"/>
                        <scope line="1780"/>
                        <scope line="1783"/>
                        <scope line="1787"/>
                    </scope>
                </scope>
                <scope line="1792"/>
                <scope line="1795"/>
            </method>
            <declaration name="timeoutTasks" type="SortedMap" line="1805"/>
            <javadoc line="1807">
                Removed the task from the list of waiting-to-be called tasks.
                  If the task has been scheduled several times removes only first one.                
            </javadoc>
            <method name="remove" type="void" line="1811">
                <params>
                    <param name="task" type="Runnable"/>
                </params>
                <scope line="1812"/>
                <scope line="1816">
                    <scope line="1817"/>
                    <scope line="1820">
                        <scope line="1821"/>
                    </scope>
                    <declaration name="values" type="Collection" line="1826"/>
                    <declaration name="iter" type="Iterator" line="1827"/>
                    <scope line="1828">
                        <declaration name="list" type="java.util.List" line="1829"/>
                        <declaration name="removed" type="boolean" line="1830"/>
                        <scope line="1831">
                            <scope line="1833"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1839"/>
            </method>
            <method name="wakeup_poll" type="void" line="1844"/>
            <javadoc line="1846">
                Registers a Runnable which &lt;code&gt;run()&lt;/code&gt; method will be called
                  once on the toolkit thread when a specified interval of time elapses.                
                <param>
                    task a Runnable which &lt;code&gt;run&lt;/code&gt; method will be called
                      on the toolkit thread when &lt;code&gt;interval&lt;/code&gt; milliseconds
                      elapse                    
                </param>
                <param>
                    interval an interal in milliseconds                    
                </param>
                <throws>
                    NullPointerException if &lt;code&gt;task&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;                    
                </throws>
                <throws>
                    IllegalArgumentException if &lt;code&gt;interval&lt;/code&gt; is not positive                    
                </throws>
            </javadoc>
            <method name="schedule" type="void" line="1858">
                <params>
                    <param name="task" type="Runnable"/>
                    <param name="interval" type="long"/>
                </params>
                <comment line="1890">
                    Added task became first task - poll won&apos;t know
                     about it so we need to wake it up                    
                </comment>
                <scope line="1859"/>
                <scope line="1862"/>
                <scope line="1867">
                    <scope line="1868"/>
                    <scope line="1875"/>
                    <declaration name="time" type="Long" line="1879"/>
                    <declaration name="tasks" type="java.util.List" line="1880"/>
                    <scope line="1881"/>
                    <scope line="1888"/>
                </scope>
                <scope line="1893"/>
            </method>
            <method name="getNextTaskTime" type="long" line="1898">
                <scope line="1900">
                    <scope line="1901"/>
                </scope>
                <scope line="1905"/>
            </method>
            <javadoc line="1910">
                Executes mature timeout tasks registered with schedule().
                  Called from run() under awtLock.                
            </javadoc>
            <method name="callTimeoutTasks" type="void" line="1914">
                <scope line="1915"/>
                <scope line="1920"/>
                <declaration name="currentTime" type="Long" line="1924"/>
                <declaration name="time" type="Long" line="1925"/>
                <scope line="1927">
                    <declaration name="tasks" type="java.util.List" line="1928"/>
                    <scope line="1930">
                        <declaration name="task" type="Runnable" line="1931"/>
                        <scope line="1933"/>
                        <scope line="1938"/>
                        <scope line="1940"/>
                        <scope line="1942"/>
                    </scope>
                    <scope line="1947"/>
                </scope>
            </method>
            <method name="getAwtDefaultFg" type="long" line="1954"/>
            <method name="isLeftMouseButton" type="boolean" line="1958">
                <params>
                    <param name="me" type="MouseEvent"/>
                </params>
            </method>
            <method name="isRightMouseButton" type="boolean" line="1972">
                <params>
                    <param name="me" type="MouseEvent"/>
                </params>
                <declaration name="numButtons" type="int" line="1973"/>
            </method>
            <declaration name="reset_time_utc" type="long" line="1989"/>
            <declaration name="WRAP_TIME_MILLIS" type="long" line="1990"/>
            <method name="nowMillisUTC_offset" type="long" line="1997">
                <params>
                    <param name="server_offset" type="long"/>
                </params>
                <comment line="1999">
                    ported from awt_util.c                    
                </comment>
                <comment line="2000">
                    Because Time is of type &apos;unsigned long&apos;, it is possible that Time will
                     never wrap when using 64-bit Xlib. However, if a 64-bit client
                     connects to a 32-bit server, I suspect the values will still wrap. So
                     we should not attempt to remove the wrap checking even if _LP64 is
                     true.                    
                </comment>
                <declaration name="current_time_utc" type="long" line="2007"/>
                <scope line="2008"/>
                <scope line="2013"/>
                <scope line="2017"/>
            </method>
            <javadoc line="2023">
                @see sun.awt.SunToolkit#needsXEmbedImpl                
            </javadoc>
            <method name="needsXEmbedImpl" type="boolean" line="2026">
                <comment line="2028">
                    XToolkit implements supports for XEmbed-client protocol and
                     requires the supports from the embedding host for it to work.                    
                </comment>
            </method>
            <method name="isModalityTypeSupported" type="boolean" line="2032">
                <params>
                    <param name="modalityType" type="Dialog.ModalityType"/>
                </params>
            </method>
            <method name="isModalExclusionTypeSupported" type="boolean" line="2040">
                <params>
                    <param name="exclusionType" type="Dialog.ModalExclusionType"/>
                </params>
            </method>
            <method name="getEventQueue" type="EventQueue" line="2047">
                <params>
                    <param name="target" type="Object"/>
                </params>
                <declaration name="appContext" type="AppContext" line="2048"/>
                <scope line="2049"/>
            </method>
            <method name="removeSourceEvents" type="void" line="2055">
                <params>
                    <param name="queue" type="EventQueue"/>
                    <param name="source" type="Object"/>
                    <param name="removeAllEvents" type="boolean"/>
                </params>
                <scope line="2056"/>
                <scope line="2060"/>
                <scope line="2063"/>
            </method>
            <method name="isAlwaysOnTopSupported" type="boolean" line="2068">
                <scope line="2069">
                    <scope line="2070"/>
                </scope>
            </method>
            <method name="useBufferPerWindow" type="boolean" line="2077"/>
            <javadoc line="2081">
                Returns one of XConstants: NotUseful, WhenMapped or Always.
                  If backing store is not available on at least one screen, or
                  java2d uses DGA(which conflicts with backing store) on at least one screen,
                  or the string system property &quot;sun.awt.backingStore&quot; is neither &quot;Always&quot;
                  nor &quot;WhenMapped&quot;, then the method returns XConstants.NotUseful.
                  Otherwise, if the system property &quot;sun.awt.backingStore&quot; is &quot;WhenMapped&quot;,
                  then the method returns XConstants.WhenMapped.
                  Otherwise (i.e., if the system property &quot;sun.awt.backingStore&quot; is &quot;Always&quot;),
                  the method returns XConstants.Always.                
            </javadoc>
            <method name="getBackingStoreType" type="int" line="2092"/>
            <method name="setBackingStoreType" type="void" line="2096">
                <declaration name="prop" type="String" line="2097"/>
                <scope line="2100">
                    <scope line="2102"/>
                </scope>
                <scope line="2109"/>
                <scope line="2113"/>
                <scope line="2115"/>
                <scope line="2117"/>
                <scope line="2121"/>
                <scope line="2128">
                    <scope line="2131"/>
                </scope>
                <scope line="2139">
                    <declaration name="screenCount" type="int" line="2140"/>
                    <scope line="2141">
                        <scope line="2143">
                            <scope line="2146"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2154"/>
            </method>
            <declaration name="backingStoreType" type="int" line="2159"/>
            <javadoc line="2159">
                One of XConstants: NotUseful, WhenMapped or Always.                
            </javadoc>
            <declaration name="XSUN_KP_BEHAVIOR" type="int" line="2164"/>
            <declaration name="XORG_KP_BEHAVIOR" type="int" line="2165"/>
            <declaration name="IS_SUN_KEYBOARD" type="int" line="2166"/>
            <declaration name="IS_NONSUN_KEYBOARD" type="int" line="2167"/>
            <declaration name="IS_KANA_KEYBOARD" type="int" line="2168"/>
            <declaration name="IS_NONKANA_KEYBOARD" type="int" line="2169"/>
            <declaration name="awt_IsXsunKPBehavior" type="int" line="2172"/>
            <declaration name="awt_UseXKB" type="boolean" line="2173"/>
            <declaration name="awt_UseXKB_Calls" type="boolean" line="2174"/>
            <declaration name="awt_XKBBaseEventCode" type="int" line="2175"/>
            <declaration name="awt_XKBEffectiveGroup" type="int" line="2176"/>
            <declaration name="awt_XKBDescPtr" type="long" line="2178"/>
            <javadoc line="2180">
                Check for Xsun convention regarding numpad keys.
                  Xsun and some other servers (i.e. derived from Xsun)
                  under certain conditions process numpad keys unlike Xorg.                
            </javadoc>
            <method name="isXsunKPBehavior" type="boolean" line="2185">
                <scope line="2187">
                    <scope line="2188">
                        <scope line="2189"/>
                        <scope line="2191"/>
                    </scope>
                </scope>
                <scope line="2196"/>
            </method>
            <declaration name="sunOrNotKeyboard" type="int" line="2201"/>
            <declaration name="kanaOrNotKeyboard" type="int" line="2202"/>
            <method name="resetKeyboardSniffer" type="void" line="2203"/>
            <method name="isSunKeyboard" type="boolean" line="2207">
                <scope line="2208">
                    <scope line="2209"/>
                    <scope line="2211"/>
                </scope>
            </method>
            <method name="isKanaKeyboard" type="boolean" line="2217">
                <scope line="2218">
                    <scope line="2219"/>
                    <scope line="2221"/>
                </scope>
            </method>
            <method name="isXKBenabled" type="boolean" line="2227">
                <scope line="2229"/>
                <scope line="2231"/>
            </method>
            <javadoc line="2236">
                Query XKEYBOARD extension.
                  If possible, initialize xkb library.                
            </javadoc>
            <method name="tryXKB" type="boolean" line="2240">
                <comment line="2245">
                    First, if there is extension at all.                    
                </comment>
                <comment line="2248">
                    There is a keyboard extension. Check if a client library is compatible.
                     If not, don&apos;t use xkb calls.
                     In this case we still may be Xkb-capable application.                    
                </comment>
                <comment line="2260">
                    |                    
                </comment>
                <comment line="2261">
                    XConstants.XkbStateNotifyMask,                    
                </comment>
                <comment line="2263">
                    |                    
                </comment>
                <comment line="2264">
                    XConstants.XkbStateNotifyMask);                    
                </comment>
                <comment line="2270">
                    XXX ? XkbGroupLockMask last, XkbAllStateComponentsMask before last?                    
                </comment>
                <scope line="2242">
                    <declaration name="name" type="String" line="2243"/>
                    <scope line="2246">
                        <scope line="2251">
                            <scope line="2254"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="2280"/>
            </method>
            <method name="canUseXKBCalls" type="boolean" line="2284">
                <scope line="2286"/>
                <scope line="2288"/>
            </method>
            <method name="getXKBEffectiveGroup" type="int" line="2292">
                <scope line="2294"/>
                <scope line="2296"/>
            </method>
            <method name="getXKBBaseEventCode" type="int" line="2300">
                <scope line="2302"/>
                <scope line="2304"/>
            </method>
            <method name="getXKBKbdDesc" type="long" line="2308">
                <scope line="2310"/>
                <scope line="2312"/>
            </method>
            <method name="freeXKB" type="void" line="2316">
                <scope line="2318">
                    <scope line="2319"/>
                </scope>
                <scope line="2323"/>
            </method>
            <method name="processXkbChanges" type="void" line="2327">
                <params>
                    <param name="ev" type="XEvent"/>
                </params>
                <comment line="2329">
                    mapping change --&gt; refresh kbd map
                     state change --&gt; get a new effective group; do I really need it
                      or that should be left for XkbTranslateKeyCode?                    
                </comment>
                <comment line="2345">
                    System.out.println(&quot;XkbNewKeyboard:&quot;+(xke.get_new_kbd()));                    
                </comment>
                <comment line="2348">
                    TODO: provide a simple unit test.                    
                </comment>
                <comment line="2355">
                    System.out.println(&quot;XkbMap:&quot;+(xke.get_map()));                    
                </comment>
                <comment line="2358">
                    May use it later e.g. to obtain an effective group etc.
                    System.out.println(&quot;XkbState:&quot;+(xke.get_state()));                    
                </comment>
                <comment line="2362">
                    System.out.println(&quot;XkbEvent of xkb_type &quot;+xkb_type);                    
                </comment>
                <declaration name="xke" type="XkbEvent" line="2331"/>
                <declaration name="xkb_type" type="int" line="2332"/>
                <scope line="2335"/>
            </method>
            <declaration name="eventNumber" type="long" line="2366"/>
            <method name="getEventNumber" type="long" line="2367">
                <scope line="2369"/>
                <scope line="2371"/>
            </method>
            <declaration name="oops_waiter" type="XEventDispatcher" line="2376"/>
            <declaration name="oops_updated" type="boolean" line="2377"/>
            <declaration name="oops_failed" type="boolean" line="2378"/>
            <declaration name="oops" type="XAtom" line="2379"/>
            <declaration name="WORKAROUND_SLEEP" type="long" line="2380"/>
            <javadoc line="2382">
                @inheritDoc                
            </javadoc>
            <method name="syncNativeQueue" type="boolean" line="2385">
                <params>
                    <param name="timeout" type="long"/>
                </params>
                <comment line="2402">
                    WM forgot to acquire selection  or there is no WM                    
                </comment>
                <comment line="2422">
                    Wait for selection notify for oops on win                    
                </comment>
                <comment line="2441">
                    This &quot;while&quot; is a protection from spurious
                     wake-ups.  However, we shouldn&apos;t wait for too long                    
                </comment>
                <comment line="2448">
                    If selection update failed we can simply wait some time
                     hoping some events will arrive                    
                </comment>
                <declaration name="win" type="XBaseWindow" line="2386"/>
                <scope line="2388">
                    <anonymous_class line="2389">
                        <method name="dispatchEvent" type="void" line="2390">
                            <params>
                                <param name="e" type="XEvent"/>
                            </params>
                            <comment line="2402">
                                WM forgot to acquire selection  or there is no WM                                
                            </comment>
                            <scope line="2391">
                                <declaration name="pe" type="XSelectionEvent" line="2392"/>
                                <scope line="2393"/>
                                <scope line="2400"/>
                            </scope>
                        </method>
                    </anonymous_class>
                </scope>
                <scope line="2411"/>
                <scope line="2416">
                    <declaration name="event_number" type="long" line="2422"/>
                    <declaration name="atom" type="XAtom" line="2423"/>
                    <declaration name="start" type="long" line="2433"/>
                    <scope line="2434">
                        <scope line="2435"/>
                        <scope line="2437"/>
                        <scope line="2442"/>
                    </scope>
                    <scope line="2446">
                        <scope line="2451"/>
                        <scope line="2453"/>
                        <scope line="2455"/>
                    </scope>
                </scope>
                <scope line="2460"/>
            </method>
            <method name="grab" type="void" line="2466">
                <params>
                    <param name="w" type="Window"/>
                </params>
                <scope line="2467"/>
            </method>
            <method name="ungrab" type="void" line="2472">
                <params>
                    <param name="w" type="Window"/>
                </params>
                <scope line="2473"/>
            </method>
            <javadoc line="2477">
                Returns if the java.awt.Desktop class is supported on the current
                  desktop.
                  &lt;p&gt;
                  The methods of java.awt.Desktop class are supported on the Gnome desktop.
                  Check if the running desktop is Gnome by checking the window manager.                
            </javadoc>
            <method name="isDesktopSupported" type="boolean" line="2484"/>
            <method name="createDesktopPeer" type="DesktopPeer" line="2488">
                <params>
                    <param name="target" type="Desktop"/>
                </params>
            </method>
            <method name="areExtraMouseButtonsEnabled" type="boolean" line="2492"/>
            <method name="isWindowOpacitySupported" type="boolean" line="2497">
                <declaration name="net_protocol" type="XNETProtocol" line="2498"/>
                <scope line="2500"/>
            </method>
            <method name="isWindowShapingSupported" type="boolean" line="2508"/>
            <method name="isWindowTranslucencySupported" type="boolean" line="2513">
                <comment line="2515">
                    NOTE: it may not be supported. The actual check is being performed
                          at com.sun.awt.AWTUtilities(). In X11 we need to check
                          whether there&apos;s any translucency-capable GC available.                    
                </comment>
            </method>
            <method name="isTranslucencyCapable" type="boolean" line="2521">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <scope line="2522"/>
            </method>
            <javadoc line="2528">
                Returns the value of &quot;sun.awt.disablegrab&quot; property. Default
                  value is {@code false}.                
            </javadoc>
            <method name="getSunAwtDisableGrab" type="boolean" line="2532"/>
        </class>
    </source>