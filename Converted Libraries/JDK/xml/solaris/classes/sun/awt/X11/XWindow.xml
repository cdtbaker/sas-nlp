<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.X11">
        <import package="java.awt"/>
        <import package="java.awt.event"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.image.ColorModel"/>
        <import package="java.lang.ref.WeakReference"/>
        <import package="java.lang.reflect.Field"/>
        <import package="java.lang.reflect.Method"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt"/>
        <import package="sun.awt.image.PixelConverter"/>
        <import package="sun.java2d.SunGraphics2D"/>
        <import package="sun.java2d.SurfaceData"/>
        <class name="XWindow" line="47">
            <extends class="XBaseWindow"/>
            <comment line="54">
                If a motion comes in while a multi-click is pending,
                 allow a smudge factor so that moving the mouse by a small
                 amount does not wipe out the multi-click state variables.                
            </comment>
            <comment line="59">
                ButtonXXX events stuff                
            </comment>
            <comment line="67">
                used to check if we need to re-create surfaceData.                
            </comment>
            <comment line="76">
                Indicates whether the value on savedState is valid                
            </comment>
            <comment line="77">
                Holds last known state of the top-level window                
            </comment>
            <comment line="99">
                whether it is reparented by default                
            </comment>
            <comment line="105">
                fallback default font object                
            </comment>
            <comment line="115">
                A bitmask keeps the button&apos;s numbers as Button1Mask, Button2Mask, Button3Mask
                 which are allowed to
                 generate the CLICK event after the RELEASE has happened.
                 There are conditions that must be true for that sending CLICK event:
                 1) button was initially PRESSED
                 2) no movement or drag has happened until RELEASE                
            </comment>
            <comment line="170">
                This create is used by the XEmbeddedFramePeer since it has to create the window                
            </comment>
            <comment line="424">
                Post an event to the event queue.                
            </comment>
            <comment line="427">
                NOTE: This method may be called by privileged threads.
                       DO NOT INVOKE CLIENT CODE ON THIS THREAD!                
            </comment>
            <comment line="445">
                overriden in XCanvasPeer                
            </comment>
            <comment line="450">
                We need a version of setBackground that does not call repaint !!
                 and one that does not get overridden. The problem is that in postInit
                 we call setBackground and we dont have all the stuff initialized to
                 do a full paint for most peers. So we cannot call setBackground in postInit.                
            </comment>
            <comment line="539">
                used by Peers to avoid flickering withing paint()                
            </comment>
            <comment line="869">
                REMIND: need to implement looking for disabled events                
            </comment>
            <comment line="1086">
                called directly from this package, unlike handleKeyRelease.
                 un-final it if you need to override it in a subclass.                
            </comment>
            <comment line="1190">
                un-private it if you need to call it from elsewhere                
            </comment>
            <comment line="1245">
                XmNiconic and MapUnmapNotify (that XmNiconic relies on) are
                 unreliable, since mapping changes can happen for a virtual desktop
                 switch or MacOS style shading that became quite popular under X as
                 well.  Yes, it probably should not be this way, as it violates
                 ICCCM, but reality is that quite a lot of window managers abuse
                 mapping state.                
            </comment>
            <comment line="1481">
                These two methods are actually applicable to toplevel windows only.
                 However, the functionality is required by both the XWindowPeer and
                 XWarningWindow, both of which have the XWindow as a common ancestor.
                 See XWM.setMotifDecor() for details.                
            </comment>
            <comment line="1522">
                Implementation of the X11ComponentPeer                
            </comment>
            <implements interface="X11ComponentPeer"/>
            <declaration name="log" type="PlatformLogger" line="48"/>
            <declaration name="insLog" type="PlatformLogger" line="49"/>
            <declaration name="eventLog" type="PlatformLogger" line="50"/>
            <declaration name="focusLog" type="PlatformLogger" line="51"/>
            <declaration name="keyEventLog" type="PlatformLogger" line="52"/>
            <declaration name="AWT_MULTICLICK_SMUDGE" type="int" line="57"/>
            <declaration name="rbutton" type="int" line="59"/>
            <declaration name="lastX" type="int" line="60"/>
            <declaration name="lastTime" type="long" line="61"/>
            <declaration name="lastButton" type="long" line="62"/>
            <declaration name="lastWindowRef" type="WeakReference" line="63"/>
            <declaration name="clickCount" type="int" line="64"/>
            <declaration name="oldWidth" type="int" line="67"/>
            <declaration name="oldHeight" type="int" line="68"/>
            <declaration name="mwm_hints" type="PropMwmHints" line="70"/>
            <declaration name="wm_protocols" type="XAtom" line="71"/>
            <declaration name="wm_delete_window" type="XAtom" line="72"/>
            <declaration name="wm_take_focus" type="XAtom" line="73"/>
            <declaration name="stateChanged" type="boolean" line="75"/>
            <declaration name="savedState" type="int" line="76"/>
            <declaration name="winAttr" type="XWindowAttributesData" line="78"/>
            <declaration name="graphicsConfig" type="X11GraphicsConfig" line="80"/>
            <declaration name="graphicsConfigData" type="AwtGraphicsConfigData" line="81"/>
            <declaration name="reparented" type="boolean" line="83"/>
            <declaration name="parent" type="XWindow" line="85"/>
            <declaration name="target" type="Component" line="87"/>
            <declaration name="JAWT_LOCK_ERROR" type="int" line="89"/>
            <declaration name="JAWT_LOCK_CLIP_CHANGED" type="int" line="90"/>
            <declaration name="JAWT_LOCK_BOUNDS_CHANGED" type="int" line="91"/>
            <declaration name="JAWT_LOCK_SURFACE_CHANGED" type="int" line="92"/>
            <declaration name="drawState" type="int" line="93"/>
            <declaration name="TARGET" type="String" line="97"/>
            <declaration name="surfaceData" type="SurfaceData" line="100"/>
            <declaration name="paintArea" type="XRepaintArea" line="102"/>
            <declaration name="defaultFont" type="Font" line="105"/>
            <method name="getDefaultFont" type="Font" line="107">
                <scope line="108"/>
            </method>
            <declaration name="mouseButtonClickAllowed" type="int" line="121"/>
            <method name="getNativeColor" type="int" line="123"/>
            <method name="getWMInsets" type="void" line="124"/>
            <method name="getTopWindow" type="long" line="125"/>
            <method name="getWindowBounds" type="void" line="126"/>
            <method name="initIDs" type="void" line="127"/>
            <declaration name="isPostedField" type="Field" line="129"/>
            <declaration name="rawCodeField" type="Field" line="130"/>
            <declaration name="primaryLevelUnicodeField" type="Field" line="131"/>
            <declaration name="extendedKeyCodeField" type="Field" line="132"/>
            <scope line="133"/>
            <method name="XWindow" type="constructor" line="137">
                <params>
                    <param name="params" type="XCreateWindowParams"/>
                </params>
            </method>
            <method name="XWindow" type="constructor" line="141"/>
            <method name="XWindow" type="constructor" line="144">
                <params>
                    <param name="parentWindow" type="long"/>
                    <param name="bounds" type="Rectangle"/>
                </params>
            </method>
            <method name="XWindow" type="constructor" line="150">
                <params>
                    <param name="target" type="Component"/>
                    <param name="parentWindow" type="long"/>
                    <param name="bounds" type="Rectangle"/>
                </params>
            </method>
            <method name="XWindow" type="constructor" line="157">
                <params>
                    <param name="target" type="Component"/>
                    <param name="parentWindow" type="long"/>
                </params>
            </method>
            <method name="XWindow" type="constructor" line="161">
                <params>
                    <param name="target" type="Component"/>
                </params>
            </method>
            <method name="XWindow" type="constructor" line="165">
                <params>
                    <param name="target" type="Object"/>
                </params>
            </method>
            <method name="XWindow" type="constructor" line="171">
                <params>
                    <param name="parentWindow" type="long"/>
                </params>
            </method>
            <method name="initGraphicsConfiguration" type="void" line="178"/>
            <method name="preInit" type="void" line="183">
                <params>
                    <param name="params" type="XCreateWindowParams"/>
                </params>
                <comment line="206">
                    fix 4948833: this call forces the color map to be initialized                    
                </comment>
                <declaration name="gData" type="AwtGraphicsConfigData" line="191"/>
                <declaration name="config" type="X11GraphicsConfig" line="192"/>
                <declaration name="visInfo" type="XVisualInfo" line="193"/>
                <scope line="199"/>
                <scope line="201"/>
                <declaration name="parentWindow" type="Long" line="211"/>
                <scope line="212">
                    <scope line="214">
                        <declaration name="screen" type="int" line="215"/>
                        <scope line="216"/>
                        <scope line="218"/>
                    </scope>
                    <scope line="221"/>
                </scope>
                <scope line="227"/>
                <scope line="234">
                    <scope line="235"/>
                </scope>
                <scope line="241"/>
            </method>
            <method name="postInit" type="void" line="248">
                <params>
                    <param name="params" type="XCreateWindowParams"/>
                </params>
                <comment line="257">
                    We need a version of setBackground that does not call repaint !!
                     and one that does not get overridden. The problem is that in postInit
                     we call setBackground and we dont have all the stuff initialized to
                     do a full paint for most peers. So we cannot call setBackground in postInit.
                     instead we need to call xSetBackground.                    
                </comment>
                <declaration name="c" type="Color" line="254"/>
                <scope line="255"/>
            </method>
            <method name="getGraphicsConfiguration" type="GraphicsConfiguration" line="265">
                <scope line="266"/>
            </method>
            <method name="getGraphicsConfigurationData" type="AwtGraphicsConfigData" line="272">
                <scope line="273"/>
            </method>
            <method name="getWMClass" type="String[]" line="279"/>
            <method name="setReparented" type="void" line="283">
                <params>
                    <param name="newValue" type="boolean"/>
                </params>
            </method>
            <method name="isReparented" type="boolean" line="287"/>
            <method name="getParentWindowID" type="long" line="291">
                <params>
                    <param name="target" type="Component"/>
                </params>
                <declaration name="peer" type="ComponentPeer" line="293"/>
                <declaration name="temp" type="Component" line="294"/>
                <scope line="296"/>
            </method>
            <method name="getParentXWindowObject" type="XWindow" line="307">
                <params>
                    <param name="target" type="Component"/>
                </params>
                <declaration name="temp" type="Component" line="309"/>
                <declaration name="peer" type="ComponentPeer" line="311"/>
                <scope line="314"/>
            </method>
            <method name="isParentOf" type="boolean" line="324">
                <params>
                    <param name="win" type="XWindow"/>
                </params>
                <scope line="325"/>
                <declaration name="parent" type="Container" line="328"/>
                <scope line="329"/>
            </method>
            <method name="getTarget" type="Object" line="335"/>
            <method name="getEventSource" type="Component" line="338"/>
            <method name="getColorModel" type="ColorModel" line="342">
                <params>
                    <param name="transparency" type="int"/>
                </params>
            </method>
            <method name="getColorModel" type="ColorModel" line="346">
                <scope line="347"/>
                <scope line="350"/>
            </method>
            <method name="getGraphics" type="Graphics" line="355">
                <params>
                    <param name="surfData" type="SurfaceData"/>
                    <param name="afore" type="Color"/>
                    <param name="aback" type="Color"/>
                    <param name="afont" type="Font"/>
                </params>
                <comment line="361">
                                        
                </comment>
                <declaration name="target" type="Component" line="358"/>
                <declaration name="bgColor" type="Color" line="361"/>
                <scope line="362"/>
                <declaration name="fgColor" type="Color" line="365"/>
                <scope line="366"/>
                <declaration name="font" type="Font" line="369"/>
                <scope line="370"/>
            </method>
            <method name="getGraphics" type="Graphics" line="376"/>
            <method name="getFontMetrics" type="FontMetrics" line="383">
                <params>
                    <param name="font" type="Font"/>
                </params>
            </method>
            <method name="getTargetBounds" type="Rectangle" line="387"/>
            <javadoc line="391">
                Returns true if the event has been handled and should not be
                  posted to Java.                
            </javadoc>
            <method name="prePostEvent" type="boolean" line="395">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
            </method>
            <declaration name="m_sendMessage" type="Method" line="399"/>
            <method name="sendEvent" type="void" line="400">
                <params>
                    <param name="e" type="AWTEvent"/>
                </params>
                <comment line="405">
                    The uses of this method imply that the incoming event is system-generated                    
                </comment>
                <scope line="401"/>
                <anonymous_class line="406">
                    <method name="run" type="void" line="407">
                        <scope line="408"/>
                        <scope line="410"/>
                        <scope line="412"/>
                    </method>
                </anonymous_class>
                <declaration name="pe" type="PeerEvent" line="406"/>
            </method>
            <method name="postEvent" type="void" line="428">
                <params>
                    <param name="event" type="AWTEvent"/>
                </params>
            </method>
            <method name="postEventStatic" type="void" line="432">
                <params>
                    <param name="event" type="AWTEvent"/>
                </params>
            </method>
            <method name="postEventToEventQueue" type="void" line="436">
                <params>
                    <param name="event" type="AWTEvent"/>
                </params>
                <comment line="438">
                    fix for 6239938 : Choice drop-down does not disappear when it loses focus, on XToolkit                    
                </comment>
                <comment line="440">
                    event hasn&apos;t been handled and must be posted to EventQueue                    
                </comment>
                <scope line="438"/>
            </method>
            <method name="doEraseBackground" type="boolean" line="445"/>
            <method name="xSetBackground" type="void" line="453">
                <params>
                    <param name="c" type="Color"/>
                </params>
                <comment line="458">
                    fix for 6558510: handle sun.awt.noerasebackground flag,
                     see doEraseBackground() and preInit() methods in XCanvasPeer                    
                </comment>
                <comment line="463">
                    6304250: XAWT: Items in choice show a blue border on OpenGL + Solaris10 when background color is set
                     Note: When OGL is enabled, surfaceData.pixelFor() will not
                     return a pixel value appropriate for passing to
                     XSetWindowBackground().  Therefore, we will use the ColorModel
                     for this component in order to calculate a pixel value from
                     the given RGB value.                    
                </comment>
                <scope line="455">
                    <scope line="459"/>
                    <declaration name="cm" type="ColorModel" line="468"/>
                    <declaration name="pixel" type="int" line="469"/>
                </scope>
                <scope line="472"/>
            </method>
            <method name="setBackground" type="void" line="477">
                <params>
                    <param name="c" type="Color"/>
                </params>
            </method>
            <declaration name="backgroundColor" type="Color" line="481"/>
            <method name="winBackground" type="void" line="482">
                <params>
                    <param name="c" type="Color"/>
                </params>
            </method>
            <method name="getWinBackground" type="Color" line="486">
                <declaration name="c" type="Color" line="487"/>
                <scope line="489"/>
                <scope line="491"/>
                <scope line="495"/>
            </method>
            <method name="isEmbedded" type="boolean" line="502"/>
            <method name="repaint" type="void" line="506">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <scope line="507"/>
                <declaration name="g" type="Graphics" line="510"/>
                <scope line="511">
                    <scope line="512"/>
                    <scope line="515"/>
                </scope>
            </method>
            <method name="repaint" type="void" line="521">
                <scope line="522"/>
                <declaration name="g" type="Graphics" line="525"/>
                <scope line="526">
                    <scope line="527"/>
                    <scope line="529"/>
                </scope>
            </method>
            <method name="paint" type="void" line="535">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
            </method>
            <method name="flush" type="void" line="539">
                <scope line="541"/>
                <scope line="543"/>
            </method>
            <method name="popup" type="void" line="548">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="550">
                    TBD: grab the pointer                    
                </comment>
            </method>
            <method name="handleExposeEvent" type="void" line="553">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <declaration name="xe" type="XExposeEvent" line="555"/>
                <scope line="556"/>
                <declaration name="x" type="int" line="559"/>
                <declaration name="y" type="int" line="560"/>
                <declaration name="w" type="int" line="561"/>
                <declaration name="h" type="int" line="562"/>
                <declaration name="target" type="Component" line="564"/>
                <declaration name="compAccessor" type="AWTAccessor.ComponentAccessor" line="565"/>
                <scope line="570"/>
            </method>
            <method name="handleExposeEvent" type="void" line="575">
                <params>
                    <param name="target" type="Component"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
                <declaration name="event" type="PaintEvent" line="576"/>
                <scope line="578"/>
            </method>
            <method name="getModifiers" type="int" line="583">
                <params>
                    <param name="state" type="int"/>
                    <param name="button" type="int"/>
                    <param name="keyCode" type="int"/>
                </params>
            </method>
            <method name="getModifiers" type="int" line="587">
                <params>
                    <param name="state" type="int"/>
                    <param name="button" type="int"/>
                    <param name="keyCode" type="int"/>
                    <param name="type" type="int"/>
                    <param name="wheel_mouse" type="boolean"/>
                </params>
                <comment line="606">
                    InputEvent.BUTTON_DOWN_MASK array is starting from BUTTON1_DOWN_MASK on index == 0.
                     button currently reflects a real button number and starts from 1. (except NOBUTTON which is zero )                    
                </comment>
                <comment line="609">
                                        
                </comment>
                <comment line="611">
                    reflects a button number similar to MouseEvent.BUTTON1, 2, 3 etc.                    
                </comment>
                <comment line="613">
                    modifier should be added if :
                     1) current button is now still in PRESSED state (means that user just pressed mouse but not released yet) or
                     2) if Xsystem reports that &quot;state&quot; represents that button was just released. This only happens on RELEASE with 1,2,3 buttons.
                     ONLY one of these conditions should be TRUE to add that modifier.                    
                </comment>
                <comment line="618">
                    exclude wheel buttons from adding their numbers as modifiers                    
                </comment>
                <declaration name="modifiers" type="int" line="588"/>
                <scope line="590"/>
                <scope line="593"/>
                <scope line="596"/>
                <scope line="599"/>
                <scope line="602"/>
                <scope line="611">
                    <scope line="616">
                        <scope line="618"/>
                    </scope>
                </scope>
            </method>
            <method name="getXModifiers" type="int" line="626">
                <params>
                    <param name="stroke" type="AWTKeyStroke"/>
                </params>
                <declaration name="mods" type="int" line="627"/>
                <declaration name="res" type="int" line="628"/>
                <scope line="629"/>
                <scope line="632"/>
                <scope line="635"/>
                <scope line="638"/>
                <scope line="641"/>
            </method>
            <javadoc line="647">
                Returns true if this event is disabled and shouldn&apos;t be passed to Java.
                  Default implementation returns false for all events.                
            </javadoc>
            <method name="getRightButtonNumber" type="int" line="651">
                <comment line="653">
                    not initialized yet                    
                </comment>
                <scope line="652">
                    <scope line="654"/>
                    <scope line="657"/>
                </scope>
            </method>
            <method name="getMouseMovementSmudge" type="int" line="664">
                <comment line="666">
                    TODO: It&apos;s possible to read corresponding settings                    
                </comment>
            </method>
            <method name="handleButtonPressRelease" type="void" line="669">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="683">
                    Ignore the buttons above 20 due to the bit limit for
                     InputEvent.BUTTON_DOWN_MASK.
                     One more bit is reserved for FIRST_HIGH_BIT.                    
                </comment>
                <comment line="704">
                    Allow this mouse button to generate CLICK event on next ButtonRelease                    
                </comment>
                <comment line="707">
                    multiclick checking                    
                </comment>
                <comment line="725">
                    Check for popup trigger !!                    
                </comment>
                <comment line="736">
                    4 and 5 buttons are usually considered assigned to a first wheel                    
                </comment>
                <comment line="742">
                    mapping extra buttons to numbers starting from 4.                    
                </comment>
                <comment line="763">
                    No up-button in the drag-state                    
                </comment>
                <comment line="790">
                                        
                </comment>
                <comment line="792">
                                        
                </comment>
                <declaration name="xbe" type="XButtonEvent" line="671"/>
                <scope line="672"/>
                <declaration name="when" type="long" line="676"/>
                <declaration name="modifiers" type="int" line="677"/>
                <declaration name="popupTrigger" type="boolean" line="678"/>
                <declaration name="button" type="int" line="679"/>
                <declaration name="wheel_mouse" type="boolean" line="680"/>
                <declaration name="lbutton" type="int" line="681"/>
                <scope line="687"/>
                <declaration name="type" type="int" line="690"/>
                <declaration name="jWhen" type="long" line="692"/>
                <declaration name="x" type="int" line="694"/>
                <declaration name="y" type="int" line="695"/>
                <scope line="696">
                    <declaration name="localXY" type="Point" line="697"/>
                </scope>
                <scope line="702">
                    <declaration name="lastWindow" type="XWindow" line="705"/>
                    <scope line="712"/>
                    <scope line="714"/>
                    <scope line="727"/>
                    <scope line="729"/>
                </scope>
                <scope line="737"/>
                <scope line="742"/>
                <scope line="746"/>
                <scope line="751">
                    <declaration name="me" type="MouseEvent" line="752"/>
                    <scope line="763"/>
                </scope>
                <scope line="776">
                    <scope line="777">
                        <declaration name="mwe" type="MouseWheelEvent" line="778"/>
                    </scope>
                </scope>
                <scope line="790"/>
            </method>
            <method name="handleMotionNotify" type="void" line="796">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="804">
                    (xme.get_state() &amp; (XConstants.buttonsMask[0] | XConstants.buttonsMask[1] | XConstants.buttonsMask[2]));                    
                </comment>
                <comment line="806">
                    this doesn&apos;t work for extra buttons because Xsystem is sending state==0 for every extra button event.
                     we can&apos;t correct it in MouseEvent class as we done it with modifiers, because exact type (DRAG|MOVE)
                     should be passed from XWindow.                    
                </comment>
                <comment line="812">
                    TODO : here is the bug in WM: extra buttons doesn&apos;t have state!=0 as they should.                    
                </comment>
                <comment line="827">
                    Fix for 6176814 .  Add multiclick checking.                    
                </comment>
                <comment line="857">
                    Fix for 5039416.
                     According to canvas.c we shouldn&apos;t post any MouseEvent if mouse is dragging and clickCount!=0.                    
                </comment>
                <declaration name="xme" type="XMotionEvent" line="798"/>
                <scope line="799"/>
                <declaration name="mouseKeyState" type="int" line="803"/>
                <declaration name="buttonsNumber" type="int" line="808"/>
                <scope line="810">
                    <scope line="812"/>
                </scope>
                <declaration name="isDragging" type="boolean" line="817"/>
                <declaration name="mouseEventType" type="int" line="818"/>
                <scope line="820"/>
                <scope line="822"/>
                <declaration name="x" type="int" line="829"/>
                <declaration name="y" type="int" line="830"/>
                <declaration name="lastWindow" type="XWindow" line="831"/>
                <scope line="836"/>
                <declaration name="jWhen" type="long" line="845"/>
                <declaration name="modifiers" type="int" line="846"/>
                <declaration name="popupTrigger" type="boolean" line="847"/>
                <declaration name="source" type="Component" line="849"/>
                <scope line="851">
                    <declaration name="localXY" type="Point" line="852"/>
                </scope>
                <scope line="859">
                    <declaration name="mme" type="MouseEvent" line="860"/>
                </scope>
            </method>
            <method name="x11inputMethodLookupString" type="boolean" line="869"/>
            <method name="haveCurrentX11InputMethodInstance" type="boolean" line="870"/>
            <declaration name="mouseAboveMe" type="boolean" line="872"/>
            <method name="isMouseAbove" type="boolean" line="874">
                <scope line="875"/>
            </method>
            <method name="setMouseAbove" type="void" line="879">
                <params>
                    <param name="above" type="boolean"/>
                </params>
                <scope line="880"/>
            </method>
            <method name="enterNotify" type="void" line="885">
                <params>
                    <param name="window" type="long"/>
                </params>
                <scope line="886"/>
            </method>
            <method name="leaveNotify" type="void" line="890">
                <params>
                    <param name="window" type="long"/>
                </params>
                <scope line="891"/>
            </method>
            <method name="handleXCrossingEvent" type="void" line="896">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="905">
                    LeaveNotify:                    
                </comment>
                <comment line="909">
                    Skip event If it was caused by a grab
                     This is needed because on displays with focus-follows-mouse on MousePress X system generates
                     two XCrossing events with mode != NormalNotify. First of them notifies that the mouse has left
                     current component. Second one notifies that it has entered into the same component.
                     This looks like the window under the mouse has actually changed and Java handle these  events
                     accordingly. This leads to impossibility to make a double click on Component (6404708)                    
                </comment>
                <comment line="918">
                    6404708 : need update cursor in accordance with skipping Leave/EnterNotify event
                     whereas it doesn&apos;t need to handled further.                    
                </comment>
                <comment line="923">
                    LeaveNotify:                    
                </comment>
                <comment line="929">
                    X sends XCrossing to all hierarchy so if the edge of child equals to
                     ancestor and mouse enters child, the ancestor will get an event too.
                     From java point the event is bogus as ancestor is obscured, so if
                     the child can get java event itself, we skip it on ancestor.                    
                </comment>
                <comment line="943">
                    Remember old component with mouse to have the opportunity to send it MOUSE_EXITED.                    
                </comment>
                <comment line="948">
                    Change XAwtState&apos;s component mouse entered to the up-to-date one before requesting
                     to update the cursor since XAwtState.getComponentMouseEntered() is used when the
                     cursor is updated (in XGlobalCursorManager.findHeavyweightUnderCursor()).                    
                </comment>
                <comment line="953">
                    LeaveNotify:                    
                </comment>
                <comment line="978">
                    This code tracks boundary crossing and ensures MOUSE_ENTER/EXIT
                     are posted in alternate pairs                    
                </comment>
                <declaration name="xce" type="XCrossingEvent" line="898"/>
                <scope line="902"/>
                <scope line="904"/>
                <declaration name="toplevel" type="XWindowPeer" line="914"/>
                <scope line="915">
                    <scope line="916">
                        <scope line="919"/>
                        <scope line="922"/>
                    </scope>
                </scope>
                <declaration name="childWnd" type="long" line="932"/>
                <scope line="933">
                    <declaration name="child" type="XBaseWindow" line="934"/>
                    <scope line="937"/>
                </scope>
                <declaration name="compWithMouse" type="Component" line="943"/>
                <scope line="944">
                    <scope line="945">
                        <scope line="946"/>
                        <scope line="952"/>
                    </scope>
                    <scope line="955"/>
                </scope>
                <scope line="961"/>
                <declaration name="jWhen" type="long" line="965"/>
                <declaration name="modifiers" type="int" line="966"/>
                <declaration name="clickCount" type="int" line="967"/>
                <declaration name="popupTrigger" type="boolean" line="968"/>
                <declaration name="x" type="int" line="969"/>
                <declaration name="y" type="int" line="970"/>
                <scope line="971">
                    <declaration name="localXY" type="Point" line="972"/>
                </scope>
                <scope line="979">
                    <declaration name="me" type="MouseEvent" line="980"/>
                </scope>
                <scope line="988">
                    <declaration name="me" type="MouseEvent" line="989"/>
                </scope>
            </method>
            <method name="doLayout" type="void" line="996">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
            </method>
            <method name="handleConfigureNotifyEvent" type="void" line="998">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="1009">
                    if ( Check if it&apos;s a resize, a move, or a stacking order change )
                      {                    
                </comment>
                <comment line="1018">
                    }                    
                </comment>
                <declaration name="oldBounds" type="Rectangle" line="999"/>
                <scope line="1004"/>
                <declaration name="bounds" type="Rectangle" line="1010"/>
                <scope line="1011"/>
                <scope line="1014"/>
            </method>
            <method name="handleMapNotifyEvent" type="void" line="1020">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <scope line="1023"/>
                <declaration name="ce" type="ComponentEvent" line="1026"/>
            </method>
            <method name="handleUnmapNotifyEvent" type="void" line="1032">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <scope line="1034"/>
                <declaration name="ce" type="ComponentEvent" line="1037"/>
            </method>
            <method name="dumpKeysymArray" type="void" line="1043">
                <params>
                    <param name="ev" type="XKeyEvent"/>
                </params>
            </method>
            <javadoc line="1049">
                Return unicode character or 0 if no correspondent character found.
                  Parameter is a keysym basically from keysymdef.h
                  XXX: how about vendor keys? Is there some with Unicode value and not in the list?                
            </javadoc>
            <method name="keysymToUnicode" type="int" line="1054">
                <params>
                    <param name="keysym" type="long"/>
                    <param name="state" type="int"/>
                </params>
            </method>
            <method name="keyEventType2Id" type="int" line="1057">
                <params>
                    <param name="xEventType" type="int"/>
                </params>
            </method>
            <method name="xkeycodeToKeysym" type="long" line="1061">
                <params>
                    <param name="ev" type="XKeyEvent"/>
                </params>
            </method>
            <method name="xkeycodeToPrimaryKeysym" type="long" line="1064">
                <params>
                    <param name="ev" type="XKeyEvent"/>
                </params>
            </method>
            <method name="primaryUnicode2JavaKeycode" type="int" line="1067">
                <params>
                    <param name="uni" type="int"/>
                </params>
                <comment line="1070">
                    return (uni &gt; 0? uni + 0x01000000 : 0);                    
                </comment>
            </method>
            <method name="logIncomingKeyEvent" type="void" line="1071">
                <params>
                    <param name="ev" type="XKeyEvent"/>
                </params>
            </method>
            <method name="handleKeyPress" type="void" line="1076">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <declaration name="ev" type="XKeyEvent" line="1078"/>
                <scope line="1080"/>
            </method>
            <method name="handleKeyPress" type="void" line="1087">
                <params>
                    <param name="ev" type="XKeyEvent"/>
                </params>
                <comment line="1096">
                    TODO check if there&apos;s an active input method instance
                     without calling a native method. Is it necessary though?                    
                </comment>
                <comment line="1114">
                    No input method instance found. For example, there&apos;s a Java Input Method.
                     Produce do-it-yourself keysym and perhaps unicode character.                    
                </comment>
                <comment line="1123">
                    Keysym should be converted to Unicode, if possible and necessary,
                     and Java KeyEvent keycode should be calculated.
                     For press we should post pressed &amp; typed Java events.
                    
                     Press event might be not processed to this time because
                      (1) either XIM could not handle it or
                      (2) it was Latin 1:1 mapping.                    
                </comment>
                <comment line="1136">
                    Take the first keysym from a keysym array associated with the XKeyevent
                     and convert it to Unicode. Then, even if a Java keycode for the keystroke
                     is undefined, we still have a guess of what has been engraved on a keytop.                    
                </comment>
                <comment line="1151">
                    someway backward compatible                    
                </comment>
                <declaration name="keysym" type="long" line="1088"/>
                <declaration name="unicodeKey" type="int" line="1089"/>
                <scope line="1092"/>
                <scope line="1097">
                    <scope line="1098">
                        <scope line="1099"/>
                    </scope>
                    <scope line="1105">
                        <scope line="1107"/>
                    </scope>
                </scope>
                <scope line="1112">
                    <scope line="1117"/>
                </scope>
                <declaration name="jkc" type="XKeysym.Keysym2JavaKeycode" line="1130"/>
                <scope line="1131"/>
                <declaration name="unicodeFromPrimaryKeysym" type="int" line="1138"/>
                <scope line="1140"/>
                <declaration name="jkeyToReturn" type="int" line="1150"/>
                <declaration name="jkeyExtended" type="int" line="1151"/>
                <scope line="1164"/>
            </method>
            <method name="handleKeyRelease" type="void" line="1180">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <declaration name="ev" type="XKeyEvent" line="1182"/>
                <scope line="1184"/>
            </method>
            <method name="handleKeyRelease" type="void" line="1190">
                <params>
                    <param name="ev" type="XKeyEvent"/>
                </params>
                <comment line="1199">
                    Keysym should be converted to Unicode, if possible and necessary,
                     and Java KeyEvent keycode should be calculated.
                     For release we should post released event.                    
                </comment>
                <comment line="1216">
                    We obtain keysym from IM and derive unicodeKey from it for KeyPress only.
                     We used to cache that value and retrieve it on KeyRelease,
                     but in case for example of a dead key+vowel pair, a vowel after a deadkey
                     might never be cached before.
                     Also, switching between keyboard layouts, we might cache a wrong letter.
                     That&apos;s why we use the same procedure as if there was no IM instance: do-it-yourself unicode.                    
                </comment>
                <comment line="1224">
                    Take a first keysym from a keysym array associated with the XKeyevent
                     and convert it to Unicode. Then, even if Java keycode for the keystroke
                     is undefined, we still will have a guess of what was engraved on a keytop.                    
                </comment>
                <comment line="1229">
                    someway backward compatible                    
                </comment>
                <declaration name="keysym" type="long" line="1191"/>
                <declaration name="unicodeKey" type="int" line="1192"/>
                <scope line="1195"/>
                <declaration name="jkc" type="XKeysym.Keysym2JavaKeycode" line="1202"/>
                <scope line="1203"/>
                <scope line="1206"/>
                <declaration name="unicodeFromPrimaryKeysym" type="int" line="1226"/>
                <declaration name="jkeyToReturn" type="int" line="1228"/>
                <declaration name="jkeyExtended" type="int" line="1229"/>
            </method>
            <method name="getWMState" type="int" line="1252">
                <scope line="1253">
                    <declaration name="getter" type="WindowPropertyGetter" line="1255"/>
                    <scope line="1258">
                        <declaration name="status" type="int" line="1259"/>
                        <scope line="1260"/>
                        <scope line="1264"/>
                    </scope>
                    <scope line="1268"/>
                </scope>
            </method>
            <javadoc line="1275">
                Override this methods to get notifications when top-level window state changes. The state is
                  meant in terms of ICCCM: WithdrawnState, IconicState, NormalState                
            </javadoc>
            <method name="stateChanged" type="void" line="1279">
                <params>
                    <param name="time" type="long"/>
                    <param name="oldState" type="int"/>
                    <param name="newState" type="int"/>
                </params>
            </method>
            <method name="handlePropertyNotify" type="void" line="1283">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="1288">
                    State has changed, invalidate saved value                    
                </comment>
                <declaration name="ev" type="XPropertyEvent" line="1285"/>
                <scope line="1286"/>
            </method>
            <method name="reshape" type="void" line="1293">
                <params>
                    <param name="bounds" type="Rectangle"/>
                </params>
            </method>
            <method name="reshape" type="void" line="1297">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <comment line="1310">
                    Fixed 6322593, 6304251, 6315137:
                     XWindow&apos;s SurfaceData should be invalidated and recreated as part
                     of the process of resizing the window
                     see the evaluation of the bug 6304251 for more information                    
                </comment>
                <scope line="1298"/>
                <scope line="1301"/>
            </method>
            <method name="layout" type="void" line="1317"/>
            <method name="isShowing" type="boolean" line="1319"/>
            <method name="isResizable" type="boolean" line="1323"/>
            <method name="isLocationByPlatform" type="boolean" line="1327"/>
            <method name="updateSizeHints" type="void" line="1331"/>
            <method name="updateSizeHints" type="void" line="1335">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                </params>
                <declaration name="flags" type="long" line="1336"/>
                <scope line="1337"/>
                <scope line="1340"/>
            </method>
            <method name="updateSizeHints" type="void" line="1346">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                </params>
                <declaration name="flags" type="long" line="1347"/>
                <scope line="1348"/>
                <scope line="1351"/>
            </method>
            <method name="validateSurface" type="void" line="1357">
                <scope line="1358"/>
            </method>
            <method name="doValidateSurface" type="void" line="1366">
                <declaration name="oldData" type="SurfaceData" line="1367"/>
                <scope line="1368"/>
            </method>
            <method name="getSurfaceData" type="SurfaceData" line="1374"/>
            <method name="dispose" type="void" line="1378">
                <declaration name="oldData" type="SurfaceData" line="1379"/>
                <scope line="1381"/>
            </method>
            <method name="getLocationOnScreen" type="Point" line="1388">
                <comment line="1397">
                    applets, embedded, etc - translate directly
                     XXX: override in subclass?                    
                </comment>
                <comment line="1413">
                    wpeer is an XDecoratedPeer not yet fully adopted by WM                    
                </comment>
                <scope line="1389">
                    <declaration name="comp" type="Component" line="1390"/>
                    <scope line="1392"/>
                    <scope line="1398"/>
                    <scope line="1403">
                        <declaration name="wpeer" type="Object" line="1404"/>
                        <scope line="1408"/>
                        <declaration name="pt" type="Point" line="1413"/>
                        <scope line="1417"/>
                    </scope>
                    <scope line="1423"/>
                </scope>
            </method>
            <declaration name="bdata" type="Field" line="1430"/>
            <method name="setBData" type="void" line="1431">
                <params>
                    <param name="e" type="KeyEvent"/>
                    <param name="data" type="byte[]"/>
                </params>
                <scope line="1432">
                    <scope line="1433"/>
                </scope>
                <scope line="1437"/>
            </method>
            <method name="postKeyEvent" type="void" line="1446">
                <params>
                    <param name="id" type="int"/>
                    <param name="when" type="long"/>
                    <param name="keyCode" type="int"/>
                    <param name="keyChar" type="int"/>
                    <param name="keyLocation" type="int"/>
                    <param name="state" type="int"/>
                    <param name="event" type="long"/>
                    <param name="eventSize" type="int"/>
                    <param name="rawCode" type="long"/>
                    <param name="unicodeFromPrimaryKeysym" type="int"/>
                    <param name="extendedKeyCode" type="int"/>
                </params>
                <declaration name="jWhen" type="long" line="1447"/>
                <declaration name="modifiers" type="int" line="1448"/>
                <scope line="1449"/>
                <scope line="1452"/>
                <scope line="1455"/>
                <declaration name="ke" type="KeyEvent" line="1459"/>
                <scope line="1461">
                    <declaration name="data" type="byte[]" line="1462"/>
                </scope>
                <scope line="1465"/>
                <scope line="1469"/>
                <scope line="1471"/>
            </method>
            <method name="getAWTKeyCodeForKeySym" type="int" line="1477"/>
            <method name="getKeySymForAWTKeyCode" type="int" line="1478"/>
            <method name="getMWMHints" type="PropMwmHints" line="1485">
                <scope line="1486">
                    <scope line="1488"/>
                </scope>
            </method>
            <method name="setMWMHints" type="void" line="1495">
                <params>
                    <param name="hints" type="PropMwmHints"/>
                </params>
                <scope line="1497"/>
            </method>
            <method name="initWMProtocols" type="void" line="1502"/>
            <javadoc line="1506">
                Returns list of protocols which should be installed on this window.
                  Descendants can override this method to add class-specific protocols                
            </javadoc>
            <method name="getWMProtocols" type="XAtomList" line="1510">
                <comment line="1512">
                    No protocols on simple window                    
                </comment>
            </method>
            <declaration name="fullScreenExclusiveModeState" type="boolean" line="1515"/>
            <javadoc line="1515">
                Indicates if the window is currently in the FSEM.
                  Synchronization: state lock.                
            </javadoc>
            <method name="setFullScreenExclusiveModeState" type="void" line="1523">
                <params>
                    <param name="state" type="boolean"/>
                </params>
                <scope line="1524"/>
            </method>
            <method name="isFullScreenExclusiveMode" type="boolean" line="1529">
                <scope line="1530"/>
            </method>
        </class>
    </source>