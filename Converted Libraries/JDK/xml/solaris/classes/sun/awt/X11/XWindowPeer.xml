<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt.X11">
        <import package="java.awt"/>
        <import package="java.awt.event.ComponentEvent"/>
        <import package="java.awt.event.FocusEvent"/>
        <import package="java.awt.event.WindowEvent"/>
        <import package="java.awt.image.BufferedImage"/>
        <import package="java.awt.peer.ComponentPeer"/>
        <import package="java.awt.peer.WindowPeer"/>
        <import package="java.io.UnsupportedEncodingException"/>
        <import package="java.security.AccessController"/>
        <import package="java.security.PrivilegedAction"/>
        <import package="java.util.ArrayList"/>
        <import package="java.util.HashSet"/>
        <import package="java.util.Iterator"/>
        <import package="java.util.Set"/>
        <import package="java.util.Vector"/>
        <import package="java.util.concurrent.atomic.AtomicBoolean"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.awt.AWTAccessor"/>
        <import package="sun.awt.DisplayChangedListener"/>
        <import package="sun.awt.SunToolkit"/>
        <import package="sun.awt.X11GraphicsDevice"/>
        <import package="sun.awt.X11GraphicsEnvironment"/>
        <import package="sun.java2d.pipe.Region"/>
        <class name="XWindowPeer" line="61">
            <extends class="XPanelPeer"/>
            <comment line="71">
                should be synchronized on awtLock                
            </comment>
            <comment line="87">
                used for modal blocking to keep existing z-order                
            </comment>
            <comment line="89">
                value of WM_TRANSIENT_FOR hint set on this window                
            </comment>
            <comment line="92">
                Whether to do a grab during showing                
            </comment>
            <comment line="94">
                Is this window mapped or not                
            </comment>
            <comment line="95">
                Am override-redirect not on top                
            </comment>
            <comment line="100">
                Focus related flags                
            </comment>
            <comment line="103">
                Is the window unhiding.                
            </comment>
            <comment line="104">
                Is the window (being shown) between
                    setVisible(true) &amp; handleMapNotify().                
            </comment>
            <comment line="119">
                It need to be accessed from XFramePeer.                
            </comment>
            <comment line="131">
                This constant defines icon size recommended for using.
                 Apparently, we should use XGetIconSizes which should
                 return icon sizes would be most appreciated by the WM.
                 However, XGetIconSizes always returns 0 for some reason.
                 So the constant has been introduced.                
            </comment>
            <comment line="140">
                Sometimes XChangeProperty(_NET_WM_ICON) doesn&apos;t work if
                 image buffer is too large. This constant holds maximum
                 length of buffer which can be used with _NET_WM_ICON hint.
                 It holds int&apos;s value.                
            </comment>
            <comment line="319">
                Sometimes XChangeProperty(_NET_WM_ICON) doesn&apos;t work if
                 image buffer is too large. This function help us accommodate
                 initial list of the icon images to certainly-acceptable.
                 It does scale some of these icons to appropriate size
                 if it&apos;s necessary.                
            </comment>
            <comment line="369">
                Dumps each icon from the list                
            </comment>
            <comment line="456">
                Fix for 6318144: PIT:Setting Min Size bigger than current size enlarges
                the window but fails to revalidate, Sol-CDE
                This bug is regression for
                5025858: Resizing a decorated frame triggers componentResized event twice.
                Since events are not posted from Component.setBounds we need to send them here.
                Note that this function is overriden in XDecoratedPeer so event
                posting is not changing for decorated peers                
            </comment>
            <comment line="519">
                NOTE: This method may be called by privileged threads.
                       DO NOT INVOKE CLIENT CODE ON THIS THREAD!                
            </comment>
            <comment line="525">
                NOTE: This method may be called by privileged threads.
                       DO NOT INVOKE CLIENT CODE ON THIS THREAD!                
            </comment>
            <comment line="531">
                NOTE: This method may be called by privileged threads.
                       DO NOT INVOKE CLIENT CODE ON THIS THREAD!                
            </comment>
            <comment line="554">
                Retrives real native focused window and converts it into Java peer.                
            </comment>
            <comment line="564">
                Retrives real native focused window and converts it into Java window.                
            </comment>
            <comment line="581">
                                
            </comment>
            <comment line="619">
                NOTE: This method may be called by privileged threads.
                       DO NOT INVOKE CLIENT CODE ON THIS THREAD!                
            </comment>
            <comment line="628">
                NOTE: This method may be called by privileged threads.
                       DO NOT INVOKE CLIENT CODE ON THIS THREAD!                
            </comment>
            <comment line="644">
                                
            </comment>
            <comment line="646">
                Xinerama
                 called to check if we&apos;ve been moved onto a different screen
                 Based on checkNewXineramaScreen() in awt_GraphicsEnv.c                
            </comment>
            <comment line="729">
                Overridden to check if we need to update our GraphicsDeviceConfig
                 Added for 4934052.                
            </comment>
            <comment line="1070">
                The height of menu bar window                
            </comment>
            <comment line="1075">
                Called when shell changes its size and requires children windows
                 to update their sizes appropriately                
            </comment>
            <comment line="1412">
                Returns a Vector of all Java top-level windows,
                 sorted by their current Z-order                
            </comment>
            <comment line="1518">
                Sets the TRANSIENT_FOR hint to the given top-level window. This
                  method is used when a window is modal blockedunblocked or
                  changed its state fromto NormalState tofrom other states.
                 If window or transientForWindow are embedded frames, the containing
                  top-level windows are used.
                
                 @param window specifies the top-level window that the hint
                  is to be set to
                 @param transientForWindow the top-level window
                 @param updateChain specifies if nextprevTransientFor fields are
                  to be updated
                 @param allStates if set to &lt;code&gt;true&lt;code&gt; then TRANSIENT_FOR hint
                  is set regardless of the state of window and transientForWindow,
                  otherwise it is set only if both are in the same state                
            </comment>
            <comment line="1565">
                This method does nothing if this window is not blocked by any modal dialog.
                 For modal blocked windows this method looks up for the nearest
                  prevTransiendFor window that is in the same state (NormalIconifiedWithdrawn)
                  as this one and makes this window transient for it. The same operation is
                  performed for nextTransientFor window.
                 Values of prevTransientFor and nextTransientFor fields are not changed.                
            </comment>
            <comment line="1593">
                Removes the TRANSIENT_FOR hint from the given top-level window.
                 If window or transientForWindow are embedded frames, the containing
                  top-level windows are used.
                
                 @param window specifies the top-level window that the hint
                  is to be removed from                
            </comment>
            <comment line="1611">
                When a modal dialog is shown, all its blocked windows are lined up into
                  a chain in such a way that each window is a transient_for window for
                  the next one. That allows us to keep the modal dialog above all its
                  blocked windows (even if there are some another modal dialogs between
                  them).
                 This method adds this top-level window to the chain of the given modal
                  dialog. To keep the current relative z-order, we should use the
                  XQueryTree to find the place to insert this window to. As each window
                  can be blocked by only one modal dialog (such checks are performed in
                  shared code), both this and blockerPeer are on the top of their chains
                  (chains may be empty).
                 If this window is a modal dialog and has its own chain, these chains are
                  merged according to the current z-order (XQueryTree is used again).
                  Below are some simple examples (z-order is from left to right, -- is
                  modal blocking).
                
                 Example 0:
                     T (current chain of this, no windows are blocked by this)
                  W1---B (current chain of blockerPeer, W2 is blocked by blockerPeer)
                  Result is:
                  W1-T-B (merged chain, all the windows are blocked by blockerPeer)
                
                 Example 1:
                  W1-T (current chain of this, W1 is blocked by this)
                       W2-B (current chain of blockerPeer, W2 is blocked by blockerPeer)
                  Result is:
                  W1-T-W2-B (merged chain, all the windows are blocked by blockerPeer)
                
                 Example 2:
                  W1----T (current chain of this, W1 is blocked by this)
                     W2---B (current chain of blockerPeer, W2 is blocked by blockerPeer)
                  Result is:
                  W1-W2-T-B (merged chain, all the windows are blocked by blockerPeer)
                
                 This method should be called under the AWT lock.
                
                 @see #removeFromTransientFors
                 @see #setModalBlocked                
            </comment>
            <comment line="1725">
                When a window is modally unblocked, it should be removed from its blocker
                  chain, see {@link #addToTransientFor addToTransientFors} method for the
                  chain definition.
                 The problem is that we cannot simply restore window&apos;s original
                  TRANSIENT_FOR hint (if any) and link prevTransientFor and
                  nextTransientFor together as the whole chain could be created as a merge
                  of two other chains in addToTransientFors. In that case, if this window is
                  a modal dialog, it would lost all its own chain, if we simply exclude it
                  from the chain.
                 The correct behaviour of this method should be to split the chain, this
                  window is currently in, into two chains. First chain is this window own
                  chain (i. e. all the windows blocked by this one, directly or indirectly),
                  if any, and the rest windows from the current chain.
                
                 Example:
                  Original state:
                   W1-B1 (window W1 is blocked by B1)
                   W2-B2 (window W2 is blocked by B2)
                  B3 is shown and blocks B1 and B2:
                   W1-W2-B1-B2-B3 (a single chain after B1.addToTransientFors() and B2.addToTransientFors())
                  If we then unblock B1, the state should be:
                   W1-B1 (window W1 is blocked by B1)
                   W2-B2-B3 (window W2 is blocked by B2 and B2 is blocked by B3)
                
                 This method should be called under the AWT lock.
                
                 @see #addToTransientFors
                 @see #setModalBlocked                
            </comment>
            <comment line="1838">
                This method is to be overriden in XDecoratedPeer.                
            </comment>
            <comment line="1896">
                should be synchronized on awtLock                
            </comment>
            <comment line="2092">
                we use it to retarget mouse drag and mouse release during grab.                
            </comment>
            <implements interface="WindowPeer"/>
            <implements interface="DisplayChangedListener"/>
            <declaration name="log" type="PlatformLogger" line="64"/>
            <declaration name="focusLog" type="PlatformLogger" line="65"/>
            <declaration name="insLog" type="PlatformLogger" line="66"/>
            <declaration name="grabLog" type="PlatformLogger" line="67"/>
            <declaration name="iconLog" type="PlatformLogger" line="68"/>
            <declaration name="windows" type="Set&lt;XWindowPeer&gt;" line="71"/>
            <declaration name="cachedFocusableWindow" type="boolean" line="74"/>
            <declaration name="warningWindow" type="XWarningWindow" line="75"/>
            <declaration name="alwaysOnTop" type="boolean" line="77"/>
            <declaration name="locationByPlatform" type="boolean" line="78"/>
            <declaration name="modalBlocker" type="Dialog" line="80"/>
            <declaration name="delayedModalBlocking" type="boolean" line="81"/>
            <declaration name="targetMinimumSize" type="Dimension" line="82"/>
            <declaration name="ownerPeer" type="XWindowPeer" line="84"/>
            <declaration name="prevTransientFor" type="XWindowPeer" line="87"/>
            <declaration name="curRealTransientFor" type="XWindowPeer" line="89"/>
            <declaration name="grab" type="boolean" line="91"/>
            <declaration name="isMapped" type="boolean" line="93"/>
            <declaration name="mustControlStackPosition" type="boolean" line="94"/>
            <declaration name="rootPropertyEventDispatcher" type="XEventDispatcher" line="95"/>
            <declaration name="isStartupNotificationRemoved" type="AtomicBoolean" line="97"/>
            <declaration name="isUnhiding" type="boolean" line="102"/>
            <declaration name="isBeforeFirstMapNotify" type="boolean" line="103"/>
            <declaration name="windowType" type="Window.Type" line="106"/>
            <javadoc line="106">
                The type of the window.
                  The type is supposed to be immutable while the peer object exists.
                  The value gets initialized in the preInit() method.                
            </javadoc>
            <method name="getWindowType" type="Window.Type" line="114"/>
            <declaration name="toplevelStateListeners" type="Vector&lt;ToplevelStateListener&gt;" line="119"/>
            <method name="XWindowPeer" type="constructor" line="120">
                <params>
                    <param name="params" type="XCreateWindowParams"/>
                </params>
            </method>
            <method name="XWindowPeer" type="constructor" line="124">
                <params>
                    <param name="target" type="Window"/>
                </params>
            </method>
            <declaration name="PREFERRED_SIZE_FOR_ICON" type="int" line="137"/>
            <declaration name="MAXIMUM_BUFFER_LENGTH_NET_WM_ICON" type="int" line="145"/>
            <method name="preInit" type="void" line="147">
                <params>
                    <param name="params" type="XCreateWindowParams"/>
                </params>
                <comment line="181">
                    we should not call setFont because it will call a repaint
                     which the peer may not be ready to do yet.                    
                </comment>
                <comment line="188">
                    we should not call setBackGround because it will call a repaint
                     which the peer may not be ready to do yet.                    
                </comment>
                <comment line="194">
                    we should not call setForeGround because it will call a repaint
                     which the peer may not be ready to do yet.                    
                </comment>
                <declaration name="eventMask" type="long" line="155"/>
                <scope line="156"/>
                <scope line="168"/>
                <scope line="170"/>
                <declaration name="f" type="Font" line="176"/>
                <scope line="177"/>
                <declaration name="c" type="Color" line="183"/>
                <scope line="184">
                    <declaration name="background" type="Color" line="185"/>
                </scope>
                <scope line="191"/>
                <declaration name="gc" type="GraphicsConfiguration" line="199"/>
            </method>
            <method name="getWMName" type="String" line="203">
                <declaration name="name" type="String" line="204"/>
                <scope line="205"/>
            </method>
            <method name="postInit" type="void" line="211">
                <params>
                    <param name="params" type="XCreateWindowParams"/>
                </params>
                <comment line="215">
                    Init WM_PROTOCOLS atom                    
                </comment>
                <comment line="218">
                    Set WM_TRANSIENT_FOR and group_leader                    
                </comment>
                <comment line="229">
                    as owner window may be an embedded window, we must get a toplevel window
                     to set as TRANSIENT_FOR hint                    
                </comment>
                <comment line="235">
                    Set WM_TRANSIENT_FOR                    
                </comment>
                <comment line="240">
                    Set group leader                    
                </comment>
                <comment line="252">
                    Init warning window(for applets)                    
                </comment>
                <comment line="254">
                    accessSystemTray permission allows to display TrayIcon, TrayIcon tooltip
                     and TrayIcon balloon windows without a warning window.                    
                </comment>
                <comment line="267">
                    no need in updateOpaque() as it is no-op                    
                </comment>
                <declaration name="t_window" type="Window" line="218"/>
                <declaration name="owner" type="Window" line="219"/>
                <scope line="220">
                    <scope line="222"/>
                    <declaration name="ownerWindow" type="long" line="230"/>
                    <scope line="231">
                        <scope line="233">
                            <declaration name="hints" type="XWMHints" line="240"/>
                        </scope>
                        <scope line="245"/>
                    </scope>
                </scope>
                <scope line="252">
                    <scope line="255"/>
                </scope>
            </method>
            <method name="updateIconImages" type="void" line="269">
                <comment line="276">
                    read icon images from target                    
                </comment>
                <comment line="301">
                    Fix for CR#6425089                    
                </comment>
                <comment line="305">
                    target.icons is empty or all icon images are broken                    
                </comment>
                <comment line="307">
                    icon is inherited from parent                    
                </comment>
                <comment line="311">
                    default icon is used                    
                </comment>
                <declaration name="target" type="Window" line="270"/>
                <declaration name="iconImages" type="java.util.List&lt;Image&gt;" line="271"/>
                <declaration name="ownerPeer" type="XWindowPeer" line="272"/>
                <scope line="274">
                    <scope line="277">
                        <declaration name="image" type="Image" line="278"/>
                        <scope line="279">
                            <scope line="280"/>
                        </scope>
                        <declaration name="iconInfo" type="XIconInfo" line="285"/>
                        <scope line="286"/>
                        <scope line="288">
                            <scope line="289"/>
                        </scope>
                        <scope line="294"/>
                    </scope>
                </scope>
                <scope line="303">
                    <scope line="305"/>
                    <scope line="309"/>
                </scope>
            </method>
            <method name="normalizeIconImages" type="java.util.List<XIconInfo>" line="325">
                <params>
                    <param name="icons" type="java.util.List<XIconInfo>"/>
                </params>
                <declaration name="result" type="java.util.List&lt;XIconInfo&gt;" line="326"/>
                <declaration name="totalLength" type="int" line="327"/>
                <declaration name="haveLargeIcon" type="boolean" line="328"/>
                <scope line="330">
                    <declaration name="width" type="int" line="331"/>
                    <declaration name="height" type="int" line="332"/>
                    <declaration name="length" type="int" line="333"/>
                    <scope line="335">
                        <scope line="336"/>
                        <declaration name="scaledWidth" type="int" line="339"/>
                        <declaration name="scaledHeight" type="int" line="340"/>
                        <scope line="342"/>
                    </scope>
                    <scope line="351">
                        <scope line="354"/>
                    </scope>
                </scope>
                <scope line="360"/>
            </method>
            <method name="dumpIcons" type="void" line="371">
                <params>
                    <param name="icons" type="java.util.List<XIconInfo>"/>
                </params>
                <scope line="372">
                    <scope line="374"/>
                </scope>
            </method>
            <method name="recursivelySetIcon" type="void" line="380">
                <params>
                    <param name="icons" type="java.util.List<XIconInfo>"/>
                </params>
                <declaration name="target" type="Window" line="383"/>
                <declaration name="children" type="Window[]" line="384"/>
                <declaration name="cnt" type="int" line="385"/>
                <scope line="386">
                    <declaration name="childPeer" type="ComponentPeer" line="387"/>
                    <scope line="388">
                        <scope line="389"/>
                    </scope>
                </scope>
            </method>
            <method name="getIconInfo" type="java.util.List<XIconInfo>" line="397"/>
            <method name="setIconHints" type="void" line="400">
                <params>
                    <param name="icons" type="java.util.List<XIconInfo>"/>
                </params>
                <comment line="402">
                    This does nothing for XWindowPeer,
                    It&apos;s overriden in XDecoratedPeer                    
                </comment>
            </method>
            <declaration name="defaultIconInfo" type="ArrayList&lt;XIconInfo&gt;" line="405"/>
            <method name="getDefaultIconInfo" type="java.util.List<XIconInfo>" line="406">
                <scope line="407">
                    <scope line="409"/>
                    <scope line="414"/>
                </scope>
            </method>
            <method name="updateShape" type="void" line="424">
                <comment line="426">
                    Shape shape = ((Window)target).getShape();                    
                </comment>
                <declaration name="shape" type="Shape" line="426"/>
                <scope line="427"/>
            </method>
            <method name="updateOpacity" type="void" line="432">
                <comment line="434">
                    float opacity = ((Window)target).getOpacity();                    
                </comment>
                <declaration name="opacity" type="float" line="434"/>
                <scope line="435"/>
            </method>
            <method name="updateMinimumSize" type="void" line="440">
                <comment line="442">
                    This function only saves minimumSize value in XWindowPeer
                    Setting WMSizeHints is implemented in XDecoratedPeer                    
                </comment>
            </method>
            <method name="getTargetMinimumSize" type="Dimension" line="447"/>
            <method name="getOwnerPeer" type="XWindowPeer" line="451"/>
            <method name="setBounds" type="void" line="462">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="op" type="int"/>
                </params>
                <scope line="464">
                    <declaration name="oldBounds" type="Rectangle" line="465"/>
                    <declaration name="bounds" type="Rectangle" line="469"/>
                    <declaration name="hints" type="XSizeHints" line="471"/>
                    <declaration name="protocol" type="XNETProtocol" line="476"/>
                    <scope line="477">
                        <declaration name="net_wm_state" type="XAtomList" line="478"/>
                    </scope>
                    <declaration name="isResized" type="boolean" line="484"/>
                    <declaration name="isMoved" type="boolean" line="485"/>
                    <scope line="486"/>
                    <scope line="489"/>
                    <scope line="492"/>
                </scope>
                <scope line="495"/>
            </method>
            <method name="updateFocusability" type="void" line="500">
                <comment line="507">
                                        
                </comment>
                <scope line="503">
                    <declaration name="hints" type="XWMHints" line="504"/>
                </scope>
                <scope line="509"/>
            </method>
            <method name="getInsets" type="Insets" line="514"/>
            <method name="handleIconify" type="void" line="520"/>
            <method name="handleDeiconify" type="void" line="526"/>
            <method name="handleStateChange" type="void" line="532">
                <params>
                    <param name="oldState" type="int"/>
                    <param name="newState" type="int"/>
                </params>
            </method>
            <javadoc line="538">
                DEPRECATED:  Replaced by getInsets().                
            </javadoc>
            <method name="insets" type="Insets" line="541"/>
            <method name="isAutoRequestFocus" type="boolean" line="545">
                <scope line="546"/>
                <scope line="548"/>
            </method>
            <method name="getNativeFocusedWindowPeer" type="XWindowPeer" line="556">
                <declaration name="baseWindow" type="XBaseWindow" line="557"/>
            </method>
            <method name="getNativeFocusedWindow" type="Window" line="566">
                <declaration name="peer" type="XWindowPeer" line="567"/>
            </method>
            <method name="isFocusableWindow" type="boolean" line="571">
                <scope line="573"/>
                <scope line="575"/>
            </method>
            <method name="isFocusedWindowModalBlocker" type="boolean" line="581"/>
            <method name="getFocusTargetWindow" type="long" line="585"/>
            <javadoc line="589">
                Returns whether or not this window peer has native X window
                  configured as non-focusable window. It might happen if:
                  - Java window is non-focusable
                  - Java window is simple Window(not Frame or Dialog)                
            </javadoc>
            <method name="isNativelyNonFocusableWindow" type="boolean" line="595">
                <scope line="597"/>
                <scope line="599"/>
            </method>
            <method name="handleWindowFocusIn_Dispatch" type="void" line="604">
                <scope line="605">
                    <declaration name="we" type="WindowEvent" line="607"/>
                </scope>
            </method>
            <method name="handleWindowFocusInSync" type="void" line="613">
                <params>
                    <param name="serial" type="long"/>
                </params>
                <declaration name="we" type="WindowEvent" line="614"/>
            </method>
            <method name="handleWindowFocusIn" type="void" line="620">
                <params>
                    <param name="serial" type="long"/>
                </params>
                <comment line="623">
                                        
                </comment>
                <declaration name="we" type="WindowEvent" line="621"/>
            </method>
            <method name="handleWindowFocusOut" type="void" line="629">
                <params>
                    <param name="oppositeWindow" type="Window"/>
                    <param name="serial" type="long"/>
                </params>
                <comment line="634">
                                        
                </comment>
                <declaration name="we" type="WindowEvent" line="630"/>
            </method>
            <method name="handleWindowFocusOutSync" type="void" line="636">
                <params>
                    <param name="oppositeWindow" type="Window"/>
                    <param name="serial" type="long"/>
                </params>
                <declaration name="we" type="WindowEvent" line="637"/>
            </method>
            <method name="checkIfOnNewScreen" type="void" line="649">
                <params>
                    <param name="newBounds" type="Rectangle"/>
                </params>
                <comment line="679">
                    Completely on this screen - done!                    
                </comment>
                <scope line="650"/>
                <scope line="654"/>
                <declaration name="area" type="int" line="658"/>
                <declaration name="intAmt" type="int" line="659"/>
                <declaration name="largestAmt" type="int" line="660"/>
                <declaration name="curScreenNum" type="int" line="661"/>
                <declaration name="newScreenNum" type="int" line="662"/>
                <declaration name="gds" type="GraphicsDevice" line="663"/>
                <declaration name="newGC" type="GraphicsConfiguration" line="664"/>
                <declaration name="screenBounds" type="Rectangle" line="665"/>
                <scope line="667">
                    <scope line="669">
                        <scope line="677"/>
                        <scope line="683"/>
                    </scope>
                </scope>
                <scope line="690">
                    <scope line="691"/>
                </scope>
            </method>
            <javadoc line="698">
                Helper method that executes the displayChanged(screen) method on
                  the event dispatch thread.  This method is used in the Xinerama case
                  and after display mode change events.                
            </javadoc>
            <method name="executeDisplayChangedOnEDT" type="void" line="703">
                <params>
                    <param name="gc" type="GraphicsConfiguration"/>
                </params>
                <anonymous_class line="704">
                    <method name="run" type="void" line="705"/>
                </anonymous_class>
                <declaration name="dc" type="Runnable" line="704"/>
            </method>
            <javadoc line="713">
                From the DisplayChangedListener interface; called from
                  X11GraphicsDevice when the display mode has been changed.                
            </javadoc>
            <method name="displayChanged" type="void" line="717"/>
            <javadoc line="721">
                From the DisplayChangedListener interface; top-levels do not need
                  to react to this event.                
            </javadoc>
            <method name="paletteChanged" type="void" line="725"/>
            <method name="handleConfigureNotifyEvent" type="void" line="733">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="735">
                    TODO: We create an XConfigureEvent every time we override
                     handleConfigureNotify() - too many!                    
                </comment>
                <comment line="743">
                    Don&apos;t call super until we&apos;ve handled a screen change.  Otherwise
                     there could be a race condition in which a ComponentListener could
                     see the old screen.                    
                </comment>
                <declaration name="xe" type="XConfigureEvent" line="736"/>
            </method>
            <method name="requestXFocus" type="void" line="749">
                <params>
                    <param name="time" type="long"/>
                </params>
            </method>
            <method name="requestXFocus" type="void" line="753"/>
            <javadoc line="757">
                Requests focus to this top-level. Descendants should override to provide
                  implementations based on a class of top-level.                
            </javadoc>
            <method name="requestXFocus" type="void" line="761">
                <params>
                    <param name="time" type="long"/>
                    <param name="timeProvided" type="boolean"/>
                </params>
                <comment line="763">
                    Since in XAWT focus is synthetic and all basic Windows are
                     override_redirect all we can do is check whether our parent
                     is active. If it is - we can freely synthesize focus transfer.
                     Luckily, this logic is already implemented in requestWindowFocus.                    
                </comment>
            </method>
            <method name="focusAllowedFor" type="boolean" line="770">
                <comment line="775">
                    Window target = (Window)this.target;
                    if (!target.isVisible() ||
                    !target.isEnabled() ||
                    !target.isFocusable())
                    {
                    return false;
                    }                    
                </comment>
                <scope line="771"/>
                <scope line="783"/>
            </method>
            <method name="handleFocusEvent" type="void" line="789">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="799">
                    If this window is non-focusable don&apos;t post any java focus event                    
                </comment>
                <comment line="801">
                    Normal notify                    
                </comment>
                <comment line="802">
                    Alt-Tab notify                    
                </comment>
                <comment line="810">
                    Normal notify                    
                </comment>
                <comment line="811">
                    Alt-Tab notify                    
                </comment>
                <comment line="813">
                    If this window is non-focusable don&apos;t post any java focus event                    
                </comment>
                <comment line="821">
                    Check if opposite window is non-focusable. In that case we don&apos;t want to
                     post any event.                    
                </comment>
                <declaration name="xfe" type="XFocusChangeEvent" line="790"/>
                <declaration name="fe" type="FocusEvent" line="791"/>
                <scope line="793"/>
                <scope line="797">
                    <scope line="799">
                        <scope line="802"/>
                    </scope>
                </scope>
                <scope line="808">
                    <scope line="811">
                        <scope line="813">
                            <declaration name="oppositeXWindow" type="XWindowPeer" line="814"/>
                            <declaration name="oppositeTarget" type="Object" line="815"/>
                            <declaration name="oppositeWindow" type="Window" line="816"/>
                            <scope line="817"/>
                            <scope line="822"/>
                            <scope line="825"/>
                            <scope line="827">
                                <scope line="828">
                                    <scope line="834"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
            </method>
            <method name="setSaveUnder" type="void" line="845">
                <params>
                    <param name="state" type="boolean"/>
                </params>
            </method>
            <method name="toFront" type="void" line="847">
                <scope line="848"/>
                <scope line="852">
                    <scope line="856"/>
                </scope>
                <scope line="859"/>
            </method>
            <method name="toBack" type="void" line="864">
                <scope line="866">
                    <scope line="867"/>
                    <scope line="869"/>
                </scope>
                <scope line="873"/>
            </method>
            <method name="lowerOverrideRedirect" type="void" line="877">
                <comment line="879">
                    make new hash of toplevels of all windows from &apos;windows&apos; hash.
                     FIXME: do not call them &quot;toplevel&quot; as it is misleading.                    
                </comment>
                <comment line="895">
                    find in the root&apos;s tree:
                     (1) my toplevel, (2) lowest java toplevel, (3) desktop
                     We must enforce (3), (1), (2) order, upward;
                     note that nautilus on the next restacking will do (1),(3),(2).                    
                </comment>
                <comment line="914">
                    we need topmost desktop of them all.                    
                </comment>
                <comment line="927">
                    no action necessary                    
                </comment>
                <comment line="938">
                    add root window property listener:
                     somebody (eg nautilus desktop) may obscure us                    
                </comment>
                <declaration name="toplevels" type="HashSet" line="882"/>
                <declaration name="topl" type="long" line="883"/>
                <scope line="885">
                    <scope line="887"/>
                </scope>
                <declaration name="laux" type="long" line="900"/>
                <declaration name="iMy" type="int" line="901"/>
                <declaration name="i" type="int" line="902"/>
                <declaration name="xqt" type="XQueryTree" line="903"/>
                <scope line="904">
                    <scope line="905">
                        <declaration name="nchildren" type="int" line="906"/>
                        <declaration name="children" type="long" line="907"/>
                        <scope line="908">
                            <scope line="910"/>
                            <scope line="912"/>
                            <scope line="918"/>
                        </scope>
                    </scope>
                    <declaration name="to_restack" type="long" line="928"/>
                    <scope line="935"/>
                </scope>
                <scope line="941"/>
            </method>
            <javadoc line="945">
                Get XID of closest to root window in a given window hierarchy.
                  FIXME: do not call it &quot;toplevel&quot; as it is misleading.
                  On error return 0.                
            </javadoc>
            <method name="getToplevelWindow" type="long" line="950">
                <params>
                    <param name="w" type="long"/>
                </params>
                <declaration name="wi" type="long" line="951"/>
                <scope line="952">
                    <declaration name="qt" type="XQueryTree" line="954"/>
                    <scope line="955">
                        <scope line="956"/>
                    </scope>
                    <scope line="961"/>
                </scope>
            </method>
            <method name="isDesktopWindow" type="boolean" line="970">
                <params>
                    <param name="wi" type="long"/>
                </params>
            </method>
            <method name="updateAlwaysOnTop" type="void" line="974"/>
            <method name="setAlwaysOnTop" type="void" line="982">
                <params>
                    <param name="alwaysOnTop" type="boolean"/>
                </params>
            </method>
            <method name="isLocationByPlatform" type="boolean" line="987"/>
            <method name="promoteDefaultPosition" type="void" line="991">
                <scope line="993">
                    <scope line="995">
                        <declaration name="bounds" type="Rectangle" line="996"/>
                        <declaration name="hints" type="XSizeHints" line="997"/>
                    </scope>
                    <scope line="1000"/>
                </scope>
            </method>
            <method name="setVisible" type="void" line="1006">
                <params>
                    <param name="vis" type="boolean"/>
                </params>
                <comment line="1012">
                    It&apos;s easier and safer to temporary suppress WM_TAKE_FOCUS
                     protocol itself than to ignore WM_TAKE_FOCUS client message.
                     Because we will have to make the difference between
                     the message come after showing and the message come after
                     activation. Also, on Metacity, for some reason, we have _two_
                     WM_TAKE_FOCUS client messages when showing a framedialog.                    
                </comment>
                <comment line="1030">
                    ICCCM, 4.1.4. Changing Window State:
                     &quot;Iconic -&gt; Withdrawn - The client should unmap the window and follow it
                     with a synthetic UnmapNotify event as described later in this section.&quot;
                     The same is true for Normal -&gt; Withdrawn                    
                </comment>
                <comment line="1050">
                    method called somewhere in parent does not generate configure-notify
                     event for override-redirect.
                     Ergo, no reshape and bugs like 5085647 in case setBounds was
                     called before setVisible.                    
                </comment>
                <scope line="1007">
                    <scope line="1010"/>
                </scope>
                <scope line="1024"/>
                <scope line="1028">
                    <scope line="1034">
                        <declaration name="unmap" type="XUnmapEvent" line="1035"/>
                    </scope>
                    <scope line="1045"/>
                </scope>
                <scope line="1053"/>
            </method>
            <method name="suppressWmTakeFocus" type="void" line="1059">
                <params>
                    <param name="doSuppress" type="boolean"/>
                </params>
            </method>
            <method name="isSimpleWindow" type="boolean" line="1062"/>
            <method name="hasWarningWindow" type="boolean" line="1065"/>
            <method name="getMenuBarHeight" type="int" line="1070"/>
            <method name="updateChildrenSizes" type="void" line="1076"/>
            <method name="repositionSecurityWarning" type="void" line="1079">
                <comment line="1081">
                    NOTE: On KWin if the window/border snapping option is enabled,
                     the Java window may be swinging while it&apos;s being moved.
                     This doesn&apos;t make the application unusable though looks quite ugly.
                     Probobly we need to find some hint to assign to our Security
                     Warning window in order to exclude it from the snapping option.
                     We are not currently aware of existance of such a property.                    
                </comment>
                <comment line="1088">
                    We can&apos;t use the coordinates stored in the XBaseWindow since
                     they are zeros for decorated frames.                    
                </comment>
                <scope line="1086">
                    <declaration name="compAccessor" type="AWTAccessor.ComponentAccessor" line="1089"/>
                    <declaration name="x" type="int" line="1090"/>
                    <declaration name="y" type="int" line="1091"/>
                    <declaration name="width" type="int" line="1092"/>
                    <declaration name="height" type="int" line="1093"/>
                </scope>
            </method>
            <method name="setMouseAbove" type="void" line="1099">
                <params>
                    <param name="above" type="boolean"/>
                </params>
            </method>
            <method name="setFullScreenExclusiveModeState" type="void" line="1105">
                <params>
                    <param name="state" type="boolean"/>
                </params>
            </method>
            <method name="updateSecurityWarningVisibility" type="void" line="1110">
                <comment line="1117">
                    The warning window should already be hidden.                    
                </comment>
                <comment line="1125">
                    getWMState() always returns 0 (Withdrawn) for simple windows. Hence
                     we ignore the state for such windows.                    
                </comment>
                <scope line="1111"/>
                <scope line="1115"/>
                <declaration name="show" type="boolean" line="1119"/>
                <scope line="1121">
                    <declaration name="state" type="int" line="1122"/>
                    <scope line="1126">
                        <scope line="1129"/>
                        <scope line="1134"/>
                    </scope>
                </scope>
            </method>
            <method name="isOverrideRedirect" type="boolean" line="1143"/>
            <method name="isOLWMDecorBug" type="boolean" line="1148"/>
            <method name="dispose" type="void" line="1153">
                <comment line="1168">
                    Fix for 6457980.
                     When disposing an owned Window we should implicitly
                     return focus to its decorated owner because it won&apos;t
                     receive WM_TAKE_FOCUS.                    
                </comment>
                <scope line="1155"/>
                <scope line="1157"/>
                <scope line="1160"/>
                <scope line="1173">
                    <scope line="1174">
                        <declaration name="owner" type="Window" line="1175"/>
                    </scope>
                </scope>
            </method>
            <method name="isResizable" type="boolean" line="1180"/>
            <method name="handleVisibilityEvent" type="void" line="1184">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="1189">
                    if (ve.get_state() == XlibWrapper.VisibilityUnobscured) {
                                  raiseInputMethodWindow
                             }                    
                </comment>
                <declaration name="ve" type="XVisibilityEvent" line="1186"/>
            </method>
            <method name="handleRootPropertyNotify" type="void" line="1194">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="1199">
                    Restore stack order unhadled/spoiled by WM or some app (nautilus).
                     As of now, don&apos;t use any generic machinery: just
                     do toBack() again.                    
                </comment>
                <declaration name="ev" type="XPropertyEvent" line="1195"/>
                <scope line="1197">
                    <scope line="1201"/>
                </scope>
            </method>
            <method name="removeStartupNotification" type="void" line="1207">
                <scope line="1208"/>
                <anonymous_class line="1212">
                    <method name="run" type="String" line="1213"/>
                </anonymous_class>
                <declaration name="desktopStartupId" type="String" line="1212"/>
                <scope line="1217"/>
                <declaration name="messageBuilder" type="StringBuilder" line="1221"/>
                <scope line="1223">
                    <scope line="1224"/>
                </scope>
                <declaration name="message" type="byte[]" line="1231"/>
                <scope line="1232"/>
                <scope line="1234"/>
                <declaration name="req" type="XClientMessageEvent" line="1238"/>
                <scope line="1241">
                    <declaration name="netStartupInfoBeginAtom" type="XAtom" line="1242"/>
                    <declaration name="netStartupInfoAtom" type="XAtom" line="1243"/>
                    <scope line="1251">
                        <declaration name="msglen" type="int" line="1252"/>
                        <declaration name="i" type="int" line="1253"/>
                        <scope line="1254"/>
                        <scope line="1257"/>
                    </scope>
                </scope>
                <scope line="1267">
                    <scope line="1269"/>
                </scope>
            </method>
            <method name="handleMapNotifyEvent" type="void" line="1275">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="1279">
                    See 6480534.                    
                </comment>
                <comment line="1284">
                    restore the protocol.                    
                </comment>
                <comment line="1285">
                    For some reason, on Metacity, a framedialog being shown
                     without WM_TAKE_FOCUS protocol doesn&apos;t get moved to the front.
                     So, we do it evidently.                    
                </comment>
                <scope line="1282">
                    <scope line="1290"/>
                    <scope line="1292"/>
                </scope>
                <scope line="1296"/>
                <scope line="1304">
                    <scope line="1305"/>
                </scope>
            </method>
            <method name="handleUnmapNotifyEvent" type="void" line="1311">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="1315">
                    On Metacity UnmapNotify comes before PropertyNotify (for _NET_WM_STATE_HIDDEN).
                     So we also check for the property later in MapNotify. See 6480534.                    
                </comment>
                <scope line="1318">
                    <scope line="1319"/>
                </scope>
            </method>
            <method name="shouldFocusOnMapNotify" type="boolean" line="1325">
                <comment line="1330">
                    Window.autoRequestFocus                    
                </comment>
                <comment line="1333">
                    Unhiding                    
                </comment>
                <comment line="1336">
                    General focusability                    
                </comment>
                <comment line="1337">
                    Modality                    
                </comment>
                <declaration name="res" type="boolean" line="1326"/>
                <scope line="1328"/>
                <scope line="1331"/>
            </method>
            <method name="isWMStateNetHidden" type="boolean" line="1341">
                <declaration name="protocol" type="XNETProtocol" line="1342"/>
            </method>
            <method name="requestInitialFocus" type="void" line="1346"/>
            <method name="addToplevelStateListener" type="void" line="1350">
                <params>
                    <param name="l" type="ToplevelStateListener"/>
                </params>
            </method>
            <method name="removeToplevelStateListener" type="void" line="1354">
                <params>
                    <param name="l" type="ToplevelStateListener"/>
                </params>
            </method>
            <javadoc line="1358">
                Override this methods to get notifications when top-level window state changes. The state is
                  meant in terms of ICCCM: WithdrawnState, IconicState, NormalState                
            </javadoc>
            <method name="stateChanged" type="void" line="1363">
                <params>
                    <param name="time" type="long"/>
                    <param name="oldState" type="int"/>
                    <param name="newState" type="int"/>
                </params>
                <comment line="1365">
                    Fix for 6401700, 6412803
                     If this window is modal blocked, it is put into the transient_for
                     chain using prevTransientFor and nextTransientFor hints. However,
                     the real WM_TRANSIENT_FOR hint shouldn&apos;t be set for windows in
                     different WM states (except for owner-window relationship), so
                     if the window changes its state, its real WM_TRANSIENT_FOR hint
                     should be updated accordingly.                    
                </comment>
                <scope line="1373"/>
            </method>
            <method name="isWithdrawn" type="boolean" line="1380"/>
            <method name="hasDecorations" type="boolean" line="1384">
                <params>
                    <param name="decor" type="int"/>
                </params>
                <scope line="1385"/>
                <scope line="1388">
                    <declaration name="myDecor" type="int" line="1389"/>
                    <declaration name="hasBits" type="boolean" line="1390"/>
                </scope>
            </method>
            <method name="setReparented" type="void" line="1398">
                <params>
                    <param name="newValue" type="boolean"/>
                </params>
                <scope line="1401">
                    <scope line="1402"/>
                </scope>
                <scope line="1406"/>
            </method>
            <method name="collectJavaToplevels" type="Vector<XWindowPeer>" line="1415">
                <comment line="1439">
                    XQueryTree returns window children ordered by z-order                    
                </comment>
                <comment line="1443">
                    filter out Java non-toplevels                    
                </comment>
                <comment line="1452">
                    XQueryTree returns windows sorted by their z-order. However,
                     if WM has not handled transient for hint for a child window,
                     it may appear in javaToplevels before its owner. Move such
                     children after their owners.                    
                </comment>
                <declaration name="javaToplevels" type="Vector&lt;XWindowPeer&gt;" line="1416"/>
                <declaration name="v" type="Vector&lt;Long&gt;" line="1417"/>
                <declaration name="ge" type="X11GraphicsEnvironment" line="1418"/>
                <declaration name="gds" type="GraphicsDevice[]" line="1420"/>
                <scope line="1421">
                    <scope line="1422">
                        <declaration name="screen" type="int" line="1423"/>
                        <declaration name="rootWindow" type="long" line="1424"/>
                    </scope>
                </scope>
                <scope line="1427"/>
                <declaration name="windowsCount" type="int" line="1430"/>
                <scope line="1431">
                    <declaration name="win" type="long" line="1432"/>
                    <declaration name="qt" type="XQueryTree" line="1433"/>
                    <scope line="1434">
                        <scope line="1435">
                            <declaration name="nchildren" type="int" line="1436"/>
                            <declaration name="children" type="long" line="1437"/>
                            <scope line="1439">
                                <declaration name="child" type="long" line="1440"/>
                                <declaration name="childWindow" type="XBaseWindow" line="1441"/>
                                <scope line="1443"/>
                                <scope line="1445"/>
                                <scope line="1448">
                                    <declaration name="np" type="XWindowPeer" line="1449"/>
                                    <declaration name="k" type="int" line="1455"/>
                                    <declaration name="toCheck" type="XWindowPeer" line="1456"/>
                                    <scope line="1457">
                                        <declaration name="toCheckOwnerPeer" type="XWindowPeer" line="1458"/>
                                        <scope line="1459"/>
                                        <scope line="1462"/>
                                    </scope>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="1470"/>
                </scope>
            </method>
            <method name="setModalBlocked" type="void" line="1477">
                <params>
                    <param name="d" type="Dialog"/>
                    <param name="blocked" type="boolean"/>
                </params>
            </method>
            <method name="setModalBlocked" type="void" line="1482">
                <params>
                    <param name="d" type="Dialog"/>
                    <param name="blocked" type="boolean"/>
                    <param name="javaToplevels" type="Vector<XWindowPeer>"/>
                </params>
                <comment line="1486">
                    State lock should always be after awtLock                    
                </comment>
                <scope line="1484">
                    <scope line="1486">
                        <declaration name="blockerPeer" type="XDialogPeer" line="1487"/>
                        <scope line="1488">
                            <scope line="1492"/>
                            <scope line="1494"/>
                        </scope>
                        <scope line="1497">
                            <scope line="1498"/>
                            <scope line="1503"/>
                            <scope line="1505"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="1512"/>
            </method>
            <method name="setToplevelTransientFor" type="void" line="1535">
                <params>
                    <param name="window" type="XWindowPeer"/>
                    <param name="transientForWindow" type="XWindowPeer"/>
                    <param name="updateChain" type="boolean"/>
                    <param name="allStates" type="boolean"/>
                </params>
                <scope line="1536"/>
                <scope line="1539"/>
                <scope line="1543"/>
                <scope line="1546"/>
                <scope line="1549"/>
                <declaration name="bpw" type="long" line="1552"/>
                <scope line="1553"/>
                <declaration name="tpw" type="long" line="1556"/>
                <scope line="1557"/>
            </method>
            <method name="updateTransientFor" type="void" line="1572">
                <declaration name="state" type="int" line="1573"/>
                <declaration name="p" type="XWindowPeer" line="1574"/>
                <scope line="1575"/>
                <scope line="1578"/>
                <scope line="1580"/>
                <declaration name="n" type="XWindowPeer" line="1583"/>
                <scope line="1584"/>
                <scope line="1587"/>
            </method>
            <method name="removeTransientForHint" type="void" line="1600">
                <params>
                    <param name="window" type="XWindowPeer"/>
                </params>
                <declaration name="XA_WM_TRANSIENT_FOR" type="XAtom" line="1601"/>
                <declaration name="bpw" type="long" line="1602"/>
                <scope line="1603"/>
            </method>
            <method name="addToTransientFors" type="void" line="1650">
                <params>
                    <param name="blockerPeer" type="XDialogPeer"/>
                </params>
            </method>
            <method name="addToTransientFors" type="void" line="1655">
                <params>
                    <param name="blockerPeer" type="XDialogPeer"/>
                    <param name="javaToplevels" type="Vector<XWindowPeer>"/>
                </params>
                <comment line="1657">
                    blockerPeer chain iterator                    
                </comment>
                <comment line="1662">
                    this window chain iterator
                     each window can be blocked no more than once, so this window
                       is on top of its chain                    
                </comment>
                <comment line="1669">
                    if there are no windows blocked by modalBlocker, simply add this window
                      and its chain to blocker&apos;s chain                    
                </comment>
                <comment line="1674">
                    Collect all the Java top-levels, if required                    
                </comment>
                <comment line="1678">
                    merged chain tail                    
                </comment>
                <declaration name="blockerChain" type="XWindowPeer" line="1657"/>
                <scope line="1658"/>
                <declaration name="thisChain" type="XWindowPeer" line="1664"/>
                <scope line="1665"/>
                <scope line="1670"/>
                <scope line="1672">
                    <scope line="1674"/>
                    <declaration name="mergedChain" type="XWindowPeer" line="1678"/>
                    <scope line="1679">
                        <declaration name="prevMergedChain" type="XWindowPeer" line="1680"/>
                        <scope line="1681">
                            <scope line="1682">
                                <scope line="1683"/>
                            </scope>
                            <scope line="1688"/>
                        </scope>
                        <scope line="1692"/>
                        <scope line="1695"/>
                        <scope line="1698"/>
                        <scope line="1700"/>
                        <scope line="1704"/>
                    </scope>
                </scope>
            </method>
            <method name="restoreTransientFor" type="void" line="1715">
                <params>
                    <param name="window" type="XWindowPeer"/>
                </params>
                <declaration name="ownerPeer" type="XWindowPeer" line="1716"/>
                <scope line="1717"/>
                <scope line="1719"/>
            </method>
            <method name="removeFromTransientFors" type="void" line="1754">
                <comment line="1756">
                    the head of the chain of this window                    
                </comment>
                <comment line="1758">
                    the head of the current chain
                     nextTransientFor is always not null as this window is in the chain                    
                </comment>
                <comment line="1761">
                    the set of blockers in this chain: if this dialog blocks some other
                     modal dialogs, their blocked windows should stay in this dialog&apos;s chain                    
                </comment>
                <comment line="1765">
                    current chain iterator in the order from next to prev                    
                </comment>
                <comment line="1770">
                    add to this dialog&apos;s chain                    
                </comment>
                <comment line="1775">
                    leave in the current chain                    
                </comment>
                <declaration name="thisChain" type="XWindowPeer" line="1756"/>
                <declaration name="otherChain" type="XWindowPeer" line="1759"/>
                <declaration name="thisChainBlockers" type="Set&lt;XWindowPeer&gt;" line="1762"/>
                <declaration name="chainToSplit" type="XWindowPeer" line="1765"/>
                <scope line="1766">
                    <declaration name="blocker" type="XWindowPeer" line="1767"/>
                    <scope line="1768"/>
                    <scope line="1773"/>
                </scope>
            </method>
            <method name="isModalBlocked" type="boolean" line="1789"/>
            <method name="getDecoratedOwner" type="Window" line="1793">
                <params>
                    <param name="window" type="Window"/>
                </params>
                <scope line="1794"/>
            </method>
            <method name="requestWindowFocus" type="boolean" line="1800">
                <params>
                    <param name="actualFocusedWindow" type="XWindowPeer"/>
                </params>
            </method>
            <method name="requestWindowFocus" type="boolean" line="1805"/>
            <method name="requestWindowFocus" type="boolean" line="1809">
                <params>
                    <param name="time" type="long"/>
                    <param name="timeProvided" type="boolean"/>
                </params>
                <comment line="1812">
                    If this is Frame or Dialog we can&apos;t assure focus request success - but we still can try
                     If this is Window and its owner Frame is active we can be sure request succedded.                    
                </comment>
                <declaration name="ownerWindow" type="Window" line="1813"/>
                <declaration name="focusedWindow" type="Window" line="1814"/>
                <declaration name="activeWindow" type="Window" line="1815"/>
                <scope line="1817"/>
                <scope line="1821"/>
                <declaration name="wpeer" type="XDecoratedPeer" line="1828"/>
                <scope line="1829"/>
            </method>
            <method name="setActualFocusedWindow" type="void" line="1838">
                <params>
                    <param name="actualFocusedWindow" type="XWindowPeer"/>
                </params>
            </method>
            <javadoc line="1841">
                Applies the current window type.                
            </javadoc>
            <method name="applyWindowType" type="void" line="1844">
                <declaration name="protocol" type="XNETProtocol" line="1845"/>
                <scope line="1846"/>
                <declaration name="typeAtom" type="XAtom" line="1850"/>
                <scope line="1865">
                    <declaration name="wtype" type="XAtomList" line="1866"/>
                </scope>
                <scope line="1870"/>
            </method>
            <method name="xSetVisible" type="void" line="1877">
                <params>
                    <param name="visible" type="boolean"/>
                </params>
                <scope line="1880">
                    <scope line="1882"/>
                    <scope line="1885"/>
                </scope>
                <scope line="1890"/>
            </method>
            <declaration name="dropTargetCount" type="int" line="1896"/>
            <method name="addDropTarget" type="void" line="1898">
                <scope line="1900">
                    <scope line="1901">
                        <declaration name="window" type="long" line="1902"/>
                        <scope line="1903"/>
                    </scope>
                </scope>
                <scope line="1908"/>
            </method>
            <method name="removeDropTarget" type="void" line="1913">
                <scope line="1915">
                    <scope line="1917">
                        <declaration name="window" type="long" line="1918"/>
                        <scope line="1919"/>
                    </scope>
                </scope>
                <scope line="1923"/>
            </method>
            <method name="addRootPropertyEventDispatcher" type="void" line="1927">
                <scope line="1928">
                    <anonymous_class line="1929">
                        <method name="dispatchEvent" type="void" line="1930">
                            <params>
                                <param name="ev" type="XEvent"/>
                            </params>
                            <scope line="1931"/>
                        </method>
                    </anonymous_class>
                </scope>
            </method>
            <method name="removeRootPropertyEventDispatcher" type="void" line="1943">
                <scope line="1944"/>
            </method>
            <method name="updateFocusableWindowState" type="void" line="1950"/>
            <declaration name="XA_NET_WM_STATE" type="XAtom" line="1954"/>
            <declaration name="net_wm_state" type="XAtomList" line="1955"/>
            <method name="getNETWMState" type="XAtomList" line="1956">
                <scope line="1957"/>
            </method>
            <method name="setNETWMState" type="void" line="1963">
                <params>
                    <param name="state" type="XAtomList"/>
                </params>
                <scope line="1965"/>
            </method>
            <method name="getMWMHints" type="PropMwmHints" line="1970">
                <scope line="1971">
                    <scope line="1973"/>
                </scope>
            </method>
            <method name="setMWMHints" type="void" line="1980">
                <params>
                    <param name="hints" type="PropMwmHints"/>
                </params>
                <scope line="1982"/>
            </method>
            <method name="updateDropTarget" type="void" line="1987">
                <scope line="1989">
                    <scope line="1990">
                        <declaration name="window" type="long" line="1991"/>
                        <scope line="1992"/>
                    </scope>
                </scope>
                <scope line="1997"/>
            </method>
            <method name="setGrab" type="void" line="2002">
                <params>
                    <param name="grab" type="boolean"/>
                </params>
                <scope line="2004"/>
                <scope line="2007"/>
            </method>
            <method name="isGrabbed" type="boolean" line="2012"/>
            <method name="handleXCrossingEvent" type="void" line="2016">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="2024">
                    When window is grabbed, all events are dispatched to
                     it.  Retarget them to the corresponding windows (notice
                     that XBaseWindow.dispatchEvent does the opposite
                     translation)
                     Note that we need to retarget XCrossingEvents to content window
                     since it generates MOUSE_ENTERED/MOUSE_EXITED for frame and dialog.
                     (fix for 6390326)                    
                </comment>
                <declaration name="xce" type="XCrossingEvent" line="2017"/>
                <scope line="2018"/>
                <scope line="2022">
                    <declaration name="target" type="XBaseWindow" line="2030"/>
                    <scope line="2032"/>
                </scope>
            </method>
            <method name="handleMotionNotify" type="void" line="2040">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="2052">
                    here is the bug in WM: extra buttons doesn&apos;t have state!=0 as they should.                    
                </comment>
                <comment line="2057">
                    When window is grabbed, all events are dispatched to
                     it.  Retarget them to the corresponding windows (notice
                     that XBaseWindow.dispatchEvent does the opposite
                     translation)                    
                </comment>
                <comment line="2063">
                    for some reasons if we grab input MotionNotify for drag is reported with target
                     to underlying window, not to window on which we have initiated drag
                     so we need to retarget them.  Here I use simplified logic which retarget all
                     such events to source of mouse press (or the grabber).  It helps with fix for 6390326.
                     So, I do not want to implement complicated logic for better retargeting.                    
                </comment>
                <comment line="2082">
                    note that we need to pass dragging events to the grabber (6390326)
                     see comment above for more inforamtion.                    
                </comment>
                <comment line="2085">
                    Outside of Java                    
                </comment>
                <declaration name="xme" type="XMotionEvent" line="2041"/>
                <scope line="2042"/>
                <scope line="2046">
                    <declaration name="dragging" type="boolean" line="2047"/>
                    <declaration name="buttonsNumber" type="int" line="2048"/>
                    <scope line="2050">
                        <scope line="2052"/>
                    </scope>
                    <declaration name="target" type="XBaseWindow" line="2060"/>
                    <scope line="2061">
                        <declaration name="localCoord" type="Point" line="2069"/>
                    </scope>
                    <scope line="2074">
                        <scope line="2075"/>
                    </scope>
                    <scope line="2083"/>
                </scope>
            </method>
            <declaration name="pressTarget" type="XBaseWindow" line="2092"/>
            <method name="handleButtonPressRelease" type="void" line="2094">
                <params>
                    <param name="xev" type="XEvent"/>
                </params>
                <comment line="2098">
                    Ignore the buttons above 20 due to the bit limit for
                     InputEvent.BUTTON_DOWN_MASK.
                     One more bit is reserved for FIRST_HIGH_BIT.                    
                </comment>
                <comment line="2111">
                    When window is grabbed, all events are dispatched to
                     it.  Retarget them to the corresponding windows (notice
                     that XBaseWindow.dispatchEvent does the opposite
                     translation)                    
                </comment>
                <comment line="2121">
                    need to keep it to retarget mouse release                    
                </comment>
                <comment line="2127">
                    during grab we do receive mouse release on different component (not on the source
                     of mouse press).  So we need to retarget it.
                     see 6390326 for more information.                    
                </comment>
                <comment line="2143">
                    Target is either us or our content window -
                     check that event is inside.  &apos;Us&apos; in case of
                     shell will mean that this will also filter out press on title                    
                </comment>
                <comment line="2147">
                    Outside this toplevel hierarchy
                     According to the specification of UngrabEvent, post it
                     when press occurs outside of the window and not on its owned windows                    
                </comment>
                <comment line="2156">
                    First, get the toplevel                    
                </comment>
                <comment line="2167">
                    toplevel == null - outside of
                     hierarchy, toplevel is Dialog - should
                     send ungrab (but shouldn&apos;t for Window)                    
                </comment>
                <comment line="2174">
                    toplevel is null - outside of hierarchy                    
                </comment>
                <comment line="2180">
                    target doesn&apos;t map to XAWT window - outside of hierarchy                    
                </comment>
                <declaration name="xbe" type="XButtonEvent" line="2095"/>
                <scope line="2102"/>
                <scope line="2105"/>
                <scope line="2109">
                    <declaration name="target" type="XBaseWindow" line="2114"/>
                    <scope line="2115">
                        <scope line="2119"/>
                        <scope line="2125">
                            <declaration name="localCoord" type="Point" line="2131"/>
                        </scope>
                        <scope line="2136"/>
                    </scope>
                    <scope line="2140">
                        <scope line="2141">
                            <scope line="2145">
                                <scope line="2149"/>
                            </scope>
                            <declaration name="toplevel" type="XWindowPeer" line="2156"/>
                            <scope line="2157">
                                <declaration name="w" type="Window" line="2158"/>
                                <scope line="2159">
                                    <scope line="2161"/>
                                </scope>
                                <scope line="2165"/>
                            </scope>
                            <scope line="2172"/>
                        </scope>
                        <scope line="2178"/>
                    </scope>
                </scope>
            </method>
            <method name="print" type="void" line="2189">
                <params>
                    <param name="g" type="Graphics"/>
                </params>
                <comment line="2191">
                    We assume we print the whole frame,
                     so we expect no clip was set previously                    
                </comment>
                <declaration name="shape" type="Shape" line="2192"/>
                <scope line="2193"/>
            </method>
            <method name="setOpacity" type="void" line="2200">
                <params>
                    <param name="opacity" type="float"/>
                </params>
                <declaration name="maxOpacity" type="long" line="2201"/>
                <declaration name="iOpacity" type="long" line="2202"/>
                <scope line="2203"/>
                <scope line="2206"/>
                <declaration name="netWmWindowOpacityAtom" type="XAtom" line="2210"/>
                <scope line="2212"/>
                <scope line="2214"/>
            </method>
            <method name="setOpaque" type="void" line="2220">
                <params>
                    <param name="isOpaque" type="boolean"/>
                </params>
                <comment line="2222">
                    no-op                    
                </comment>
            </method>
            <method name="updateWindow" type="void" line="2225">
                <comment line="2227">
                    no-op                    
                </comment>
            </method>
        </class>
    </source>