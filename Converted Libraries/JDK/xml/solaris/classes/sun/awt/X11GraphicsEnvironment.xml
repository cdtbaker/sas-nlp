<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt.GraphicsDevice"/>
        <import package="java.awt.Point"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.io.BufferedReader"/>
        <import package="java.io.File"/>
        <import package="java.io.FileReader"/>
        <import package="java.io.FileNotFoundException"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.StreamTokenizer"/>
        <import package="java.net.InetAddress"/>
        <import package="java.net.NetworkInterface"/>
        <import package="java.net.SocketException"/>
        <import package="java.net.UnknownHostException"/>
        <import package="java.util"/>
        <import package="sun.awt.motif.MFontConfiguration"/>
        <import package="sun.font.FcFontConfiguration"/>
        <import package="sun.font.Font2D"/>
        <import package="sun.font.FontManager"/>
        <import package="sun.font.NativeFont"/>
        <import package="sun.java2d.SunGraphicsEnvironment"/>
        <import package="sun.java2d.SurfaceManagerFactory"/>
        <import package="sun.java2d.UnixSurfaceManagerFactory"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.java2d.xr.XRSurfaceData"/>
        <class name="X11GraphicsEnvironment" line="27">
            <extends class="SunGraphicsEnvironment"/>
            <javadoc line="27">
                This is an implementation of a GraphicsEnvironment object for the
                  default local GraphicsEnvironment used by the Java Runtime Environment
                  for X11 environments.                
                <see>
                    GraphicsDevice                    
                </see>
                <see>
                    GraphicsConfiguration                    
                </see>
            </javadoc>
            <declaration name="log" type="PlatformLogger" line="35"/>
            <declaration name="screenLog" type="PlatformLogger" line="36"/>
            <declaration name="xinerState" type="Boolean" line="37"/>
            <scope line="38">
                <anonymous_class line="39">
                    <method name="run" type="Object" line="40">
                        <scope line="42">
                            <declaration name="glxRequested" type="boolean" line="43"/>
                            <declaration name="prop" type="String" line="44"/>
                            <scope line="45">
                                <scope line="46"/>
                                <scope line="49"/>
                            </scope>
                            <declaration name="xRenderRequested" type="boolean" line="54"/>
                            <declaration name="xProp" type="String" line="55"/>
                            <scope line="56">
                                <scope line="57"/>
                                <scope line="60"/>
                            </scope>
                            <scope line="66">
                                <scope line="68"/>
                            </scope>
                            <scope line="72">
                                <scope line="74"/>
                            </scope>
                            <scope line="78"/>
                        </scope>
                    </method>
                </anonymous_class>
            </scope>
            <declaration name="glxAvailable" type="boolean" line="88"/>
            <declaration name="glxVerbose" type="boolean" line="89"/>
            <method name="initGLX" type="boolean" line="90"/>
            <method name="isGLXAvailable" type="boolean" line="91"/>
            <method name="isGLXVerbose" type="boolean" line="94"/>
            <declaration name="xRenderVerbose" type="boolean" line="97"/>
            <declaration name="xRenderAvailable" type="boolean" line="98"/>
            <method name="initXRender" type="boolean" line="99"/>
            <method name="isXRenderAvailable" type="boolean" line="100"/>
            <method name="isXRenderVerbose" type="boolean" line="103"/>
            <method name="checkShmExt" type="int" line="106"/>
            <javadoc line="106">
                Checks if Shared Memory extension can be used.
                  Returns:
                  -1 if server doesn&apos;t support MITShm
                  1 if server supports it and it can be used
                  0 otherwise                
            </javadoc>
            <method name="getDisplayString" type="String" line="114"/>
            <declaration name="isDisplayLocal" type="Boolean" line="115"/>
            <method name="initDisplay" type="void" line="116"/>
            <javadoc line="116">
                This should only be called from the static initializer, so no need for
                  the synchronized keyword.                
            </javadoc>
            <method name="X11GraphicsEnvironment" type="constructor" line="121"/>
            <method name="getNumScreens" type="int" line="123"/>
            <method name="makeScreenDevice" type="GraphicsDevice" line="124">
                <params>
                    <param name="screennum" type="int"/>
                </params>
            </method>
            <method name="getDefaultScreenNum" type="int" line="127"/>
            <javadoc line="128">
                Returns the default screen graphics device.                
            </javadoc>
            <method name="getDefaultScreenDevice" type="GraphicsDevice" line="131"/>
            <method name="isDisplayLocal" type="boolean" line="134">
                <scope line="135">
                    <scope line="137">
                        <scope line="138"/>
                    </scope>
                    <scope line="142"/>
                </scope>
            </method>
            <method name="_isDisplayLocal" type="boolean" line="148">
                <scope line="149"/>
                <declaration name="isRemote" type="String" line="152"/>
                <scope line="153"/>
                <declaration name="shm" type="int" line="156"/>
                <scope line="157"/>
                <declaration name="display" type="String" line="160"/>
                <declaration name="ind" type="int" line="161"/>
                <declaration name="hostName" type="String" line="162"/>
                <scope line="163"/>
                <anonymous_class line="166">
                    <method name="run" type="Object" line="167">
                        <declaration name="remAddr" type="InetAddress" line="168"/>
                        <declaration name="locals" type="Enumeration" line="169"/>
                        <declaration name="interfaces" type="Enumeration" line="170"/>
                        <scope line="171">
                            <scope line="174"/>
                        </scope>
                        <scope line="178"/>
                        <scope line="182"/>
                        <scope line="186">
                            <scope line="188">
                                <scope line="189">
                                    <scope line="190"/>
                                </scope>
                            </scope>
                        </scope>
                    </method>
                </anonymous_class>
                <declaration name="result" type="Boolean" line="166"/>
            </method>
            <javadoc line="202">
                Returns face name for default font, or null if
                  no face names are used for CompositeFontDescriptors
                  for this platform.                
            </javadoc>
            <method name="getDefaultFontFaceName" type="String" line="207"/>
            <method name="pRunningXinerama" type="boolean" line="210"/>
            <method name="getXineramaCenterPoint" type="Point" line="211"/>
            <javadoc line="212">
                Override for Xinerama case: call new Solaris API for getting the correct
                  centering point from the windowing system.                
            </javadoc>
            <method name="getCenterPoint" type="Point" line="216">
                <scope line="217">
                    <declaration name="p" type="Point" line="218"/>
                    <scope line="219"/>
                </scope>
            </method>
            <javadoc line="225">
                Override for Xinerama case                
            </javadoc>
            <method name="getMaximumWindowBounds" type="Rectangle" line="228">
                <scope line="229"/>
                <scope line="232"/>
            </method>
            <method name="runningXinerama" type="boolean" line="236">
                <scope line="237">
                    <scope line="239"/>
                </scope>
            </method>
            <javadoc line="245">
                Return the bounds for a centered Window on a system running in Xinerama
                  mode.
                  Calculations are based on the assumption of a perfectly rectangular
                  display area (display edges line up with one another, and displays
                  have consistent width and/or height).
                  The bounds to return depend on the arrangement of displays and on where
                  Windows are to be centered.  There are two common situations:
                  1) The center point lies at the center of the combined area of all the
                  displays.  In this case, the combined area of all displays is
                  returned.
                  2) The center point lies at the center of a single display.  In this case
                  the user most likely wants centered Windows to be constrained to that
                  single display.  The boundaries of the one display are returned.
                  It is possible for the center point to be at both the center of the
                  entire display space AND at the center of a single monitor (a square of
                  9 monitors, for instance).  In this case, the entire display area is
                  returned.
                  Because the center point is arbitrarily settable by the user, it could
                  fit neither of the cases above.  The fallback case is to simply return
                  the combined area for all screens.                
            </javadoc>
            <method name="getXineramaWindowBounds" type="Rectangle" line="267">
                <declaration name="center" type="Point" line="268"/>
                <declaration name="unionRect" type="Rectangle" line="269"/>
                <declaration name="gds" type="GraphicsDevice[]" line="270"/>
                <declaration name="centerMonitorRect" type="Rectangle" line="271"/>
                <declaration name="i" type="int" line="272"/>
                <scope line="274">
                    <scope line="276"/>
                </scope>
                <scope line="281">
                    <scope line="282"/>
                </scope>
                <scope line="287">
                    <scope line="288"/>
                </scope>
                <scope line="293"/>
            </method>
            <javadoc line="298">
                From the DisplayChangedListener interface; devices do not need
                  to react to this event.                
            </javadoc>
            <method name="paletteChanged" type="void" line="302"/>
        </class>
    </source>