<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.awt">
        <import package="java.awt.GraphicsDevice"/>
        <import package="java.awt.Point"/>
        <import package="java.awt.Rectangle"/>
        <import package="java.io.BufferedReader"/>
        <import package="java.io.File"/>
        <import package="java.io.FileReader"/>
        <import package="java.io.FileNotFoundException"/>
        <import package="java.io.InputStream"/>
        <import package="java.io.IOException"/>
        <import package="java.io.StreamTokenizer"/>
        <import package="java.net.InetAddress"/>
        <import package="java.net.NetworkInterface"/>
        <import package="java.net.SocketException"/>
        <import package="java.net.UnknownHostException"/>
        <import package="java.util"/>
        <import package="sun.awt.motif.MFontConfiguration"/>
        <import package="sun.font.FcFontConfiguration"/>
        <import package="sun.font.Font2D"/>
        <import package="sun.font.FontManager"/>
        <import package="sun.font.NativeFont"/>
        <import package="sun.java2d.SunGraphicsEnvironment"/>
        <import package="sun.java2d.SurfaceManagerFactory"/>
        <import package="sun.java2d.UnixSurfaceManagerFactory"/>
        <import package="sun.util.logging.PlatformLogger"/>
        <import package="sun.java2d.xr.XRSurfaceData"/>
        <class name="X11GraphicsEnvironment" line="57">
            <extends class="SunGraphicsEnvironment"/>
            <javadoc line="57">
                This is an implementation of a GraphicsEnvironment object for the
                  default local GraphicsEnvironment used by the Java Runtime Environment
                  for X11 environments.                
                <see>
                    GraphicsDevice                    
                </see>
                <see>
                    GraphicsConfiguration                    
                </see>
            </javadoc>
            <declaration name="log" type="PlatformLogger" line="68"/>
            <declaration name="screenLog" type="PlatformLogger" line="69"/>
            <declaration name="xinerState" type="Boolean" line="71"/>
            <scope line="73">
                <anonymous_class line="75">
                    <method name="run" type="Object" line="76">
                        <comment line="79">
                            Note: The MToolkit object depends on the static initializer
                             of X11GraphicsEnvironment to initialize the connection to
                             the X11 server.                            
                        </comment>
                        <comment line="85">
                            first check the OGL system property                            
                        </comment>
                        <comment line="97">
                            Now check for XRender system property                            
                        </comment>
                        <comment line="109">
                            initialize the X11 display connection                            
                        </comment>
                        <comment line="112">
                            only attempt to initialize GLX if it was requested                            
                        </comment>
                        <comment line="122">
                            only attempt to initialize Xrender if it was requested                            
                        </comment>
                        <scope line="84">
                            <declaration name="glxRequested" type="boolean" line="86"/>
                            <declaration name="prop" type="String" line="87"/>
                            <scope line="88">
                                <scope line="89"/>
                                <scope line="91"/>
                            </scope>
                            <declaration name="xRenderRequested" type="boolean" line="98"/>
                            <declaration name="xProp" type="String" line="99"/>
                            <scope line="100">
                                <scope line="101"/>
                                <scope line="103"/>
                            </scope>
                            <scope line="113">
                                <scope line="115"/>
                            </scope>
                            <scope line="123">
                                <scope line="125"/>
                            </scope>
                            <scope line="131"/>
                        </scope>
                    </method>
                </anonymous_class>
            </scope>
            <declaration name="glxAvailable" type="boolean" line="146"/>
            <declaration name="glxVerbose" type="boolean" line="147"/>
            <method name="initGLX" type="boolean" line="149"/>
            <method name="isGLXAvailable" type="boolean" line="151"/>
            <method name="isGLXVerbose" type="boolean" line="155"/>
            <declaration name="xRenderVerbose" type="boolean" line="159"/>
            <declaration name="xRenderAvailable" type="boolean" line="160"/>
            <method name="initXRender" type="boolean" line="162"/>
            <method name="isXRenderAvailable" type="boolean" line="163"/>
            <method name="isXRenderVerbose" type="boolean" line="167"/>
            <method name="checkShmExt" type="int" line="171"/>
            <javadoc line="171">
                Checks if Shared Memory extension can be used.
                  Returns:
                  -1 if server doesn&apos;t support MITShm
                  1 if server supports it and it can be used
                  0 otherwise                
            </javadoc>
            <method name="getDisplayString" type="String" line="180"/>
            <declaration name="isDisplayLocal" type="Boolean" line="181"/>
            <method name="initDisplay" type="void" line="183"/>
            <javadoc line="183">
                This should only be called from the static initializer, so no need for
                  the synchronized keyword.                
            </javadoc>
            <method name="X11GraphicsEnvironment" type="constructor" line="189"/>
            <method name="getNumScreens" type="int" line="192"/>
            <method name="makeScreenDevice" type="GraphicsDevice" line="194">
                <params>
                    <param name="screennum" type="int"/>
                </params>
            </method>
            <method name="getDefaultScreenNum" type="int" line="198"/>
            <javadoc line="199">
                Returns the default screen graphics device.                
            </javadoc>
            <method name="getDefaultScreenDevice" type="GraphicsDevice" line="202"/>
            <method name="isDisplayLocal" type="boolean" line="206">
                <scope line="207">
                    <scope line="209">
                        <scope line="210"/>
                    </scope>
                    <scope line="213"/>
                </scope>
            </method>
            <method name="_isDisplayLocal" type="boolean" line="220">
                <comment line="236">
                    If XServer doesn&apos;t support ShMem extension,                    
                </comment>
                <comment line="237">
                    try the other way                    
                </comment>
                <comment line="243">
                    &apos;:0&apos; case                    
                </comment>
                <scope line="221"/>
                <declaration name="isRemote" type="String" line="225"/>
                <scope line="227"/>
                <declaration name="shm" type="int" line="231"/>
                <scope line="232"/>
                <declaration name="display" type="String" line="239"/>
                <declaration name="ind" type="int" line="240"/>
                <declaration name="hostName" type="String" line="241"/>
                <scope line="242"/>
                <anonymous_class line="248">
                    <method name="run" type="Object" line="249">
                        <declaration name="remAddr" type="InetAddress" line="250"/>
                        <declaration name="locals" type="Enumeration" line="251"/>
                        <declaration name="interfaces" type="Enumeration" line="252"/>
                        <scope line="253">
                            <scope line="256"/>
                        </scope>
                        <scope line="259"/>
                        <scope line="262"/>
                        <scope line="267">
                            <scope line="269">
                                <scope line="270">
                                    <scope line="271"/>
                                </scope>
                            </scope>
                        </scope>
                    </method>
                </anonymous_class>
                <declaration name="result" type="Boolean" line="247"/>
            </method>
            <javadoc line="284">
                Returns face name for default font, or null if
                  no face names are used for CompositeFontDescriptors
                  for this platform.                
            </javadoc>
            <method name="getDefaultFontFaceName" type="String" line="289"/>
            <method name="pRunningXinerama" type="boolean" line="294"/>
            <method name="getXineramaCenterPoint" type="Point" line="295"/>
            <javadoc line="297">
                Override for Xinerama case: call new Solaris API for getting the correct
                  centering point from the windowing system.                
            </javadoc>
            <method name="getCenterPoint" type="Point" line="301">
                <scope line="302">
                    <declaration name="p" type="Point" line="303"/>
                    <scope line="304"/>
                </scope>
            </method>
            <javadoc line="311">
                Override for Xinerama case                
            </javadoc>
            <method name="getMaximumWindowBounds" type="Rectangle" line="314">
                <scope line="315"/>
                <scope line="317"/>
            </method>
            <method name="runningXinerama" type="boolean" line="322">
                <comment line="324">
                    pRunningXinerama() simply returns a global boolean variable,                    
                </comment>
                <comment line="325">
                    so there is no need to synchronize here                    
                </comment>
                <scope line="323">
                    <scope line="327"/>
                </scope>
            </method>
            <javadoc line="334">
                Return the bounds for a centered Window on a system running in Xinerama
                  mode.
                  Calculations are based on the assumption of a perfectly rectangular
                  display area (display edges line up with one another, and displays
                  have consistent width and/or height).
                  The bounds to return depend on the arrangement of displays and on where
                  Windows are to be centered.  There are two common situations:
                  1) The center point lies at the center of the combined area of all the
                  displays.  In this case, the combined area of all displays is
                  returned.
                  2) The center point lies at the center of a single display.  In this case
                  the user most likely wants centered Windows to be constrained to that
                  single display.  The boundaries of the one display are returned.
                  It is possible for the center point to be at both the center of the
                  entire display space AND at the center of a single monitor (a square of
                  9 monitors, for instance).  In this case, the entire display area is
                  returned.
                  Because the center point is arbitrarily settable by the user, it could
                  fit neither of the cases above.  The fallback case is to simply return
                  the combined area for all screens.                
            </javadoc>
            <method name="getXineramaWindowBounds" type="Rectangle" line="362">
                <comment line="369">
                    if center point is at the center of all monitors                    
                </comment>
                <comment line="370">
                    return union of all bounds                    
                </comment>
                <comment line="371">
                                        
                </comment>
                <comment line="372">
                    MM*MM     MMM       M                    
                </comment>
                <comment line="373">
                    M*M       *                    
                </comment>
                <comment line="374">
                    MMM       M                    
                </comment>
                <comment line="376">
                    if center point is at center of a single monitor (but not of all                    
                </comment>
                <comment line="377">
                    monitors)                    
                </comment>
                <comment line="378">
                    return bounds of single monitor                    
                </comment>
                <comment line="379">
                                        
                </comment>
                <comment line="380">
                    MMM         MM                    
                </comment>
                <comment line="381">
                    MM*         *M                    
                </comment>
                <comment line="383">
                    else, center is in some strange spot (such as on the border between                    
                </comment>
                <comment line="384">
                    monitors), and we should just return the union of all monitors                    
                </comment>
                <comment line="385">
                                        
                </comment>
                <comment line="386">
                    MM          MMM                    
                </comment>
                <comment line="387">
                    MM          MMM                    
                </comment>
                <comment line="394">
                    add a pixel or two for fudge-factor                    
                </comment>
                <comment line="404">
                    first: check for center of all monitors (video wall)                    
                </comment>
                <comment line="405">
                    add a pixel or two for fudge-factor                    
                </comment>
                <comment line="417">
                    next, check if at center of one monitor                    
                </comment>
                <comment line="426">
                    otherwise, the center is at some weird spot: return unionRect                    
                </comment>
                <declaration name="center" type="Point" line="363"/>
                <declaration name="unionRect" type="Rectangle" line="364"/>
                <declaration name="gds" type="GraphicsDevice[]" line="365"/>
                <declaration name="centerMonitorRect" type="Rectangle" line="366"/>
                <declaration name="i" type="int" line="367"/>
                <scope line="391">
                    <scope line="398"/>
                </scope>
                <scope line="409">
                    <scope line="411"/>
                </scope>
                <scope line="418">
                    <scope line="419"/>
                </scope>
                <scope line="427"/>
            </method>
            <javadoc line="433">
                From the DisplayChangedListener interface; devices do not need
                  to react to this event.                
            </javadoc>
            <method name="paletteChanged" type="void" line="438"/>
        </class>
    </source>