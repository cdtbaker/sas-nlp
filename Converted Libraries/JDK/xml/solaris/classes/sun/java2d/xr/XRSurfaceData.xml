<?xml version="1.0" encoding="UTF-8"?>
    <source package="sun.java2d.xr">
        <import package="java.awt"/>
        <import package="java.awt.geom"/>
        <import package="java.awt.image"/>
        <import package="sun.awt"/>
        <import package="sun.java2d.InvalidPipeException"/>
        <import package="sun.java2d.SunGraphics2D"/>
        <import package="sun.java2d.SurfaceData"/>
        <import package="sun.java2d.SurfaceDataProxy"/>
        <import package="sun.java2d.jules"/>
        <import package="sun.java2d.loops"/>
        <import package="sun.java2d.pipe"/>
        <import package="sun.java2d.x11"/>
        <import package="sun.font.FontManagerNativeLibrary"/>
        <class name="XRSurfaceData" line="42">
            <extends class="XSurfaceData"/>
            <comment line="386">
                GC is still used for copyArea                
            </comment>
            <declaration name="peer" type="X11ComponentPeer" line="43"/>
            <declaration name="graphicsConfig" type="XRGraphicsConfig" line="44"/>
            <declaration name="renderQueue" type="XRBackend" line="45"/>
            <declaration name="solidloops" type="RenderLoops" line="47"/>
            <declaration name="depth" type="int" line="49"/>
            <method name="initIDs" type="void" line="51"/>
            <method name="XRInitSurface" type="void" line="53"/>
            <method name="initXRPicture" type="void" line="56"/>
            <method name="freeXSDOPicture" type="void" line="58"/>
            <declaration name="DESC_BYTE_A8_X11" type="String" line="60"/>
            <declaration name="DESC_INT_RGB_X11" type="String" line="61"/>
            <declaration name="DESC_INT_ARGB_X11" type="String" line="62"/>
            <declaration name="ByteA8X11" type="SurfaceType" line="64"/>
            <declaration name="IntRgbX11" type="SurfaceType" line="66"/>
            <declaration name="IntArgbPreX11" type="SurfaceType" line="68"/>
            <method name="getRaster" type="Raster" line="71">
                <params>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                </params>
            </method>
            <declaration name="xrpipe" type="XRRenderer" line="75"/>
            <declaration name="xrtxpipe" type="PixelToShapeConverter" line="76"/>
            <declaration name="xrtextpipe" type="TextPipe" line="77"/>
            <declaration name="xrDrawImage" type="XRDrawImage" line="78"/>
            <declaration name="aaShapePipe" type="ShapeDrawPipe" line="80"/>
            <declaration name="aaPixelToShapeConv" type="PixelToShapeConverter" line="81"/>
            <method name="initXRSurfaceData" type="void" line="83">
                <scope line="84"/>
            </method>
            <javadoc line="95">
                Synchronized accessor method for isDrawableValid.                
            </javadoc>
            <method name="isXRDrawableValid" type="boolean" line="98">
                <scope line="99"/>
                <scope line="102"/>
            </method>
            <method name="makeProxyFor" type="SurfaceDataProxy" line="108">
                <params>
                    <param name="srcData" type="SurfaceData"/>
                </params>
            </method>
            <method name="validatePipe" type="void" line="112">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <comment line="116">
                    The textpipe for now can&apos;t handle TexturePaint when extra-alpha is
                     specified nore XOR mode                    
                </comment>
                <comment line="136">
                    TODO: Can we rely on the GC for ARGB32 surfaces?                    
                </comment>
                <comment line="150">
                    custom paints handled by super.validatePipe() below                    
                </comment>
                <comment line="180">
                    install the text pipe based on our earlier decision                    
                </comment>
                <comment line="183">
                    always override the image pipe with the specialized XRender pipe                    
                </comment>
                <declaration name="textpipe" type="TextPipe" line="113"/>
                <declaration name="validated" type="boolean" line="114"/>
                <scope line="125"/>
                <scope line="127"/>
                <declaration name="txPipe" type="PixelToShapeConverter" line="133"/>
                <declaration name="nonTxPipe" type="XRRenderer" line="134"/>
                <scope line="139">
                    <scope line="140">
                        <scope line="141"/>
                    </scope>
                    <scope line="145">
                        <scope line="146"/>
                    </scope>
                </scope>
                <scope line="156"/>
                <scope line="160">
                    <scope line="161">
                        <scope line="162"/>
                        <scope line="165"/>
                        <scope line="168"/>
                    </scope>
                    <scope line="173">
                        <scope line="174"/>
                    </scope>
                </scope>
            </method>
            <method name="getMaskFill" type="MaskFill" line="187">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <scope line="190"/>
            </method>
            <method name="getRenderLoops" type="RenderLoops" line="196">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                </params>
                <scope line="199"/>
            </method>
            <method name="getDeviceConfiguration" type="GraphicsConfiguration" line="206"/>
            <javadoc line="210">
                Method for instantiating a Window SurfaceData                
            </javadoc>
            <method name="createData" type="XRWindowSurfaceData" line="213">
                <params>
                    <param name="peer" type="X11ComponentPeer"/>
                </params>
                <declaration name="gc" type="XRGraphicsConfig" line="214"/>
            </method>
            <javadoc line="218">
                Method for instantiating a Pixmap SurfaceData (offscreen).
                  If the surface  is opaque a 24-bit/RGB surface is chosen,
                  otherwise a 32-bit ARGB surface.                
            </javadoc>
            <method name="createData" type="XRPixmapSurfaceData" line="227">
                <params>
                    <param name="gc" type="XRGraphicsConfig"/>
                    <param name="width" type="int"/>
                    <param name="height" type="int"/>
                    <param name="cm" type="ColorModel"/>
                    <param name="image" type="Image"/>
                    <param name="drawable" type="long"/>
                    <param name="transparency" type="int"/>
                </params>
                <declaration name="depth" type="int" line="228"/>
                <scope line="229"/>
                <scope line="232"/>
            </method>
            <method name="XRSurfaceData" type="constructor" line="245">
                <params>
                    <param name="peer" type="X11ComponentPeer"/>
                    <param name="gc" type="XRGraphicsConfig"/>
                    <param name="sType" type="SurfaceType"/>
                    <param name="cm" type="ColorModel"/>
                    <param name="depth" type="int"/>
                    <param name="transparency" type="int"/>
                </params>
            </method>
            <method name="XRSurfaceData" type="constructor" line="256">
                <params>
                    <param name="renderQueue" type="XRBackend"/>
                </params>
            </method>
            <javadoc line="262">
                Inits the XRender-data-structures which belong to the XRSurfaceData.                
                <param>
                    pictureFormat                    
                </param>
            </javadoc>
            <method name="initXRender" type="void" line="267">
                <params>
                    <param name="pictureFormat" type="int"/>
                </params>
                <scope line="268"/>
                <scope line="273"/>
                <scope line="275"/>
            </method>
            <method name="getGC" type="XRGraphicsConfig" line="280">
                <params>
                    <param name="peer" type="X11ComponentPeer"/>
                </params>
                <scope line="281"/>
                <scope line="283">
                    <declaration name="env" type="GraphicsEnvironment" line="284"/>
                    <declaration name="gd" type="GraphicsDevice" line="286"/>
                </scope>
            </method>
            <method name="canSourceSendExposures" type="boolean" line="291"/>
            <javadoc line="291">
                Returns a boolean indicating whether or not a copyArea from the given
                  rectangle source coordinates might be incomplete and result in X11
                  GraphicsExposure events being generated from XCopyArea. This method
                  allows the SurfaceData copyArea method to determine if it needs to set
                  the GraphicsExposures attribute of the X11 GC to True or False to receive
                  or avoid the events.                
                <return>
                    true if there is any chance that an XCopyArea from the given
                      source coordinates could produce any X11 Exposure events.                    
                </return>
            </javadoc>
            <javadoc line="304">
                CopyArea is implemented using the &quot;old&quot; X11 GC, therefor clip and
                  needExposures have to be validated against that GC. Pictures and GCs
                  don&apos;t share state.                
            </javadoc>
            <method name="validateCopyAreaGC" type="void" line="309">
                <params>
                    <param name="gcClip" type="Region"/>
                    <param name="needExposures" type="boolean"/>
                </params>
                <scope line="310"/>
                <scope line="316"/>
                <scope line="321"/>
            </method>
            <method name="copyArea" type="boolean" line="329">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="x" type="int"/>
                    <param name="y" type="int"/>
                    <param name="w" type="int"/>
                    <param name="h" type="int"/>
                    <param name="dx" type="int"/>
                    <param name="dy" type="int"/>
                </params>
                <scope line="330">
                    <scope line="331"/>
                </scope>
                <declaration name="comptype" type="CompositeType" line="336"/>
                <scope line="340">
                    <scope line="343">
                        <declaration name="needExposures" type="boolean" line="345"/>
                    </scope>
                    <scope line="348"/>
                </scope>
            </method>
            <javadoc line="356">
                Returns the XRender SurfaceType which is able to fullfill the specified
                  transparency requirement.                
            </javadoc>
            <method name="getSurfaceType" type="SurfaceType" line="361">
                <params>
                    <param name="gc" type="XRGraphicsConfig"/>
                    <param name="transparency" type="int"/>
                </params>
                <declaration name="sType" type="SurfaceType" line="362"/>
            </method>
            <method name="invalidate" type="void" line="378">
                <scope line="379"/>
            </method>
            <declaration name="xgc" type="long" line="385"/>
            <declaration name="validatedGCForegroundPixel" type="int" line="386"/>
            <declaration name="validatedXorComp" type="XORComposite" line="387"/>
            <declaration name="xid" type="int" line="388"/>
            <declaration name="picture" type="int" line="389"/>
            <declaration name="maskBuffer" type="XRCompositeManager" line="390"/>
            <declaration name="validatedClip" type="Region" line="392"/>
            <declaration name="validatedGCClip" type="Region" line="393"/>
            <declaration name="validatedExposures" type="boolean" line="394"/>
            <declaration name="transformInUse" type="boolean" line="396"/>
            <declaration name="validatedSourceTransform" type="AffineTransform" line="397"/>
            <declaration name="validatedRepeat" type="int" line="398"/>
            <declaration name="validatedFilter" type="int" line="399"/>
            <javadoc line="401">
                Validates an XRSurfaceData when used as source. Note that the clip is
                  applied when used as source as well as destination.                
            </javadoc>
            <method name="validateAsSource" type="void" line="405">
                <params>
                    <param name="sxForm" type="AffineTransform"/>
                    <param name="repeat" type="int"/>
                    <param name="filter" type="int"/>
                </params>
                <scope line="407"/>
                <scope line="412"/>
                <scope line="417">
                    <scope line="418"/>
                </scope>
                <scope line="425"/>
                <scope line="436"/>
            </method>
            <javadoc line="442">
                Validates the Surface when used as destination.                
            </javadoc>
            <method name="validateAsDestination" type="void" line="445">
                <params>
                    <param name="sg2d" type="SunGraphics2D"/>
                    <param name="clip" type="Region"/>
                </params>
                <comment line="463">
                    validate pixel                    
                </comment>
                <scope line="446"/>
                <declaration name="updateGCClip" type="boolean" line="450"/>
                <scope line="451"/>
                <scope line="457">
                    <scope line="458">
                        <declaration name="xorpixelmod" type="int" line="460"/>
                        <declaration name="pixel" type="int" line="464"/>
                        <scope line="465"/>
                    </scope>
                    <scope line="471"/>
                </scope>
            </method>
            <method name="makePipes" type="void" line="477">
                <scope line="481">
                    <scope line="482">
                        <scope line="491"/>
                    </scope>
                    <scope line="496"/>
                </scope>
            </method>
            <class name="XRWindowSurfaceData" line="502">
                <extends class="XRSurfaceData"/>
                <method name="XRWindowSurfaceData" type="constructor" line="504">
                    <params>
                        <param name="peer" type="X11ComponentPeer"/>
                        <param name="gc" type="XRGraphicsConfig"/>
                        <param name="sType" type="SurfaceType"/>
                    </params>
                    <scope line="508"/>
                </method>
                <method name="getReplacement" type="SurfaceData" line="515"/>
                <method name="getBounds" type="Rectangle" line="519">
                    <declaration name="r" type="Rectangle" line="520"/>
                </method>
                <method name="canSourceSendExposures" type="boolean" line="526">
                    <params>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                </method>
                <javadoc line="530">
                    Returns destination Component associated with this SurfaceData.                    
                </javadoc>
                <method name="getDestination" type="Object" line="533"/>
                <method name="invalidate" type="void" line="537">
                    <scope line="538"/>
                    <scope line="541"/>
                </method>
            </class>
            <class name="XRInternalSurfaceData" line="549">
                <extends class="XRSurfaceData"/>
                <method name="XRInternalSurfaceData" type="constructor" line="551">
                    <params>
                        <param name="renderQueue" type="XRBackend"/>
                        <param name="pictXid" type="int"/>
                        <param name="transform" type="AffineTransform"/>
                    </params>
                    <scope line="556"/>
                </method>
                <method name="canSourceSendExposures" type="boolean" line="561">
                    <params>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                </method>
                <method name="getBounds" type="Rectangle" line="565"/>
                <method name="getDestination" type="Object" line="569"/>
                <method name="getReplacement" type="SurfaceData" line="573"/>
            </class>
            <class name="XRPixmapSurfaceData" line="578">
                <extends class="XRSurfaceData"/>
                <declaration name="offscreenImage" type="Image" line="579"/>
                <declaration name="width" type="int" line="580"/>
                <declaration name="height" type="int" line="581"/>
                <declaration name="transparency" type="int" line="582"/>
                <method name="XRPixmapSurfaceData" type="constructor" line="588">
                    <params>
                        <param name="gc" type="XRGraphicsConfig"/>
                        <param name="width" type="int"/>
                        <param name="height" type="int"/>
                        <param name="image" type="Image"/>
                        <param name="sType" type="SurfaceType"/>
                        <param name="cm" type="ColorModel"/>
                        <param name="drawable" type="long"/>
                        <param name="transparency" type="int"/>
                        <param name="pictFormat" type="int"/>
                        <param name="depth" type="int"/>
                    </params>
                </method>
                <method name="initSurface" type="void" line="601">
                    <params>
                        <param name="depth" type="int"/>
                        <param name="width" type="int"/>
                        <param name="height" type="int"/>
                        <param name="drawable" type="long"/>
                        <param name="pictFormat" type="int"/>
                    </params>
                    <scope line="602"/>
                    <scope line="605"/>
                </method>
                <method name="getReplacement" type="SurfaceData" line="610"/>
                <javadoc line="614">
                    Need this since the surface data is created with the color model of
                      the target GC, which is always opaque. But in SunGraphics2D.blitSD we
                      choose loops based on the transparency on the source SD, so it could
                      choose wrong loop (blit instead of blitbg, for example).                    
                </javadoc>
                <method name="getTransparency" type="int" line="620"/>
                <method name="getBounds" type="Rectangle" line="624"/>
                <method name="canSourceSendExposures" type="boolean" line="629">
                    <params>
                        <param name="x" type="int"/>
                        <param name="y" type="int"/>
                        <param name="w" type="int"/>
                        <param name="h" type="int"/>
                    </params>
                </method>
                <method name="flush" type="void" line="633">
                    <comment line="634">
                        We need to invalidate the surface before disposing the native
                         Drawable and Picture. This way if an application tries to render
                         to an already flushed XRSurfaceData, we will notice in the
                         validate() method above that it has been invalidated, and we will
                         avoid using those native resources that have already been
                         disposed.                        
                    </comment>
                </method>
                <javadoc line="646">
                    Returns destination Image associated with this SurfaceData.                    
                </javadoc>
                <method name="getDestination" type="Object" line="649"/>
            </class>
            <method name="getGC" type="long" line="654"/>
            <class name="LazyPipe" line="658">
                <extends class="ValidatePipe"/>
                <method name="validate" type="boolean" line="659">
                    <params>
                        <param name="sg2d" type="SunGraphics2D"/>
                    </params>
                    <declaration name="xsd" type="XRSurfaceData" line="660"/>
                    <scope line="661"/>
                </method>
            </class>
            <method name="getPicture" type="int" line="669"/>
            <method name="getXid" type="int" line="673"/>
            <method name="getGraphicsConfig" type="XRGraphicsConfig" line="677"/>
        </class>
    </source>