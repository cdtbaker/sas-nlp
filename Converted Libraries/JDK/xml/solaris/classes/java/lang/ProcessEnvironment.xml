<?xml version="1.0" encoding="UTF-8"?>
    <source package="java.lang">
        <import package="java.io"/>
        <import package="java.util"/>
        <class name="ProcessEnvironment" line="61">
            <comment line="84">
                                
            </comment>
            <comment line="89">
                                
            </comment>
            <comment line="94">
                                
            </comment>
            <comment line="100">
                                
            </comment>
            <comment line="107">
                This class is not instantiable.                
            </comment>
            <comment line="110">
                Check that name is suitable for insertion into Environment map                
            </comment>
            <comment line="118">
                Check that value is suitable for insertion into Environment map                
            </comment>
            <comment line="125">
                A class hiding the byteArray-String duality of
                 text data on Unixoid operating systems.                
            </comment>
            <comment line="220">
                This implements the String map view the user sees.                
            </comment>
            <comment line="413">
                Replace with general purpose method someday                
            </comment>
            <comment line="422">
                Replace with general purpose method someday                
            </comment>
            <comment line="432">
                Replace with general purpose method someday                
            </comment>
            <declaration name="theEnvironment" type="HashMap&lt;Variable,Value&gt;" line="63"/>
            <declaration name="theUnmodifiableEnvironment" type="Map&lt;String,String&gt;" line="64"/>
            <declaration name="MIN_NAME_LENGTH" type="int" line="65"/>
            <scope line="67">
                <declaration name="environ" type="byte[][]" line="70"/>
            </scope>
            <method name="getenv" type="String" line="84">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="getenv" type="Map<String,String>" line="89"/>
            <method name="environment" type="Map<String,String>" line="94"/>
            <method name="emptyEnvironment" type="Map<String,String>" line="100">
                <params>
                    <param name="capacity" type="int"/>
                </params>
            </method>
            <method name="environ" type="byte[][]" line="104"/>
            <method name="ProcessEnvironment" type="constructor" line="107"/>
            <method name="validateVariable" type="void" line="110">
                <params>
                    <param name="name" type="String"/>
                </params>
            </method>
            <method name="validateValue" type="void" line="118">
                <params>
                    <param name="value" type="String"/>
                </params>
            </method>
            <class name="ExternalData" line="126">
                <comment line="258">
                    It is technically feasible to provide a byte-oriented view
                     as follows:
                          public Map&lt;byte[],byte[]&gt; asByteArrayMap() {
                              return new ByteArrayEnvironment(m);
                          }                    
                </comment>
                <comment line="265">
                    Convert to Unix style environ as a monolithic byte array
                     inspired by the Windows Environment Block, except we work
                     exclusively with bytes instead of chars, and we need only
                     one trailing NUL on Unix.
                     This keeps the JNI as simple and efficient as possible.                    
                </comment>
                <declaration name="str" type="String" line="127"/>
                <declaration name="bytes" type="byte[]" line="128"/>
                <method name="ExternalData" type="constructor" line="130">
                    <params>
                        <param name="str" type="String"/>
                        <param name="bytes" type="byte[]"/>
                    </params>
                </method>
                <method name="getBytes" type="byte[]" line="135"/>
                <method name="toString" type="String" line="139"/>
                <method name="equals" type="boolean" line="143">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="148"/>
            </class>
            <class name="Variable" line="153">
                <extends class="ExternalData"/>
                <comment line="258">
                    It is technically feasible to provide a byte-oriented view
                     as follows:
                          public Map&lt;byte[],byte[]&gt; asByteArrayMap() {
                              return new ByteArrayEnvironment(m);
                          }                    
                </comment>
                <comment line="265">
                    Convert to Unix style environ as a monolithic byte array
                     inspired by the Windows Environment Block, except we work
                     exclusively with bytes instead of chars, and we need only
                     one trailing NUL on Unix.
                     This keeps the JNI as simple and efficient as possible.                    
                </comment>
                <implements interface="Comparable">
                    <type_params>
                        <type_param name="Variable"/>
                    </type_params>
                </implements>
                <method name="Variable" type="constructor" line="156">
                    <params>
                        <param name="str" type="String"/>
                        <param name="bytes" type="byte[]"/>
                    </params>
                </method>
                <method name="valueOfQueryOnly" type="Variable" line="160">
                    <params>
                        <param name="str" type="Object"/>
                    </params>
                </method>
                <method name="valueOfQueryOnly" type="Variable" line="164">
                    <params>
                        <param name="str" type="String"/>
                    </params>
                </method>
                <method name="valueOf" type="Variable" line="168">
                    <params>
                        <param name="str" type="String"/>
                    </params>
                </method>
                <method name="valueOf" type="Variable" line="173">
                    <params>
                        <param name="bytes" type="byte[]"/>
                    </params>
                </method>
                <method name="compareTo" type="int" line="177">
                    <params>
                        <param name="variable" type="Variable"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="181">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
            </class>
            <class name="Value" line="186">
                <extends class="ExternalData"/>
                <comment line="258">
                    It is technically feasible to provide a byte-oriented view
                     as follows:
                          public Map&lt;byte[],byte[]&gt; asByteArrayMap() {
                              return new ByteArrayEnvironment(m);
                          }                    
                </comment>
                <comment line="265">
                    Convert to Unix style environ as a monolithic byte array
                     inspired by the Windows Environment Block, except we work
                     exclusively with bytes instead of chars, and we need only
                     one trailing NUL on Unix.
                     This keeps the JNI as simple and efficient as possible.                    
                </comment>
                <implements interface="Comparable">
                    <type_params>
                        <type_param name="Value"/>
                    </type_params>
                </implements>
                <method name="Value" type="constructor" line="189">
                    <params>
                        <param name="str" type="String"/>
                        <param name="bytes" type="byte[]"/>
                    </params>
                </method>
                <method name="valueOfQueryOnly" type="Value" line="193">
                    <params>
                        <param name="str" type="Object"/>
                    </params>
                </method>
                <method name="valueOfQueryOnly" type="Value" line="197">
                    <params>
                        <param name="str" type="String"/>
                    </params>
                </method>
                <method name="valueOf" type="Value" line="201">
                    <params>
                        <param name="str" type="String"/>
                    </params>
                </method>
                <method name="valueOf" type="Value" line="206">
                    <params>
                        <param name="bytes" type="byte[]"/>
                    </params>
                </method>
                <method name="compareTo" type="int" line="210">
                    <params>
                        <param name="value" type="Value"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="214">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
            </class>
            <class name="StringEnvironment" line="220">
                <extends class="AbstractMap">
                    <type_params>
                        <type_param name="String"/>
                        <type_param name="String"/>
                    </type_params>
                </extends>
                <comment line="258">
                    It is technically feasible to provide a byte-oriented view
                     as follows:
                          public Map&lt;byte[],byte[]&gt; asByteArrayMap() {
                              return new ByteArrayEnvironment(m);
                          }                    
                </comment>
                <comment line="265">
                    Convert to Unix style environ as a monolithic byte array
                     inspired by the Windows Environment Block, except we work
                     exclusively with bytes instead of chars, and we need only
                     one trailing NUL on Unix.
                     This keeps the JNI as simple and efficient as possible.                    
                </comment>
                <declaration name="m" type="Map&lt;Variable,Value&gt;" line="223"/>
                <method name="toString" type="String" line="224">
                    <params>
                        <param name="v" type="Value"/>
                    </params>
                </method>
                <method name="StringEnvironment" type="constructor" line="227">
                    <params>
                        <param name="m" type="Map<Variable,Value>"/>
                    </params>
                </method>
                <method name="size" type="int" line="228"/>
                <method name="isEmpty" type="boolean" line="229"/>
                <method name="clear" type="void" line="230"/>
                <method name="containsKey" type="boolean" line="231">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="containsValue" type="boolean" line="234">
                    <params>
                        <param name="value" type="Object"/>
                    </params>
                </method>
                <method name="get" type="String" line="237">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="put" type="String" line="240">
                    <params>
                        <param name="key" type="String"/>
                        <param name="value" type="String"/>
                    </params>
                </method>
                <method name="remove" type="String" line="244">
                    <params>
                        <param name="key" type="Object"/>
                    </params>
                </method>
                <method name="keySet" type="Set<String>" line="247"/>
                <method name="entrySet" type="Set<Map.Entry<String,String>>" line="250"/>
                <method name="values" type="Collection<String>" line="253"/>
                <method name="toEnvironmentBlock" type="byte[]" line="269">
                    <params>
                        <param name="envc" type="int[]"/>
                    </params>
                    <comment line="271">
                        For added &apos;=&apos; and NUL                        
                    </comment>
                    <comment line="288">
                        No need to write NUL byte explicitly
                        block[i++] = (byte) &apos;\u0000&apos;;                        
                    </comment>
                    <declaration name="count" type="int" line="270"/>
                    <scope line="271"/>
                    <declaration name="block" type="byte[]" line="276"/>
                    <declaration name="i" type="int" line="278"/>
                    <scope line="279">
                        <declaration name="key" type="byte[]" line="280"/>
                        <declaration name="value" type="byte[]" line="281"/>
                    </scope>
                </method>
            </class>
            <method name="toEnvironmentBlock" type="byte[]" line="295">
                <params>
                    <param name="map" type="Map<String,String>"/>
                    <param name="envc" type="int[]"/>
                </params>
            </method>
            <class name="StringEntry" line="301">
                <comment line="258">
                    It is technically feasible to provide a byte-oriented view
                     as follows:
                          public Map&lt;byte[],byte[]&gt; asByteArrayMap() {
                              return new ByteArrayEnvironment(m);
                          }                    
                </comment>
                <comment line="265">
                    Convert to Unix style environ as a monolithic byte array
                     inspired by the Windows Environment Block, except we work
                     exclusively with bytes instead of chars, and we need only
                     one trailing NUL on Unix.
                     This keeps the JNI as simple and efficient as possible.                    
                </comment>
                <implements interface="Map.Entry">
                    <type_params>
                        <type_param name="String"/>
                        <type_param name="String"/>
                    </type_params>
                </implements>
                <declaration name="e" type="Map.Entry&lt;Variable,Value&gt;" line="304"/>
                <method name="StringEntry" type="constructor" line="305">
                    <params>
                        <param name="e" type="Map.Entry<Variable,Value>"/>
                    </params>
                </method>
                <method name="getKey" type="String" line="306"/>
                <method name="getValue" type="String" line="307"/>
                <method name="setValue" type="String" line="308">
                    <params>
                        <param name="newValue" type="String"/>
                    </params>
                </method>
                <method name="toString" type="String" line="311"/>
                <method name="equals" type="boolean" line="312">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="316"/>
            </class>
            <class name="StringEntrySet" line="319">
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="Map.Entry<String,String>"/>
                    </type_params>
                </extends>
                <comment line="258">
                    It is technically feasible to provide a byte-oriented view
                     as follows:
                          public Map&lt;byte[],byte[]&gt; asByteArrayMap() {
                              return new ByteArrayEnvironment(m);
                          }                    
                </comment>
                <comment line="265">
                    Convert to Unix style environ as a monolithic byte array
                     inspired by the Windows Environment Block, except we work
                     exclusively with bytes instead of chars, and we need only
                     one trailing NUL on Unix.
                     This keeps the JNI as simple and efficient as possible.                    
                </comment>
                <declaration name="s" type="Set&lt;Map.Entry&lt;Variable,Value&gt;&gt;" line="322"/>
                <method name="StringEntrySet" type="constructor" line="323">
                    <params>
                        <param name="s" type="Set<Map.Entry<Variable,Value>>"/>
                    </params>
                </method>
                <method name="size" type="int" line="324"/>
                <method name="isEmpty" type="boolean" line="325"/>
                <method name="clear" type="void" line="326"/>
                <method name="iterator" type="Iterator<Map.Entry<String,String>>" line="327">
                    <anonymous_class line="328">
                        <declaration name="i" type="Iterator&lt;Map.Entry&lt;Variable,Value&gt;&gt;" line="329"/>
                        <method name="hasNext" type="boolean" line="330"/>
                        <method name="next" type="Map.Entry<String,String>" line="331"/>
                        <method name="remove" type="void" line="334"/>
                    </anonymous_class>
                </method>
                <method name="vvEntry" type="Map.Entry<Variable,Value>" line="337">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                    <anonymous_class line="340">
                        <method name="getKey" type="Variable" line="341"/>
                        <method name="getValue" type="Value" line="344"/>
                        <method name="setValue" type="Value" line="347">
                            <params>
                                <param name="value" type="Value"/>
                            </params>
                        </method>
                    </anonymous_class>
                </method>
                <method name="contains" type="boolean" line="352">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="353">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="354">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="358"/>
            </class>
            <class name="StringValues" line="361">
                <extends class="AbstractCollection">
                    <type_params>
                        <type_param name="String"/>
                    </type_params>
                </extends>
                <comment line="258">
                    It is technically feasible to provide a byte-oriented view
                     as follows:
                          public Map&lt;byte[],byte[]&gt; asByteArrayMap() {
                              return new ByteArrayEnvironment(m);
                          }                    
                </comment>
                <comment line="265">
                    Convert to Unix style environ as a monolithic byte array
                     inspired by the Windows Environment Block, except we work
                     exclusively with bytes instead of chars, and we need only
                     one trailing NUL on Unix.
                     This keeps the JNI as simple and efficient as possible.                    
                </comment>
                <declaration name="c" type="Collection&lt;Value&gt;" line="364"/>
                <method name="StringValues" type="constructor" line="365">
                    <params>
                        <param name="c" type="Collection<Value>"/>
                    </params>
                </method>
                <method name="size" type="int" line="366"/>
                <method name="isEmpty" type="boolean" line="367"/>
                <method name="clear" type="void" line="368"/>
                <method name="iterator" type="Iterator<String>" line="369">
                    <anonymous_class line="370">
                        <declaration name="i" type="Iterator&lt;Value&gt;" line="371"/>
                        <method name="hasNext" type="boolean" line="372"/>
                        <method name="next" type="String" line="373"/>
                        <method name="remove" type="void" line="374"/>
                    </anonymous_class>
                </method>
                <method name="contains" type="boolean" line="377">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="380">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="equals" type="boolean" line="383">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="hashCode" type="int" line="387"/>
            </class>
            <class name="StringKeySet" line="390">
                <extends class="AbstractSet">
                    <type_params>
                        <type_param name="String"/>
                    </type_params>
                </extends>
                <comment line="258">
                    It is technically feasible to provide a byte-oriented view
                     as follows:
                          public Map&lt;byte[],byte[]&gt; asByteArrayMap() {
                              return new ByteArrayEnvironment(m);
                          }                    
                </comment>
                <comment line="265">
                    Convert to Unix style environ as a monolithic byte array
                     inspired by the Windows Environment Block, except we work
                     exclusively with bytes instead of chars, and we need only
                     one trailing NUL on Unix.
                     This keeps the JNI as simple and efficient as possible.                    
                </comment>
                <declaration name="s" type="Set&lt;Variable&gt;" line="391"/>
                <method name="StringKeySet" type="constructor" line="392">
                    <params>
                        <param name="s" type="Set<Variable>"/>
                    </params>
                </method>
                <method name="size" type="int" line="393"/>
                <method name="isEmpty" type="boolean" line="394"/>
                <method name="clear" type="void" line="395"/>
                <method name="iterator" type="Iterator<String>" line="396">
                    <anonymous_class line="397">
                        <declaration name="i" type="Iterator&lt;Variable&gt;" line="398"/>
                        <method name="hasNext" type="boolean" line="399"/>
                        <method name="next" type="String" line="400"/>
                        <method name="remove" type="void" line="401"/>
                    </anonymous_class>
                </method>
                <method name="contains" type="boolean" line="404">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
                <method name="remove" type="boolean" line="407">
                    <params>
                        <param name="o" type="Object"/>
                    </params>
                </method>
            </class>
            <method name="arrayCompare" type="int" line="413">
                <params>
                    <param name="x" type="byte[]"/>
                    <param name="y" type="byte[]"/>
                </params>
                <declaration name="min" type="int" line="414"/>
            </method>
            <method name="arrayEquals" type="boolean" line="422">
                <params>
                    <param name="x" type="byte[]"/>
                    <param name="y" type="byte[]"/>
                </params>
            </method>
            <method name="arrayHash" type="int" line="432">
                <params>
                    <param name="x" type="byte[]"/>
                </params>
                <declaration name="hash" type="int" line="433"/>
            </method>
        </class>
    </source>