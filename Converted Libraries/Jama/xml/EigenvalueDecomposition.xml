<?xml version="1.0" encoding="UTF-8"?>
    <source package="Jama">
        <import package="Jama.util"/>
        <class name="EigenvalueDecomposition" line="4">
            <comment line="23">
                ------------------------
                Class variables                
            </comment>
            <comment line="57">
                ------------------------
                Private Methods                
            </comment>
            <comment line="61">
                Symmetric Householder reduction to tridiagonal form.                
            </comment>
            <comment line="178">
                Symmetric tridiagonal QL algorithm.                
            </comment>
            <comment line="298">
                Nonsymmetric reduction to Hessenberg form.                
            </comment>
            <comment line="392">
                Complex scalar division.                
            </comment>
            <comment line="411">
                Nonsymmetric reduction from Hessenberg to real Schur form.                
            </comment>
            <comment line="854">
                ------------------------
                Constructor                
            </comment>
            <comment line="908">
                ------------------------
                Public Methods                
            </comment>
            <implements interface="java.io.Serializable"/>
            <javadoc line="4">
                Eigenvalues and eigenvectors of a real matrix. 
                  &lt;P&gt;
                  If A is symmetric, then A = VDV&apos; where the eigenvalue matrix D is
                  diagonal and the eigenvector matrix V is orthogonal.
                  I.e. A = V.times(D.times(V.transpose())) and 
                  V.times(V.transpose()) equals the identity matrix.
                  &lt;P&gt;
                  If A is not symmetric, then the eigenvalue matrix D is block diagonal
                  with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
                  lambda + imu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The
                  columns of V represent the eigenvectors in the sense that AV = VD,
                  i.e. A.times(V) equals V.times(D).  The matrix V may be badly
                  conditioned, or even singular, so the validity of the equation
                  A = VDinverse(V) depends upon V.cond().                
            </javadoc>
            <declaration name="n" type="int" line="26"/>
            <javadoc line="26">
                Row and column dimension (square matrix).                
                <serial>
                    matrix dimension.                    
                </serial>
            </javadoc>
            <declaration name="issymmetric" type="boolean" line="31"/>
            <javadoc line="31">
                Symmetry flag.                
                <serial>
                    internal symmetry flag.                    
                </serial>
            </javadoc>
            <declaration name="d" type="double[]" line="36"/>
            <javadoc line="36">
                Arrays for internal storage of eigenvalues.                
                <serial>
                    internal storage of eigenvalues.                    
                </serial>
            </javadoc>
            <declaration name="V" type="double[][]" line="41"/>
            <javadoc line="41">
                Array for internal storage of eigenvectors.                
                <serial>
                    internal storage of eigenvectors.                    
                </serial>
            </javadoc>
            <declaration name="H" type="double[][]" line="46"/>
            <javadoc line="46">
                Array for internal storage of nonsymmetric Hessenberg form.                
                <serial>
                    internal storage of nonsymmetric Hessenberg form.                    
                </serial>
            </javadoc>
            <declaration name="ort" type="double[]" line="51"/>
            <javadoc line="51">
                Working storage for nonsymmetric algorithm.                
                <serial>
                    working storage for nonsymmetric algorithm.                    
                </serial>
            </javadoc>
            <method name="tred2" type="void" line="62">
                <comment line="64">
                    This is derived from the Algol procedures tred2 by                    
                </comment>
                <comment line="65">
                    Bowdler, Martin, Reinsch, and Wilkinson, Handbook for                    
                </comment>
                <comment line="66">
                    Auto. Comp., Vol.ii-Linear Algebra, and the corresponding                    
                </comment>
                <comment line="67">
                    Fortran subroutine in EISPACK.                    
                </comment>
                <comment line="73">
                    Householder reduction to tridiagonal form.                    
                </comment>
                <comment line="77">
                    Scale to avoid under/overflow.                    
                </comment>
                <comment line="93">
                    Generate Householder vector.                    
                </comment>
                <comment line="111">
                    Apply similarity transformation to remaining columns.                    
                </comment>
                <comment line="145">
                    Accumulate transformations.                    
                </comment>
                <scope line="69"/>
                <scope line="75">
                    <declaration name="scale" type="double" line="79"/>
                    <declaration name="h" type="double" line="80"/>
                    <scope line="81"/>
                    <scope line="84">
                        <scope line="86"/>
                    </scope>
                    <scope line="91">
                        <scope line="95"/>
                        <declaration name="f" type="double" line="99"/>
                        <declaration name="g" type="double" line="100"/>
                        <scope line="101"/>
                        <scope line="107"/>
                        <scope line="113">
                            <scope line="117"/>
                        </scope>
                        <scope line="124"/>
                        <declaration name="hh" type="double" line="128"/>
                        <scope line="129"/>
                        <scope line="132">
                            <scope line="135"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="147">
                    <declaration name="h" type="double" line="150"/>
                    <scope line="151">
                        <scope line="152"/>
                        <scope line="155">
                            <declaration name="g" type="double" line="156"/>
                            <scope line="157"/>
                            <scope line="160"/>
                        </scope>
                    </scope>
                    <scope line="165"/>
                </scope>
                <scope line="169"/>
            </method>
            <method name="tql2" type="void" line="179">
                <comment line="181">
                    This is derived from the Algol procedures tql2, by                    
                </comment>
                <comment line="182">
                    Bowdler, Martin, Reinsch, and Wilkinson, Handbook for                    
                </comment>
                <comment line="183">
                    Auto. Comp., Vol.ii-Linear Algebra, and the corresponding                    
                </comment>
                <comment line="184">
                    Fortran subroutine in EISPACK.                    
                </comment>
                <comment line="196">
                    Find small subdiagonal element                    
                </comment>
                <comment line="207">
                    If m == l, d[l] is an eigenvalue,                    
                </comment>
                <comment line="208">
                    otherwise, iterate.                    
                </comment>
                <comment line="213">
                    (Could check iteration count here.)                    
                </comment>
                <comment line="215">
                    Compute implicit shift                    
                </comment>
                <comment line="232">
                    Implicit QL transformation.                    
                </comment>
                <comment line="254">
                    Accumulate transformation.                    
                </comment>
                <comment line="266">
                    Check for convergence.                    
                </comment>
                <comment line="274">
                    Sort eigenvalues and corresponding vectors.                    
                </comment>
                <scope line="186"/>
                <declaration name="f" type="double" line="191"/>
                <declaration name="tst1" type="double" line="192"/>
                <declaration name="eps" type="double" line="193"/>
                <scope line="194">
                    <declaration name="m" type="int" line="199"/>
                    <scope line="200">
                        <scope line="201"/>
                    </scope>
                    <scope line="210">
                        <declaration name="iter" type="int" line="211"/>
                        <scope line="212">
                            <declaration name="g" type="double" line="217"/>
                            <declaration name="p" type="double" line="218"/>
                            <declaration name="r" type="double" line="219"/>
                            <scope line="220"/>
                            <declaration name="dl1" type="double" line="225"/>
                            <declaration name="h" type="double" line="226"/>
                            <scope line="227"/>
                            <declaration name="c" type="double" line="235"/>
                            <declaration name="c2" type="double" line="236"/>
                            <declaration name="c3" type="double" line="237"/>
                            <declaration name="el1" type="double" line="238"/>
                            <declaration name="s" type="double" line="239"/>
                            <declaration name="s2" type="double" line="240"/>
                            <scope line="241">
                                <scope line="256"/>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="276">
                    <declaration name="k" type="int" line="277"/>
                    <declaration name="p" type="double" line="278"/>
                    <scope line="279">
                        <scope line="280"/>
                    </scope>
                    <scope line="285">
                        <scope line="288"/>
                    </scope>
                </scope>
            </method>
            <method name="orthes" type="void" line="299">
                <comment line="301">
                    This is derived from the Algol procedures orthes and ortran,                    
                </comment>
                <comment line="302">
                    by Martin and Wilkinson, Handbook for Auto. Comp.,                    
                </comment>
                <comment line="303">
                    Vol.ii-Linear Algebra, and the corresponding                    
                </comment>
                <comment line="304">
                    Fortran subroutines in EISPACK.                    
                </comment>
                <comment line="311">
                    Scale column.                    
                </comment>
                <comment line="319">
                    Compute Householder transformation.                    
                </comment>
                <comment line="333">
                    Apply Householder similarity transformation                    
                </comment>
                <comment line="334">
                    H = (I-u*u&apos;/h)*H*(I-u*u&apos;)/h)                    
                </comment>
                <comment line="362">
                    Accumulate transformations (Algol&apos;s ortran).                    
                </comment>
                <comment line="380">
                    Double division avoids possible underflow                    
                </comment>
                <declaration name="low" type="int" line="306"/>
                <declaration name="high" type="int" line="307"/>
                <scope line="309">
                    <declaration name="scale" type="double" line="313"/>
                    <scope line="314"/>
                    <scope line="317">
                        <declaration name="h" type="double" line="321"/>
                        <scope line="322"/>
                        <declaration name="g" type="double" line="326"/>
                        <scope line="327"/>
                        <scope line="336">
                            <declaration name="f" type="double" line="337"/>
                            <scope line="338"/>
                            <scope line="342"/>
                        </scope>
                        <scope line="347">
                            <declaration name="f" type="double" line="348"/>
                            <scope line="349"/>
                            <scope line="353"/>
                        </scope>
                    </scope>
                </scope>
                <scope line="364">
                    <scope line="365"/>
                </scope>
                <scope line="370">
                    <scope line="371">
                        <scope line="372"/>
                        <scope line="375">
                            <declaration name="g" type="double" line="376"/>
                            <scope line="377"/>
                            <scope line="382"/>
                        </scope>
                    </scope>
                </scope>
            </method>
            <declaration name="cdivr" type="double" line="393"/>
            <method name="cdiv" type="void" line="394">
                <params>
                    <param name="xr" type="double"/>
                    <param name="xi" type="double"/>
                    <param name="yr" type="double"/>
                    <param name="yi" type="double"/>
                </params>
                <declaration name="r" type="double" line="395"/>
                <scope line="396"/>
                <scope line="401"/>
            </method>
            <method name="hqr2" type="void" line="412">
                <comment line="414">
                    This is derived from the Algol procedure hqr2,                    
                </comment>
                <comment line="415">
                    by Martin and Wilkinson, Handbook for Auto. Comp.,                    
                </comment>
                <comment line="416">
                    Vol.ii-Linear Algebra, and the corresponding                    
                </comment>
                <comment line="417">
                    Fortran subroutine in EISPACK.                    
                </comment>
                <comment line="419">
                    Initialize                    
                </comment>
                <comment line="429">
                    Store roots isolated by balanc and compute matrix norm                    
                </comment>
                <comment line="442">
                    Outer loop over eigenvalue index                    
                </comment>
                <comment line="447">
                    Look for single small sub-diagonal element                    
                </comment>
                <comment line="461">
                    Check for convergence                    
                </comment>
                <comment line="462">
                    One root found                    
                </comment>
                <comment line="471">
                    Two roots found                    
                </comment>
                <comment line="482">
                    Real pair                    
                </comment>
                <comment line="505">
                    Row modification                    
                </comment>
                <comment line="513">
                    Column modification                    
                </comment>
                <comment line="521">
                    Accumulate transformations                    
                </comment>
                <comment line="529">
                    Complex pair                    
                </comment>
                <comment line="540">
                    No convergence yet                    
                </comment>
                <comment line="544">
                    Form shift                    
                </comment>
                <comment line="554">
                    Wilkinson&apos;s original ad hoc shift                    
                </comment>
                <comment line="566">
                    MATLAB&apos;s new ad hoc shift                    
                </comment>
                <comment line="585">
                    (Could check iteration count here.)                    
                </comment>
                <comment line="587">
                    Look for two consecutive small sub-diagonal elements                    
                </comment>
                <comment line="619">
                    Double QR step involving rows l:n and columns m:n                    
                </comment>
                <comment line="654">
                    Row modification                    
                </comment>
                <comment line="666">
                    Column modification                    
                </comment>
                <comment line="678">
                    Accumulate transformations                    
                </comment>
                <comment line="689">
                    (s != 0)                    
                </comment>
                <comment line="690">
                    k loop                    
                </comment>
                <comment line="691">
                    check convergence                    
                </comment>
                <comment line="692">
                    while (n &gt;= low)                    
                </comment>
                <comment line="694">
                    Backsubstitute to find vectors of upper triangular form                    
                </comment>
                <comment line="704">
                    Real vector                    
                </comment>
                <comment line="727">
                    Solve real equations                    
                </comment>
                <comment line="742">
                    Overflow control                    
                </comment>
                <comment line="753">
                    Complex vector                    
                </comment>
                <comment line="758">
                    Last vector component imaginary so matrix is triangular                    
                </comment>
                <comment line="792">
                    Solve complex equations                    
                </comment>
                <comment line="815">
                    Overflow control                    
                </comment>
                <comment line="829">
                    Vectors of isolated roots                    
                </comment>
                <comment line="839">
                    Back transformation to get eigenvectors of original matrix                    
                </comment>
                <declaration name="nn" type="int" line="421"/>
                <declaration name="n" type="int" line="422"/>
                <declaration name="low" type="int" line="423"/>
                <declaration name="high" type="int" line="424"/>
                <declaration name="eps" type="double" line="425"/>
                <declaration name="exshift" type="double" line="426"/>
                <declaration name="p" type="double" line="427"/>
                <declaration name="norm" type="double" line="431"/>
                <scope line="432">
                    <scope line="433"/>
                    <scope line="437"/>
                </scope>
                <declaration name="iter" type="int" line="444"/>
                <scope line="445">
                    <declaration name="l" type="int" line="449"/>
                    <scope line="450">
                        <scope line="452"/>
                        <scope line="455"/>
                    </scope>
                    <scope line="464"/>
                    <scope line="473">
                        <scope line="484">
                            <scope line="485"/>
                            <scope line="487"/>
                            <scope line="492"/>
                            <scope line="507"/>
                            <scope line="515"/>
                            <scope line="523"/>
                        </scope>
                        <scope line="531"/>
                    </scope>
                    <scope line="542">
                        <scope line="549"/>
                        <scope line="556">
                            <scope line="558"/>
                        </scope>
                        <scope line="568">
                            <scope line="571">
                                <scope line="573"/>
                                <scope line="577"/>
                            </scope>
                        </scope>
                        <declaration name="m" type="int" line="589"/>
                        <scope line="590">
                            <scope line="601"/>
                            <scope line="606"/>
                        </scope>
                        <scope line="612">
                            <scope line="614"/>
                        </scope>
                        <scope line="622">
                            <declaration name="notlast" type="boolean" line="623"/>
                            <scope line="624">
                                <scope line="629"/>
                            </scope>
                            <scope line="638"/>
                            <scope line="641">
                                <scope line="642"/>
                                <scope line="644"/>
                                <scope line="656">
                                    <scope line="658"/>
                                </scope>
                                <scope line="668">
                                    <scope line="670"/>
                                </scope>
                                <scope line="680">
                                    <scope line="682"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="696"/>
                <scope line="700">
                    <scope line="706">
                        <declaration name="l" type="int" line="707"/>
                        <scope line="709">
                            <scope line="712"/>
                            <scope line="715"/>
                            <scope line="718">
                                <scope line="720">
                                    <scope line="721"/>
                                    <scope line="723"/>
                                </scope>
                                <scope line="729">
                                    <scope line="735"/>
                                    <scope line="737"/>
                                </scope>
                                <scope line="745">
                                    <scope line="746"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                    <scope line="755">
                        <declaration name="l" type="int" line="756"/>
                        <scope line="760"/>
                        <scope line="763"/>
                        <scope line="770">
                            <declaration name="ra" type="double" line="771"/>
                            <scope line="774"/>
                            <scope line="780"/>
                            <scope line="784">
                                <scope line="786"/>
                                <scope line="790">
                                    <scope line="798"/>
                                    <scope line="805"/>
                                    <scope line="808"/>
                                </scope>
                                <scope line="818">
                                    <scope line="819"/>
                                </scope>
                            </scope>
                        </scope>
                    </scope>
                </scope>
                <scope line="831">
                    <scope line="832">
                        <scope line="833"/>
                    </scope>
                </scope>
                <scope line="841">
                    <scope line="842">
                        <scope line="844"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="857">
                Check for symmetry, then construct the eigenvalue decomposition
                  Structure to access D and V.                
                <param>
                    Arg    Square matrix                    
                </param>
            </javadoc>
            <method name="EigenvalueDecomposition" type="constructor" line="862">
                <params>
                    <param name="Arg" type="Matrix"/>
                </params>
                <comment line="883">
                    Tridiagonalize.                    
                </comment>
                <comment line="886">
                    Diagonalize.                    
                </comment>
                <comment line="899">
                    Reduce to Hessenberg form.                    
                </comment>
                <comment line="902">
                    Reduce Hessenberg to real Schur form.                    
                </comment>
                <declaration name="A" type="double[][]" line="863"/>
                <scope line="870">
                    <scope line="871"/>
                </scope>
                <scope line="876">
                    <scope line="877">
                        <scope line="878"/>
                    </scope>
                </scope>
                <scope line="889">
                    <scope line="893">
                        <scope line="894"/>
                    </scope>
                </scope>
            </method>
            <javadoc line="911">
                Return the eigenvector matrix                
                <return>
                    V                    
                </return>
            </javadoc>
            <method name="getV" type="Matrix" line="915"/>
            <javadoc line="919">
                Return the real parts of the eigenvalues                
                <return>
                    real(diag(D))                    
                </return>
            </javadoc>
            <method name="getRealEigenvalues" type="double[]" line="923"/>
            <javadoc line="927">
                Return the imaginary parts of the eigenvalues                
                <return>
                    imag(diag(D))                    
                </return>
            </javadoc>
            <method name="getImagEigenvalues" type="double[]" line="931"/>
            <javadoc line="935">
                Return the block diagonal eigenvalue matrix                
                <return>
                    D                    
                </return>
            </javadoc>
            <method name="getD" type="Matrix" line="939">
                <declaration name="X" type="Matrix" line="940"/>
                <declaration name="D" type="double[][]" line="941"/>
                <scope line="942">
                    <scope line="943"/>
                    <scope line="947"/>
                    <scope line="949"/>
                </scope>
            </method>
            <declaration name="serialVersionUID" type="long" line="955"/>
        </class>
    </source>