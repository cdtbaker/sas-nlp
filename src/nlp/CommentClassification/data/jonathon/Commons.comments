Commons/xml/main/java/org/apache/commons/math3/analysis/BivariateFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/DifferentiableUnivariateFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/DifferentiableUnivariateMatrixFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/DifferentiableUnivariateVectorFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.xml
EX 127	the derivative of the variable with respect to itself is 1.
EX 399	we use the bits representation to also handle -0.0
EX 453	Sign is currently OK
DF 456	flip sign
EX 465	Sign is currently OK
DF 468	flip sign
EX 517	y is neglectible with respect to x
EX 520	x is neglectible with respect to y
EX 524	find an intermediate scale to avoid both overflow and underflow
EX 527	scale parameters without losing precision
EX 531	compute scaled hypotenuse
EX 535	remove scaling
EX 882	compute an accurate value, taking care of cancellations
EX 893	compute a simple value, with all partial derivatives
EX 899	create a result with accurate value and all derivatives (not necessarily as accurate as the value)
EX 914	compute an accurate value, taking care of cancellations
EX 921	compute a simple value, with all partial derivatives
EX 927	create a result with accurate value and all derivatives (not necessarily as accurate as the value)
EX 943	compute an accurate value, taking care of cancellations
EX 947	compute a simple value, with all partial derivatives
EX 950	create a result with accurate value and all derivatives (not necessarily as accurate as the value)
EX 966	compute an accurate value, taking care of cancellations
EX 970	compute a simple value, with all partial derivatives
EX 973	create a result with accurate value and all derivatives (not necessarily as accurate as the value)
EX 990	compute an accurate value, taking care of cancellations
EX 995	compute a simple value, with all partial derivatives
EX 998	create a result with accurate value and all derivatives (not necessarily as accurate as the value)
EX 1015	compute an accurate value, taking care of cancellations
EX 1020	compute a simple value, with all partial derivatives
EX 1023	create a result with accurate value and all derivatives (not necessarily as accurate as the value)
EX 1041	compute an accurate value, taking care of cancellations
EX 1047	compute a simple value, with all partial derivatives
EX 1050	create a result with accurate value and all derivatives (not necessarily as accurate as the value)
EX 1068	compute an accurate value, taking care of cancellations
EX 1074	compute a simple value, with all partial derivatives
EX 1077	create a result with accurate value and all derivatives (not necessarily as accurate as the value)

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.xml
EX 195	get the cached compilers
CF 199	the compiler has already been created
EX 203	we need to create more compilers
CF 209	preserve the already created compilers
CF 215	create the array in increasing diagonal order
EX 227	atomically reset the cached compilers array
EX 277	set up the indices for the value part
EX 279	copy the first indices, the last one remaining set to 0
EX 285	set up the indices for the derivative part
EX 288	copy the indices
EX 293	increment the derivation order for the last parameter
EX 321	this is an implementation of definition 6 in Dan Kalman's paper.
EX 356	this is an implementation of definition 3 in Dan Kalman's paper.
EX 371	combine terms with similar derivation orders
EX 379	combine termJ and termK
CF 381	make sure we will skip termK later on in the outer loop
EX 427	the composition rules from the value part can be reused as is
EX 430	the composition rules for the derivative part are deduced by differentiation the rules from the underlying compiler once with respect to the parameter this compiler handles and the underlying one did not handle
EX 438	handle term p * f_k(g(x)) * g_l1(x) * g_l2(x) * ... * g_lp(x)
EX 440	derive the first factor in the term: f_k with respect to new parameter
EX 442	p
EX 443	f_(k+1)
EX 446	g_1
EX 448	convert the indices as the mapping for the current order is different from the mapping with one less order
EX 457	derive the various g_l
EX 463	convert the indices as the mapping for the current order is different from the mapping with one less order
EX 469	derive this term
EX 481	combine terms with similar derivation orders
EX 493	combine termJ and termK
CF 495	make sure we will skip termK later on in the outer loop
EX 546	safety check
EX 569	the value is obtained by diving into the recursive Dan Kalman's structure this is theorem 2 of his paper, with recursion replaced by iteration
EX 576	derivative order for current free parameter
EX 579	safety check
EX 586	as long as we differentiate according to current free parameter, we have to skip the value part and dive into the derivative part so we add the size of the value part to the base index
CF 825	compute k such that lhs % rhs = lhs - k rhs
EX 829	set up value
EX 832	set up partial derivatives
EX 851	create the function value and derivatives [x^p, px^(p-1), p(p-1)x^(p-2), ... ]
EX 866	apply function composition
EX 884	special case, x^0 = 1 for all x
EX 890	create the power function value and derivatives [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]
DF 895	strictly positive power
DF 904	strictly negative power
EX 919	apply function composition
EX 956	create the function value and derivatives [x^(1/n), (1/n)x^((1/n)-1), (1-n)/n^2x^((1/n)-2), ... ]
EX 977	apply function composition
EX 993	create the function value and derivatives
EX 997	apply function composition
EX 1013	create the function value and derivatives
EX 1018	apply function composition
EX 1034	create the function value and derivatives
EX 1046	apply function composition
EX 1061	create the function value and derivatives
EX 1073	apply function composition
EX 1088	create the function value and derivatives
EX 1100	apply function composition
EX 1116	create the function value and derivatives
EX 1126	apply function composition
EX 1142	create the function value and derivatives
EX 1152	apply function composition
EX 1168	create the function value and derivatives
EX 1175	the nth order derivative of tan has the form: dn(tan(x)/dxn = P_n(tan(x)) where P_n(t) is a degree n+1 polynomial with same parity as n+1 P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ... the general recurrence relation for P_n is: P_n(x) = (1+t^2) P_(n-1)'(t) as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
EX 1187	update and evaluate polynomial P_n(t)
EX 1207	apply function composition
EX 1223	create the function value and derivatives
EX 1228	the nth order derivative of acos has the form: dn(acos(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2) where P_n(x) is a degree n-1 polynomial with same parity as n-1 P_1(x) = -1, P_2(x) = -x, P_3(x) = -2x^2 - 1 ... the general recurrence relation for P_n is: P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x) as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
EX 1243	update and evaluate polynomial P_n(x)
EX 1264	apply function composition
EX 1280	create the function value and derivatives
EX 1285	the nth order derivative of asin has the form: dn(asin(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2) where P_n(x) is a degree n-1 polynomial with same parity as n-1 P_1(x) = 1, P_2(x) = x, P_3(x) = 2x^2 + 1 ... the general recurrence relation for P_n is: P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x) as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
EX 1300	update and evaluate polynomial P_n(x)
EX 1321	apply function composition
EX 1337	create the function value and derivatives
EX 1342	the nth order derivative of atan has the form: dn(atan(x)/dxn = Q_n(x) / (1 + x^2)^n where Q_n(x) is a degree n-1 polynomial with same parity as n-1 Q_1(x) = 1, Q_2(x) = -2x, Q_3(x) = 6x^2 - 2 ... the general recurrence relation for Q_n is: Q_n(x) = (1+x^2) Q_(n-1)'(x) - 2(n-1) x Q_(n-1)(x) as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array
EX 1357	update and evaluate polynomial Q_n(x)
EX 1378	apply function composition
DF 1397	compute r = sqrt(x^2+y^2)
EX 1399	x^2
EX 1401	y^2
EX 1402	x^2 + y^2
EX 1403	r = sqrt(x^2 + y^2)
DF 1407	compute atan2(y, x) = 2 atan(y / (r + x))
EX 1408	r + x
EX 1409	y /(r + x)
EX 1410	atan(y / (r + x))
EX 1412	2 * atan(y / (r + x))
DF 1417	compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
EX 1418	r - x
EX 1419	y /(r - x)
EX 1420	atan(y / (r - x))
EX 1422	+/-pi - 2 * atan(y / (r - x))
EX 1424	+/-pi - 2 * atan(y / (r - x))
EX 1429	fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
EX 1445	create the function value and derivatives
EX 1455	apply function composition
EX 1471	create the function value and derivatives
EX 1481	apply function composition
EX 1497	create the function value and derivatives
EX 1504	the nth order derivative of tanh has the form: dn(tanh(x)/dxn = P_n(tanh(x)) where P_n(t) is a degree n+1 polynomial with same parity as n+1 P_0(t) = t, P_1(t) = 1 - t^2, P_2(t) = -2 t (1 - t^2) ... the general recurrence relation for P_n is: P_n(x) = (1-t^2) P_(n-1)'(t) as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
EX 1516	update and evaluate polynomial P_n(t)
EX 1536	apply function composition
EX 1552	create the function value and derivatives
EX 1557	the nth order derivative of acosh has the form: dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2) where P_n(x) is a degree n-1 polynomial with same parity as n-1 P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ... the general recurrence relation for P_n is: P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x) as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
EX 1572	update and evaluate polynomial P_n(x)
EX 1593	apply function composition
EX 1609	create the function value and derivatives
EX 1614	the nth order derivative of asinh has the form: dn(asinh(x)/dxn = P_n(x) / [x^2 + 1]^((2n-1)/2) where P_n(x) is a degree n-1 polynomial with same parity as n-1 P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 - 1 ... the general recurrence relation for P_n is: P_n(x) = (x^2+1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x) as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
EX 1629	update and evaluate polynomial P_n(x)
EX 1650	apply function composition
EX 1666	create the function value and derivatives
EX 1671	the nth order derivative of atanh has the form: dn(atanh(x)/dxn = Q_n(x) / (1 - x^2)^n where Q_n(x) is a degree n-1 polynomial with same parity as n-1 Q_1(x) = 1, Q_2(x) = 2x, Q_3(x) = 6x^2 + 2 ... the general recurrence relation for Q_n is: Q_n(x) = (1-x^2) Q_(n-1)'(x) + 2(n-1) x Q_(n-1)(x) as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array
EX 1686	update and evaluate polynomial Q_n(x)
EX 1707	apply function composition
CF 1758	this cannot happen

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.xml
EX 198	create divided differences diagonal arrays
EX 204	update the bottom diagonal of the divided differences array
EX 210	update the top diagonal of the divided differences array
EX 215	evaluate interpolation polynomial (represented by top diagonal) at t
DF 224	start with monomial(t) = 1
DF 227	monomial(t) = (t - t0) * (t - t1) * ... * (t - t(i-1))
EX 257	check we can achieve the requested derivation order with the sample
EX 262	compute sample position, trying to be centered if possible
EX 265	compute sample points
EX 271	evaluate derivatives
EX 257	check we can achieve the requested derivation order with the sample
EX 262	compute sample position, trying to be centered if possible
EX 265	compute sample points
EX 271	evaluate derivatives
EX 297	check we can achieve the requested derivation order with the sample
EX 302	compute sample position, trying to be centered if possible
EX 305	compute sample points
EX 317	evaluate derivatives
EX 297	check we can achieve the requested derivation order with the sample
EX 302	compute sample position, trying to be centered if possible
EX 305	compute sample points
EX 317	evaluate derivatives
EX 348	check we can achieve the requested derivation order with the sample
EX 353	compute sample position, trying to be centered if possible
EX 356	compute sample points
EX 370	evaluate derivatives
EX 348	check we can achieve the requested derivation order with the sample
EX 353	compute sample position, trying to be centered if possible
EX 356	compute sample points
EX 370	evaluate derivatives

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/GradientFunction.xml
EX 45	set up parameters
EX 51	compute the derivatives
EX 54	extract the gradient

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/JacobianFunction.xml
EX 47	set up parameters
EX 53	compute the derivatives
EX 56	extract the Jacobian

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/MultivariateDifferentiableFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/MultivariateDifferentiableVectorFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableMatrixFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableVectorFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateMatrixFunctionDifferentiator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateVectorFunctionDifferentiator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Abs.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Acos.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Acosh.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Add.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Asin.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Asinh.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Atan.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Atan2.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Atanh.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Cbrt.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Ceil.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Constant.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Cos.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Cosh.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Divide.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Exp.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Expm1.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Floor.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Gaussian.xml
219	the nth order derivative of the Gaussian has the form: dn(g(x)/dxn = (norm / s^n) P_n(u) exp(-u^2/2) with u=(x-m)/s where P_n(u) is a degree n polynomial with same parity as n P_0(u) = 1, P_1(u) = -u, P_2(u) = u^2 - 1, P_3(u) = -u^3 + 3 u... the general recurrence relation for P_n is: P_n(u) = P_(n-1)'(u) - u P_(n-1)(u) as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
236	update and evaluate polynomial P_n(x)

Commons/xml/main/java/org/apache/commons/math3/analysis/function/HarmonicOscillator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Identity.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Inverse.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Log.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Log10.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Log1p.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Logistic.xml
161	Components of the gradient.

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Logit.xml
181	function value
189	fill the array with infinities (for x close to lo the signs will flip between -inf and +inf, for x close to hi the signs will always be +inf) this is probably overkill, since the call to compose at the end of the method will transform most infinities into NaN ...
200	function derivatives

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Max.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Min.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Minus.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Multiply.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Pow.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Power.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Rint.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Sigmoid.xml
175	special handling near lower boundary, to avoid NaN
181	the nth order derivative of sigmoid has the form: dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1) where P_n(t) is a degree n polynomial with normalized higher term P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t... the general recurrence relation for P_n is: P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)
193	update and evaluate polynomial P_n(t)
210	fix function value

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Signum.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Sin.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Sinc.xml
90	use Taylor series
94	use definition expression
123	even derivation order
127	odd derivation order
141	the nth order derivative of sinc has the form: dn(sinc(x)/dxn = [S_n(x) sin(x) + C_n(x) cos(x)] / x^(n+1) where S_n(x) is an even polynomial with degree n-1 or n (depending on parity) and C_n(x) is an odd polynomial with degree n-1 or n (depending on parity) S_0(x) = 1, S_1(x) = -1, S_2(x) = -x^2 + 2, S_3(x) = 3x^2 - 6... C_0(x) = 0, C_1(x) = x, C_2(x) = -2x, C_3(x) = -x^3 + 6x... the general recurrence relations for S_n and C_n are: S_n(x) = x S_(n-1)'(x) - n S_(n-1)(x) - x C_(n-1)(x) C_n(x) = x C_(n-1)'(x) - n C_(n-1)(x) + x S_(n-1)(x) as per polynomials parity, we can store both S_n and C_n in the same array
160	update and evaluate polynomials S_n(x) and C_n(x)
163	even derivation order, S_n is degree n and C_n is degree n-1
167	odd derivation order, S_n is degree n-1 and C_n is degree n
173	in this loop, k is always even
176	sine part
180	cosine part

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Sinh.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Sqrt.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/StepFunction.xml
89	"x" is between "abscissa[-index-2]" and "abscissa[-index-1]".
92	"x" is exactly "abscissa[index]".
95	Otherwise, "x" is smaller than the first value in "abscissa" (hence the returned value should be "ordinate[0]").

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Subtract.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Tan.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Tanh.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/function/Ulp.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/FunctionUtils.xml
544	delegate computation to underlying function
555	extract partial derivative
569	delegate computation to underlying function
576	extract gradient
544	delegate computation to underlying function
555	extract partial derivative
544	delegate computation to underlying function
555	extract partial derivative
569	delegate computation to underlying function
576	extract gradient
569	delegate computation to underlying function
576	extract gradient
622	check parameters and orders limits
630	check all elements in the array are consistent
641	delegate computation to underlying function
649	merge value and gradient into one DerivativeStructure
622	check parameters and orders limits
630	check all elements in the array are consistent
641	delegate computation to underlying function
649	merge value and gradient into one DerivativeStructure
690	delegate computation to underlying function
697	extract Jacobian
690	delegate computation to underlying function
697	extract Jacobian
690	delegate computation to underlying function
697	extract Jacobian
745	check parameters and orders limits
753	check all elements in the array are consistent
764	delegate computation to underlying function
772	merge value and Jacobian into a DerivativeStructure array
745	check parameters and orders limits
753	check all elements in the array are consistent
764	delegate computation to underlying function
772	merge value and Jacobian into a DerivativeStructure array

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/BaseAbstractUnivariateIntegrator.xml
116	accuracy settings
120	iterations count settings
131	prepare evaluations counter, but do not set it yet
241	Checks.
245	Reset.
261	Initialization.
264	Perform computation.

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/gauss/BaseRuleFactory.xml
64	Try to obtain the rule from the cache.
68	Rule not computed yet.
70	Compute the rule.
74	Cache it.
78	Return a copy.
99	The rule should be available now.

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegratorFactory.xml
135	Scaling

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/gauss/LegendreHighPrecisionRuleFactory.xml
70	Break recursion.
75	Get previous rule. If it has not been computed yet it will trigger a recursive call to this method.
80	Compute next rule.
84	Find i-th root of P[n+1] by bracketing.
87	Lower-bound of the interval.
89	Upper-bound of the interval.
91	P[j-1](a)
93	P[j](a)
95	P[j-1](b)
97	P[j](b)
104	Compute P[j+1](a) ppa = ((2 * j + 1) * a * pa - j * pma) / (j + 1);
110	P[j+1](a)
114	Compute P[j+1](b) ppb = ((2 * j + 1) * b * pb - j * pmb) / (j + 1);
120	P[j+1](b)
129	Now pa = P[n+1](a), and pma = P[n](a). Same holds for b. Middle of the interval.
132	P[j-1](c)
134	P[j](c)
148	Compute P[j+1](c)
152	P[j+1](c)
159	Now pc = P[n+1](c) and pmc = P[n](c).
189	If "numberOfPoints" is odd, 0 is a root. Note: as written, the test for oddness will work for negative integers too (although it is not necessary here), preventing a FindBugs warning.
199	pmc = -j * pmc / (j + 1);
205	2 / pow(numberOfPoints * pmc, 2);

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/gauss/LegendreRuleFactory.xml
41	Break recursion.
46	Get previous rule. If it has not been computed yet it will trigger a recursive call to this method.
51	Compute next rule.
55	Find i-th root of P[n+1] by bracketing.
58	Lower-bound of the interval.
60	Upper-bound of the interval.
62	P[j-1](a)
64	P[j](a)
66	P[j-1](b)
68	P[j](b)
73	P[j+1](a)
75	P[j+1](b)
82	Now pa = P[n+1](a), and pma = P[n](a) (same holds for b). Middle of the interval.
85	P[j-1](c)
87	P[j](c)
95	P[j+1](c)
100	Now pc = P[n+1](c) and pmc = P[n](c).
124	If "numberOfPoints" is odd, 0 is a root. Note: as written, the test for oddness will work for negative integers too (although it is not necessary here), preventing a FindBugs warning.

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/gauss/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/IterativeLegendreGaussIntegrator.xml
115	Compute first estimate with a single step.
120	Improve integral with a larger number of steps.
123	Estimate the error.
129	check convergence
135	Prepare next iteration.
153	Function to be integrated is stored in the base class.
167	Integrate over each sub-interval [a, b].

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/LegendreGaussIntegrator.xml
209	compute first estimate with a single step
215	improve integral with a larger number of steps
218	estimate error
224	check convergence
229	prepare next iteration
249	set up the step for the current stage
253	integrate over all elementary steps

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/RombergIntegrator.xml
118	switch rows
126	Richardson extrapolation coefficient

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/SimpsonIntegrator.xml
110	Simpson's rule requires at least two trapezoid stages.

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/TrapezoidIntegrator.xml
129	number of new points in this stage
133	spacing between adjacent new points
135	the first new point
140	add the new sum to previously calculated result

Commons/xml/main/java/org/apache/commons/math3/analysis/integration/UnivariateIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.xml
57	Samples (first index is y-coordinate, i.e. subarray variable is x) 0 <= i < xval.length 0 <= j < yval.length fX[j][i] = f(xval[i], yval[j])
74	For each line y[j] (0 <= j < yLen), construct a 1D spline with respect to variable x
81	For each line x[i] (0 <= i < xLen), construct a 1D spline with respect to variable y generated by array fY_1[i]
88	Partial derivatives with respect to x at the grid knots
97	Partial derivatives with respect to y at the grid knots
106	Cross partial derivatives
120	Create the interpolating splines

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/DividedDifferenceInterpolator.xml
60	a[] and c[] are defined in the general formula of Newton form: p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... + a[n](x-c[0])(x-c[1])...(x-c[n-1])
67	When used for interpolation, the Newton form formula becomes p(x) = f[x0] + f[x0,x1](x-x0) + f[x0,x1,x2](x-x0)(x-x1) + ... + f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2]) Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k]. <p> Note x[], y[], a[] have the same length but c[]'s size is one less.<p>
106	initialization

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/FieldHermiteInterpolator.xml
109	update the bottom diagonal of the divided differences array
125	update the top diagonal of the divided differences array
128	update the abscissae array
143	safety check
174	safety check

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.xml
101	update the bottom diagonal of the divided differences array
117	update the top diagonal of the divided differences array
120	update the abscissae array
134	safety check
137	iteration initialization
145	build the polynomials by iterating on the top diagonal of the divided differences array
172	safety check
204	safety check

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/LinearInterpolator.xml
60	Number of intervals.  The number of data points is n + 1.
65	Slope of the lines between the datapoints.

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/LoessInterpolator.xml
260	Do an initial fit and 'robustnessIters' robustness iterations. This is equivalent to doing 'robustnessIters+1' robustness iterations starting with all robustness weights set to 1.
267	At each x, compute a local weighted linear regression
271	Find out the interval of source points on which a regression is to be made.
280	Compute the point of the bandwidth interval that is farthest from x
289	Compute a least-squares linear fit weighted by the product of robustness weights and the tricube weight function. See http:en.wikipedia.org/wiki/Linear_regression (section "Univariate linear case") and http:en.wikipedia.org/wiki/Weighted_least_squares (section "Weighted least squares")
333	No need to recompute the robustness weights at the last iteration, they won't be needed anymore
339	Recompute the robustness weights.
341	Find the median residual. An arraycopy and a sort are completely tractable here, because the preceding loop is a lot more expensive
420	The right edge should be adjusted if the next point to the right is closer to xval[i] than the leftmost point of the current interval

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/MicrosphereInterpolatingFunction.xml
172	Copy data samples.
187	Generate the microsphere, assuming that a fairly large number of randomly generated normals will represent a sphere.
202	Reset.
207	Compute contribution of each sample points to the microsphere elements illumination
210	Vector between interpolation point and current sample point.
215	No need to interpolate, as the interpolation point is actually (very close to) one of the sampled points.
227	Interpolation calculation.

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/MicrosphereInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/MultivariateInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/NevilleInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.xml
121	For each line y[j] (0 <= j < yLen), construct a polynomial, with respect to variable x, fitting array fval[][j]
130	Initial guess for the fit is zero for each coefficients (of which there are "xDegree" + 1).
135	For every knot (xval[i], yval[j]) of the grid, calculate corrected values fval_1
145	For each line x[i] (0 <= i < xLen), construct a polynomial, with respect to variable y, fitting array fval_1[i][]
154	Initial guess for the fit is zero for each coefficients (of which there are "yDegree" + 1).
159	For every knot (xval[i], yval[j]) of the grid, calculate corrected values fval_2

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/SplineInterpolator.xml
80	Number of intervals.  The number of data points is n + 1.
85	Differences between knot points
103	cubic spline coefficients --  b is linear, c quadratic, d is cubic (original y's are constants)

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.xml
58	Samples, re-ordered as (z, x, y) and (y, z, x) tuplets fvalXY[k][i][j] = f(xval[i], yval[j], zval[k]) fvalZX[j][k][i] = f(xval[i], yval[j], zval[k])
83	For each line x[i] (0 <= i < xLen), construct a 2D spline in y and z
90	For each line y[j] (0 <= j < yLen), construct a 2D spline in z and x
97	For each line z[k] (0 <= k < zLen), construct a 2D spline in x and y
104	Partial derivatives wrt x and wrt y
121	Partial derivatives wrt y and wrt z
136	Partial derivatives wrt x and wrt z
149	Third partial cross-derivatives
161	XXX Not sure about this formula
171	Create the interpolating splines

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/interpolation/UnivariatePeriodicInterpolator.xml
105	Wrap to enable interpolation at the boundaries.

Commons/xml/main/java/org/apache/commons/math3/analysis/MultivariateFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/MultivariateMatrixFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/MultivariateVectorFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/ParametricUnivariateFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/polynomials/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.xml
171	identify the lowest degree polynomial
175	build the coefficients array
196	identify the lowest degree polynomial
200	build the coefficients array

Commons/xml/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionLagrangeForm.xml
83	Second check in case some abscissa is duplicated.
180	Array is not sorted.
187	Second check in case some abscissa is duplicated.
215	initialize the difference arrays
218	find out the abscissa closest to z
226	initial approximation to the function value at z
234	update the difference arrays
239	sum up the difference terms to get the final value
241	fork down
244	fork up
264	c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])
277	d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])
285	Lagrange polynomial is the sum of n terms, each of which is a polynomial of degree n-1. tc[] are the coefficients of the i-th numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).
288	actually c[n] = 1

Commons/xml/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionNewtonForm.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialSplineFunction.xml
145	This will handle the case where v is the last knot value There are only n-1 polynomials, so if v is the last knot then we will use the last polynomial to calculate the value.
189	This will handle the case where t is the last knot value There are only n-1 polynomials, so if t is the last knot then we will use the last polynomial to calculate the value.

Commons/xml/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialsUtils.xml
217	select the appropriate list
222	allocate a new list for v, w
226	Pv,w,0(x) = 1;
229	P1(x) = (v - w) / 2 + (2 + v + w) * X / 2
328	Pascal triangle.
336	First polynomial coefficient.
341	Superior order.
371	coefficient  for polynomial 0 is  l [0] coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1) coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2) coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3) coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4) coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5) coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6) ...
386	build the polynomial
404	start indices of two previous polynomials Pk(X) and Pk-1(X)
408	Pk+1(X) = (a[0] + a[1] X) Pk(X) - a[2] Pk-1(X)
414	degree 0 coefficient
417	degree 1 to degree k-1 coefficients
425	degree k coefficient
430	degree k+1 coefficient

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/AbstractDifferentiableUnivariateSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/AbstractPolynomialSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/AbstractUnivariateDifferentiableSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/AbstractUnivariateSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/AllowedSolution.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.xml
177	Checks.
180	Reset.
193	Initialization.
196	Perform computation.

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/BaseSecantSolver.xml
138	Get initial solution
144	If one of the bounds is the exact root, return it. Since these are not under-approximations or over-approximations, we can return them regardless of the allowed solutions.
154	Verify bracketing of initial solution.
157	Get accuracies.
162	Keep track of inverted intervals, meaning that the left bound is larger than the right bound.
166	Keep finding better approximations.
168	Calculate the next approximation.
172	If the new approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions.
179	Update the bounds with the new approximation.
181	The value of x1 has switched to the other bound, thus inverting the interval.
195	Detect early that algorithm is stuck, instead of waiting for the maximum number of iterations to be exceeded.
202	Should never happen.
206	Update from [x0, x1] to [x0, x].
210	If the function value of the last approximation is too small, given the function value accuracy, then we can't get closer to the root than we already are.
242	If the current interval is within the given accuracies, we are satisfied with the current approximation.

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/BaseUnivariateSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/BisectionSolver.xml
80	max and m bracket the root.
83	min and m bracket the root.

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.xml
150	prepare arrays with the first points
158	evaluate initial guess
161	return the initial guess if it is a perfect root.
165	evaluate first  endpoint
168	return the first endpoint if it is a perfect root.
176	reduce interval if it brackets the root
182	evaluate second endpoint
185	return the second endpoint if it is a perfect root.
190	use all computed point as a start sampling array for solving
199	prepare a work array for inverse polynomial interpolation
202	current tightest bracketing of the root
212	search loop
215	check convergence of bracketing interval
231	this should never happen
236	target for the next evaluation point
239	we keep updating the high bracket, try to compensate this
245	we keep updating the low bracket, try to compensate this
251	bracketing is balanced, try to find the root itself
255	make a few attempts to guess a root,
261	guess a value for current target, using inverse polynomial interpolation
266	the guessed root is not strictly inside of the tightest bracketing interval
268	the guessed root is either not strictly inside the interval or it is a NaN (which occurs when some sampling points share the same y) we try again with a lower interpolation order
272	we have more points before the sign change, drop the lowest point
275	we have more points after sign change, drop the highest point
279	we need to do one more attempt
287	fall back to bisection
293	evaluate the function at the guessed root
296	we have found an exact root, since it is not an approximation we don't need to bother about the allowed solutions setting
303	we have been forced to ignore some points to keep bracketing, they are probably too far from the root, drop them from now on
312	we have to drop one point in order to insert the new one
315	keep the tightest bracketing interval as centered as possible
317	we drop the lowest point, we have to shift the arrays and the index
325	insert the last computed point (by construction, we know it lies inside the tightest bracketing interval)
333	update the bracketing interval
335	the sign change occurs before the inserted point
342	the sign change occurs after the inserted point
349	update the sign change index
375	compute Q Newton coefficients by divided differences
383	evaluate Q(targetY)

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/BrentSolver.xml
96	Return the initial guess if it is good enough.
102	Return the first endpoint if it is good enough.
108	Reduce interval if min and initial bracket the root.
113	Return the second endpoint if it is good enough.
119	Reduce interval if initial and max bracket the root.
176	Force bisection.
183	The equality test (a == c) is intentional, it is part of the original Brent's method and it should NOT be replaced by proximity test.
187	Linear interpolation.
191	Inverse quadratic interpolation.
206	Inverse quadratic interpolation gives a value in the wrong direction, or progress is slow. Fall back to bisection.

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/DifferentiableUnivariateSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/IllinoisSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/LaguerreSolver.xml
104	Return the initial guess if it is good enough.
110	Return the first endpoint if it is good enough.
116	Reduce interval if min and initial bracket the root.
121	Return the second endpoint if it is good enough.
127	Reduce interval if initial and max bracket the root.
166	Solve all roots and select the one we are seeking.
284	Coefficients for deflated polynomial.
290	Solve individual roots successively.
296	Polynomial deflation using synthetic division.
346	Compute pv (polynomial value), dv (derivative value), and d2v (second derivative value) simultaneously.
358	Check for convergence.
368	Now pv != 0, calculate the new approximation.
373	Choose a denominator larger in magnitude.
378	Perturb z if denominator is zero, for instance, p(x) = x^3 + 1, z = 0.

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/MullerSolver.xml
97	check for zeros before verifying bracketing
138	[x0, x2] is the bracketing interval in each iteration x1 is the last approximation and an interpolation point in (x0, x2) x is the new root approximation and new x1 for next round d01, d12, d012 are divided differences
152	Muller's method employs quadratic interpolation through x0, x1, x2 and x is the zero of the interpolating parabola. Due to bracketing condition, this parabola must have two real roots and we choose one in [x0, x2] to be x.
163	xplus and xminus are two roots of parabola and at least one of them should lie in (x0, x2)
168	check for convergence
175	Bisect if convergence is too slow. Bisection would waste our calculation of x, hopefully it won't happen often. the real number equality test x == x1 is intentional and completes the proximity tests above it
182	prepare the new bracketing interval for next iteration

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/MullerSolver2.xml
98	x2 is the last root approximation x is the new approximation and new x2 for next round x0 < x1 < x2 does not hold here
122	quadratic interpolation through x0, x1, x2
131	choose a denominator larger in magnitude
136	take the modulus of (B +/- FastMath.sqrt(delta))
141	perturb x if it exactly coincides with x1 or x2 the equality tests here are intentional
147	extremely rare case, get a random number to skip it
153	check for convergence
160	prepare the next iteration

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/NewtonSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/PegasusSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/PolynomialSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/RiddersSolver.xml
74	[x1, x2] is the bracketing interval in each iteration x3 is the midpoint of [x1, x2] x is the new root approximation and an endpoint of the new interval
82	check for zeros before verifying bracketing
97	calculate the new root approximation
103	delta > 1 due to bracketing
106	correction != 0
109	check for convergence
118	prepare the new interval for next iteration Ridders' method guarantees x1 < x < x2
120	x1 < x < x3
130	x3 < x < x2

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/SecantSolver.xml
79	Get initial solution
85	If one of the bounds is the exact root, return it. Since these are not under-approximations or over-approximations, we can return them regardless of the allowed solutions.
95	Verify bracketing of initial solution.
98	Get accuracies.
103	Keep finding better approximations.
105	Calculate the next approximation.
109	If the new approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions.
116	Update the bounds with the new approximation.
122	If the function value of the last approximation is too small, given the function value accuracy, then we can't get closer to the root than we already are.
129	If the current interval is within the given accuracies, we are satisfied with the current approximation.

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/UnivariateSolver.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/solvers/UnivariateSolverUtils.xml
109	no further bracketing required
113	find a very small interval bracketing the root
124	compute the root on the selected side
128	try increasing the interval
132	increasing function
139	decreasing function
146	unknown variation
151	update the lower bound
158	update the higher bound

Commons/xml/main/java/org/apache/commons/math3/analysis/TrivariateFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/UnivariateFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/UnivariateMatrixFunction.xml

Commons/xml/main/java/org/apache/commons/math3/analysis/UnivariateVectorFunction.xml

Commons/xml/main/java/org/apache/commons/math3/complex/Complex.xml
61	CHECKSTYLE: stop ConstantName
64	CHECKSTYLE: resume ConstantName
447	we don't use isInfinite() to avoid testing for NaN again
488	we don't use isInfinite() to avoid testing for NaN again
1148	nth root of abs -- faster / more accurate to use a solver here?
1151	Compute nth roots of complex number with k = 0, 1, ... n-1
1156	inner part

Commons/xml/main/java/org/apache/commons/math3/complex/ComplexField.xml
67	CHECKSTYLE: stop HideUtilityClassConstructor
75	CHECKSTYLE: resume HideUtilityClassConstructor
81	return the singleton instance

Commons/xml/main/java/org/apache/commons/math3/complex/ComplexFormat.xml
208	format real
212	format sign and imaginary
247	Remove the character "1" if it is the only one.
373	parse whitespace
376	parse real
379	invalid real number set index back to initial, error index should already be set
385	parse sign
391	no sign return real only complex number
401	invalid sign set index back to initial, error index should be the last character examined.
409	parse whitespace
412	parse imaginary
415	invalid imaginary number set index back to initial, error index should already be set
421	parse imaginary character

Commons/xml/main/java/org/apache/commons/math3/complex/ComplexUtils.xml

Commons/xml/main/java/org/apache/commons/math3/complex/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/complex/Quaternion.xml
127	Components of the first quaternion.
133	Components of the second quaternion.
139	Components of the product.
289	"Effective Java" (second edition, p. 47).
346	The quaternion of rotation (normalized quaternion) q and -q are equivalent (i.e. represent the same rotation).

Commons/xml/main/java/org/apache/commons/math3/complex/RootsOfUnity.xml
127	avoid repetitive calculations
134	calculate everything from scratch

Commons/xml/main/java/org/apache/commons/math3/dfp/BracketingNthOrderBrentSolverDFP.xml
184	Checks.
187	Reset.
193	prepare arrays with the first points
200	evaluate initial guess
204	return the initial guess if it is a perfect root.
208	evaluate first  endpoint
212	return the first endpoint if it is a perfect root.
220	reduce interval if it brackets the root
226	evaluate second endpoint
230	return the second endpoint if it is a perfect root.
235	use all computed point as a start sampling array for solving
245	prepare a work array for inverse polynomial interpolation
248	current tightest bracketing of the root
260	search loop
263	check convergence of bracketing interval
281	this should never happen
286	target for the next evaluation point
289	we keep updating the high bracket, try to compensate this
292	we keep updating the low bracket, try to compensate this
295	bracketing is balanced, try to find the root itself
299	make a few attempts to guess a root,
305	guess a value for current target, using inverse polynomial interpolation
310	the guessed root is not strictly inside of the tightest bracketing interval
312	the guessed root is either not strictly inside the interval or it is a NaN (which occurs when some sampling points share the same y) we try again with a lower interpolation order
316	we have more points before the sign change, drop the lowest point
319	we have more points after sign change, drop the highest point
323	we need to do one more attempt
331	fall back to bisection
337	evaluate the function at the guessed root
341	we have found an exact root, since it is not an approximation we don't need to bother about the allowed solutions setting
348	we have been forced to ignore some points to keep bracketing, they are probably too far from the root, drop them from now on
357	we have to drop one point in order to insert the new one
360	keep the tightest bracketing interval as centered as possible
362	we drop the lowest point, we have to shift the arrays and the index
370	insert the last computed point (by construction, we know it lies inside the tightest bracketing interval)
378	update the bracketing interval
380	the sign change occurs before the inserted point
387	the sign change occurs after the inserted point
394	update the sign change index
420	compute Q Newton coefficients by divided differences
428	evaluate Q(targetY)

Commons/xml/main/java/org/apache/commons/math3/dfp/Dfp.xml
679	Note that shiftRight() does not call round() as that round() itself
2676	TODO: deactivate this implementation (and return type) in 4.0
2687	TODO: activate this implementation (and return type) in 4.0 /** {@inheritDoc} * @since 3.2 */ public Dfp log10() { return DfpMath.log(this).divide(DfpMath.log(newInstance(10))); }
214	initialize as if 0
221	special case for Long.MIN_VALUE (-9223372036854775808) we must shift it before taking its absolute value
227	set the sign
244	remove the shift added for Long.MIN_VALUE we know in this case that fixing the last digit is sufficient
261	initialize as if 0
273	Zero or sub-normal
275	make sure 0 has the right sign
284	Normalize the subnormal number
293	infinity or NAN
308	Divide by 2^52, then add one
339	initialize as if 0
347	size of radix in decimal digits
348	Starting offset into Striped
351	Check some special cases
370	Check for scientific notation
372	try upper case?
379	scientific notation
400	normal case
404	If there is a minus sign in the number then it is negative
409	First off, find all of the leading zeros, trailing zeros, and significant digits
412	Move p to first significant digit
434	Copy the string onto Stripped
446	Don't want to run pass the end of the array
470	If the decimal point has been found then get rid of trailing zeros.
485	special case of numbers like "0.00000"
490	Implicit decimal point at end of number if not present
495	Find the number of significant trailing zeros
496	set q to point to first sig digit
506	Make sure the decimal is on a mod 10000 boundary
511	Make the mantissa length right by adding zeros at the end if necessary
518	Ok, now we know how many trailing zeros there are, and where the least significant digit is
532	Is there possible another digit?
599	make sure we don't mix number with different precision
715	Special case
727	Keep track of loss -- only signal inexact after losing 2 digits. the first lost digit is returned to add() and may be incorporated into the result.
758	make sure we don't mix number with different precision
783	make sure we don't mix number with different precision
949	Ignore the sign of zero
963	deal with the infinities
976	Handle special case when a or b is zero, by ignoring the exponents
987	compare the mantissas
1039	IEEE 854-1987 says that if the result is zero, then it carries the sign of this
1064	a is zero
1068	If the exponent is less than zero then we can certainly
1077	If the exponent is greater than or equal to digits, then it must already be an integer since there is no precision left
1085	General case:  create another dfp, result, that contains the
1098	then we must increment the mantissa by one
1105	then we must increment the mantissa by one
1113	difference between this and result
1114	force positive (take abs)
1130	signal inexact
1262	make sure we don't mix number with different precision
1321	Handle special case when a or b is zero, by setting the exponent of the zero number equal to the other one.  This avoids an alignment
1360	handle overflow -- note, when asign!=bsign an overflow is
1391	Unless adding 2 negative zeros, sign is positive
1392	Per IEEE 854-1987 Section 6.3
1434	round up if n!=0
1438	round half up
1442	round half down
1446	round half-even
1450	round half-odd
1454	round ceil
1459	round floor
1464	increment if necessary
1478	check for exceptional cases and raise signals if necessary
1480	Gradual Underflow
1486	Overflow
1492	Inexact
1507	make sure we don't mix number with different precision
1555	Big enough to hold even the largest result
1558	acts as a carry
1560	multiply the 2 digits
1561	add to the product digit with carry in
1569	Find the most sig digit
1570	default, in case result is zero
1578	Copy the digits into the result
1583	Fixup the exponent.
1588	if result is zero, set exp to zero
1596	has no effect except to check status
1670	if result is zero, set exp to zero
1687	current status of the dividend
1688	quotient
1689	remainder
1690	current quotient digit we're working with
1691	number of significant quotient digits we have
1692	trial quotient digit
1693	minimum adjustment
1694	Flag to indicate a good trail digit
1695	most sig digit in result
1696	exceptions
1698	make sure we don't mix number with different precision
1749	one extra digit needed
1750	two extra digits needed 1 for overflow, 1 for rounding
1751	one extra digit needed
1760	copy our mantissa into the dividend, initialize the
1774	r =  most sig 2 digits of dividend
1781	try the mean
1794	carry in to aid the subtraction
1803	trial is too big -- negative remainder
1813	update the minimum
1817	May have a good one here, check more thoroughly.  Basically
1819	assume false
1845	We have enough for this mode
1850	We have enough digits
1862	default
1879	if result is zero, set exp to zero
1903	Handle special cases
1914	Test for divide by zero
1924	range check divisor
1944	normalize
1946	compute the next digit and put it in
1952	do the rounding
1972	check for unusual cases
1974	if zero
1980	if positive infinity
1999	if negative
2033	Now that we have the first pass estimate, compute the rest
2048	alternating between two values
2052	if dx is zero, break.  Note testing the most sig digit is a sufficient test since dx is normalized
2069	if non-finite exceptional cases
2097	Get all the digits
2106	Find the first non-zero one
2114	Now do the conversion
2121	there are non zero digits...
2139	Find the msd of the exponent
2147	Find the largest p such that p < e
2149	nothing to do
2212	Ensure we have a radix point!
2216	Suppress leading zeros
2225	Suppress trailing zeros
2230	Insert sign
2258	normal case, we are finite, non-zero
2265	0/0
2286	gradual underflow
2346	make sure we don't mix number with different precision
2354	if this is greater than x
2440	Find the exponent, first estimate by integer log10, then adjust.
2476	Handle special case where we round up to next power of two
2580	Sign is currently OK
2583	flip sign
2591	Sign is currently OK
2594	flip sign
2743	compute r = sqrt(x^2+y^2)
2748	compute atan2(y, x) = 2 atan(y / (r + x))
2753	compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))

Commons/xml/main/java/org/apache/commons/math3/dfp/DfpDec.xml
131	make sure we don't mix number with different precision
170	special case -- this == zero
197	not looking at this after this point
200	look to the next digit for rounding
210	need to know if there are any discarded bits
223	round up if n!=0
227	round half up
231	round half down
237	round half-even
243	round half-odd
247	round ceil
252	round floor
257	increment if necessary
271	Check for exceptional cases and raise signals if necessary
273	Gradual Underflow
279	Overflow
285	Inexact
298	make sure we don't mix number with different precision
310	if this is greater than x

Commons/xml/main/java/org/apache/commons/math3/dfp/DfpField.xml
79	Note: the static strings are set up (once) by the ctor and @GuardedBy("DfpField.class")
202	set up transcendental constants
205	as a heuristic to circumvent Table-Maker's Dilemma, we set the string representation of the constants to be at least 3 times larger than the number of decimal digits, also as an attempt to really compute these constants only once, we set a minimum number of digits
211	set up the constants at current field accuracy
229	dummy settings for unused constants
581	recompute the string representation of the transcendental constants
618	The formula converges quartically. This means the number of correct digits is multiplied by 4 at each iteration! Five iterations are sufficient for about 160 digits, eight iterations give about 10000 digits (this has been checked) and 20 iterations more than 160 billions of digits (this has NOT been checked). So the limit here is considered sufficient for most purposes ...

Commons/xml/main/java/org/apache/commons/math3/dfp/DfpMath.xml
117	If result[0] is infinite or zero, don't compute result[1]. Attempting to do so may produce NaNs.
164	Special case a = 0
169	If a is less than zero
174	Exponentiate by successive squaring
219	Special case
228	Exponentiate by successive squaring
272	return +Infinity
277	return 0;
324	Check the arguments somewhat here
326	negative, zero or NaN
349	use spy[0] temporarily as a divisor
353	Use spy[0] for comparison
360	X is now in the range of 2/3 < x < 4/3
438	Now we want to compute x = (a-1)(a+1) but this is prone to loss of precision.  So instead, compute x = (a4 - 14)  (a4 + 14)
508	make sure we don't mix number with different precision
529	Test for NaNs
537	Test for NaNs
542	X == 0
545	X == +0
552	X == -0
554	If y is odd integer
561	Y is not odd integer
572	Make x positive, but keep track of it
599	x = +/- inf
601	negative infinity
603	If y is odd integer
610	Y is not odd integer
618	positive infinity
632	End special cases
653	very large exponent.  |y| > 1e8
658	if y is odd integer
684	1 over fact
717	1 over fact
749	Since sine(x) = sine(pi - x) we can reduce the range to 0 < x < pi2
763	y = sinInternal(c);
799	Since cos(x) = -cos(pi - x) we can reduce the range to 0 < x < pi2
917	x = x.subtract(ty).divide(dfp.one.add(x.multiply(ty)));
958	absolute value

Commons/xml/main/java/org/apache/commons/math3/dfp/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/dfp/UnivariateDfpFunction.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.xml
63	Legacy users are only allowed to access the deprecated "randomData". New users are forbidden to use this constructor.
115	this ensures cumulativeProbability(lower) < p, which is important for the solving step
124	use the one-sided Chebyshev inequality to narrow the bracket cf. AbstractRealDistribution.inverseCumulativeProbability(double)
162	Overflow. There will never be an overflow in both calculation methods for xm at the same time

Commons/xml/main/java/org/apache/commons/math3/distribution/AbstractMultivariateRealDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/AbstractRealDistribution.xml
69	Legacy users are only allowed to access the deprecated "randomData". New users are forbidden to use this constructor.
130	IMPLEMENTATION NOTES -------------------- Where applicable, use is made of the one-sided Chebyshev inequality to bracket the root. This inequality states that P(X - mu >= k  sig) <= 1  (1 + k^2), mu: mean, sig: standard deviation. Equivalently 1 - P(X < mu + k  sig) <= 1  (1 + k^2), F(mu + k  sig) >= k^2  (1 + k^2).  For k = sqrt(p  (1 - p)), we find F(mu + k  sig) >= p, and (mu + k  sig) is an upper-bound for the root.  Then, introducing Y = -X, mean(Y) = -mu, sd(Y) = sig, and P(Y >= -mu + k  sig) <= 1  (1 + k^2), P(-X >= -mu + k  sig) <= 1  (1 + k^2), P(X <= mu - k  sig) <= 1  (1 + k^2), F(mu - k  sig) <= 1  (1 + k^2).  For k = sqrt((1 - p)  p), we find F(mu - k  sig) <= p, and (mu - k  sig) is a lower-bound for the root.  In cases where the Chebyshev inequality does not apply, geometric progressions 1, 2, 4, ... and -1, -2, -4, ... are used to bracket the root.

Commons/xml/main/java/org/apache/commons/math3/distribution/BetaDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/BinomialDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/CauchyDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/ChiSquaredDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/EnumeratedDistribution.xml
200	This should never happen, but it ensures we will return a correct object in case the loop above has some floating point inequality
254	safe as both are of type T

Commons/xml/main/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/ExponentialDistribution.xml
209	Step 1:
213	Step 2 and 3:
219	Step 4 (now u >= 0.5):
222	Step 5:
227	Step 6:
228	Should be 1, be we iterate before it in while using 0
232	Step 7 and 8:
241	Step 8:
242	Ensured to exit since EXPONENTIAL_SA_QI[MAX] = 1

Commons/xml/main/java/org/apache/commons/math3/distribution/FDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/fitting/MultivariateNormalMixtureExpectationMaximization.xml
98	Jagged arrays not allowed
148	Number of data columns. Jagged data already rejected in constructor, so we can assume the lengths of each row are equal.
165	Initialize model to fit to initial mixture.
173	Mixture components
177	Weight and distribution of each component
187	E-step: compute the data dependent parameters of the expectation function. The percentage of row's total density between a row and a component
193	Sum of gamma for each component
196	Sum of gamma times its row for each each component
215	M-step: compute the new parameters based on the expectation function.
227	Compute new covariance matrices
242	Converting to arrays for use by fitted model
249	Update current model
256	Did not converge before the maximum number of iterations
319	sort the data
326	uniform weight for each bin
329	components of mixture model to be created
333	create a component based on data in each bin
335	minimum index (inclusive) from sorted data for this bin
338	maximum index (exclusive) from sorted data for this bin
341	number of data records that will be in this bin
344	data for this bin
347	mean of each column for the data in the this bin
350	populate bin and create component
361	covariance matrix for this bin
405	Store reference.
407	Compute mean.

Commons/xml/main/java/org/apache/commons/math3/distribution/fitting/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/GammaDistribution.xml
201	The present method must return the value of  1       x a     - x ---------- (-)  exp(---) x Gamma(a)  b        b  where a is the shape parameter, and b the scale parameter. Substituting the Lanczos approximation of Gamma(a) leads to the following expression of the density  a              e            1         y      a - sqrt(------------------) ---- (-----------)  exp(a - y + g), x      2 pi (a + g + 0.5)  L(a)  a + g + 0.5  where y = x  b. The above formula is the "natural" computation, which is implemented when no overflow is likely to occur. If overflow occurs with the natural computation, the following identity is used. It is based on the BOOST library http:www.boost.orgdoclibs1_35_0libsmathdocsf_and_disthtmlmath_toolkitspecialsf_gammaigamma.html Formula (15) needs adaptations, which are detailed below.  y      a (-----------)  exp(a - y + g) a + g + 0.5 y - a - g - 0.5    y (g + 0.5) = exp(a log1pm(---------------) - ----------- + g), a + g + 0.5      a + g + 0.5  where log1pm(z) = log(1 + z) - z. Therefore, the value to be returned is  a              e            1 - sqrt(------------------) ---- x      2 pi (a + g + 0.5)  L(a) y - a - g - 0.5    y (g + 0.5) exp(a log1pm(---------------) - ----------- + g). a + g + 0.5      a + g + 0.5
244	Overflow.
253	Natural calculation.
376	[1]: p. 228, Algorithm GS
379	Step 1:
385	Step 2:
391	Reject
397	Step 3:
403	Reject
412	Now shape >= 1
428	Squeeze

Commons/xml/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/IntegerDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/KolmogorovSmirnovDistribution.xml
164	n! f^n = n*f * (n-1)*f * ... * 1*x
208	BigFraction.doubleValue converts numerator to double and the denominator to double and divides afterwards. That gives NaN quite easy. This does not (scale is the number of digits):
233	Here the rounding part comes into play: use RealMatrix instead of FieldMatrix<BigFraction>
293	Start by filling everything with either 0 or 1.
306	Setting up power-array to avoid calculating the same value twice: hPowers[0] = h^1 ... hPowers[m-1] = h^m
316	First column and last row has special values (each other reversed).
324	[1] states: "For 12 < h < 1 the bottom left element of the matrix should be (1 - 2h^m + (2h - 1)^m )m!" Since 0 <= h < 1, then if h > 12 is sufficient to check:
333	Aside from the first column and last row, the (i, j)-th element is 1(i - j + 1)! if i - j + 1 >= 0, else 0. 1's and 0's are already put, so only division with (i - j + 1)! is needed in the elements that have 1's. There is no need to calculate (i - j + 1)! and then divide - small steps avoid overflows.  Note that i - j + 1 > 0 <=> i + 1 > j instead of j'ing all the way to m. Also note that it is started at g = 2 because dividing by 1 isn't really necessary.

Commons/xml/main/java/org/apache/commons/math3/distribution/LevyDistribution.xml
41	Setting this to 1 returns a cumProb of 1.0
144	there is a division by x-mu in the computation, so density is not finite at lower bound, bound must be excluded
151	upper bound is infinite, so it must be excluded

Commons/xml/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/MixtureMultivariateNormalDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/MixtureMultivariateRealDistribution.xml
84	Check for overflow.
89	Store each distribution and its normalized weight.
110	Sampled values.
113	Determine which component to sample from.
120	pick model i
127	This should never happen, but it ensures we won't return a null in case the loop above has some floating point inequality problem on the final iteration.
138	Seed needs to be propagated to underlying components in order to maintain consistency between runs.
143	Make each component's seed different in order to avoid using the same sequence of random numbers.

Commons/xml/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.xml
122	Covariance matrix eigen decomposition.
125	Compute and store the inverse.
127	Compute and store the determinant.
130	Eigenvalues of the covariance matrix.
139	Matrix where each column is an eigenvector of the covariance matrix.
148	Scale each eigenvector by the square root of its eigenvalue.

Commons/xml/main/java/org/apache/commons/math3/distribution/MultivariateRealDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/NormalDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/PascalDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/PoissonDistribution.xml
120	Use the same RNG instance as the parent class.
202	calculate the probability using half-correction

Commons/xml/main/java/org/apache/commons/math3/distribution/RealDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/SaddlePointExpansion.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/TDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/TriangularDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/distribution/WeibullDistribution.xml
155	FastMath.pow(x  scale, shape) = FastMath.pow(xscale, shape) = FastMath.pow(xscale, shape - 1)  xscale

Commons/xml/main/java/org/apache/commons/math3/distribution/ZipfDistribution.xml

Commons/xml/main/java/org/apache/commons/math3/exception/ConvergenceException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/DimensionMismatchException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MathArithmeticException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MathIllegalArgumentException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MathIllegalNumberException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MathIllegalStateException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MathInternalError.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MathParseException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MathRuntimeException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MathUnsupportedOperationException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MaxCountExceededException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/MultiDimensionMismatchException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NoBracketingException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NoDataException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NonMonotonicSequenceException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NotANumberException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NotFiniteNumberException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NotPositiveException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NotStrictlyPositiveException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NullArgumentException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NumberIsTooLargeException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/NumberIsTooSmallException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/OutOfRangeException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/exception/TooManyEvaluationsException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/TooManyIterationsException.xml

Commons/xml/main/java/org/apache/commons/math3/exception/util/ArgUtils.xml

Commons/xml/main/java/org/apache/commons/math3/exception/util/DummyLocalizable.xml

Commons/xml/main/java/org/apache/commons/math3/exception/util/ExceptionContext.xml
182	Add a separator if there are other messages.
225	Step 1.
228	Step 2.
231	Step 3.
235	Step 4.
239	Step 5a.
242	Step 5b.
259	Step 1.
263	Step 2.
265	Step 3.
268	Step 4.
272	Step 5.
287	Step 1.
291	Step 2.
295	Step 3a.
298	Step 3b.
314	Step 1.
318	Step 2.
320	Step 3.

Commons/xml/main/java/org/apache/commons/math3/exception/util/ExceptionContextProvider.xml

Commons/xml/main/java/org/apache/commons/math3/exception/util/Localizable.xml

Commons/xml/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.xml
387	the value of the resource is the translated format
391	NOPMD
392	do nothing here
395	either the locale is not supported or the resource is unknown don't translate and fall back to using the source format

Commons/xml/main/java/org/apache/commons/math3/exception/util/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/exception/ZeroException.xml

Commons/xml/main/java/org/apache/commons/math3/Field.xml

Commons/xml/main/java/org/apache/commons/math3/FieldElement.xml

Commons/xml/main/java/org/apache/commons/math3/filter/DefaultMeasurementModel.xml

Commons/xml/main/java/org/apache/commons/math3/filter/DefaultProcessModel.xml

Commons/xml/main/java/org/apache/commons/math3/filter/KalmanFilter.xml
136	create an empty matrix if no control matrix was given
147	check that the process and measurement noise matrices are not null they will be directly accessed from the model as they may change over time
155	set the initial state estimate to a zero vector if it is not available from the process model
168	initialize the error covariance to the process noise if it is not available from the process model
176	sanity checks, the control matrix B may be null
178	A must be a square matrix
185	row dimension of B must be equal to A
196	Q must be equal to A
199	column dimension of H must be equal to row dimension of A
207	row dimension of R must be equal to row dimension of H
298	sanity checks
305	project the state estimation ahead (a priori state) xHat(k)- = A * xHat(k-1) + B * u(k-1)
309	add control input if it is available
314	project the error covariance ahead P(k)- = A * P(k-1) * A' + Q
353	sanity checks
360	S = H * P(k) - * H' + R
365	invert S as the error covariance matrix is a symmetric positive semi-definite matrix, we can use the cholesky decomposition
371	Inn = z(k) - H * xHat(k)-
374	calculate gain matrix K(k) = P(k)- * H' * (H * P(k)- * H' + R)^-1 K(k) = P(k)- * H' * S^-1
379	update estimate with measurement z(k) xHat(k) = xHat(k)- + K * Inn
383	update covariance of prediction error P(k) = (I - K * H) * P(k)-

Commons/xml/main/java/org/apache/commons/math3/filter/MeasurementModel.xml

Commons/xml/main/java/org/apache/commons/math3/filter/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/filter/ProcessModel.xml

Commons/xml/main/java/org/apache/commons/math3/fitting/CurveFitter.xml
159	Prepare least squares problem.
169	Input to the optimizer: the model and its Jacobian.
172	Perform the fit.
180	Extract the coefficients.
203	compute the residuals
203	compute the residuals

Commons/xml/main/java/org/apache/commons/math3/fitting/GaussianFitter.xml
88	NOPMD
89	Do nothing.
101	NOPMD
102	Do nothing.
88	NOPMD
89	Do nothing.
101	NOPMD
102	Do nothing.
241	TODO: Exceptions should not be used for flow control.
338	Boundaries are replaced by dummy values because the raised exception is caught and the message never displayed. TODO: Exceptions should not be used for flow control.

Commons/xml/main/java/org/apache/commons/math3/fitting/HarmonicFitter.xml
234	Since the samples are almost always already sorted, this method is implemented as an insertion sort that reorders the elements in place. Insertion sort is very efficient in this case.
242	the current element should be inserted closer to the beginning
274	initialize the sums for the linear model between the two integrals
287	one step forward
293	update the integrals of f<sup>2</sup> and f'<sup>2</sup> considering a linear model for f (and therefore constant f')
312	compute the amplitude and pulsation coefficients
318	Range of the observations, assuming that the observations are sorted.
340	In some ill-conditioned cases (cf. MATH-844), the guesser procedure cannot produce sensible results.
359	initialize the means
366	one step forward

Commons/xml/main/java/org/apache/commons/math3/fitting/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/fitting/PolynomialFitter.xml

Commons/xml/main/java/org/apache/commons/math3/fitting/WeightedObservedPoint.xml

Commons/xml/main/java/org/apache/commons/math3/fraction/AbstractFormat.xml

Commons/xml/main/java/org/apache/commons/math3/fraction/BigFraction.xml
132	reduce numerator and denominator by greatest common denominator
139	move sign to numerator
145	store the values in the final fields
181	compute m and k such that value = m * 2^k
187	this was a normalized number, add the implicit most significant bit
280	check for (almost) integer arguments, which should not go to iterations.
435	normalize zero.
685	Numerator and/or denominator must be out of range: Calculate how far to shift them to put them in range.
738	Numerator and/or denominator must be out of range: Calculate how far to shift them to put them in range.

Commons/xml/main/java/org/apache/commons/math3/fraction/BigFractionField.xml
66	CHECKSTYLE: stop HideUtilityClassConstructor
74	CHECKSTYLE: resume HideUtilityClassConstructor
80	return the singleton instance

Commons/xml/main/java/org/apache/commons/math3/fraction/BigFractionFormat.xml
212	parse whitespace
215	parse numerator
218	invalid integer number set index back to initial, error index should already be set character examined.
225	parse '/'
230	no '/' return num as a BigFraction
234	found '/', continue parsing denominator
237	invalid '/' set index back to initial, error index should be the last character examined.
245	parse whitespace
248	parse denominator
251	invalid integer number set index back to initial, error index should already be set character examined.

Commons/xml/main/java/org/apache/commons/math3/fraction/Fraction.xml
186	check for (almost) integer arguments, which should not go to iterations.
271	reduce numerator and denominator by greatest common denominator.
278	move sign to numerator.
338	since fractions are always in lowest terms, numerators and denominators can be compared directly for equality.
481	zero is identity for addition.
488	if denominators are randomly distributed, d1 will be 1 about 61% of the time.
492	result is ( (u*v' +/- u'v) / u'v')
500	the quantity 't' requires 65 bits of precision; see knuth 4.5.1 exercise 7.  we're going to use a BigInteger. t = u(v'/d1) +/- v(u'/d1)
508	but d2 doesn't need extra precision because d2 = gcd(t,d1) = gcd(t mod d1, d1)
513	result is (t/d2) / (u'/d1)(v'/d2)
541	knuth 4.5.1 make sure we don't overflow unless the result *must* overflow.
618	normalize zero.
620	allow 2^k/-2^31 as a valid fraction (where k>0)
633	simplify fraction.

Commons/xml/main/java/org/apache/commons/math3/fraction/FractionConversionException.xml

Commons/xml/main/java/org/apache/commons/math3/fraction/FractionField.xml
66	CHECKSTYLE: stop HideUtilityClassConstructor
74	CHECKSTYLE: resume HideUtilityClassConstructor
80	return the singleton instance

Commons/xml/main/java/org/apache/commons/math3/fraction/FractionFormat.xml
217	parse whitespace
220	parse numerator
223	invalid integer number set index back to initial, error index should already be set character examined.
230	parse '/'
235	no '/' return num as a fraction
239	found '/', continue parsing denominator
242	invalid '/' set index back to initial, error index should be the last character examined.
250	parse whitespace
253	parse denominator
256	invalid integer number set index back to initial, error index should already be set character examined.

Commons/xml/main/java/org/apache/commons/math3/fraction/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/fraction/ProperBigFractionFormat.xml
137	try to parse improper BigFraction
145	parse whitespace
148	parse whole
151	invalid integer number set index back to initial, error index should already be set character examined.
158	parse whitespace
161	parse numerator
164	invalid integer number set index back to initial, error index should already be set character examined.
172	minus signs should be leading, invalid expression
177	parse '/'
182	no '/' return num as a BigFraction
186	found '/', continue parsing denominator
189	invalid '/' set index back to initial, error index should be the last character examined.
197	parse whitespace
200	parse denominator
203	invalid integer number set index back to initial, error index should already be set character examined.
211	minus signs must be leading, invalid

Commons/xml/main/java/org/apache/commons/math3/fraction/ProperFractionFormat.xml
137	try to parse improper fraction
145	parse whitespace
148	parse whole
151	invalid integer number set index back to initial, error index should already be set character examined.
158	parse whitespace
161	parse numerator
164	invalid integer number set index back to initial, error index should already be set character examined.
172	minus signs should be leading, invalid expression
177	parse '/'
182	no '/' return num as a fraction
186	found '/', continue parsing denominator
189	invalid '/' set index back to initial, error index should be the last character examined.
197	parse whitespace
200	parse denominator
203	invalid integer number set index back to initial, error index should already be set character examined.
211	minus signs must be leading, invalid

Commons/xml/main/java/org/apache/commons/math3/genetics/AbstractListChromosome.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/BinaryChromosome.xml
70	random binary list
80	type check
85	size check
95	all is ok

Commons/xml/main/java/org/apache/commons/math3/genetics/BinaryMutation.xml
49	randomly select a gene
51	and change it

Commons/xml/main/java/org/apache/commons/math3/genetics/Chromosome.xml
45	no cache - compute the fitness

Commons/xml/main/java/org/apache/commons/math3/genetics/ChromosomePair.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/CrossoverPolicy.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/CycleCrossover.xml
129	array representations of the parents
132	and of the children: do a crossover copy to simplify the later processing
136	the set of all visited indices so far
138	the indices of the current cycle
141	determine the starting index
152	add that index to the cycle indices
154	get the item in the second parent at that index
156	get the index of that item in the first parent
160	for even cycles: swap the child elements on the indices found in this cycle
170	find next starting index: last one + 1 until we find an unvisited index

Commons/xml/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.xml
85	initialize a new generation with the same parameters
92	index of the last "not good enough" chromosome

Commons/xml/main/java/org/apache/commons/math3/genetics/Fitness.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/FixedElapsedTime.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/FixedGenerationCount.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/GeneticAlgorithm.xml
156	select parent chromosomes
159	crossover?
161	apply crossover policy to create two offspring
165	mutation?
167	apply mutation policy to the chromosomes
173	add the first chromosome to the population
175	is there still a place for the second chromosome?
177	add the second chromosome to the population

Commons/xml/main/java/org/apache/commons/math3/genetics/InvalidRepresentationException.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/ListPopulation.xml
163	best so far
167	better chromosome found

Commons/xml/main/java/org/apache/commons/math3/genetics/MutationPolicy.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/NPointCrossover.xml
108	OK because of instanceof checks
139	array representations of the parents
142	and of the children
154	select the next crossover point at random
157	copy the current segment
163	swap the children for the next segment
171	copy the last segment

Commons/xml/main/java/org/apache/commons/math3/genetics/OnePointCrossover.xml
79	OK because of instanceof checks
105	array representations of the parents
108	and of the children
112	select a crossover point at random (0 and length makes no sense)
115	copy the first part
120	and switch the second part

Commons/xml/main/java/org/apache/commons/math3/genetics/OrderedCrossover.xml
97	array representations of the parents
100	and of the children
103	sets of already inserted items for quick access
108	choose random points, making sure that lb < ub.
114	determine the lower and upper bounds
118	add the subLists that are between lb and ub
124	iterate over every item in the parents
128	retrieve the current item in each parent
132	if the first child already contains the item in the second parent add it
138	if the second child already contains the item in the first parent add it
145	rotate so that the original slice is in the same place as in the parents.

Commons/xml/main/java/org/apache/commons/math3/genetics/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/PermutationChromosome.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/Population.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/RandomKey.xml
76	store the sorted representation
80	store the permutation of [0,1,...,n-1] list for toString() and isSame() methods
121	the size of the three lists must be equal
129	do not modify the original representation
132	now find the indices in the original repr and use them for permuting
151	type check
156	size check
161	two different representations can still encode the same permutation the ordering is what counts
171	the permutations are the same

Commons/xml/main/java/org/apache/commons/math3/genetics/RandomKeyMutation.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/SelectionPolicy.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/StoppingCondition.xml

Commons/xml/main/java/org/apache/commons/math3/genetics/TournamentSelection.xml
77	auxiliary population
80	not useful here
85	create a copy of the chromosome list
88	select a random individual and add it to the tournament
91	do not select it again
94	the winner takes it all
80	not useful here

Commons/xml/main/java/org/apache/commons/math3/genetics/UniformCrossover.xml
112	array representations of the parents
115	and of the children
124	swap the bits -> take other parent

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/oned/Euclidean1D.xml
66	CHECKSTYLE: stop HideUtilityClassConstructor
74	CHECKSTYLE: resume HideUtilityClassConstructor
80	return the singleton instance

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/oned/Interval.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.xml
97	the tree must cover the whole real line
100	the tree must be open on the negative infinity side
111	the tree must be open on the positive infinity side
118	the tree must be bounded on the two sides
227	this leaf cell is an inside cell: an interval
235	make sure we explore the tree in increasing order
244	merge the last interval added and the first one of the high sub-tree

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/oned/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1D.xml
42	CHECKSTYLE: stop ConstantName
45	CHECKSTYLE: resume ConstantName

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1DFormat.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/CardanEulerSingularityException.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/Euclidean3D.xml
58	CHECKSTYLE: stop HideUtilityClassConstructor
66	CHECKSTYLE: resume HideUtilityClassConstructor
72	return the singleton instance

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotation.xml
80	normalization preprocessing
168	dimension check
176	compute a "close" orthogonal matrix
179	check the sign of the determinant
221	build orthonormalized base from u1, u2 this fails when vectors are null or colinear, which is forbidden to define a rotation
227	build an orthonormalized base from v1, v2 this fails when vectors are null or colinear, which is forbidden to define a rotation
233	buid a matrix transforming the first base into the second one
276	special case u = -v: we select a PI angle rotation around an arbitrary vector orthogonal to u
284	general case: (u, v) defines a plane, we select the shortest possible rotation: axis orthogonal to this plane
335	There are different ways to compute the quaternions elements from the matrix. They all involve computing one element from the diagonal of the matrix, and computing the three other ones using a formula involving a division by the first element, which unfortunately can be zero. Since the norm of the quaternion is 1, we know at least one element has an absolute value greater or equal to 0.5, so it is always possible to select the right formula and avoid division by zero and even numerical inaccuracy. Checking the elements in turn and using the first one greater than 0.45 is safe (this leads to a simple test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
348	compute q0 and deduce q1, q2 and q3
357	compute q1 and deduce q0, q2 and q3
366	compute q2 and deduce q0, q1 and q3
373	compute q3 and deduce q0, q1 and q2
497	r (+K) coordinates are : sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi) (-r) (+I) coordinates are : cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
501	and we can choose to have theta in the interval [-PI/2 ; +PI/2]
513	r (+J) coordinates are : -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi) (-r) (+I) coordinates are : cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi) and we can choose to have psi in the interval [-PI/2 ; +PI/2]
529	r (+K) coordinates are : cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta) (-r) (+J) coordinates are : sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi) and we can choose to have phi in the interval [-PI/2 ; +PI/2]
545	r (+I) coordinates are : cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta) (-r) (+J) coordinates are : sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi) and we can choose to have psi in the interval [-PI/2 ; +PI/2]
561	r (+J) coordinates are : -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi) (-r) (+K) coordinates are : -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi) and we can choose to have phi in the interval [-PI/2 ; +PI/2]
577	r (+I) coordinates are : cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta) (-r) (+K) coordinates are : -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta) and we can choose to have theta in the interval [-PI/2 ; +PI/2]
593	r (+I) coordinates are : cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta) (-r) (+I) coordinates are : cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2) and we can choose to have theta in the interval [0 ; PI]
609	r (+I) coordinates are : cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi) (-r) (+I) coordinates are : cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2) and we can choose to have psi in the interval [0 ; PI]
625	r (+J) coordinates are : sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi) (-r) (+J) coordinates are : sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2) and we can choose to have phi in the interval [0 ; PI]
641	r (+J) coordinates are : -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi) (-r) (+J) coordinates are : sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2) and we can choose to have psi in the interval [0 ; PI]
657	r (+K) coordinates are : sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi) (-r) (+K) coordinates are : sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi) and we can choose to have phi in the interval [0 ; PI]
671	last possibility is ZYZ
673	r (+K) coordinates are : cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta) (-r) (+K) coordinates are : -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta) and we can choose to have theta in the interval [0 ; PI]
721	products
733	create the matrix
1089	iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)
1093	Mt.Xn
1104	Xn+1
1115	correction on each elements
1126	Frobenius norm of the correction
1131	convergence test
1136	prepare next iteration
1150	the algorithm did not converge after 10 iterations

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3D.xml
358	there are no cancellation problems here, so we use the straightforward formula
366	there are no cancellation problems here, so we use the straightforward formula
590	the vectors are almost aligned, compute using the sine
598	the vectors are sufficiently separated to use the cosine
626	the vectors are almost aligned, compute using the sine
634	the vectors are sufficiently separated to use the cosine

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.xml
179	lines are parallel
183	signed separation of the two parallel planes that contains the lines
199	the lines are parallel

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/NotARotationMatrixException.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/OutlineExtractor.xml
66	project all boundary facets into one polygons set
71	Remove the spurious intermediate vertices from the outline
79	the point should be removed
85	the point remains in the loop
90	resize the array
162	extract the vertices of the facet
174	the facet is seen from the inside, we need to invert its boundary orientation
193	use the reverted vertices
198	compute the projection of the facet in the outline plane
217	the previous point is a real vertex it defines one bounding point of the edge
226	the current point is a real vertex it defines one bounding point of the edge
244	add the contribution of the facet to the global outline

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.xml
278	make sure the frame is transformed as desired
295	make sure the frame is transformed as desired
341	coefficients of the three planes linear equations
357	direct Cramer resolution of the linear system (this is still feasible for a 3x3 system)

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.xml
135	compute the contribution of all boundary facets
139	the polyhedrons set as a finite outside surrounded by an infinite inside
144	the polyhedrons set is finite, apply the remaining scaling factors
243	establish search order
257	search in the cut hyperplane
264	search in the near branch
271	search in the cut hyperplane
281	search in the far branch
359	we have changed hyperplane, reset the in-hyperplane transform
426	we have changed hyperplane, reset the in-hyperplane transform

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.xml
140	normalization preprocessing
226	dimension check
234	compute a "close" orthogonal matrix
237	check the sign of the determinant
277	build orthonormalized base from u1, u2 this fails when vectors are null or colinear, which is forbidden to define a rotation
283	build an orthonormalized base from v1, v2 this fails when vectors are null or colinear, which is forbidden to define a rotation
289	buid a matrix transforming the first base into the second one
339	special case u = -v: we select a PI angle rotation around an arbitrary vector orthogonal to u
347	general case: (u, v) defines a plane, we select the shortest possible rotation: axis orthogonal to this plane
398	There are different ways to compute the quaternions elements from the matrix. They all involve computing one element from the diagonal of the matrix, and computing the three other ones using a formula involving a division by the first element, which unfortunately can be zero. Since the norm of the quaternion is 1, we know at least one element has an absolute value greater or equal to 0.5, so it is always possible to select the right formula and avoid division by zero and even numerical inaccuracy. Checking the elements in turn and using the first one greater than 0.45 is safe (this leads to a simple test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
411	compute q0 and deduce q1, q2 and q3
420	compute q1 and deduce q0, q2 and q3
429	compute q2 and deduce q0, q1 and q3
436	compute q3 and deduce q0, q1 and q2
559	r (Vector3D.plusK) coordinates are : sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi) (-r) (Vector3D.plusI) coordinates are : cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta) and we can choose to have theta in the interval [-PI/2 ; +PI/2]
577	r (Vector3D.plusJ) coordinates are : -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi) (-r) (Vector3D.plusI) coordinates are : cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi) and we can choose to have psi in the interval [-PI/2 ; +PI/2]
595	r (Vector3D.plusK) coordinates are : cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta) (-r) (Vector3D.plusJ) coordinates are : sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi) and we can choose to have phi in the interval [-PI/2 ; +PI/2]
613	r (Vector3D.plusI) coordinates are : cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta) (-r) (Vector3D.plusJ) coordinates are : sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi) and we can choose to have psi in the interval [-PI/2 ; +PI/2]
631	r (Vector3D.plusJ) coordinates are : -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi) (-r) (Vector3D.plusK) coordinates are : -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi) and we can choose to have phi in the interval [-PI/2 ; +PI/2]
649	r (Vector3D.plusI) coordinates are : cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta) (-r) (Vector3D.plusK) coordinates are : -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta) and we can choose to have theta in the interval [-PI/2 ; +PI/2]
667	r (Vector3D.plusI) coordinates are : cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta) (-r) (Vector3D.plusI) coordinates are : cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2) and we can choose to have theta in the interval [0 ; PI]
685	r (Vector3D.plusI) coordinates are : cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi) (-r) (Vector3D.plusI) coordinates are : cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2) and we can choose to have psi in the interval [0 ; PI]
703	r (Vector3D.plusJ) coordinates are : sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi) (-r) (Vector3D.plusJ) coordinates are : sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2) and we can choose to have phi in the interval [0 ; PI]
721	r (Vector3D.plusJ) coordinates are : -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi) (-r) (Vector3D.plusJ) coordinates are : sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2) and we can choose to have psi in the interval [0 ; PI]
739	r (Vector3D.plusK) coordinates are : sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi) (-r) (Vector3D.plusK) coordinates are : sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi) and we can choose to have phi in the interval [0 ; PI]
755	last possibility is ZYZ
757	r (Vector3D.plusK) coordinates are : cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta) (-r) (Vector3D.plusK) coordinates are : -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta) and we can choose to have theta in the interval [0 ; PI]
782	products
794	create the matrix
960	iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)
964	Mt.Xn
975	Xn+1
986	correction on each elements
997	Frobenius norm of the correction
1002	convergence test
1007	prepare next iteration
1021	the algorithm did not converge after 10 iterations

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/RotationOrder.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/Segment.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphericalCoordinates.xml
88	Cartesian coordinates
91	remaining spherical coordinates
110	spherical coordinates
115	Cartesian coordinates
165	lazy evaluation of Jacobian
168	compose derivatives as gradient^T . J the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0
201	compose derivative as J^T . H_f . J + df/dr H_r + df/dtheta H_theta + df/dphi H_phi the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0 and H_theta is only a 2x2 matrix as it does not depend on z
207	compute H_f . J beware we use ONLY the lower-left part of sHessian
214	don't compute hj[1][2] as it is not used below
219	compute lower-left part of J^T . H_f . J
227	add gradient contribution
235	ensure symmetry
249	intermediate variables
259	row representing the gradient of r
264	row representing the gradient of theta
267	jacobian[1][2] is already set to 0 at allocation time
269	row representing the gradient of phi
283	intermediate variables
302	lower-left part of Hessian of r
311	upper-right part is symmetric
316	lower-left part of Hessian of azimuthal angle theta
322	upper-right part is symmetric
325	lower-left part of Hessian of polar (co-latitude) angle phi
339	upper-right part is symmetric

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.xml
113	compute the intersection on infinite line
116	check location of point with respect to first sub-line
119	check location of point with respect to second sub-line

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubPlane.xml
62	the hyperplanes are parallel, any point can be used to check their relative position
68	create a 2D line in the otherPlane canonical 2D frame such that: - the line is the crossing line of the two planes in 3D - the line splits the otherPlane in two half planes with an orientation consistent with the orientation of the instance (i.e. the 3D half space on the plus side (resp. minus side) of the instance contains the 2D half plane on the plus side (resp. minus side) of the 2D line
86	check the side on the 2D plane
105	the hyperplanes are parallel
112	the hyperplanes do intersect

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.xml
62	CHECKSTYLE: stop ConstantName
65	CHECKSTYLE: resume ConstantName
243	there are no cancellation problems here, so we use the straightforward formula
249	there are no cancellation problems here, so we use the straightforward formula
360	the vectors are almost aligned, compute using the sine
368	the vectors are sufficiently separated to use the cosine

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DFormat.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/twod/Euclidean2D.xml
58	CHECKSTYLE: stop HideUtilityClassConstructor
66	CHECKSTYLE: resume HideUtilityClassConstructor
72	return the singleton instance

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.xml
353	CHECKSTYLE: stop JavadocVariable check
364	CHECKSTYLE: resume JavadocVariable check

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/twod/NestedLoops.xml
86	build the polygon defined by the loop
99	ensure the polygon encloses a finite region of the plane
125	check if we can go deeper in the tree
133	check if we can absorb some of the instance children
142	we should be separate from the remaining children
172	we need to inverse the original loop
182	go deeper in the tree

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/twod/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.xml
179	the tree represents the whole space
183	build the vertices
189	build the edges
193	get the endpoints of the edge
197	get the line supporting the edge, taking care not to recreate it if it was already created earlier due to another edge being aligned with the current one
205	create the edge and store it
208	check if another vertex also happens to be on this line
218	build the tree top-down
238	find an edge with an hyperplane that can be inserted in the node
255	no suitable edge was found, the node remains a leaf node we need to set its inside/outside boolean indicator
266	we have split the node by inserted an edge as a cut sub-hyperplane distribute the remaining edges in the two sub-trees
281	we need to insert a split point on the hyperplane
291	we need to insert a split point on the hyperplane
310	recurse through lower levels
451	connect the vertices back to the edge
529	the instance covers the whole space
537	there is at least one open-loop: the polygon is infinite
541	all loops are closed, we compute some integrals around the shape
563	the polygon as a finite outside surrounded by an infinite inside
604	sort the segments according to their start point
609	identify the loops, starting from the open ones (their start segments are naturally at the sorted set beginning)
620	tranform the loops in an array of arrays of points
626	single infinite line
634	open loop with at least one real point
640	null point and first dummy point
648	current point
653	last dummy point
695	is this an open or a closed loop ?
700	search the sub-hyperplane starting where the previous one ended
719	this is a degenerated loop, it probably comes from a very tiny region with some segments smaller than the threshold, we simply ignore it
732	this is a degenerated infinitely thin loop, we simply ignore it

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/twod/Segment.xml
91	r == 0 => P = startPt r == 1 => P = endPt r < 0 => P is on the backward extension of the segment r > 1 => P is on the forward extension of the segment 0 < r < 1 => P is on the segment
97	if point isn't on the line segment, just return the shortest distance to the end points
105	find point on line and see if it is in the line segment

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.xml
113	retrieve the underlying lines
117	compute the intersection on infinite line
120	check location of point with respect to first sub-line
123	check location of point with respect to second sub-line
161	the lines are parallel,
166	the lines do intersect
182	the lines are parallel
189	the lines do intersect

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.xml
40	CHECKSTYLE: stop ConstantName
43	CHECKSTYLE: resume ConstantName

Commons/xml/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2DFormat.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.xml
95	the tree represents the whole space
100	sort the boundary elements in decreasing size order (we don't want equal size elements to be removed, so we use a trick to fool the TreeSet)
112	build the tree top-down
116	set up the inside/outside flags
148	use the first hyperplane to build the right class
151	chop off parts of the space
180	build the current level
193	distribute the remaining edges in the two sub-trees
211	ignore the sub-hyperplanes belonging to the cut hyperplane
215	recurse through lower levels
234	we use a recursive function rather than the BSPTreeVisitor interface because we can stop visiting the tree as soon as we have found an inside cell
239	if we find an inside node, the region is not empty
243	check both sides of the sub-tree
268	the point is in the interior of a cell, just check the attribute
272	the point is on a cut-sub-hyperplane, is it on a boundary ?
282	we need to compute the boundary attributes
307	characterize the cut sub-hyperplane, first with respect to the plus sub-tree
314	plusChar[0] corresponds to a subset of the cut sub-hyperplane known to have outside cells on its plus side, we want to check if parts of this subset do have inside cells on their minus side
321	this part belongs to the boundary, it has the outside on its plus side and the inside on its minus side
328	plusChar[1] corresponds to a subset of the cut sub-hyperplane known to have inside cells on its plus side, we want to check if parts of this subset do have outside cells on their minus side
335	this part belongs to the boundary, it has the inside on its plus side and the outside on its minus side
341	set the boundary attribute at non-leaf nodes
366	we have reached a leaf node
396	this should not happen
474	this is an inside cell expanding across the hyperplane
484	the sub-hyperplane is entirely in the plus sub-tree
499	the sub-hyperplane is entirely in the minus sub-tree
514	the sub-hyperplane extends in both sub-trees
517	explore first the plus sub-tree
520	if needed, explore the minus sub-tree
526	the sub-hyperplane and the cut sub-hyperplane share the same hyperplane

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/BoundaryAttribute.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/BoundarySizeVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.xml
317	position of the point with respect to the cut hyperplane
323	point is on the minus side of the cut hyperplane
326	point is on the plus side of the cut hyperplane
387	cell/tree operation
390	tree/cell operation
393	tree/tree operation
404	merging phase
499	the partitioning sub-hyperplane is entirely in the plus sub-tree
515	the partitioning sub-hyperplane is entirely in the minus sub-tree
567	set up parent/child links
577	make sure the inserted tree lies in the cell defined by its parent nodes
580	explore the parent nodes from here towards tree root
583	this is an hyperplane of some parent node
586	chop off the parts of the inserted tree that extend on the wrong side of this parent hyperplane
600	since we may have drop some parts of the inserted tree, perform a condensation pass to keep the tree structure simple

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/BSPTreeVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/Embedding.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/Hyperplane.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/Region.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/RegionFactory.xml
49	use the first hyperplane to build the right class
52	chop off parts of the space
166	the leaf node represents an inside cell
170	the leaf node represents an outside cell
183	the leaf node represents an inside cell
187	the leaf node represents an outside cell
201	the leaf node represents an inside cell
216	the leaf node represents an inside cell
222	the leaf node represents an outside cell

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/Side.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/SubHyperplane.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/Transform.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.xml
85	loop over all elements neither smaller nor larger than the specified one
91	all the remaining elements are known to be larger, the element is not in the tree
351	the inserted element is smaller than the node
359	the inserted element is equal to or greater than the node
372	this was the last node, the tree is now empty

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.xml
161	instance cannot be sorted logically
168	encode the T-upple with the specified offset
184	choose an offset with some margins
189	the components are all zeroes
193	allocate an integer array to encode the components (we use only 63 bits per element because there is no unsigned long in Java)
199	mix the bits from all components
305	the following constants are arbitrary small primes
310	hash fields and combine them (we rely on the multiplier to have different combined weights for all int fields and all boolean fields)
353	subnormal number
354	normal number

Commons/xml/main/java/org/apache/commons/math3/geometry/partitioning/utilities/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/Space.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/Vector.xml

Commons/xml/main/java/org/apache/commons/math3/geometry/VectorFormat.xml
199	format prefix
202	format components
210	format suffix
246	parse prefix
254	skip whitespace
257	parse separator
262	skip whitespace
265	parse coordinate
268	invalid coordinate set index back to initial, error index should already be set
274	store coordinate
279	parse suffix

Commons/xml/main/java/org/apache/commons/math3/linear/AbstractFieldMatrix.xml
179	safety check
197	safety check
244	safety check
291	Only log_2(p) operations is used by doing as follows: 5^214 = 5^128  5^64  5^16  5^4  5^2  In general, the same approach is used for A^p.
366	safety checks
369	copy entries
392	safety checks
403	copy entries
435	safety checks
445	copy entries

Commons/xml/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.xml
975	Empty implementations of these methods are provided in order to allow for the use of the @Override tag with Java 1.5.
188	Only log_2(p) operations is used by doing as follows: 5^214 = 5^128  5^64  5^16  5^4  5^2  In general, the same approach is used for A^p.
204	The positions are taken in turn, so maxI is only changed once

Commons/xml/main/java/org/apache/commons/math3/linear/AnyMatrix.xml

Commons/xml/main/java/org/apache/commons/math3/linear/Array2DRowFieldMatrix.xml
232	safety check
260	safety check
289	safety check
594	can't copy 2-d array in one shot, otherwise get row references

Commons/xml/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.xml
165	Safety check.
227	Will hold a column of "m".
231	Multiply.
233	Copy all elements of column "col" of "m" so that will be in contiguous memory.
531	can't copy 2-d array in one shot, otherwise get row references

Commons/xml/main/java/org/apache/commons/math3/linear/ArrayFieldVector.xml
917	May fail, but we ignore ClassCastException
930	ignore exception

Commons/xml/main/java/org/apache/commons/math3/linear/ArrayRealVector.xml

Commons/xml/main/java/org/apache/commons/math3/linear/BiDiagonalTransformer.xml
75	transform matrix
100	fill up the part of the matrix not affected by Householder transforms
105	build up first part of the matrix by applying Householder transforms
129	return the cached matrix
160	return the cached matrix
181	fill up the part of the matrix not affected by Householder transforms
186	build up first part of the matrix by applying Householder transforms
210	return the cached matrix
264	zero-out a column
290	zero-out a row
328	zero-out a row
353	zero-out a column

Commons/xml/main/java/org/apache/commons/math3/linear/BlockFieldMatrix.xml
108	number of blocks
112	allocate storage blocks, taking care of smaller ones at right and bottom
158	number of blocks
163	allocate storage blocks, taking care of smaller ones at right and bottom
166	reference existing array
217	safety checks
225	convert array
238	allocate new block
242	copy data
307	create an empty matrix
310	copy the blocks
326	safety check
331	perform addition block-wise, to ensure good cache behavior
336	perform addition on the current block
351	go to next block
372	safety check
377	perform addition block-wise, to ensure good cache behavior
398	safety check
403	perform subtraction block-wise, to ensure good cache behavior
408	perform subtraction on the current block
423	go to next block
442	safety check
447	perform subtraction block-wise, to ensure good cache behavior
465	perform subtraction block-wise, to ensure good cache behavior
483	perform subtraction block-wise, to ensure good cache behavior
503	safety check
509	perform multiplication block-wise, to ensure good cache behavior
521	select current block
524	perform multiplication on current block
546	go to next block
566	safety check
572	perform multiplication block-wise, to ensure good cache behavior
585	select current block
588	perform multiplication on current block
620	go to next block
663	safety checks
666	create the output matrix
670	compute blocks shifts
676	perform extraction block-wise, to ensure good cache behavior
684	handle one block of the output matrix
693	the submatrix block spans on two blocks rows from the original matrix
695	the submatrix block spans on two blocks columns from the original matrix
714	the submatrix block spans on one block column from the original matrix
725	the submatrix block spans on one block row from the original matrix
727	the submatrix block spans on two blocks columns from the original matrix
738	the submatrix block spans on one block column from the original matrix
789	safety checks
804	compute blocks bounds
810	perform copy block-wise, to ensure good cache behavior
824	handle one block, row by row
843	perform copy block-wise, to ensure good cache behavior
900	perform copy block-wise, to ensure good cache behavior
929	perform copy block-wise, to ensure good cache behavior
984	perform copy block-wise, to ensure good cache behavior
1011	perform copy block-wise, to ensure good cache behavior
1043	perform copy block-wise, to ensure good cache behavior
1076	perform copy block-wise, to ensure good cache behavior
1100	perform copy block-wise, to ensure good cache behavior
1118	perform copy block-wise, to ensure good cache behavior
1144	perform copy block-wise, to ensure good cache behavior
1227	perform transpose block-wise, to ensure good cache behavior
1232	transpose current block
1250	go to next block
1280	perform multiplication block-wise, to ensure good cache behavior
1322	perform multiplication block-wise, to ensure good cache behavior

Commons/xml/main/java/org/apache/commons/math3/linear/BlockRealMatrix.xml
103	number of blocks
107	allocate storage blocks, taking care of smaller ones at right and bottom
154	number of blocks
159	allocate storage blocks, taking care of smaller ones at right and bottom
162	reference existing array
209	safety checks
217	convert array
229	allocate new block
233	copy data
291	create an empty matrix
294	copy the blocks
309	safety check
314	perform addition block-wise, to ensure good cache behavior
319	perform addition on the current block
333	go to next block
352	safety check
357	perform addition block-wise, to ensure good cache behavior
377	safety check
382	perform subtraction block-wise, to ensure good cache behavior
387	perform subtraction on the current block
401	go to next block
420	safety check
425	perform subtraction block-wise, to ensure good cache behavior
444	perform subtraction block-wise, to ensure good cache behavior
461	perform subtraction block-wise, to ensure good cache behavior
480	safety check
485	perform multiplication block-wise, to ensure good cache behavior
495	select current block
498	perform multiplication on current block
519	go to next block
537	safety check
542	perform multiplication block-wise, to ensure good cache behavior
555	select current block
558	perform multiplication on current block
588	go to next block
668	safety checks
671	create the output matrix
675	compute blocks shifts
681	perform extraction block-wise, to ensure good cache behavior
689	handle one block of the output matrix
698	the submatrix block spans on two blocks rows from the original matrix
700	the submatrix block spans on two blocks columns from the original matrix
719	the submatrix block spans on one block column from the original matrix
730	the submatrix block spans on one block row from the original matrix
732	the submatrix block spans on two blocks columns from the original matrix
743	the submatrix block spans on one block column from the original matrix
794	safety checks
809	compute blocks bounds
815	perform copy block-wise, to ensure good cache behavior
829	handle one block, row by row
848	perform copy block-wise, to ensure good cache behavior
905	perform copy block-wise, to ensure good cache behavior
934	perform copy block-wise, to ensure good cache behavior
989	perform copy block-wise, to ensure good cache behavior
1016	perform copy block-wise, to ensure good cache behavior
1048	perform copy block-wise, to ensure good cache behavior
1081	perform copy block-wise, to ensure good cache behavior
1105	perform copy block-wise, to ensure good cache behavior
1123	perform copy block-wise, to ensure good cache behavior
1149	perform copy block-wise, to ensure good cache behavior
1220	perform transpose block-wise, to ensure good cache behavior
1224	transpose current block
1241	go to next block
1270	perform multiplication block-wise, to ensure good cache behavior
1310	perform multiplication block-wise, to ensure good cache behavior

Commons/xml/main/java/org/apache/commons/math3/linear/CholeskyDecomposition.xml
118	check the matrix before transformation
122	check off-diagonal elements (and reset them to 0)
136	transform the matrix
141	check diagonal element
182	return the cached matrix
222	if we get this far, the matrix was positive definite, hence non-singular
235	Solve LY = b
245	Solve LTX = Y
267	Solve LY = b
284	Solve LTX = Y

Commons/xml/main/java/org/apache/commons/math3/linear/ConjugateGradient.xml
158	Initialization of default stopping criterion
163	Initialization phase counts as one iteration.
165	p and x are constructed as copies of x0, since presumably, the type of x is optimized for the calculation of the matrix-vector product A.x.

Commons/xml/main/java/org/apache/commons/math3/linear/DecompositionSolver.xml

Commons/xml/main/java/org/apache/commons/math3/linear/DefaultFieldMatrixChangingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/DefaultFieldMatrixPreservingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/DefaultIterativeLinearSolverEvent.xml

Commons/xml/main/java/org/apache/commons/math3/linear/DefaultRealMatrixChangingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/DefaultRealMatrixPreservingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/DiagonalMatrix.xml
121	Safety check.
267	we don't care about non-diagonal elements for multiplication

Commons/xml/main/java/org/apache/commons/math3/linear/EigenDecomposition.xml
207	return the cached matrix
225	cache the matrix for subsequent calls
259	return the cached matrix
561	transform the matrix to tridiagonal
586	Determine the largest main and secondary value in absolute term.
596	Make null any main and secondary value too small to be significant
678	Sort the eigen values (and vectors) in increase order
699	Determine the largest eigen value in absolute term.
706	Make null any eigen value too small to be significant
782	compute matrix norm
790	we can not handle a matrix with zero norm
795	Backsubstitute to find vectors of upper triangular form
806	Real vector
827	Solve real equations
841	Overflow control
851	Complex vector
854	Last vector component imaginary so matrix is triangular
888	Solve complex equations
917	Overflow control
931	Vectors of isolated roots
940	Back transformation to get eigenvectors of original matrix

Commons/xml/main/java/org/apache/commons/math3/linear/FieldDecompositionSolver.xml

Commons/xml/main/java/org/apache/commons/math3/linear/FieldLUDecomposition.xml
100	Initialize permutation array and parity
107	Loop over columns
112	upper
122	lower
123	permutation row
133	try to select a better permutation choice
138	Singularity check
144	Pivot if necessary
158	Divide the lower elements by the "winning" diagonal elt.
310	Apply permutations to b
316	Solve LY = b
324	Solve UX = Y
355	Apply permutations to b
361	Solve LY = b
369	Solve UX = Y
393	Apply permutations to b
403	Solve LY = b
415	Solve UX = Y

Commons/xml/main/java/org/apache/commons/math3/linear/FieldMatrix.xml

Commons/xml/main/java/org/apache/commons/math3/linear/FieldMatrixChangingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/FieldMatrixPreservingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/FieldVector.xml

Commons/xml/main/java/org/apache/commons/math3/linear/HessenbergTransformer.xml
74	transform matrix
109	Double division avoids possible underflow
135	return the cached matrix
150	copy the entry of the lower sub-diagonal
154	copy upper triangular part of the matrix
162	return the cached matrix
186	Scale column.
193	Compute Householder transformation.
204	Apply Householder similarity transformation H = (I - u*u' / h) * H * (I - u*u' / h)

Commons/xml/main/java/org/apache/commons/math3/linear/IllConditionedOperatorException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/IterativeLinearSolver.xml

Commons/xml/main/java/org/apache/commons/math3/linear/IterativeLinearSolverEvent.xml

Commons/xml/main/java/org/apache/commons/math3/linear/JacobiPreconditioner.xml
99	Dimension check is carried out by ebeDivide

Commons/xml/main/java/org/apache/commons/math3/linear/LUDecomposition.xml
100	Initialize permutation array and parity
107	Loop over columns
110	upper
120	lower
121	permutation row
131	maintain best permutation choice
138	Singularity check
144	Pivot if necessary
160	Divide the lower elements by the "winning" diagonal elt.
303	Apply permutations to b
308	Solve LY = b
316	Solve UX = Y
341	Apply permutations to b
351	Solve LY = b
363	Solve UX = Y

Commons/xml/main/java/org/apache/commons/math3/linear/MatrixDimensionMismatchException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/MatrixUtils.xml
774	read the vector data
781	create the instance
784	set up the field
879	read the matrix data
890	create the instance
893	set up the field

Commons/xml/main/java/org/apache/commons/math3/linear/NonPositiveDefiniteMatrixException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/NonPositiveDefiniteOperatorException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/NonSelfAdjointOperatorException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/NonSquareMatrixException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/NonSquareOperatorException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/NonSymmetricMatrixException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/OpenMapRealMatrix.xml
214	Safety check.

Commons/xml/main/java/org/apache/commons/math3/linear/OpenMapRealVector.xml
345	MATH-803: it is not sufficient to loop through non zero entries of this only. Indeed, if this[i] = 0d and v[i] = 0d, then this[i]  v[i] = NaN, and not 0d.
368	MATH-803: the above loop assumes that 0d  x  = 0d for any double x, which allows to consider only the non-zero entries of this. However, this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).  These special cases are handled below.

Commons/xml/main/java/org/apache/commons/math3/linear/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/linear/PreconditionedIterativeLinearSolver.xml

Commons/xml/main/java/org/apache/commons/math3/linear/QRDecomposition.xml
127	Let x be the first column of the minor, and a^2 = |x|^2. x will be in the positions qr[minor][minor] through qr[m][minor]. The first column of the transformed minor will be (a,0,0,..)' The sign of a is chosen to be opposite to the sign of the first component of x. Let's find a:
144	Calculate the normalized reflection vector v and transform the first column. We know the norm of v beforehand: v = x-ae so |v|^2 = <x-ae,x-ae> = <x,x>-2a<x,e>+a^2<e,e> = a^2+a^2-2a<x,e> = 2a(a - <x,e>). Here <x, e> is now qr[minor][minor]. v = x-ae is stored in the column at qr:
152	now |v|^2 = -2a*(qr[minor][minor])
154	Transform the rest of the columns of the minor: They will be transformed by the matrix H = I-2vv'|v|^2. If x is a column vector of the minor, then Hx = (I-2vv'|v|^2)x = x-2vv'x|v|^2 = x - 2<x,v>|v|^2 v. Therefore the transformation is easily calculated by subtracting the column vector (2<x,v>|v|^2)v from x.  Let 2<x,v>|v|^2 = alpha. From above we have |v|^2 = -2a(qr[minor][minor]), so alpha = -<x,v>(aqr[minor][minor])
174	Subtract the column vector alpha*v from x.
192	R is supposed to be m x n
196	copy the diagonal from rDiag and the upper triangle of qr
206	return the cached matrix
230	QT is supposed to be m x m
235	Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in succession to the result
264	return the cached matrix
289	return the cached matrix
354	apply Householder transforms to solve Q.y = b
369	solve triangular system R.x = y
406	get the right hand side vector
409	apply Householder transforms to solve Q.y = b
435	solve triangular system R.x = y

Commons/xml/main/java/org/apache/commons/math3/linear/RealLinearOperator.xml

Commons/xml/main/java/org/apache/commons/math3/linear/RealMatrix.xml

Commons/xml/main/java/org/apache/commons/math3/linear/RealMatrixChangingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/RealMatrixFormat.xml
142	disable grouping to prevent parsing problems
252	format prefix
255	format rows
271	format suffix
313	parse prefix
319	parse components
358	invalid component set index back to initial, error index should already be set
372	parse suffix
378	do not allow an empty matrix
384	build vector

Commons/xml/main/java/org/apache/commons/math3/linear/RealMatrixPreservingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/RealVector.xml
219	TODO Use more specific error message
1241	This anonymous class is an implementation of {@link RealVector} with read-only access. It wraps any {@link RealVector}, and exposes all methods which do not modify it. Invoking methods which should normally result in the modification of the calling {@link RealVector} results in a {@link MathUnsupportedOperationException}. It should be noted that {@link UnmodifiableVector} is <em>not<em> immutable.

Commons/xml/main/java/org/apache/commons/math3/linear/RealVectorChangingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/RealVectorFormat.xml
199	format prefix
202	format components
210	format suffix
245	parse prefix
251	parse components
268	invalid component set index back to initial, error index should already be set
277	parse suffix
283	build vector

Commons/xml/main/java/org/apache/commons/math3/linear/RealVectorPreservingVisitor.xml

Commons/xml/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.xml
98	find maximal diagonal element
109	swap elements
119	check diagonal element
127	check remaining diagonal elements
130	there is at least one sufficiently negative diagonal element, the symmetric positive semidefinite matrix is wrong
136	all remaining diagonal elements are close to zero, we consider we have found the rank of the symmetric positive semidefinite matrix
142	transform the matrix
160	prepare next iteration
165	build the root matrix

Commons/xml/main/java/org/apache/commons/math3/linear/RRQRDecomposition.xml
102	Find the unreduced column with the greatest L2-Norm
114	swap the current column with that with the greated L2-Norm and record in p

Commons/xml/main/java/org/apache/commons/math3/linear/SchurTransformer.xml
83	transform matrix
111	return the cached matrix
125	return the cached matrix
136	compute matrix norm
139	shift information
142	Outer loop over eigenvalue index
147	Look for single small sub-diagonal element
150	Check for convergence
152	One root found
157	Two roots found
178	Row modification
185	Column modification
192	Accumulate transformations
202	No convergence yet
205	stop transformation after too many iterations
211	the initial houseHolder vector for the QR step
228	as matrix T is (quasi-)triangular, also take the sub-diagonal element into account
267	Form shift
275	Wilkinson's original ad hoc shift
287	MATLAB's new ad hoc shift
316	Look for two consecutive small sub-diagonal elements
394	Row modification
405	Column modification
416	Accumulate transformations
427	(s != 0)
428	k loop
430	clean up pollution due to round-off errors
444	CHECKSTYLE: stop all
455	CHECKSTYLE: resume all

Commons/xml/main/java/org/apache/commons/math3/linear/SingularMatrixException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/SingularOperatorException.xml

Commons/xml/main/java/org/apache/commons/math3/linear/SingularValueDecomposition.xml
92	"m" is always the largest dimension.
110	Reduce A to bidiagonal form, storing the diagonal elements in s and the super-diagonal elements in e.
116	Compute the transformation for the k-th column and place the k-th diagonal in s[k]. Compute 2-norm of k-th column without under/overflow.
137	Apply the transformation.
147	Place the k-th row of A into e for the subsequent calculation of the row transformation.
152	Place the transformation in U for subsequent back multiplication.
159	Compute the k-th row transformation and place the k-th super-diagonal in e[k]. Compute 2-norm without under/overflow.
178	Apply the transformation.
195	Place the transformation in V for subsequent back multiplication.
202	Set up the final bidiagonal matrix or order p.
215	Generate U.
249	Generate V.
270	Main iteration loop for the singular values.
276	Here is where a test for too many iterations would go. This section of the program inspects for negligible elements in the s and e arrays.  On completion the variables kase and k are set as follows. kase = 1     if s(p) and e[k-1] are negligible and k<p kase = 2     if s(k) is negligible and k<p kase = 3     if e[k-1] is negligible, k<p, and s(k), ..., s(p) are not negligible (qr step). kase = 4     if e(p-1) is negligible (convergence).
290	the following condition is written this way in order to break out of the loop when NaN occurs, writing it as "if (FastMath.abs(e[k]) <= threshold)" would loop indefinitely in case of NaNs because comparison on NaNs always return false, regardless of what is checked see issue MATH-947
328	Perform the task indicated by kase.
330	Deflate negligible s(p).
352	Split at negligible s(k).
372	Perform one qr step.
374	Calculate the shift.
399	Chase zeros.
437	Convergence.
439	Make the singular values positive.
447	Order the singular values.
478	Set the small value tolerance used to calculate rank and pseudo-inverse
498	return the cached matrix
513	return the cached matrix
525	cache the matrix for subsequent calls
548	return the cached matrix
562	return the cached matrix
578	get the number of singular values to consider

Commons/xml/main/java/org/apache/commons/math3/linear/SparseFieldMatrix.xml

Commons/xml/main/java/org/apache/commons/math3/linear/SparseFieldVector.xml
574	OK, because "else if" check below ensures that other must be the same type as this

Commons/xml/main/java/org/apache/commons/math3/linear/SparseRealMatrix.xml

Commons/xml/main/java/org/apache/commons/math3/linear/SparseRealVector.xml

Commons/xml/main/java/org/apache/commons/math3/linear/SymmLQ.xml
158	IMPLEMENTATION NOTES -------------------- The implementation follows as closely as possible the notations of Paige and Saunders (1975). Attention must be paid to the fact that some quantities which are relevant to iteration k can only be computed in iteration (k+1). Therefore, minute attention must be paid to the index of each state variable of this algorithm.  1. Preconditioning --------------- The Lanczos iterations associated with Ahat and bhat read beta[1] = ||P  b|| v[1] = P  b  beta[1] beta[k+1]  v[k+1] = Ahat  v[k] - alpha[k]  v[k] - beta[k]  v[k-1] = P  (A - shift  I)  P'  v[k] - alpha[k]  v[k] - beta[k]  v[k-1] Multiplying both sides by P', we get beta[k+1]  (P'  v)[k+1] = M  (A - shift  I)  (P'  v)[k] - alpha[k]  (P'  v)[k] - beta[k]  (P'  v[k-1]), and alpha[k+1] = v[k+1]'  Ahat  v[k+1] = v[k+1]'  P  (A - shift  I)  P'  v[k+1] = (P'  v)[k+1]'  (A - shift  I)  (P'  v)[k+1].  In other words, the Lanczos iterations are unchanged, except for the fact that we really compute (P'  v) instead of v. It can easily be checked that all other formulas are unchanged. It must be noted that P is never explicitly used, only matrix-vector products involving are invoked.  2. Accounting for the shift parameter ---------------------------------- Is trivial: each time A.operate(x) is invoked, one must subtract shift  x to the result.  3. Accounting for the goodb flag ----------------------------- When goodb is set to true, the component of xL along b is computed separately. From Paige and Saunders (1975), equation (5.9), we have wbar[k+1] = s[k]  wbar[k] - c[k]  v[k+1], wbar[1] = v[1]. Introducing wbar2[k] = wbar[k] - s[1]  ...  s[k-1]  v[1], it can easily be verified by induction that wbar2 follows the same recursive relation wbar2[k+1] = s[k]  wbar2[k] - c[k]  v[k+1], wbar2[1] = 0, and we then have w[k] = c[k]  wbar2[k] + s[k]  v[k+1] + s[1]  ...  s[k-1]  c[k]  v[1]. Introducing w2[k] = w[k] - s[1]  ...  s[k-1]  c[k]  v[1], we find, from (5.10) xL[k] = zeta[1]  w[1] + ... + zeta[k]  w[k] = zeta[1]  w2[1] + ... + zeta[k]  w2[k] + (s[1]  c[2]  zeta[2] + ... + s[1]  ...  s[k-1]  c[k]  zeta[k])  v[1] = xL2[k] + bstep[k]  v[1], where xL2[k] is defined by xL2[0] = 0, xL2[k+1] = xL2[k] + zeta[k+1]  w2[k+1], and bstep is defined by bstep[1] = 0, bstep[k] = bstep[k-1] + s[1]  ...  s[k-1]  c[k]  zeta[k]. We also have, from (5.11) xC[k] = xL[k-1] + zbar[k]  wbar[k] = xL2[k-1] + zbar[k]  wbar2[k] + (bstep[k-1] + s[1]  ...  s[k-1]  zbar[k])  v[1].
522	ynorm = FastMath.sqrt(ynorm2 + zbar * zbar);
547	Set up y for the first Lanczos vector. y and beta1 will be zero if b = 0.
568	At this point r1 = b, y = M  b, beta1 = beta[1].
578	Set up y for the second Lanczos vector. y and beta will be zero or very small if b is an eigenvector.
585	At this point alpha = alpha[1] y     = beta[2]  M^(-1)  P'  v[2]
604	At this point oldb = beta[1] beta = beta[2] y  = beta[2]  P'  v[2] r2 = beta[2]  M^(-1)  P'  v[2]
643	At this point v     = P'  v[k], y     = (A - shift  I)  P'  v[k] - beta[k]  M^(-1)  P'  v[k-1], alpha = v'[k]  P  (A - shift  I)  P'  v[k] - beta[k]  v[k]'  P  M^(-1)  P'  v[k-1] = v'[k]  P  (A - shift  I)  P'  v[k] - beta[k]  v[k]'  v[k-1] = alpha[k].
654	At this point y = (A - shift  I)  P'  v[k] - alpha[k]  M^(-1)  P'  v[k] - beta[k]  M^(-1)  P'  v[k-1] = M^(-1)  P'  (P  (A - shift  I)  P'  v[k] -alpha[k]  v[k] - beta[k]  v[k-1]) = beta[k+1]  M^(-1)  P'  v[k+1], from Paige and Saunders (1975), equation (3.2).  WATCH-IT: the two following lines work only because y is no longer updated up to the end of the present iteration, and is reinitialized at the beginning of the next iteration.
678	At this point r1 = beta[k]  M^(-1)  P'  v[k], r2 = beta[k+1]  M^(-1)  P'  v[k+1], y  = beta[k+1]  P'  v[k+1], oldb = beta[k], beta = beta[k+1].
687	Compute the next plane rotation for Q. See Paige and Saunders (1975), equation (5.6), with gamma = gamma[k-1], c     = c[k-1], s     = s[k-1].
697	The relations gbar[k] = s[k-1]  (-c[k-2]  beta[k]) - c[k-1]  alpha[k] = s[k-1]  dbar[k] - c[k-1]  alpha[k], delta[k] = c[k-1]  dbar[k] + s[k-1]  alpha[k], are not stated in Paige and Saunders (1975), but can be retrieved by expanding the (k, k-1) and (k, k) coefficients of the matrix in equation (5.5).
711	At this point gbar   = gbar[k] deltak = delta[k] eps    = eps[k+1] dbar   = dbar[k+1] zeta   = zeta[k-1]
729	At this point x = xL[k-1], ptwbar = P' wbar[k], see Paige and Saunders (1975), equations (5.9) and (5.10).
742	At this point snprod       = s[1]  ...  s[k-1], gmax         = max(|alpha[1]|, gamma[1], ..., gamma[k-1]), gmin         = min(|alpha[1]|, gamma[1], ..., gamma[k-1]), ynorm2       = zeta[1]^2 + ... + zeta[k-1]^2, gammaZeta    = gamma[k]  zeta[k], minusEpsZeta = -eps[k+1]  zeta[k-1]. The relation for gammaZeta can be retrieved from Paige and Saunders (1975), equation (5.4a), last line of the vector gbar[k]  zbar[k] = -eps[k]  zeta[k-2] - delta[k]  zeta[k-1].
773	Estimate cond(A). In this version we look at the diagonals of L in the factorization of the tridiagonal matrix, T = L  Q. Sometimes, T[k] can be misleadingly ill-conditioned when T[k+1] is not, so we must be careful not to overestimate acond.
789	x has converged to an eigenvector of A corresponding to the eigenvalue shift.

Commons/xml/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.xml
77	transform matrix
103	build up first part of the matrix by applying Householder transforms
131	return the cached matrix
155	return the cached matrix
198	zero-out a row and a column simultaneously
209	apply Householder transform from left and right simultaneously
214	compute a = beta A v, where v is the Householder vector this loop is written in such a way 1) only the upper triangular part of the matrix is accessed 2) access is cache-friendly for a matrix stored in rows
231	compute gamma = beta vT z / 2
238	compute z = z - gamma v
243	update matrix: A = A - v zT - z vT only the upper triangular part of the matrix is updated

Commons/xml/main/java/org/apache/commons/math3/ml/clustering/CentroidCluster.xml

Commons/xml/main/java/org/apache/commons/math3/ml/clustering/Cluster.xml

Commons/xml/main/java/org/apache/commons/math3/ml/clustering/Clusterable.xml

Commons/xml/main/java/org/apache/commons/math3/ml/clustering/Clusterer.xml

Commons/xml/main/java/org/apache/commons/math3/ml/clustering/DBSCANClusterer.xml
137	sanity checks
149	DBSCAN does not care about center points
183	only check non-visited points

Commons/xml/main/java/org/apache/commons/math3/ml/clustering/DoublePoint.xml

Commons/xml/main/java/org/apache/commons/math3/ml/clustering/KMeansPlusPlusClusterer.xml
200	sanity checks
203	number of clusters has to be smaller or equal the number of data points
208	create the initial clusters
211	create an array containing the latest assignment of a point to a cluster no need to initialize the array, as it will be filled with the first assignment
216	iterate through updating the centers until we're done
246	if there were no more changes in the point-to-cluster assignment and there are no empty clusters left, return the current clusters
290	Convert to list for indexed access. Make it unmodifiable, since removal of items would screw up the logic of this method.
294	The number of points in the list.
297	Set the corresponding element in this array to indicate when elements of pointList are no longer available.
301	The resulting list of initial centers.
304	Choose one center uniformly at random from among the data points.
311	Must mark it as taken
314	To keep track of the minimum distance squared of elements of pointList to elements of resultSet.
318	Initialize the elements.  Since the only point in resultSet is firstPoint, this is very easy.
321	That point isn't considered
329	Sum up the squared distances for the points in pointList not already taken.
339	Add one new data point as a center. Each point x is chosen with probability proportional to D(x)2
343	The index of the next point to be added to the resultSet.
346	Sum through the squared min distances again, stopping when sum >= r.
359	If it's not set to >= 0, the point wasn't found in the previous for loop, probably because distances are extremely small.  Just pick the last available point.
371	We found one.
378	Mark it as taken.
382	Now update elements of minDistSquared.  We only have to compute the distance to the new center to do this.
385	Only have to worry about the points still not taken.
397	None found -- Break from the while loop to prevent an infinite loop.
422	compute the distance variance of the current cluster
430	select the cluster with the largest variance
439	did we find at least one non-empty cluster ?
444	extract a random point from the cluster
464	get the number of points of the current cluster
467	select the cluster with the largest number of points
475	did we find at least one non-empty cluster ?
480	extract a random point from the cluster
500	get the farthest point
514	did we find at least one non-empty cluster ?

Commons/xml/main/java/org/apache/commons/math3/ml/clustering/MultiKMeansPlusPlusClusterer.xml
84	at first, we have not found any clusters list yet
88	do several clustering trials
91	compute a clusters list
94	compute the variance of the current list
99	compute the distance variance of the current cluster
111	this one is the best we have found so far, remember it
118	return the best clusters list found

Commons/xml/main/java/org/apache/commons/math3/ml/clustering/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/ml/distance/CanberraDistance.xml

Commons/xml/main/java/org/apache/commons/math3/ml/distance/ChebyshevDistance.xml

Commons/xml/main/java/org/apache/commons/math3/ml/distance/DistanceMeasure.xml

Commons/xml/main/java/org/apache/commons/math3/ml/distance/EuclideanDistance.xml

Commons/xml/main/java/org/apache/commons/math3/ml/distance/ManhattanDistance.xml

Commons/xml/main/java/org/apache/commons/math3/ml/distance/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/ml/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/ode/AbstractIntegrator.xml
239	prepare expandable stateful equations
244	perform integration
247	extract results back from the stateful equations
320	initialize the events states if needed
328	search for next events that may occur during the step
341	the event occurs during the current step
348	handle the chronologically first event
353	restrict the interpolator to the first part of the step, up to the event
358	get state at event time
370	advance all event states to current time
376	handle the first part of the step, up to the event
382	the event asked to stop integration
392	some event handler has triggered changes that invalidate the derivatives, we need to recompute them
401	prepare handling of the remaining part of the step
406	check if the same event occurs again in the remaining part of the step
408	the event occurs during the current step
414	last part of the step, after the last event
423	handle the remaining part of the step, after all events if any

Commons/xml/main/java/org/apache/commons/math3/ode/AbstractParameterizable.xml

Commons/xml/main/java/org/apache/commons/math3/ode/ContinuousOutputModel.xml
247	initialize the search with the complete steps table
256	handle points outside of the integration interval or in the first and last step
269	reduction of the table slice size
272	use the last estimated index as the splitting index
282	we have found the target step, no need to continue searching
287	compute a new estimate of the index in the reduced table slice
293	too close to the bounds, we estimate using a simple dichotomy
296	estimate the index using a reverse quadratic polynom (reverse means we have i = P(t), thus allowing to simply compute index = P(time) rather than solving a quadratic equation)
312	force the next size reduction to be at least one tenth
323	now the table slice is very small, we perform an iterative search

Commons/xml/main/java/org/apache/commons/math3/ode/EquationsMapper.xml

Commons/xml/main/java/org/apache/commons/math3/ode/events/EventFilter.xml
94	delegate to raw handler
97	initialize events triggering logic
110	search which transformer should be applied to g
114	we are at the forward end of the history
116	check if a new rough root has been crossed
120	there is a root somewhere between extremeT end t the new transformer, which is valid on both sides of the root, so it is valid for t (this is how we have just computed it above), but it was already valid before, so we store the switch at extremeT for safety, to ensure the previous transformer is not applied too close of the root
134	apply the transform
138	we are in the middle of the history
140	select the transformer
143	apply the transform
153	we are at the backward end of the history
155	check if a new rough root has been crossed
159	there is a root somewhere between extremeT end t the new transformer, which is valid on both sides of the root, so it is valid for t (this is how we have just computed it above), but it was already valid before, so we store the switch at extremeT for safety, to ensure the previous transformer is not applied too close of the root
173	apply the transform
177	we are in the middle of the history
179	select the transformer
182	apply the transform
196	delegate to raw handler, fixing increasing status on the fly
202	delegate to raw handler

Commons/xml/main/java/org/apache/commons/math3/ode/events/EventHandler.xml

Commons/xml/main/java/org/apache/commons/math3/ode/events/EventState.xml
110	some dummy values ...
162	excerpt from MATH-421 issue: If an ODE solver is setup with an EventHandler that return STOP when the even is triggered, the integrator stops (which is exactly the expected behavior). If however the user wants to restart the solver from the final state reached at the event with the same configuration (expecting the event to be triggered again at a later time), then the integrator may fail to start. It can get stuck at the previous event. The use case for the bug MATH-421 is fairly general, so events occurring exactly at start in the first step should be ignored.
173	extremely rare case: there is a zero EXACTLY at interval start we will use the sign slightly after step beginning to force ignoring this zero
201	we cannot do anything on such a small step, don't trigger any events
222	evaluate handler value at the end of the substep
227	check events occurrence
229	there is a sign change: an event is expected during this step
231	variation direction, with respect to the integration direction
234	find the event time making sure we select a solution just at or past the exact root
260	we have either found nothing or found (again ?) a past event, retry the substep excluding this value
271	no sign change: there is no event for now
277	no sign change: there is no event for now
284	no event during the whole step
317	force the sign to its value "just after the event"

Commons/xml/main/java/org/apache/commons/math3/ode/events/FilterType.xml
95	we are initializing the first point
97	initialize as if previous root (i.e. backward one) was an ignored increasing event
100	initialize as if previous root (i.e. backward one) was a triggered decreasing event
103	we are exactly at a root, we don't know if it is an increasing or a decreasing event, we remain in uninitialized state
109	we have crossed the zero line on an ignored increasing event, we must change the transformer
113	we are still in the same status
118	we have crossed the zero line on an ignored increasing event, we must change the transformer
122	we are still in the same status
127	we have crossed the zero line on a triggered decreasing event, we must change the transformer
131	we are still in the same status
136	we have crossed the zero line on a triggered decreasing event, we must change the transformer
140	we are still in the same status
144	this should never happen
150	we are initializing the first point
152	initialize as if previous root (i.e. forward one) was a triggered decreasing event
155	initialize as if previous root (i.e. forward one) was an ignored increasing event
158	we are exactly at a root, we don't know if it is an increasing or a decreasing event, we remain in uninitialized state
164	we have crossed the zero line on an ignored increasing event, we must change the transformer
168	we are still in the same status
173	we have crossed the zero line on an ignored increasing event, we must change the transformer
177	we are still in the same status
182	we have crossed the zero line on a triggered decreasing event, we must change the transformer
186	we are still in the same status
191	we have crossed the zero line on a triggered decreasing event, we must change the transformer
195	we are still in the same status
199	this should never happen
271	we are initializing the first point
273	initialize as if previous root (i.e. backward one) was a triggered increasing event
276	initialize as if previous root (i.e. backward one) was an ignored decreasing event
279	we are exactly at a root, we don't know if it is an increasing or a decreasing event, we remain in uninitialized state
285	we have crossed the zero line on an ignored decreasing event, we must change the transformer
289	we are still in the same status
294	we have crossed the zero line on an ignored decreasing event, we must change the transformer
298	we are still in the same status
303	we have crossed the zero line on a triggered increasing event, we must change the transformer
307	we are still in the same status
312	we have crossed the zero line on a triggered increasing event, we must change the transformer
316	we are still in the same status
320	this should never happen
326	we are initializing the first point
328	initialize as if previous root (i.e. forward one) was an ignored decreasing event
331	initialize as if previous root (i.e. forward one) was a triggered increasing event
334	we are exactly at a root, we don't know if it is an increasing or a decreasing event, we remain in uninitialized state
340	we have crossed the zero line on an ignored decreasing event, we must change the transformer
344	we are still in the same status
349	we have crossed the zero line on an ignored decreasing event, we must change the transformer
353	we are still in the same status
358	we have crossed the zero line on a triggered increasing event, we must change the transformer
362	we are still in the same status
367	we have crossed the zero line on a triggered increasing event, we must change the transformer
371	we are still in the same status
375	this should never happen

Commons/xml/main/java/org/apache/commons/math3/ode/events/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/ode/events/Transformer.xml

Commons/xml/main/java/org/apache/commons/math3/ode/ExpandableStatefulODE.xml
99	there are no secondary equations, the complete set is limited to the primary set
102	there are secondary equations, the complete set ends after the last set
118	compute derivatives of the primary equations
122	Add contribution for secondary equations
142	lazy creation of the components list
197	safety checks
202	set the data
231	get either the secondary state
234	safety checks
239	set the data
270	safety checks
275	set the data
290	allocate complete array
293	set the data

Commons/xml/main/java/org/apache/commons/math3/ode/FirstOrderConverter.xml
103	split the state vector in two
107	apply the underlying equations set
110	build the result state derivative

Commons/xml/main/java/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.xml

Commons/xml/main/java/org/apache/commons/math3/ode/FirstOrderIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/JacobianMatrices.xml
148	set the default initial state Jacobian to the identity and the default initial parameters Jacobian to the null matrix
168	safety checks
240	Check dimensions
244	store the matrix in row major order as a single dimension array
270	Check dimensions
273	store the column in a global single dimension array
295	get current state for this set of equations from the expandable fode
312	get current state for this set of equations from the expandable fode
357	Lazy initialization
363	variational equations: from d[dy/dt]/dy0 and d[dy/dt]/dp to d[dy/dy0]/dt and d[dy/dp]/dt
366	compute Jacobian matrix with respect to primary state
370	Dispatch Jacobian matrix in the compound secondary state vector
386	compute Jacobian matrices with respect to parameters

Commons/xml/main/java/org/apache/commons/math3/ode/MainStateJacobianProvider.xml

Commons/xml/main/java/org/apache/commons/math3/ode/MultistepIntegrator.xml
134	set the default values of the algorithm control parameters
173	set the default values of the algorithm control parameters
221	make sure NO user event nor user step handler is triggered, this is the task of the top level integrator, not the task of the starter integrator
227	set up one specific step handler to extract initial Nordsieck vector
230	start integration, expecting a InitializationCompletedMarkerException
251	NOPMD
252	this is the expected nominal interruption of the start integrator
254	count the evaluations used by the starter
259	remove the specific step handler
375	first step, we need to store also the beginning of the step
390	store the end of the step
408	this was the last step we needed, we can compute the derivatives
412	first scaled derivative
418	higher order derivatives
421	stop the integrator now that all needed steps have been handled
430	nothing to do

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/AdamsBashforthIntegrator.xml
203	initialize working arrays
208	set up an interpolator sharing the integrator arrays
213	set up integration control objects
216	compute the initial Nordsieck vector using the configured starter integrator
222	reuse the step that was chosen by the starter integrator
226	main integration loop
235	evaluate error using the last term of the Taylor expansion
248	reject the step and attempt to reduce error by stepsize control
256	predict a first estimate of the state at step end
269	evaluate the derivative
272	update Nordsieck vector
281	discrete events handling
290	prepare next step
294	some events handler has triggered changes that invalidate the derivatives, we need to restart from scratch
300	stepsize control for next step
319	dispatch results

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/AdamsIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/AdamsMoultonIntegrator.xml
220	initialize working arrays
228	set up two interpolators sharing the integrator arrays
233	set up integration control objects
236	compute the initial Nordsieck vector using the configured starter integrator
252	predict a first estimate of the state at step end (P in the PECE sequence)
264	evaluate a first estimate of the derivative (first E in the PECE sequence)
267	update Nordsieck vector
274	apply correction (C in the PECE sequence)
278	reject the step and attempt to reduce error by stepsize control
285	evaluate a final estimate of the derivative (second E in the PECE sequence)
289	update Nordsieck vector
296	discrete events handling
308	prepare next step
312	some events handler has triggered changes that invalidate the derivatives, we need to restart from scratch
319	stepsize control for next step
337	dispatch results

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/AdamsNordsieckTransformer.xml
154	compute exact coefficients
164	update coefficients are computed by combining transform from Nordsieck to multistep, then shifting rows to represent step advance then applying inverse transform
169	shift rows
177	convert coefficients to double
229	build the P matrix elements from Taylor series formulas
255	using Taylor series with di = ti - t0, we get: y(ti)  - y(t0)  - di y'(t0) =   di^2 / h^2 s2 + ... +   di^k     / h^k sk + O(h^(k+1)) y'(ti) - y'(t0)             = 2 di   / h^2 s2 + ... + k di^(k-1) / h^k sk + O(h^k) we write these relations for i = 1 to i= n-1 as a set of 2(n-1) linear equations depending on the Nordsieck vector [s2 ... sk]
270	linear coefficients of equations y(ti) - y(t0) - di y'(t0) and y'(ti) - y'(t0)
280	expected value of the previous equations
292	solve the rectangular system in the least square sense to get the best estimate of the Nordsieck vector [s2 ... sk]

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/AdaptiveStepsizeIntegrator.xml
255	use the user provided value
259	very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale|| this guess will be used to perform an Euler step
277	perform an Euler step using the preceding rough guess
283	estimate the second derivative of the solution
291	step size is computed such that h^order * max (||y'/tol||, ||y''/tol||) = 0.01
298	avoids cancellation when computing t1 - t0

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/ClassicalRungeKuttaIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/DormandPrince54Integrator.xml
78	element 2 is zero, so it is neither stored nor used

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/DormandPrince54StepInterpolator.xml
41	element 1 is zero, so it is neither stored nor used
58	element 1 is zero, so it is neither stored nor used
182	no step finalization is needed for this interpolator
184	we need to compute the interpolation vectors for this time step
202	interpolate

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853Integrator.xml
157	elements 2 to 5 are zero, so they are neither stored nor used
184	elements 2 to 5 are zero, so they are neither stored nor used

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853StepInterpolator.xml
49	elements 2 to 5 are zero, so they are neither stored nor used
78	elements 2 to 5 are zero, so they are neither stored nor used
111	elements 2 to 5 are zero, so they are neither stored nor used
147	elements 2 to 5 are zero, so they are neither stored nor used
330	perform the last evaluations if they have not been done yet
333	compute the interpolation vectors for this time step
411	we are finalizing an uninitialized instance
419	k14
428	k15
438	k16
456	save the local attributes
472	save the state of the base class
482	read the local attributes
495	read the base state

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/EmbeddedRungeKuttaIntegrator.xml
128	set the default values of the algorithm control parameters
166	set the default values of the algorithm control parameters
202	create some internal working arrays
210	set up an interpolator sharing the integrator arrays
216	set up integration control objects
222	main integration loop
228	iterate over step size, ensuring local normalized error is smaller than 1
233	first stage
264	next stages
279	estimate the state at the end of the step
288	estimate the error at the end of the step
291	reject the step and attempt to reduce error by stepsize control
300	local error is small enough: accept the step, trigger events and step handlers
309	prepare next step
313	save the last evaluation for the next step
317	stepsize control for next step
335	dispatch results

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/EulerIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/EulerStepInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/GillIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/GillStepInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerIntegrator.xml
332	reinitialize the arrays
343	reinitialize the arrays
358	reinitialize the arrays
369	all arrays should be reallocated with the right size
377	step size sequence: 2, 6, 10, 14, ...
382	initialize the order selection cost array (number of function calls for each column of the extrapolation table)
389	initialize the extrapolation tables
469	first substep
477	other substeps
481	save the point at the middle of the step
494	stability check
513	correction of the last substep (at t0 + step)
532	update the diagonal
535	Aitken-Neville's recursive formula
541	update the last element
543	Aitken-Neville's recursive formula
558	create some internal working arrays
578	all substeps start at the same point, so share the first array
594	initial scaling
598	initial order selection
606	set up an interpolator sharing the integrator arrays
634	first evaluation, at the beginning of the step
650	step adjustment near bounds
658	iterate over several substep sizes
664	modified midpoint integration with the current substep
670	the stability check failed, we reduce the global step
677	the substep was computed successfully
680	extrapolate the state at the end of the step using last iteration data
685	estimate the error at the end of the step.
694	error is too big, we reduce the global step
702	compute optimal stepsize for this order
710	check convergence
716	check if we can stop iterations now
718	convergence have been reached just before targetIter
721	estimate if there is a chance convergence will be reached on next iteration, using the asymptotic evolution of error
727	we don't expect to converge on next iteration we reject the step immediately and reduce order
745	convergence has been reached exactly at targetIter
748	estimate if there is a chance convergence will be reached on next iteration, using the asymptotic evolution of error
753	we don't expect to converge on next iteration we reject the step immediately
794	derivatives at end of step
798	dense output handling
802	extrapolate state at middle point of the step
811	derivative at middle point of the step
830	compute centered differences to evaluate next derivatives
843	estimate the dense output coefficients
849	use the interpolation error to limit stepsize
865	Discrete events handling
869	prepare next step
900	after a rejected step neither order nor stepsize should increase
905	stepsize control
943	dispatch results

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerStepInterpolator.xml
163	the interpolator has been finalized, the following arrays are not needed anymore
170	copy the interpolation polynomials (up to the current degree only)
212	initialize the error factors array for interpolation
269	compute the remaining coefficients
355	in this degenerated case, the previous computation leads to NaN for derivatives we fix this by using the derivatives at midpoint
369	save the state of the base class
372	save the local attributes (but not the temporary vectors)
387	read the base class
391	read the local attributes
402	we can now set the interpolated time and state

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/HighamHall54Integrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/HighamHall54StepInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/MidpointIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/MidpointStepInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.xml
104	create some internal working arrays
115	set up an interpolator sharing the integrator arrays
121	set up integration control objects
126	main integration loop
132	first stage
135	next stages
150	estimate the state at the end of the step
159	discrete events handling
167	prepare next step
170	stepsize control for next step
180	dispatch results

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaStepInterpolator.xml
102	we cannot keep any reference to the equations in the copy the interpolator should have been finalized before
153	save the state of the base class
156	save the local attributes
170	we do not save any reference to the equations
179	read the base class
182	read the local attributes
205	we can now set the interpolated time and state

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/ThreeEighthesIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/nonstiff/ThreeEighthesStepInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/ODEIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/ode/ParameterConfiguration.xml

Commons/xml/main/java/org/apache/commons/math3/ode/Parameterizable.xml

Commons/xml/main/java/org/apache/commons/math3/ode/ParameterizedODE.xml

Commons/xml/main/java/org/apache/commons/math3/ode/ParameterizedWrapper.xml

Commons/xml/main/java/org/apache/commons/math3/ode/ParameterJacobianProvider.xml

Commons/xml/main/java/org/apache/commons/math3/ode/ParameterJacobianWrapper.xml
58	set up parameters for jacobian computation
86	compute the jacobian df/dp w.r.t. parameter

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/AbstractStepInterpolator.xml
269	finalize the step before performing copy
272	create the new independent instance
306	the step is not finalized anymore
407	lazy evaluation of the state
546	we do not store the interpolated state, it will be recomputed as needed after reading
550	finalize the step (and don't bother saving the now true flag)
597	we do NOT handle the interpolated time and state here

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/DummyStepHandler.xml
73	CHECKSTYLE: stop HideUtilityClassConstructor
81	CHECKSTYLE: resume HideUtilityClassConstructor
87	return the singleton instance

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/FixedStepHandler.xml

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/NordsieckStepInterpolator.xml
139	make sure the state and derivatives will depend on the new arrays
183	compute and ignore interpolated state to make sure state variation is computed as a side effect
199	apply Taylor formula from high order to low order, for the sake of numerical accuracy
227	save the state of the base class
230	save the local attributes
251	we don't save state variation, it will be recomputed
260	read the base class
263	read the local attributes
286	we can now set the interpolated time and state

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/StepHandler.xml

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/StepInterpolator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/StepNormalizer.xml
186	initialize the underlying handler
206	The first time, update the last state with the start information.
214	Take the integration direction into account.
221	Calculate next normalized step time.
230	Process normalized steps as long as they are in the current step.
233	Output the stored previous step.
236	Store the next step as last step.
239	Move on to the next step.
245	There will be no more steps. The stored one should be given to the handler. We may have to output one more step. Only the last one of those should be flagged as being the last.

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/StepNormalizerBounds.xml

Commons/xml/main/java/org/apache/commons/math3/ode/sampling/StepNormalizerMode.xml

Commons/xml/main/java/org/apache/commons/math3/ode/SecondaryEquations.xml

Commons/xml/main/java/org/apache/commons/math3/ode/SecondOrderDifferentialEquations.xml

Commons/xml/main/java/org/apache/commons/math3/ode/SecondOrderIntegrator.xml

Commons/xml/main/java/org/apache/commons/math3/ode/UnknownParameterException.xml

Commons/xml/main/java/org/apache/commons/math3/optim/AbstractConvergenceChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optim/BaseMultiStartMultivariateOptimizer.xml
133	Store arguments in order to pass them to the internal optimizer.
135	Set up base class and perform computations.
142	Remove all instances of "MaxEval" and "InitialGuess" from the array that will be passed to the internal optimizer. The former is to enforce smaller numbers of allowed evaluations (according to how many have been used up already), and the latter to impose a different start value for each start.
174	Multi-start loop.
176	CHECKSTYLE: stop IllegalCatch
178	Decrease number of allowed evaluations.
180	New start value.
193	reject the vector
200	Optimize.
206	CHECKSTYLE: resume IllegalCatch
213	All runs failed.
214	Cannot be null if starts >= 1.
217	Return the best optimum.

Commons/xml/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.xml
66	Perform optimization.
82	Allow base class to register its own data.
85	The existing values (as set by the previous call) are reused if not provided in the argument list.
100	Check input consistency.

Commons/xml/main/java/org/apache/commons/math3/optim/BaseOptimizer.xml
137	Parse options.
140	Reset counters.
143	Perform optimization.
189	The existing values (as set by the previous call) are reused if not provided in the argument list.

Commons/xml/main/java/org/apache/commons/math3/optim/ConvergenceChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optim/InitialGuess.xml

Commons/xml/main/java/org/apache/commons/math3/optim/linear/LinearConstraint.xml

Commons/xml/main/java/org/apache/commons/math3/optim/linear/LinearConstraintSet.xml

Commons/xml/main/java/org/apache/commons/math3/optim/linear/LinearObjectiveFunction.xml

Commons/xml/main/java/org/apache/commons/math3/optim/linear/LinearOptimizer.xml
53	No convergence checker.
95	Set up base class and perform computation.
113	Allow base class to register its own data.
116	The existing values (as set by the previous call) are reused if not provided in the argument list.

Commons/xml/main/java/org/apache/commons/math3/optim/linear/NoFeasibleSolutionException.xml

Commons/xml/main/java/org/apache/commons/math3/optim/linear/NonNegativeConstraint.xml

Commons/xml/main/java/org/apache/commons/math3/optim/linear/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optim/linear/Relationship.xml

Commons/xml/main/java/org/apache/commons/math3/optim/linear/SimplexSolver.xml
129	check if the entry is strictly smaller than the current minimum do not use a ulp/epsilon check
147	create a list of all the rows that tie for the lowest score in the minimum ratio test
156	check if the entry is strictly equal to the current min ratio do not use a ulp/epsilon check
172	there's a degeneracy as indicated by a tie in the minimum ratio test
174	1. check if there's an artificial variable that can be forced out of the basis
187	2. apply Bland's rule to prevent cycling: take the row for which the corresponding basic variable has the smallest index  see http:www.stanford.edu/class/msande310/blandrule.pdf see http:en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)  Additional heuristic: if we did not get a solution after half of maxIterations revert to the simple case of just returning the top-most row This heuristic is based on empirical data gathered while investigating MATH-828.
235	set the pivot element to 1
239	set the rest of the pivot column to 0
261	make sure we're in Phase 1
270	if W is not zero then we have no feasible solution

Commons/xml/main/java/org/apache/commons/math3/optim/linear/SimplexTableau.xml
206	create a matrix of the correct size
208	+ 1 is for RHS
212	initialize the objective function rows
229	initialize the constraint rows
236	decision variable coefficients
239	x-
245	RHS
248	slack variables
250	slack
252	excess
255	artificial variables
361	positive cost non-artificial variables
369	non-basic artificial variables
387	remove the columns in reverse order so the indices are correct
438	if the basic row is found to be the objective function row set the coefficient to 0 -> this case handles unconstrained variables that are still part of the objective function
443	if multiple variables can take a given value then we choose the first and set the rest equal to 0
485	cut-off values smaller than the cut-off threshold, otherwise may lead to numerical instabilities

Commons/xml/main/java/org/apache/commons/math3/optim/linear/UnboundedSolutionException.xml

Commons/xml/main/java/org/apache/commons/math3/optim/MaxEval.xml

Commons/xml/main/java/org/apache/commons/math3/optim/MaxIter.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/GoalType.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.xml
187	Set up base class and perform computation.
205	Initial search direction.
223	We have found an optimum.
227	Find the optimal step in the search direction.
230	XXX Last parameters is set to a value close to zero in order to work around the divergence problem in the "testCircleFitting" unit test (see MATH-439).
234	Subtract used up evaluations.
236	Validate new point.
248	Compute beta.
269	Should never happen.
274	Compute conjugate search direction.
277	Break conjugation: reset search direction.
280	Compute new conjugate search direction.
300	Allow base class to register its own data.
303	The existing values (as set by the previous call) are reused if not provided in the argument list.
308	If more data must be parsed, this statement _must_ be changed to "continue".
376	current point in the search direction
382	gradient of the objective function
385	dot product with the search direction

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/Preconditioner.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/GradientMultivariateOptimizer.xml
74	Set up base class and perform computation.
90	Allow base class to register its own data.
93	The existing values (as set by the previous call) are reused if not provided in the argument list.
98	If more data must be parsed, this statement _must_ be changed to "continue".

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/LeastSquaresConverter.xml
160	compute residuals
169	compute sum of squares

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultiStartMultivariateOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateFunctionMappingAdapter.xml
102	safety checks
109	note the following test is written in such a way it also fails for NaN
120	element is unbounded, no transformation is needed
123	element is simple-bounded on the upper side
128	element is simple-bounded on the lower side
131	element is double-bounded
145	Map unbounded input point to bounded point.
161	Map bounded input point to unbounded point.

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateFunctionPenaltyAdapter.xml
128	safety checks
139	note the following test is written in such a way it also fails for NaN
167	bound violation starting at this component
184	all boundaries are fulfilled, we are in the expected domain of the underlying function

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateOptimizer.xml
64	Set up base class and perform computation.
81	Allow base class to register its own data.
84	The existing values (as set by the previous call) are reused if not provided in the argument list.

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.xml
107	Only the relative position of the n final vertices with respect to the first one are stored.
140	Only the relative position of the n final vertices with respect to the first one are stored.
145	Loop over vertices.
149	Safety checks.
168	Store vertex i position relative to vertex 0 position.
222	Set first vertex.
226	Set remaining vertices.
247	Evaluate the objective function at all non-evaluated simplex points.
256	Sort the simplex from best to worst.

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/BOBYQAOptimizer.xml
331	bobyqa
333	----------------------------------------------------------------------------------------
1217	bobyqb
1219	----------------------------------------------------------------------------------------
1554	altmov
1556	----------------------------------------------------------------------------------------
1749	prelim
1752	----------------------------------------------------------------------------------------
2271	trsbox
2273	----------------------------------------------------------------------------------------
2367	update
2430	XXX utility for figuring out call sequence.
2437	XXX utility for figuring out call sequence.
2441	XXX utility for figuring out call sequence.
224	No custom convergence criterion.
236	Validity checks.
285	XXX
289	Return if there is insufficient space between the bounds. Modify the initial X if necessary in order to avoid conflicts between the bounds and the construction of the first quadratic model. The lower and upper bounds on moves from the updated X are set now, in the ISL and ISU partitions of W, in order to provide useful and exact information about components of X that become within distance RHOBEG from their bounds.
308	Computing MAX
319	Computing MIN
328	Make the call of BOBYQB.
374	XXX
391	Set some constants. Parameter adjustments
394	Function Body
396	The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, BMAT and ZMAT for the first iteration, with the corresponding values of of NF and KOPT, which are the number of calls of CALFUN so far and the index of the interpolation point at the trust region centre. Then the initial XOPT is set too. The branch to label 720 occurs if MAXFUN is less than NPT. GOPT will be updated if KOPT is different from KBASE.
409	Computing 2nd power
416	Complete the settings that are required for the iterative procedure.
437	Update GOPT if necessary before the first iteration and after each call of RESCUE that makes a call of CALFUN.
443	XXX
466	throw new PathIsExploredException(); // XXX
470	Generate the next point in the trust region that provides a small value of the quadratic model subject to the constraints on the variables. The int NTRITS is set to the number "trust region" iterations that have occurred since the last "alternative" iteration. If the length of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.
479	XXX
491	Computing MIN
497	Computing 2nd power
504	The following choice between labels 650 and 680 depends on whether or not our work with the current RHO seems to be complete. Either RHO is decreased or termination occurs if the errors in the quadratic model at the last three interpolation points compare favourably with predictions of likely improvements to the model within distance HALF*RHO of XOPT.
510	Computing MAX
530	Computing 2nd power
538	throw new PathIsExploredException(); // XXX
545	Severe cancellation is likely to occur if XOPT is too far from XBASE. If the following test holds, then XBASE is shifted so that XOPT becomes zero. The appropriate changes are made to BMAT and to the second derivatives of the current model, beginning with the changes to BMAT that do not depend on ZMAT. VLAG is used temporarily for working space.
553	XXX
557	final RealVector sumVector = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));
565	sum = sumVector.getEntry(k); // XXX "testAckley" and "testDiffPow" fail.
581	Then the revisions of BMAT that depend on ZMAT are calculated.
614	The following instructions complete the shift, including the changes to the second derivative parameters of the quadratic model.
647	XBASE is also moved to XOPT by a call of RESCUE. This calculation is more expensive than the previous shift, because new matrices BMAT and ZMAT are generated from scratch, which may include the replacement of interpolation points whose positions seem to be causing near linear dependence in the interpolation conditions. Therefore RESCUE is called only if rounding errors have reduced by at least a factor of two the denominator of the formula for updating the H matrix. It provides a useful safeguard, but is not invoked in most applications of BOBYQA.
658	XXX
659	Pick two alternative vectors of variables, relative to XBASE, that are suitable as new positions of the KNEW-th interpolation point. Firstly, XNEW is set to the point on a line through XOPT and another interpolation point that minimizes the predicted value of the next denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL and SU bounds. Secondly, XALT is set to the best feasible point on a constrained version of the Cauchy step of the KNEW-th Lagrange function, the corresponding value of the square of this function being returned in CAUCHY. The choice between these alternatives is going to be made when the denominator is calculated.
678	Calculate VLAG and BETA for the current choice of D. The scalar product of D with XPT(K,.) is going to be held in W(NPT+K) for use when VQUAD is calculated.
684	XXX
713	Computing 2nd power
730	Original
731	beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX "testAckley" and "testDiffPow" fail. beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum;  XXX "testDiffPow" fails.
737	If NTRITS is zero, the denominator may be increased by replacing the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if rounding errors have damaged the chosen denominator.
742	Computing 2nd power
750	XXX Useful statement?
753	Alternatively, if NTRITS is positive, then set KNEW to the index of the next interpolation point to be deleted to make room for a trust region step. Again RESCUE may be called if rounding errors have damaged_ the chosen denominator, which is the reason for attempting to select KNEW before calculating the next value of the objective function.
770	Computing 2nd power
774	Computing 2nd power
779	Computing 2nd power
783	Computing MAX Computing 2nd power
792	Computing MAX Computing 2nd power
799	Put the variables for the next calculation of the objective function in XNEW, with any adjustments for the bounds.
802	Calculate the value of the objective function at XBASE+XNEW, unless the limit on the number of calculations of F has been reached.
807	XXX
809	Computing MIN Computing MAX
833	Use the quadratic model to predict the change in F due to the step D, and set DIFF to the error of this prediction.
851	Computing 2nd power
853	"d1" must be squared first to prevent test failures.
864	Pick the next value of DELTA after a trust region step.
873	Computing MIN
876	Computing MAX
879	Computing MAX
886	Recalculate KNEW and DENOM if the new F is less than FOPT.
898	Computing 2nd power
902	Computing 2nd power
907	Computing 2nd power
911	Computing MAX Computing 2nd power
920	Computing MAX Computing 2nd power
933	Update BMAT and ZMAT, so that the KNEW-th interpolation point can be moved. Also update the second derivative terms of the model.
955	Include the new interpolation point, and make the changes to GOPT at the old XOPT that are caused by the updating of the quadratic model.
981	Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.
989	Computing 2nd power
1012	Calculate the parameters of the least Frobenius norm interpolant to the current data, the gradient of this interpolant at XOPT being put into VLAG(NPT+I), I=1,2,...,N.
1047	Computing MIN Computing 2nd power
1051	Computing 2nd power
1055	Computing MAX Computing 2nd power
1059	Computing 2nd power
1063	Computing 2nd power
1071	Test whether to replace the new quadratic model by the least Frobenius norm interpolant, making the replacement if the test is satisfied.
1094	If a trust region step has provided a sufficient decrease in F, then branch for another trust region calculation. The case NTRITS=0 occurs when the new interpolation point was reached by an alternative step.
1105	Alternatively, find out if the interpolation points are close enough to the best point so far.
1108	Computing MAX Computing 2nd power
1111	Computing 2nd power
1116	XXX
1121	Computing 2nd power
1131	If KNEW is positive, then ALTMOV finds alternative new positions for the KNEW-th interpolation point within distance ADELT of XOPT. It is reached via label 90. Otherwise, there is a branch to label 60 for another trust region iteration, unless the calculations with the current RHO are complete.
1140	Computing MIN
1147	Computing MAX Computing MIN
1164	The calculations with the current value of RHO are complete. Pick the next values of RHO and DELTA.
1168	XXX
1185	Return from the calculation, after another Newton-Raphson step, if it is too short to have been tried before.
1193	XXX
1196	Computing MIN Computing MAX
1258	XXX
1281	Calculate the gradient of the KNEW-th Lagrange function at XOPT.
1297	Search for a large denominator along the straight lines through XOPT and another interpolation point. SLBD and SUBD will be lower and upper bounds on the step along each of these lines in turn. PREDSQ will be set to the square of the predicted denominator for each line. PRESAV will be set to the largest admissible value of PREDSQ that occurs.
1325	Revise SLBD and SUBD if necessary because of the bounds in SL and SU.
1335	Computing MAX
1346	Computing MAX
1354	Seek a large modulus of the KNEW-th Lagrange function when the index of the other interpolation point on the line through XOPT is KNEW.
1381	Search along each of the other lines through XOPT and another point.
1399	Calculate PREDSQ for the current line search and maintain PRESAV.
1411	Construct XNEW in a way that satisfies the bound constraints exactly.
1425	Prepare for the iterative method that assembles the constrained Cauchy step in W. The sum of squares of the fixed components of W is formed in WFIXSQ, and the free components of W are set to BIGSTP.
1442	Computing 2nd power
1450	Investigate whether more components of W can be fixed.
1460	Computing 2nd power
1465	Computing 2nd power
1469	Computing 2nd power
1477	Set the remaining free components of W and all components of XALT, except that W may be scaled later.
1498	Set CURV to the curvature of the KNEW-th Lagrange function along W. Scale W by a factor less than one if that can reduce the modulus of the Lagrange function at XOPT+W. Set CAUCHY to the final value of the square of this function.
1522	Computing 2nd power
1526	Computing 2nd power
1531	If IFLAG is zero, then XALT is calculated as before after reversing the sign of GLAG. Thus two XALT vectors become available. The one that is chosen is the one that gives the larger value of CAUCHY.
1580	XXX
1590	Set XBASE to the initial vector of variables, and set the initial elements of XPT, BMAT, HQ, PQ and ZMAT to zero.
1612	Begin the initialization procedure. NF becomes one more than the number of function values so far. The coordinates of the displacement of the next initial interpolation point from XBASE are set in XPT(NF+1,.).
1632	throw new PathIsExploredException(); // XXX
1640	throw new PathIsExploredException(); // XXX
1644	throw new PathIsExploredException(); // XXX
1656	throw new PathIsExploredException(); // XXX
1664	Calculate the next value of F. The least function value so far and its index are required.
1681	nfm + 1
1691	Set the nonzero initial elements of BMAT and the quadratic model in the cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions of the NF-th and (NF-N)-th interpolation points may be switched, in order that the function value at the first of them contributes to the off-diagonal second derivative terms of the initial quadratic model.
1706	throw new PathIsExploredException(); // XXX
1729	zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX "testAckley" and "testDiffPow" fail.
1734	Set the off-diagonal second derivatives of the Lagrange functions and the initial quadratic model.
1746	throw new PathIsExploredException(); // XXX
1806	XXX
1814	Local variables
1830	Set some constants.
1832	Function Body
1834	The sign of GOPT(I) gives the sign of the change to the I-th variable that will reduce Q from its value at XOPT. Thus xbdi.get((I) shows whether or not to fix the I-th variable at one of its bounds initially, with NACT being set to the number of fixed variables. D and GNEW are also set for the first iteration. DELSQ is the upper bound on the sum of squares of the free variables. QRED is the reduction in Q so far.
1863	Set the next search direction of the conjugate gradient method. It is the steepest descent direction initially and when the iterations are restarted because a variable has just been fixed by a bound, and of course the components of the fixed variables are zero. ITERMAX is an upper bound on the indices of the conjugate gradient iterations.
1873	XXX
1877	XXX
1887	Computing 2nd power
1902	Multiply the search direction by the second derivative matrix of Q and calculate some scalars for the choice of steplength. Then set BLEN to the length of the the step to the trust region boundary and STPLEN to the steplength, ignoring the simple bounds.
1910	XXX
1916	Computing 2nd power
1934	Computing MIN
1938	Reduce STPLEN if necessary in order to preserve the simple bounds, letting IACT be the index of the new constrained variable.
1957	Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.
1974	Computing 2nd power
1980	Computing MAX
1986	Restart the conjugate gradient method if it has hit a new bound.
1994	Computing 2nd power
2003	If STPLEN is less than BLEN, then either apply another conjugate gradient iteration or RETURN.
2018	XXX
2021	Prepare for the alternative iteration by calculating some scalars and by multiplying the reduced D by the second derivative matrix of Q, where S holds the reduced D in the call of GGMULT.
2027	XXX
2036	Computing 2nd power
2040	Computing 2nd power
2050	Let the search direction S be a linear combination of the reduced D and the reduced G that is orthogonal to the reduced D.
2054	XXX
2070	By considering the simple bounds on the variables, calculate an upper bound on the tangent of half the angle of the alternative iteration, namely ANGBD, except that, if already a free variable has reached a bound, there is a branch back to label 100 after fixing that variable.
2090	Computing 2nd power
2092	Computing 2nd power
2095	Computing 2nd power
2106	Computing 2nd power
2120	Calculate HHD and some curvatures for the alternative iteration.
2125	XXX
2137	Seek the greatest reduction in Q for a range of equally spaced values of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of the alternative iteration.
2160	Return if the reduction is zero. Otherwise, set the sine and cosine of the angle of the alternative iteration, and calculate SDEC.
2178	Update GNEW, D and HRED. If the angle of the alternative iteration is restricted by a bound on a free variable, that variable is fixed at the bound.
2189	Computing 2nd power
2202	If SDEC is sufficiently small, then RETURN after setting XNEW to XOPT+D, giving careful attention to the bounds.
2210	XXX
2213	Computing MAX Computing MIN
2225	Computing 2nd power
2230	The following instructions multiply the current S-vector by the second derivative matrix of the quadratic model, putting the product in HS. They are reached from three different parts of the software above and they can be regarded as an external subroutine.
2236	XXX
2293	XXX
2299	XXX Should probably be split into two arrays.
2305	Computing MAX
2311	Apply the rotations that put zeros in the KNEW-th row of ZMAT.
2316	Computing 2nd power
2318	Computing 2nd power
2332	Put the first NPT components of the KNEW-th column of HLAG into W, and calculate the parameters of the updating formula.
2342	Complete the updating of ZMAT.
2352	Finally, update the matrix BMAT.
2377	XXX
2382	Check problem dimension.
2386	Check number of interpolation points.
2396	Initialize bound differences.
2409	Initialize the data structures used by the "bobyqa" method.
2439	System.out.println(caller(2) + ": state " + s);
2443	System.out.println(caller(2));

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.xml
82	global search parameters
90	population size
124	termination criteria
138	selection strategy parameters
148	dynamic strategy parameters and constants
168	CMA internal values - updated each generation
973	-----Matrix utility functions similar to the Matlab build in functions------
363	Set up base class and perform computation.
370	-------------------- Initialization --------------------------------
374	number of objective variables/problem dimension
385	-------------------- Generation Loop --------------------------------
391	Generate and evaluate lambda offspring
395	generate random offspring
401	m + sig * Normal(0,C)
410	regenerate random arguments for row
415	compute fitness
420	Sort by fitness and compute weighted mean into xmean
422	Calculate new xmean, this is selection and recombination
423	for speed up of Eq. (2) and (3)
434	Adapt step size sigma - Eq. (5)
448	handle termination criteria Break, if fitness is good enough
479	condition number of the covariance matrix exceeds 1e14
483	user defined termination
494	Adjust step size in case of equal function values (flat fitness)
502	store best in history
527	Allow base class to register its own data.
530	The existing values (as set by the previous call) are reused if not provided in the argument list.
575	initialize sigma
581	overall standard deviation
583	initialize termination criteria
589	initialize selection strategy parameters
590	number of parents/points for recombination
601	variance-effectiveness of sum w_i x_i
603	initialize dynamic strategy parameters and constants
610	minor increment
618	intialize CMA internal values - updated each generation
619	objective variables
622	evolution paths for C and sigma
623	B defines the coordinate system
627	diagonal D defines the scaling
629	covariance
631	history of fitness values
669	minor correction if hsig==false
672	regard old matrix
673	plus rank one update
674	plus rank mu update
676	replaces eig(C)
679	full covariance matrix from now on
704	mu difference vectors
706	rank one update
707	minor correction if hsig==false
711	Adapt covariance matrix C active CMA
714	keep at least 0.66 in all directions, small popsize are most critical
717	where to make up for the variance loss
719	prepare vectors, compute negative updating matrix Cneg
730	check and set learning rate negccov
741	regard old matrix
742	plus rank one update
743	plus rank mu update
748	Adapt covariance matrix C - nonactive
749	regard old matrix
750	plus rank one update
751	plus rank mu update
767	to achieve O(N^2)
769	enforce symmetry to prevent complex numbers
771	eigen decomposition, B==normalized eigenvectors
790	D contains standard deviations now
791	O(n^2)

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/MultiDirectionalSimplex.xml
157	Save the original simplex.
161	Perform a reflection step.
165	Compute the expanded simplex.
170	Keep the reflected simplex.
173	Keep the expanded simplex.
177	Compute the contracted simplex.
199	Perform a linear transformation on all the simplex points, except the first one.
212	Evaluate the simplex.

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/NelderMeadSimplex.xml
189	The simplex has n + 1 points if dimension is n.
192	Interesting values.
198	Compute the centroid of the best vertices (dismissing the worst point at index n).
212	compute the reflection point
222	Accept the reflected point.
225	Compute the expansion point.
234	Accept the expansion point.
237	Accept the reflected point.
242	Perform an outside contraction.
250	Accept the contraction point.
255	Perform an inside contraction.
264	Accept the contraction point.
270	Perform a shrink.

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.xml
134	Create the line search optimizer.
218	Default convergence check.
225	User-defined stopping criteria.
357	Passing "MAX_VALUE" as a dummy value because it is the enclosing class that counts the number of evaluations (and will eventually generate the exception).

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.xml
122	Set up base class and perform computation.
131	Indirect call to "computeObjectiveValue" in order to update the evaluations counter.
151	Initialize search.
167	We have found an optimum.
172	We still need to search.
192	Allow base class to register its own data.
195	The existing values (as set by the previous call) are reused if not provided in the argument list.
200	If more data must be parsed, this statement _must_ be changed to "continue".

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/ObjectiveFunction.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/ObjectiveFunctionGradient.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/scalar/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.xml
142	Set up the Jacobian.
145	Compute transpose(J)J.
148	Compute the covariances matrix.
197	Set up base class and perform computation.
244	Allow base class to register its own data.
247	The existing values (as set by the previous call) are reused if not provided in the argument list.
252	If more data must be parsed, this statement _must_ be changed to "continue".

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.xml
87	Computation will be useless without a checker (see "for-loop").
93	Number of observed data.
96	Diagonal of the weight matrix.
105	iterate until convergence is reached
110	evaluate the objective function and its jacobian
112	Value of the objective function at "currentPoint".
118	build the linear problem
127	compute the normal equation
133	build the contribution matrix for measurement i
144	solve the linearized least squares problem
150	update the estimated parameters
158	Check convergence.
167	Must never happen.

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.xml
277	No custom convergence criterion.
290	Number of observed data.
292	Number of parameters.
294	arrays shared with the other private methods
302	local point
316	Evaluate the function at the starting point and calculate its norm.
322	Outer loop.
331	QR decomposition of the jacobian matrix
339	compute Qt.res
342	now we don't need Q anymore, so let jacobian contain the R matrix with its diagonal elements
350	scale the point according to the norms of the columns of the initial jacobian
364	initialize the step bound delta
368	check orthogonality between function vector and jacobian columns
384	Convergence has been reached.
389	rescale if necessary
394	Inner loop.
397	save the state
410	determine the Levenberg-Marquardt parameter
413	compute the new point and the norm of the evolution direction
423	on the first iteration, adjust the initial step bound.
428	Evaluate the function at x + p and calculate its norm.
434	compute the scaled actual reduction
441	compute the scaled predicted reduction and the scaled directional derivative
461	ratio of the actual to the predicted reduction
464	update the step bound
478	test for successful iteration.
480	successful iteration, update the norm
489	tests for convergence.
495	failed iteration, reset the previous values
507	Reset "current" to previous values.
511	Default convergence criteria.
520	tests for termination and stringent tolerances
563	compute and store in x the gauss-newton direction, if the jacobian is rank-deficient, obtain a least squares solution
580	evaluate the function at the origin, and test for acceptance of the Gauss-Newton direction
596	if the jacobian is not rank deficient, the Newton step provides a lower bound, parl, for the zero of the function, otherwise set this bound to zero
620	calculate an upper bound, paru, for the zero of the function
637	if the input par lies outside of the interval (parl,paru), set par to the closer endpoint
646	evaluate the function at the current value of lmPar
668	if the function is small enough, accept the current value of lmPar, also test for the exceptional cases where parl is zero
675	compute the Newton correction
695	depending on the sign of the function, update parl or paru.
702	compute an improved estimate for lmPar
731	copy R and Qty to preserve input and initialize s in particular, save the diagonal elements of R in lmDir
742	eliminate the diagonal matrix d using a Givens rotation
745	prepare the row of d to be eliminated, locating the diagonal element using p from the Q.R. factorization
754	the transformations to eliminate the row of d modify only a single element of Qty beyond the first n, which is initially zero.
761	determine a Givens rotation which eliminates the appropriate element in the current row of d
778	compute the modified diagonal element of R and the modified element of (Qty,0)
785	accumulate the tranformation in the row of s
795	store the diagonal element of s and restore the corresponding diagonal element of R
801	solve the triangular system for z, if the system is singular, then obtain a least squares solution
823	permute the components of z back to components of lmDir
854	Code in this class assumes that the weighted Jacobian is -(W^(1/2) J), hence the multiplication by -1.
861	initializations
872	transform the matrix column after column
875	select the column with the greatest norm on active components
901	choose alpha such that Hk.u = alpha ek
907	transform the current column
911	transform the remaining columns

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/JacobianMultivariateVectorOptimizer.xml
83	Set up base class and perform computation.
99	Allow base class to register its own data.
102	The existing values (as set by the previous call) are reused if not provided in the argument list.
107	If more data must be parsed, this statement _must_ be changed to "continue".

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/ModelFunction.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/ModelFunctionJacobian.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.xml
87	Set up base class and perform computation.
131	Allow base class to register its own data.
134	The existing values (as set by the previous call) are reused if not provided in the argument list.
151	Check input consistency.

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/Target.xml

Commons/xml/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.xml

Commons/xml/main/java/org/apache/commons/math3/optim/OptimizationData.xml

Commons/xml/main/java/org/apache/commons/math3/optim/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optim/PointValuePair.xml

Commons/xml/main/java/org/apache/commons/math3/optim/PointVectorValuePair.xml

Commons/xml/main/java/org/apache/commons/math3/optim/SimpleBounds.xml

Commons/xml/main/java/org/apache/commons/math3/optim/SimplePointChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optim/SimpleValueChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optim/SimpleVectorValueChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optim/univariate/BracketFinder.xml

Commons/xml/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.xml
122	Optional additional convergence criteria.
151	Best point encountered so far (which is the initial guess).
160	Default stopping criterion.
168	Fit parabola.
186	Parabolic interpolation step.
190	f must not be evaluated too close to a or b.
199	Golden section step.
208	Golden section step.
217	Update by at least "tol1".
233	User-defined convergence checker.
246	Update a, b, v, w and x.
278	Default termination (Brent's criterion).

Commons/xml/main/java/org/apache/commons/math3/optim/univariate/MultiStartUnivariateOptimizer.xml
134	Store arguments in order to pass them to the internal optimizer.
136	Set up base class and perform computations.
143	Remove all instances of "MaxEval" and "SearchInterval" from the array that will be passed to the internal optimizer. The former is to enforce smaller numbers of allowed evaluations (according to how many have been used up already), and the latter to impose a different start value for each start.
176	Multi-start loop.
178	CHECKSTYLE: stop IllegalCatch
180	Decrease number of allowed evaluations.
182	New start value.
187	Optimize.
193	CHECKSTYLE: resume IllegalCatch
201	Cannot be null if starts >= 1.
204	Return the point with the best objective function value.

Commons/xml/main/java/org/apache/commons/math3/optim/univariate/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optim/univariate/SearchInterval.xml

Commons/xml/main/java/org/apache/commons/math3/optim/univariate/SimpleUnivariateValueChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optim/univariate/UnivariateObjectiveFunction.xml

Commons/xml/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.xml
70	Perform computation.
95	Allow base class to register its own data.
98	The existing values (as set by the previous call) are reused if not provided in the argument list.

Commons/xml/main/java/org/apache/commons/math3/optim/univariate/UnivariatePointValuePair.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/AbstractConvergenceChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/BaseMultivariateMultiStartOptimizer.xml
148	Multi-start loop.
150	CHECKSTYLE: stop IllegalCatch
158	CHECKSTYLE: resume IllegalCatch
166	cannot be null if starts >=1
169	Return the found point given the best objective function value.

Commons/xml/main/java/org/apache/commons/math3/optimization/BaseMultivariateOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/BaseMultivariateSimpleBoundsOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/BaseMultivariateVectorMultiStartOptimizer.xml
149	Multi-start loop.
152	CHECKSTYLE: stop IllegalCatch
162	CHECKSTYLE: resume IllegalCatch
170	cannot be null if starts >=1
173	Return the found point given the best objective function value.

Commons/xml/main/java/org/apache/commons/math3/optimization/BaseMultivariateVectorOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/BaseOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/ConvergenceChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/DifferentiableMultivariateMultiStartOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/DifferentiableMultivariateOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorMultiStartOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/AbstractSimplex.xml
109	Only the relative position of the n final vertices with respect to the first one are stored.
142	Only the relative position of the n final vertices with respect to the first one are stored.
147	Loop over vertices.
151	Safety checks.
170	Store vertex i position relative to vertex 0 position.
224	Set first vertex.
228	Set remaining vertices.
249	Evaluate the objective function at all non-evaluated simplex points.
258	Sort the simplex from best to worst.

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.xml
197	Set internal state.
202	Retrieve other settings.
204	Check input consistency.
206	Perform computation.
221	The existing values (as set by the previous call) are reused if not provided in the argument list.
304	If the bounds were not specified, the allowed interval is assumed to be [-inf, +inf].

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateVectorOptimizer.xml
183	Checks.
231	Set internal state.
235	Retrieve other settings.
237	Check input consistency.
239	Allow subclasses to reset their own internal state.
241	Perform computation.
321	XXX Temporary code until the new internal data is used everywhere.
341	The existing values (as set by the previous call) are reused if not provided in the argument list.

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/BOBYQAOptimizer.xml
336	bobyqa
338	----------------------------------------------------------------------------------------
1222	bobyqb
1224	----------------------------------------------------------------------------------------
1559	altmov
1561	----------------------------------------------------------------------------------------
1754	prelim
1757	----------------------------------------------------------------------------------------
2276	trsbox
2278	----------------------------------------------------------------------------------------
2372	update
2435	XXX utility for figuring out call sequence.
2442	XXX utility for figuring out call sequence.
2446	XXX utility for figuring out call sequence.
229	No custom convergence criterion.
241	Validity checks.
290	XXX
294	Return if there is insufficient space between the bounds. Modify the initial X if necessary in order to avoid conflicts between the bounds and the construction of the first quadratic model. The lower and upper bounds on moves from the updated X are set now, in the ISL and ISU partitions of W, in order to provide useful and exact information about components of X that become within distance RHOBEG from their bounds.
313	Computing MAX
324	Computing MIN
333	Make the call of BOBYQB.
379	XXX
396	Set some constants. Parameter adjustments
399	Function Body
401	The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, BMAT and ZMAT for the first iteration, with the corresponding values of of NF and KOPT, which are the number of calls of CALFUN so far and the index of the interpolation point at the trust region centre. Then the initial XOPT is set too. The branch to label 720 occurs if MAXFUN is less than NPT. GOPT will be updated if KOPT is different from KBASE.
414	Computing 2nd power
421	Complete the settings that are required for the iterative procedure.
442	Update GOPT if necessary before the first iteration and after each call of RESCUE that makes a call of CALFUN.
448	XXX
471	throw new PathIsExploredException(); // XXX
475	Generate the next point in the trust region that provides a small value of the quadratic model subject to the constraints on the variables. The int NTRITS is set to the number "trust region" iterations that have occurred since the last "alternative" iteration. If the length of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.
484	XXX
496	Computing MIN
502	Computing 2nd power
509	The following choice between labels 650 and 680 depends on whether or not our work with the current RHO seems to be complete. Either RHO is decreased or termination occurs if the errors in the quadratic model at the last three interpolation points compare favourably with predictions of likely improvements to the model within distance HALF*RHO of XOPT.
515	Computing MAX
535	Computing 2nd power
543	throw new PathIsExploredException(); // XXX
550	Severe cancellation is likely to occur if XOPT is too far from XBASE. If the following test holds, then XBASE is shifted so that XOPT becomes zero. The appropriate changes are made to BMAT and to the second derivatives of the current model, beginning with the changes to BMAT that do not depend on ZMAT. VLAG is used temporarily for working space.
558	XXX
562	final RealVector sumVector = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));
570	sum = sumVector.getEntry(k); // XXX "testAckley" and "testDiffPow" fail.
586	Then the revisions of BMAT that depend on ZMAT are calculated.
619	The following instructions complete the shift, including the changes to the second derivative parameters of the quadratic model.
652	XBASE is also moved to XOPT by a call of RESCUE. This calculation is more expensive than the previous shift, because new matrices BMAT and ZMAT are generated from scratch, which may include the replacement of interpolation points whose positions seem to be causing near linear dependence in the interpolation conditions. Therefore RESCUE is called only if rounding errors have reduced by at least a factor of two the denominator of the formula for updating the H matrix. It provides a useful safeguard, but is not invoked in most applications of BOBYQA.
663	XXX
664	Pick two alternative vectors of variables, relative to XBASE, that are suitable as new positions of the KNEW-th interpolation point. Firstly, XNEW is set to the point on a line through XOPT and another interpolation point that minimizes the predicted value of the next denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL and SU bounds. Secondly, XALT is set to the best feasible point on a constrained version of the Cauchy step of the KNEW-th Lagrange function, the corresponding value of the square of this function being returned in CAUCHY. The choice between these alternatives is going to be made when the denominator is calculated.
683	Calculate VLAG and BETA for the current choice of D. The scalar product of D with XPT(K,.) is going to be held in W(NPT+K) for use when VQUAD is calculated.
689	XXX
718	Computing 2nd power
735	Original
736	beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX "testAckley" and "testDiffPow" fail. beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum;  XXX "testDiffPow" fails.
742	If NTRITS is zero, the denominator may be increased by replacing the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if rounding errors have damaged the chosen denominator.
747	Computing 2nd power
755	XXX Useful statement?
758	Alternatively, if NTRITS is positive, then set KNEW to the index of the next interpolation point to be deleted to make room for a trust region step. Again RESCUE may be called if rounding errors have damaged_ the chosen denominator, which is the reason for attempting to select KNEW before calculating the next value of the objective function.
775	Computing 2nd power
779	Computing 2nd power
784	Computing 2nd power
788	Computing MAX Computing 2nd power
797	Computing MAX Computing 2nd power
804	Put the variables for the next calculation of the objective function in XNEW, with any adjustments for the bounds.
807	Calculate the value of the objective function at XBASE+XNEW, unless the limit on the number of calculations of F has been reached.
812	XXX
814	Computing MIN Computing MAX
838	Use the quadratic model to predict the change in F due to the step D, and set DIFF to the error of this prediction.
856	Computing 2nd power
858	"d1" must be squared first to prevent test failures.
869	Pick the next value of DELTA after a trust region step.
878	Computing MIN
881	Computing MAX
884	Computing MAX
891	Recalculate KNEW and DENOM if the new F is less than FOPT.
903	Computing 2nd power
907	Computing 2nd power
912	Computing 2nd power
916	Computing MAX Computing 2nd power
925	Computing MAX Computing 2nd power
938	Update BMAT and ZMAT, so that the KNEW-th interpolation point can be moved. Also update the second derivative terms of the model.
960	Include the new interpolation point, and make the changes to GOPT at the old XOPT that are caused by the updating of the quadratic model.
986	Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.
994	Computing 2nd power
1017	Calculate the parameters of the least Frobenius norm interpolant to the current data, the gradient of this interpolant at XOPT being put into VLAG(NPT+I), I=1,2,...,N.
1052	Computing MIN Computing 2nd power
1056	Computing 2nd power
1060	Computing MAX Computing 2nd power
1064	Computing 2nd power
1068	Computing 2nd power
1076	Test whether to replace the new quadratic model by the least Frobenius norm interpolant, making the replacement if the test is satisfied.
1099	If a trust region step has provided a sufficient decrease in F, then branch for another trust region calculation. The case NTRITS=0 occurs when the new interpolation point was reached by an alternative step.
1110	Alternatively, find out if the interpolation points are close enough to the best point so far.
1113	Computing MAX Computing 2nd power
1116	Computing 2nd power
1121	XXX
1126	Computing 2nd power
1136	If KNEW is positive, then ALTMOV finds alternative new positions for the KNEW-th interpolation point within distance ADELT of XOPT. It is reached via label 90. Otherwise, there is a branch to label 60 for another trust region iteration, unless the calculations with the current RHO are complete.
1145	Computing MIN
1152	Computing MAX Computing MIN
1169	The calculations with the current value of RHO are complete. Pick the next values of RHO and DELTA.
1173	XXX
1190	Return from the calculation, after another Newton-Raphson step, if it is too short to have been tried before.
1198	XXX
1201	Computing MIN Computing MAX
1263	XXX
1286	Calculate the gradient of the KNEW-th Lagrange function at XOPT.
1302	Search for a large denominator along the straight lines through XOPT and another interpolation point. SLBD and SUBD will be lower and upper bounds on the step along each of these lines in turn. PREDSQ will be set to the square of the predicted denominator for each line. PRESAV will be set to the largest admissible value of PREDSQ that occurs.
1330	Revise SLBD and SUBD if necessary because of the bounds in SL and SU.
1340	Computing MAX
1351	Computing MAX
1359	Seek a large modulus of the KNEW-th Lagrange function when the index of the other interpolation point on the line through XOPT is KNEW.
1386	Search along each of the other lines through XOPT and another point.
1404	Calculate PREDSQ for the current line search and maintain PRESAV.
1416	Construct XNEW in a way that satisfies the bound constraints exactly.
1430	Prepare for the iterative method that assembles the constrained Cauchy step in W. The sum of squares of the fixed components of W is formed in WFIXSQ, and the free components of W are set to BIGSTP.
1447	Computing 2nd power
1455	Investigate whether more components of W can be fixed.
1465	Computing 2nd power
1470	Computing 2nd power
1474	Computing 2nd power
1482	Set the remaining free components of W and all components of XALT, except that W may be scaled later.
1503	Set CURV to the curvature of the KNEW-th Lagrange function along W. Scale W by a factor less than one if that can reduce the modulus of the Lagrange function at XOPT+W. Set CAUCHY to the final value of the square of this function.
1527	Computing 2nd power
1531	Computing 2nd power
1536	If IFLAG is zero, then XALT is calculated as before after reversing the sign of GLAG. Thus two XALT vectors become available. The one that is chosen is the one that gives the larger value of CAUCHY.
1585	XXX
1595	Set XBASE to the initial vector of variables, and set the initial elements of XPT, BMAT, HQ, PQ and ZMAT to zero.
1617	Begin the initialization procedure. NF becomes one more than the number of function values so far. The coordinates of the displacement of the next initial interpolation point from XBASE are set in XPT(NF+1,.).
1637	throw new PathIsExploredException(); // XXX
1645	throw new PathIsExploredException(); // XXX
1649	throw new PathIsExploredException(); // XXX
1661	throw new PathIsExploredException(); // XXX
1669	Calculate the next value of F. The least function value so far and its index are required.
1686	nfm + 1
1696	Set the nonzero initial elements of BMAT and the quadratic model in the cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions of the NF-th and (NF-N)-th interpolation points may be switched, in order that the function value at the first of them contributes to the off-diagonal second derivative terms of the initial quadratic model.
1711	throw new PathIsExploredException(); // XXX
1734	zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX "testAckley" and "testDiffPow" fail.
1739	Set the off-diagonal second derivatives of the Lagrange functions and the initial quadratic model.
1751	throw new PathIsExploredException(); // XXX
1811	XXX
1819	Local variables
1835	Set some constants.
1837	Function Body
1839	The sign of GOPT(I) gives the sign of the change to the I-th variable that will reduce Q from its value at XOPT. Thus xbdi.get((I) shows whether or not to fix the I-th variable at one of its bounds initially, with NACT being set to the number of fixed variables. D and GNEW are also set for the first iteration. DELSQ is the upper bound on the sum of squares of the free variables. QRED is the reduction in Q so far.
1868	Set the next search direction of the conjugate gradient method. It is the steepest descent direction initially and when the iterations are restarted because a variable has just been fixed by a bound, and of course the components of the fixed variables are zero. ITERMAX is an upper bound on the indices of the conjugate gradient iterations.
1878	XXX
1882	XXX
1892	Computing 2nd power
1907	Multiply the search direction by the second derivative matrix of Q and calculate some scalars for the choice of steplength. Then set BLEN to the length of the the step to the trust region boundary and STPLEN to the steplength, ignoring the simple bounds.
1915	XXX
1921	Computing 2nd power
1939	Computing MIN
1943	Reduce STPLEN if necessary in order to preserve the simple bounds, letting IACT be the index of the new constrained variable.
1962	Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.
1979	Computing 2nd power
1985	Computing MAX
1991	Restart the conjugate gradient method if it has hit a new bound.
1999	Computing 2nd power
2008	If STPLEN is less than BLEN, then either apply another conjugate gradient iteration or RETURN.
2023	XXX
2026	Prepare for the alternative iteration by calculating some scalars and by multiplying the reduced D by the second derivative matrix of Q, where S holds the reduced D in the call of GGMULT.
2032	XXX
2041	Computing 2nd power
2045	Computing 2nd power
2055	Let the search direction S be a linear combination of the reduced D and the reduced G that is orthogonal to the reduced D.
2059	XXX
2075	By considering the simple bounds on the variables, calculate an upper bound on the tangent of half the angle of the alternative iteration, namely ANGBD, except that, if already a free variable has reached a bound, there is a branch back to label 100 after fixing that variable.
2095	Computing 2nd power
2097	Computing 2nd power
2100	Computing 2nd power
2111	Computing 2nd power
2125	Calculate HHD and some curvatures for the alternative iteration.
2130	XXX
2142	Seek the greatest reduction in Q for a range of equally spaced values of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of the alternative iteration.
2165	Return if the reduction is zero. Otherwise, set the sine and cosine of the angle of the alternative iteration, and calculate SDEC.
2183	Update GNEW, D and HRED. If the angle of the alternative iteration is restricted by a bound on a free variable, that variable is fixed at the bound.
2194	Computing 2nd power
2207	If SDEC is sufficiently small, then RETURN after setting XNEW to XOPT+D, giving careful attention to the bounds.
2215	XXX
2218	Computing MAX Computing MIN
2230	Computing 2nd power
2235	The following instructions multiply the current S-vector by the second derivative matrix of the quadratic model, putting the product in HS. They are reached from three different parts of the software above and they can be regarded as an external subroutine.
2241	XXX
2298	XXX
2304	XXX Should probably be split into two arrays.
2310	Computing MAX
2316	Apply the rotations that put zeros in the KNEW-th row of ZMAT.
2321	Computing 2nd power
2323	Computing 2nd power
2337	Put the first NPT components of the KNEW-th column of HLAG into W, and calculate the parameters of the updating formula.
2347	Complete the updating of ZMAT.
2357	Finally, update the matrix BMAT.
2382	XXX
2387	Check problem dimension.
2391	Check number of interpolation points.
2401	Initialize bound differences.
2414	Initialize the data structures used by the "bobyqa" method.
2444	System.out.println(caller(2) + ": state " + s);
2448	System.out.println(caller(2));

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.xml
103	global search parameters
111	population size
145	termination criteria
159	selection strategy parameters
169	dynamic strategy parameters and constants
189	CMA internal values - updated each generation
1101	-----Matrix utility functions similar to the Matlab build in functions------
487	Scan "optData" for the input specific to this optimizer.
490	The parent's method will retrieve the common parameters from "optData" and call "doOptimize".
499	-------------------- Initialization --------------------------------
503	number of objective variables/problem dimension
513	-------------------- Generation Loop --------------------------------
517	Generate and evaluate lambda offspring
521	generate random offspring
527	m + sig * Normal(0,C)
536	regenerate random arguments for row
541	compute fitness
546	Sort by fitness and compute weighted mean into xmean
548	Calculate new xmean, this is selection and recombination
549	for speed up of Eq. (2) and (3)
560	Adapt step size sigma - Eq. (5)
574	handle termination criteria Break, if fitness is good enough
605	condition number of the covariance matrix exceeds 1e14
609	user defined termination
620	Adjust step size in case of equal function values (flat fitness)
628	store best in history
652	The existing values (as set by the previous call) are reused if not provided in the argument list.
680	XXX Remove this block in 4.0 (check performed in "Sigma" class).
697	XXX Line below to replace the current one in 4.0 (MATH-879). throw new NotStrictlyPositiveException(lambda);
701	initialize sigma
704	XXX Line below to replace the current one in 4.0 (MATH-868). sigmaArray[i][0] = inputSigma[i];
709	overall standard deviation
711	initialize termination criteria
717	initialize selection strategy parameters
718	number of parents/points for recombination
729	variance-effectiveness of sum w_i x_i
731	initialize dynamic strategy parameters and constants
738	minor increment
746	intialize CMA internal values - updated each generation
747	objective variables
750	evolution paths for C and sigma
751	B defines the coordinate system
755	diagonal D defines the scaling
757	covariance
759	history of fitness values
797	minor correction if hsig==false
800	regard old matrix
801	plus rank one update
802	plus rank mu update
804	replaces eig(C)
807	full covariance matrix from now on
832	mu difference vectors
834	rank one update
835	minor correction if hsig==false
839	Adapt covariance matrix C active CMA
842	keep at least 0.66 in all directions, small popsize are most critical
845	where to make up for the variance loss
847	prepare vectors, compute negative updating matrix Cneg
858	check and set learning rate negccov
869	regard old matrix
870	plus rank one update
871	plus rank mu update
876	Adapt covariance matrix C - nonactive
877	regard old matrix
878	plus rank one update
879	plus rank mu update
895	to achieve O(N^2)
897	enforce symmetry to prevent complex numbers
899	eigen decomposition, B==normalized eigenvectors
918	D contains standard deviations now
919	O(n^2)

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/MultiDirectionalSimplex.xml
160	Save the original simplex.
164	Perform a reflection step.
168	Compute the expanded simplex.
173	Keep the reflected simplex.
176	Keep the expanded simplex.
180	Compute the contracted simplex.
202	Perform a linear transformation on all the simplex points, except the first one.
215	Evaluate the simplex.

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/MultivariateFunctionMappingAdapter.xml
103	safety checks
110	note the following test is written in such a way it also fails for NaN
121	element is unbounded, no transformation is needed
124	element is simple-bounded on the upper side
129	element is simple-bounded on the lower side
132	element is double-bounded
146	map unbounded input point to bounded point
162	map bounded input point to unbounded point

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/MultivariateFunctionPenaltyAdapter.xml
130	safety checks
141	note the following test is written in such a way it also fails for NaN
169	bound violation starting at this component
186	all boundaries are fulfilled, we are in the expected domain of the underlying function

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/NelderMeadSimplex.xml
192	The simplex has n + 1 points if dimension is n.
195	Interesting values.
201	Compute the centroid of the best vertices (dismissing the worst point at index n).
215	compute the reflection point
225	Accept the reflected point.
228	Compute the expansion point.
237	Accept the expansion point.
240	Accept the reflected point.
245	Perform an outside contraction.
253	Accept the contraction point.
258	Perform an inside contraction.
267	Accept the contraction point.
273	Perform a shrink.

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/PowellOptimizer.xml
124	Create the line search optimizer.
208	Default convergence check.
347	Passing "MAX_VALUE" as a dummy value because it is the enclosing class that counts the number of evaluations (and will eventually generate the exception).

Commons/xml/main/java/org/apache/commons/math3/optimization/direct/SimplexOptimizer.xml
152	Scan "optData" for the input specific to this optimizer.
155	The parent's method will retrieve the common parameters from "optData" and call "doOptimize".
170	The existing values (as set by the previous call) are reused if not provided in the argument list.
187	Indirect call to "computeObjectiveValue" in order to update the evaluations counter.
207	Initialize search.
223	We have found an optimum.
228	We still need to search.

Commons/xml/main/java/org/apache/commons/math3/optimization/fitting/CurveFitter.xml
176	prepare least squares problem
186	perform the fit
189	to be removed in 4.0
197	extract the coefficients
233	compute the residuals
259	compute the residuals
272	extract parameters
278	compute the residuals
283	build the DerivativeStructure by adding first the value as a constant and then adding derivatives

Commons/xml/main/java/org/apache/commons/math3/optimization/fitting/GaussianFitter.xml
92	NOPMD
93	Do nothing.
105	NOPMD
106	Do nothing.
92	NOPMD
93	Do nothing.
105	NOPMD
106	Do nothing.
245	TODO: Exceptions should not be used for flow control.
342	Boundaries are replaced by dummy values because the raised exception is caught and the message never displayed. TODO: Exceptions should not be used for flow control.

Commons/xml/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.xml
237	Since the samples are almost always already sorted, this method is implemented as an insertion sort that reorders the elements in place. Insertion sort is very efficient in this case.
245	the current element should be inserted closer to the beginning
277	initialize the sums for the linear model between the two integrals
290	one step forward
296	update the integrals of f<sup>2</sup> and f'<sup>2</sup> considering a linear model for f (and therefore constant f')
315	compute the amplitude and pulsation coefficients
321	Range of the observations, assuming that the observations are sorted.
343	In some ill-conditioned cases (cf. MATH-844), the guesser procedure cannot produce sensible results.
362	initialize the means
369	one step forward

Commons/xml/main/java/org/apache/commons/math3/optimization/fitting/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.xml
65	To avoid compilation error until the instance variable is removed.

Commons/xml/main/java/org/apache/commons/math3/optimization/fitting/WeightedObservedPoint.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/general/AbstractDifferentiableOptimizer.xml
86	Store optimization problem characteristics.
89	Perform optimization.

Commons/xml/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.xml
209	Compute cost.
212	Compute weighted residuals.
330	Set up the Jacobian.
333	Compute transpose(J)J.
336	Compute the covariances matrix.
495	XXX Conversion will be removed when the generic argument of the base class becomes "MultivariateDifferentiableVectorFunction".
505	Reset counter.
508	Square-root of the weight matrix.
511	Store least squares problem characteristics. XXX The conversion won't be necessary when the generic argument of the base class becomes "MultivariateDifferentiableVectorFunction". XXX "jF" is not strictly necessary anymore but is currently more efficient than converting the value returned from "getObjectiveFunction()" every time it is used.
519	Arrays shared with "private" and "protected" methods.

Commons/xml/main/java/org/apache/commons/math3/optimization/general/AbstractScalarDifferentiableOptimizer.xml
84	Store optimization problem characteristics.

Commons/xml/main/java/org/apache/commons/math3/optimization/general/ConjugateGradientFormula.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.xml
110	Computation will be useless without a checker (see "for-loop").
116	Number of observed data.
119	Diagonal of the weight matrix.
128	iterate until convergence is reached
134	evaluate the objective function and its jacobian
136	Value of the objective function at "currentPoint".
142	build the linear problem
151	compute the normal equation
157	build the contribution matrix for measurement i
168	solve the linearized least squares problem
174	update the estimated parameters
182	Check convergence.
187	Update (deprecated) "point" field.
193	Must never happen.

Commons/xml/main/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.xml
271	No custom convergence criterion.
282	Number of observed data.
284	Number of parameters.
286	arrays shared with the other private methods
294	local point
308	Evaluate the function at the starting point and calculate its norm.
314	Outer loop.
323	QR decomposition of the jacobian matrix
331	compute Qt.res
334	now we don't need Q anymore, so let jacobian contain the R matrix with its diagonal elements
342	scale the point according to the norms of the columns of the initial jacobian
356	initialize the step bound delta
360	check orthogonality between function vector and jacobian columns
376	Convergence has been reached.
378	Update (deprecated) "point" field.
383	rescale if necessary
388	Inner loop.
391	save the state
404	determine the Levenberg-Marquardt parameter
407	compute the new point and the norm of the evolution direction
417	on the first iteration, adjust the initial step bound.
422	Evaluate the function at x + p and calculate its norm.
428	compute the scaled actual reduction
435	compute the scaled predicted reduction and the scaled directional derivative
455	ratio of the actual to the predicted reduction
458	update the step bound
472	test for successful iteration.
474	successful iteration, update the norm
483	tests for convergence.
486	Update (deprecated) "point" field.
491	failed iteration, reset the previous values
503	Reset "current" to previous values.
507	Default convergence criteria.
513	Update (deprecated) "point" field.
518	tests for termination and stringent tolerances (2.2204e-16 is the machine epsilon for IEEE754)
560	compute and store in x the gauss-newton direction, if the jacobian is rank-deficient, obtain a least squares solution
577	evaluate the function at the origin, and test for acceptance of the Gauss-Newton direction
593	if the jacobian is not rank deficient, the Newton step provides a lower bound, parl, for the zero of the function, otherwise set this bound to zero
617	calculate an upper bound, paru, for the zero of the function
631	2.2251e-308 is the smallest positive real for IEE754
635	if the input par lies outside of the interval (parl,paru), set par to the closer endpoint
644	evaluate the function at the current value of lmPar
666	if the function is small enough, accept the current value of lmPar, also test for the exceptional cases where parl is zero
673	compute the Newton correction
693	depending on the sign of the function, update parl or paru.
700	compute an improved estimate for lmPar
729	copy R and Qty to preserve input and initialize s in particular, save the diagonal elements of R in lmDir
740	eliminate the diagonal matrix d using a Givens rotation
743	prepare the row of d to be eliminated, locating the diagonal element using p from the Q.R. factorization
752	the transformations to eliminate the row of d modify only a single element of Qty beyond the first n, which is initially zero.
759	determine a Givens rotation which eliminates the appropriate element in the current row of d
776	compute the modified diagonal element of R and the modified element of (Qty,0)
783	accumulate the tranformation in the row of s
793	store the diagonal element of s and restore the corresponding diagonal element of R
799	solve the triangular system for z, if the system is singular, then obtain a least squares solution
821	permute the components of z back to components of lmDir
852	Code in this class assumes that the weighted Jacobian is -(W^(1/2) J), hence the multiplication by -1.
859	initializations
870	transform the matrix column after column
873	select the column with the greatest norm on active components
899	choose alpha such that Hk.u = alpha ek
905	transform the current column
909	transform the remaining columns

Commons/xml/main/java/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizer.xml
163	Initial search direction.
182	We have found an optimum.
186	Find the optimal step in the search direction.
189	XXX Last parameters is set to a value close to zero in order to work around the divergence problem in the "testCircleFitting" unit test (see MATH-439).
193	Subtract used up evaluations.
195	Validate new point.
207	Compute beta.
227	Compute conjugate search direction.
230	Break conjugation: reset search direction.
233	Compute new conjugate search direction.
295	current point in the search direction
301	gradient of the objective function
304	dot product with the search direction

Commons/xml/main/java/org/apache/commons/math3/optimization/general/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/general/Preconditioner.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/GoalType.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/InitialGuess.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/LeastSquaresConverter.xml
156	compute residuals
165	compute sum of squares

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.xml
143	store linear problem characteristics
151	solve the problem

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/LinearConstraint.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/LinearObjectiveFunction.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/LinearOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/NoFeasibleSolutionException.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/Relationship.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.xml
78	check if the entry is strictly smaller than the current minimum do not use a ulp/epsilon check
95	create a list of all the rows that tie for the lowest score in the minimum ratio test
104	check if the entry is strictly equal to the current min ratio do not use a ulp/epsilon check
120	there's a degeneracy as indicated by a tie in the minimum ratio test
122	1. check if there's an artificial variable that can be forced out of the basis
135	2. apply Bland's rule to prevent cycling: take the row for which the corresponding basic variable has the smallest index  see http:www.stanford.edu/class/msande310/blandrule.pdf see http:en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)  Additional heuristic: if we did not get a solution after half of maxIterations revert to the simple case of just returning the top-most row This heuristic is based on empirical data gathered while investigating MATH-828.
181	set the pivot element to 1
185	set the rest of the pivot column to 0
204	make sure we're in Phase 1
213	if W is not zero then we have no feasible solution

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.xml
185	create a matrix of the correct size
187	+ 1 is for RHS
191	initialize the objective function rows
208	initialize the constraint rows
215	decision variable coefficients
218	x-
224	RHS
227	slack variables
229	slack
231	excess
234	artificial variables
340	positive cost non-artificial variables
348	non-basic artificial variables
366	remove the columns in reverse order so the indices are correct
417	if the basic row is found to be the objective function row set the coefficient to 0 -> this case handles unconstrained variables that are still part of the objective function
422	if multiple variables can take a given value then we choose the first and set the rest equal to 0
464	cut-off values smaller than the CUTOFF_THRESHOLD, otherwise may lead to numerical instabilities

Commons/xml/main/java/org/apache/commons/math3/optimization/linear/UnboundedSolutionException.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/MultivariateDifferentiableMultiStartOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/MultivariateDifferentiableOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/MultivariateDifferentiableVectorMultiStartOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/MultivariateDifferentiableVectorOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/MultivariateMultiStartOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/MultivariateOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/OptimizationData.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/PointValuePair.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/PointVectorValuePair.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/SimpleBounds.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/SimplePointChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/SimpleValueChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/SimpleVectorValueChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/Target.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.xml
119	Checks.
127	Reset.
136	Perform computation.

Commons/xml/main/java/org/apache/commons/math3/optimization/univariate/BaseUnivariateOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/univariate/BracketFinder.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.xml
124	Optional additional convergence criteria.
153	Best point encountered so far (which is the initial guess).
162	Default stopping criterion.
170	Fit parabola.
188	Parabolic interpolation step.
192	f must not be evaluated too close to a or b.
201	Golden section step.
210	Golden section step.
219	Update by at least "tol1".
235	User-defined convergence checker.
248	Update a, b, v, w and x.
280	Default termination (Brent's criterion).

Commons/xml/main/java/org/apache/commons/math3/optimization/univariate/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/univariate/SimpleUnivariateValueChecker.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/univariate/UnivariateMultiStartOptimizer.xml
158	Multi-start loop.
160	CHECKSTYLE: stop IllegalCatch
168	CHECKSTYLE: resume IllegalCatch
176	cannot be null if starts >=1
179	Return the point with the best objective function value.

Commons/xml/main/java/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/univariate/UnivariatePointValuePair.xml

Commons/xml/main/java/org/apache/commons/math3/optimization/Weight.xml

Commons/xml/main/java/org/apache/commons/math3/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/primes/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/primes/PollardRho.xml
90	start at -3 to ensure we enter this loop at least 3 times
135	both a and b must be positive, it is not checked here gdc(a,0) = a
143	make a and b odd, keep in mind the common power of twos
150	a and b >0 if a > b then gdc(a,b) = gcd(a-b,b) if a < b then gcd(a,b) = gcd(b-a,a) so next a is the absolute difference and next b is the minimum of current values
158	for speed optimization: remove any power of two in a as b is guaranteed to be odd throughout all iterations
163	gcd(a,a) = a, just "add" the common power of twos

Commons/xml/main/java/org/apache/commons/math3/primes/Primes.xml
82	make sure n is odd
91	prepare entry in the +2, +4 loop: n should not be a multiple of 3
94	if n % 3 == 0
95	n % 3 == 2
96	if n % 3 == 1
97	if (isPrime(n)) return n;
98	n % 3 == 2
100	this loop skips all multiple of 3
104	n % 3 == 1
108	n % 3 == 2
124	slower than trial div unless we do an awful lot of computation (then it finally gets JIT-compiled efficiently List<Integer> out = PollardRho.primeFactors(n);

Commons/xml/main/java/org/apache/commons/math3/primes/SmallPrimes.xml
103	no check is done about n >= f
135	here we are sure that n is either a prime or a semi prime
154	r must be odd, it is not checked here
164	works up to 3.2 billion, int range stops at 2.7 so we are safe :-)
179	definitely composite
184	definitely composite
187	definitely prime

Commons/xml/main/java/org/apache/commons/math3/random/AbstractRandomGenerator.xml
73	the following number is the largest prime that fits in 32 bits (it is 2^32 - 5)

Commons/xml/main/java/org/apache/commons/math3/random/AbstractWell.xml
97	the bits pool contains k bits, k = r w - p where r is the number of w bits blocks, w is the block size (always 32 in the original paper) and p is the number of unused bits in the last block
105	precompute indirection index tables. These tables are used for optimizing access they allow saving computations like "(j + r - 2) % r" with costly modulo operations
120	initialize the pool content
170	Clear normal deviate cache

Commons/xml/main/java/org/apache/commons/math3/random/BitsStreamGenerator.xml
106	generate a new pair of gaussian numbers
114	use the second element of the pair already generated

Commons/xml/main/java/org/apache/commons/math3/random/CorrelatedRandomVectorGenerator.xml
168	generate uncorrelated vector
173	compute correlated vector

Commons/xml/main/java/org/apache/commons/math3/random/EmpiricalDistribution.xml
592	Distribution methods ---------------------------
233	new adapter for the second pass
236	Can't happen
266	new adapter for the second pass
273	NOPMD
274	ignore
297	new adapter for second pass
305	NOPMD
306	ignore
429	Set up grid
434	Initialize binStats ArrayList
443	Filling data in binStats Array
446	Assign upperBounds based on bin counts
482	Start with a uniformly distributed random number in (0,1)
485	Use this to select the bin and generate a Gaussian within the bin
490	more than one obs
493	only one obs in bin
846	Default to Gaussian

Commons/xml/main/java/org/apache/commons/math3/random/GaussianRandomGenerator.xml

Commons/xml/main/java/org/apache/commons/math3/random/ISAACRandom.xml
200	fill in mem[] with messy stuff
213	second pass makes all of seed affect all of mem

Commons/xml/main/java/org/apache/commons/math3/random/JDKRandomGenerator.xml
41	the following number is the largest prime that fits in 32 bits (it is 2^32 - 5)

Commons/xml/main/java/org/apache/commons/math3/random/MersenneTwister.xml
144	we use a long masked by 0xffffffffL as a poor man unsigned int
146	NB: unlike original C code, we are working with java longs, the cast below makes masking unnecessary
149	See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. initializer from the 2002-01-09 C version by Makoto Matsumoto
155	Clear normal deviate cache
180	non linear
195	non linear
204	MSB is 1; assuring non-zero initial array
206	Clear normal deviate cache
234	generate N words at one time
256	tempering

Commons/xml/main/java/org/apache/commons/math3/random/NormalizedRandomGenerator.xml

Commons/xml/main/java/org/apache/commons/math3/random/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/random/RandomAdaptor.xml
179	required to avoid NPE in constructor
186	required to avoid NPE in constructor
194	required to avoid NPE in constructor

Commons/xml/main/java/org/apache/commons/math3/random/RandomData.xml

Commons/xml/main/java/org/apache/commons/math3/random/RandomDataGenerator.xml
166	Get a random number generator
169	Initialize output buffer
172	Get int(len/2)+1 random bytes
176	Convert each byte to 2 hex digits
180	Add 128 to byte value to make interval 0-255 before doing hex conversion. This guarantees <= 2 hex digits from toHexString() toHexString would otherwise add 2^32 to negative arguments.
187	Make sure we add 2 hex digits for each byte
204	the range is too wide to fit in a positive int (larger than 2^31); as it covers more than half the integer range, we use directly a simple rejection method
214	we can shift the range and generate directly a positive int
227	the range is too wide to fit in a positive long (larger than 2^63); as it covers more than half the long range, we use directly a simple rejection method
237	we can shift the range and generate directly a positive int
240	we can shift the range and generate directly a positive long
298	Get SecureRandom and setup Digest provider
304	this should never happen
309	Compute number of iterations required (40 bytes each)
318	Compute hash -- will create 20-byte binary hash
321	Loop over the hash, converting each byte to 2 hex digits
325	Add 128 to byte value to make interval 0-255 This guarantees <= 2 hex digits from toHexString() toHexString would otherwise add 2^32 to negative arguments
332	Keep strings uniform length -- guarantees 40 bytes
350	the range is too wide to fit in a positive int (larger than 2^31); as it covers more than half the integer range, we use directly a simple rejection method
360	we can shift the range and generate directly a positive int
373	the range is too wide to fit in a positive long (larger than 2^63); as it covers more than half the long range, we use directly a simple rejection method
383	we can shift the range and generate directly a positive int
386	we can shift the range and generate directly a positive long
677	ensure nextDouble() isn't 0.0
873	NumberIsTooLargeException cannot occur

Commons/xml/main/java/org/apache/commons/math3/random/RandomDataImpl.xml

Commons/xml/main/java/org/apache/commons/math3/random/RandomGenerator.xml

Commons/xml/main/java/org/apache/commons/math3/random/RandomVectorGenerator.xml

Commons/xml/main/java/org/apache/commons/math3/random/StableRandomGenerator.xml
92	we need 2 uniform random numbers to calculate omega and phi
96	Normal distribution case (Box-Muller algorithm)
102	when beta = 0, zeta is zero as well Thus we can exclude it from the formula
105	Cauchy distribution case
115	Generic stable distribution
117	to avoid rounding errors around alpha = 1

Commons/xml/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.xml

Commons/xml/main/java/org/apache/commons/math3/random/UncorrelatedRandomVectorGenerator.xml

Commons/xml/main/java/org/apache/commons/math3/random/UniformRandomGenerator.xml

Commons/xml/main/java/org/apache/commons/math3/random/UnitSphereRandomVectorGenerator.xml
65	See http://mathworld.wolfram.com/SpherePointPicking.html for example. Pick a point by choosing a standard Gaussian for each element, and then normalizing to unit length.

Commons/xml/main/java/org/apache/commons/math3/random/ValueServer.xml
94	Data generation modes ======================================
370	------------- private methods ---------------------------------
296	NOPMD
297	ignore
416	we have probably reached end of file, wrap around from EOF to BOF

Commons/xml/main/java/org/apache/commons/math3/random/Well1024a.xml

Commons/xml/main/java/org/apache/commons/math3/random/Well19937a.xml

Commons/xml/main/java/org/apache/commons/math3/random/Well19937c.xml
107	add Matsumoto-Kurita tempering to get a maximally-equidistributed generator

Commons/xml/main/java/org/apache/commons/math3/random/Well44497a.xml
95	the values below include the errata of the original article

Commons/xml/main/java/org/apache/commons/math3/random/Well44497b.xml
87	compute raw value given by WELL44497a generator which is NOT maximally-equidistributed
97	the values below include the errata of the original article
111	add Matsumoto-Kurita tempering to get a maximally-equidistributed generator

Commons/xml/main/java/org/apache/commons/math3/random/Well512a.xml
94	the values below include the errata of the original article

Commons/xml/main/java/org/apache/commons/math3/RealFieldElement.xml
209	TODO: add this method in 4.0, as it is not possible to do it in 3.2 due to incompatibility of the return type in the Dfp class /** Base 10 logarithm. * @return base 10 logarithm of the instance */ T log10();

Commons/xml/main/java/org/apache/commons/math3/special/Beta.xml
205	even
205	even
313	d = a + b - 0.5
357	s[i] = 1 + q + ... - q(2  i)
365	w = Delta(b) - Delta(a + b)
503	The following command is the original NSWC implementation. return Gamma.logGamma(a) + (Gamma.logGamma(b) - Gamma.logGamma(a + b)); The following command turns out to be more accurate.

Commons/xml/main/java/org/apache/commons/math3/special/Erf.xml
146	beware that the logarithm argument must be commputed as (1.0 - x) * (1.0 + x), it must NOT be simplified as 1.0 - x * x as this would induce rounding errors near the boundaries +/-1
219	this branch does not appears in the original code, it was added because the previous branch does not handle x = +/-1 correctly. In this case, w is positive infinity and as the first coefficient (-2.71e-11) is negative. Once the first multiplication is done, p becomes negative infinity and remains so throughout the polynomial evaluation. So the branch above incorrectly returns negative infinity instead of the correct positive infinity.

Commons/xml/main/java/org/apache/commons/math3/special/Gamma.xml
97	limits for switching algorithm in digamma
104	Constants for the computation of double invGamma1pm1(double). Copied from DGAM1 in the NSWC library.
322	use regularizedGammaQ because it should converge faster in this case.
326	calculate series
327	current element index
328	n-th element in the series
329	partial sum
333	compute next element in the series
337	update partial sum
400	use regularizedGammaP because it should converge faster in this case.
404	create continued fraction
448	use method 5 from Bernardo AS103 accurate to O(x)
454	use method 4 (accurate to O(1/x^8)
456	1       1        1         1 log(x) -  --- - ------ + ------- - ------- 2 x   12 x^2   120 x^4   252 x^6
483	1    1      1       1       1 - + ---- + ---- - ----- + ----- x      2      3       5       7 2 x    6 x    30 x    42 x
659	From the recurrence relation Gamma(x) = (x - 1)  ...  (x - n)  Gamma(x - n), then Gamma(t) = 1  [1 + invGamma1pm1(t - 1)], where t = x - n. This means that t must satisfy -0.5 <= t - 1 <= 1.5.
675	From the recurrence relation Gamma(x) = Gamma(x + n + 1)  [x  (x + 1)  ...  (x + n)] then Gamma(x + n + 1) = 1  [1 + invGamma1pm1(x + n)], which requires -0.5 <= x + n <= 1.5.
698	From the reflection formula Gamma(x)  Gamma(1 - x)  sin(pi  x) = pi, and the recurrence relation Gamma(1 - x) = -x  Gamma(-x), it is found Gamma(x) = -pi  [x  sin(pi  x)  Gamma(-x)].

Commons/xml/main/java/org/apache/commons/math3/special/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/clustering/Cluster.xml

Commons/xml/main/java/org/apache/commons/math3/stat/clustering/Clusterable.xml

Commons/xml/main/java/org/apache/commons/math3/stat/clustering/DBSCANClusterer.xml
131	sanity checks
143	DBSCAN does not care about center points
177	only check non-visited points

Commons/xml/main/java/org/apache/commons/math3/stat/clustering/EuclideanDoublePoint.xml

Commons/xml/main/java/org/apache/commons/math3/stat/clustering/EuclideanIntegerPoint.xml

Commons/xml/main/java/org/apache/commons/math3/stat/clustering/KMeansPlusPlusClusterer.xml
109	at first, we have not found any clusters list yet
113	do several clustering trials
116	compute a clusters list
119	compute the variance of the current list
124	compute the distance variance of the current cluster
136	this one is the best we have found so far, remember it
143	return the best clusters list found
165	sanity checks
168	number of clusters has to be smaller or equal the number of data points
173	create the initial clusters
176	create an array containing the latest assignment of a point to a cluster no need to initialize the array, as it will be filled with the first assignment
181	iterate through updating the centers until we're done
211	if there were no more changes in the point-to-cluster assignment and there are no empty clusters left, return the current clusters
260	Convert to list for indexed access. Make it unmodifiable, since removal of items would screw up the logic of this method.
264	The number of points in the list.
267	Set the corresponding element in this array to indicate when elements of pointList are no longer available.
271	The resulting list of initial centers.
274	Choose one center uniformly at random from among the data points.
281	Must mark it as taken
284	To keep track of the minimum distance squared of elements of pointList to elements of resultSet.
288	Initialize the elements.  Since the only point in resultSet is firstPoint, this is very easy.
291	That point isn't considered
299	Sum up the squared distances for the points in pointList not already taken.
309	Add one new data point as a center. Each point x is chosen with probability proportional to D(x)2
313	The index of the next point to be added to the resultSet.
316	Sum through the squared min distances again, stopping when sum >= r.
329	If it's not set to >= 0, the point wasn't found in the previous for loop, probably because distances are extremely small.  Just pick the last available point.
341	We found one.
348	Mark it as taken.
352	Now update elements of minDistSquared.  We only have to compute the distance to the new center to do this.
355	Only have to worry about the points still not taken.
367	None found -- Break from the while loop to prevent an infinite loop.
392	compute the distance variance of the current cluster
400	select the cluster with the largest variance
409	did we find at least one non-empty cluster ?
414	extract a random point from the cluster
433	get the number of points of the current cluster
436	select the cluster with the largest number of points
444	did we find at least one non-empty cluster ?
449	extract a random point from the cluster
469	get the farthest point
483	did we find at least one non-empty cluster ?

Commons/xml/main/java/org/apache/commons/math3/stat/clustering/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/correlation/Covariance.xml
53	Create an empty covariance matrix.

Commons/xml/main/java/org/apache/commons/math3/stat/correlation/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/correlation/PearsonsCorrelation.xml

Commons/xml/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.xml
205	if we have found NaN values, we have to update the matrix size

Commons/xml/main/java/org/apache/commons/math3/stat/correlation/StorelessBivariateCovariance.xml

Commons/xml/main/java/org/apache/commons/math3/stat/correlation/StorelessCovariance.xml
156	only update the upper triangular part of the covariance matrix as only these parts are actually stored

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.xml
79	No try-catch or throws NAE because arg is guaranteed non-null
289	No try - catch or advertising NAE because neither argument will ever be null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.xml
489	Implementation getters and setter
364	We need to check to see if we need to discard elements from the front of the array.  If the windowSize is less than the current number of elements.
435	Setter guard should prevent
469	No catch for MIAE because actual parameter is valid below
485	No try-catch or advertised exception here because arguments are guaranteed valid
731	No try-catch or advertised exception because parms are guaranteed valid
748	Copy data and window size
752	Copy implementations

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/FirstMoment.xml
146	No try-catch or advertised exception because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/FourthMoment.xml
131	No try-catch or advertised exception because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/GeometricMean.xml
97	no try-catch or advertised exception because args guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/Kurtosis.xml
165	Initialize the kurtosis
170	Compute the mean and standard deviation
176	Sum the ^4 of the distance from the mean divided by the standard deviation
184	Get N
192	Calculate kurtosis
204	No try-catch because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/Mean.xml
168	Compute initial estimate using definitional formula
171	Compute correction factor in second pass
215	Compute initial estimate using definitional formula
219	Compute correction factor in second pass
264	No try-catch or advertised exception because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/SecondMoment.xml
113	no try-catch or advertised NAE because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/SemiVariance.xml
151	No try-catch or advertised exception because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/Skewness.xml
162	Initialize the skewness
167	Get the mean and the standard deviation
170	Calc the std, this is implemented here instead of using the standardDeviation method eliminate a duplicate pass to get the mean
189	Get N
192	Calculate skewness
204	No try-catch or advertised exception because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/StandardDeviation.xml
260	No try-catch or advertised exception because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/ThirdMoment.xml
126	No try-catch or advertised exception because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/Variance.xml
606	No try-catch or advertised exception because parameters are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/VectorialCovariance.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/moment/VectorialMean.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/MultivariateSummaryStatistics.xml
409	Getters and setters for statistics implementations

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/rank/Max.xml
152	No try-catch or advertised exception because args are non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/rank/Median.xml
45	No try-catch or advertised exception - arg is valid

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/rank/Min.xml
152	No try-catch or advertised exception - args are non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/rank/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.xml
108	No try-catch or advertised exception here - arg is valid
278	always return single value for n = 1
329	the pivot has already been found in a previous call and the array has already been partitioned around it
333	select a pivot and partition work array around it
341	the pivot was exactly the element we wanted
344	the element is in the left partition
346	the min is here to avoid integer overflow
348	the element is in the right partition
350	the min is here to avoid integer overflow
355	the element is somewhere in the small sub-array sort the sub-array using insertion sort
487	No try-catch or advertised exception because args are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/StatisticalMultivariateSummary.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/StatisticalSummary.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/StatisticalSummaryValues.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/summary/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/summary/Product.xml
210	No try-catch or advertised exception because args are valid

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/summary/Sum.xml
206	No try-catch or advertised exception because args are valid

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/summary/SumOfLogs.xml
151	No try-catch or advertised exception here because args are valid

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/summary/SumOfSquares.xml
139	no try-catch or advertised exception here because args are valid

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/SummaryStatistics.xml
407	Getters and setters for statistics implementations
158	If mean, variance or geomean have been overridden, need to increment these
659	No try-catch or advertised exception because arguments are guaranteed non-null
684	Keep commons-math supplied statistics with embedded moments in synch
701	Make sure that if stat == statImpl in source, same holds in dest; otherwise copy stat

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.xml
46	no try-catch or advertized IAE because arg is valid
161	No try-catch or advertised exception because arguments are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/SynchronizedMultivariateSummaryStatistics.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.xml
334	No try-catch or advertised exception because arguments are guaranteed non-null

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.xml

Commons/xml/main/java/org/apache/commons/math3/stat/descriptive/WeightedEvaluation.xml

Commons/xml/main/java/org/apache/commons/math3/stat/Frequency.xml
219	-------------------------------------------------------------------------
348	-----------------------------------------------------------------------------------------
437	----------------------------------------------------------------------------------------------
497	----------------------------------------------------------------------------------------------
535	----------------------------------------------------------------------------------------------
74	TODO is the cast OK?
144	TreeMap will throw ClassCastException if v is not comparable
252	NOPMD
253	ignore and return 0 -- ClassCastException will be thrown if value is not comparable
378	v is not comparable
382	v is comparable, but less than first value
386	v is comparable, but greater than the last value
74	TODO is the cast OK?
559	cast to (T) may throw ClassCastException, see Javadoc

Commons/xml/main/java/org/apache/commons/math3/stat/inference/ChiSquareTest.xml
253	compute row, column and total sums
265	compute expected counts and chi-square
414	Make sure lengths are same
422	Ensure non-negative counts
426	Compute and compare count sums
435	Ensure neither sample is uniformly 0
439	Compare and compute weight only if different
444	Compute ChiSquare statistic
455	apply weights

Commons/xml/main/java/org/apache/commons/math3/stat/inference/GTest.xml
352	Make sure lengths are same
360	Ensure non-negative counts
364	Compute and compare count sums
368	Compute and compare count sums
383	Ensure neither sample is uniformly 0

Commons/xml/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.xml
137	The ranks for x is in the first x.length entries in ranks because x is in the first x.length entries in z
145	U1 = R1 - (n1  (n1 + 1))  2 where R1 is sum of ranks for sample 1, e.g. x, n1 is the number of observations in sample 1.
151	It can be shown that U1 + U2 = n1  n2
174	long multiplication to avoid overflow (double not used due to efficiency and to avoid precision loss)
179	http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
185	No try-catch or advertised exception because args are valid
231	It can be shown that U1 + U2 = n1  n2

Commons/xml/main/java/org/apache/commons/math3/stat/inference/OneWayAnova.xml
130	No try-catch or advertised exception because args are valid
200	convert arrays to SummaryStatistics
281	check if we have enough categories
287	check if each category has enough data

Commons/xml/main/java/org/apache/commons/math3/stat/inference/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/inference/TestUtils.xml
61	CHECKSTYLE: stop JavadocMethodCheck
453	CHECKSTYLE: resume JavadocMethodCheck

Commons/xml/main/java/org/apache/commons/math3/stat/inference/TTest.xml
977	----------------------------------------------- Protected methods
208	No try-catch or advertised exception because args have just been checked
279	No try-catch or advertised exception because args have just been checked
320	No try-catch or advertised exception because args have just been checked
451	No try-catch or advertised exception because args have just been checked
633	No try-catch or advertised exception because args have just been checked
680	No try-catch or advertised exception because args have just been checked

Commons/xml/main/java/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.xml
178	throws IllegalArgumentException if x and y are not correctly specified
211	Total number of outcomes (equal to 2^N but a lot faster)
219	Generate all possible rank sums
222	(i >> j) & 1 extract i's j-th bit from the right
233	largerRankSums  m gives the one-sided p-value, so it's multiplied with 2 to get the two-sided p-value
249	Same as (but saves computations): final double VarW = ((double) (N  (N + 1)  (2N + 1)))  24;
254	- 0.5 is a continuity correction
257	No try-catch or advertised exception because args are valid

Commons/xml/main/java/org/apache/commons/math3/stat/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/ranking/NaNStrategy.xml

Commons/xml/main/java/org/apache/commons/math3/stat/ranking/NaturalRanking.xml
195	Array recording initial positions of data to be ranked
201	Recode, remove or record positions of NaNs
204	Replace NaNs with +INFs
207	Replace NaNs with -INFs
210	Drop NaNs from data
213	Record positions of NaNs
222	this should not happen unless NaNStrategy enum is changed
226	Sort the IntDoublePairs
229	Walk the sorted array, filling output array using sorted positions, resolving ties as we go
232	position in sorted array
238	tie sequence has ended (or had length 1)
240	if seq is nontrivial, resolve
246	tie sequence continues
251	handle tie sequence at end
275	drop, but adjust original ranks of later elements
337	constant value of ranks over tiesTrace
340	length of sequence of tied ranks
344	Replace ranks with average
347	Replace ranks with maximum values
350	Replace ties with minimum
353	Fill with random integral values in [c, c + length - 1]
357	No advertised exception because args are guaranteed valid
362	Fill sequentially from c to c + length - 1
363	walk and fill
371	this should not happen unless TiesStrategy enum is changed
458	N.B. equals() and hashCode() are not implemented; see MATH-610 for discussion.

Commons/xml/main/java/org/apache/commons/math3/stat/ranking/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/ranking/RankingAlgorithm.xml

Commons/xml/main/java/org/apache/commons/math3/stat/ranking/TiesStrategy.xml

Commons/xml/main/java/org/apache/commons/math3/stat/regression/AbstractMultipleLinearRegression.xml
194	Augment design matrix with initial unitary column
233	Must be no y data either

Commons/xml/main/java/org/apache/commons/math3/stat/regression/GLSMultipleLinearRegression.xml

Commons/xml/main/java/org/apache/commons/math3/stat/regression/MillerUpdatingRegression.xml
202	Must be no y data either
420	Set elements within R to zero if they are less than tol(col) in absolute value after being scaled by the square root of their row multiplier
431	If diagonal element is near zero, set it to zero, set appropriate element of LINDEP, and use INCLUD to augment the projections in the lower rows of the orthogonalization.
730	Special cases.
751	break;
760	break;
791	Adjust variable order (VORDER), the tolerances (TOL) and the vector of residual sums of squares (RSS).

Commons/xml/main/java/org/apache/commons/math3/stat/regression/ModelSpecificationException.xml

Commons/xml/main/java/org/apache/commons/math3/stat/regression/MultipleLinearRegression.xml

Commons/xml/main/java/org/apache/commons/math3/stat/regression/OLSMultipleLinearRegression.xml
106	Create augmented identity matrix
110	No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3
123	Compute and return Hat matrix No DME advertised - args valid if we get here
159	No advertised DME, args are valid

Commons/xml/main/java/org/apache/commons/math3/stat/regression/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/stat/regression/RegressionResults.xml
404	could be stored in upper or lower triangular
412	could be in single array

Commons/xml/main/java/org/apache/commons/math3/stat/regression/SimpleRegression.xml
96	---------------------Public methods--------------------------------------
692	---------------------Private methods-----------------------------------
393	not enough data
396	not enough variation in x
654	No advertised NotStrictlyPositiveException here - will return NaN above
686	No advertised NotStrictlyPositiveException here - will return NaN above
749	final double mse = getMeanSquareError();
814	just the mean
822	final double _syy = sumYY + sumY * sumY / ((double) n);

Commons/xml/main/java/org/apache/commons/math3/stat/regression/UpdatingMultipleLinearRegression.xml

Commons/xml/main/java/org/apache/commons/math3/stat/StatUtils.xml
777	Add the data from the series to stats
782	Compute mean and standard deviation
786	initialize the standardizedSample, which has the same length as the sample
790	z = (x- mean)/standardDeviation

Commons/xml/main/java/org/apache/commons/math3/transform/DctNormalization.xml

Commons/xml/main/java/org/apache/commons/math3/transform/DftNormalization.xml

Commons/xml/main/java/org/apache/commons/math3/transform/DstNormalization.xml

Commons/xml/main/java/org/apache/commons/math3/transform/FastCosineTransformer.xml
148	trivial case
154	construct a new array and perform FFT on it
158	temporary variable for transformed[1]
172	reconstruct the FCT result for the original array

Commons/xml/main/java/org/apache/commons/math3/transform/FastFourierTransformer.xml
138	swap indices i & j
190	This should never occur in normal conditions. However this clause has been added as a safeguard if other types of normalizations are ever implemented, and the corresponding test is forgotten in the present switch.
243	X_0 = x_0 + x_1
246	X_1 = x_0 - x_1
256	Do 4-term DFT.
272	4-term DFT X_0 = x_0 + x_1 + x_2 + x_3
276	X_1 = x_0 - x_2 + j * (x_3 - x_1)
279	X_2 = x_0 - x_1 + x_2 - x_3
282	X_3 = x_0 - x_2 + j * (x_1 - x_3)
301	4-term DFT X_0 = x_0 + x_1 + x_2 + x_3
305	X_1 = x_0 - x_2 + j * (x_3 - x_1)
308	X_2 = x_0 - x_1 + x_2 - x_3
311	X_3 = x_0 - x_2 + j * (x_1 - x_3)
328	Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).
341	dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr
344	dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr
348	WsubN0ToR *= WsubN0R
442	cycle through each dimension
464	if done
468	fft along dimension d
483	value is not important once the recursion is done. then an fft will be applied along the dimension d.
490	further split along the next dimension
526	count dimensions
535	allocate array with exact count
538	fill array

Commons/xml/main/java/org/apache/commons/math3/transform/FastHadamardTransformer.xml
241	Instead of creating a matrix with p+1 columns and n rows, we use two one dimension arrays which we are used in an alternating way.
248	iterate from left to right (column)
251	switch columns
256	iterate from top to bottom (row)
258	Dtop: the top part works with addition
263	Dbottom: the bottom part works with subtraction
292	Instead of creating a matrix with p+1 columns and n rows, we use two one dimension arrays which we are used in an alternating way.
299	iterate from left to right (column)
302	switch columns
307	iterate from top to bottom (row)
309	Dtop: the top part works with addition
314	Dbottom: the bottom part works with subtraction
320	return the last computed output vector y

Commons/xml/main/java/org/apache/commons/math3/transform/FastSineTransformer.xml
153	trivial case
158	construct a new array and perform FFT on it
172	reconstruct the FST result for the original array

Commons/xml/main/java/org/apache/commons/math3/transform/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/transform/RealTransformer.xml

Commons/xml/main/java/org/apache/commons/math3/transform/TransformType.xml

Commons/xml/main/java/org/apache/commons/math3/transform/TransformUtils.xml

Commons/xml/main/java/org/apache/commons/math3/util/ArithmeticUtils.xml
123	Use symmetry for large k
128	We use the formula (n choose k) = n! / (n-k)! / k! (n choose k) == ((n-k+1)*...*n) / (1*...*k) which could be written (n choose k) == (n-1 choose k-1) * n / k
135	For n <= 61, the naive implementation cannot overflow.
142	For n > 61 but n <= 66, the result cannot overflow, but we must take care not to overflow intermediate values.
146	We know that (result * i) is divisible by j, but (result * i) may overflow, so we split j: Filter out the gcd, d, so j/d and i/d are integer. result is divisible by (j/d) because (j/d) is relative prime to (i/d) and is a divisor of result * (i/d).
157	For n > 66, a result overflow might occur, so we check the multiplication, taking care to not overflow unnecessary.
250	For values small enough to do exact integer computation, return the log of the exact value
258	Return the log of binomialCoefficientDouble for values that will not overflow binomialCoefficientDouble
270	Sum logs for values that could overflow
275	n!/(n-k)!
280	divide by k!
448	Now "al" and "bl" fit in an "int".
485	Make "a" and "b" odd, keeping track of common power of 2.
492	"a" and "b" are positive. If a > b then "gdc(a, b)" is equal to "gcd(a - b, b)". If a < b then "gcd(a, b)" is equal to "gcd(b - a, a)". Hence, in the successive iterations: "a" becomes the absolute difference of the current values, "b" becomes the minimum of the current values.
503	Remove any power of 2 in "a" ("b" is guaranteed to be odd).
507	Recover the common power of 2.
550	keep u and v negative, as negative integers range down to -2^63, while positive numbers can only be as large as 2^63-1 (i.e. we can't necessarily negate a negative number without overflow)
557	make u negative
560	make v negative
561	B1. [Find power of 2]
563	while u and v are
564	both even...
567	cast out twos.
573	B2. Initialize: u and v have been divided by 2^k and at least one is odd.
576	t negative: u was odd, v may be even (t replaces v) t positive: u was even, v is odd (t replaces u)
580	B4/B3: cast out twos from t.
581	while t is even..
582	cast out twos
584	B5 [reset max(u,v)]
590	B6/B3. at this point both u and v should be odd.
592	|u| larger: t positive (replace u) |v| larger: t negative (replace v)
595	gcd is u*2^k
697	use symmetry to reduce boundary cases
702	check for positive overflow with negative a, negative b
709	check for negative overflow with negative a, positive b
717	assert b == 0
721	assert a > 0 assert b > 0
724	check for positive overflow with positive a, positive b
731	assert a == 0
775	use additive inverse
985	the cache has never been initialized, compute the first numbers by direct recurrence relation
988	as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE we must stop computation at row 26
1003	atomically save the cache
1009	the number is in the small cache
1012	use explicit formula to compute the number without caching it
1022	definition formula: note that this may trigger some overflow
1029	there was an overflow somewhere
1054	use symmetry to reduce boundary cases
1057	assert a <= b
1061	check for negative overflow
1068	opposite sign addition is always safe
1072	assert a >= 0 assert b >= 0
1075	check for positive overflow

Commons/xml/main/java/org/apache/commons/math3/util/BigReal.xml
256	Division by zero has occured
270	Division by zero has occured

Commons/xml/main/java/org/apache/commons/math3/util/BigRealField.xml
67	CHECKSTYLE: stop HideUtilityClassConstructor
75	CHECKSTYLE: resume HideUtilityClassConstructor
81	return the singleton instance

Commons/xml/main/java/org/apache/commons/math3/util/CompositeFormat.xml
147	check for error parsing number
149	try parsing special numbers
180	set index back to start, error index should be the start index
186	the string was here

Commons/xml/main/java/org/apache/commons/math3/util/ContinuedFraction.xml
129	use the value of small as epsilon criteria for zero checks

Commons/xml/main/java/org/apache/commons/math3/util/Decimal64.xml
79	Methods from the FieldElement interface.
164	Methods from the Number abstract class
224	Methods from the Comparable interface.
241	Methods from the Object abstract class.
283	Methods inspired by the Double class.

Commons/xml/main/java/org/apache/commons/math3/util/Decimal64Field.xml
37	Do nothing

Commons/xml/main/java/org/apache/commons/math3/util/DefaultTransformer.xml
79	some arbitrary number ...

Commons/xml/main/java/org/apache/commons/math3/util/DoubleArray.xml

Commons/xml/main/java/org/apache/commons/math3/util/FastMath.xml
95	0, 1/1024, ... 1024/1024
295	There are 52 bits in the mantissa of a double. For additional precision, the code splits double numbers into two parts, by clearing the low order 30 bits if possible, and then performs the arithmetic on each half separately.
306	1073741824L
309	0xFFFFFFFFC0000000L;
362	Generic helper methods
373	These are un-normalised - don't try to convert
375	can take raw bits because just gonna convert it back
376	Drop low order bits
398	cosh[z] = (exp(z) + exp(-z))/2
400	for numbers with magnitude 20 or so, exp(-z) can be ignored in comparison with exp(z)
405	Avoid overflow (MATH-905).
413	Avoid overflow (MATH-905).
434	recip = 1/y
440	Correct for rounding in division
442	Account for yb
445	y = y + 1/y
468	sinh[z] = (exp(z) - exp(-z) / 2
470	for values of z larger than about 20, exp(-z) can be ignored in comparison with exp(z)
475	Avoid overflow (MATH-905).
483	Avoid overflow (MATH-905).
513	recip = 1/y
519	Correct for rounding in division
521	Account for yb
527	y = y + 1/y
560	Adjust for yb
561	numerator
562	denominator
564	y = y - 1/y
594	tanh[z] = sinh[z] / cosh[z] = (exp(z) - exp(-z)) / (exp(z) + exp(-z)) = (exp(2x) - 1) / (exp(2x) + 1)
598	for magnitude > 20, sinh[z] == cosh[z] in double precision
620	tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
644	ratio = na/da
650	Correct for rounding in division
653	Account for nb
655	Account for db
662	tanh(x) = expm1(2x) / (expm1(2x) + 2)
683	ratio = na/da
689	Correct for rounding in division
692	Account for nb
694	Account for db
781	return +0.0/-0.0/NaN depending on a
790	return +0.0/-0.0/NaN depending on a
853	Lookup exp(floor(x)). intPartA will have the upper 22 bits, intPartB will have the lower 52 bits.
909	Get the fractional part of x, find the greatest multiple of 2^-10 less than x and look up the exp function of it. fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.
917	epsilon is the difference in x from the nearest multiple of 2^-10.  It has a value in the range 0 <= epsilon < 2^-10. Do the subtraction from x as the last step to avoid possible loss of percison.
923	Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has full double precision (52 bits).  Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1.  This will be
928	Remez generated polynomial.  Converges on the interval [0, 2^-10], error
936	Compute (intPartA+intPartB)  (fracPartA+fracPartB) by binomial expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision.
944	Compute the result.  (1+z)(tempA+tempB).  Order of operations is important.  For accuracy add by increasing size.  tempA is exact and much larger than the others.  If there are extra bits specified from the
957	If requesting high precision
979	NaN or zero
984	If not between +/- 1.0 return exp(x) - 1.0;
1045	double yb = za*baseB + zb*baseA + zb*baseB;
1058	ya = ya + za + baseA; yb = yb + zb + baseB;
1065	yb += (ya > za) ? -(temp - ya - za) : -(temp - za - ya);
1070	yb += (ya > baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);
1075	yb += (ya > zb) ? -(temp - ya - zb) : -(temp - zb - ya);
1095	f(x) = x/1+x Compute f'(x) Product rule:  d(uv) = du*v + u*dv Chain rule:  d(f(g(x)) = f'(g(x))*f(g'(x)) d(1/x) = -1/(x*x) d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x)) d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))
1103	Adjust for yb
1104	numerator
1105	denominator
1107	negate
1137	Handle special case of +0/-0
1164	Subnormal!
1166	Zero
1184	The normal method doesn't work well in the range [0.99, 1.01], so call do a straight
1230	lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)
1233	double epsilon = x  Double.longBitsToDouble(bits & 0xfffffc0000000000L);  epsilon -= 1.0;
1239	y is the most significant 10 bits of the mantissa double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L); double epsilon = (x - y) / y;
1290	tmp = aa  1073741824.0; lnza = aa + tmp - tmp; lnzb = aa - lnza + ab;
1298	High precision not required.  Eval Remez polynomial
1309	Relative sizes: lnzb     [0, 2.33E-10] lnm[1]   [0, 1.17E-7] ln2Bexp [0, 1.12E-4] lnza      [0, 9.7E-4] lnm[0]   [0, 0.692] ln2Aexp [0, 709]
1318	Compute the following sum: lnzb + lnm[1] + ln2Bexp + lnza + lnm[0] + ln2Aexp;
1322	return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
1380	Don't allow this to be converted to NaN
1384	Do a taylor series expansion around xpa: f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2
1390	Value is small |x| < 1e6, do a Taylor series centered on 1.
1404	don't allow this to be converted to NaN
1452	X is NaN
1460	-zero
1483	y is NaN
1506	y is NaN
1544	y is an even integer in this case
1550	If y is an integer
1573	don't allow this to be converted to NaN
1586	y*ln(x) = (aa+ab)
1601	result = result + result * z;
1623	split d as two 26 bits numbers beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
1630	prepare result
1634	d^(2p)
1642	accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
1653	accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
1687	p *= x2; p *= x;
1721	idx*0.125;
1723	Table lookups
1729	Polynomial eval of sin(epsilon), cos(epsilon)
1735	Split epsilon   xa + xb = x
1744	Compute the following sum:  result = sintA + costAsinEpsA + sintAcosEpsB + costAsinEpsB + sintB + costBsinEpsA + sintBcosEpsB + costBsinEpsB;  Ranges of elements  xxxtA   0            PI2 xxxtB   -1.5e-9      1.5e-9 sinEpsA -0.0625      0.0625 sinEpsB -6e-11       6e-11 cosEpsA  1.0 cosEpsB  0           -0.0625
1760	result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
1763	result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB; result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;
1781	t = sintAcosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d;  t = costAsinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d;
1796	t = sintB; c = a + t; d = -(c - a - t); a = c; b = b + d;  t = costBsinEpsA; c = a + t; d = -(c - a - t); a = c; b = b + d;  t = sintBcosEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d;  t = costBsinEpsB; c = a + t; d = -(c - a - t); a = c; b = b + d;
1824	approximate cosine*xb
1865	idx*0.125;
1867	Table lookups
1873	Polynomial eval of sin(epsilon), cos(epsilon)
1879	Split epsilon   xa + xb = x
1887	Compute the following sum:  result = sintA + costAsinEpsA + sintAcosEpsB + costAsinEpsB + sintB + costBsinEpsA + sintBcosEpsB + costBsinEpsB;  Ranges of elements  xxxtA   0            PI2 xxxtB   -1.5e-9      1.5e-9 sinEpsA -0.0625      0.0625 sinEpsB -6e-11       6e-11 cosEpsA  1.0 cosEpsB  0           -0.0625
1903	result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
1906	result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB; result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;
1911	Compute sine
1930	Compute cosine
1960	double est = (sina+sinb)(cosa+cosb); double err = (sina - cosaest) + (sinb - cosbest); est += err(cosa+cosb); err = (sina - cosaest) + (sinb - cosbest);
1967	f(x) = 1/x,   f'(x) = -1/x^2
1980	double err = (sina - est*cosa)/cosa;  // Correction for division rounding
1981	Correction for division rounding
1982	Change in est due to sinb
1983	Change in est due to cosb
1986	tan' = 1 + tan^2      cot' = -(1 + cot^2) Approximate impact of xb
2111	prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of PI2, so use the following steps: 1.) multiply by 4. 2.) do a fixed point muliply by PI4. 3.) Convert to floating point. 4.) Multiply by 2
2210	High order 52 bits
2211	Low bits
2256	PI * (2**20) Argument too big for CodyWaite reduction.  Must use PayneHanek.
2272	Flip bit 1
2311	PI * (2**20) Argument too big for CodyWaite reduction.  Must use PayneHanek.
2326	if (negative) quadrant = (quadrant + 2) % 4;
2376	PI * (2**20) Argument too big for CodyWaite reduction.  Must use PayneHanek.
2392	Accuracy suffers between 1.5 and PI/2
2439	Matches +/- 0.0; return correct sign
2444	negative
2450	Very large input
2476	if (idx > 8 || idx == 0)
2479	double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);
2481	double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);
2518	yb = -0.09001346640161823; yb = yb  epsA2 + 0.11110718400605211; yb = yb  epsA2 + -0.1428571349122913; yb = yb  epsA2 + 0.19999999999273194; yb = yb  epsA2 + -0.33333333333333093; yb = yb  epsA2  epsA;
2545	result = yb + eighths[idx] + ya;
2556	Result is in the left plane
2592	X is infinite
2594	return +/- 0.0
2611	y cannot now be zero
2658	Neither y nor x can be infinite or NAN here
2670	Compute ratio r = y/x
2672	bypass calculations that can create NaN
2679	Split x
2689	Fix up the sign so atan works correctly
2693	Call atan
2720	Matches +/- 0.0; return correct sign
2759	Compute ratio r = x/y
2765	Correct for rounding in division
2766	Add in effect additional bits of sqrt.
2836	Compute ratio r = y/x
2839	Did r overflow?
2840	x is effectively zero
2841	so return the appropriate value
2847	Correct for rounding in division
2848	Add in effect additional bits of sqrt.
2874	2^54
2880	Nan or infinity.  Don't care which.
2903	est should now be good to about 15 bits of precision.   Do 2 rounds of Newton's method to get closer,  this should get us full double precision Scale down x for the purpose of doing newtons method.  This avoids over/under flows.
2910	Do one round of Newton's method in extended precision to get the last bit right.
2935	2^-18
2948	Matches +/- 0.0; return correct sign
2952	These are PI/180 split into high and low order bits
2961	ensure correct sign if calculation underflows
2973	Matches +/- 0.0; return correct sign
2977	These are 180/PI split into high and low order bits
3004	l is one if x negative zero else ~l+1 is zero if x is positive, -1 if x is negative x^(~l+1) is x is x is positive, ~x if x is negative add around
3061	first simple and fast handling when 2^n can be represented using normal numbers
3066	handle special cases
3077	decompose d
3083	compute scaled exponent
3087	we are really in the case n <= -1023
3089	both the input and the result are normal numbers, we only adjust the exponent
3092	the input is a normal number and the result is a subnormal number
3094	recover the hidden mantissa bit
3097	scales down complete mantissa, hence losing least significant bits
3101	we need to add 1 bit to round up the result
3107	no need to compute the mantissa, the number scales down to 0
3111	we are really in the case n >= 1024
3114	the input number is subnormal, normalize it
3145	first simple and fast handling when 2^n can be represented using normal numbers
3150	handle special cases
3161	decompose f
3167	compute scaled exponent
3171	we are really in the case n <= -127
3173	both the input and the result are normal numbers, we only adjust the exponent
3176	the input is a normal number and the result is a subnormal number
3178	recover the hidden mantissa bit
3181	scales down complete mantissa, hence losing least significant bits
3185	we need to add 1 bit to round up the result
3191	no need to compute the mantissa, the number scales down to 0
3195	we are really in the case n >= 128
3198	the input number is subnormal, normalize it
3254	handling of some important special cases
3264	special cases MAX_VALUE to infinity and  MIN_VALUE to 0 are handled just as normal numbers can use raw bits since already dealt with infinity and NaN
3310	handling of some important special cases
3320	special cases MAX_VALUE to infinity and  MIN_VALUE to 0 are handled just as normal numbers
3340	NaN
3367	NaN
3395	Preserve sign of operand
3584	y is neglectible with respect to x
3587	x is neglectible with respect to y
3591	find an intermediate scale to avoid both overflow and underflow
3594	scale parameters without losing precision
3598	compute scaled hypotenuse
3601	remove scaling
3630	TODO provide our own implementation
3642	The highest order bit is going to be zero if the highest order bit of m and s is the same and one otherwise. So (m^s) will be positive if both m and s have the same sign and negative otherwise.
3646	don't care about NaN
3651	flip sign
3663	The highest order bit is going to be zero if the highest order bit of m and s is the same and one otherwise. So (m^s) will be positive if both m and s have the same sign and negative otherwise.
3672	flip sign
3685	NaN and Infinite will return 1024 anywho so can use raw bits
3699	NaN and Infinite will return the same exponent anywho so can use raw bits
3828	Estimate k. k = (int)(xa / 1.5707963267948966);
3832	Compute remainder.
3854	Remainder is negative, so decrement k and try again. This should only happen if the input is very close to an even multiple of pi/2.

Commons/xml/main/java/org/apache/commons/math3/util/FastMathCalc.xml
34	1073741824L
130	Even, use double angle
220	skip odd entries
227	alternate terms are negative
264	Ignore even numbers
271	alternate terms are negative
350	MAGIC NUMBER
416	can happen if result[1] is NAN
494	double x = M_E;
498	split(x, xs); xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]); xs[0] = 2.71827697753906250000; xs[1] = 4.85091998273542816811e-06; xs[0] = Double.longBitsToDouble(0x4005bf0800000000L); xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);
573	x[0] -= 1.0; resplit(x);
608	"double array[]" causes PMD parsing error
610	assume inner array has very few entries
611	multiple entries per line
630	one entry per line

Commons/xml/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.xml

Commons/xml/main/java/org/apache/commons/math3/util/Incrementor.xml

Commons/xml/main/java/org/apache/commons/math3/util/IterationEvent.xml

Commons/xml/main/java/org/apache/commons/math3/util/IterationListener.xml

Commons/xml/main/java/org/apache/commons/math3/util/IterationManager.xml

Commons/xml/main/java/org/apache/commons/math3/util/MathArrays.xml
341	Should never happen.
406	Should never happen.
414	Loop completed.
418	Loop early exit means wrong ordering.
716	Should never happen.
716	Should never happen.
849	either we have split infinite numbers or some coefficients were NaNs, just rely on the naive implementation and let IEEE754 handle this
884	the code below is split in many additions/subtractions that may appear redundant. However, they should NOT be simplified, as they use IEEE754 floating point arithmetic rounding properties. as an example, the expression "ca1 - (ca1 - a1)" is NOT the same as "a1" The variable naming conventions are that xyzHigh contains the most significant bits of xyz and xyzLow contains its least significant bits. So theoretically xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot be represented in only one double precision number so we preserve two numbers to hold it as long as we can, combining the high and low order bits together only at the end, after cancellation may have occurred on high order bits
895	split a1 and b1 as two 26 bits numbers
903	accurate multiplication a1 * b1
907	split a2 and b2 as two 26 bits numbers
915	accurate multiplication a2 * b2
919	accurate addition a1 * b1 + a2 * b2
924	final rounding, s12 may have suffered many cancellations, we try to recover some bits from the extra words we have saved up to now
929	either we have split infinite numbers or some coefficients were NaNs, just rely on the naive implementation and let IEEE754 handle this
964	the code below is split in many additions/subtractions that may appear redundant. However, they should NOT be simplified, as they do use IEEE754 floating point arithmetic rounding properties. as an example, the expression "ca1 - (ca1 - a1)" is NOT the same as "a1" The variables naming conventions are that xyzHigh contains the most significant bits of xyz and xyzLow contains its least significant bits. So theoretically xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot be represented in only one double precision number so we preserve two numbers to hold it as long as we can, combining the high and low order bits together only at the end, after cancellation may have occurred on high order bits
975	split a1 and b1 as two 26 bits numbers
983	accurate multiplication a1 * b1
987	split a2 and b2 as two 26 bits numbers
995	accurate multiplication a2 * b2
999	split a3 and b3 as two 26 bits numbers
1007	accurate multiplication a3 * b3
1011	accurate addition a1 * b1 + a2 * b2
1016	accurate addition a1 * b1 + a2 * b2 + a3 * b3
1021	final rounding, s123 may have suffered many cancellations, we try to recover some bits from the extra words we have saved up to now
1026	either we have split infinite numbers or some coefficients were NaNs, just rely on the naive implementation and let IEEE754 handle this
1066	the code below is split in many additions/subtractions that may appear redundant. However, they should NOT be simplified, as they do use IEEE754 floating point arithmetic rounding properties. as an example, the expression "ca1 - (ca1 - a1)" is NOT the same as "a1" The variables naming conventions are that xyzHigh contains the most significant bits of xyz and xyzLow contains its least significant bits. So theoretically xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot be represented in only one double precision number so we preserve two numbers to hold it as long as we can, combining the high and low order bits together only at the end, after cancellation may have occurred on high order bits
1077	split a1 and b1 as two 26 bits numbers
1085	accurate multiplication a1 * b1
1089	split a2 and b2 as two 26 bits numbers
1097	accurate multiplication a2 * b2
1101	split a3 and b3 as two 26 bits numbers
1109	accurate multiplication a3 * b3
1113	split a4 and b4 as two 26 bits numbers
1121	accurate multiplication a4 * b4
1125	accurate addition a1 * b1 + a2 * b2
1130	accurate addition a1 * b1 + a2 * b2 + a3 * b3
1135	accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4
1140	final rounding, s1234 may have suffered many cancellations, we try to recover some bits from the extra words we have saved up to now
1145	either we have split infinite numbers or some coefficients were NaNs, just rely on the naive implementation and let IEEE754 handle this
1320	OK because field must be correct class

Commons/xml/main/java/org/apache/commons/math3/util/MathUtils.xml
131	Sign is OK.
137	Flip sign.
154	Sign is OK.
160	Flip sign.
177	Sign is OK.
183	Flip sign.
200	Sign is OK.
206	Flip sign.

Commons/xml/main/java/org/apache/commons/math3/util/MultidimensionalCounter.xml

Commons/xml/main/java/org/apache/commons/math3/util/NumberTransformer.xml

Commons/xml/main/java/org/apache/commons/math3/util/OpenIntToDoubleHashMap.xml
295	due to the loop exit condition, if (states[index] == FULL) then keys[index] == key
498	preserve the modification count of the map to detect concurrent modifications later
501	initialize current index
505	NOPMD
506	ignored
565	advance on step
568	prepare next step
570	NOPMD
571	nothing to do

Commons/xml/main/java/org/apache/commons/math3/util/OpenIntToFieldHashMap.xml
308	due to the loop exit condition, if (states[index] == FULL) then keys[index] == key
614	field is of type T
511	preserve the modification count of the map to detect concurrent modifications later
514	initialize current index
518	NOPMD
519	ignored
578	advance on step
581	prepare next step
583	NOPMD
584	nothing to do
614	field is of type T

Commons/xml/main/java/org/apache/commons/math3/util/package-info.xml

Commons/xml/main/java/org/apache/commons/math3/util/Pair.xml

Commons/xml/main/java/org/apache/commons/math3/util/Precision.xml
207	Make lexicographically ordered as a two's-complement integer.
335	Make lexicographically ordered as a two's-complement integer.
494	The following equality test is intentional and needed for rounding purposes
496	even
498	odd

Commons/xml/main/java/org/apache/commons/math3/util/ResizableDoubleArray.xml
372	XXX Just ot retain the expected failure in a unit test. With the new "enum", that test will become obsolete.
485	Increment the start index
488	Add the new value
491	Check the contraction criterion.
594	Copy and swap - copy only the element array from the src array.
598	Reset the start index to zero
665	"Subtract" this number of discarded from numElements
686	notice the use of FastMath.ceil(), this guarantees that we will always have an array of at least currentSize + 1.   Assume that the current initial capacity is 1 and the expansion factor is 1.000000000000000001.  The newly calculated size will be rounded up to 2 after the multiplication is performed.
699	Copy and swap
711	Copy and swap
816	Should never happen.
988	The check above verifies that the expansion factor is > 1.0;
1042	Body removed in 3.1.
1055	If index is negative thrown an error.
1062	Test the new num elements, check to see if the array needs to be expanded to accommodate this new number of elements.
1069	Set the new number of elements to new value.

Commons/xml/main/java/org/apache/commons/math3/util/TransformerMap.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.xml
228	f(x, y, z) = x + 5 x y - 2 z + (8 z x - y)^3
246	df/dx = 1 + 5 y + 24 (8 z x - y)^2 z
253	df/dxdy = 5 + 48 z*(y - 8 z x)
260	df/dxdydz = 48 (y - 16 z x)
371	the following checks shows a LIMITATION of the current implementation we have no way to tell dsZero is a pure linear variable x = 0 we only say: "dsZero is a structure with value = 0.0, first derivative = 1.0, second and higher derivatives = 0.0". Function composition rule for second derivatives is: d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x) when function f is the nth root and x = 0 we have: f(0) = 0, f'(0) = +infinity, f''(0) = -infinity (and higher derivatives keep switching between +infinity and -infinity) so given that in our case dsZero represents g, we have g(x) = 0, g'(x) = 1 and g''(x) = 0 applying the composition rules gives: d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x) = -infinity * 1^2 + +infinity * 0 = -infinity + NaN = NaN if we knew dsZero is really the x variable and not the identity function applied to x, we would not have computed f'(g(x)) * g''(x) and we would have found that the result was -infinity and not NaN
394	the following shows that the limitation explained above is NOT a bug... if we set up the higher order derivatives for g appropriately, we do compute the higher order derivatives of the composition correctly
1245	expected
1267	expected
1332	we compare accurate versus naive dot product implementations on regular vectors (i.e. not extreme cases like in the previous test)
1376	we compare accurate versus naive dot product implementations on regular vectors (i.e. not extreme cases like in the previous test)
1429	check dimension
1432	check value, directly and also as 0th order derivative
1436	check first order derivatives
1447	check dimension

Commons/xml/test/java/org/apache/commons/math3/analysis/differentiation/DSCompilerTest.xml
247	the following reference rules have all been computed independently from the library, using only pencil and paper and some search and replace to handle symmetries

Commons/xml/test/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiatorTest.xml
148	the 0.25 step size is good for finite differences in the quintic on this abscissa range for 7 points the errors are fair
154	the 1.0e-6 step size is far too small for finite differences in the quintic on this abscissa range for 7 points the errors are huge!
172	this exception should not be thrown because wrong order should be detected before function call
172	this exception should not be thrown because wrong order should be detected before function call
185	this exception should not be thrown because wrong order should be detected before function call
185	this exception should not be thrown because wrong order should be detected before function call
198	this exception should not be thrown because wrong order should be detected before function call
198	this exception should not be thrown because wrong order should be detected before function call
235	here, we did not set the bounds, so the differences are evaluated out of domain using f(-0.05), f(0.05), f(0.15)
246	here, we did not set the bounds, so the differences are evaluated out of domain using f(0.85), f(0.95), f(1.05)
256	here, we did set the bounds, so evaluations are done within domain using f(0.0), f(0.1), f(0.2)
260	here, we did set the bounds, so evaluations are done within domain using f(0.8), f(0.9), f(1.0)
277	we are able to compute derivative near 0, but the accuracy is much poorer there

Commons/xml/test/java/org/apache/commons/math3/analysis/differentiation/GradientFunctionTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/differentiation/JacobianFunctionTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/function/GaussianTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/function/HarmonicOscillatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/function/LogisticTest.xml
149	Compare using the "Sigmoid" function.

Commons/xml/test/java/org/apache/commons/math3/analysis/function/LogitTest.xml
91	expected
198	each function evaluates correctly near boundaries, but combination leads to NaN as some intermediate point is infinite

Commons/xml/test/java/org/apache/commons/math3/analysis/function/SigmoidTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/function/SincTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/function/SqrtTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/function/StepFunctionTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/FunctionUtilsTest.xml
242	Sin implements both UnivariateDifferentiableFunction and DifferentiableUnivariateFunction
256	Sin implements both UnivariateDifferentiableFunction and DifferentiableUnivariateFunction

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/gauss/BaseRuleFactoryTest.xml
46	Number of times the same rule will be called.
59	Ensure that all computations have completed.
64	Assertion would fail if "getRuleInternal" were not "synchronized".
74	Always request the same rule.
89	Tracks whether this computation has been called more than once.
93	Sleep to simulate computation time.
99	Dummy rule (but contents must exist).

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/gauss/GaussianQuadratureAbstractTest.xml
101	System.out.println(n + "/" + maxDegree + " " + integrator.getNumberOfPoints() + " " + expected + " " + actual + " " + Math.ulp(expected));

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/gauss/LegendreHighPrecisionParametricTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/gauss/LegendreHighPrecisionTest.xml
41	System.out.println("s=" + s + " e=" + 1);
57	System.out.println("s=" + s + " e=" + expected);

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/gauss/LegendreParametricTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/gauss/LegendreTest.xml
41	System.out.println("s=" + s + " e=" + 1);
57	System.out.println("s=" + s + " e=" + expected);

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/IterativeLegendreGaussIntegratorTest.xml
89	an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly
117	due to the discontinuity, integration implies *many* calls
123	setting up limits prevents such large number of calls
128	expected
132	integrating on the two sides should be simpler

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/LegendreGaussIntegratorTest.xml
89	an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly
116	due to the discontinuity, integration implies *many* calls
122	setting up limits prevents such large number of calls
127	expected
131	integrating on the two sides should be simpler

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/RombergIntegratorTest.xml
104	bad interval
108	expected
111	bad iteration limits
115	expected
118	bad iteration limits
122	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/SimpsonIntegratorTest.xml
102	bad interval
106	expected
109	bad iteration limits
113	expected
116	bad iteration limits
120	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/integration/TrapezoidIntegratorTest.xml
104	bad interval
108	expected
111	bad iteration limits
115	expected
118	bad iteration limits
122	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.xml
50	Expected
57	Expected
64	Expected
70	Expected
76	Expected
82	Expected
90	Expected
96	Expected
102	Expected
108	Expected
121	Function values
133	Partial derivatives with respect to x
140	Partial derivatives with respect to y
147	Partial cross-derivatives
191	Function values
203	Partial derivatives with respect to x
215	Partial derivatives with respect to y
227	Partial cross-derivatives
355	Coordinate values
360	Function values
380	Partial derivatives with respect to x
394	Partial derivatives with respect to y
408	Partial cross-derivatives

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatorTest.xml
51	Expected
59	Expected
67	Expected
74	Expected

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/DividedDifferenceInterpolatorTest.xml
56	6 interpolating points on interval [0, 2*PI]
88	5 interpolating points on interval [-1, 1]
121	bad abscissas array
128	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/FieldHermiteInterpolatorTest.xml
213	this test corresponds to the example from Wikipedia page: http:en.wikipedia.org/wiki/Hermite_interpolation

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolatorTest.xml
193	this test corresponds to the example from Wikipedia page: http:en.wikipedia.org/wiki/Hermite_interpolation

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/LinearInterpolatorTest.xml
53	Verify coefficients using analytical values
60	Check interpolation
75	Verify coefficients using analytical values
84	Check interpolation
98	Verify coefficients using analytical values
108	Data set arrays of different size.
116	Expected.
118	X values not sorted.
125	Expected.
127	Not enough data to interpolate.
134	Expected.

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/LoessInterpolatorTest.xml
81	Check that the resulting curve differs from the "real" sine less than the jittered one
109	Check that variance decreases as bandwidth increases
140	Introduce a couple of outliers
144	Check that variance decreases as the number of robustness iterations increases
238	Output from R, rounded to .001

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/MicrosphereInterpolatorTest.xml
49	Interpolating points in [-1, 1][-1, 1] by steps of 1.
101	Interpolating points in [-10, 10][-10, 10] by steps of 2.

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/NevilleInterpolatorTest.xml
56	6 interpolating points on interval [0, 2*PI]
88	5 interpolating points on interval [-1, 1]
121	bad abscissas array
128	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.xml
52	Expected
60	Expected
68	Expected
75	Expected
82	Expected

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/SplineInterpolatorTest.xml
57	Verify coefficients using analytical values
64	Check interpolation
79	Verify coefficients using analytical values
88	Check interpolation
103	Verify coefficients using analytical values
130	Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)  To replicate in R: x[1] <- 0 x[2] <- pi  6, etc, same for y[] (could use y <- scan() for y values) g <- splinefun(x, y, "natural") splinecoef <- eval(expression(z), envir = environment(g)) print(splinecoef)
157	Check interpolation
164	Data set arrays of different size.
172	Expected.
174	X values not sorted.
181	Expected.
183	Not enough data to interpolate.
190	Expected.
212	evaluate polynomials and derivatives at x[i + 1]

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.xml
55	Expected
64	Expected
73	Expected
82	Expected
90	Expected
98	Expected
106	Expected
114	Expected
122	Expected
130	Expected
138	Expected
147	Expected
155	Expected
163	Expected
171	Expected
179	Expected
187	Expected
195	Expected
203	Expected
212	Expected
220	Expected
228	Expected
236	Expected
244	Expected
252	Expected
260	Expected
268	Expected
284	Function values
300	Partial derivatives with respect to x
309	Partial derivatives with respect to y
319	Partial derivatives with respect to z
328	Partial cross-derivatives
394	Function values
410	Partial derivatives with respect to x
425	Partial derivatives with respect to y
440	Partial derivatives with respect to z
455	Partial second derivatives w.r.t. (x, y)
470	Partial second derivatives w.r.t. (x, z)
485	Partial second derivatives w.r.t. (y, z)
500	Partial third derivatives

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatorTest.xml
53	Expected
61	Expected
69	Expected
77	Expected
84	Expected
91	Expected
167	Function values

Commons/xml/test/java/org/apache/commons/math3/analysis/interpolation/UnivariatePeriodicInterpolatorTest.xml
59	Comparing with original interpolation algorithm.
70	Test interpolation outside the primary interval.
101	Test interpolation outside the sample data interval.
132	Test interpolation outside the sample data interval.

Commons/xml/test/java/org/apache/commons/math3/analysis/MonitoredFunction.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionLagrangeFormTest.xml
43	p(x) = 1.5x - 4
73	p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)
104	p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)
137	bad input array length
143	expected
146	mismatch input arrays
152	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionNewtonFormTest.xml
43	p(x) = 1.5x - 4 = 2 + 1.5(x-4)
73	p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)
104	p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)
137	x^3 = 0 * [1] + 1 * [x] + 3 * [x(x-1)] + 1 * [x(x-1)(x-2)]
162	bad input array length
168	expected
171	mismatch input arrays
177	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionTest.xml
45	verify that we are equal to c[0] at several (nonsymmetric) places
72	verify that we are equal to c[0] when x=0
75	now check a few other places
96	verify that we are equal to c[0] when x=0
99	now check a few other places
116	verify that we are equal to c[0] when x=0
119	now check a few other places
146	compare f' = g
153	compare g' = h
245	compare f' = g
252	compare g' = h

Commons/xml/test/java/org/apache/commons/math3/analysis/polynomials/PolynomialSplineFunctionTest.xml
71	too few knots
75	expected
78	too many knots
82	expected
85	knots not increasing
89	expected
99	interior points -- spline value at x should equal p(x - knot) where knot is the largest knot point less than or equal to x and p is the polynomial defined over the knot segment to which x belongs.
115	knot points -- centering should zero arguments
123	outside of domain -- under min
127	expected
130	outside of domain -- over max
134	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/polynomials/PolynomialsUtilsTest.xml
324	f1(x) = 1 + x + 2 x^2
339	f2(x) = 2 + 3 x^2 + 8 x^3 + 121 x^5
381	integral should be non-zero
385	integral should be zero

Commons/xml/test/java/org/apache/commons/math3/analysis/QuinticFunction.xml
30	Evaluate quintic. @see org.apache.commons.math3.UnivariateFunction#value(double)

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/BaseSecantSolverAbstractTest.xml
52	The sinus function is behaved well around the root at pi. The second order derivative is zero, which means linear approximating methods still converge quadratically.
60	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
65	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
73	The quintic function has zeros at 0, +-0.5 and +-1. Around the root of 0 the function is well behaved, with a second derivative of zero a 0. The other roots are less well to find, in particular the root at 1, because the function grows fast for x>1. The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643, intervals containing these values are harder for the solvers.
87	Tests data: initial bounds, and expected solution, per test case.
103	Skip test, if needed.
106	Compute solution.
109	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
112	Check solution.
123	End-point is root. This should be a special case in the solver, and the initial end-point should be returned exactly.
142	bad interval
146	expected
148	no bracket
152	expected
154	no bracket
158	expected
169	Test whether the allowed solutions are taken into account.
175	Prepare for next test.
188	Test whether the allowed solutions are taken into account.
194	Prepare for next test.
206	Test whether the allowed solutions are taken into account.
212	Prepare for next test.
225	Test whether the allowed solutions are taken into account.
231	Prepare for next test.
247	the solution slipped out of interval

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/BisectionSolverTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolverTest.xml
102	the following test functions come from Beny Neta's paper: "Several New Methods for solving Equations" intern J. Computer Math Vol 23 pp 265-282 available here: http:www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF the reference roots have been computed by the Dfp solver to more than 80 digits and checked with emacs (only the first 20 digits are reproduced here)
171	bracketing solver evaluates only function value, we set the weight to 1
174	Newton-Raphson solver evaluates both function value and derivative, we set the weight to 2

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/BrentSolverTest.xml
51	The sinus function is behaved well around the root at pi. The second order derivative is zero, which means linar approximating methods will still converge quadratically.
57	Somewhat benign interval. The function is monotone.
59	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
63	Larger and somewhat less benign interval. The function is grows first.
65	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
73	The quintic function has zeros at 0, +-0.5 and +-1. Around the root of 0 the function is well behaved, with a second derivative of zero a 0. The other roots are less well to find, in particular the root at 1, because the function grows fast for x>1. The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643, intervals containing these values are harder for the solvers.
82	Brent-Dekker solver.
84	Symmetric bracket around 0. Test whether solvers can handle hitting the root in the first iteration.
87	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
91	1 iterations on i586 JDK 1.4.1. Asymmetric bracket around 0, just for fun. Contains extremum.
94	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
97	5 iterations on i586 JDK 1.4.1.
99	Large bracket around 0. Contains two extrema.
101	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
104	6 iterations on i586 JDK 1.4.1.
106	Benign bracket around 0.5, function is monotonous.
108	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
111	6 iterations on i586 JDK 1.4.1.
113	Less benign bracket around 0.5, contains one extremum.
115	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
119	Large, less benign bracket around 0.5, contains both extrema.
121	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
125	Relatively benign bracket around 1, function is monotonous. Fast growth for x>1 is still a problem.
128	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
132	Less benign bracket around 1 with extremum.
134	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
138	Large bracket around 1. Monotonous.
140	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
144	Large bracket around 1. Interval contains extremum.
146	System.out.println( "Root: " + result + " Evaluations: " + solver.getEvaluations());
150	Very large bracket around 1 for testing fast growth behaviour.
152	System.out.println(
153	"Root: " + result + " Evaluations: " + solver.getEvaluations());
161	Expected.
170	endpoint is root
188	bad interval
192	expected
194	no bracket
198	expected
200	no bracket
204	expected
214	no guess
220	invalid guess (it *is* a root, but outside of the range)
225	expected behaviour
228	bad guess
234	good guess
240	perfect guess

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/IllinoisSolverTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/LaguerreSolverTest.xml
47	p(x) = 4x - 1
66	p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)
91	p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)
121	p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)
147	bad interval
151	expected
154	no bracketing
158	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/MullerSolver2Test.xml
133	bad interval
137	expected
140	no bracketing
144	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/MullerSolverTest.xml
135	bad interval
140	expected
143	no bracketing
147	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolverTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/NewtonSolverTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/PegasusSolverTest.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolverTest.xml
41	While the Regula Falsi method guarantees convergence, convergence may be extremely slow. The last test case does not converge within even a million iterations. As such, it was disabled.

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/RiddersSolverTest.xml
129	bad interval
133	expected
136	no bracketing
140	expected

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/SecantSolverTest.xml
36	As the Secant method does not maintain a bracketed solution, convergence is not guaranteed. Two test cases are disabled (-1) due to bad solutions.

Commons/xml/test/java/org/apache/commons/math3/analysis/solvers/UnivariateSolverUtilsTest.xml
49	bad accuracy
51	Assert.fail("Expecting MathIllegalArgumentException"); // TODO needs rework since convergence behaviour was changed
53	expected
109	endpoints not valid
115	bad maximum iterations
123	Static solve method

Commons/xml/test/java/org/apache/commons/math3/analysis/SumSincFunction.xml

Commons/xml/test/java/org/apache/commons/math3/analysis/XMinus5Function.xml
30	Evaluate x - 5 fuction. @see org.apache.commons.math3.UnivariateFunction#value(double)

Commons/xml/test/java/org/apache/commons/math3/complex/ComplexFieldTest.xml
38	deserializing the singleton should give the singleton itself back

Commons/xml/test/java/org/apache/commons/math3/complex/ComplexFormatAbstractTest.xml

Commons/xml/test/java/org/apache/commons/math3/complex/ComplexFormatTest.xml

Commons/xml/test/java/org/apache/commons/math3/complex/ComplexTest.xml
232	Assert.assertEquals(z, Complex.INF); // See MATH-657
363	Assert.assertTrue(infInf.multiply(infInf).isNaN()); // MATH-620
374	[MATH-164]
1087	The complex number we want to compute all third-roots for.
1089	The List holding all third roots
1091	Returned Collection must not be empty!
1093	test z_0
1096	test z_1
1099	test z_2
1119	The complex number we want to compute all third-roots for.
1121	The List holding all fourth roots
1123	Returned Collection must not be empty!
1125	test z_0
1128	test z_1
1131	test z_2
1134	test z_3
1152	The number 8 has three third roots. One we all already know is the number 2. But there are two more complex roots.
1155	The List holding all third roots
1157	Returned Collection must not be empty!
1159	test z_0
1162	test z_1
1165	test z_2
1184	complex number with only imaginary part
1186	The List holding all third roots
1188	Returned Collection must not be empty!
1190	test z_0
1193	test z_1
1196	test z_2
1206	NaN + finite -> NaN
1215	NaN + infinite -> NaN
1220	finite + infinite -> Inf
1225	infinite + infinite -> Inf

Commons/xml/test/java/org/apache/commons/math3/complex/ComplexUtilsTest.xml

Commons/xml/test/java/org/apache/commons/math3/complex/FrenchComplexFormatTest.xml

Commons/xml/test/java/org/apache/commons/math3/complex/QuaternionTest.xml
108	Case : analytic test case
119	comparison with the result given by the formula : qResult = (scalarA * scalarB - vectorA . vectorB) + (scalarA * vectorB + scalarB * vectorA + vectorA ^ vectorB)
137	Conjugate of the product of two quaternions and product of their conjugates : Conj(qA * qB) = Conj(qB) * Conj(qA)
152	Case : Product between a vector and a quaternion : QxV
163	comparison with the result given by the formula : qResult = (- vectorQ . vector) + (scalarQ * vector + vectorQ ^ vector)
177	Case : Product between a vector and a quaternion : VxQ
188	comparison with the result given by the formula : qResult = (- vector . vectorQ) + (scalarQ * vector + vector ^ vectorQ)
202	expected output
204	inputs
217	expected outputs
222	inputs
236	expected outputs
241	inputs
261	expected outputs
266	inputs
443	expected

Commons/xml/test/java/org/apache/commons/math3/complex/RootsOfUnityTest.xml
64	Testing -5 right after 5 is important, as the roots in this case are not recomputed.
78	Testing -n right after n is important, as the roots in this case are not recomputed.

Commons/xml/test/java/org/apache/commons/math3/dfp/BracketingNthOrderBrentSolverDFPTest.xml
81	the following test functions come from Beny Neta's paper: "Several New Methods for solving Equations" intern J. Computer Math Vol 23 pp 265-282 available here: http:www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF
154	this should never happen

Commons/xml/test/java/org/apache/commons/math3/dfp/Decimal10.xml

Commons/xml/test/java/org/apache/commons/math3/dfp/DfpDecTest.xml
48	Generic test function.  Takes params x and y and tests them for equality.  Then checks the status flags against the flags argument. If the test fail, it prints the desc string
34	Some basic setup.  Define some constants and clear the status flags
54	NaNs involved
57	distinguish +/- zero
159	Round down
174	Round up
197	Round half up
220	Round half down
243	Round half odd
262	Round ceil
273	Round floor
282	reset
376	RoundDecimal10 down
391	RoundDecimal10 up
414	RoundDecimal10 half up
437	RoundDecimal10 half down
460	RoundDecimal10 half odd
479	RoundDecimal10 ceil
490	RoundDecimal10 floor
499	reset

Commons/xml/test/java/org/apache/commons/math3/dfp/DfpMathTest.xml
57	Generic test function.  Takes params x and y and tests them for equality.  Then checks the status flags against the flags argument. If the test fail, it prints the desc string
36	Some basic setup.  Define some constants and clear the status flags
44	force loading of dfpmath
64	NaNs involved
67	distinguish +/- zero
81	Test special cases  exponent of zero
118	exponent of one
147	exponent of NaN
176	radix of NaN
197	(x > 1) ^ pinf = pinf,    (x < -1) ^ pinf = pinf
214	(x > 1) ^ ninf = +0,    (x < -1) ^ ninf = +0
231	(-1 < x < 1) ^ pinf = 0
240	(-1 < x < 1) ^ ninf = pinf
249	+/- 1  ^ +/-inf  = NaN
266	+0  ^ +anything except 0, NAN  = +0
284	-0  ^ +anything except 0, NAN, odd integer  = +0
302	+0  ^ -anything except 0, NAN  = +INF
320	-0  ^ -anything except 0, NAN, odd integer  = +INF
338	-0  ^ -odd integer   =  -INF
347	-0  ^ +odd integer   =  -0
356	pinf  ^ +anything   = pinf
373	pinf  ^ -anything   = +0
391	ninf  ^ anything   = -0 ^ -anything ninf  ^ -anything except 0, NAN, odd integer  = +0
410	ninf  ^ +anything except 0, NAN, odd integer  = +INF
428	ninf  ^ +odd integer   =  -INF
437	ninf  ^ -odd integer   =  -0
446	-anything ^ integer
463	-anything ^ noninteger = NaN
469	Some fractional cases.
510	pi/4
514	-pi/4
518	-pi/4
539	off by one ULP
543	off by one ULP
554	off by one ULP

Commons/xml/test/java/org/apache/commons/math3/dfp/DfpTest.xml
64	Generic test function.  Takes params x and y and tests them for equality.  Then checks the status flags against the flags argument. If the test fail, it prints the desc string
116	Test addition
369	//////////////////////////////////////////////////////////////////////////////////////////////////////
371	Test comparisons
373	utility function to help test comparisons
758	Test multiplication
44	Some basic setup.  Define some constants and clear the status flags
71	NaNs involved
74	distinguish +/- zero
122	Basic tests   1+1 = 2
126	1 + (-1) = 0
130	(-1) + 1 = 0
134	(-1) + (-1) = -2
138	rounding mode is round half even
140	rounding on add
144	rounding on add
148	rounding on add
152	rounding on add
156	rounding on add
160	rounding on add
164	rounding on add
168	rounding on add
172	rounding on add
176	rounding on add
180	overflow on add
184	overflow on add
188	overflow on add
192	overflow on add
196	underflow on add
200	underflow on add
204	underflow on add
208	underflow on add
212	underflow on add
216	loss of precision on alignment?
220	proper normalization?
224	adding zeros
228	adding zeros
232	adding zeros
236	adding zeros
240	adding zeros
244	adding zeros
248	adding zeros
252	adding infinities
256	adding infinities
260	adding infinities
264	adding infinities
268	adding infinities
272	adding infinities
276	adding infinities
280	adding infinities
284	adding infinities
288	adding infinities
292	adding infinities
296	adding infinities
300	adding infinities
304	adding infinities
308	adding infinities
312	adding infinities
316	overflow
320	overflow
396	test equal() comparison check zero vs. zero
400	0 == 0
401	0 == -0
402	-0 == -0
403	-0 == 0
405	check zero vs normal numbers
407	0 == 1
408	1 == 0
409	-1 == 0
410	0 == -1
411	0 == 1e-131072
412	check flags
416	0 == 1e-131078
418	check flags  -- underflow should be set
424	0 == 1e+131071
426	check zero vs infinities
428	0 == pinf
429	0 == ninf
430	-0 == pinf
431	-0 == ninf
432	pinf == 0
433	ninf == 0
434	pinf == -0
435	ninf == -0
436	ninf == pinf
437	pinf == ninf
438	pinf == pinf
439	ninf == ninf
441	check some normal numbers
442	1 == 1
443	1 == -1
444	-1 == -1
445	1 == 1.0000000000000001
447	The tests below checks to ensure that comparisons don't set FLAG_INEXACT 100000 == 1.0000000000000001
455	check some nans -- nans shouldnt equal anything
484	Tests for un equal  -- do it all over again
488	0 == 0
489	0 == -0
490	-0 == -0
491	-0 == 0
493	check zero vs normal numbers
495	0 == 1
496	1 == 0
497	-1 == 0
498	0 == -1
499	0 == 1e-131072
500	check flags
504	0 == 1e-131078
506	check flags  -- underflow should be set
512	0 == 1e+131071
514	check zero vs infinities
516	0 == pinf
517	0 == ninf
518	-0 == pinf
519	-0 == ninf
520	pinf == 0
521	ninf == 0
522	pinf == -0
523	ninf == -0
524	ninf == pinf
525	pinf == ninf
526	pinf == pinf
527	ninf == ninf
529	check some normal numbers
530	1 == 1
531	1 == -1
532	-1 == -1
533	1 == 1.0000000000000001
535	The tests below checks to ensure that comparisons don't set FLAG_INEXACT 100000 == 1.0000000000000001
543	check some nans -- nans shouldnt be unequal to anything
575	Tests for lessThan  -- do it all over again
579	0 < 0
580	0 < -0
581	-0 < -0
582	-0 < 0
584	check zero vs normal numbers
586	0 < 1
587	1 < 0
588	-1 < 0
589	0 < -1
590	0 < 1e-131072
591	check flags
595	0 < 1e-131078
597	check flags  -- underflow should be set
602	0 < 1e+131071
604	check zero vs infinities
606	0 < pinf
607	0 < ninf
608	-0 < pinf
609	-0 < ninf
610	pinf < 0
611	ninf < 0
612	pinf < -0
613	ninf < -0
614	ninf < pinf
615	pinf < ninf
616	pinf < pinf
617	ninf < ninf
619	check some normal numbers
620	1 < 1
621	1 < -1
622	-1 < -1
623	1 < 1.0000000000000001
625	The tests below checks to ensure that comparisons don't set FLAG_INEXACT 100000 < 1.0000000000000001
633	check some nans -- nans shouldnt be lessThan to anything
661	lessThan compares with nans should raise FLAG_INVALID
666	Tests for greaterThan  -- do it all over again
670	0 > 0
671	0 > -0
672	-0 > -0
673	-0 > 0
675	check zero vs normal numbers
677	0 > 1
678	1 > 0
679	-1 > 0
680	0 > -1
681	0 > 1e-131072
682	check flags
686	0 > 1e-131078
688	check flags  -- underflow should be set
693	0 > 1e+131071
695	check zero vs infinities
697	0 > pinf
698	0 > ninf
699	-0 > pinf
700	-0 > ninf
701	pinf > 0
702	ninf > 0
703	pinf > -0
704	ninf > -0
705	ninf > pinf
706	pinf > ninf
707	pinf > pinf
708	ninf > ninf
710	check some normal numbers
711	1 > 1
712	1 > -1
713	-1 > -1
714	1 > 1.0000000000000001
716	The tests below checks to ensure that comparisons don't set FLAG_INEXACT 100000 > 1.0000000000000001
724	check some nans -- nans shouldnt be greaterThan to anything
752	greaterThan compares with nans should raise FLAG_INVALID
764	Basic tests   1*1 = 1
768	Basic tests   1*1 = 1
772	Basic tests   -1*1 = -1
776	Basic tests   -1*1 = -1
780	basic tests with integers
805	multiply by zero
931	divide by NaN = NaN
935	NaN / number = NaN
1031	test trial-divisor too high
1091	NaN / number = NaN
1239	Round down
1254	Round up
1273	Round half up
1292	Round half down
1311	Round half odd
1330	Round ceil
1341	Round floor
1350	reset

Commons/xml/test/java/org/apache/commons/math3/distribution/AbstractIntegerDistributionTest.xml
49	cum(0,6) = p(0 < X <= 6) = 1, cum(1,5) = 4/6, cum(2,4) = 2/6
95	E(X^2) - E(X)^2

Commons/xml/test/java/org/apache/commons/math3/distribution/AbstractRealDistributionTest.xml

Commons/xml/test/java/org/apache/commons/math3/distribution/BetaDistributionTest.xml
27	all test data computed using R 2.5

Commons/xml/test/java/org/apache/commons/math3/distribution/BinomialDistributionTest.xml
28	-------------- Implementations for abstract methods -----------------------
80	----------------- Additional test cases ---------------------------------
134	for large trials the evaluation of ContinuedFraction was inaccurate do a sweep over several large trials to test if the current implementation is numerically stable.

Commons/xml/test/java/org/apache/commons/math3/distribution/CauchyDistributionTest.xml
34	--------------------- Override tolerance  --------------
42	-------------- Implementations for abstract methods -----------------------
72	---------------------------- Additional test cases -------------------------
53	quantiles computed using R 2.9.2
100	Expected.
106	Expected.

Commons/xml/test/java/org/apache/commons/math3/distribution/ChiSquaredDistributionTest.xml
32	-------------- Implementations for abstract methods -----------------------
76	--------------------- Override tolerance  --------------
83	---------------------------- Additional test cases -------------------------
43	quantiles computed using R version 2.9.2
89	quantiles computed using R version 1.8.1 (linux version)
108	R 2.5: print(dchisq(x, df=1), digits=10)
110	R 2.5: print(dchisq(x, df=0.1), digits=10)
112	R 2.5: print(dchisq(x, df=2), digits=10)
114	R 2.5: print(dchisq(x, df=10), digits=10)

Commons/xml/test/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistributionTest.xml
45	Non-sorted singleton array with duplicates should be allowed. Values with zero-probability do not extend the support.
159	fixed seed

Commons/xml/test/java/org/apache/commons/math3/distribution/EnumeratedRealDistributionTest.xml
49	Non-sorted singleton array with duplicates should be allowed. Values with zero-probability do not extend the support.
194	fixed seed

Commons/xml/test/java/org/apache/commons/math3/distribution/ExponentialDistributionTest.xml
35	--------------------- Override tolerance  --------------
42	-------------- Implementations for abstract methods -----------------------
72	------------ Additional tests -------------------------------------------
53	quantiles computed using R version 2.9.2
105	computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5
108	computed using  print(dexp(2, rate=1/3), digits=10) in R 2.5

Commons/xml/test/java/org/apache/commons/math3/distribution/FDistributionTest.xml
33	-------------- Implementations for abstract methods -----------------------
62	--------------------- Override tolerance  --------------
69	---------------------------- Additional test cases -------------------------
44	quantiles computed using R version 2.9.2
98	Expected.
104	Expected.
149	this test was failing due to inaccurate results from ContinuedFraction.

Commons/xml/test/java/org/apache/commons/math3/distribution/fitting/MultivariateNormalMixtureExpectationMaximizationTest.xml
44	Should not accept empty data
50	Reject data with nonconstant numbers of columns
60	Data should have at least 2 columns
69	Maximum iterations for fit must be positive integer
82	Maximum iterations for fit must be positive
96	ConvergenceException thrown if fit terminates before threshold met
104	5 iterations not enough to meet convergence threshold
110	Data has 3 columns
116	These distributions are compatible with 2-column data, not 3-column data
130	Create components and mixture
149	Testing initial mixture estimated from data
196	Test that the loglikelihood, weights, and models are determined and fitted correctly
247	generated using R Mixtools rmvnorm with mean vectors [-1.5, 2] and [4, 8.2]

Commons/xml/test/java/org/apache/commons/math3/distribution/GammaDistributionTest.xml
42	-------------- Implementations for abstract methods -----------------------
71	--------------------- Override tolerance  --------------
78	---------------------------- Additional test cases -------------------------
216	MATH-753: large values of x or shape parameter cause density(double) to overflow. Reference data is generated with the Maxima script gamma-distribution.mac, which can be found in srctestresourcesorgapachecommonsmath3distribution.
53	quantiles computed using R version 2.9.2
92	Expected.
98	Expected.
134	R2.5: print(dgamma(x, shape=1, rate=1), digits=10)
136	R2.5: print(dgamma(x, shape=2, rate=1), digits=10)
138	R2.5: print(dgamma(x, shape=4, rate=1), digits=10)
140	R2.5: print(dgamma(x, shape=4, rate=10), digits=10)
142	R2.5: print(dgamma(x, shape=.1, rate=10), digits=10)
144	R2.5: print(dgamma(x, shape=.1, rate=20), digits=10)
146	R2.5: print(dgamma(x, shape=.1, rate=4), digits=10)
148	R2.5: print(dgamma(x, shape=.1, rate=1), digits=10)
183	This is a copy of double Gamma.logGamma(double) prior to MATH-849
204	This is a copy of double GammaDistribution.density(double) prior to MATH-753.
268	If no overflow occurs, check that new implementation is better than old one.

Commons/xml/test/java/org/apache/commons/math3/distribution/HypergeometricDistributionTest.xml
38	-------------- Implementations for abstract methods -----------------------
85	-------------------- Additional test cases ------------------------------
147	Expected.
153	Expected.
159	Expected.
165	Expected.
171	Expected.
274	population
275	successes in population
276	number of trials
284	another way to calculate the upper cumulative probability

Commons/xml/test/java/org/apache/commons/math3/distribution/IntegerDistributionAbstractTest.xml
51	-------------------- Private test instance data -------------------------
76	-------------------- Abstract methods -----------------------------------
99	-------------------- Setup / tear down ----------------------------------
129	-------------------- Verification methods -------------------------------
168	------------------------ Default test cases -----------------------------
267	------------------ Getters / Setters for test instance data -----------
224	expected
230	expected
236	expected
255	Use fixed seed

Commons/xml/test/java/org/apache/commons/math3/distribution/KolmogorovSmirnovDistributionTest.xml
38	The code below is generated using the R-script located in srctestRKolmogorovSmirnovDistributionTestCases.R
45	formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(200), PACKAGE = "stats")$p, 40) gives 4.907829957616471622388047046469198862537e-86
51	formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(200), PACKAGE = "stats")$p, 40) gives 5.151982014280041957199687829849210629618e-06
57	formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(200), PACKAGE = "stats")$p, 40) gives 0.01291614648162886340443389343590752105229
63	formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(200), PACKAGE = "stats")$p, 40) gives 0.1067137011362679355208626930107129737735
69	formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(341), PACKAGE = "stats")$p, 40) gives 1.914734701559404553985102395145063418825e-53
75	formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(341), PACKAGE = "stats")$p, 40) gives 0.001171328985781981343872182321774744195864
81	formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(341), PACKAGE = "stats")$p, 40) gives 0.1142955196267499418105728636874118819833
87	formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(341), PACKAGE = "stats")$p, 40) gives 0.3685529520496805266915885113121476024389
93	formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(389), PACKAGE = "stats")$p, 40) gives 1.810657144595055888918455512707637574637e-47
99	formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(389), PACKAGE = "stats")$p, 40) gives 0.003068542559702356568168690742481885536108
105	formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(389), PACKAGE = "stats")$p, 40) gives 0.1658291700122746237244797384846606291831
111	formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(389), PACKAGE = "stats")$p, 40) gives 0.4513143712128902529379104180407011881471

Commons/xml/test/java/org/apache/commons/math3/distribution/LevyDistributionTest.xml
53	values computed with R and function plevy from rmutil package
61	values computed with R and function dlevy from rmutil package

Commons/xml/test/java/org/apache/commons/math3/distribution/LogNormalDistributionTest.xml
35	-------------- Implementations for abstract methods -----------------------
102	--------------------- Override tolerance  --------------
109	---------------------------- Additional test cases -------------------------
46	quantiles computed using R
76	Exclude the test points less than zero, as they have cumulative probability of zero, meaning the inverse returns zero, and not the points less than zero.
83	return Arrays.copyOfRange(points, 4, points.length - 4);
92	Exclude the test points less than zero, as they have cumulative probability of zero, meaning the inverse returns zero, and not the points less than zero.
99	return Arrays.copyOfRange(points, 1, points.length - 4);
187	R 2.13: print(dlnorm(c(-2,-1,0,1,2)), digits=10)
191	R 2.13: print(dlnorm(c(-2,-1,0,1,2), mean=1.1), digits=10)
212	make sure no convergence exception
214	make sure not top-coded
217	make sure top coding not reversed

Commons/xml/test/java/org/apache/commons/math3/distribution/MultivariateNormalDistributionTest.xml
125	From dmvnorm function in R 2.15 CRAN package Mixtools v0.4.5

Commons/xml/test/java/org/apache/commons/math3/distribution/MultivariateNormalMixtureModelDistributionTest.xml
94	Test vectors
100	Densities that we should get back. Calculated by assigning weights to multivariate normal distribution and summing values from dmvnorm function in R 2.15 CRAN package Mixtools v0.4. Like: .3*dmvnorm(val,mu1,sigma1)+.7*dmvnorm(val,mu2,sigma2)
169	These were sampled from the MultivariateNormalMixtureModelDistribution class with seed 50.  They were then fit to a MVN mixture model in R using mixtools.  The optimal parameters were: - component weights: {0.3595186, 0.6404814} - mean vectors: {-1.645879, 1.989797}, {3.474328, 7.782232} - covariance matrices: { 1.397738 -1.167732 -1.167732 1.801782 } and { 3.934593 2.354787 2.354787 4.428024 }  It is considered fairly close to the actual test parameters, considering that the sample size is only 100.

Commons/xml/test/java/org/apache/commons/math3/distribution/NormalDistributionTest.xml
34	-------------- Implementations for abstract methods -----------------------
64	--------------------- Override tolerance  --------------
72	---------------------------- Additional test cases -------------------------
45	quantiles computed using R
81	Quantiles computed using R (same as Mathematica)
135	R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10)
137	R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10)
155	make sure no convergence exception
158	make sure not top-coded
159	For i = 10, due to bad tail precision in erf (MATH-364), 1 is returned TODO: once MATH-364 is resolved, replace 9 with 30
164	make sure top coding not reversed

Commons/xml/test/java/org/apache/commons/math3/distribution/PascalDistributionTest.xml
32	--------------------- Override tolerance  --------------
40	-------------- Implementations for abstract methods -----------------------
89	----------------- Additional test cases ---------------------------------

Commons/xml/test/java/org/apache/commons/math3/distribution/PoissonDistributionTest.xml
204	Extended test value: 1E7.  Reduced to limit run time.
211	Verify that returned value satisties definition

Commons/xml/test/java/org/apache/commons/math3/distribution/RealDistributionAbstractTest.xml
77	-------------------- Private test instance data -------------------------
99	-------------------- Abstract methods -----------------------------------
113	---- Default implementations of inverse test data generation methods ----
125	-------------------- Setup / tear down ----------------------------------
153	-------------------- Verification methods -------------------------------
212	------------------------ Default test cases -----------------------------
398	------------------ Getters / Setters for test instance data -----------
160	verify cumulativeProbability(double)
167	verify cumulativeProbability(double, double) XXX In 4.0, "cumulativeProbability(double,double)" must be replaced with "probability" (MATH-839).
248	check that cdf(x, x) = 0 XXX In 4.0, "cumulativeProbability(double,double)" must be replaced with "probability" (MATH-839).
254	check that P(a < X <= b) = P(X <= b) - P(X <= a)
259	XXX In 4.0, "cumulativeProbability(double,double)" must be replaced with "probability" (MATH-839).
272	XXX In 4.0, "cumulativeProbability(double,double)" must be replaced with "probability" (MATH-839).
276	expected
282	expected
288	expected
298	Use fixed seed
332	exclude integrals outside domain.
339	FIXME @4.0 when rename happens
342	Triangle integrals are very slow to converge
384	Construct a distribution and initialize its internal random generator, using a fixed seed for deterministic results.
389	Clone the distribution.
392	Make sure they still produce the same samples.
497	Serialize to byte array.
503	Deserialize from byte array.

Commons/xml/test/java/org/apache/commons/math3/distribution/TDistributionTest.xml
33	-------------- Implementations for abstract methods -----------------------
63	--------------------- Override tolerance  --------------
70	---------------------------- Additional test cases -------------------------
135	Adding this test to benchmark against tables published by NIST http:itl.nist.govdiv898handbookedasection3eda3672.htm Have chosen tabulated results for degrees of freedom 2,10,30,100 Have chosen problevels from 0.10 to 0.001
44	quantiles computed using R version 2.9.2
85	quantiles computed using R version 2.9.2

Commons/xml/test/java/org/apache/commons/math3/distribution/TriangularDistributionTest.xml
32	--- Override tolerance -------------------------------------------------
40	--- Implementations for abstract methods --------------------------------
137	--- Additional test cases -----------------------------------------------
47	Left side 5 wide, right side 10 wide.
57	below lower limit
58	at lower limit
59	on lower side
60	at mode
61	on upper side
62	at upper limit
63	above upper limit
72	Top at 2 / (b - a) = 2 / (12 - -3) = 2 / 15 = 7.5 Area left  = 7.5 * 5  * 0.5 = 18.75 (1/3 of the total area) Area right = 7.5 * 10 * 0.5 = 37.5  (2/3 of the total area) Area total = 18.75 + 37.5 = 56.25 Derivative left side = 7.5 / 5 = 1.5 Derivative right side = -7.5 / 10 = -0.75
98	Exclude the points outside the limits, as they have cumulative probability of zero and one, meaning the inverse returns the limits and not the points outside the limits.
105	return Arrays.copyOfRange(points, 1, points.length - 1);
114	Exclude the points outside the limits, as they have cumulative probability of zero and one, meaning the inverse returns the limits and not the points outside the limits.
121	return Arrays.copyOfRange(points, 1, points.length - 1);

Commons/xml/test/java/org/apache/commons/math3/distribution/UniformIntegerDistributionTest.xml
30	--- Override tolerance -------------------------------------------------
38	--- Implementations for abstract methods --------------------------------
85	--- Additional test cases -----------------------------------------------

Commons/xml/test/java/org/apache/commons/math3/distribution/UniformRealDistributionTest.xml
31	--- Override tolerance -------------------------------------------------
39	--- Implementations for abstract methods --------------------------------
69	--- Additional test cases -----------------------------------------------

Commons/xml/test/java/org/apache/commons/math3/distribution/WeibullDistributionTest.xml
36	-------------- Implementations for abstract methods -----------------------
65	---------------------------- Additional test cases -------------------------
47	quantiles computed using R version 2.9.2
83	Expected.
95	Expected.
105	In R: 3.5*gamma(1+(1/2.5)) (or emperically: mean(rweibull(10000, 2.5, 3.5)))

Commons/xml/test/java/org/apache/commons/math3/distribution/ZipfDistributionTest.xml
46	-------------- Implementations for abstract methods -----------------------

Commons/xml/test/java/org/apache/commons/math3/exception/DimensionMismatchExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/MaxCountExceededExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/NonMonotonicSequenceExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/NotPositiveExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/NotStrictlyPositiveExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/NumberIsTooLargeExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/NumberIsTooSmallExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/OutOfRangeExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/TooManyEvaluationsExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/util/ArgUtilsTest.xml

Commons/xml/test/java/org/apache/commons/math3/exception/util/ExceptionContextTest.xml
40	Non-default separator.
70	Check that all keys are present.
73	Check that all values are correctly stored.
78	Check behaviour on missing key.

Commons/xml/test/java/org/apache/commons/math3/exception/util/LocalizedFormatsTest.xml

Commons/xml/test/java/org/apache/commons/math3/ExtendedFieldElementAbstractTest.xml
316	TODO: add this test in 4.0, as it is not possible to do it in 3.2 due to incompatibility of the return type in the Dfp class @Test public void testLog10() { for (double x = -0.9; x < 0.9; x += 0.05) { checkRelative(FastMath.log10(x), build(x).log10()); } }

Commons/xml/test/java/org/apache/commons/math3/filter/KalmanFilterTest.xml
39	A and H matrix do not match in dimensions
41	A = [ 1 ]
43	no control input
45	H = [ 1 1 ]
47	Q = [ 0 ]
49	R = [ 0 ]
63	A and B matrix do not match in dimensions
65	A = [ 1 ]
67	B = [ 1 1 ]
69	H = [ 1 ]
71	Q = [ 0 ]
73	R = [ 0 ]
86	simulates a simple process with a constant state and no control input
92	A = [ 1 ]
94	no control input
96	H = [ 1 ]
98	x = [ 10 ]
100	Q = [ 1e-5 ]
102	R = [ 0.1 ]
116	check the initial state
124	iterate 60 steps
128	Simulate the process
131	x = A * x + p_noise
134	Simulate the measurement
137	z = H * x + m_noise
142	state estimate shouldn't be larger than measurement noise
144	System.out.println(diff);
148	error covariance should be already very low (< 0.02)
155	simulates a vehicle, accelerating at a constant rate (0.1 m/s)
157	discrete time interval
159	position measurement noise (meter)
161	acceleration noise (meter/sec^2)
164	A = [ 1 dt ] [ 0  1 ]
168	B = [ dt^2/2 ] [ dt     ]
173	H = [ 1 0 ]
176	x = [ 0 0 ]
183	Q = [ dt^4/4 dt^3/2 ] [ dt^3/2 dt^2   ]
187	P0 = [ 1 1 ] [ 1 1 ]
191	R = [ measurementNoise^2 ]
195	constant control input, increase velocity by 0.1 m/s per cycle
207	check the initial state
218	iterate 60 steps
222	Simulate the process
225	x = A * x + B * u + pNoise
228	Simulate the measurement
231	z = H * x + m_noise
236	state estimate shouldn't be larger than the measurement noise
241	error covariance of the velocity should be already very low (< 0.1)

Commons/xml/test/java/org/apache/commons/math3/fitting/CurveFitterTest.xml
99	derivative with respect to a
102	derivative with respect to b in the reported (invalid) issue, there was a sign error here
106	derivative with respect to c
109	derivative with respect to d
99	derivative with respect to a
102	derivative with respect to b in the reported (invalid) issue, there was a sign error here
106	derivative with respect to c
109	derivative with respect to d

Commons/xml/test/java/org/apache/commons/math3/fitting/GaussianFitterTest.xml
275	The optimizer will try negative sigma values but "GaussianFitter" will catch the raised exceptions and return NaN values instead.
322	When the data points are not commented out below, the fit stalls. This is expected however, since the whole dataset hardly looks like a Gaussian. When commented out, the fit proceeds fine.
328	fitter.addObservedPoint(0.68, 0.0);
330	fitter.addObservedPoint(1.59, 0.0);
332	fitter.addObservedPoint(2.50, 0.0);
334	fitter.addObservedPoint(3.41, 0.0);
336	fitter.addObservedPoint(4.32, 0.0);
341	Values are copied from a previous run of this test.

Commons/xml/test/java/org/apache/commons/math3/fitting/HarmonicFitterTest.xml
97	This test serves to cover the part of the code of "guessAOmega" when the algorithm using integrals fails.
133	build a regularly spaced array of measurements
142	shake it
154	pass it to the fitter
178	The guesser fails because the function is far from an harmonic function: It is a triangular periodic function with amplitude 3 and period 12, and all sample points are taken at integer abscissae so function values all belong to the integer subset {-3, -2, -1, 0, 1, 2, 3}.

Commons/xml/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.xml
48	12.9 - 3.4 x + 2.1 x^2
51	Collect data from a known polynomial.
57	Start fit from initial guesses that are far from the optimal values.
137	Trying hard to fit.
153	Trying hard to fit.
214	Levenberg-Marquardt should handle redundant information gracefully
220	Gauss-Newton should not be able to solve redundant information
259	reusing the same point over and over again does not bring information, the problem cannot be solved in this case for degrees greater than 1 (but one point is sufficient for degree 0)

Commons/xml/test/java/org/apache/commons/math3/fraction/BigFractionFieldTest.xml
39	deserializing the singleton should give the singleton itself back

Commons/xml/test/java/org/apache/commons/math3/fraction/BigFractionFormatTest.xml
148	success
154	success
166	success
172	success
219	success
237	success
248	expected
255	expected

Commons/xml/test/java/org/apache/commons/math3/fraction/BigFractionTest.xml
101	MATH-179
147	MATH-181
203	MATH-744
215	MATH-744
73	expected
79	expected
85	expected
91	expected
97	the golden ratio is notoriously a difficult number for continuous fraction
183	these two values are different approximations of PI the first  one is approximately PI - 3.07e-18 the second one is approximately PI + 1.936e-17
269	expected
314	large values
335	large values
371	if this fraction is added naively, it will overflow. check that it doesn't.
526	if this fraction is subtracted naively, it will overflow. check that it doesn't.
580	expected

Commons/xml/test/java/org/apache/commons/math3/fraction/FractionFieldTest.xml
39	deserializing the singleton should give the singleton itself back

Commons/xml/test/java/org/apache/commons/math3/fraction/FractionFormatTest.xml
174	This test shows that the sign is not preserved.
186	success
192	success
204	success
210	success
257	success
275	success
286	expected
293	expected

Commons/xml/test/java/org/apache/commons/math3/fraction/FractionTest.xml
76	MATH-179
122	MATH-181
51	overflow
56	success
62	success
72	the golden ratio is notoriously a difficult number for continuous fraction
148	expected behavior
175	these two values are different approximations of PI the first  one is approximately PI - 3.07e-18 the second one is approximately PI + 1.936e-17
255	With the implementation that preceded the fix suggested in MATH-835, this test was failing, due to overflow.
285	large values
306	large values
349	if this fraction is added naively, it will overflow. check that it doesn't.
370	should overflow
374	denominator should not be a multiple of 2 or 3 to trigger overflow
378	should overflow
397	should overflow
448	should overflow
453	should overflow
507	if this fraction is subtracted naively, it will overflow. check that it doesn't.
534	should overflow
537	denominator should not be a multiple of 2 or 3 to trigger overflow
541	should overflow
560	should overflow
588	expected

Commons/xml/test/java/org/apache/commons/math3/genetics/BinaryChromosomeTest.xml
38	Expected

Commons/xml/test/java/org/apache/commons/math3/genetics/BinaryMutationTest.xml
30	stochastic testing :)
35	one gene should be different

Commons/xml/test/java/org/apache/commons/math3/genetics/ChromosomeTest.xml
99	not important
99	not important

Commons/xml/test/java/org/apache/commons/math3/genetics/CycleCrossoverTest.xml
29	taken from http://www.rubicite.com/Tutorials/GeneticAlgorithms/CrossoverOperators/CycleCrossoverOperator.aspx
50	taken from http://www.scribd.com/doc/54206412/32/Cycle-crossover
85	Determine if it is in the same spot as in the first parent, if not it comes from the second parent.
96	Same as above only for the second parent.
127	Not important
127	Not important
142	Not important
142	Not important

Commons/xml/test/java/org/apache/commons/math3/genetics/DummyBinaryChromosome.xml
41	uninteresting

Commons/xml/test/java/org/apache/commons/math3/genetics/DummyListChromosome.xml
36	Not important.
42	Not important.

Commons/xml/test/java/org/apache/commons/math3/genetics/DummyRandomKey.xml
41	unimportant

Commons/xml/test/java/org/apache/commons/math3/genetics/ElitisticListPopulationTest.xml

Commons/xml/test/java/org/apache/commons/math3/genetics/FitnessCachingTest.xml
30	parameters for the GA
40	how many times was the fitness computed
46	initialize a new genetic algorithm
49	all selected chromosomes will be recombined (=crosssover)
51	no mutation
55	initial population
57	stopping conditions
60	run the algorithm
67	some chromosomes after crossover may be the same os old ones

Commons/xml/test/java/org/apache/commons/math3/genetics/FixedElapsedTimeTest.xml
33	unimportant
36	unimportant
40	unimportant
44	unimportant
48	unimportant
52	unimportant
65	ignore
33	unimportant
36	unimportant
40	unimportant
44	unimportant
48	unimportant
52	unimportant

Commons/xml/test/java/org/apache/commons/math3/genetics/FixedGenerationCountTest.xml
35	unimportant
38	unimportant
42	unimportant
46	unimportant
50	unimportant
54	unimportant
35	unimportant
38	unimportant
42	unimportant
46	unimportant
50	unimportant
54	unimportant

Commons/xml/test/java/org/apache/commons/math3/genetics/GeneticAlgorithmTestBinary.xml
32	parameters for the GA
43	to test a stochastic algorithm is hard, so this will rather be an usage example
45	initialize a new genetic algorithm
48	all selected chromosomes will be recombined (=crosssover)
56	initial population
58	stopping conditions
61	best initial chromosome
64	run the algorithm
67	best chromosome from the final population
70	the only thing we can test is whether the final solution is not worse than the initial one however, for some implementations of GA, this need not be true :)
114	number of elements >= 0

Commons/xml/test/java/org/apache/commons/math3/genetics/GeneticAlgorithmTestPermutations.xml
36	parameters for the GA
45	numbers from 0 to N-1
55	to test a stochastic algorithm is hard, so this will rather be an usage example
57	initialize a new genetic algorithm
66	initial population
68	stopping conditions
71	best initial chromosome
74	run the algorithm
77	best chromosome from the final population
80	the only thing we can test is whether the final solution is not worse than the initial one however, for some implementations of GA, this need not be true :)
85	System.out.println(bestInitial); System.out.println(bestFinal);
119	bad position found
123	the most fitted chromosome is the one with minimal error therefore we must return negative value

Commons/xml/test/java/org/apache/commons/math3/genetics/ListPopulationTest.xml
57	not important
57	not important
74	not important
74	not important
92	not important
92	not important
104	not important
104	not important
116	not important
116	not important
130	not important
130	not important
145	not important
145	not important
158	not important
158	not important
177	not important
177	not important
200	not important
200	not important

Commons/xml/test/java/org/apache/commons/math3/genetics/NPointCrossoverTest.xml
60	Not important
60	Not important
75	Not important
75	Not important
95	the two parent chromosomes are different at each position, so it is easy to detect the number of crossovers that happened for each child

Commons/xml/test/java/org/apache/commons/math3/genetics/OnePointCrossoverTest.xml
35	how to test a stochastic method?
45	first and last values will be the same
50	moreover, in the above setting, the 2nd, 3rd and 7th values will be the same

Commons/xml/test/java/org/apache/commons/math3/genetics/OrderedCrossoverTest.xml
52	make sure that the children have exactly the same elements as their parents
80	Not important
80	Not important
95	Not important
95	Not important

Commons/xml/test/java/org/apache/commons/math3/genetics/RandomKeyMutationTest.xml

Commons/xml/test/java/org/apache/commons/math3/genetics/RandomKeyTest.xml
73	never generate an invalid one
148	no-op
157	no-op

Commons/xml/test/java/org/apache/commons/math3/genetics/TournamentSelectionTest.xml
35	how to write a test for stochastic method?
38	the worst chromosome should NEVER be selected

Commons/xml/test/java/org/apache/commons/math3/genetics/UniformCrossoverTest.xml
56	test crossover with different ratios
68	make a number of rounds
78	check first child
93	check second child
125	Not important
125	Not important
140	Not important
140	Not important

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSetTest.xml

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalTest.xml

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotationDfpTest.xml
117	expected behavior
157	expected behavior
173	expected behavior
184	expected behavior
195	expected behavior
303	expected
380	expected behavior
401	expected behavior

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotationDSTest.xml
171	expected behavior
211	expected behavior
227	expected behavior
238	expected behavior
249	expected behavior
357	expected
431	expected behavior
452	expected behavior
627	Jacobian of the normalized rotation axis a with respect to the Cartesian vector k
640	explicit formula for rotation of vector u around axis a with angle theta
650	Jacobian of the image v = r(u) with respect to rotation axis a (analytical differentiation of the explicit formula)
658	compose Jacobians
661	derivatives with respect to un-normalized axis
672	derivative with respect to rotation angle (analytical differentiation of the explicit formula)

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3DTest.xml
512	expected
526	expected behavior
550	expected behavior
569	expected behavior
575	the following two vectors are nearly but not exactly orthogonal naive dot product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z leads to a result of 0.0, instead of the correct -1.855129...
592	we compare accurate versus naive dot product implementations on regular vectors (i.e. not extreme cases like in the previous test)
625	the vectors u1 and u2 are nearly but not exactly anti-parallel (7.31e-16 degrees from 180 degrees) naive cross product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z leads to a result of   [0.0009765, -0.0001220, -0.0039062], instead of the correct [0.0006913, -0.0001254, -0.0007909]
649	we compare accurate versus naive cross product implementations on regular vectors (i.e. not extreme cases like in the previous test)

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/FrenchVector3DFormatTest.xml

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/LineTest.xml
136	setup
141	action
144	verify

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/PlaneTest.xml

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSetTest.xml
247	1.000000f, 1.000000f, 1.000000f,

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationOrderTest.xml
55	ignored

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.xml
107	expected behavior
147	expected behavior
163	expected behavior
174	expected behavior
185	expected behavior
293	expected
359	expected behavior
377	expected behavior

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/SphericalCoordinatesTest.xml
68	don't check theta on poles, as it is singular
72	don't check theta on poles, as it is singular
124	d2F/dR2
125	d2F/dRdTheta
126	d2F/dRdPhi
127	just to check upper-right part is not used
128	d2F/dTheta2
129	d2F/dThetadPhi
130	just to check upper-right part is not used
131	just to check upper-right part is not used
132	d2F/dPhi2
138	d2F/dX2
139	d2F/dXdY
140	d2F/dXdZ
142	d2F/dY2
143	d2F/dYdZ
146	d2F/dZ2

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/SubLineTest.xml

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DFormatAbstractTest.xml

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DFormatTest.xml

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DTest.xml
286	expected behavior
309	expected behavior
327	expected behavior
333	the following two vectors are nearly but not exactly orthogonal naive dot product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z leads to a result of 0.0, instead of the correct -1.855129...
350	we compare accurate versus naive dot product implementations on regular vectors (i.e. not extreme cases like in the previous test)
368	the vectors u1 and u2 are nearly but not exactly anti-parallel (7.31e-16 degrees from 180 degrees) naive cross product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z leads to a result of   [0.0009765, -0.0001220, -0.0039062], instead of the correct [0.0006913, -0.0001254, -0.0007909]
392	we compare accurate versus naive cross product implementations on regular vectors (i.e. not extreme cases like in the previous test)

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/twod/LineTest.xml

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSetTest.xml
1052	each rebuilt vertex should be in a segment joining two original vertices
1068	each original vertex should have a corresponding rebuilt vertex

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/twod/SegmentTest.xml
34	distance to center of segment
37	distance a point on segment
40	distance to end point
43	distance to start point

Commons/xml/test/java/org/apache/commons/math3/geometry/euclidean/twod/SubLineTest.xml

Commons/xml/test/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTreeTest.xml
28	this array in this order allows to pass in all branches of the insertion algorithm

Commons/xml/test/java/org/apache/commons/math3/linear/Array2DRowRealMatrixTest.xml
41	3 x 3 identity matrix
44	Test data for group operations
60	lu decomposition tests
65	singular matrices
68	4th row = 1st + 2nd
72	vectors
76	submatrix accessor tests
79	array selections
83	effective permutations
86	contiguous ranges
90	row matrices
93	column matrices
97	tolerances
213	Additional Test for Array2DRowRealMatrixTest.testMultiply
453	test submatrix accessors
1105	--------------- -----------------Protected methods
1163	/** Useful for debugging */ private void dumpMatrix(RealMatrix m) { for (int i = 0; i < m.getRowDimension(); i++) { String os = ""; for (int j = 0; j < m.getColumnDimension(); j++) { os += m.getEntry(i, j) + " "; } System.out.println(os); } }
151	ignored
184	ignored
209	ignored
270	ignored
277	ignored
291	ignored
316	ignored
358	ignored
384	ignored
397	ignored
403	ignored
415	expected
422	Create a real matrix with two rows and three columns
425	One more with three rows, two columns
428	Now multiply m by n
432	Invert p
437	Solve example
542	rectangular check
629	expected
635	expected
650	expected
656	expected
673	expected
679	expected
694	expected
700	expected
715	expected
721	expected
736	expected
742	expected
757	expected
763	expected
778	expected
784	expected
805	expected
811	expected
825	expected
831	expected
846	expected
852	expected
867	expected
873	expected
934	dimension overflow
939	expected
941	dimension underflow
946	expected
952	expected
955	null
960	expected
967	expected
973	expected
976	ragged
981	expected
984	empty
989	expected

Commons/xml/test/java/org/apache/commons/math3/linear/ArrayFieldVectorTest.xml
62	Testclass to test the FieldVector<Fraction> interface only with enough content to support the test
78	field is of type T
283	expected behavior
301	expected behavior
359	ArrayFieldVector<Fraction> vout4 = (ArrayFieldVector<Fraction>) v1.clone(); Assert.assertEquals(3, vout4.getDimension()); Assert.assertEquals(v1.getDataRef(), vout4.getDataRef());
371	expected behavior
381	expected behavior
392	expected behavior
403	expected behavior
414	expected behavior
430	octave =  v1 .+ 2.0
435	octave =  v1 .+ 2.0
441	octave =  v1 .- 2.0
446	octave =  v1 .- 2.0
452	octave =  v1 .* 2.0
457	octave =  v1 .* 2.0
463	octave =  v1 ./ 2.0
468	octave =  v1 ./ 2.0
474	octave =  v1 .^-1
479	octave =  v1 .^-1
495	octave =  v1 + v2
505	octave =  v1 - v2
514	octave v1 .* v2
523	octave v1 ./ v2
532	octave  dot(v1,v2)
536	octave  dot(v1,v2_t)
564	Fraction[] dout1 = v1.copyOut(); Assert.assertEquals(3, dout1.length); assertNotSame("testData not same object ", v1.getDataRef(), dout1);
573	expected behavior
580	expected behavior
587	expected behavior
601	when the field is not specified, array cannot be empty
606	expected behavior
612	expected behavior
618	expected behavior
621	when the field is specified, array can be empty

Commons/xml/test/java/org/apache/commons/math3/linear/ArrayRealVectorTest.xml
78	expected behavior
96	expected behavior

Commons/xml/test/java/org/apache/commons/math3/linear/BiDiagonalTransformerTest.xml
150	check values against known references
158	check the same cached instance is returned the second time
183	check values against known references
191	check the same cached instance is returned the second time

Commons/xml/test/java/org/apache/commons/math3/linear/BlockFieldMatrixTest.xml
44	3 x 3 identity matrix
51	Test data for group operations
95	lu decomposition tests
107	singular matrices
114	4th row = 1st + 2nd
122	vectors
126	submatrix accessor tests
133	array selections
140	effective permutations
146	contiguous ranges
150	row matrices
153	column matrices
157	tolerances
332	Additional Test for BlockFieldMatrix<Fraction>Test.testMultiply
569	test submatrix accessors
209	ignored
223	ignored
243	expected
364	ignored
387	ignored
458	ignored
480	ignored
493	ignored
499	ignored
511	expected
518	Create a real matrix with two rows and three columns
524	One more with three rows, two columns
531	Now multiply m by n
535	Invert p
540	Solve example
754	expected
760	expected
775	expected
781	expected
818	expected
824	expected
839	expected
845	expected
882	expected
888	expected
903	expected
909	expected
944	expected
950	expected
965	expected
971	expected
1012	expected
1018	expected
1032	expected
1038	expected
1074	expected
1080	expected
1095	expected
1101	expected
1179	javadoc example
1198	dimension overflow
1203	expected
1205	dimension underflow
1210	expected
1216	expected
1219	null
1224	expected
1227	ragged
1232	expected
1235	empty
1240	expected

Commons/xml/test/java/org/apache/commons/math3/linear/BlockRealMatrixTest.xml
42	3 x 3 identity matrix
45	Test data for group operations
61	lu decomposition tests
66	singular matrices
69	4th row = 1st + 2nd
73	vectors
77	submatrix accessor tests
80	array selections
84	effective permutations
87	contiguous ranges
91	row matrices
94	column matrices
98	tolerances
292	Additional Test for BlockRealMatrixTest.testMultiply
498	test submatrix accessors
1256	--------------- -----------------Protected methods
152	ignored
184	ignored
204	expected
316	ignored
338	ignored
407	ignored
429	ignored
442	ignored
448	ignored
460	expected
467	Create a real matrix with two rows and three columns
470	One more with three rows, two columns
473	Now multiply m by n
477	Invert p
482	Solve example
673	expected
679	expected
694	expected
700	expected
734	expected
740	expected
755	expected
761	expected
796	expected
802	expected
817	expected
823	expected
857	expected
863	expected
878	expected
884	expected
924	expected
930	expected
944	expected
950	expected
985	expected
991	expected
1006	expected
1012	expected
1090	javadoc example
1098	dimension overflow
1103	expected
1105	dimension underflow
1110	expected
1116	expected
1119	null
1124	expected
1127	ragged
1132	expected
1135	empty
1140	expected

Commons/xml/test/java/org/apache/commons/math3/linear/CholeskyDecompositionTest.xml
129	check values against known references
135	check the same cached instance is returned the second time

Commons/xml/test/java/org/apache/commons/math3/linear/CholeskySolverTest.xml
46	expected behavior
52	expected behavior
58	expected behavior
82	using RealMatrix
85	using ArrayRealVector
92	using RealVector with an alternate implementation

Commons/xml/test/java/org/apache/commons/math3/linear/ConjugateGradientTest.xml
173	Do nothing
177	Do nothing
190	Do nothing
173	Do nothing
177	Do nothing
190	Do nothing
344	Do nothing
348	Do nothing
361	Do nothing
344	Do nothing
348	Do nothing
361	Do nothing
444	count[0] = number of calls to initializationPerformed count[1] = number of calls to iterationStarted count[2] = number of calls to iterationPerformed count[3] = number of calls to terminationPerformed
459	Expected behavior
465	Expected behavior
471	Expected behavior
459	Expected behavior
465	Expected behavior
471	Expected behavior

Commons/xml/test/java/org/apache/commons/math3/linear/DiagonalMatrixTest.xml
55	Check that the underlying was copied.
74	Check that the underlying is referenced.

Commons/xml/test/java/org/apache/commons/math3/linear/EigenDecompositionTest.xml
126	the following test triggered an ArrayIndexOutOfBoundsException in commons-math 2.0
137	the reference values have been computed using routine DSTEMR from the fortran library LAPACK version 3.2.1
174	the reference values have been computed using routine DSTEMR from the fortran library LAPACK version 3.2.1
192	the following line triggers the exception
220	the reference values have been computed using routine DSTEMR from the fortran library LAPACK version 3.2.1
237	the following line triggers the exception
352	Reconstruct initial matrix.
390	Vandermonde matrix V(x;i,j) = x_i^{n - j} with x = (-1,-2,3,4)
405	from http://eigen.tuxfamily.org/dox/classEigen_1_1RealSchur.html
423	matrix size
445	matrix size
485	RealMatrix vT = ed.getVT();
659	Use the first entry where both are non-zero as scalar
705	generate randomly row I
710	project the row in the subspace orthogonal to previous rows
722	normalize the row

Commons/xml/test/java/org/apache/commons/math3/linear/EigenSolverTest.xml
42	expected behavior
74	expected behavior
80	expected behavior
86	expected behavior
119	using RealMatrix
123	using RealVector
130	using RealVector with an alternate implementation

Commons/xml/test/java/org/apache/commons/math3/linear/FieldLUDecompositionTest.xml
45	singular matrices
55	4th row = 1st + 2nd
76	we don't use FractionField.getInstance() for testing purposes
84	expected behavior
246	check values against known references
258	check the same cached instance is returned the second time
287	check values against known references
299	check the same cached instance is returned the second time

Commons/xml/test/java/org/apache/commons/math3/linear/FieldLUSolverTest.xml
39	singular matrices
49	4th row = 1st + 2nd
91	expected behavior
97	expected behavior
112	expected behavior
118	expected behavior
135	using FieldMatrix
144	using ArrayFieldVector
153	using SparseFieldVector

Commons/xml/test/java/org/apache/commons/math3/linear/FieldMatrixImplTest.xml
43	3 x 3 identity matrix
46	Test data for group operations
62	lu decomposition tests
67	singular matrices
70	4th row = 1st + 2nd
74	vectors
78	submatrix accessor tests
81	array selections
85	effective permutations
88	contiguous ranges
92	row matrices
95	column matrices
99	tolerances
188	Additional Test for Array2DRowFieldMatrix<Fraction>Test.testMultiply
429	test submatrix accessors
1090	--------------- -----------------Protected methods
150	ignored
164	ignored
184	ignored
221	stop at 5 to avoid overflow
237	ignored
244	ignored
258	ignored
280	ignored
321	ignored
343	ignored
356	ignored
362	ignored
374	expected
381	Create a real matrix with two rows and three columns
387	One more with three rows, two columns
394	Now multiply m by n
398	Invert p
403	Solve example
596	expected
602	expected
617	expected
623	expected
640	expected
646	expected
661	expected
667	expected
682	expected
688	expected
703	expected
709	expected
724	expected
730	expected
745	expected
751	expected
772	expected
778	expected
792	expected
798	expected
813	expected
819	expected
834	expected
840	expected
911	dimension overflow
916	expected
918	dimension underflow
923	expected
929	expected
932	null
937	expected
944	expected
950	expected
953	ragged
958	expected
961	empty
966	expected

Commons/xml/test/java/org/apache/commons/math3/linear/FrenchRealVectorFormatTest.xml

Commons/xml/test/java/org/apache/commons/math3/linear/HessenbergTransformerTest.xml
43	from http://eigen.tuxfamily.org/dox/classEigen_1_1HessenbergDecomposition.html
164	///////////////////////////////////////////////////////////////////////// Test helpers /
58	expected behavior
92	matrix size
114	matrix size
211	check values against known references
218	check the same cached instance is returned the second time

Commons/xml/test/java/org/apache/commons/math3/linear/HilbertMatrix.xml
63	Positive and negative values are sorted out in order to limit catastrophic cancellations (do not forget that Hilbert matrices are *very* ill-conditioned!

Commons/xml/test/java/org/apache/commons/math3/linear/InverseHilbertMatrix.xml
88	Positive and negative values are sorted out in order to limit catastrophic cancellations (do not forget that Hilbert matrices are *very* ill-conditioned!

Commons/xml/test/java/org/apache/commons/math3/linear/LUDecompositionTest.xml
41	singular matrices
51	4th row = 1st + 2nd
78	expected behavior
234	check values against known references
246	check the same cached instance is returned the second time
275	check values against known references
287	check the same cached instance is returned the second time

Commons/xml/test/java/org/apache/commons/math3/linear/LUSolverTest.xml
38	singular matrices
48	4th row = 1st + 2nd
84	expected behavior
90	expected behavior
96	expected behavior
110	expected behavior
116	expected behavior
122	expected behavior
138	using RealMatrix
141	using ArrayRealVector
148	using RealVector with an alternate implementation

Commons/xml/test/java/org/apache/commons/math3/linear/MatrixDimensionMismatchExceptionTest.xml

Commons/xml/test/java/org/apache/commons/math3/linear/MatrixUtilsTest.xml
317	Taken from R manual http:stat.ethz.chR-manualR-patchedlibrarybasehtmlbacksolve.html
73	ragged
76	expected
79	no columns
82	expected
85	null
88	expected
99	ragged
102	expected
105	no columns
108	expected
111	null
114	expected
123	empty
126	expected
129	null
132	expected
143	empty
146	expected
149	null
152	expected
161	empty
164	expected
167	null
170	expected
182	empty
185	expected
188	null
191	expected
219	expected
247	expected
352	Check that we recovered the identity matrix.

Commons/xml/test/java/org/apache/commons/math3/linear/OpenMapRealMatrixTest.xml

Commons/xml/test/java/org/apache/commons/math3/linear/QRDecompositionTest.xml
228	check values against known references
238	check the same cached instance is returned the second time

Commons/xml/test/java/org/apache/commons/math3/linear/QRSolverTest.xml
82	expected behavior
88	expected behavior
102	expected behavior
108	expected behavior
125	using RealMatrix
128	using ArrayRealVector
135	using RealVector with an alternate implementation
154	build a perturbed system: A.X + noise = B
164	despite perturbation, the least square solution should be pretty good
180	too many equations, the system cannot be solved at all
183	the last unknown should have been set to 0

Commons/xml/test/java/org/apache/commons/math3/linear/RealMatrixFormatAbstractTest.xml
323	expected behavior

Commons/xml/test/java/org/apache/commons/math3/linear/RealMatrixFormatTest.xml

Commons/xml/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.xml
1383	TESTS OF THE VISITOR PATTERN
172	Make sure that x, y, z are three different values. Also, x is the preferred value (e.g. the value which is not stored in sparse implementations).
225	Try setting to any value.
239	Try setting to the preferred value.
273	Try adding any value.
287	Try incrementing so that result is equal to preferred value.
1088	Expected behavior
1096	Expected behavior
1429	Do nothing
1433	Do nothing
1444	Expected behavior
1450	Expected behavior
1456	Expected behavior
1462	Expected behavior
1468	Expected behavior
1429	Do nothing
1433	Do nothing
1552	Do nothing
1556	Do nothing
1567	Expected behavior
1573	Expected behavior
1579	Expected behavior
1585	Expected behavior
1591	Expected behavior
1552	Do nothing
1556	Do nothing
1683	Do nothing
1694	Expected behavior
1700	Expected behavior
1706	Expected behavior
1712	Expected behavior
1718	Expected behavior
1683	Do nothing
1814	Do nothing
1825	Expected behavior
1831	Expected behavior
1837	Expected behavior
1843	Expected behavior
1849	Expected behavior
1814	Do nothing

Commons/xml/test/java/org/apache/commons/math3/linear/RealVectorFormatAbstractTest.xml
315	expected behavior

Commons/xml/test/java/org/apache/commons/math3/linear/RealVectorFormatTest.xml

Commons/xml/test/java/org/apache/commons/math3/linear/RealVectorTest.xml
42	Do nothing
49	Do nothing
56	Do nothing
63	Do nothing
70	Do nothing
77	Do nothing
84	Do nothing
91	Do nothing
98	Do nothing
105	Do nothing
112	Do nothing
119	Do nothing
126	Do nothing
133	Do nothing
140	Do nothing
147	Do nothing
154	Do nothing
161	Do nothing
168	Do nothing
175	Do nothing
182	Do nothing
189	Do nothing
194	For non-default values, use x + 1, x + 2, etc... to make sure that these values are really different from x.
225	Do nothing
232	Do nothing

Commons/xml/test/java/org/apache/commons/math3/linear/RectangularCholeskyDecompositionTest.xml
38	as this decomposition permutes lines and columns, the root is NOT triangular (in fact here it is the lower right part of the matrix which is zero and the upper left non-zero)
70	the pivoted Cholesky decomposition is *not* unique. Here, the root is not equal to the original trianbular base matrix

Commons/xml/test/java/org/apache/commons/math3/linear/RRQRDecompositionTest.xml

Commons/xml/test/java/org/apache/commons/math3/linear/RRQRSolverTest.xml
82	expected behavior
88	expected behavior
103	expected behavior
109	expected behavior
128	using RealMatrix
131	using ArrayRealVector
138	using RealVector with an alternate implementation
157	build a perturbed system: A.X + noise = B
167	despite perturbation, the least square solution should be pretty good
184	too many equations, the system cannot be solved at all
187	the last permuted unknown should have been set to 0

Commons/xml/test/java/org/apache/commons/math3/linear/SchurTransformerTest.xml
43	from http://eigen.tuxfamily.org/dox/classEigen_1_1RealSchur.html
150	///////////////////////////////////////////////////////////////////////// Test helpers /
59	expected behavior
96	matrix size
118	matrix size
192	check values against known references
199	check the same cached instance is returned the second time

Commons/xml/test/java/org/apache/commons/math3/linear/SingularValueDecompositionTest.xml
171	This test is useless since whereas the columns of U and V are linked together, the actual triplet (U,S,V) is not uniquely defined.
189	check values against known references
197	check the same cached instance is returned the second time
205	This test is useless since whereas the columns of U and V are linked together, the actual triplet (U,S,V) is not uniquely defined.
226	check values against known references
236	check the same cached instance is returned the second time
300	replace 1.0e-15 with 1.5e-15

Commons/xml/test/java/org/apache/commons/math3/linear/SingularValueSolverTest.xml
45	expected behavior
51	expected behavior
57	expected behavior
99	using RealMatrix
102	using ArrayRealVector
109	using RealVector with an alternate implementation
125	replace 1.0e-15 with 1.5e-15

Commons/xml/test/java/org/apache/commons/math3/linear/SparseFieldMatrixTest.xml
39	3 x 3 identity matrix
41	Test data for group operations
59	lu decomposition tests
63	singular matrices
66	4th
68	row = 1st + 2nd
77	vectors
81	submatrix accessor tests
84	array selections
89	effective permutations
93	contiguous ranges
98	row matrices
102	column matrices
106	tolerances
226	Additional Test for Array2DRowRealMatrixTest.testMultiply
413	test submatrix accessors
585	Disable for now @Test public void testToString() { SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); Assert.assertEquals("SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}", m.toString()); m = new SparseFieldMatrix<Fraction>(field, 1, 1); Assert.assertEquals("SparseFieldMatrix<Fraction>{{0.0}}", m.toString()); }
675	--------------- -----------------Protected methods
124	ignore, can't happen
179	ignored
195	ignored
222	ignored
250	ignored
275	ignored
316	ignored
342	ignored
355	ignored
361	ignored
373	expected
380	Create a real matrix with two rows and three columns
383	One more with three rows, two columns
386	Now multiply m by n
390	Invert p
395	Solve example
445	expected
451	expected
457	expected
463	expected
469	expected
475	expected
490	expected
496	expected
511	expected
517	expected
532	expected
538	expected
553	expected
559	expected
614	javadoc example
623	dimension overflow
628	expected
630	dimension underflow
635	expected
641	expected
644	null
649	expected
655	expected
658	ragged
663	expected
666	empty
671	expected

Commons/xml/test/java/org/apache/commons/math3/linear/SparseFieldVectorTest.xml
46	tolerances
56	octave =  v1 .+ 2.0
61	octave =  v1 .+ 2.0
67	octave =  v1 .- 2.0
72	octave =  v1 .- 2.0
78	octave =  v1 .* 2.0
83	octave =  v1 .* 2.0
89	octave =  v1 ./ 2.0
94	octave =  v1 ./ 2.0
100	octave =  v1 .^-1
105	octave =  v1 .^-1
121	octave =  v1 + v2
131	octave =  v1 - v2
140	octave v1 .* v2
149	octave v1 ./ v2
158	octave  dot(v1,v2)
162	octave  dot(v1,v2_t)
207	expected behavior

Commons/xml/test/java/org/apache/commons/math3/linear/SparseRealMatrixTest.xml
37	3 x 3 identity matrix
39	Test data for group operations
58	lu decomposition tests
63	singular matrices
66	4th
68	row = 1st + 2nd
77	vectors
81	submatrix accessor tests
85	array selections
90	effective permutations
94	contiguous ranges
99	row matrices
103	column matrices
107	tolerances
217	Additional Test for Array2DRowRealMatrixTest.testMultiply
404	test submatrix accessors
671	--------------- -----------------Protected methods
162	ignored
186	ignored
213	ignored
241	ignored
266	ignored
307	ignored
333	ignored
346	ignored
352	ignored
364	expected
371	Create a real matrix with two rows and three columns
374	One more with three rows, two columns
377	Now multiply m by n
381	Invert p
386	Solve example
436	expected
442	expected
448	expected
454	expected
460	expected
466	expected
481	expected
487	expected
502	expected
508	expected
523	expected
529	expected
544	expected
550	expected
603	javadoc example
612	dimension overflow
617	expected
619	dimension underflow
624	expected
630	expected
633	null
638	expected
644	expected
647	ragged
652	expected
655	empty
660	expected

Commons/xml/test/java/org/apache/commons/math3/linear/SparseRealVectorTest.xml
52	SparseRealVector v4 = new SparseRealVector(vec4, 3, 2); Assert.assertEquals("testData len", 2, v4.getDimension()); Assert.assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0)); try { new SparseRealVector(vec4, 8, 3); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) {
59	expected behavior
60	}

Commons/xml/test/java/org/apache/commons/math3/linear/SymmLQTest.xml
483	count[0] = number of calls to initializationPerformed count[1] = number of calls to iterationStarted count[2] = number of calls to iterationPerformed count[3] = number of calls to terminationPerformed
530	Check that solution is not "over-refined". When the last iteration has occurred, no further refinement should be performed.

Commons/xml/test/java/org/apache/commons/math3/linear/TriDiagonalTransformerTest.xml
50	expected behavior
158	check values against known references
175	check the same cached instance is returned the second time

Commons/xml/test/java/org/apache/commons/math3/linear/UnmodifiableArrayRealVectorTest.xml

Commons/xml/test/java/org/apache/commons/math3/linear/UnmodifiableOpenMapRealVectorTest.xml

Commons/xml/test/java/org/apache/commons/math3/linear/UnmodifiableRealVectorAbstractTest.xml

Commons/xml/test/java/org/apache/commons/math3/ml/clustering/DBSCANClustererTest.xml
32	Test data generated using: http://people.cs.nctu.edu.tw/~rsliang/dbscan/testdatagen.html
140	A
146	B
147	C
148	N - Noise, should not be present
149	D - single-link connected to C should not be present

Commons/xml/test/java/org/apache/commons/math3/ml/clustering/KMeansPlusPlusClustererTest.xml
76	initialise testvalues
81	testvalues will be multiplied
85	define the space which will break the cluster algorithm
88	multiply the values
136	Create a bunch of CloseDoublePoints. Most are identical, but one is different by a small distance.
150	Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial cluster centers).
162	Check that one of the chosen centers is the unique point.

Commons/xml/test/java/org/apache/commons/math3/ml/clustering/MultiKMeansPlusPlusClustererTest.xml
38	first expected cluster
48	second expected cluster
55	third expected cluster

Commons/xml/test/java/org/apache/commons/math3/ml/distance/CanberraDistanceTest.xml

Commons/xml/test/java/org/apache/commons/math3/ml/distance/ChebyshevDistanceTest.xml

Commons/xml/test/java/org/apache/commons/math3/ml/distance/EuclideanDistanceTest.xml

Commons/xml/test/java/org/apache/commons/math3/ml/distance/ManhattanDistanceTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/ContinuousOutputModelTest.xml
89	theoretical solution: y[0] = cos(t), y[1] = sin(t)
101	integrate backward from &pi; to 0;
109	integrate backward from 2&pi; to &pi;
117	merge the two half circles
123	check circle
142	dimension mismatch
145	hole between time ranges
148	propagation direction mismatch
151	no errors
164	there was an allowable error
166	no allowable error

Commons/xml/test/java/org/apache/commons/math3/ode/events/EventFilterTest.xml
39	start point: g > 0
43	start point: g = 0
47	start point: g < 0
56	start point: g > 0
60	start point: g = 0
64	start point: g < 0
73	start point: g > 0
77	start point: g = 0
81	start point: g < 0
90	start point: g > 0
94	start point: g = 0
98	start point: g < 0
110	first pass to set up switches history for a long period
118	verify old events are preserved, even if randomly accessed
266	in fact, we don't really reset anything for this test

Commons/xml/test/java/org/apache/commons/math3/ode/events/EventStateTest.xml
36	JIRA: MATH-322
85	Jira: MATH-695
128	the bug corresponding to issue 695 causes the g function to be called at obsolete times t despite an event occurring later has already been triggered. When this occurs, the following assertion is violated
138	remember in a class variable when the event was triggered

Commons/xml/test/java/org/apache/commons/math3/ode/events/OverlappingEventsTest.xml
97	System.out.println("t=" + t + ",\t\ty=[" + y[0] + "," + y[1] + "]");
102	System.out.println("Event 1 @ t=" + t);
107	System.out.println("Event 2 @ t=" + t);
118	System.out.println();
166	Never called.

Commons/xml/test/java/org/apache/commons/math3/ode/events/ReappearingEventTest.xml
94	Never called.

Commons/xml/test/java/org/apache/commons/math3/ode/FirstOrderConverterTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/JacobianMatricesTest.xml
38	this test does not really test JacobianMatrices, it only shows that WITHOUT this class, attempting to recover the jacobians from external differentiation on simple integration results with low accuracy gives very poor results. In fact, the curves dy/dp = g(b) when b varies from 2.88 to 3.08 are essentially noise. This test is taken from Hairer, Norsett and Wanner book Solving Ordinary Differential Equations I (Nonstiff problems), the curves dy/dp = g(b) are in figure 6.5
128	Assert.assertEquals(5000, integ.getMaxEvaluations()); Assert.assertTrue(integ.getEvaluations() > 1500); Assert.assertTrue(integ.getEvaluations() < 2100); Assert.assertEquals(4 * integ.getEvaluations(), integ.getEvaluations());
169	Assert.assertEquals(5000, integ.getMaxEvaluations()); Assert.assertTrue(integ.getEvaluations() > 350); Assert.assertTrue(integ.getEvaluations() < 510);

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/AdamsBashforthIntegratorTest.xml
88	the 50 and 300 factors are only valid for this test and has been obtained from trial and error there is no general relation between local and global errors

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/AdamsMoultonIntegratorTest.xml
93	the 0.5 and 11.0 factors are only valid for this test and has been obtained from trial and error there is no general relation between local and global errors

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.xml
277	even with more than 1000 evaluations per period, RK4 is not able to integrate such an eccentric orbit with a good accuracy

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince54IntegratorTest.xml
184	the 0.7 factor is only valid for this test and has been obtained from trial and error there is no general relation between local and global errors

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince54StepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853IntegratorTest.xml
176	the 1.3 factor is only valid for this test and has been obtained from trial and error there is no general relation between local and global errors
353	events at 0, PI, 2PI ...
354	events at PI/2, 3PI/2, 5PI/2 ...
388	once a step has been handled by handleStep, events checking should only refer to dates after the step
399	in fact, we don't need to reset anything for the test

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853StepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/EulerIntegratorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/EulerStepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/GillIntegratorTest.xml
208	even with more than 1000 evaluations per period, RK4 is not able to integrate such an eccentric orbit with a good accuracy

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/GillStepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerIntegratorTest.xml
136	the coefficients are only valid for this test and have been obtained from trial and error there is no general relation between local and global errors
165	stability control

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/HighamHall54IntegratorTest.xml
65	expected behavior
72	expected behavior
122	the 1.3 factor is only valid for this test and has been obtained from trial and error there is no general relation between local and global errors
280	Expected.
300	expected behavior
310	expected behavior
320	expected behavior
330	expected behavior
340	expected behavior

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/HighamHall54StepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/MidpointIntegratorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/MidpointStepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/StepProblem.xml

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/ThreeEighthesIntegratorTest.xml
200	even with more than 1000 evaluations per period, RK4 is not able to integrate such an eccentric orbit with a good accuracy

Commons/xml/test/java/org/apache/commons/math3/ode/nonstiff/ThreeEighthesStepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/sampling/DummyStepInterpolator.xml
117	save the state of the base class
136	read the base class
148	we can now set the interpolated time and state

Commons/xml/test/java/org/apache/commons/math3/ode/sampling/DummyStepInterpolatorTest.xml
119	expected behavior

Commons/xml/test/java/org/apache/commons/math3/ode/sampling/NordsieckStepInterpolatorTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/sampling/StepInterpolatorTestUtils.xml

Commons/xml/test/java/org/apache/commons/math3/ode/sampling/StepNormalizerOutputOverlapTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/sampling/StepNormalizerOutputTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/sampling/StepNormalizerOutputTestBase.xml
248	Forward test.

Commons/xml/test/java/org/apache/commons/math3/ode/sampling/StepNormalizerTest.xml

Commons/xml/test/java/org/apache/commons/math3/ode/TestProblem1.xml
74	compute the derivatives

Commons/xml/test/java/org/apache/commons/math3/ode/TestProblem2.xml
75	compute the derivatives

Commons/xml/test/java/org/apache/commons/math3/ode/TestProblem3.xml
90	current radius
94	compute the derivatives
105	solve Kepler's equation

Commons/xml/test/java/org/apache/commons/math3/ode/TestProblem4.xml
127	this sign change is needed because the state will be reset soon

Commons/xml/test/java/org/apache/commons/math3/ode/TestProblem5.xml

Commons/xml/test/java/org/apache/commons/math3/ode/TestProblem6.xml
73	compute the derivatives

Commons/xml/test/java/org/apache/commons/math3/ode/TestProblemAbstract.xml

Commons/xml/test/java/org/apache/commons/math3/ode/TestProblemFactory.xml

Commons/xml/test/java/org/apache/commons/math3/ode/TestProblemHandler.xml
77	multistep integrators do not handle the first steps themselves so we have to make sure the integrator we look at has really started its work
80	the step should either start at the end of the integrator step or at an event if the step is split into several substeps
95	store the error at the last step
106	walk through the step
114	update the errors

Commons/xml/test/java/org/apache/commons/math3/optim/linear/SimplexSolverTest.xml
140	allowing only non-negative values, no feasible solution shall be found

Commons/xml/test/java/org/apache/commons/math3/optim/linear/SimplexTableauTest.xml

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/CircleScalar.xml
71	gradient of the sum of squared residuals
71	gradient of the sum of squared residuals

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.xml
141	Check that the number of iterations is updated (MATH-949).

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/MultiStartMultivariateOptimizerTest.xml
46	TODO: the wrapper around NonLinearConjugateGradientOptimizer is a temporary hack for version 3.1 of the library. It should be removed when NonLinearConjugateGradientOptimizer will officially be declared as implementing MultivariateDifferentiableOptimizer

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateFunctionMappingAdapterTest.xml
166	the function should never be called with out of range points

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateFunctionPenaltyAdapterTest.xml
173	the function should never be called with out of range points

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/BOBYQAOptimizerTest.xml
239	See MATH-728 TODO: this test is temporarily disabled for 3.2 release as a bug in Cobertura makes it run for several hours before completing
248	This should have been 78 because in the code the hard limit is said to be ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1) i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64, 65, 66, ...
318	System.out.println(func.getClass().getName() + " BEGIN"); // XXX
335	System.out.println(func.getClass().getName() + " = " + optim.getEvaluations() + " f("); for (double x: result.getPoint())  System.out.print(x + " "); System.out.println(") = " +  result.getValue());
345	System.out.println(func.getClass().getName() + " END"); // XXX
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
507	System.out.print("" + (fcount++) + ") "); for (int i = 0; i < x.length; i++) System.out.print(x[i] +  " "); System.out.println(" = " + f);
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis
501	private int fcount = 0;
590	use not always the same basis

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.xml
415	No bounds.
425	Optimum is near the lower bound.
438	Optimum is near the upper bound.
450	System.out.println("resNoBound=" + resNoBound + " resNearLo=" + resNearLo + " resNearHi=" + resNearHi);
454	The two values currently differ by a substantial amount, indicating that the bounds definition can prevent reaching the optimum.
489	test diagonalOnly = 0 - slow but normally fewer feval#
509	System.out.println("sol=" + Arrays.toString(result.getPoint()));
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis
756	use not always the same basis

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.xml
63	Initial is minimum.
69	Initial is far from minimum.
74	More stringent line search tolerance enhances the precision of the result.
97	Initial is minimum.
103	Initial is far from minimum.
128	Initial is minimum.
134	Initial is far from minimum.
165	Initial is far from minimum.
173	Very small absolute tolerance to rely solely on the relative tolerance as a stopping criterion
198	Check that both minima provide the same objective funciton values, within the relative function tolerance.
202	Check that the numbers of evaluations are the same.

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.xml
66	Check that the number of iterations is updated (MATH-949).
87	Check that the number of iterations is updated (MATH-949).
108	Check that the number of iterations is updated (MATH-949).
129	Check that the number of iterations is updated (MATH-949).
193	fails because MultiDirectional.iterateSimplex is looping forever the while(true) should be replaced with a convergence check
214	The following function has 4 local extrema.
219	Local maximum.
220	Local minimum.
221	Global minimum.
222	Global maximum.
214	The following function has 4 local extrema.
219	Local maximum.
220	Local minimum.
221	Global minimum.
222	Global maximum.

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.xml
71	Check that the number of iterations is updated (MATH-949).
92	Check that the number of iterations is updated (MATH-949).
113	Check that the number of iterations is updated (MATH-949).
134	Check that the number of iterations is updated (MATH-949).
267	The following function has 4 local extrema.
272	Local maximum.
273	Local minimum.
274	Global minimum.
275	Global maximum.
267	The following function has 4 local extrema.
272	Local maximum.
273	Local minimum.
274	Global minimum.
275	Global maximum.
267	The following function has 4 local extrema.
272	Local maximum.
273	Local minimum.
274	Global minimum.
275	Global maximum.

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.xml
471	add perfect measurements and check errors are reduced

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTestValidation.xml
70	Error on the observations.
73	True values of the parameters.
77	Samples generator.
84	Number of observations.
85	XXX Should be a command-line option.
86	number of parameters.
89	Parameters found for each of Monte-Carlo run.
91	Sigma estimations (square-root of the diagonal elements of the covariance matrix), for each Monte-Carlo run.
95	Initialize statistics accumulators.
101	Dummy optimizer (to compute the covariance matrix).
105	Monte-Carlo (generates many sets of observations).
109	Observations.
118	Direct solution (using simple regression).
121	Estimation of the standard deviation (diagonal elements of the covariance matrix).
132	Accumulate statistics.
138	Next Monte-Carlo.
142	Print statistics.
162	Check the error estimation.
196	Error on the observations.
199	True values of the parameters.
203	Samples generator.
210	Number of observations.
212	number of parameters.
215	Create a single set of observations.
224	Direct solution (using simple regression).
227	Dummy optimizer (to compute the chi-square).
230	Get chi-square of the best parameters set for the given set of observations.
235	Monte-Carlo (generates a grid of parameters).
239	Parameters found for each of Monte-Carlo run. Index 0 = slope Index 1 = offset Index 2 = normalized chi2
261	Output (for use with "gnuplot").
263	Some info.
265	For plotting separately sets of parameters that have a large chi2.
271	Point with smallest chi-square.
273	Empty line.
275	Points within the confidence interval.
281	Empty line.
283	Points outside the confidence interval.
290	Empty line.

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/CircleProblem.xml
125	Find the angle for which the circle passes closest to the current point (using a resolution of 100 points along the circumference).
125	Find the angle for which the circle passes closest to the current point (using a resolution of 100 points along the circumference).
164	Partial derivative wrt x-coordinate of center.
167	Partial derivative wrt y-coordinate of center.
170	Partial derivative wrt radius.

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/CircleVectorial.xml
85	Jacobian of the radius residuals.
85	Jacobian of the radius residuals.

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizerTest.xml
118	Exception is expected with this optimizer
127	Exception is expected with this optimizer
156	This test does not converge with this optimizer.
166	TODO This test leads to a singular problem with the Gauss-Newton optimizer. This should be inquired.

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizerTest.xml
128	Overrides the method from parent class, since the default singularity threshold (1e-14) does not trigger the expected exception.
210	column 1 = times
217	column 2 = measured counts
262	Check that the computed solution is within the reference error range.
268	Check that each entry of the computed covariance matrix is within 10% of the reference matrix entry.
287	The test is extremely sensitive to the seed.
300	First guess for the center's coordinates and radius.
314	Retrieve errors estimation.
317	Check that the parameters are found within the assumed error bars.

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/MinpackTest.xml
339	0.2578330049, 0.257829976764542

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/RandomCirclePointGenerator.xml

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/RandomStraightLinePointGenerator.xml

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/StatisticalReferenceDataset.xml
98	Data columns are in reverse order!!!

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/StatisticalReferenceDatasetFactory.xml
33	Do nothing

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/StraightLineProblem.xml
66	x-coordinate.
79	y-coordinate.
142	Partial derivative wrt "a".
144	Partial derivative wrt "b".

Commons/xml/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.xml
157	filter out simple bounds, as they are not supported by the underlying optimizer, and we don't really care for this test
183	only the first start should have succeeded
157	filter out simple bounds, as they are not supported by the underlying optimizer, and we don't really care for this test

Commons/xml/test/java/org/apache/commons/math3/optim/PointValuePairTest.xml

Commons/xml/test/java/org/apache/commons/math3/optim/PointVectorValuePairTest.xml

Commons/xml/test/java/org/apache/commons/math3/optim/SimplePointCheckerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optim/SimpleValueCheckerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optim/SimpleVectorValueCheckerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optim/univariate/BracketFinderTest.xml
46	Comparing with results computed in Python.

Commons/xml/test/java/org/apache/commons/math3/optim/univariate/BrentOptimizerTest.xml
65	expected
73	The default stopping criterion of Brent's algorithm should not pass, but the search will stop at the given relative tolerance for the function value.
116	The function has local minima at -0.27195613 and 0.82221643.
129	search in a large interval
139	The function has local minima at -0.27195613 and 0.82221643.
170	The quintic function has zeros at 0, +-0.5 and +-1. The function has a local maximum at 0.27195613.
185	expected
194	endpoint is minimum
245	A slightly less stringent tolerance would make the test pass even with the previous implementation.
262	System.out.println("numEval=" + numEval); System.out.println("min=" + init + " f=" + f.value(init)); System.out.println("sol=" + sol + " f=" + f.value(sol)); System.out.println("exp=" + expected + " f=" + f.value(expected));
296	System.out.println("min=" + (minSin + offset) + " f=" + f.value(minSin + offset)); System.out.println("sol=" + sol + " f=" + f.value(sol)); System.out.println("exp=" + expected + " f=" + f.value(expected));

Commons/xml/test/java/org/apache/commons/math3/optim/univariate/MultiStartUnivariateOptimizerTest.xml
77	The quintic function has zeros at 0, +-0.5 and +-1. The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,
123	Expected.
126	Ensure that the exception was thrown because no optimum was found.

Commons/xml/test/java/org/apache/commons/math3/optim/univariate/SimpleUnivariateValueCheckerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/direct/BOBYQAOptimizerTest.xml
238	See MATH-728 TODO: this test is temporarily disabled for 3.2 release as a bug in Cobertura makes it run for several hours before completing
247	This should have been 78 because in the code the hard limit is said to be ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1) i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64, 65, 66, ...
317	System.out.println(func.getClass().getName() + " BEGIN"); // XXX
320	MultivariateOptimizer optim = new PowellOptimizer(1e-13, Math.ulp(1d)); PointValuePair result = optim.optimize(100000, func, goal, startPoint);
333	System.out.println(func.getClass().getName() + " = " + optim.getEvaluations() + " f("); for (double x: result.getPoint())  System.out.print(x + " "); System.out.println(") = " +  result.getValue());
343	System.out.println(func.getClass().getName() + " END"); // XXX
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
505	System.out.print("" + (fcount++) + ") "); for (int i = 0; i < x.length; i++) System.out.print(x[i] +  " "); System.out.println(" = " + f);
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis
499	private int fcount = 0;
588	use not always the same basis

Commons/xml/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.xml
404	No bounds.
409	Optimum is near the lower bound.
416	Optimum is near the upper bound.
423	System.out.println("resNoBound=" + resNoBound + " resNearLo=" + resNearLo + " resNearHi=" + resNearHi);
427	The two values currently differ by a substantial amount, indicating that the bounds definition can prevent reaching the optimum.
462	test diagonalOnly = 0 - slow but normally fewer feval#
477	System.out.println("sol=" + Arrays.toString(result.getPoint()));
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis
722	use not always the same basis

Commons/xml/test/java/org/apache/commons/math3/optimization/direct/MultivariateFunctionMappingAdapterTest.xml
161	the function should never be called with out of range points

Commons/xml/test/java/org/apache/commons/math3/optimization/direct/MultivariateFunctionPenaltyAdapterTest.xml
163	the function should never be called with out of range points

Commons/xml/test/java/org/apache/commons/math3/optimization/direct/PowellOptimizerTest.xml
46	Initial is minimum.
52	Initial is far from minimum.
57	More stringent line search tolerance enhances the precision of the result.
80	Initial is minimum.
86	Initial is far from minimum.
111	Initial is minimum.
117	Initial is far from minimum.
148	Initial is far from minimum.
156	Very small absolute tolerance to rely solely on the relative tolerance as a stopping criterion
175	Check that both minima provide the same objective funciton values, within the relative function tolerance.
179	Check that the numbers of evaluations are the same.

Commons/xml/test/java/org/apache/commons/math3/optimization/direct/SimplexOptimizerMultiDirectionalTest.xml
143	fails because MultiDirectional.iterateSimplex is looping forever the while(true) should be replaced with a convergence check
162	The following function has 4 local extrema.
167	Local maximum.
168	Local minimum.
169	Global minimum.
170	Global maximum.
162	The following function has 4 local extrema.
167	Local maximum.
168	Local minimum.
169	Global minimum.
170	Global maximum.

Commons/xml/test/java/org/apache/commons/math3/optimization/direct/SimplexOptimizerNelderMeadTest.xml
209	The following function has 4 local extrema.
214	Local maximum.
215	Local minimum.
216	Global minimum.
217	Global maximum.
209	The following function has 4 local extrema.
214	Local maximum.
215	Local minimum.
216	Global minimum.
217	Global maximum.
209	The following function has 4 local extrema.
214	Local maximum.
215	Local minimum.
216	Global minimum.
217	Global maximum.

Commons/xml/test/java/org/apache/commons/math3/optimization/fitting/CurveFitterTest.xml
108	derivative with respect to a
111	derivative with respect to b in the reported (invalid) issue, there was a sign error here
115	derivative with respect to c
118	derivative with respect to d
108	derivative with respect to a
111	derivative with respect to b in the reported (invalid) issue, there was a sign error here
115	derivative with respect to c
118	derivative with respect to d

Commons/xml/test/java/org/apache/commons/math3/optimization/fitting/GaussianFitterTest.xml
277	The optimizer will try negative sigma values but "GaussianFitter" will catch the raised exceptions and return NaN values instead.
324	When the data points are not commented out below, the fit stalls. This is expected however, since the whole dataset hardly looks like a Gaussian. When commented out, the fit proceeds fine.
330	fitter.addObservedPoint(0.68, 0.0);
332	fitter.addObservedPoint(1.59, 0.0);
334	fitter.addObservedPoint(2.50, 0.0);
336	fitter.addObservedPoint(3.41, 0.0);
338	fitter.addObservedPoint(4.32, 0.0);
343	Values are copied from a previous run of this test.

Commons/xml/test/java/org/apache/commons/math3/optimization/fitting/HarmonicFitterTest.xml
42	This test fails (throwing "ConvergenceException" instead).
43	@Test(expected=ZeroException.class) public void testPreconditions2() { HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer());
48	final double x = 1.2; fitter.addObservedPoint(1, x, 1); fitter.addObservedPoint(1, x, -1); fitter.addObservedPoint(1, x, 0.5); fitter.addObservedPoint(1, x, 0);
54	final double[] fitted = fitter.fit(); }
114	This test serves to cover the part of the code of "guessAOmega" when the algorithm using integrals fails.
150	build a regularly spaced array of measurements
159	shake it
171	pass it to the fitter
195	The guesser fails because the function is far from an harmonic function: It is a triangular periodic function with amplitude 3 and period 12, and all sample points are taken at integer abscissae so function values all belong to the integer subset {-3, -2, -1, 0, 1, 2, 3}.

Commons/xml/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.xml
51	12.9 - 3.4 x + 2.1 x^2
54	Collect data from a known polynomial.
60	Start fit from initial guesses that are far from the optimal values.
140	Trying hard to fit.
156	Trying hard to fit.
217	Levenberg-Marquardt should handle redundant information gracefully
223	Gauss-Newton should not be able to solve redundant information
262	reusing the same point over and over again does not bring information, the problem cannot be solved in this case for degrees greater than 1 (but one point is sufficient for degree 0)

Commons/xml/test/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizerAbstractTest.xml
118	expected behavior
374	add perfect measurements and check errors are reduced

Commons/xml/test/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizerTestValidation.xml
66	Error on the observations.
69	True values of the parameters.
73	Samples generator.
80	Number of observations.
81	XXX Should be a command-line option.
82	number of parameters.
85	Parameters found for each of Monte-Carlo run.
87	Sigma estimations (square-root of the diagonal elements of the covariance matrix), for each Monte-Carlo run.
91	Initialize statistics accumulators.
97	Dummy optimizer (to compute the covariance matrix).
101	Monte-Carlo (generates many sets of observations).
105	Observations.
114	Direct solution (using simple regression).
117	Estimation of the standard deviation (diagonal elements of the covariance matrix).
123	Accumulate statistics.
129	Next Monte-Carlo.
133	Print statistics.
153	Check the error estimation.
187	Error on the observations.
190	True values of the parameters.
194	Samples generator.
201	Number of observations.
203	number of parameters.
206	Create a single set of observations.
215	Direct solution (using simple regression).
218	Dummy optimizer (to compute the chi-square).
221	Get chi-square of the best parameters set for the given set of observations.
226	Monte-Carlo (generates a grid of parameters).
230	Parameters found for each of Monte-Carlo run. Index 0 = slope Index 1 = offset Index 2 = normalized chi2
252	Output (for use with "gnuplot").
254	Some info.
256	For plotting separately sets of parameters that have a large chi2.
262	Point with smallest chi-square.
264	Empty line.
266	Points within the confidence interval.
272	Empty line.
274	Points outside the confidence interval.
281	Empty line.

Commons/xml/test/java/org/apache/commons/math3/optimization/general/CircleProblem.xml
100	Find the circle point closest to the observed point (observed points are points add through the addPoint method above)
124	Find the circle point closest to the observed point (observed points are points add through the addPoint method above)

Commons/xml/test/java/org/apache/commons/math3/optimization/general/CircleScalar.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/general/CircleVectorial.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/general/GaussNewtonOptimizerTest.xml
101	Exception is expected with this optimizer
110	Exception is expected with this optimizer
136	This test does not converge with this optimizer.
146	TODO This test leads to a singular problem with the Gauss-Newton optimizer. This should be inquired.

Commons/xml/test/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizerTest.xml
165	Test is skipped because it fails with the latest code update.
111	Overrides the method from parent class, since the default singularity threshold (1e-14) does not trigger the expected exception.
183	expected behavior
197	column 1 = times
204	column 2 = measured counts
245	Check that the computed solution is within the reference error range.
251	Check that each entry of the computed covariance matrix is within 10% of the reference matrix entry.
270	The test is extremely sensitive to the seed.
281	System.out.println(p.x + " " + p.y);
284	First guess for the center's coordinates and radius.
295	Retrieve errors estimation.
301	System.out.println("i=" + i + " value=" + paramFound[i] + " sigma=" + sigmaFound[i] + " ase=" + asymptoticStandardErrorFound[i]);
306	System.out.println("chi2=" + optimizer.getChiSquare());
308	Check that the parameters are found within the assumed error bars.

Commons/xml/test/java/org/apache/commons/math3/optimization/general/MinpackTest.xml
339	0.2578330049, 0.257829976764542
511	Assert.assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));

Commons/xml/test/java/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/general/RandomCirclePointGenerator.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/general/RandomStraightLinePointGenerator.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/general/StatisticalReferenceDataset.xml
97	Data columns are in reverse order!!!

Commons/xml/test/java/org/apache/commons/math3/optimization/general/StatisticalReferenceDatasetFactory.xml
34	Do nothing

Commons/xml/test/java/org/apache/commons/math3/optimization/general/StraightLineProblem.xml
65	x-coordinate.
78	y-coordinate.

Commons/xml/test/java/org/apache/commons/math3/optimization/linear/SimplexSolverTest.xml
136	allowing only non-negative values, no feasible solution shall be found

Commons/xml/test/java/org/apache/commons/math3/optimization/linear/SimplexTableauTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/MultivariateDifferentiableMultiStartOptimizerTest.xml
44	TODO: the wrapper around NonLinearConjugateGradientOptimizer is a temporary hack for version 3.1 of the library. It should be removed when NonLinearConjugateGradientOptimizer will officially be declared as implementing MultivariateDifferentiableOptimizer

Commons/xml/test/java/org/apache/commons/math3/optimization/MultivariateDifferentiableVectorMultiStartOptimizerTest.xml
103	TODO: the wrapper around GaussNewtonOptimizer is a temporary hack for version 3.1 of the library. It should be removed when GaussNewtonOptimizer will officialy be declared as implementing MultivariateDifferentiableVectorOptimizer
140	no optima before first optimization attempt
145	expected
165	TODO: the wrapper around GaussNewtonOptimizer is a temporary hack for version 3.1 of the library. It should be removed when GaussNewtonOptimizer will officialy be declared as implementing MultivariateDifferentiableVectorOptimizer

Commons/xml/test/java/org/apache/commons/math3/optimization/MultivariateMultiStartOptimizerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/PointValuePairTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/PointVectorValuePairTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/SimplePointCheckerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/SimpleValueCheckerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/SimpleVectorValueCheckerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/univariate/BracketFinderTest.xml
47	Comparing with results computed in Python.

Commons/xml/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.xml
55	expected
63	The default stopping criterion of Brent's algorithm should not pass, but the search will stop at the given relative tolerance for the function value.
97	The function has local minima at -0.27195613 and 0.82221643.
104	search in a large interval
111	The function has local minima at -0.27195613 and 0.82221643.
139	The quintic function has zeros at 0, +-0.5 and +-1. The function has a local maximum at 0.27195613.
148	expected
157	endpoint is minimum
202	A slightly less stringent tolerance would make the test pass even with the previous implementation.
217	System.out.println("numEval=" + numEval); System.out.println("min=" + init + " f=" + f.value(init)); System.out.println("sol=" + sol + " f=" + f.value(sol)); System.out.println("exp=" + expected + " f=" + f.value(expected));
249	System.out.println("min=" + (minSin + offset) + " f=" + f.value(minSin + offset)); System.out.println("sol=" + sol + " f=" + f.value(sol)); System.out.println("exp=" + expected + " f=" + f.value(expected));

Commons/xml/test/java/org/apache/commons/math3/optimization/univariate/SimpleUnivariateValueCheckerTest.xml

Commons/xml/test/java/org/apache/commons/math3/optimization/univariate/UnivariateMultiStartOptimizerTest.xml
54	The quintic function has zeros at 0, +-0.5 and +-1. The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,
96	Expected.
99	Ensure that the exception was thrown because no optimum was found.

Commons/xml/test/java/org/apache/commons/math3/PerfTestUtils.xml
109	Try to perform GC outside the timed block.
116	Timed block.
123	Collect run time.
125	Keep track of a randomly selected result.
130	Abort benchmarking if codes throw exceptions.
167	Header format.
170	Width of the longest name.
180	Column format.
182	Result format.

Commons/xml/test/java/org/apache/commons/math3/primes/PrimesTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/AbstractRandomGeneratorTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/BitsStreamGeneratorTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/CorrelatedRandomVectorGeneratorTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/EmpiricalDistributionTest.xml
308	Setup for distribution tests
63	empiricalDistribution = new EmpiricalDistribution(100, new RandomDataImpl()); // XXX Deprecated API
68	empiricalDistribution2 = new EmpiricalDistribution(100, new RandomDataImpl()); // XXX Deprecated API
97	Load from a URL
101	Load again from a file (also verifies idempotency of load)
108	testData File has 10000 values, with mean ~ 5.0, std dev ~ 1 Make sure that loaded distribution matches this
111	TODO: replace with statistical tests
127	testData File has 10000 values, with mean ~ 5.0, std dev ~ 1 Make sure that loaded distribution matches this
130	TODO: replace with statistical tests
164	expected
185	ridiculous tolerance; but ridiculous grid size really just checking to make sure we do not bomb
202	Empty
207	Loaded
254	Verify no NPE with null generator argument
312	Create a uniform distribution on [0, 10,000]
337	Bins should be [0, 10], (10, 20], ..., (9990, 10000] Kernels should be N(4.5, 3.02765), N(14.5, 3.02765)... Each bin should have mass 1010000 = .001
351	Compute bMinus = sum or mass of bins below the bin containing the point First bin has mass 11 / 10000, the rest have mass 10 / 10000.
406	Triangle integrals are very slow to converge
415	Number of bins below x should be trunc(x/10)
418	If x falls on a bin boundary, it is in the lower bin
442	Bin masses concentrated on 2, 5, 8, 11, 14 <- effectively discrete uniform distribution over these
468	Kernels are uniform distributions on [1,3], [4,6], [7,9], [10,12], [13,15]
473	Make sure v is not in the excluded range between bins - that is (bounds[i], bounds[i] + 1)
502	Use constant distribution equal to bin mean within bin
502	Use constant distribution equal to bin mean within bin
502	Use constant distribution equal to bin mean within bin

Commons/xml/test/java/org/apache/commons/math3/random/GaussianRandomGeneratorTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/ISAACTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/MersenneTwisterTest.xml
30	TODO: Some of the tests moved up to RandomGeneratorAbstractTest tested alternative seeding / constructors Tests exercising these features directly should be added to this class.

Commons/xml/test/java/org/apache/commons/math3/random/RandomAdaptorTest.xml
57	"Constant" generator to test Adaptor delegation. "Powered by Eclipse ;-)"

Commons/xml/test/java/org/apache/commons/math3/random/RandomDataGeneratorTest.xml
996	Disable until we have equals public void testSerial() { Assert.assertEquals(randomData, TestUtils.serializeAndRecover(randomData)); }
107	ignored
182	ignored
257	ignored
314	ignored
378	ignored
384	ignored
390	ignored
416	Small integral means
420	non-integer means
424	large means TODO: When MATH-282 is resolved, s/3000/10000 below
441	Generate sample values
442	Number of deviates to generate
443	Minimum size of expected bin count
445	Probability of false failure
455	Set up bins for chi-square test. Ensure expected counts are all at least minExpectedCount. Start with upper and lower tail bins. Lower bin = [0, lower); Upper bin = [upper, +inf).
466	Even for mean = 1, not much mass beyond 5
471	Set bin width for interior bins.  For poisson, only need to look at end bins.
483	Determine interior bin bounds.  Bins are [1, lower = binBounds[0]), [lower, binBounds[1]), [binBounds[1], binBounds[2]), ... , [binBounds[binCount - 2], upper = binBounds[binCount - 1]), [upper, +inf)
496	The size of bin [binBounds[binCount - 2], upper) satisfies binWidth <= size < 2*binWidth.
498	Compute observed and expected bin counts
503	Bottom bin
510	Top bin
517	Interior bins
522	Expected count is (mass in [binBounds[i-1], binBounds[i])) * sampleSize
527	Use chisquare test to verify that generated values are poisson(mean)-distributed
529	Fail if we can reject null hypothesis that distributions are the same
567	ignored
573	ignored
587	ignored
616	ignored
622	ignored
636	ignored
663	ignored
669	ignored
675	ignored
681	ignored
687	ignored
720	Set up bin bounds - min, binBound[0], ..., binBound[binCount-2], max
722	Prevent overflow in extreme value case
726	+ instead of * to avoid overflow in extreme case
733	Find bin
769	ignored
788	ignored
794	ignored
799	Mean 1
809	Mean 5
839	remove this test back soon, since it takes about 4 seconds  try { randomData.setSecureAlgorithm("SHA1PRNG","SUN"); } catch (NoSuchProviderException ex) { ; } Assert.assertTrue("different seeds", !hex.equals(randomData.nextSecureHexString(40))); try { randomData.setSecureAlgorithm("NOSUCHTHING","SUN"); Assert.fail("expecting NoSuchAlgorithmException"); } catch (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException ex) { ; }  try { randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER"); Assert.fail("expecting NoSuchProviderException"); } catch (NoSuchProviderException ex) { ; }
855	test reseeding without first using the generators
879	{0,1,2,3,4}
884	2-sets from 5
897	Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67 for alpha = .01
904	Make sure sample of size = size of collection returns same collection
913	Make sure we fail for sample size > collection size
918	ignored
921	Make sure we fail for empty collection
927	ignored
964	Check size = 1 boundary case
969	Make sure we fail for k size > n
974	ignored
977	Make sure we fail for n = 0
982	ignored
985	Make sure we fail for k < n < 0
990	ignored
1019	Set the seed for the default random generator
1026	Reseed again so the inversion generator gets the same sequence
1030	Generate a sequence of deviates using inversion - the distribution function evaluated at the random value from the distribution should match the uniform random value used to generate it, which is stored in the quantiles[] array.
1094	Tests shape > 1, one case in the rejection sampling
1104	Tests shape <= 1, another case in the rejection sampling
1242	MATH-720

Commons/xml/test/java/org/apache/commons/math3/random/RandomGeneratorAbstractTest.xml
72	Omit secureXxx tests, since they do not use the provided generator
93	Tests uniformity of nextInt(int) distribution by generating 1000 samples for each of 10 test values and for each sample performing a chi-square test of homogeneity of the observed distribution with the expected uniform distribution.  Tests are performed at the .01 level and an average failure rate higher than 2% (i.e. more than 20 null hypothesis rejections) causes the test case to fail.  All random values are generated using the generator instance used by other tests and the generator is not reseeded, so this is a fixed seed test.
106	Set up test values - end of the array filled randomly
116	Set up bins
131	Run the tests
171	ignored
176	ignored
208	Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34 for alpha = .01
227	Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.635 for alpha = .01
257	Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34 for alpha = .01
367	makeGenerator initializes with fixed seed
371	reseed, but recreate the second one verifies MATH-723
380	Needs to be an odd number to check MATH-723

Commons/xml/test/java/org/apache/commons/math3/random/StableRandomGeneratorTest.xml
82	Standard Cauchy distribution should have zero median and mode

Commons/xml/test/java/org/apache/commons/math3/random/SynchronizedRandomGeneratorTest.xml
71	Running the test several times in order to decrease the probability that a non-thread-safe code did not trigger a concurrency problem.

Commons/xml/test/java/org/apache/commons/math3/random/TestRandomGenerator.xml

Commons/xml/test/java/org/apache/commons/math3/random/UncorrelatedRandomVectorGeneratorTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/UniformRandomGeneratorTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/UnitSphereRandomVectorGeneratorTest.xml
36	In 2D, angles with a given vector should be uniformly distributed
43	Compute angle formed with vector (1,0) Cosine of angle is their dot product, because both are unit length Dot product here is just the first element of the vector by construction
51	Simplistic test for roughly even distribution

Commons/xml/test/java/org/apache/commons/math3/random/ValueServerTest.xml
137	expected behavior
150	expected behavior
179	make sure no NPE
208	ignored

Commons/xml/test/java/org/apache/commons/math3/random/Well1024aTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/Well19937aTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/Well19937cTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/Well44497aTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/Well44497bTest.xml

Commons/xml/test/java/org/apache/commons/math3/random/Well512aTest.xml

Commons/xml/test/java/org/apache/commons/math3/Retry.xml

Commons/xml/test/java/org/apache/commons/math3/RetryRunner.xml
60	Do a single test run attempt.
67	Do a single test run attempt.
69	Attempt succeeded, stop evaluation here.
72	Attempt failed, store the reason.
77	All attempts failed.
60	Do a single test run attempt.
67	Do a single test run attempt.
69	Attempt succeeded, stop evaluation here.
72	Attempt failed, store the reason.
77	All attempts failed.

Commons/xml/test/java/org/apache/commons/math3/RetryRunnerTest.xml

Commons/xml/test/java/org/apache/commons/math3/special/BetaTest.xml
36	Use reflection to test private methods.
280	Use reflection to access private method.
465	Use reflection to access private method.
638	Use reflection to access private method.

Commons/xml/test/java/org/apache/commons/math3/special/ErfTest.xml

Commons/xml/test/java/org/apache/commons/math3/special/GammaTest.xml
116	values for negative powers of 10 from 1 to 30 as computed by webMathematica with 20 digits see functions.wolfram.com
132	computed using webMathematica.  For example, to compute trigamma($i) = Polygamma(1, $i), use  http:functions.wolfram.com/webMathematica/Evaluated.jsp?name=PolyGamma2&plottype=0&vars={%221%22,%22$i%22}&digits=20

Commons/xml/test/java/org/apache/commons/math3/stat/CertifiedDataTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/clustering/DBSCANClustererTest.xml
32	Test data generated using: http://people.cs.nctu.edu.tw/~rsliang/dbscan/testdatagen.html
140	A
146	B
147	C
148	N - Noise, should not be present
149	D - single-link connected to C should not be present

Commons/xml/test/java/org/apache/commons/math3/stat/clustering/EuclideanDoublePointTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/clustering/EuclideanIntegerPointTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/clustering/KMeansPlusPlusClustererTest.xml
40	first expected cluster
50	second expected cluster
57	third expected cluster
133	initialise testvalues
138	testvalues will be multiplied
142	define the space which will break the cluster algorithm
145	multiply the values
216	Create a bunch of CloseIntegerPoints. Most are identical, but one is different by a small distance.
232	Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial cluster centers).
242	Check that one of the chosen centers is the unique point.

Commons/xml/test/java/org/apache/commons/math3/stat/correlation/CovarianceTest.xml
188	Expected
194	Expected
207	Variances on the diagonal
213	Symmetry, column-consistency
218	All columns same -> all entries = column variance
231	Check bias-correction defaults

Commons/xml/test/java/org/apache/commons/math3/stat/correlation/PearsonsCorrelationTest.xml
173	Create a dataset that has r -> 1, p -> 0 as dimension increases. Prior to the fix for MATH-371, p vanished for dimension >= 14. Post fix, p-values diminish smoothly, vanishing at dimension = 127. Tested value is ~1E-303.
213	Expected
220	Expected

Commons/xml/test/java/org/apache/commons/math3/stat/correlation/SpearmansRankCorrelationTest.xml
154	Not relevant here
100	Expected
107	Expected
147	compute correlation

Commons/xml/test/java/org/apache/commons/math3/stat/correlation/StorelessCovarianceTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/data/CertifiedDataAbstractTest.xml
69	this call to StringUtils did little for the following conditional structure
74	not empty line or comment
78	data value
83	certified value
141	Get the value of prop
153	ignored

Commons/xml/test/java/org/apache/commons/math3/stat/data/LewTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/data/LotteryTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatisticTest.xml
56	start past end
59	expected
62	end past end
65	expected
68	start negative
71	expected
74	length negative
77	expected
80	null array
83	expected
86	null weights array
89	expected
92	weights.length != value.length
95	expected
98	can't have negative weights
101	expected

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatisticsTest.xml
88	Generate a random sample and random partition
93	Create aggregator and total stats for comparison
97	Create array of component stats
102	Make componentStats[i] a contributing statistic to aggregate
105	Add values from subsample
111	Compute totalStats directly
116	Compare statistics in totalStats with aggregate. Note that guaranteed success of this comparison depends on the fact that <aggregate> gets values in exactly the same order as <totalStats>.
138	Generate a random sample and random partition
143	Compute combined stats directly
149	Now compute subsample stats individually and aggregate
162	Compare values
173	Compute combined stats directly
179	Now compute subsample stats individually and aggregate
192	Compare values
202	Compute combined stats directly
208	Now compute subsample stats individually and aggregate
221	Compare values
268	beginning of current partition segment
269	end of current partition segment
270	number of segments defined

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/DescriptiveStatisticsTest.xml
268	Test UnivariateStatistics impls for setter injection tests
51	Now lets try some new math
63	Now lets try some new math
83	expected
133	the purpose of this test is only to check the get/set methods we are aware shuffling statistics like this is really not something sensible to do in production ...
175	Inject wrapped Percentile impl
179	Try "new math" impl
183	Try to set bad impl
188	expected

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/ListUnivariateImpl.xml
80	If the window size is not INFINITE_WINDOW AND the current list is larger that the window size, we need to take into account only the last n elements of the list as definied by windowSize
90	Create an array to hold all values
199	Discard elements from the front of the list if the windowSize is less than the size of the list.

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/ListUnivariateImplTest.xml
120	Now test rolling - StorelessDescriptiveStatistics should discount the contribution of a discarded element
125	Values should be (2,3,4,5,6,7,8,9,10,11)

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/MixedListUnivariateImplTest.xml
167	Now test rolling - StorelessDescriptiveStatistics should discount the contribution of a discarded element
172	Values should be (2,3,4,5,6,7,8,9,10,11)

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/FirstMomentTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/FourthMomentTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/GeometricMeanTest.xml
52	empty
55	finite data
59	add 0 -- makes log sum blow to minus infinity, should make 0
63	add positive infinity - note the minus infinity above
67	clear
71	positive infinity by itself
75	negative value -- should make NaN

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/InteractionTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/KurtosisTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/MeanTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/SecondMomentTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/SemiVarianceTest.xml
70	6.333...
71	Default bias correction is true
72	Downside is the default
81	Verify that upper + lower semivariance against the mean sum to variance
101	Turn off bias correction - use df = length
120	Bias corrected
138	Bias corrected

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/SkewnessTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/StandardDeviationTest.xml
71	side effect is to add values

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/ThirdMomentTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/VarianceTest.xml
75	side effect is to add values
107	All weights = 1 -> weighted variance = unweighted variance
111	All weights the same -> when weights are normalized to sum to the length of the values array, weighted variance = unweighted value

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/VectorialCovarianceTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/moment/VectorialMeanTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/MultivariateSummaryStatisticsTest.xml
61	OK after clear
80	expected
109	the purpose of this test is only to check the get/set methods we are aware shuffling statistics like this is really not something sensible to do in production ...
181	expected behavior
256	Empty test
261	Add some data
268	Test again
288	Add some data to u
298	Add data in same order to t
308	Clear and make sure summaries are indistinguishable from empty summary

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/rank/MaxTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/rank/MedianTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/rank/MinTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/rank/PercentileTest.xml
76	invalid percentiles
81	success
87	success
116	expected
148	Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY
155	OK
161	expected
167	expected

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/StatisticalSummaryValuesTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatisticAbstractTest.xml
53	Add testArray one value at a time and check result
63	Add testArray all at once and check again
70	Cleared
195	Randomly select a portion of testArray to load first
198	Put first half in master and copy master to replica
202	Check same
206	Now add second part to both and check again

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/summary/ProductTest.xml
47	sic -- big absolute error due to only 15 digits of accuracy in double

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/summary/SumLogTest.xml
53	empty
56	finite data
60	add negative infinity
64	add positive infinity -- should make NaN
68	clear
72	positive infinity by itself
76	negative value -- should make NaN

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/summary/SumSqTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/summary/SumTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/SummaryStatisticsTest.xml
147	FiXME: test all other NaN contract specs
169	Empty test
175	Add some data
182	Test again
203	Add some data to u
213	Add data in same order to t
223	Clear and make sure summaries are indistinguishable from empty summary
243	Make sure both behave the same with additional values added
255	Check implementation pointers are preserved
288	OK after clear
300	expected
312	use "population variance"

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatisticsTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/SynchronizedMultivariateSummaryStatisticsTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatisticsTest.xml

Commons/xml/test/java/org/apache/commons/math3/stat/descriptive/UnivariateStatisticAbstractTest.xml
122	See if this statistic computes weighted statistics If not, skip this test
171	See if this statistic computes weighted statistics If not, skip this test
178	Create arrays of values and corresponding integral weights and longer array with values repeated according to the weights
180	length of values array
181	mean of test data
182	std dev of test data
186	Fill weights array with random int values between 1 and 5
194	Fill values array with random data from N(mu, sigma) and fill valuesList with values from values array with values[i] repeated weights[i] times, each i
207	Dump valuesList into repeatedValues array
214	Compare result of weighted statistic computation with direct computation on array of repeated values
221	Check consistency of weighted evaluation methods

Commons/xml/test/java/org/apache/commons/math3/stat/FrequencyTest.xml
75	userguide examples -------------------------------------------------------------------
164	expected
170	expected
183	expected
212	System.out.println(s);
215	header line
218	one's or two's line
221	one's or two's line
224	no more elements

Commons/xml/test/java/org/apache/commons/math3/stat/inference/ChiSquareTestTest.xml
42	Target values computed using R version 1.8.1 Some assembly required ;-) Use sum((obs - exp)^2/exp) for the chi-square statistic and 1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value
63	expected
72	expected
75	unmatched arrays
82	expected
85	0 expected count
91	expected
94	negative observed count
101	expected
109	Target values computed using R version 1.8.1
122	ragged input array
128	expected
131	insufficient data
137	expected
144	expected
147	negative counts
153	expected
156	bad alpha
161	expected
186	Target values computed using R version 1.8.1
241	expected
250	expected
259	expected

Commons/xml/test/java/org/apache/commons/math3/stat/inference/GTestTest.xml
87	Intrinisic (Hardy-Weinberg proportions) P-Value should be 0.033
162	expected
171	expected
180	expected
193	expected
199	expected
212	expected
218	expected
230	expected
243	expected
249	expected
272	positive where k11 is bigger than expected.
275	negative because k11 is lower than expected

Commons/xml/test/java/org/apache/commons/math3/stat/inference/MannWhitneyUTestTest.xml
38	Target values computed using R version 2.11.1 x <- c(19, 22, 16, 29, 24) y <- c(20, 11, 17, 12) wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = FALSE, exact = FALSE, correct = FALSE) W = 17, p-value = 0.08641
54	Samples must be present, i.e. length > 0
60	expected
67	expected
70	x and y is null
77	expected
84	expected
87	x or y is null
94	expected
101	expected

Commons/xml/test/java/org/apache/commons/math3/stat/inference/OneWayAnovaTest.xml
50	Target comparison values computed using R version 2.6.0 (Linux version)
73	expected
82	expected
89	Target comparison values computed using R version 2.6.0 (Linux version)
109	Target comparison values computed using R version 2.6.0 (Linux version)
141	Target comparison values computed using R version 2.3.1 (Linux version)

Commons/xml/test/java/org/apache/commons/math3/stat/inference/TestUtilsTest.xml
44	Target values computed using R version 1.8.1 Some assembly required ;-) Use sum((obs - exp)^2/exp) for the chi-square statistic and 1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value
65	expected
74	expected
77	unmatched arrays
84	expected
87	0 expected count
93	expected
96	negative observed count
103	expected
111	Target values computed using R version 1.8.1
124	ragged input array
130	expected
133	insufficient data
139	expected
146	expected
149	negative counts
155	expected
158	bad alpha
163	expected
188	Target values computed using R version 1.8.1
211	Target comparison values computed using R version 1.8.1 (Linux version)
225	expected
232	expected
239	expected
246	expected
253	expected
259	expected
266	expected
272	expected
284	Target comparison values computed using R version 1.8.1 (Linux version)
302	expected
309	expected
327	Target comparison values computed using R version 1.8.1 (Linux version)
349	expected
356	expected
363	expected
370	expected
377	expected
384	expected
391	expected
398	expected
414	Target comparison values computed using R version 1.8.1 (Linux version)
430	Target values computed using R, version 1.8.1 (linux version)
443	Target values computed using R, version 1.8.1 (linux version)
512	positive where k11 is bigger than expected.
515	negative because k11 is lower than expected

Commons/xml/test/java/org/apache/commons/math3/stat/inference/TTestTest.xml
60	Target comparison values computed using R version 1.8.1 (Linux version)
74	expected
81	expected
88	expected
95	expected
102	expected
108	expected
115	expected
121	expected
133	Target comparison values computed using R version 1.8.1 (Linux version)
151	expected
158	expected
176	Target comparison values computed using R version 1.8.1 (Linux version)
198	expected
205	expected
212	expected
219	expected
226	expected
233	expected
240	expected
247	expected
263	Target comparison values computed using R version 1.8.1 (Linux version)
279	Target values computed using R, version 1.8.1 (linux version)
292	Target values computed using R, version 1.8.1 (linux version)

Commons/xml/test/java/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTestTest.xml
40	Target values computed using R version 2.11.1 x <- c(1.83, 0.50, 1.62, 2.48, 1.68, 1.88, 1.55, 3.06, 1.30) y <- c(0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29)
47	EXACT: wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = TRUE, exact = TRUE, correct = FALSE) V = 40, p-value = 0.03906  Corresponds to the value obtained in R.
56	ASYMPTOTIC: wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = TRUE, exact = FALSE, correct = FALSE) V = 40, p-value = 0.03815  This is not entirely the same due to different corrects, e.g. http:mlsc.lboro.ac.ukresourcesstatisticswsrt.pdf and srclibrarystatsRwilcox.test.R in the R source
70	Exact only for sample size <= 30
81	Exactly 30 is okay testStatistic.wilcoxonSignedRankTest(x1, y1, true);
88	expected
91	Samples must be present, i.e. length > 0
97	expected
104	expected
111	expected
118	expected
121	Samples not same size, i.e. cannot be pairred
127	expected
134	expected
137	x and y is null
144	expected
151	expected
154	x or y is null
161	expected
168	expected
175	expected
182	expected

Commons/xml/test/java/org/apache/commons/math3/stat/ranking/NaturalRankingTest.xml
46	Ties averaged, NaNs failed
54	expected
68	expected

Commons/xml/test/java/org/apache/commons/math3/stat/regression/GLSMultipleLinearRegressionTest.xml
160	assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};
206	TODO:  Should have assertRelativelyEquals(double[], double[], eps) in TestUtils Should also add RealVector and RealMatrix versions
221	Seed has been selected to generate non-trivial covariance
223	Assume model has 16 observations (will use Longley data).  Start by generating non-constant variances for the 16 error terms.
231	Now generate 1000 error vectors to use to estimate the covariance matrix Columns are draws on N(0, sigma[col])
241	Get covariance matrix for columns
244	Create a CorrelatedRandomVectorGenerator to use to generate correlated errors
246	Counting on init to 0 here
250	Now start generating models.  Use Longley X matrix on LHS and Longley OLS beta vector as "true" beta.  Generate Y values by XB + u where u is a CorrelatedRandomVector generated from cov.
259	Create a GLS model to reuse
264	Create aggregators for stats measuring model performance
268	Generate Y vectors for 10000 models, estimate GLS and OLS and Verify that OLS estimates are better
273	Generate y = xb + u with u cov
277	Estimate OLS parameters
281	Estimate GLS parameters
285	Record deviations from "true" beta
293	Verify that GLS is on average more efficient, lower variance

Commons/xml/test/java/org/apache/commons/math3/stat/regression/MillerUpdatingRegressionTest.xml
34	This is the Greene Airline Cost data. The data can be downloaded from http:www.indiana.edu~statmathstatallpanelairline.csv
162	Results can be found at http:www.indiana.edu~statmathstatallpanelpanel4.html This test concerns a known data set
559	@Test
717	@Test public void testRegressReorder() { System.out.println("testRegressReorder"); MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); double[][] x = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; for (int i = 0; i < airdata[0].length; i++) { x[i] = new double[4]; x[i][0] = 1.0; x[i][1] = Math.log(airdata[3][i]); x[i][2] = Math.log(airdata[4][i]); x[i][3] = airdata[5][i]; y[i] = Math.log(airdata[2][i]); }  instance.addObservations(x, y); RegressionResults result = instance.regress(); if (result == null) { Assert.fail("Null result...."); }  instance.reorderRegressors(new int[]{3, 2}, 0); RegressionResults resultInverse = instance.regress();  double[] beta = result.getParameterEstimates(); double[] betar = resultInverse.getParameterEstimates(); if (Math.abs(beta[0] - betar[0]) > 1.0e-14) { Assert.fail("Parameters not correct after reorder (0,3)"); } if (Math.abs(beta[1] - betar[1]) > 1.0e-14) { Assert.fail("Parameters not correct after reorder (1,2)"); } if (Math.abs(beta[2] - betar[2]) > 1.0e-14) { Assert.fail("Parameters not correct after reorder (2,1)"); } if (Math.abs(beta[3] - betar[3]) > 1.0e-14) { Assert.fail("Parameters not correct after reorder (3,0)"); } }
113	now we try it without an intercept
323	tmp[1] = tmp[0] * tmp[0]; tmp[2] = tmp[0] * tmp[1]; ^3 tmp[3] = tmp[1] * tmp[1]; ^4 tmp[4] = tmp[2] * tmp[1]; ^5 tmp[5] = tmp[2] * tmp[2]; ^6 tmp[6] = tmp[2] * tmp[3]; ^7 tmp[7] = tmp[3] * tmp[3]; ^8 tmp[8] = tmp[4] * tmp[3]; ^9 tmp[9] = tmp[4] * tmp[4]; ^10
630	Y values are first, then independent vars Each row is one observation
654	Estimate the model
664	Check expected beta values from NIST
673	Check standard errors from NIST
683	Check R-Square statistics against R
686	Estimate model without intercept
696	Check expected beta values from R
704	Check standard errors from R
711	// Check R-Square statistics against R

Commons/xml/test/java/org/apache/commons/math3/stat/regression/MultipleLinearRegressionAbstractTest.xml
97	No intercept

Commons/xml/test/java/org/apache/commons/math3/stat/regression/OLSMultipleLinearRegressionTest.xml
513	This is a test based on the Wampler1 data set http:www.itl.nist.govdiv898strdllsdataWampler1.shtml
581	This is a test based on the Wampler2 data set http:www.itl.nist.govdiv898strdllsdataWampler2.shtml
649	This is a test based on the Wampler3 data set http:www.itl.nist.govdiv898strdllsdataWampler3.shtml
718	This is a test based on the Wampler4 data set http:www.itl.nist.govdiv898strdllsdataWampler4.shtml
118	Y values are first, then independent vars Each row is one observation
142	Estimate the model
146	Check expected beta values from NIST
154	Check expected residuals from R
165	Check standard errors from NIST
175	Check regression standard error against R
178	Check R-Square statistics against R
184	Estimate model without intercept
188	Check expected beta values from R
195	Check standard errors from R
201	Check expected residuals from R
210	Check regression standard error against R
213	Check R-Square statistics against R
278	Estimate the model
282	Check expected beta values from R
291	Check expected residuals from R
312	Check standard errors from R
320	Check regression standard error against R
323	Check R-Square statistics against R
329	Estimate the model with no intercept
334	Check expected beta values from R
342	Check expected residuals from R
359	Check standard errors from R
364	Check regression standard error against R
367	Check R-Square statistics against R
379	This example is from "The Hat Matrix in Regression and ANOVA", David C. Hoaglin and Roy E. Welsch, The American Statistician, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.
401	Estimate the model
407	Reference data is upper half of symmetric hat matrix
421	Check against reference data and verify symmetry
431	Verify that residuals computed using the hat matrix are close to what we get from direct computation, i.e. r = (I - H) y
447	assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};
459	Check Y variance consistency
462	Check residual variance consistency
492	No intercept

Commons/xml/test/java/org/apache/commons/math3/stat/regression/SimpleRegressionTest.xml
36	NIST "Norris" refernce data set from http:www.itl.nist.govdiv898strdllsdataLINKSDATANorris.dat Strangely, order is {y,x}
51	Correlation example from http:www.xycoon.comcorrelation.htm
61	From Moore and Mcabe, "Introduction to the Practice of Statistics" Example 10.3
69	Points to remove in the remove tests
78	Data with bad linear fit
86	Data from NIST NOINT1
103	Data from NIST NOINT2
480	Jira MATH-85 = Bugzilla 39432
492	Test remove X,Y (single observation)
512	Test remove single observation in array
531	Test remove multiple observations
550	Remove observation when empty
558	Remove single observation to empty
567	Remove multiple observations to empty
576	Remove multiple observations past empty (i.e. size of array > n)
125	should not be null
166	No intercept
171	null array
175	Expected
177	empty array
181	Expected
183	more than 1 regressor
187	Expected
189	invalid regressor
193	Expected
196	With intercept
201	null array
205	Expected
207	empty array
211	Expected
213	more than 2 regressors
217	Expected
219	wrong order
223	Expected
225	out of range
229	Expected
231	out of range
235	Expected
237	out of range
241	Expected
295	Tests against certified values from http:www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat
313	------------  End certified data tests
348	No x variation, so these should still blow...
360	but SSTO should be OK
368	All should be OK except MSE, s(b0), s(b1) which need one more df
383	MSE, MSE, s(b0), s(b1) should all be OK now
404	----------  verified against R, version 1.8.1 ----- infData
416	infData2
427	------------- End R-verified tests -------------------------------
429	FIXME: get a real example to test against with alpha = .01
437	ignored
495	Create regression with inference data then remove to test
500	Use the inference assertions to make sure that everything worked
515	Create regression with inference data then remove to test
520	Use the inference assertions to make sure that everything worked
534	Create regression with inference data then remove to test
539	Use the inference assertions to make sure that everything worked

Commons/xml/test/java/org/apache/commons/math3/stat/StatUtilsTest.xml
106	expected
113	expected
122	test null
127	success
134	success
137	test empty
142	test one
147	test many
157	test null
162	success
169	success
172	test empty
177	test one
182	test many
192	test null
197	success
204	success
207	test empty
212	test one
217	test many
231	success
234	test empty
238	test one
242	test many
255	success
258	test empty
262	test one
266	test many
270	test precomputed mean
283	success
286	test empty
290	test one
294	test many
298	test precomputed mean
312	success
315	test empty
319	test one
323	test many
327	test first nan is ignored
331	test middle nan is ignored
335	test last nan is ignored
339	test all nan returns nan
352	success
355	test empty
359	test one
363	test many
367	test first nan is ignored
371	test middle nan is ignored
375	test last nan is ignored
379	test all nan returns nan
388	test null
393	success
400	success
403	test empty
408	test one
413	test many
434	expected
440	expected
447	expected
458	expected
490	create an sample with 77 values
496	normalize this sample
500	Add the data from the array
504	the calculations do have a limited precision
506	check the mean an standard deviation

Commons/xml/test/java/org/apache/commons/math3/TestUtils.xml
64	check for NaN
115	serialize the Object
120	deserialize the Object
408	Fail if we can reject null hypothesis that distributions are the same

Commons/xml/test/java/org/apache/commons/math3/transform/FastCosineTransformerTest.xml
173	Additional tests.
163	Should never occur. This clause is a safeguard in case other types are used to TransformType (which should not be done).
227	bad interval
231	expected
234	bad samples number
239	expected
242	bad samples number
247	expected

Commons/xml/test/java/org/apache/commons/math3/transform/FastFourierTransformerTest.xml
45	Precondition checks.
165	Utility methods for checking (successful) transforms.
333	Tests of standard transform (when data is valid).
397	Additional tests for 1D data.
485	Additional tests for 2D data.
66	Expected behaviour
89	Expected behaviour
112	Expected behaviour
136	Expected behaviour
159	Expected behaviour

Commons/xml/test/java/org/apache/commons/math3/transform/FastHadamardTransformerTest.xml
71	expected
82	Initiate the transformer
85	check double transform
92	compare computed results to precomputed results
98	Initiate the transformer
101	check integer transform
104	compare computed results to precomputed results
111	Initiate the transformer
114	check double transform
121	compare computed results to precomputed results

Commons/xml/test/java/org/apache/commons/math3/transform/FastSineTransformerTest.xml
184	Additional tests.
204	Additional (legacy) tests.
174	Should never occur. This clause is a safeguard in case other types are used to TransformType (which should not be done).
199	Expected: do nothing
281	bad interval
285	expected
288	bad samples number
292	expected
295	bad samples number
299	expected

Commons/xml/test/java/org/apache/commons/math3/transform/RealTransformerAbstractTest.xml
146	Check of preconditions.
246	Accuracy tests of transform of valid data.
296	Utility methods.
316	The tests per se.
165	Expected: do nothing
190	Expected: do nothing
215	Expected: do nothing
240	Expected: do nothing

Commons/xml/test/java/org/apache/commons/math3/util/ArithmeticUtilsTest.xml
140	ignored
147	ignored
154	ignored
161	ignored
167	ignored
173	ignored
180	ignored
186	ignored
199	This tests all legal and illegal values for n <= 200.
237	This one should throw
242	Expected
273	ignored
279	ignored
285	ignored
291	ignored
325	gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE
329	expected
332	gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE
336	expected
339	gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE
343	expected
402	gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE
406	expected
409	gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE
413	expected
416	gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE
420	expected
441	Assert that no intermediate value overflows: The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)
445	Special case
449	lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int
453	expected
457	lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int
461	expected
468	expected
490	Assert that no intermediate value overflows: The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)
494	Special case
498	lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int
502	expected
506	lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int
510	expected
519	expected
600	min == -1-max
617	expected behavior
626	expected behavior
635	expected behavior
644	expected behavior
654	expected behavior
663	expected behavior
672	expected behavior
772	Reduce stack depth for larger values of n
808	success
817	success
826	success

Commons/xml/test/java/org/apache/commons/math3/util/BigRealFieldTest.xml
39	deserializing the singleton should give the singleton itself back

Commons/xml/test/java/org/apache/commons/math3/util/BigRealTest.xml

Commons/xml/test/java/org/apache/commons/math3/util/ContinuedFractionTest.xml

Commons/xml/test/java/org/apache/commons/math3/util/Decimal64Test.xml

Commons/xml/test/java/org/apache/commons/math3/util/DefaultTransformerTest.xml
55	expected

Commons/xml/test/java/org/apache/commons/math3/util/DoubleArrayAbstractTest.xml
34	Array used to test rolling

Commons/xml/test/java/org/apache/commons/math3/util/FastMathStrictComparisonTest.xml
45	Values which often need special handling
107	show difference as hex
111	Not 100% sure off-by-one errors are allowed everywhere, so only allow for these methods
121	show difference as hex
204	Only test public methods
206	Only check methods with at least one parameter
208	Get the corresponding FastMath method
210	It must be public too
231	System.out.println(fastMethod);
232	The current implementation runs each method as a separate test. Could be amended to run each value as a separate test
237	setupMethodCall(mathMethod, fastMethod, params, data);

Commons/xml/test/java/org/apache/commons/math3/util/FastMathTest.xml
243	double x = generator.nextDouble()*2.0;
253	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
268	double x = generator.nextDouble()*2.0;
277	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
292	double x = generator.nextDouble()*2.0;
301	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
335	Smallest value that will round up to Double.MIN_VALUE
392	Added tests for a 100% coverage
475	double x = FastMath.floor(generator.nextDouble()1024.0 - 512.0); double y; if (x != 0) y = FastMath.floor(512.0  FastMath.abs(x)); else y = generator.nextDouble()1200.0; y = y - y2; x = FastMath.pow(2.0, x) generator.nextDouble(); y = y  generator.nextDouble();
482	double x = generator.nextDouble()*2.0;
492	System.out.println(x + "\t" + y + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
508	double x = (generator.nextDouble() * 20.0) - 10.0; double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
519	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
534	double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();
537	double x = (generator.nextDouble() * 20.0) - 10.0; double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
548	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
563	double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();
566	double x = (generator.nextDouble() * 20.0) - 10.0; double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
577	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
592	double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();
595	double x = (generator.nextDouble() * 20.0) - 10.0; double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
606	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
621	double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble(); double x = ((generator.nextDouble() * Math.PI) - Math.PI/2.0) * generator.nextDouble();
626	double x = (generator.nextDouble() * 20.0) - 10.0; double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
637	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
652	double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();
655	double x = (generator.nextDouble() * 20.0) - 10.0; double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
677	System.out.println(x + "\t" + y + "\t" + tst + "\t" + ref + "\t" + errulp);
692	double x = (generator.nextDouble() * 20.0) - 10.0;
704	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
727	System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);
750	System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);
823	System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);
845	System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);
867	System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);
889	System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);
927	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
950	System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);
961	0x402fffffffffffff 0x404123456789abcd -> 4030000000000000
964	0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe
967	0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe
970	0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe
973	0x4020000000000000 0x404123456789abcd -> 4020000000000001
976	0xc020000000000000 0x404123456789abcd -> c01fffffffffffff
979	0x4020000000000000 0x400123456789abcd -> 401fffffffffffff
982	0xc020000000000000 0x400123456789abcd -> c01fffffffffffff
985	0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224
988	0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a223
991	0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222
994	0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222
997	0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222
1000	0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222
1003	0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222
1006	0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222
1009	0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222
1012	0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224
1015	0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a223
1018	0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222

Commons/xml/test/java/org/apache/commons/math3/util/FastMathTestPerformance.xml
39	Header format
41	Detail format

Commons/xml/test/java/org/apache/commons/math3/util/IncrementorTest.xml
59	Must keep try/catch because the exception must be generated here, and not in the previous loop.
65	Expected.

Commons/xml/test/java/org/apache/commons/math3/util/MathArraysTest.xml
46	Make sure test has not changed
51	Test scaled values
63	Make sure test has changed
185	Expected
192	Expected
199	Expected
206	Expected
213	Expected
305	Expected
311	Expected
327	Expected
333	Expected
349	Expected
355	Expected
371	Expected
377	Expected
435	expected
441	expected
447	expected
582	we compare accurate versus naive dot product implementations on regular vectors (i.e. not extreme cases like in the previous test)
805	Ignore NaNs
811	Zero sum -> MathArithmeticException
818	Infinite elements -> MathArithmeticException
825	Infinite target -> MathIllegalArgumentException
831	NaN target -> MathIllegalArgumentException

Commons/xml/test/java/org/apache/commons/math3/util/MathUtilsTest.xml
84	Generate 10 distinct random values
90	Generate a random permutation, making sure it is not the identity
102	Verify that permuted array has different hash
248	Expected
254	Expected
260	Expected
267	Expected
273	Expected
279	Expected
289	Expected.
299	Expected.

Commons/xml/test/java/org/apache/commons/math3/util/MultidimensionalCounterTest.xml
39	Expected.
45	Expected.
51	Expected.
59	Expected.
65	Expected.
71	Expected.
77	Expected.
83	Expected.
94	Expected.
100	Expected.

Commons/xml/test/java/org/apache/commons/math3/util/OpenIntToDoubleHashMapTest.xml
261	expected
274	expected

Commons/xml/test/java/org/apache/commons/math3/util/OpenIntToFieldTest.xml
270	expected
283	expected

Commons/xml/test/java/org/apache/commons/math3/util/PairTest.xml
38	Check that both APIs refer to the same data.
69	Same contents, same hash code.
72	Different contents, different hash codes.

Commons/xml/test/java/org/apache/commons/math3/util/PrecisionTest.xml
124	Tests for floating point equality
98	Because they are adjacent floating point numbers, "a" and "b" are considered equal even though the allowed error is smaller than their difference.
105	Because "a" and "c" are not adjacent, the tolerance is taken into account for assessing equality.
136	These tests need adjusting for floating point precision
137	Assert.assertTrue(Precision.equals(153.0f, 153.00000000000003f, 1)); Assert.assertFalse(Precision.equals(153.0f, 153.00000000000006f, 1)); Assert.assertTrue(Precision.equals(153.0f, 152.99999999999997f, 1)); Assert.assertFalse(Precision.equals(153f, 152.99999999999994f, 1));  Assert.assertTrue(Precision.equals(-128.0f, -127.99999999999999f, 1)); Assert.assertFalse(Precision.equals(-128.0f, -127.99999999999997f, 1)); Assert.assertTrue(Precision.equals(-128.0f, -128.00000000000003f, 1)); Assert.assertFalse(Precision.equals(-128.0f, -128.00000000000006f, 1));
297	JIRA MATH-151
304	BZ 35904
372	expected
386	expected
389	MATH-151
392	special values
406	BZ 35904
472	success
486	success
489	special values
525	a) 1 + EPSILON is equal to 1.
528	b) 1 + "the number after EPSILON" is not equal to 1.

Commons/xml/test/java/org/apache/commons/math3/util/ResizableDoubleArrayTest.xml
64	expected
85	expected
103	expected
119	expected
122	Copy constructor
136	MULTIPLICATIVE_MODE
142	Expand the array arbitrarily to 1000 items
159	Make sure numElements and expansion work correctly for expansion boundary cases
179	expected
182	ADDITIVE_MODE
207	MULTIPLICATIVE_MODE
217	ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)
221	x,0
222	x,x
223	x,x,x,0 -- expanded
227	x,x,x,0
236	MULTIPLICATIVE_MODE
252	ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)
256	x,0
257	x,x
258	x,x,x,0 -- expanded
262	x,x,x,0
268	0,x,x,x
270	0,0,x,x,x,0 -- time to contract
274	contracted -- x,x,x,0
280	expected
286	expected
451	greater than contractionCriteria
454	expected
464	expected
471	Wrong type
476	Null
480	Reflexive
483	Argumentless constructor
487	Equals iff same data, same properties
502	expand
515	discard
521	discard recent
526	wrong order
533	copy
537	Copy constructor
540	Instance copy
549	Modify "a" through the public API.
554	Modify the internal storage through the protected API.

Commons/xml/test/java/org/apache/commons/math3/util/TestBean.xml

Commons/xml/test/java/org/apache/commons/math3/util/TransformerMapTest.xml

Commons/xml/test/maxima/special/RealFunctionValidation/RealFunctionValidation.xml
267	This should never occur.

